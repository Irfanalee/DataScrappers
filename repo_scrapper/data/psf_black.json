{
  "repo": "psf/black",
  "scraped_at": "2026-02-03T14:02:35.361317",
  "stats": {
    "total_comments": 1543,
    "filtered": {
      "not_python": 484,
      "too_short": 281,
      "no_diff_hunk": 1,
      "skip_pattern:nit:": 4,
      "too_long": 1,
      "skip_pattern:thank you": 2
    },
    "kept": 770
  },
  "examples": [
    {
      "repo": "psf/black",
      "pr_number": 4489,
      "file_path": "src/black/lines.py",
      "line": 608,
      "side": "RIGHT",
      "diff_hunk": "@@ -605,7 +605,16 @@ def _maybe_empty_lines(self, current_line: Line) -> tuple[int, int]:  # noqa: C9\n             # Consume the first leaf's extra newlines.\n             first_leaf = current_line.leaves[0]\n             before = first_leaf.prefix.count(\"\\n\")\n-            before = min(before, max_allowed)\n+            before = (",
      "comment": "This change should be applied only to the preview style; you'll need to add a feature to the enum and use Mode here to decide whether to make the change. Look for other recent changes that changed the formatting style for examples.",
      "comment_id": 1803934265,
      "user": "JelleZijlstra",
      "created_at": "2024-10-17T00:12:55Z",
      "url": "https://github.com/psf/black/pull/4489#discussion_r1803934265"
    },
    {
      "repo": "psf/black",
      "pr_number": 4489,
      "file_path": "src/black/lines.py",
      "line": 608,
      "side": "RIGHT",
      "diff_hunk": "@@ -605,7 +605,16 @@ def _maybe_empty_lines(self, current_line: Line) -> tuple[int, int]:  # noqa: C9\n             # Consume the first leaf's extra newlines.\n             first_leaf = current_line.leaves[0]\n             before = first_leaf.prefix.count(\"\\n\")\n-            before = min(before, max_allowed)\n+            before = (",
      "comment": "Thanks!! after taking a look at some of the other PRs for preview styles I've added a new feature to the enum, docs, etc and added another condition here to make sure it's in the Mode. I updated the change log to have this change in the preview section as well. Based on the changes in the other PRs I believe I've updated everything necessary but please let me know if I'm missing anything else!",
      "comment_id": 1804030258,
      "user": "kastkeepitjumpinlikekangaroos",
      "created_at": "2024-10-17T02:44:39Z",
      "url": "https://github.com/psf/black/pull/4489#discussion_r1804030258"
    },
    {
      "repo": "psf/black",
      "pr_number": 4489,
      "file_path": "tests/data/cases/preview_import_line_collapse.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,13 @@\n+# flags: --preview",
      "comment": "Could you add some more test cases, e.g. a comment line right after the import? Not every test case needs to be in its own file.",
      "comment_id": 1805757796,
      "user": "JelleZijlstra",
      "created_at": "2024-10-18T02:43:37Z",
      "url": "https://github.com/psf/black/pull/4489#discussion_r1805757796"
    },
    {
      "repo": "psf/black",
      "pr_number": 4489,
      "file_path": "tests/data/cases/preview_import_line_collapse.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,13 @@\n+# flags: --preview",
      "comment": "sure thing! I added a few more test cases to this file and the other one, let me know if you think there should be any other test cases covered!",
      "comment_id": 1807107450,
      "user": "kastkeepitjumpinlikekangaroos",
      "created_at": "2024-10-18T23:42:58Z",
      "url": "https://github.com/psf/black/pull/4489#discussion_r1807107450"
    },
    {
      "repo": "psf/black",
      "pr_number": 4489,
      "file_path": "tests/data/cases/preview_import_line_collapse.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,13 @@\n+# flags: --preview",
      "comment": "also modified the logic to collapse to one line for comments as well since removing that condition didn't affect any existing test cases",
      "comment_id": 1807107969,
      "user": "kastkeepitjumpinlikekangaroos",
      "created_at": "2024-10-18T23:43:37Z",
      "url": "https://github.com/psf/black/pull/4489#discussion_r1807107969"
    },
    {
      "repo": "psf/black",
      "pr_number": 4930,
      "file_path": "src/black/concurrency.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,6 +89,11 @@ def reformat_many(\n     if sys.platform == \"win32\":\n         # Work around https://bugs.python.org/issue26903\n         workers = min(workers, 60)\n+    if getattr(sys, \"frozen\", False):\n+        # In frozen (PyInstaller) builds, avoid multiprocessing to prevent shutdown\n+        # errors when worker processes try to import modules after cleanup begins.",
      "comment": "The inline comment says \"avoid multiprocessing\", but this change specifically avoids using `ProcessPoolExecutor` (and `schedule_formatting()` can still create a `multiprocessing.Manager()` for `--diff/--color-diff`). Consider rewording to something more precise like avoiding spawning worker processes / avoiding `ProcessPoolExecutor`, and (optionally) broaden \"PyInstaller\" to \"frozen builds (e.g. PyInstaller)\" since `sys.frozen` isn\u2019t PyInstaller-specific.\n```suggestion\n        # In frozen builds (e.g. PyInstaller), avoid spawning worker processes (i.e.\n        # avoid using ProcessPoolExecutor) to prevent shutdown errors when workers\n        # try to import modules after cleanup begins.\n```",
      "comment_id": 2719370230,
      "user": "Copilot",
      "created_at": "2026-01-23T02:41:35Z",
      "url": "https://github.com/psf/black/pull/4930#discussion_r2719370230"
    },
    {
      "repo": "psf/black",
      "pr_number": 4930,
      "file_path": "src/black/concurrency.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,6 +89,11 @@ def reformat_many(\n     if sys.platform == \"win32\":\n         # Work around https://bugs.python.org/issue26903\n         workers = min(workers, 60)\n+    if getattr(sys, \"frozen\", False):\n+        # In frozen (PyInstaller) builds, avoid multiprocessing to prevent shutdown\n+        # errors when worker processes try to import modules after cleanup begins.\n+        # See https://github.com/psf/black/issues/4823\n+        workers = 1",
      "comment": "This new `sys.frozen` branch isn\u2019t covered by tests. Even without a real PyInstaller build, it should be possible to add a unit/CLI-level test that monkeypatches `sys.frozen = True` (and e.g. makes `ProcessPoolExecutor` raise or records instantiation) to assert we don\u2019t attempt to create a `ProcessPoolExecutor` when `workers > 1`. That would prevent regressions if this logic is refactored later.",
      "comment_id": 2719370237,
      "user": "Copilot",
      "created_at": "2026-01-23T02:41:36Z",
      "url": "https://github.com/psf/black/pull/4930#discussion_r2719370237"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/__init__.py",
      "line": 857,
      "side": "RIGHT",
      "diff_hunk": "@@ -825,6 +853,9 @@ def format_file_contents(src_contents: str, *, fast: bool, mode: Mode) -> FileCo\n     valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n     `mode` is passed to :func:`format_str`.\n     \"\"\"\n+    if mode.is_ipynb:\n+        return format_ipynb_string(src_contents, mode=mode)",
      "comment": "This means we're skipping the equivalent and stable checks below for notebooks.",
      "comment_id": 667261407,
      "user": "JelleZijlstra",
      "created_at": "2021-07-10T00:11:47Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667261407"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 135,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,388 @@\n+\"\"\"Functions to process IPython magics with.\"\"\"\n+import ast\n+import tokenize\n+import io\n+from typing import Dict\n+\n+import secrets\n+from typing import NamedTuple, List, Tuple\n+import collections\n+\n+from typing import Optional\n+\n+\n+class Replacement(NamedTuple):\n+    mask: str\n+    src: str\n+\n+\n+class UnsupportedMagic(UserWarning):\n+    \"\"\"Raise when Magic is not supported (e.g. `a = b??`)\"\"\"\n+\n+\n+def remove_trailing_semicolon(src: str) -> Tuple[str, bool]:\n+    \"\"\"Remove trailing semicolon from Jupyter notebook cell.\n+\n+    For example,\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data);  # plot data\n+\n+    would become\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data)  # plot data\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    trailing_semicolon = False\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        if token[0] == tokenize.OP and token[1] == \";\":\n+            # We're iterating backwards, so `-idx`.\n+            del tokens[-idx]\n+            trailing_semicolon = True\n+        break\n+    if not trailing_semicolon:\n+        return src, False\n+    return tokenize.untokenize(tokens), True\n+\n+\n+def put_trailing_semicolon_back(src: str, has_trailing_semicolon: bool) -> str:\n+    \"\"\"Put trailing semicolon back if cell originally had it.\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    if not has_trailing_semicolon:\n+        return src\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        # We're iterating backwards, so `-idx`.\n+        tokens[-idx] = token._replace(string=token.string + \";\")\n+        break\n+    else:  # pragma: nocover\n+        raise AssertionError(\"Unreachable code\")\n+    return str(tokenize.untokenize(tokens))\n+\n+\n+def mask_cell(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Mask IPython magics so content becomes parseable Python code.\n+\n+    For example,\n+\n+        %matplotlib inline\n+        'foo'\n+\n+    becomes\n+\n+        \"25716f358c32750e\"\n+        'foo'\n+\n+    The replacements are returned, along with the transformed code.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+    try:\n+        ast.parse(src)\n+    except SyntaxError:\n+        # Might have IPython magics, will process below.\n+        pass\n+    else:\n+        # Syntax is fine, nothing to mask, early return.\n+        return src, replacements\n+\n+    from IPython.core.inputtransformer2 import TransformerManager\n+\n+    transformer_manager = TransformerManager()\n+    transformed = transformer_manager.transform_cell(src)\n+    transformed, cell_magic_replacements = replace_cell_magics(transformed)\n+    replacements += cell_magic_replacements\n+    transformed = transformer_manager.transform_cell(transformed)\n+    try:\n+        transformed, magic_replacements = replace_magics(transformed)\n+    except UnsupportedMagic:\n+        raise SyntaxError\n+    if len(transformed.splitlines()) != len(src.splitlines()):  # multi-line magic\n+        raise SyntaxError\n+    replacements += magic_replacements\n+    return transformed, replacements\n+\n+\n+def get_token(src: str, magic: str) -> str:\n+    \"\"\"Return randomly generated token to mask IPython magic with.\n+\n+    For example, if 'magic' was `%matplotlib inline`, then a possible\n+    token to mask it with would be `\"43fdd17f7e5ddc83\"`. The token\n+    will be the same length as the magic, and we make sure that it was\n+    not already present anywhere else in the cell.\n+    \"\"\"\n+    assert magic\n+    nbytes = max(len(magic) // 2 - 1, 1)\n+    token = secrets.token_hex(nbytes)\n+    while token in src:  # pragma: nocover",
      "comment": "Can you make this throw an exception after say 100 iterations? Just so we don't go into an infinite loop if token_hex is badly broken.",
      "comment_id": 667261865,
      "user": "JelleZijlstra",
      "created_at": "2021-07-10T00:14:58Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667261865"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 275,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,388 @@\n+\"\"\"Functions to process IPython magics with.\"\"\"\n+import ast\n+import tokenize\n+import io\n+from typing import Dict\n+\n+import secrets\n+from typing import NamedTuple, List, Tuple\n+import collections\n+\n+from typing import Optional\n+\n+\n+class Replacement(NamedTuple):\n+    mask: str\n+    src: str\n+\n+\n+class UnsupportedMagic(UserWarning):\n+    \"\"\"Raise when Magic is not supported (e.g. `a = b??`)\"\"\"\n+\n+\n+def remove_trailing_semicolon(src: str) -> Tuple[str, bool]:\n+    \"\"\"Remove trailing semicolon from Jupyter notebook cell.\n+\n+    For example,\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data);  # plot data\n+\n+    would become\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data)  # plot data\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    trailing_semicolon = False\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        if token[0] == tokenize.OP and token[1] == \";\":\n+            # We're iterating backwards, so `-idx`.\n+            del tokens[-idx]\n+            trailing_semicolon = True\n+        break\n+    if not trailing_semicolon:\n+        return src, False\n+    return tokenize.untokenize(tokens), True\n+\n+\n+def put_trailing_semicolon_back(src: str, has_trailing_semicolon: bool) -> str:\n+    \"\"\"Put trailing semicolon back if cell originally had it.\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    if not has_trailing_semicolon:\n+        return src\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        # We're iterating backwards, so `-idx`.\n+        tokens[-idx] = token._replace(string=token.string + \";\")\n+        break\n+    else:  # pragma: nocover\n+        raise AssertionError(\"Unreachable code\")\n+    return str(tokenize.untokenize(tokens))\n+\n+\n+def mask_cell(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Mask IPython magics so content becomes parseable Python code.\n+\n+    For example,\n+\n+        %matplotlib inline\n+        'foo'\n+\n+    becomes\n+\n+        \"25716f358c32750e\"\n+        'foo'\n+\n+    The replacements are returned, along with the transformed code.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+    try:\n+        ast.parse(src)\n+    except SyntaxError:\n+        # Might have IPython magics, will process below.\n+        pass\n+    else:\n+        # Syntax is fine, nothing to mask, early return.\n+        return src, replacements\n+\n+    from IPython.core.inputtransformer2 import TransformerManager\n+\n+    transformer_manager = TransformerManager()\n+    transformed = transformer_manager.transform_cell(src)\n+    transformed, cell_magic_replacements = replace_cell_magics(transformed)\n+    replacements += cell_magic_replacements\n+    transformed = transformer_manager.transform_cell(transformed)\n+    try:\n+        transformed, magic_replacements = replace_magics(transformed)\n+    except UnsupportedMagic:\n+        raise SyntaxError\n+    if len(transformed.splitlines()) != len(src.splitlines()):  # multi-line magic\n+        raise SyntaxError\n+    replacements += magic_replacements\n+    return transformed, replacements\n+\n+\n+def get_token(src: str, magic: str) -> str:\n+    \"\"\"Return randomly generated token to mask IPython magic with.\n+\n+    For example, if 'magic' was `%matplotlib inline`, then a possible\n+    token to mask it with would be `\"43fdd17f7e5ddc83\"`. The token\n+    will be the same length as the magic, and we make sure that it was\n+    not already present anywhere else in the cell.\n+    \"\"\"\n+    assert magic\n+    nbytes = max(len(magic) // 2 - 1, 1)\n+    token = secrets.token_hex(nbytes)\n+    while token in src:  # pragma: nocover\n+        token = secrets.token_hex(nbytes)\n+    if len(token) + 2 < len(magic):\n+        token = f\"{token}.\"\n+    return f'\"{token}\"'\n+\n+\n+def replace_cell_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace cell magic with token.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example,\n+\n+        get_ipython().run_cell_magic('t', '-n1', 'ls =!ls\\\\n')\n+\n+    becomes\n+\n+        \"a794.\"\n+        ls =!ls\n+\n+    The replacement, along with the transformed code, is returned.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+\n+    tree = ast.parse(src)\n+\n+    cell_magic_finder = CellMagicFinder()\n+    cell_magic_finder.visit(tree)\n+    if not cell_magic_finder.header:\n+        return src, replacements\n+    mask = get_token(src, cell_magic_finder.header)\n+    replacements.append(Replacement(mask=mask, src=cell_magic_finder.header))\n+    return f\"{mask}\\n{cell_magic_finder.body}\", replacements\n+\n+\n+def replace_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace magics within body of cell.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example, this\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+        'foo'\n+\n+    becomes\n+\n+        \"5e67db56d490fd39\"\n+        'foo'\n+\n+    The replacement, along with the transformed code, are returned.\n+    \"\"\"\n+    replacements = []\n+    magic_finder = MagicFinder()\n+    magic_finder.visit(ast.parse(src))\n+    new_srcs = []\n+    for i, line in enumerate(src.splitlines(), start=1):\n+        if i in magic_finder.magics:\n+            magics = magic_finder.magics[i]\n+            if len(magics) != 1:  # pragma: nocover\n+                # defensive check\n+                raise UnsupportedMagic\n+            col_offset, magic = magics[0]\n+            mask = get_token(src, magic)\n+            replacements.append(Replacement(mask=mask, src=magic))\n+            line = line[:col_offset] + mask\n+        new_srcs.append(line)\n+    return \"\\n\".join(new_srcs), replacements\n+\n+\n+def unmask_cell(src: str, replacements: List[Replacement]) -> str:\n+    \"\"\"Remove replacements from cell.\n+\n+    For example\n+\n+        \"9b20\"\n+        foo = bar\n+\n+    becomes\n+\n+        %%time\n+        foo = bar\n+    \"\"\"\n+    for replacement in replacements:\n+        src = src.replace(replacement.mask, replacement.src)\n+    return src\n+\n+\n+def _is_ipython_magic(node: ast.expr) -> bool:\n+    \"\"\"Check if attribute is IPython magic.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+    \"\"\"\n+    return (\n+        isinstance(node, ast.Attribute)\n+        and isinstance(node.value, ast.Call)\n+        and isinstance(node.value.func, ast.Name)\n+        and node.value.func.id == \"get_ipython\"\n+    )\n+\n+\n+class CellMagicFinder(ast.NodeVisitor):\n+    \"\"\"Find cell magics.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %%time\\nfoo()\n+\n+    would have been transformed to\n+\n+        get_ipython().run_cell_magic('time', '', 'foo()\\\\n')\n+\n+    and we look for instances of the latter.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self.header: Optional[str] = None\n+        self.body: Optional[str] = None\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Find cell magic, extract header and body.\"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"run_cell_magic\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            header: Optional[str] = f\"%%{args[0]}\"",
      "comment": "Why do you need the annotation? The local variable is never None.",
      "comment_id": 667262222,
      "user": "JelleZijlstra",
      "created_at": "2021-07-10T00:17:25Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667262222"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 360,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,388 @@\n+\"\"\"Functions to process IPython magics with.\"\"\"\n+import ast\n+import tokenize\n+import io\n+from typing import Dict\n+\n+import secrets\n+from typing import NamedTuple, List, Tuple\n+import collections\n+\n+from typing import Optional\n+\n+\n+class Replacement(NamedTuple):\n+    mask: str\n+    src: str\n+\n+\n+class UnsupportedMagic(UserWarning):\n+    \"\"\"Raise when Magic is not supported (e.g. `a = b??`)\"\"\"\n+\n+\n+def remove_trailing_semicolon(src: str) -> Tuple[str, bool]:\n+    \"\"\"Remove trailing semicolon from Jupyter notebook cell.\n+\n+    For example,\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data);  # plot data\n+\n+    would become\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data)  # plot data\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    trailing_semicolon = False\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        if token[0] == tokenize.OP and token[1] == \";\":\n+            # We're iterating backwards, so `-idx`.\n+            del tokens[-idx]\n+            trailing_semicolon = True\n+        break\n+    if not trailing_semicolon:\n+        return src, False\n+    return tokenize.untokenize(tokens), True\n+\n+\n+def put_trailing_semicolon_back(src: str, has_trailing_semicolon: bool) -> str:\n+    \"\"\"Put trailing semicolon back if cell originally had it.\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    if not has_trailing_semicolon:\n+        return src\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        # We're iterating backwards, so `-idx`.\n+        tokens[-idx] = token._replace(string=token.string + \";\")\n+        break\n+    else:  # pragma: nocover\n+        raise AssertionError(\"Unreachable code\")\n+    return str(tokenize.untokenize(tokens))\n+\n+\n+def mask_cell(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Mask IPython magics so content becomes parseable Python code.\n+\n+    For example,\n+\n+        %matplotlib inline\n+        'foo'\n+\n+    becomes\n+\n+        \"25716f358c32750e\"\n+        'foo'\n+\n+    The replacements are returned, along with the transformed code.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+    try:\n+        ast.parse(src)\n+    except SyntaxError:\n+        # Might have IPython magics, will process below.\n+        pass\n+    else:\n+        # Syntax is fine, nothing to mask, early return.\n+        return src, replacements\n+\n+    from IPython.core.inputtransformer2 import TransformerManager\n+\n+    transformer_manager = TransformerManager()\n+    transformed = transformer_manager.transform_cell(src)\n+    transformed, cell_magic_replacements = replace_cell_magics(transformed)\n+    replacements += cell_magic_replacements\n+    transformed = transformer_manager.transform_cell(transformed)\n+    try:\n+        transformed, magic_replacements = replace_magics(transformed)\n+    except UnsupportedMagic:\n+        raise SyntaxError\n+    if len(transformed.splitlines()) != len(src.splitlines()):  # multi-line magic\n+        raise SyntaxError\n+    replacements += magic_replacements\n+    return transformed, replacements\n+\n+\n+def get_token(src: str, magic: str) -> str:\n+    \"\"\"Return randomly generated token to mask IPython magic with.\n+\n+    For example, if 'magic' was `%matplotlib inline`, then a possible\n+    token to mask it with would be `\"43fdd17f7e5ddc83\"`. The token\n+    will be the same length as the magic, and we make sure that it was\n+    not already present anywhere else in the cell.\n+    \"\"\"\n+    assert magic\n+    nbytes = max(len(magic) // 2 - 1, 1)\n+    token = secrets.token_hex(nbytes)\n+    while token in src:  # pragma: nocover\n+        token = secrets.token_hex(nbytes)\n+    if len(token) + 2 < len(magic):\n+        token = f\"{token}.\"\n+    return f'\"{token}\"'\n+\n+\n+def replace_cell_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace cell magic with token.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example,\n+\n+        get_ipython().run_cell_magic('t', '-n1', 'ls =!ls\\\\n')\n+\n+    becomes\n+\n+        \"a794.\"\n+        ls =!ls\n+\n+    The replacement, along with the transformed code, is returned.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+\n+    tree = ast.parse(src)\n+\n+    cell_magic_finder = CellMagicFinder()\n+    cell_magic_finder.visit(tree)\n+    if not cell_magic_finder.header:\n+        return src, replacements\n+    mask = get_token(src, cell_magic_finder.header)\n+    replacements.append(Replacement(mask=mask, src=cell_magic_finder.header))\n+    return f\"{mask}\\n{cell_magic_finder.body}\", replacements\n+\n+\n+def replace_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace magics within body of cell.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example, this\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+        'foo'\n+\n+    becomes\n+\n+        \"5e67db56d490fd39\"\n+        'foo'\n+\n+    The replacement, along with the transformed code, are returned.\n+    \"\"\"\n+    replacements = []\n+    magic_finder = MagicFinder()\n+    magic_finder.visit(ast.parse(src))\n+    new_srcs = []\n+    for i, line in enumerate(src.splitlines(), start=1):\n+        if i in magic_finder.magics:\n+            magics = magic_finder.magics[i]\n+            if len(magics) != 1:  # pragma: nocover\n+                # defensive check\n+                raise UnsupportedMagic\n+            col_offset, magic = magics[0]\n+            mask = get_token(src, magic)\n+            replacements.append(Replacement(mask=mask, src=magic))\n+            line = line[:col_offset] + mask\n+        new_srcs.append(line)\n+    return \"\\n\".join(new_srcs), replacements\n+\n+\n+def unmask_cell(src: str, replacements: List[Replacement]) -> str:\n+    \"\"\"Remove replacements from cell.\n+\n+    For example\n+\n+        \"9b20\"\n+        foo = bar\n+\n+    becomes\n+\n+        %%time\n+        foo = bar\n+    \"\"\"\n+    for replacement in replacements:\n+        src = src.replace(replacement.mask, replacement.src)\n+    return src\n+\n+\n+def _is_ipython_magic(node: ast.expr) -> bool:\n+    \"\"\"Check if attribute is IPython magic.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+    \"\"\"\n+    return (\n+        isinstance(node, ast.Attribute)\n+        and isinstance(node.value, ast.Call)\n+        and isinstance(node.value.func, ast.Name)\n+        and node.value.func.id == \"get_ipython\"\n+    )\n+\n+\n+class CellMagicFinder(ast.NodeVisitor):\n+    \"\"\"Find cell magics.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %%time\\nfoo()\n+\n+    would have been transformed to\n+\n+        get_ipython().run_cell_magic('time', '', 'foo()\\\\n')\n+\n+    and we look for instances of the latter.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self.header: Optional[str] = None\n+        self.body: Optional[str] = None\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Find cell magic, extract header and body.\"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"run_cell_magic\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            header: Optional[str] = f\"%%{args[0]}\"\n+            if args[1]:\n+                assert header is not None\n+                header += f\" {args[1]}\"\n+            self.header = header\n+            self.body = args[2]\n+        self.generic_visit(node)\n+\n+\n+class MagicFinder(ast.NodeVisitor):\n+    \"\"\"Visit cell to look for get_ipython calls.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %matplotlib inline\n+\n+    would have been transformed to\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+\n+    and we look for instances of the latter (and likewise for other\n+    types of magics).\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        \"\"\"Record where magics occur.\"\"\"\n+        self.magics: Dict[int, List[Tuple[int, str]]] = collections.defaultdict(list)\n+\n+    def visit_Assign(self, node: ast.Assign) -> None:\n+        \"\"\"Look for system assign magics.\n+\n+        For example,\n+\n+            black_version = !black --version\n+\n+        would have been transformed to\n+\n+            black_version = get_ipython().getoutput('black --version')\n+\n+        and we look for instances of the latter.\n+        \"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"getoutput\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            assert args\n+            src = f\"!{args[0]}\"\n+            self.magics[node.value.lineno].append(\n+                (\n+                    node.value.col_offset,\n+                    src,\n+                )\n+            )\n+        self.generic_visit(node)\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Look for magics in body of cell.\n+\n+        For examples,\n+\n+            !ls\n+            !!ls\n+            ?ls\n+            ??ls\n+\n+        would (respectively) get transformed to\n+\n+            get_ipython().system('ls')\n+            get_ipython().getoutput('ls')\n+            get_ipython().run_line_magic('pinfo', 'ls')\n+            get_ipython().run_line_magic('pinfo2', 'ls')\n+\n+        and we look for instances of any of the latter.\n+        \"\"\"\n+        if isinstance(node.value, ast.Call) and _is_ipython_magic(node.value.func):\n+            assert isinstance(node.value.func, ast.Attribute)  # help mypy",
      "comment": "Using a PEP 647 TypeGuard should make this unnecessary. Mypy doesn't support that very well yet though, so no worries if you're not interested.",
      "comment_id": 667262491,
      "user": "JelleZijlstra",
      "created_at": "2021-07-10T00:19:46Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667262491"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "tests/test_ipynb.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+from black import NothingChanged, format_cell, format_ipynb_string\n+import os\n+from tests.util import DEFAULT_MODE\n+import pytest\n+import subprocess\n+\n+pytestmark = pytest.mark.jupyter\n+\n+\n+def test_noop() -> None:\n+    src = 'foo = \"a\"'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, mode=DEFAULT_MODE)\n+\n+\n+def test_trailing_semicolon() -> None:\n+    src = 'foo = \"a\" ;'\n+    result = format_cell(src, mode=DEFAULT_MODE)\n+    expected = 'foo = \"a\";'\n+    assert result == expected\n+\n+\n+def test_trailing_semicolon_with_comment() -> None:\n+    src = 'foo = \"a\" ;  # bar'\n+    result = format_cell(src, mode=DEFAULT_MODE)\n+    expected = 'foo = \"a\";  # bar'\n+    assert result == expected\n+\n+\n+def test_trailing_semicolon_noop() -> None:\n+    src = 'foo = \"a\";'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, mode=DEFAULT_MODE)\n+\n+\n+def test_cell_magic() -> None:\n+    src = \"%%time\\nfoo =bar\"\n+    result = format_cell(src, mode=DEFAULT_MODE)\n+    expected = \"%%time\\nfoo = bar\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_noop() -> None:\n+    src = \"%%time\\n2 + 2\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, mode=DEFAULT_MODE)\n+\n+\n+@pytest.mark.parametrize(\n+    \"src, expected\",\n+    (\n+        pytest.param(\"ls =!ls\", \"ls = !ls\", id=\"System assignment\"),",
      "comment": "What if the input already contains `get_ipython().system` or similar? The output should still be `get_ipython().system`, not something transformed back into magics.",
      "comment_id": 667262868,
      "user": "JelleZijlstra",
      "created_at": "2021-07-10T00:22:11Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667262868"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "tests/test_ipynb.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,286 @@\n+from black import NothingChanged, format_cell, format_ipynb_string\n+import os\n+from tests.util import DEFAULT_MODE\n+import pytest\n+import subprocess\n+\n+pytestmark = pytest.mark.jupyter\n+\n+\n+def test_noop() -> None:\n+    src = 'foo = \"a\"'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, mode=DEFAULT_MODE)\n+\n+\n+def test_trailing_semicolon() -> None:\n+    src = 'foo = \"a\" ;'\n+    result = format_cell(src, mode=DEFAULT_MODE)\n+    expected = 'foo = \"a\";'\n+    assert result == expected\n+\n+\n+def test_trailing_semicolon_with_comment() -> None:\n+    src = 'foo = \"a\" ;  # bar'\n+    result = format_cell(src, mode=DEFAULT_MODE)\n+    expected = 'foo = \"a\";  # bar'\n+    assert result == expected\n+\n+\n+def test_trailing_semicolon_noop() -> None:\n+    src = 'foo = \"a\";'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, mode=DEFAULT_MODE)\n+\n+\n+def test_cell_magic() -> None:\n+    src = \"%%time\\nfoo =bar\"\n+    result = format_cell(src, mode=DEFAULT_MODE)\n+    expected = \"%%time\\nfoo = bar\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_noop() -> None:\n+    src = \"%%time\\n2 + 2\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, mode=DEFAULT_MODE)\n+\n+\n+@pytest.mark.parametrize(\n+    \"src, expected\",\n+    (\n+        pytest.param(\"ls =!ls\", \"ls = !ls\", id=\"System assignment\"),",
      "comment": "That's an excellent point, thanks - looks like they can't be distinguished after `TransformerManager` has transformed the cell:\r\n```\r\n>>> TransformerManager().transform_cell(\"get_ipython().system('ls')\")\r\n\"get_ipython().system('ls')\\n\"\r\n>>> TransformerManager().transform_cell(\"!ls\")\r\n\"get_ipython().system('ls')\\n\"\r\n```\r\n\r\nThe only solution I can think of is ignore cells which contain these transformed magics",
      "comment_id": 667326644,
      "user": "MarcoGorelli",
      "created_at": "2021-07-10T11:15:57Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667326644"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 360,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,388 @@\n+\"\"\"Functions to process IPython magics with.\"\"\"\n+import ast\n+import tokenize\n+import io\n+from typing import Dict\n+\n+import secrets\n+from typing import NamedTuple, List, Tuple\n+import collections\n+\n+from typing import Optional\n+\n+\n+class Replacement(NamedTuple):\n+    mask: str\n+    src: str\n+\n+\n+class UnsupportedMagic(UserWarning):\n+    \"\"\"Raise when Magic is not supported (e.g. `a = b??`)\"\"\"\n+\n+\n+def remove_trailing_semicolon(src: str) -> Tuple[str, bool]:\n+    \"\"\"Remove trailing semicolon from Jupyter notebook cell.\n+\n+    For example,\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data);  # plot data\n+\n+    would become\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data)  # plot data\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    trailing_semicolon = False\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        if token[0] == tokenize.OP and token[1] == \";\":\n+            # We're iterating backwards, so `-idx`.\n+            del tokens[-idx]\n+            trailing_semicolon = True\n+        break\n+    if not trailing_semicolon:\n+        return src, False\n+    return tokenize.untokenize(tokens), True\n+\n+\n+def put_trailing_semicolon_back(src: str, has_trailing_semicolon: bool) -> str:\n+    \"\"\"Put trailing semicolon back if cell originally had it.\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    if not has_trailing_semicolon:\n+        return src\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        # We're iterating backwards, so `-idx`.\n+        tokens[-idx] = token._replace(string=token.string + \";\")\n+        break\n+    else:  # pragma: nocover\n+        raise AssertionError(\"Unreachable code\")\n+    return str(tokenize.untokenize(tokens))\n+\n+\n+def mask_cell(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Mask IPython magics so content becomes parseable Python code.\n+\n+    For example,\n+\n+        %matplotlib inline\n+        'foo'\n+\n+    becomes\n+\n+        \"25716f358c32750e\"\n+        'foo'\n+\n+    The replacements are returned, along with the transformed code.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+    try:\n+        ast.parse(src)\n+    except SyntaxError:\n+        # Might have IPython magics, will process below.\n+        pass\n+    else:\n+        # Syntax is fine, nothing to mask, early return.\n+        return src, replacements\n+\n+    from IPython.core.inputtransformer2 import TransformerManager\n+\n+    transformer_manager = TransformerManager()\n+    transformed = transformer_manager.transform_cell(src)\n+    transformed, cell_magic_replacements = replace_cell_magics(transformed)\n+    replacements += cell_magic_replacements\n+    transformed = transformer_manager.transform_cell(transformed)\n+    try:\n+        transformed, magic_replacements = replace_magics(transformed)\n+    except UnsupportedMagic:\n+        raise SyntaxError\n+    if len(transformed.splitlines()) != len(src.splitlines()):  # multi-line magic\n+        raise SyntaxError\n+    replacements += magic_replacements\n+    return transformed, replacements\n+\n+\n+def get_token(src: str, magic: str) -> str:\n+    \"\"\"Return randomly generated token to mask IPython magic with.\n+\n+    For example, if 'magic' was `%matplotlib inline`, then a possible\n+    token to mask it with would be `\"43fdd17f7e5ddc83\"`. The token\n+    will be the same length as the magic, and we make sure that it was\n+    not already present anywhere else in the cell.\n+    \"\"\"\n+    assert magic\n+    nbytes = max(len(magic) // 2 - 1, 1)\n+    token = secrets.token_hex(nbytes)\n+    while token in src:  # pragma: nocover\n+        token = secrets.token_hex(nbytes)\n+    if len(token) + 2 < len(magic):\n+        token = f\"{token}.\"\n+    return f'\"{token}\"'\n+\n+\n+def replace_cell_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace cell magic with token.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example,\n+\n+        get_ipython().run_cell_magic('t', '-n1', 'ls =!ls\\\\n')\n+\n+    becomes\n+\n+        \"a794.\"\n+        ls =!ls\n+\n+    The replacement, along with the transformed code, is returned.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+\n+    tree = ast.parse(src)\n+\n+    cell_magic_finder = CellMagicFinder()\n+    cell_magic_finder.visit(tree)\n+    if not cell_magic_finder.header:\n+        return src, replacements\n+    mask = get_token(src, cell_magic_finder.header)\n+    replacements.append(Replacement(mask=mask, src=cell_magic_finder.header))\n+    return f\"{mask}\\n{cell_magic_finder.body}\", replacements\n+\n+\n+def replace_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace magics within body of cell.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example, this\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+        'foo'\n+\n+    becomes\n+\n+        \"5e67db56d490fd39\"\n+        'foo'\n+\n+    The replacement, along with the transformed code, are returned.\n+    \"\"\"\n+    replacements = []\n+    magic_finder = MagicFinder()\n+    magic_finder.visit(ast.parse(src))\n+    new_srcs = []\n+    for i, line in enumerate(src.splitlines(), start=1):\n+        if i in magic_finder.magics:\n+            magics = magic_finder.magics[i]\n+            if len(magics) != 1:  # pragma: nocover\n+                # defensive check\n+                raise UnsupportedMagic\n+            col_offset, magic = magics[0]\n+            mask = get_token(src, magic)\n+            replacements.append(Replacement(mask=mask, src=magic))\n+            line = line[:col_offset] + mask\n+        new_srcs.append(line)\n+    return \"\\n\".join(new_srcs), replacements\n+\n+\n+def unmask_cell(src: str, replacements: List[Replacement]) -> str:\n+    \"\"\"Remove replacements from cell.\n+\n+    For example\n+\n+        \"9b20\"\n+        foo = bar\n+\n+    becomes\n+\n+        %%time\n+        foo = bar\n+    \"\"\"\n+    for replacement in replacements:\n+        src = src.replace(replacement.mask, replacement.src)\n+    return src\n+\n+\n+def _is_ipython_magic(node: ast.expr) -> bool:\n+    \"\"\"Check if attribute is IPython magic.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+    \"\"\"\n+    return (\n+        isinstance(node, ast.Attribute)\n+        and isinstance(node.value, ast.Call)\n+        and isinstance(node.value.func, ast.Name)\n+        and node.value.func.id == \"get_ipython\"\n+    )\n+\n+\n+class CellMagicFinder(ast.NodeVisitor):\n+    \"\"\"Find cell magics.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %%time\\nfoo()\n+\n+    would have been transformed to\n+\n+        get_ipython().run_cell_magic('time', '', 'foo()\\\\n')\n+\n+    and we look for instances of the latter.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self.header: Optional[str] = None\n+        self.body: Optional[str] = None\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Find cell magic, extract header and body.\"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"run_cell_magic\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            header: Optional[str] = f\"%%{args[0]}\"\n+            if args[1]:\n+                assert header is not None\n+                header += f\" {args[1]}\"\n+            self.header = header\n+            self.body = args[2]\n+        self.generic_visit(node)\n+\n+\n+class MagicFinder(ast.NodeVisitor):\n+    \"\"\"Visit cell to look for get_ipython calls.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %matplotlib inline\n+\n+    would have been transformed to\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+\n+    and we look for instances of the latter (and likewise for other\n+    types of magics).\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        \"\"\"Record where magics occur.\"\"\"\n+        self.magics: Dict[int, List[Tuple[int, str]]] = collections.defaultdict(list)\n+\n+    def visit_Assign(self, node: ast.Assign) -> None:\n+        \"\"\"Look for system assign magics.\n+\n+        For example,\n+\n+            black_version = !black --version\n+\n+        would have been transformed to\n+\n+            black_version = get_ipython().getoutput('black --version')\n+\n+        and we look for instances of the latter.\n+        \"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"getoutput\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            assert args\n+            src = f\"!{args[0]}\"\n+            self.magics[node.value.lineno].append(\n+                (\n+                    node.value.col_offset,\n+                    src,\n+                )\n+            )\n+        self.generic_visit(node)\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Look for magics in body of cell.\n+\n+        For examples,\n+\n+            !ls\n+            !!ls\n+            ?ls\n+            ??ls\n+\n+        would (respectively) get transformed to\n+\n+            get_ipython().system('ls')\n+            get_ipython().getoutput('ls')\n+            get_ipython().run_line_magic('pinfo', 'ls')\n+            get_ipython().run_line_magic('pinfo2', 'ls')\n+\n+        and we look for instances of any of the latter.\n+        \"\"\"\n+        if isinstance(node.value, ast.Call) and _is_ipython_magic(node.value.func):\n+            assert isinstance(node.value.func, ast.Attribute)  # help mypy",
      "comment": "That's awesome, thanks!\r\n\r\nWould this require typing_extensions as a runtime dependency before Python 3.10?",
      "comment_id": 667326744,
      "user": "MarcoGorelli",
      "created_at": "2021-07-10T11:16:43Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667326744"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/__init__.py",
      "line": 857,
      "side": "RIGHT",
      "diff_hunk": "@@ -825,6 +853,9 @@ def format_file_contents(src_contents: str, *, fast: bool, mode: Mode) -> FileCo\n     valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.\n     `mode` is passed to :func:`format_str`.\n     \"\"\"\n+    if mode.is_ipynb:\n+        return format_ipynb_string(src_contents, mode=mode)",
      "comment": "Yes, you're right thanks. I've changed it so that, unless `--fast` is passed, the checks will be performed on a cell-by-cell basis, but after the cells have been masked (I don't see how to do it with the raw cells because they might not be parseable by `ast.parse` if they contain magics)",
      "comment_id": 667326962,
      "user": "MarcoGorelli",
      "created_at": "2021-07-10T11:19:19Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667326962"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 360,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,388 @@\n+\"\"\"Functions to process IPython magics with.\"\"\"\n+import ast\n+import tokenize\n+import io\n+from typing import Dict\n+\n+import secrets\n+from typing import NamedTuple, List, Tuple\n+import collections\n+\n+from typing import Optional\n+\n+\n+class Replacement(NamedTuple):\n+    mask: str\n+    src: str\n+\n+\n+class UnsupportedMagic(UserWarning):\n+    \"\"\"Raise when Magic is not supported (e.g. `a = b??`)\"\"\"\n+\n+\n+def remove_trailing_semicolon(src: str) -> Tuple[str, bool]:\n+    \"\"\"Remove trailing semicolon from Jupyter notebook cell.\n+\n+    For example,\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data);  # plot data\n+\n+    would become\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data)  # plot data\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    trailing_semicolon = False\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        if token[0] == tokenize.OP and token[1] == \";\":\n+            # We're iterating backwards, so `-idx`.\n+            del tokens[-idx]\n+            trailing_semicolon = True\n+        break\n+    if not trailing_semicolon:\n+        return src, False\n+    return tokenize.untokenize(tokens), True\n+\n+\n+def put_trailing_semicolon_back(src: str, has_trailing_semicolon: bool) -> str:\n+    \"\"\"Put trailing semicolon back if cell originally had it.\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    if not has_trailing_semicolon:\n+        return src\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        # We're iterating backwards, so `-idx`.\n+        tokens[-idx] = token._replace(string=token.string + \";\")\n+        break\n+    else:  # pragma: nocover\n+        raise AssertionError(\"Unreachable code\")\n+    return str(tokenize.untokenize(tokens))\n+\n+\n+def mask_cell(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Mask IPython magics so content becomes parseable Python code.\n+\n+    For example,\n+\n+        %matplotlib inline\n+        'foo'\n+\n+    becomes\n+\n+        \"25716f358c32750e\"\n+        'foo'\n+\n+    The replacements are returned, along with the transformed code.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+    try:\n+        ast.parse(src)\n+    except SyntaxError:\n+        # Might have IPython magics, will process below.\n+        pass\n+    else:\n+        # Syntax is fine, nothing to mask, early return.\n+        return src, replacements\n+\n+    from IPython.core.inputtransformer2 import TransformerManager\n+\n+    transformer_manager = TransformerManager()\n+    transformed = transformer_manager.transform_cell(src)\n+    transformed, cell_magic_replacements = replace_cell_magics(transformed)\n+    replacements += cell_magic_replacements\n+    transformed = transformer_manager.transform_cell(transformed)\n+    try:\n+        transformed, magic_replacements = replace_magics(transformed)\n+    except UnsupportedMagic:\n+        raise SyntaxError\n+    if len(transformed.splitlines()) != len(src.splitlines()):  # multi-line magic\n+        raise SyntaxError\n+    replacements += magic_replacements\n+    return transformed, replacements\n+\n+\n+def get_token(src: str, magic: str) -> str:\n+    \"\"\"Return randomly generated token to mask IPython magic with.\n+\n+    For example, if 'magic' was `%matplotlib inline`, then a possible\n+    token to mask it with would be `\"43fdd17f7e5ddc83\"`. The token\n+    will be the same length as the magic, and we make sure that it was\n+    not already present anywhere else in the cell.\n+    \"\"\"\n+    assert magic\n+    nbytes = max(len(magic) // 2 - 1, 1)\n+    token = secrets.token_hex(nbytes)\n+    while token in src:  # pragma: nocover\n+        token = secrets.token_hex(nbytes)\n+    if len(token) + 2 < len(magic):\n+        token = f\"{token}.\"\n+    return f'\"{token}\"'\n+\n+\n+def replace_cell_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace cell magic with token.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example,\n+\n+        get_ipython().run_cell_magic('t', '-n1', 'ls =!ls\\\\n')\n+\n+    becomes\n+\n+        \"a794.\"\n+        ls =!ls\n+\n+    The replacement, along with the transformed code, is returned.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+\n+    tree = ast.parse(src)\n+\n+    cell_magic_finder = CellMagicFinder()\n+    cell_magic_finder.visit(tree)\n+    if not cell_magic_finder.header:\n+        return src, replacements\n+    mask = get_token(src, cell_magic_finder.header)\n+    replacements.append(Replacement(mask=mask, src=cell_magic_finder.header))\n+    return f\"{mask}\\n{cell_magic_finder.body}\", replacements\n+\n+\n+def replace_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace magics within body of cell.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example, this\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+        'foo'\n+\n+    becomes\n+\n+        \"5e67db56d490fd39\"\n+        'foo'\n+\n+    The replacement, along with the transformed code, are returned.\n+    \"\"\"\n+    replacements = []\n+    magic_finder = MagicFinder()\n+    magic_finder.visit(ast.parse(src))\n+    new_srcs = []\n+    for i, line in enumerate(src.splitlines(), start=1):\n+        if i in magic_finder.magics:\n+            magics = magic_finder.magics[i]\n+            if len(magics) != 1:  # pragma: nocover\n+                # defensive check\n+                raise UnsupportedMagic\n+            col_offset, magic = magics[0]\n+            mask = get_token(src, magic)\n+            replacements.append(Replacement(mask=mask, src=magic))\n+            line = line[:col_offset] + mask\n+        new_srcs.append(line)\n+    return \"\\n\".join(new_srcs), replacements\n+\n+\n+def unmask_cell(src: str, replacements: List[Replacement]) -> str:\n+    \"\"\"Remove replacements from cell.\n+\n+    For example\n+\n+        \"9b20\"\n+        foo = bar\n+\n+    becomes\n+\n+        %%time\n+        foo = bar\n+    \"\"\"\n+    for replacement in replacements:\n+        src = src.replace(replacement.mask, replacement.src)\n+    return src\n+\n+\n+def _is_ipython_magic(node: ast.expr) -> bool:\n+    \"\"\"Check if attribute is IPython magic.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+    \"\"\"\n+    return (\n+        isinstance(node, ast.Attribute)\n+        and isinstance(node.value, ast.Call)\n+        and isinstance(node.value.func, ast.Name)\n+        and node.value.func.id == \"get_ipython\"\n+    )\n+\n+\n+class CellMagicFinder(ast.NodeVisitor):\n+    \"\"\"Find cell magics.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %%time\\nfoo()\n+\n+    would have been transformed to\n+\n+        get_ipython().run_cell_magic('time', '', 'foo()\\\\n')\n+\n+    and we look for instances of the latter.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self.header: Optional[str] = None\n+        self.body: Optional[str] = None\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Find cell magic, extract header and body.\"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"run_cell_magic\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            header: Optional[str] = f\"%%{args[0]}\"\n+            if args[1]:\n+                assert header is not None\n+                header += f\" {args[1]}\"\n+            self.header = header\n+            self.body = args[2]\n+        self.generic_visit(node)\n+\n+\n+class MagicFinder(ast.NodeVisitor):\n+    \"\"\"Visit cell to look for get_ipython calls.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %matplotlib inline\n+\n+    would have been transformed to\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+\n+    and we look for instances of the latter (and likewise for other\n+    types of magics).\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        \"\"\"Record where magics occur.\"\"\"\n+        self.magics: Dict[int, List[Tuple[int, str]]] = collections.defaultdict(list)\n+\n+    def visit_Assign(self, node: ast.Assign) -> None:\n+        \"\"\"Look for system assign magics.\n+\n+        For example,\n+\n+            black_version = !black --version\n+\n+        would have been transformed to\n+\n+            black_version = get_ipython().getoutput('black --version')\n+\n+        and we look for instances of the latter.\n+        \"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"getoutput\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            assert args\n+            src = f\"!{args[0]}\"\n+            self.magics[node.value.lineno].append(\n+                (\n+                    node.value.col_offset,\n+                    src,\n+                )\n+            )\n+        self.generic_visit(node)\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Look for magics in body of cell.\n+\n+        For examples,\n+\n+            !ls\n+            !!ls\n+            ?ls\n+            ??ls\n+\n+        would (respectively) get transformed to\n+\n+            get_ipython().system('ls')\n+            get_ipython().getoutput('ls')\n+            get_ipython().run_line_magic('pinfo', 'ls')\n+            get_ipython().run_line_magic('pinfo2', 'ls')\n+\n+        and we look for instances of any of the latter.\n+        \"\"\"\n+        if isinstance(node.value, ast.Call) and _is_ipython_magic(node.value.func):\n+            assert isinstance(node.value.func, ast.Attribute)  # help mypy",
      "comment": "We already require typing_extensions for `Final` < Python 3.8 so don't worry :)",
      "comment_id": 667363325,
      "user": "ichard26",
      "created_at": "2021-07-10T17:18:46Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667363325"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 360,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,388 @@\n+\"\"\"Functions to process IPython magics with.\"\"\"\n+import ast\n+import tokenize\n+import io\n+from typing import Dict\n+\n+import secrets\n+from typing import NamedTuple, List, Tuple\n+import collections\n+\n+from typing import Optional\n+\n+\n+class Replacement(NamedTuple):\n+    mask: str\n+    src: str\n+\n+\n+class UnsupportedMagic(UserWarning):\n+    \"\"\"Raise when Magic is not supported (e.g. `a = b??`)\"\"\"\n+\n+\n+def remove_trailing_semicolon(src: str) -> Tuple[str, bool]:\n+    \"\"\"Remove trailing semicolon from Jupyter notebook cell.\n+\n+    For example,\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data);  # plot data\n+\n+    would become\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data)  # plot data\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    trailing_semicolon = False\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        if token[0] == tokenize.OP and token[1] == \";\":\n+            # We're iterating backwards, so `-idx`.\n+            del tokens[-idx]\n+            trailing_semicolon = True\n+        break\n+    if not trailing_semicolon:\n+        return src, False\n+    return tokenize.untokenize(tokens), True\n+\n+\n+def put_trailing_semicolon_back(src: str, has_trailing_semicolon: bool) -> str:\n+    \"\"\"Put trailing semicolon back if cell originally had it.\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    if not has_trailing_semicolon:\n+        return src\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        # We're iterating backwards, so `-idx`.\n+        tokens[-idx] = token._replace(string=token.string + \";\")\n+        break\n+    else:  # pragma: nocover\n+        raise AssertionError(\"Unreachable code\")\n+    return str(tokenize.untokenize(tokens))\n+\n+\n+def mask_cell(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Mask IPython magics so content becomes parseable Python code.\n+\n+    For example,\n+\n+        %matplotlib inline\n+        'foo'\n+\n+    becomes\n+\n+        \"25716f358c32750e\"\n+        'foo'\n+\n+    The replacements are returned, along with the transformed code.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+    try:\n+        ast.parse(src)\n+    except SyntaxError:\n+        # Might have IPython magics, will process below.\n+        pass\n+    else:\n+        # Syntax is fine, nothing to mask, early return.\n+        return src, replacements\n+\n+    from IPython.core.inputtransformer2 import TransformerManager\n+\n+    transformer_manager = TransformerManager()\n+    transformed = transformer_manager.transform_cell(src)\n+    transformed, cell_magic_replacements = replace_cell_magics(transformed)\n+    replacements += cell_magic_replacements\n+    transformed = transformer_manager.transform_cell(transformed)\n+    try:\n+        transformed, magic_replacements = replace_magics(transformed)\n+    except UnsupportedMagic:\n+        raise SyntaxError\n+    if len(transformed.splitlines()) != len(src.splitlines()):  # multi-line magic\n+        raise SyntaxError\n+    replacements += magic_replacements\n+    return transformed, replacements\n+\n+\n+def get_token(src: str, magic: str) -> str:\n+    \"\"\"Return randomly generated token to mask IPython magic with.\n+\n+    For example, if 'magic' was `%matplotlib inline`, then a possible\n+    token to mask it with would be `\"43fdd17f7e5ddc83\"`. The token\n+    will be the same length as the magic, and we make sure that it was\n+    not already present anywhere else in the cell.\n+    \"\"\"\n+    assert magic\n+    nbytes = max(len(magic) // 2 - 1, 1)\n+    token = secrets.token_hex(nbytes)\n+    while token in src:  # pragma: nocover\n+        token = secrets.token_hex(nbytes)\n+    if len(token) + 2 < len(magic):\n+        token = f\"{token}.\"\n+    return f'\"{token}\"'\n+\n+\n+def replace_cell_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace cell magic with token.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example,\n+\n+        get_ipython().run_cell_magic('t', '-n1', 'ls =!ls\\\\n')\n+\n+    becomes\n+\n+        \"a794.\"\n+        ls =!ls\n+\n+    The replacement, along with the transformed code, is returned.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+\n+    tree = ast.parse(src)\n+\n+    cell_magic_finder = CellMagicFinder()\n+    cell_magic_finder.visit(tree)\n+    if not cell_magic_finder.header:\n+        return src, replacements\n+    mask = get_token(src, cell_magic_finder.header)\n+    replacements.append(Replacement(mask=mask, src=cell_magic_finder.header))\n+    return f\"{mask}\\n{cell_magic_finder.body}\", replacements\n+\n+\n+def replace_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace magics within body of cell.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example, this\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+        'foo'\n+\n+    becomes\n+\n+        \"5e67db56d490fd39\"\n+        'foo'\n+\n+    The replacement, along with the transformed code, are returned.\n+    \"\"\"\n+    replacements = []\n+    magic_finder = MagicFinder()\n+    magic_finder.visit(ast.parse(src))\n+    new_srcs = []\n+    for i, line in enumerate(src.splitlines(), start=1):\n+        if i in magic_finder.magics:\n+            magics = magic_finder.magics[i]\n+            if len(magics) != 1:  # pragma: nocover\n+                # defensive check\n+                raise UnsupportedMagic\n+            col_offset, magic = magics[0]\n+            mask = get_token(src, magic)\n+            replacements.append(Replacement(mask=mask, src=magic))\n+            line = line[:col_offset] + mask\n+        new_srcs.append(line)\n+    return \"\\n\".join(new_srcs), replacements\n+\n+\n+def unmask_cell(src: str, replacements: List[Replacement]) -> str:\n+    \"\"\"Remove replacements from cell.\n+\n+    For example\n+\n+        \"9b20\"\n+        foo = bar\n+\n+    becomes\n+\n+        %%time\n+        foo = bar\n+    \"\"\"\n+    for replacement in replacements:\n+        src = src.replace(replacement.mask, replacement.src)\n+    return src\n+\n+\n+def _is_ipython_magic(node: ast.expr) -> bool:\n+    \"\"\"Check if attribute is IPython magic.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+    \"\"\"\n+    return (\n+        isinstance(node, ast.Attribute)\n+        and isinstance(node.value, ast.Call)\n+        and isinstance(node.value.func, ast.Name)\n+        and node.value.func.id == \"get_ipython\"\n+    )\n+\n+\n+class CellMagicFinder(ast.NodeVisitor):\n+    \"\"\"Find cell magics.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %%time\\nfoo()\n+\n+    would have been transformed to\n+\n+        get_ipython().run_cell_magic('time', '', 'foo()\\\\n')\n+\n+    and we look for instances of the latter.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self.header: Optional[str] = None\n+        self.body: Optional[str] = None\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Find cell magic, extract header and body.\"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"run_cell_magic\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            header: Optional[str] = f\"%%{args[0]}\"\n+            if args[1]:\n+                assert header is not None\n+                header += f\" {args[1]}\"\n+            self.header = header\n+            self.body = args[2]\n+        self.generic_visit(node)\n+\n+\n+class MagicFinder(ast.NodeVisitor):\n+    \"\"\"Visit cell to look for get_ipython calls.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %matplotlib inline\n+\n+    would have been transformed to\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+\n+    and we look for instances of the latter (and likewise for other\n+    types of magics).\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        \"\"\"Record where magics occur.\"\"\"\n+        self.magics: Dict[int, List[Tuple[int, str]]] = collections.defaultdict(list)\n+\n+    def visit_Assign(self, node: ast.Assign) -> None:\n+        \"\"\"Look for system assign magics.\n+\n+        For example,\n+\n+            black_version = !black --version\n+\n+        would have been transformed to\n+\n+            black_version = get_ipython().getoutput('black --version')\n+\n+        and we look for instances of the latter.\n+        \"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"getoutput\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            assert args\n+            src = f\"!{args[0]}\"\n+            self.magics[node.value.lineno].append(\n+                (\n+                    node.value.col_offset,\n+                    src,\n+                )\n+            )\n+        self.generic_visit(node)\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Look for magics in body of cell.\n+\n+        For examples,\n+\n+            !ls\n+            !!ls\n+            ?ls\n+            ??ls\n+\n+        would (respectively) get transformed to\n+\n+            get_ipython().system('ls')\n+            get_ipython().getoutput('ls')\n+            get_ipython().run_line_magic('pinfo', 'ls')\n+            get_ipython().run_line_magic('pinfo2', 'ls')\n+\n+        and we look for instances of any of the latter.\n+        \"\"\"\n+        if isinstance(node.value, ast.Call) and _is_ipython_magic(node.value.func):\n+            assert isinstance(node.value.func, ast.Attribute)  # help mypy",
      "comment": "Cool, done - TypeGuard's really neat, it's been worth it trying to contribute to `black` even if just to learn about TypeGuard's existence!",
      "comment_id": 667366126,
      "user": "MarcoGorelli",
      "created_at": "2021-07-10T17:48:56Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667366126"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 305,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,388 @@\n+\"\"\"Functions to process IPython magics with.\"\"\"\n+import ast\n+import tokenize\n+import io\n+from typing import Dict\n+\n+import secrets\n+from typing import NamedTuple, List, Tuple\n+import collections\n+\n+from typing import Optional\n+\n+\n+class Replacement(NamedTuple):\n+    mask: str\n+    src: str\n+\n+\n+class UnsupportedMagic(UserWarning):\n+    \"\"\"Raise when Magic is not supported (e.g. `a = b??`)\"\"\"\n+\n+\n+def remove_trailing_semicolon(src: str) -> Tuple[str, bool]:\n+    \"\"\"Remove trailing semicolon from Jupyter notebook cell.\n+\n+    For example,\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data);  # plot data\n+\n+    would become\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data)  # plot data\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    trailing_semicolon = False\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        if token[0] == tokenize.OP and token[1] == \";\":\n+            # We're iterating backwards, so `-idx`.\n+            del tokens[-idx]\n+            trailing_semicolon = True\n+        break\n+    if not trailing_semicolon:\n+        return src, False\n+    return tokenize.untokenize(tokens), True\n+\n+\n+def put_trailing_semicolon_back(src: str, has_trailing_semicolon: bool) -> str:\n+    \"\"\"Put trailing semicolon back if cell originally had it.\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`.\n+    \"\"\"\n+    if not has_trailing_semicolon:\n+        return src\n+    tokens = list(tokenize.generate_tokens(io.StringIO(src).readline))\n+    for idx, token in enumerate(reversed(tokens), start=1):\n+        if token[0] in (\n+            tokenize.ENDMARKER,\n+            tokenize.NL,\n+            tokenize.NEWLINE,\n+            tokenize.COMMENT,\n+        ):\n+            continue\n+        # We're iterating backwards, so `-idx`.\n+        tokens[-idx] = token._replace(string=token.string + \";\")\n+        break\n+    else:  # pragma: nocover\n+        raise AssertionError(\"Unreachable code\")\n+    return str(tokenize.untokenize(tokens))\n+\n+\n+def mask_cell(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Mask IPython magics so content becomes parseable Python code.\n+\n+    For example,\n+\n+        %matplotlib inline\n+        'foo'\n+\n+    becomes\n+\n+        \"25716f358c32750e\"\n+        'foo'\n+\n+    The replacements are returned, along with the transformed code.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+    try:\n+        ast.parse(src)\n+    except SyntaxError:\n+        # Might have IPython magics, will process below.\n+        pass\n+    else:\n+        # Syntax is fine, nothing to mask, early return.\n+        return src, replacements\n+\n+    from IPython.core.inputtransformer2 import TransformerManager\n+\n+    transformer_manager = TransformerManager()\n+    transformed = transformer_manager.transform_cell(src)\n+    transformed, cell_magic_replacements = replace_cell_magics(transformed)\n+    replacements += cell_magic_replacements\n+    transformed = transformer_manager.transform_cell(transformed)\n+    try:\n+        transformed, magic_replacements = replace_magics(transformed)\n+    except UnsupportedMagic:\n+        raise SyntaxError\n+    if len(transformed.splitlines()) != len(src.splitlines()):  # multi-line magic\n+        raise SyntaxError\n+    replacements += magic_replacements\n+    return transformed, replacements\n+\n+\n+def get_token(src: str, magic: str) -> str:\n+    \"\"\"Return randomly generated token to mask IPython magic with.\n+\n+    For example, if 'magic' was `%matplotlib inline`, then a possible\n+    token to mask it with would be `\"43fdd17f7e5ddc83\"`. The token\n+    will be the same length as the magic, and we make sure that it was\n+    not already present anywhere else in the cell.\n+    \"\"\"\n+    assert magic\n+    nbytes = max(len(magic) // 2 - 1, 1)\n+    token = secrets.token_hex(nbytes)\n+    while token in src:  # pragma: nocover\n+        token = secrets.token_hex(nbytes)\n+    if len(token) + 2 < len(magic):\n+        token = f\"{token}.\"\n+    return f'\"{token}\"'\n+\n+\n+def replace_cell_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace cell magic with token.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example,\n+\n+        get_ipython().run_cell_magic('t', '-n1', 'ls =!ls\\\\n')\n+\n+    becomes\n+\n+        \"a794.\"\n+        ls =!ls\n+\n+    The replacement, along with the transformed code, is returned.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+\n+    tree = ast.parse(src)\n+\n+    cell_magic_finder = CellMagicFinder()\n+    cell_magic_finder.visit(tree)\n+    if not cell_magic_finder.header:\n+        return src, replacements\n+    mask = get_token(src, cell_magic_finder.header)\n+    replacements.append(Replacement(mask=mask, src=cell_magic_finder.header))\n+    return f\"{mask}\\n{cell_magic_finder.body}\", replacements\n+\n+\n+def replace_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace magics within body of cell.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example, this\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+        'foo'\n+\n+    becomes\n+\n+        \"5e67db56d490fd39\"\n+        'foo'\n+\n+    The replacement, along with the transformed code, are returned.\n+    \"\"\"\n+    replacements = []\n+    magic_finder = MagicFinder()\n+    magic_finder.visit(ast.parse(src))\n+    new_srcs = []\n+    for i, line in enumerate(src.splitlines(), start=1):\n+        if i in magic_finder.magics:\n+            magics = magic_finder.magics[i]\n+            if len(magics) != 1:  # pragma: nocover\n+                # defensive check\n+                raise UnsupportedMagic\n+            col_offset, magic = magics[0]\n+            mask = get_token(src, magic)\n+            replacements.append(Replacement(mask=mask, src=magic))\n+            line = line[:col_offset] + mask\n+        new_srcs.append(line)\n+    return \"\\n\".join(new_srcs), replacements\n+\n+\n+def unmask_cell(src: str, replacements: List[Replacement]) -> str:\n+    \"\"\"Remove replacements from cell.\n+\n+    For example\n+\n+        \"9b20\"\n+        foo = bar\n+\n+    becomes\n+\n+        %%time\n+        foo = bar\n+    \"\"\"\n+    for replacement in replacements:\n+        src = src.replace(replacement.mask, replacement.src)\n+    return src\n+\n+\n+def _is_ipython_magic(node: ast.expr) -> bool:\n+    \"\"\"Check if attribute is IPython magic.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+    \"\"\"\n+    return (\n+        isinstance(node, ast.Attribute)\n+        and isinstance(node.value, ast.Call)\n+        and isinstance(node.value.func, ast.Name)\n+        and node.value.func.id == \"get_ipython\"\n+    )\n+\n+\n+class CellMagicFinder(ast.NodeVisitor):\n+    \"\"\"Find cell magics.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %%time\\nfoo()\n+\n+    would have been transformed to\n+\n+        get_ipython().run_cell_magic('time', '', 'foo()\\\\n')\n+\n+    and we look for instances of the latter.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        self.header: Optional[str] = None\n+        self.body: Optional[str] = None\n+\n+    def visit_Expr(self, node: ast.Expr) -> None:\n+        \"\"\"Find cell magic, extract header and body.\"\"\"\n+        if (\n+            isinstance(node.value, ast.Call)\n+            and _is_ipython_magic(node.value.func)\n+            and isinstance(node.value.func, ast.Attribute)\n+            and node.value.func.attr == \"run_cell_magic\"\n+        ):\n+            args = []\n+            for arg in node.value.args:\n+                assert isinstance(arg, ast.Str)\n+                args.append(arg.s)\n+            header: Optional[str] = f\"%%{args[0]}\"\n+            if args[1]:\n+                assert header is not None\n+                header += f\" {args[1]}\"\n+            self.header = header\n+            self.body = args[2]\n+        self.generic_visit(node)\n+\n+\n+class MagicFinder(ast.NodeVisitor):\n+    \"\"\"Visit cell to look for get_ipython calls.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %matplotlib inline\n+\n+    would have been transformed to\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+\n+    and we look for instances of the latter (and likewise for other\n+    types of magics).\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        \"\"\"Record where magics occur.\"\"\"\n+        self.magics: Dict[int, List[Tuple[int, str]]] = collections.defaultdict(list)",
      "comment": "Just to clarify - which part would you like to be a dataclass? I've done it for the `Tuple[int, str]`, but did you mean it for the whole thing? If so, it's not clear to me how to make a dataclass out of a `collections.defaultdict`, but I'll think about what I can do here",
      "comment_id": 667500034,
      "user": "MarcoGorelli",
      "created_at": "2021-07-11T15:46:41Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r667500034"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 299,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+\"\"\"Functions to process IPython magics with.\"\"\"\n+import dataclasses\n+import ast\n+from typing import Dict\n+\n+import secrets\n+from typing import List, Tuple\n+import collections\n+\n+from typing import Optional\n+from typing_extensions import TypeGuard\n+\n+TRANSFORMED_MAGICS = frozenset(\n+    (\n+        \"get_ipython().run_cell_magic\",\n+        \"get_ipython().system\",\n+        \"get_ipython().getoutput\",\n+        \"get_ipython().run_line_magic\",\n+    )\n+)\n+TOKENS_TO_IGNORE = frozenset(\n+    (\n+        \"ENDMARKER\",\n+        \"NL\",\n+        \"NEWLINE\",\n+        \"COMMENT\",\n+        \"DEDENT\",\n+        \"UNIMPORTANT_WS\",\n+        \"ESCAPED_NL\",\n+    )\n+)\n+\n+\n+@dataclasses.dataclass(frozen=True)\n+class Replacement:\n+    mask: str\n+    src: str\n+\n+\n+class UnsupportedMagic(UserWarning):\n+    \"\"\"Raise when Magic is not supported (e.g. `a = b??`)\"\"\"\n+\n+\n+def remove_trailing_semicolon(src: str) -> Tuple[str, bool]:\n+    \"\"\"Remove trailing semicolon from Jupyter notebook cell.\n+\n+    For example,\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data);  # plot data\n+\n+    would become\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data)  # plot data\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`, but uses\n+    ``tokenize_rt`` so that round-tripping works fine.\n+    \"\"\"\n+    from tokenize_rt import (\n+        src_to_tokens,\n+        tokens_to_src,\n+        reversed_enumerate,\n+    )\n+\n+    tokens = src_to_tokens(src)\n+    trailing_semicolon = False\n+    for idx, token in reversed_enumerate(tokens):\n+        if token.name in TOKENS_TO_IGNORE:\n+            continue\n+        if token.name == \"OP\" and token.src == \";\":\n+            del tokens[idx]\n+            trailing_semicolon = True\n+        break\n+    if not trailing_semicolon:\n+        return src, False\n+    return tokens_to_src(tokens), True\n+\n+\n+def put_trailing_semicolon_back(src: str, has_trailing_semicolon: bool) -> str:\n+    \"\"\"Put trailing semicolon back if cell originally had it.\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`, but uses\n+    ``tokenize_rt`` so that round-tripping works fine.\n+    \"\"\"\n+    if not has_trailing_semicolon:\n+        return src\n+    from tokenize_rt import src_to_tokens, tokens_to_src, reversed_enumerate\n+\n+    tokens = src_to_tokens(src)\n+    for idx, token in reversed_enumerate(tokens):\n+        if token.name in TOKENS_TO_IGNORE:\n+            continue\n+        tokens[idx] = token._replace(src=token.src + \";\")\n+        break\n+    else:  # pragma: nocover\n+        raise AssertionError(\n+            \"INTERNAL ERROR: Was not able to reinstate trailing semicolon. \"\n+            \"Please report a bug on https://github.com/psf/black/issues.  \"\n+        ) from None\n+    return str(tokens_to_src(tokens))\n+\n+\n+def mask_cell(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Mask IPython magics so content becomes parseable Python code.\n+\n+    For example,\n+\n+        %matplotlib inline\n+        'foo'\n+\n+    becomes\n+\n+        \"25716f358c32750e\"\n+        'foo'\n+\n+    The replacements are returned, along with the transformed code.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+    try:\n+        ast.parse(src)\n+    except SyntaxError:\n+        # Might have IPython magics, will process below.\n+        pass\n+    else:\n+        # Syntax is fine, nothing to mask, early return.\n+        return src, replacements\n+\n+    from IPython.core.inputtransformer2 import TransformerManager\n+\n+    transformer_manager = TransformerManager()\n+    transformed = transformer_manager.transform_cell(src)\n+    transformed, cell_magic_replacements = replace_cell_magics(transformed)\n+    replacements += cell_magic_replacements\n+    transformed = transformer_manager.transform_cell(transformed)\n+    try:\n+        transformed, magic_replacements = replace_magics(transformed)\n+    except UnsupportedMagic:\n+        raise SyntaxError\n+    if len(transformed.splitlines()) != len(src.splitlines()):  # multi-line magic\n+        raise SyntaxError\n+    replacements += magic_replacements\n+    return transformed, replacements\n+\n+\n+def get_token(src: str, magic: str) -> str:\n+    \"\"\"Return randomly generated token to mask IPython magic with.\n+\n+    For example, if 'magic' was `%matplotlib inline`, then a possible\n+    token to mask it with would be `\"43fdd17f7e5ddc83\"`. The token\n+    will be the same length as the magic, and we make sure that it was\n+    not already present anywhere else in the cell.\n+    \"\"\"\n+    assert magic\n+    nbytes = max(len(magic) // 2 - 1, 1)\n+    token = secrets.token_hex(nbytes)\n+    counter = 0\n+    while token in src:  # pragma: nocover\n+        token = secrets.token_hex(nbytes)\n+        counter += 1\n+        if counter > 100:\n+            raise AssertionError(\n+                \"INTERNAL ERROR: Black was not able to replace IPython magic. \"\n+                \"Please report a bug on https://github.com/psf/black/issues.  \"\n+                f\"The magic might be helpful: {magic}\"\n+            ) from None\n+    if len(token) + 2 < len(magic):\n+        token = f\"{token}.\"\n+    return f'\"{token}\"'\n+\n+\n+def replace_cell_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace cell magic with token.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example,\n+\n+        get_ipython().run_cell_magic('t', '-n1', 'ls =!ls\\\\n')\n+\n+    becomes\n+\n+        \"a794.\"\n+        ls =!ls\n+\n+    The replacement, along with the transformed code, is returned.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+\n+    tree = ast.parse(src)\n+\n+    cell_magic_finder = CellMagicFinder()\n+    cell_magic_finder.visit(tree)\n+    if cell_magic_finder.cell_magic is None:\n+        return src, replacements\n+    mask = get_token(src, cell_magic_finder.cell_magic.header)\n+    replacements.append(Replacement(mask=mask, src=cell_magic_finder.cell_magic.header))\n+    return f\"{mask}\\n{cell_magic_finder.cell_magic.body}\", replacements\n+\n+\n+def replace_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace magics within body of cell.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example, this\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+        'foo'\n+\n+    becomes\n+\n+        \"5e67db56d490fd39\"\n+        'foo'\n+\n+    The replacement, along with the transformed code, are returned.\n+    \"\"\"\n+    replacements = []\n+    magic_finder = MagicFinder()\n+    magic_finder.visit(ast.parse(src))\n+    new_srcs = []\n+    for i, line in enumerate(src.splitlines(), start=1):\n+        if i in magic_finder.magics:\n+            offsets_and_magics = magic_finder.magics[i]\n+            if len(offsets_and_magics) != 1:  # pragma: nocover\n+                # defensive check\n+                raise UnsupportedMagic\n+            col_offset, magic = (\n+                offsets_and_magics[0].col_offset,\n+                offsets_and_magics[0].magic,\n+            )\n+            mask = get_token(src, magic)\n+            replacements.append(Replacement(mask=mask, src=magic))\n+            line = line[:col_offset] + mask\n+        new_srcs.append(line)\n+    return \"\\n\".join(new_srcs), replacements\n+\n+\n+def unmask_cell(src: str, replacements: List[Replacement]) -> str:\n+    \"\"\"Remove replacements from cell.\n+\n+    For example\n+\n+        \"9b20\"\n+        foo = bar\n+\n+    becomes\n+\n+        %%time\n+        foo = bar\n+    \"\"\"\n+    for replacement in replacements:\n+        src = src.replace(replacement.mask, replacement.src)\n+    return src\n+\n+\n+def _is_ipython_magic(node: ast.expr) -> TypeGuard[ast.Attribute]:\n+    \"\"\"Check if attribute is IPython magic.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+    \"\"\"\n+    return (\n+        isinstance(node, ast.Attribute)\n+        and isinstance(node.value, ast.Call)\n+        and isinstance(node.value.func, ast.Name)\n+        and node.value.func.id == \"get_ipython\"\n+    )\n+\n+\n+@dataclasses.dataclass(frozen=True)\n+class CellMagic:\n+    header: str\n+    body: str\n+\n+\n+@dataclasses.dataclass\n+class CellMagicFinder(ast.NodeVisitor):\n+    \"\"\"Find cell magics.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %%time\\nfoo()\n+\n+    would have been transformed to\n+\n+        get_ipython().run_cell_magic('time', '', 'foo()\\\\n')\n+\n+    and we look for instances of the latter.\n+    \"\"\"\n+\n+    cell_magic: Optional[CellMagic] = None",
      "comment": "> Same, let's use a dataclass\r\n\r\nDone - is this what you meant @JelleZijlstra ? (sorry having taken some time to address that, I wasn't aware that dataclasses would inherit from other classes - there, that's another new thing I've learned from this PR \ud83d\udc9a  )",
      "comment_id": 668952306,
      "user": "MarcoGorelli",
      "created_at": "2021-07-13T17:01:30Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r668952306"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/__init__.py",
      "line": 855,
      "side": "RIGHT",
      "diff_hunk": "@@ -819,6 +852,23 @@ def format_stdin_to_stdout(\n         f.detach()\n \n \n+def check_src_and_dst_equivalent(",
      "comment": "I like this! If we ever provide a stable API, this is 100% going in. Might be worth adding a docstring tho.",
      "comment_id": 671587972,
      "user": "ichard26",
      "created_at": "2021-07-17T01:28:32Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r671587972"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/__init__.py",
      "line": 216,
      "side": "RIGHT",
      "diff_hunk": "@@ -196,6 +206,14 @@ def validate_regex(\n         \" when piping source on standard input).\"\n     ),\n )\n+@click.option(\n+    \"--ipynb\",\n+    is_flag=True,\n+    help=(\n+        \"Format all input files like ipynb notebooks regardless of file extension \"\n+        \"(useful when piping source on standard input).\"\n+    ),\n+)",
      "comment": "I'm not the biggest fan of this since this allows for \"illegal state\" to be configured (forcing all files to be treated both as stubs and jupyter notebooks). While this doesn't break anything (the --ipynb flag wins out), it's probably not the best UX. Totally down to deal with this in a later PR (although before this gets released). Also, totally fine to leave this alone, it's not that terrible anyway.",
      "comment_id": 671594383,
      "user": "ichard26",
      "created_at": "2021-07-17T02:19:12Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r671594383"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/__init__.py",
      "line": 773,
      "side": "RIGHT",
      "diff_hunk": "@@ -741,6 +765,12 @@ def format_file_in_place(\n         dst_contents = format_file_contents(src_contents, fast=fast, mode=mode)\n     except NothingChanged:\n         return False\n+    except ModuleNotFoundError:\n+        warnings.warn(\n+            f\"Skipping '{src}' as Jupyter dependencies are not installed.\\n\"\n+            \"You can fix this by running ``pip install black[jupyter]``\"\n+        )\n+        return False",
      "comment": "I don't like very much since it's kinda tacked on and could easily become misleading if we ever add additional lazy / conditional imports. It's also not immediately clear that this situation must be about missing Jupyter dependencies.",
      "comment_id": 671595360,
      "user": "ichard26",
      "created_at": "2021-07-17T02:29:13Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r671595360"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/__init__.py",
      "line": 971,
      "side": "RIGHT",
      "diff_hunk": "@@ -829,26 +879,116 @@ def format_file_contents(src_contents: str, *, fast: bool, mode: Mode) -> FileCo\n     if not src_contents.strip():\n         raise NothingChanged\n \n-    dst_contents = format_str(src_contents, mode=mode)\n+    if mode.is_ipynb:\n+        dst_contents = format_ipynb_string(src_contents, fast=fast, mode=mode)\n+    else:\n+        dst_contents = format_str(src_contents, mode=mode)\n     if src_contents == dst_contents:\n         raise NothingChanged\n \n-    if not fast:\n-        assert_equivalent(src_contents, dst_contents)\n-\n-        # Forced second pass to work around optional trailing commas (becoming\n-        # forced trailing commas on pass 2) interacting differently with optional\n-        # parentheses.  Admittedly ugly.\n-        dst_contents_pass2 = format_str(dst_contents, mode=mode)\n-        if dst_contents != dst_contents_pass2:\n-            dst_contents = dst_contents_pass2\n-            assert_equivalent(src_contents, dst_contents, pass_num=2)\n-            assert_stable(src_contents, dst_contents, mode=mode)\n-        # Note: no need to explicitly call `assert_stable` if `dst_contents` was\n-        # the same as `dst_contents_pass2`.\n+    if not fast and not mode.is_ipynb:\n+        # Jupyter notebooks will already have been checked above.\n+        check_src_and_dst_equivalent(src_contents, dst_contents, mode=mode)\n     return dst_contents\n \n \n+def validate_cell(src: str) -> None:\n+    \"\"\"Check that cell does not already contain TransformerManager transformations.\n+\n+    If a cell contains ``!ls``, then it'll be transformed to\n+    ``get_ipython().system('ls')``. However, if the cell originally contained\n+    ``get_ipython().system('ls')``, then it would get transformed in the same way:\n+\n+        >>> TransformerManager().transform_cell(\"get_ipython().system('ls')\")\n+        \"get_ipython().system('ls')\\n\"\n+        >>> TransformerManager().transform_cell(\"!ls\")\n+        \"get_ipython().system('ls')\\n\"\n+\n+    Due to the impossibility of safely roundtripping in such situations, cells\n+    containing transformed magics will be ignored.\n+    \"\"\"\n+    if any(transformed_magic in src for transformed_magic in TRANSFORMED_MAGICS):\n+        raise NothingChanged\n+\n+\n+def format_cell(src: str, *, fast: bool, mode: Mode) -> str:\n+    \"\"\"Format code in given cell of Jupyter notebook.\n+\n+    General idea is:\n+\n+      - if cell has trailing semicolon, remove it;\n+      - if cell has IPython magics, mask them;\n+      - format cell;\n+      - reinstate IPython magics;\n+      - reinstate trailing semicolon (if originally present);\n+      - strip trailing newlines.\n+\n+    Cells with syntax errors will not be processed, as they\n+    could potentially be automagics or multi-line magics, which\n+    are currently not supported.\n+    \"\"\"\n+    validate_cell(src)\n+    src_without_trailing_semicolon, has_trailing_semicolon = remove_trailing_semicolon(\n+        src\n+    )\n+    try:\n+        masked_src, replacements = mask_cell(src_without_trailing_semicolon)\n+    except SyntaxError:\n+        raise NothingChanged\n+    masked_dst = format_str(masked_src, mode=mode)\n+    if not fast:\n+        check_src_and_dst_equivalent(masked_src, masked_dst, mode=mode)\n+    dst_without_trailing_semicolon = unmask_cell(masked_dst, replacements)\n+    dst = put_trailing_semicolon_back(\n+        dst_without_trailing_semicolon, has_trailing_semicolon\n+    )\n+    dst = dst.rstrip(\"\\n\")\n+    if dst == src:\n+        raise NothingChanged\n+    return dst\n+\n+\n+def validate_metadata(nb: MutableMapping[str, Any]) -> None:\n+    \"\"\"If notebook is marked as non-Python, don't format it.\n+\n+    All notebook metadata fields are optional, see\n+    https://nbformat.readthedocs.io/en/latest/format_description.html. So\n+    if a notebook has empty metadata, we will try to parse it anyway.\n+    \"\"\"\n+    language = nb.get(\"metadata\", {}).get(\"language_info\", {}).get(\"name\", None)\n+    if language is not None and language != \"python\":\n+        raise NothingChanged\n+\n+\n+def format_ipynb_string(src_contents: str, *, fast: bool, mode: Mode) -> FileContent:\n+    \"\"\"Format Jupyter notebook.\n+\n+    Operate cell-by-cell, only on code cells, only for Python notebooks.\n+    If the ``.ipynb`` originally had a trailing newline, it'll be preseved.\n+    \"\"\"\n+    trailing_newline = src_contents[-1] == \"\\n\"\n+    modified = False\n+    nb = json.loads(src_contents)",
      "comment": "Maybe it's worth failing with a more descriptive error message when JSON decoding fails? Currently the JSONDecodeError is caught untouched.",
      "comment_id": 671595854,
      "user": "ichard26",
      "created_at": "2021-07-17T02:33:42Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r671595854"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/__init__.py",
      "line": 773,
      "side": "RIGHT",
      "diff_hunk": "@@ -741,6 +765,12 @@ def format_file_in_place(\n         dst_contents = format_file_contents(src_contents, fast=fast, mode=mode)\n     except NothingChanged:\n         return False\n+    except ModuleNotFoundError:\n+        warnings.warn(\n+            f\"Skipping '{src}' as Jupyter dependencies are not installed.\\n\"\n+            \"You can fix this by running ``pip install black[jupyter]``\"\n+        )\n+        return False",
      "comment": "This is also what's causing the caching bug I noted above.",
      "comment_id": 671599527,
      "user": "JelleZijlstra",
      "created_at": "2021-07-17T03:09:44Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r671599527"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/__init__.py",
      "line": 855,
      "side": "RIGHT",
      "diff_hunk": "@@ -819,6 +852,23 @@ def format_stdin_to_stdout(\n         f.detach()\n \n \n+def check_src_and_dst_equivalent(",
      "comment": "actually, this name isn't 100% clear because this also includes the stability check, I can't think of a good name tho.",
      "comment_id": 671601078,
      "user": "ichard26",
      "created_at": "2021-07-17T03:26:42Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r671601078"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/__init__.py",
      "line": 216,
      "side": "RIGHT",
      "diff_hunk": "@@ -196,6 +206,14 @@ def validate_regex(\n         \" when piping source on standard input).\"\n     ),\n )\n+@click.option(\n+    \"--ipynb\",\n+    is_flag=True,\n+    help=(\n+        \"Format all input files like ipynb notebooks regardless of file extension \"\n+        \"(useful when piping source on standard input).\"\n+    ),\n+)",
      "comment": "Yeah, that's a good point...I'll remove it for now then",
      "comment_id": 671684408,
      "user": "MarcoGorelli",
      "created_at": "2021-07-17T11:25:50Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r671684408"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 299,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+\"\"\"Functions to process IPython magics with.\"\"\"\n+import dataclasses\n+import ast\n+from typing import Dict\n+\n+import secrets\n+from typing import List, Tuple\n+import collections\n+\n+from typing import Optional\n+from typing_extensions import TypeGuard\n+\n+TRANSFORMED_MAGICS = frozenset(\n+    (\n+        \"get_ipython().run_cell_magic\",\n+        \"get_ipython().system\",\n+        \"get_ipython().getoutput\",\n+        \"get_ipython().run_line_magic\",\n+    )\n+)\n+TOKENS_TO_IGNORE = frozenset(\n+    (\n+        \"ENDMARKER\",\n+        \"NL\",\n+        \"NEWLINE\",\n+        \"COMMENT\",\n+        \"DEDENT\",\n+        \"UNIMPORTANT_WS\",\n+        \"ESCAPED_NL\",\n+    )\n+)\n+\n+\n+@dataclasses.dataclass(frozen=True)\n+class Replacement:\n+    mask: str\n+    src: str\n+\n+\n+class UnsupportedMagic(UserWarning):\n+    \"\"\"Raise when Magic is not supported (e.g. `a = b??`)\"\"\"\n+\n+\n+def remove_trailing_semicolon(src: str) -> Tuple[str, bool]:\n+    \"\"\"Remove trailing semicolon from Jupyter notebook cell.\n+\n+    For example,\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data);  # plot data\n+\n+    would become\n+\n+        fig, ax = plt.subplots()\n+        ax.plot(x_data, y_data)  # plot data\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`, but uses\n+    ``tokenize_rt`` so that round-tripping works fine.\n+    \"\"\"\n+    from tokenize_rt import (\n+        src_to_tokens,\n+        tokens_to_src,\n+        reversed_enumerate,\n+    )\n+\n+    tokens = src_to_tokens(src)\n+    trailing_semicolon = False\n+    for idx, token in reversed_enumerate(tokens):\n+        if token.name in TOKENS_TO_IGNORE:\n+            continue\n+        if token.name == \"OP\" and token.src == \";\":\n+            del tokens[idx]\n+            trailing_semicolon = True\n+        break\n+    if not trailing_semicolon:\n+        return src, False\n+    return tokens_to_src(tokens), True\n+\n+\n+def put_trailing_semicolon_back(src: str, has_trailing_semicolon: bool) -> str:\n+    \"\"\"Put trailing semicolon back if cell originally had it.\n+\n+    Mirrors the logic in `quiet` from `IPython.core.displayhook`, but uses\n+    ``tokenize_rt`` so that round-tripping works fine.\n+    \"\"\"\n+    if not has_trailing_semicolon:\n+        return src\n+    from tokenize_rt import src_to_tokens, tokens_to_src, reversed_enumerate\n+\n+    tokens = src_to_tokens(src)\n+    for idx, token in reversed_enumerate(tokens):\n+        if token.name in TOKENS_TO_IGNORE:\n+            continue\n+        tokens[idx] = token._replace(src=token.src + \";\")\n+        break\n+    else:  # pragma: nocover\n+        raise AssertionError(\n+            \"INTERNAL ERROR: Was not able to reinstate trailing semicolon. \"\n+            \"Please report a bug on https://github.com/psf/black/issues.  \"\n+        ) from None\n+    return str(tokens_to_src(tokens))\n+\n+\n+def mask_cell(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Mask IPython magics so content becomes parseable Python code.\n+\n+    For example,\n+\n+        %matplotlib inline\n+        'foo'\n+\n+    becomes\n+\n+        \"25716f358c32750e\"\n+        'foo'\n+\n+    The replacements are returned, along with the transformed code.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+    try:\n+        ast.parse(src)\n+    except SyntaxError:\n+        # Might have IPython magics, will process below.\n+        pass\n+    else:\n+        # Syntax is fine, nothing to mask, early return.\n+        return src, replacements\n+\n+    from IPython.core.inputtransformer2 import TransformerManager\n+\n+    transformer_manager = TransformerManager()\n+    transformed = transformer_manager.transform_cell(src)\n+    transformed, cell_magic_replacements = replace_cell_magics(transformed)\n+    replacements += cell_magic_replacements\n+    transformed = transformer_manager.transform_cell(transformed)\n+    try:\n+        transformed, magic_replacements = replace_magics(transformed)\n+    except UnsupportedMagic:\n+        raise SyntaxError\n+    if len(transformed.splitlines()) != len(src.splitlines()):  # multi-line magic\n+        raise SyntaxError\n+    replacements += magic_replacements\n+    return transformed, replacements\n+\n+\n+def get_token(src: str, magic: str) -> str:\n+    \"\"\"Return randomly generated token to mask IPython magic with.\n+\n+    For example, if 'magic' was `%matplotlib inline`, then a possible\n+    token to mask it with would be `\"43fdd17f7e5ddc83\"`. The token\n+    will be the same length as the magic, and we make sure that it was\n+    not already present anywhere else in the cell.\n+    \"\"\"\n+    assert magic\n+    nbytes = max(len(magic) // 2 - 1, 1)\n+    token = secrets.token_hex(nbytes)\n+    counter = 0\n+    while token in src:  # pragma: nocover\n+        token = secrets.token_hex(nbytes)\n+        counter += 1\n+        if counter > 100:\n+            raise AssertionError(\n+                \"INTERNAL ERROR: Black was not able to replace IPython magic. \"\n+                \"Please report a bug on https://github.com/psf/black/issues.  \"\n+                f\"The magic might be helpful: {magic}\"\n+            ) from None\n+    if len(token) + 2 < len(magic):\n+        token = f\"{token}.\"\n+    return f'\"{token}\"'\n+\n+\n+def replace_cell_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace cell magic with token.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example,\n+\n+        get_ipython().run_cell_magic('t', '-n1', 'ls =!ls\\\\n')\n+\n+    becomes\n+\n+        \"a794.\"\n+        ls =!ls\n+\n+    The replacement, along with the transformed code, is returned.\n+    \"\"\"\n+    replacements: List[Replacement] = []\n+\n+    tree = ast.parse(src)\n+\n+    cell_magic_finder = CellMagicFinder()\n+    cell_magic_finder.visit(tree)\n+    if cell_magic_finder.cell_magic is None:\n+        return src, replacements\n+    mask = get_token(src, cell_magic_finder.cell_magic.header)\n+    replacements.append(Replacement(mask=mask, src=cell_magic_finder.cell_magic.header))\n+    return f\"{mask}\\n{cell_magic_finder.cell_magic.body}\", replacements\n+\n+\n+def replace_magics(src: str) -> Tuple[str, List[Replacement]]:\n+    \"\"\"Replace magics within body of cell.\n+\n+    Note that 'src' will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    Example, this\n+\n+        get_ipython().run_line_magic('matplotlib', 'inline')\n+        'foo'\n+\n+    becomes\n+\n+        \"5e67db56d490fd39\"\n+        'foo'\n+\n+    The replacement, along with the transformed code, are returned.\n+    \"\"\"\n+    replacements = []\n+    magic_finder = MagicFinder()\n+    magic_finder.visit(ast.parse(src))\n+    new_srcs = []\n+    for i, line in enumerate(src.splitlines(), start=1):\n+        if i in magic_finder.magics:\n+            offsets_and_magics = magic_finder.magics[i]\n+            if len(offsets_and_magics) != 1:  # pragma: nocover\n+                # defensive check\n+                raise UnsupportedMagic\n+            col_offset, magic = (\n+                offsets_and_magics[0].col_offset,\n+                offsets_and_magics[0].magic,\n+            )\n+            mask = get_token(src, magic)\n+            replacements.append(Replacement(mask=mask, src=magic))\n+            line = line[:col_offset] + mask\n+        new_srcs.append(line)\n+    return \"\\n\".join(new_srcs), replacements\n+\n+\n+def unmask_cell(src: str, replacements: List[Replacement]) -> str:\n+    \"\"\"Remove replacements from cell.\n+\n+    For example\n+\n+        \"9b20\"\n+        foo = bar\n+\n+    becomes\n+\n+        %%time\n+        foo = bar\n+    \"\"\"\n+    for replacement in replacements:\n+        src = src.replace(replacement.mask, replacement.src)\n+    return src\n+\n+\n+def _is_ipython_magic(node: ast.expr) -> TypeGuard[ast.Attribute]:\n+    \"\"\"Check if attribute is IPython magic.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+    \"\"\"\n+    return (\n+        isinstance(node, ast.Attribute)\n+        and isinstance(node.value, ast.Call)\n+        and isinstance(node.value.func, ast.Name)\n+        and node.value.func.id == \"get_ipython\"\n+    )\n+\n+\n+@dataclasses.dataclass(frozen=True)\n+class CellMagic:\n+    header: str\n+    body: str\n+\n+\n+@dataclasses.dataclass\n+class CellMagicFinder(ast.NodeVisitor):\n+    \"\"\"Find cell magics.\n+\n+    Note that the source of the abstract syntax tree\n+    will already have been processed by IPython's\n+    TransformerManager().transform_cell.\n+\n+    For example,\n+\n+        %%time\\nfoo()\n+\n+    would have been transformed to\n+\n+        get_ipython().run_cell_magic('time', '', 'foo()\\\\n')\n+\n+    and we look for instances of the latter.\n+    \"\"\"\n+\n+    cell_magic: Optional[CellMagic] = None",
      "comment": "Annnddd it looks like this broke compatibility with mypyc:\r\n\r\n```console\r\n~/programming/oss/black on mypyc-support-pt2 [$?\u21e1] via Python v3.8.5 (bm-venv) took 1s445ms \r\n\u276f black setup.py --check -v\r\nTraceback (most recent call last):\r\n  File \"/home/ichard26/programming/oss/black/bm-venv/bin/black\", line 5, in <module>\r\n    from black import patched_main\r\n  File \"src/black/__init__.py\", line 47, in <module>\r\n    from black.files import find_project_root, find_pyproject_toml, parse_pyproject_toml\r\n  File \"/home/ichard26/programming/oss/black/bm-venv/lib/python3.8/site-packages/black/files.py\", line 26, in <module>\r\n    from black.handle_ipynb_magics import jupyter_dependencies_are_installed\r\n  File \"src/black/handle_ipynb_magics.py\", line 316, in <module>\r\n    class CellMagicFinder(ast.NodeVisitor):\r\nAttributeError: attribute '__dict__' of 'type' objects is not writable\r\n```\r\n\r\n(it's broken on main too but I'm currently working on mypyc integration on the `mypyc-support-pt2` branch). _I'll deal with this myself since I need to assess how badly this broke things._ The good news is that this should be easy to work around (hopefully just remove the dataclass decorator) since I've seen and dealt with issues like this before. ",
      "comment_id": 680180887,
      "user": "ichard26",
      "created_at": "2021-07-30T19:42:31Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r680180887"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "tests/test_ipynb.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+import pathlib\n+from click.testing import CliRunner\n+from black.handle_ipynb_magics import jupyter_dependencies_are_installed\n+from black import (\n+    main,\n+    NothingChanged,\n+    format_cell,\n+    format_file_contents,\n+    format_file_in_place,\n+)\n+import os\n+import pytest\n+from black import Mode\n+from _pytest.monkeypatch import MonkeyPatch\n+from _pytest.tmpdir import tmpdir\n+\n+pytestmark = pytest.mark.jupyter\n+pytest.importorskip(\"IPython\", reason=\"IPython is an optional dependency\")\n+pytest.importorskip(\"tokenize_rt\", reason=\"tokenize-rt is an optional dependency\")\n+\n+JUPYTER_MODE = Mode(is_ipynb=True)\n+\n+runner = CliRunner()\n+\n+\n+def test_noop() -> None:\n+    src = 'foo = \"a\"'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+@pytest.mark.parametrize(\"fast\", [True, False])\n+def test_trailing_semicolon(fast: bool) -> None:\n+    src = 'foo = \"a\" ;'\n+    result = format_cell(src, fast=fast, mode=JUPYTER_MODE)\n+    expected = 'foo = \"a\";'\n+    assert result == expected\n+\n+\n+def test_trailing_semicolon_with_comment() -> None:\n+    src = 'foo = \"a\" ;  # bar'\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = 'foo = \"a\";  # bar'\n+    assert result == expected\n+\n+\n+def test_trailing_semicolon_with_comment_on_next_line() -> None:\n+    src = \"import black;\\n\\n# this is a comment\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_trailing_semicolon_indented() -> None:\n+    src = \"with foo:\\n    plot_bar();\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_trailing_semicolon_noop() -> None:\n+    src = 'foo = \"a\";'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_cell_magic() -> None:\n+    src = \"%%time\\nfoo =bar\"\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = \"%%time\\nfoo = bar\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_noop() -> None:\n+    src = \"%%time\\n2 + 2\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+@pytest.mark.parametrize(\n+    \"src, expected\",\n+    (\n+        pytest.param(\"ls =!ls\", \"ls = !ls\", id=\"System assignment\"),\n+        pytest.param(\"!ls\\n'foo'\", '!ls\\n\"foo\"', id=\"System call\"),\n+        pytest.param(\"!!ls\\n'foo'\", '!!ls\\n\"foo\"', id=\"Other system call\"),\n+        pytest.param(\"?str\\n'foo'\", '?str\\n\"foo\"', id=\"Help\"),\n+        pytest.param(\"??str\\n'foo'\", '??str\\n\"foo\"', id=\"Other help\"),\n+        pytest.param(\n+            \"%matplotlib inline\\n'foo'\",\n+            '%matplotlib inline\\n\"foo\"',\n+            id=\"Line magic with argument\",\n+        ),\n+        pytest.param(\"%time\\n'foo'\", '%time\\n\"foo\"', id=\"Line magic without argument\"),\n+    ),\n+)\n+def test_magic(src: str, expected: str) -> None:\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    assert result == expected\n+\n+\n+@pytest.mark.parametrize(\n+    \"src\",\n+    (\n+        \"%%bash\\n2+2\",\n+        \"%%html --isolated\\n2+2\",\n+    ),\n+)\n+def test_non_python_magics(src: str) -> None:\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_set_input() -> None:\n+    src = \"a = b??\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_input_already_contains_transformed_magic() -> None:\n+    src = '%time foo()\\nget_ipython().run_cell_magic(\"time\", \"\", \"foo()\\\\n\")'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_magic_noop() -> None:\n+    src = \"ls = !ls\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_cell_magic_with_magic() -> None:\n+    src = \"%%t -n1\\nls =!ls\"\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = \"%%t -n1\\nls = !ls\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_nested() -> None:\n+    src = \"%%time\\n%%time\\n2+2\"\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = \"%%time\\n%%time\\n2 + 2\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_with_magic_noop() -> None:\n+    src = \"%%t -n1\\nls = !ls\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_automagic() -> None:\n+    src = \"pip install black\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_multiline_magic() -> None:\n+    src = \"%time 1 + \\\\\\n2\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_multiline_no_magic() -> None:\n+    src = \"1 + \\\\\\n2\"\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = \"1 + 2\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_with_invalid_body() -> None:\n+    src = \"%%time\\nif True\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_empty_cell() -> None:\n+    src = \"\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_entire_notebook_empty_metadata() -> None:\n+    with open(\n+        os.path.join(\"tests\", \"data\", \"notebook_empty_metadata.ipynb\"), \"rb\"\n+    ) as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    result = format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+    expected = (\n+        \"{\\n\"\n+        ' \"cells\": [\\n'\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {\\n'\n+        '    \"tags\": []\\n'\n+        \"   },\\n\"\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": [\\n'\n+        '    \"%%time\\\\n\",\\n'\n+        '    \"\\\\n\",\\n'\n+        '    \"print(\\\\\"foo\\\\\")\"\\n'\n+        \"   ]\\n\"\n+        \"  },\\n\"\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {},\\n'\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": []\\n'\n+        \"  }\\n\"\n+        \" ],\\n\"\n+        ' \"metadata\": {},\\n'\n+        ' \"nbformat\": 4,\\n'\n+        ' \"nbformat_minor\": 4\\n'\n+        \"}\\n\"\n+    )\n+    assert result == expected\n+\n+\n+def test_entire_notebook_trailing_newline() -> None:\n+    with open(\n+        os.path.join(\"tests\", \"data\", \"notebook_trailing_newline.ipynb\"), \"rb\"\n+    ) as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    result = format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+    expected = (\n+        \"{\\n\"\n+        ' \"cells\": [\\n'\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {\\n'\n+        '    \"tags\": []\\n'\n+        \"   },\\n\"\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": [\\n'\n+        '    \"%%time\\\\n\",\\n'\n+        '    \"\\\\n\",\\n'\n+        '    \"print(\\\\\"foo\\\\\")\"\\n'\n+        \"   ]\\n\"\n+        \"  },\\n\"\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {},\\n'\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": []\\n'\n+        \"  }\\n\"\n+        \" ],\\n\"\n+        ' \"metadata\": {\\n'\n+        '  \"interpreter\": {\\n'\n+        '   \"hash\": \"e758f3098b5b55f4d87fe30bbdc1367f20f246b483f96267ee70e6c40cb185d8\"\\n'  # noqa:B950\n+        \"  },\\n\"\n+        '  \"kernelspec\": {\\n'\n+        '   \"display_name\": \"Python 3.8.10 64-bit (\\'black\\': venv)\",\\n'\n+        '   \"name\": \"python3\"\\n'\n+        \"  },\\n\"\n+        '  \"language_info\": {\\n'\n+        '   \"name\": \"python\",\\n'\n+        '   \"version\": \"\"\\n'\n+        \"  }\\n\"\n+        \" },\\n\"\n+        ' \"nbformat\": 4,\\n'\n+        ' \"nbformat_minor\": 4\\n'\n+        \"}\\n\"\n+    )\n+    assert result == expected\n+\n+\n+def test_entire_notebook_no_trailing_newline() -> None:\n+    with open(\n+        os.path.join(\"tests\", \"data\", \"notebook_no_trailing_newline.ipynb\"), \"rb\"\n+    ) as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    result = format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+    expected = (\n+        \"{\\n\"\n+        ' \"cells\": [\\n'\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {\\n'\n+        '    \"tags\": []\\n'\n+        \"   },\\n\"\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": [\\n'\n+        '    \"%%time\\\\n\",\\n'\n+        '    \"\\\\n\",\\n'\n+        '    \"print(\\\\\"foo\\\\\")\"\\n'\n+        \"   ]\\n\"\n+        \"  },\\n\"\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {},\\n'\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": []\\n'\n+        \"  }\\n\"\n+        \" ],\\n\"\n+        ' \"metadata\": {\\n'\n+        '  \"interpreter\": {\\n'\n+        '   \"hash\": \"e758f3098b5b55f4d87fe30bbdc1367f20f246b483f96267ee70e6c40cb185d8\"\\n'  # noqa: B950\n+        \"  },\\n\"\n+        '  \"kernelspec\": {\\n'\n+        '   \"display_name\": \"Python 3.8.10 64-bit (\\'black\\': venv)\",\\n'\n+        '   \"name\": \"python3\"\\n'\n+        \"  },\\n\"\n+        '  \"language_info\": {\\n'\n+        '   \"name\": \"python\",\\n'\n+        '   \"version\": \"\"\\n'\n+        \"  }\\n\"\n+        \" },\\n\"\n+        ' \"nbformat\": 4,\\n'\n+        ' \"nbformat_minor\": 4\\n'\n+        \"}\"\n+    )\n+    assert result == expected\n+\n+\n+def test_entire_notebook_without_changes() -> None:\n+    with open(\n+        os.path.join(\"tests\", \"data\", \"notebook_without_changes.ipynb\"), \"rb\"\n+    ) as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    with pytest.raises(NothingChanged):\n+        format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_non_python_notebook() -> None:\n+    with open(os.path.join(\"tests\", \"data\", \"non_python_notebook.ipynb\"), \"rb\") as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    with pytest.raises(NothingChanged):\n+        format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_empty_string() -> None:\n+    with pytest.raises(NothingChanged):\n+        format_file_contents(\"\", fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_unparseable_notebook() -> None:\n+    msg = (\n+        r\"File 'tests[/\\\\]data[/\\\\]notebook_which_cant_be_parsed\\.ipynb' \"\n+        r\"cannot be parsed as valid Jupyter notebook\\.\"\n+    )\n+    with pytest.raises(ValueError, match=msg):\n+        format_file_in_place(\n+            pathlib.Path(\"tests\") / \"data/notebook_which_cant_be_parsed.ipynb\",\n+            fast=True,\n+            mode=JUPYTER_MODE,\n+        )\n+\n+\n+def test_ipynb_diff_with_change() -> None:\n+    result = runner.invoke(\n+        main,\n+        [\n+            os.path.join(\"tests\", \"data\", \"notebook_trailing_newline.ipynb\"),\n+            \"--diff\",\n+        ],\n+    )\n+    expected = \"@@ -1,3 +1,3 @@\\n %%time\\n \\n-print('foo')\\n\" '+print(\"foo\")\\n'\n+    assert expected in result.output\n+\n+\n+def test_ipynb_diff_with_no_change() -> None:\n+    result = runner.invoke(\n+        main,\n+        [\n+            os.path.join(\"tests\", \"data\", \"notebook_without_changes.ipynb\"),\n+            \"--diff\",\n+        ],\n+    )\n+    expected = \"1 file would be left unchanged.\"\n+    assert expected in result.output\n+\n+\n+def test_cache_isnt_written_if_no_jupyter_deps_single(\n+    monkeypatch: MonkeyPatch, tmpdir: tmpdir\n+) -> None:\n+    # Check that the cache isn't written to if Jupyter dependencies aren't installed.\n+    jupyter_dependencies_are_installed.cache_clear()\n+    nb = os.path.join(\"tests\", \"data\", \"notebook_trailing_newline.ipynb\")\n+    tmp_nb = tmpdir / \"notebook.ipynb\"\n+    with open(nb) as src, open(tmp_nb, \"w\") as dst:\n+        dst.write(src.read())\n+    monkeypatch.setattr(\n+        \"black.jupyter_dependencies_are_installed\", lambda verbose, quiet: False\n+    )\n+    result = runner.invoke(main, [str(tmpdir / \"notebook.ipynb\")])\n+    assert \"No Python files are present to be formatted. Nothing to do\" in result.output\n+    jupyter_dependencies_are_installed.cache_clear()\n+    monkeypatch.setattr(\n+        \"black.jupyter_dependencies_are_installed\", lambda verbose, quiet: True\n+    )\n+    result = runner.invoke(main, [str(tmpdir / \"notebook.ipynb\")])\n+    assert \"reformatted\" in result.output\n+\n+\n+def test_cache_isnt_written_if_no_jupyter_deps_many(",
      "comment": "This isn't firing `reformat_many` as the name suggests since there's still ultimately only one file discovered. \r\nhttps://github.com/psf/black/blob/8ea641eed5b9540287a8e9a9afa1458b72b9b630/src/black/__init__.py#L432-L447\r\n\r\nThis does hit the `get_python_files` code path though so maybe that's what you were going for?",
      "comment_id": 680189296,
      "user": "ichard26",
      "created_at": "2021-07-30T20:01:18Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r680189296"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "tests/test_no_ipynb.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+import pytest\n+import os\n+\n+from tests.util import THIS_DIR\n+from black import main, jupyter_dependencies_are_installed\n+from click.testing import CliRunner\n+from _pytest.tmpdir import tmpdir\n+\n+pytestmark = pytest.mark.no_jupyter\n+\n+runner = CliRunner()\n+\n+\n+def test_ipynb_diff_with_no_change_single() -> None:\n+    jupyter_dependencies_are_installed.cache_clear()\n+    path = THIS_DIR / \"data/notebook_trailing_newline.ipynb\"\n+    result = runner.invoke(main, [str(path)])\n+    expected_output = (\n+        \"Skipping .ipynb files as Jupyter dependencies are not installed.\\n\"\n+        \"You can fix this by running ``pip install black[jupyter]``\\n\"\n+    )\n+    assert expected_output in result.output\n+\n+\n+def test_ipynb_diff_with_no_change_many(tmpdir: tmpdir) -> None:",
      "comment": "Ditto with the similar test in `tests/test_ipynb.py`.",
      "comment_id": 680189733,
      "user": "ichard26",
      "created_at": "2021-07-30T20:02:11Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r680189733"
    },
    {
      "repo": "psf/black",
      "pr_number": 2357,
      "file_path": "tests/test_ipynb.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+import pathlib\n+from click.testing import CliRunner\n+from black.handle_ipynb_magics import jupyter_dependencies_are_installed\n+from black import (\n+    main,\n+    NothingChanged,\n+    format_cell,\n+    format_file_contents,\n+    format_file_in_place,\n+)\n+import os\n+import pytest\n+from black import Mode\n+from _pytest.monkeypatch import MonkeyPatch\n+from _pytest.tmpdir import tmpdir\n+\n+pytestmark = pytest.mark.jupyter\n+pytest.importorskip(\"IPython\", reason=\"IPython is an optional dependency\")\n+pytest.importorskip(\"tokenize_rt\", reason=\"tokenize-rt is an optional dependency\")\n+\n+JUPYTER_MODE = Mode(is_ipynb=True)\n+\n+runner = CliRunner()\n+\n+\n+def test_noop() -> None:\n+    src = 'foo = \"a\"'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+@pytest.mark.parametrize(\"fast\", [True, False])\n+def test_trailing_semicolon(fast: bool) -> None:\n+    src = 'foo = \"a\" ;'\n+    result = format_cell(src, fast=fast, mode=JUPYTER_MODE)\n+    expected = 'foo = \"a\";'\n+    assert result == expected\n+\n+\n+def test_trailing_semicolon_with_comment() -> None:\n+    src = 'foo = \"a\" ;  # bar'\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = 'foo = \"a\";  # bar'\n+    assert result == expected\n+\n+\n+def test_trailing_semicolon_with_comment_on_next_line() -> None:\n+    src = \"import black;\\n\\n# this is a comment\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_trailing_semicolon_indented() -> None:\n+    src = \"with foo:\\n    plot_bar();\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_trailing_semicolon_noop() -> None:\n+    src = 'foo = \"a\";'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_cell_magic() -> None:\n+    src = \"%%time\\nfoo =bar\"\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = \"%%time\\nfoo = bar\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_noop() -> None:\n+    src = \"%%time\\n2 + 2\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+@pytest.mark.parametrize(\n+    \"src, expected\",\n+    (\n+        pytest.param(\"ls =!ls\", \"ls = !ls\", id=\"System assignment\"),\n+        pytest.param(\"!ls\\n'foo'\", '!ls\\n\"foo\"', id=\"System call\"),\n+        pytest.param(\"!!ls\\n'foo'\", '!!ls\\n\"foo\"', id=\"Other system call\"),\n+        pytest.param(\"?str\\n'foo'\", '?str\\n\"foo\"', id=\"Help\"),\n+        pytest.param(\"??str\\n'foo'\", '??str\\n\"foo\"', id=\"Other help\"),\n+        pytest.param(\n+            \"%matplotlib inline\\n'foo'\",\n+            '%matplotlib inline\\n\"foo\"',\n+            id=\"Line magic with argument\",\n+        ),\n+        pytest.param(\"%time\\n'foo'\", '%time\\n\"foo\"', id=\"Line magic without argument\"),\n+    ),\n+)\n+def test_magic(src: str, expected: str) -> None:\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    assert result == expected\n+\n+\n+@pytest.mark.parametrize(\n+    \"src\",\n+    (\n+        \"%%bash\\n2+2\",\n+        \"%%html --isolated\\n2+2\",\n+    ),\n+)\n+def test_non_python_magics(src: str) -> None:\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_set_input() -> None:\n+    src = \"a = b??\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_input_already_contains_transformed_magic() -> None:\n+    src = '%time foo()\\nget_ipython().run_cell_magic(\"time\", \"\", \"foo()\\\\n\")'\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_magic_noop() -> None:\n+    src = \"ls = !ls\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_cell_magic_with_magic() -> None:\n+    src = \"%%t -n1\\nls =!ls\"\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = \"%%t -n1\\nls = !ls\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_nested() -> None:\n+    src = \"%%time\\n%%time\\n2+2\"\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = \"%%time\\n%%time\\n2 + 2\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_with_magic_noop() -> None:\n+    src = \"%%t -n1\\nls = !ls\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_automagic() -> None:\n+    src = \"pip install black\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_multiline_magic() -> None:\n+    src = \"%time 1 + \\\\\\n2\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_multiline_no_magic() -> None:\n+    src = \"1 + \\\\\\n2\"\n+    result = format_cell(src, fast=True, mode=JUPYTER_MODE)\n+    expected = \"1 + 2\"\n+    assert result == expected\n+\n+\n+def test_cell_magic_with_invalid_body() -> None:\n+    src = \"%%time\\nif True\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_empty_cell() -> None:\n+    src = \"\"\n+    with pytest.raises(NothingChanged):\n+        format_cell(src, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_entire_notebook_empty_metadata() -> None:\n+    with open(\n+        os.path.join(\"tests\", \"data\", \"notebook_empty_metadata.ipynb\"), \"rb\"\n+    ) as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    result = format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+    expected = (\n+        \"{\\n\"\n+        ' \"cells\": [\\n'\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {\\n'\n+        '    \"tags\": []\\n'\n+        \"   },\\n\"\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": [\\n'\n+        '    \"%%time\\\\n\",\\n'\n+        '    \"\\\\n\",\\n'\n+        '    \"print(\\\\\"foo\\\\\")\"\\n'\n+        \"   ]\\n\"\n+        \"  },\\n\"\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {},\\n'\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": []\\n'\n+        \"  }\\n\"\n+        \" ],\\n\"\n+        ' \"metadata\": {},\\n'\n+        ' \"nbformat\": 4,\\n'\n+        ' \"nbformat_minor\": 4\\n'\n+        \"}\\n\"\n+    )\n+    assert result == expected\n+\n+\n+def test_entire_notebook_trailing_newline() -> None:\n+    with open(\n+        os.path.join(\"tests\", \"data\", \"notebook_trailing_newline.ipynb\"), \"rb\"\n+    ) as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    result = format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+    expected = (\n+        \"{\\n\"\n+        ' \"cells\": [\\n'\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {\\n'\n+        '    \"tags\": []\\n'\n+        \"   },\\n\"\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": [\\n'\n+        '    \"%%time\\\\n\",\\n'\n+        '    \"\\\\n\",\\n'\n+        '    \"print(\\\\\"foo\\\\\")\"\\n'\n+        \"   ]\\n\"\n+        \"  },\\n\"\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {},\\n'\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": []\\n'\n+        \"  }\\n\"\n+        \" ],\\n\"\n+        ' \"metadata\": {\\n'\n+        '  \"interpreter\": {\\n'\n+        '   \"hash\": \"e758f3098b5b55f4d87fe30bbdc1367f20f246b483f96267ee70e6c40cb185d8\"\\n'  # noqa:B950\n+        \"  },\\n\"\n+        '  \"kernelspec\": {\\n'\n+        '   \"display_name\": \"Python 3.8.10 64-bit (\\'black\\': venv)\",\\n'\n+        '   \"name\": \"python3\"\\n'\n+        \"  },\\n\"\n+        '  \"language_info\": {\\n'\n+        '   \"name\": \"python\",\\n'\n+        '   \"version\": \"\"\\n'\n+        \"  }\\n\"\n+        \" },\\n\"\n+        ' \"nbformat\": 4,\\n'\n+        ' \"nbformat_minor\": 4\\n'\n+        \"}\\n\"\n+    )\n+    assert result == expected\n+\n+\n+def test_entire_notebook_no_trailing_newline() -> None:\n+    with open(\n+        os.path.join(\"tests\", \"data\", \"notebook_no_trailing_newline.ipynb\"), \"rb\"\n+    ) as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    result = format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+    expected = (\n+        \"{\\n\"\n+        ' \"cells\": [\\n'\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {\\n'\n+        '    \"tags\": []\\n'\n+        \"   },\\n\"\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": [\\n'\n+        '    \"%%time\\\\n\",\\n'\n+        '    \"\\\\n\",\\n'\n+        '    \"print(\\\\\"foo\\\\\")\"\\n'\n+        \"   ]\\n\"\n+        \"  },\\n\"\n+        \"  {\\n\"\n+        '   \"cell_type\": \"code\",\\n'\n+        '   \"execution_count\": null,\\n'\n+        '   \"metadata\": {},\\n'\n+        '   \"outputs\": [],\\n'\n+        '   \"source\": []\\n'\n+        \"  }\\n\"\n+        \" ],\\n\"\n+        ' \"metadata\": {\\n'\n+        '  \"interpreter\": {\\n'\n+        '   \"hash\": \"e758f3098b5b55f4d87fe30bbdc1367f20f246b483f96267ee70e6c40cb185d8\"\\n'  # noqa: B950\n+        \"  },\\n\"\n+        '  \"kernelspec\": {\\n'\n+        '   \"display_name\": \"Python 3.8.10 64-bit (\\'black\\': venv)\",\\n'\n+        '   \"name\": \"python3\"\\n'\n+        \"  },\\n\"\n+        '  \"language_info\": {\\n'\n+        '   \"name\": \"python\",\\n'\n+        '   \"version\": \"\"\\n'\n+        \"  }\\n\"\n+        \" },\\n\"\n+        ' \"nbformat\": 4,\\n'\n+        ' \"nbformat_minor\": 4\\n'\n+        \"}\"\n+    )\n+    assert result == expected\n+\n+\n+def test_entire_notebook_without_changes() -> None:\n+    with open(\n+        os.path.join(\"tests\", \"data\", \"notebook_without_changes.ipynb\"), \"rb\"\n+    ) as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    with pytest.raises(NothingChanged):\n+        format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_non_python_notebook() -> None:\n+    with open(os.path.join(\"tests\", \"data\", \"non_python_notebook.ipynb\"), \"rb\") as fd:\n+        content_bytes = fd.read()\n+    content = content_bytes.decode()\n+    with pytest.raises(NothingChanged):\n+        format_file_contents(content, fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_empty_string() -> None:\n+    with pytest.raises(NothingChanged):\n+        format_file_contents(\"\", fast=True, mode=JUPYTER_MODE)\n+\n+\n+def test_unparseable_notebook() -> None:\n+    msg = (\n+        r\"File 'tests[/\\\\]data[/\\\\]notebook_which_cant_be_parsed\\.ipynb' \"\n+        r\"cannot be parsed as valid Jupyter notebook\\.\"\n+    )\n+    with pytest.raises(ValueError, match=msg):\n+        format_file_in_place(\n+            pathlib.Path(\"tests\") / \"data/notebook_which_cant_be_parsed.ipynb\",\n+            fast=True,\n+            mode=JUPYTER_MODE,\n+        )\n+\n+\n+def test_ipynb_diff_with_change() -> None:\n+    result = runner.invoke(\n+        main,\n+        [\n+            os.path.join(\"tests\", \"data\", \"notebook_trailing_newline.ipynb\"),\n+            \"--diff\",\n+        ],\n+    )\n+    expected = \"@@ -1,3 +1,3 @@\\n %%time\\n \\n-print('foo')\\n\" '+print(\"foo\")\\n'\n+    assert expected in result.output\n+\n+\n+def test_ipynb_diff_with_no_change() -> None:\n+    result = runner.invoke(\n+        main,\n+        [\n+            os.path.join(\"tests\", \"data\", \"notebook_without_changes.ipynb\"),\n+            \"--diff\",\n+        ],\n+    )\n+    expected = \"1 file would be left unchanged.\"\n+    assert expected in result.output\n+\n+\n+def test_cache_isnt_written_if_no_jupyter_deps_single(\n+    monkeypatch: MonkeyPatch, tmpdir: tmpdir\n+) -> None:\n+    # Check that the cache isn't written to if Jupyter dependencies aren't installed.\n+    jupyter_dependencies_are_installed.cache_clear()\n+    nb = os.path.join(\"tests\", \"data\", \"notebook_trailing_newline.ipynb\")\n+    tmp_nb = tmpdir / \"notebook.ipynb\"\n+    with open(nb) as src, open(tmp_nb, \"w\") as dst:\n+        dst.write(src.read())\n+    monkeypatch.setattr(\n+        \"black.jupyter_dependencies_are_installed\", lambda verbose, quiet: False\n+    )\n+    result = runner.invoke(main, [str(tmpdir / \"notebook.ipynb\")])\n+    assert \"No Python files are present to be formatted. Nothing to do\" in result.output\n+    jupyter_dependencies_are_installed.cache_clear()\n+    monkeypatch.setattr(\n+        \"black.jupyter_dependencies_are_installed\", lambda verbose, quiet: True\n+    )\n+    result = runner.invoke(main, [str(tmpdir / \"notebook.ipynb\")])\n+    assert \"reformatted\" in result.output\n+\n+\n+def test_cache_isnt_written_if_no_jupyter_deps_many(",
      "comment": "Ah, what I meant was that it's running on a directory rather than on a single file - I've renamed it for clarity (as with the one below), thanks for pointing this out!",
      "comment_id": 680225257,
      "user": "MarcoGorelli",
      "created_at": "2021-07-30T21:23:40Z",
      "url": "https://github.com/psf/black/pull/2357#discussion_r680225257"
    },
    {
      "repo": "psf/black",
      "pr_number": 2431,
      "file_path": "src/black/brackets.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,7 +49,9 @@\n DOT_PRIORITY: Final = 1\n \n \n-class BracketMatchError(KeyError):\n+# Ideally this would be a subclass of KeyError, but mypyc doesn't like that.",
      "comment": "I don't think it really needs to be a subclass of KeyError. I say we just remove this comment and leave it a direct subclass of Exception.",
      "comment_id": 691365413,
      "user": "JelleZijlstra",
      "created_at": "2021-08-18T15:37:09Z",
      "url": "https://github.com/psf/black/pull/2431#discussion_r691365413"
    },
    {
      "repo": "psf/black",
      "pr_number": 2431,
      "file_path": "src/black/linegen.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -362,6 +365,11 @@ def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n                 line, line_length=mode.line_length, features=features\n             )\n \n+        # HACK: functions (like rhs) compiled by mypyc don't retain their __name__",
      "comment": "I guess it would be a bigger refactor but I'd like it better if we just stopped using `__name__`.",
      "comment_id": 691367047,
      "user": "JelleZijlstra",
      "created_at": "2021-08-18T15:38:26Z",
      "url": "https://github.com/psf/black/pull/2431#discussion_r691367047"
    },
    {
      "repo": "psf/black",
      "pr_number": 2431,
      "file_path": "src/black/strings.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,6 +152,11 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     return f\"{new_prefix}{match.group(2)}\"\n \n \n+@lru_cache(maxsize=256)",
      "comment": "Does this really help? `re.compile` already caches things internally I believe.",
      "comment_id": 691369479,
      "user": "JelleZijlstra",
      "created_at": "2021-08-18T15:40:15Z",
      "url": "https://github.com/psf/black/pull/2431#discussion_r691369479"
    },
    {
      "repo": "psf/black",
      "pr_number": 2431,
      "file_path": "src/black/linegen.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -362,6 +365,11 @@ def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n                 line, line_length=mode.line_length, features=features\n             )\n \n+        # HACK: functions (like rhs) compiled by mypyc don't retain their __name__",
      "comment": "Yeah, I'd prefer doing this later - tbh I'm a bit tired after all of work! I'll open an issue about this.",
      "comment_id": 691544580,
      "user": "ichard26",
      "created_at": "2021-08-18T19:30:10Z",
      "url": "https://github.com/psf/black/pull/2431#discussion_r691544580"
    },
    {
      "repo": "psf/black",
      "pr_number": 2431,
      "file_path": "src/black/strings.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,6 +152,11 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     return f\"{new_prefix}{match.group(2)}\"\n \n \n+@lru_cache(maxsize=256)",
      "comment": "Looking at the source and testing locally, I can confirm that both re and regex cache compiled patterns. Somehow I still observe a 8-9% speed up on that strings list literal file. Running this test script:\r\n```python\r\nimport time\r\nfrom functools import lru_cache\r\n\r\nimport re\r\nimport regex\r\n\r\n_cached_regex_compile = lru_cache(regex.compile)\r\n\r\n# This is *roughly* how many times regex.compile was called formatting strings-list.py\r\nloops = 410 \r\npattern = r\"\\s*\\t+\\s*(\\S)\"\r\n\r\nre.compile(pattern)\r\nregex.compile(pattern)\r\n\r\nt0 = time.perf_counter()\r\nfor i in range(1, loops + 1):\r\n    re.compile(pattern)\r\nelapsed = time.perf_counter() - t0\r\nprint(f\"{loops} cached compiles with re: {elapsed * 1000:.1f}ms\")\r\n\r\nt0 = time.perf_counter()\r\nfor i in range(1, loops + 1):\r\n    regex.compile(pattern)\r\nelapsed = time.perf_counter() - t0\r\nprint(f\"{loops} cached compiles with regex: {elapsed * 1000:.1f}ms\")\r\n\r\nt0 = time.perf_counter()\r\nfor i in range(1, loops + 1):\r\n    _cached_regex_compile(pattern)\r\nelapsed = time.perf_counter() - t0\r\nprint(f\"{loops} cached compiles with regex + lru_cache: {elapsed * 1000:.1f}ms\")\r\n```\r\nI get:\r\n- 410 cached compiles with re: 0.4ms\r\n- 410 cached compiles with regex: 1.6ms\r\n- 410 cached compiles with regex + lru_cache: 0.1ms\r\n\r\nSo it seems like this is the source of the slight speedup, but oddly enough this only accounts for ~half of the 8-9% speedup I saw for fmt-strings-list. Maybe the fact this script only repeatedly compiles one regex is why the delta isn't 1:1. For real life cases this speedup is probably minimal so I wouldn't mind reverting this to be less confusing :)",
      "comment_id": 691568236,
      "user": "ichard26",
      "created_at": "2021-08-18T20:08:56Z",
      "url": "https://github.com/psf/black/pull/2431#discussion_r691568236"
    },
    {
      "repo": "psf/black",
      "pr_number": 2431,
      "file_path": "src/black/strings.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,6 +152,11 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     return f\"{new_prefix}{match.group(2)}\"\n \n \n+@lru_cache(maxsize=256)",
      "comment": "Interesting, thanks for the extra information. I looked at `re.compile` and it calls a helper function (`_compile`) and does an `isinstance` call before looking at the cache, and the cache key is a tuple `type(pattern), pattern, flags`. I suppose that adds up to more overhead than whatever lru_cache does internally.",
      "comment_id": 691576743,
      "user": "JelleZijlstra",
      "created_at": "2021-08-18T20:22:51Z",
      "url": "https://github.com/psf/black/pull/2431#discussion_r691576743"
    },
    {
      "repo": "psf/black",
      "pr_number": 2431,
      "file_path": "src/black/parsing.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -79,7 +91,7 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n         src_txt += \"\\n\"\n \n     for grammar in get_grammars(set(target_versions)):\n-        drv = driver.Driver(grammar, pytree.convert)\n+        drv = driver.Driver(grammar)",
      "comment": "Ah yea the optimizations I made can be confusing! Profiling found that a lot of time parsing was spent in the Parser.push / Parser.shift methods so optimizing them was critical. Function lookups at runtime are expensive since calls must use the generic Python calling convention (involving a lookup + a call to the vectorcall API) (instead of being a direct C function call) so I wanted to avoid them. There's other reasons, but that's the main reason why.",
      "comment_id": 691580661,
      "user": "ichard26",
      "created_at": "2021-08-18T20:29:13Z",
      "url": "https://github.com/psf/black/pull/2431#discussion_r691580661"
    },
    {
      "repo": "psf/black",
      "pr_number": 4865,
      "file_path": "tests/data/cases/remove_parens_from_lhs.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,35 @@\n+# Remove unnecessary parentheses from LHS of assignments\n+\n+\n+def a():\n+    return [1, 2, 3]\n+\n+\n+# Single variable with unnecessary parentheses\n+b = a()[0]\n+\n+# Tuple unpacking with unnecessary parentheses\n+c, *_ = a()\n+\n+# These should not be changed - parentheses are necessary\n+(d,) = a()  # single-element tuple\n+e = (1 + 2) * 3  # RHS has precedence needs",
      "comment": "Yes, I think I might have done that, I have now replaced the formatted code with the unformatted version in the original issue.",
      "comment_id": 2559672290,
      "user": "Nikhil172913832",
      "created_at": "2025-11-25T11:39:23Z",
      "url": "https://github.com/psf/black/pull/4865#discussion_r2559672290"
    },
    {
      "repo": "psf/black",
      "pr_number": 4865,
      "file_path": "gallery/gallery.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,9 +103,7 @@ def download_and_extract(package: str, version: str | None, directory: Path) ->\n     return directory / result_dir\n \n \n-def get_package(\n-    package: str, version: str | None, directory: Path\n-) -> Path | None:\n+def get_package(package: str, version: str | None, directory: Path) -> Path | None:",
      "comment": "```suggestion\ndef get_package(\n    package: str, version: str | None, directory: Path\n) -> Path | None:\n```\n\nApparently this file isn't included in CI's formatted check; formatted it in #4867",
      "comment_id": 2561275453,
      "user": "cobaltt7",
      "created_at": "2025-11-25T20:13:30Z",
      "url": "https://github.com/psf/black/pull/4865#discussion_r2561275453"
    },
    {
      "repo": "psf/black",
      "pr_number": 4845,
      "file_path": "src/black/linegen.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -405,7 +405,27 @@ def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:\n         else:\n             is_fmt_off_block = False\n         if is_fmt_off_block:\n-            # This is a fmt:off/on block from normalize_fmt_off - append directly\n+            # This is a fmt:off/on block from normalize_fmt_off - we still need\n+            # to process any prefix comments (like markdown comments) but append\n+            # the fmt block itself directly to preserve its formatting\n+\n+            # Only process prefix comments if there actually is a prefix with comments\n+            fmt_directives = {\n+                'fmt: off', 'fmt:off', 'fmt: on', 'fmt:on',\n+                'yapf: disable', 'yapf: enable'\n+            }\n+            if leaf.prefix and any(\n+                line.strip().startswith('#')\n+                and line.strip().lstrip('#').strip() not in fmt_directives\n+                for line in leaf.prefix.split('\\n')\n+            ):",
      "comment": "Are we able to use `_contains_fmt_directive` from `comments.py` here?",
      "comment_id": 2532417472,
      "user": "cobaltt7",
      "created_at": "2025-11-17T01:39:59Z",
      "url": "https://github.com/psf/black/pull/4845#discussion_r2532417472"
    },
    {
      "repo": "psf/black",
      "pr_number": 4845,
      "file_path": "src/black/linegen.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -405,7 +405,27 @@ def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:\n         else:\n             is_fmt_off_block = False\n         if is_fmt_off_block:\n-            # This is a fmt:off/on block from normalize_fmt_off - append directly\n+            # This is a fmt:off/on block from normalize_fmt_off - we still need\n+            # to process any prefix comments (like markdown comments) but append\n+            # the fmt block itself directly to preserve its formatting\n+\n+            # Only process prefix comments if there actually is a prefix with comments\n+            fmt_directives = {\n+                'fmt: off', 'fmt:off', 'fmt: on', 'fmt:on',\n+                'yapf: disable', 'yapf: enable'\n+            }\n+            if leaf.prefix and any(\n+                line.strip().startswith('#')\n+                and line.strip().lstrip('#').strip() not in fmt_directives\n+                for line in leaf.prefix.split('\\n')\n+            ):",
      "comment": "Fixed :)\r\nAdded ```_contains_fmt_directive``` to imports from ```black.comments``` Replaced custom fmt_directives set with call to existing function",
      "comment_id": 2532672904,
      "user": "HWKDS",
      "created_at": "2025-11-17T04:38:32Z",
      "url": "https://github.com/psf/black/pull/4845#discussion_r2532672904"
    },
    {
      "repo": "psf/black",
      "pr_number": 4845,
      "file_path": "tests/data/cases/jupytext_markdown_fmt.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,51 @@\n+# Test that Jupytext markdown comments are preserved before fmt:off/on blocks\n+# %% [markdown]\n+\n+# fmt: off\n+# fmt: on\n+\n+# Also test with other comments\n+# Some comment\n+# %% [markdown]\n+# Another comment\n+\n+# fmt: off\n+x = 1\n+# fmt: on\n+\n+# Test multiple markdown comments\n+# %% [markdown]\n+# First markdown\n+# %% [code]\n+# Code cell\n+\n+# fmt: off\n+y = 2\n+# fmt: on\n+\n+# output\n+\n+# Test that Jupytext markdown comments are preserved before fmt:off/on blocks\n+# %% [markdown]\n+\n+# fmt: off\n+# fmt: on\n+\n+# Also test with other comments\n+# Some comment\n+# %% [markdown]\n+# Another comment\n+\n+# fmt: off\n+x = 1\n+# fmt: on\n+\n+# Test multiple markdown comments\n+# %% [markdown]\n+# First markdown\n+# %% [code]\n+# Code cell\n+\n+# fmt: off\n+y = 2\n+# fmt: on",
      "comment": "```suggestion\n\n```\n\nThe `output` section can be omitted to automatically assert no changes",
      "comment_id": 2551089715,
      "user": "cobaltt7",
      "created_at": "2025-11-21T22:07:07Z",
      "url": "https://github.com/psf/black/pull/4845#discussion_r2551089715"
    },
    {
      "repo": "psf/black",
      "pr_number": 4842,
      "file_path": "scripts/migrate-black.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,7 +40,7 @@ def blackify(base_branch: str, black_command: str, logger: logging.Logger) -> in\n \n     git(\"checkout\", base_branch, f\"-b{current_branch}-black\")\n \n-    for last_commit, commit in zip(commits, commits[1:]):\n+    for last_commit, commit in zip(commits, commits[1:], strict=True):",
      "comment": "Using `strict=True` with `zip(commits, commits[1:])` will raise a `ValueError` because these sequences have different lengths (N vs N-1). The `strict=True` parameter should be removed here, as the intention is to iterate over consecutive pairs of commits.\n```suggestion\n    for last_commit, commit in zip(commits, commits[1:]):\n```",
      "comment_id": 2524218481,
      "user": "Copilot",
      "created_at": "2025-11-13T16:51:58Z",
      "url": "https://github.com/psf/black/pull/4842#discussion_r2524218481"
    },
    {
      "repo": "psf/black",
      "pr_number": 4842,
      "file_path": "src/blib2to3/pytree.py",
      "line": 232,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,16 +232,16 @@ def get_suffix(self) -> str:\n class Node(Base):",
      "comment": "The class 'Node' does not override ['__eq__'](1), but adds the new attribute [type](2).\nThe class 'Node' does not override ['__eq__'](1), but adds the new attribute [children](3).\nThe class 'Node' does not override ['__eq__'](1), but adds the new attribute [prefix](4).\nThe class 'Node' does not override ['__eq__'](1), but adds the new attribute [fixers_applied](5).\nThe class 'Node' does not override ['__eq__'](1), but adds the new attribute [fixers_applied](6).\nThe class 'Node' does not override ['__eq__'](1), but adds the new attribute [prev_sibling_map](7).\nThe class 'Node' does not override ['__eq__'](1), but adds the new attribute [next_sibling_map](8).\nThe class 'Node' does not override ['__eq__'](1), but adds the new attribute [prev_sibling_map](9).\nThe class 'Node' does not override ['__eq__'](1), but adds the new attribute [next_sibling_map](10).",
      "comment_id": 2524218541,
      "user": "Copilot",
      "created_at": "2025-11-13T16:51:59Z",
      "url": "https://github.com/psf/black/pull/4842#discussion_r2524218541"
    },
    {
      "repo": "psf/black",
      "pr_number": 4842,
      "file_path": "scripts/migrate-black.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,7 +40,7 @@ def blackify(base_branch: str, black_command: str, logger: logging.Logger) -> in\n \n     git(\"checkout\", base_branch, f\"-b{current_branch}-black\")\n \n-    for last_commit, commit in zip(commits, commits[1:]):\n+    for last_commit, commit in zip(commits, commits[1:], strict=True):",
      "comment": "We can't remove it because Ruff's B905 demands something: https://docs.astral.sh/ruff/rules/zip-without-explicit-strict/\r\n\r\nThen it needs to be `strict=False`:\r\n\r\n```suggestion\r\n    for last_commit, commit in zip(commits, commits[1:], strict=False):\r\n```",
      "comment_id": 2524655758,
      "user": "hugovk",
      "created_at": "2025-11-13T19:19:55Z",
      "url": "https://github.com/psf/black/pull/4842#discussion_r2524655758"
    },
    {
      "repo": "psf/black",
      "pr_number": 4842,
      "file_path": "src/blib2to3/pgen2/driver.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,7 @@\n from contextlib import contextmanager\n from dataclasses import dataclass, field\n from logging import Logger\n-from typing import IO, Any, Optional, Union, cast\n+from typing import IO, Any, Union, cast",
      "comment": "Indeed it's not. I'm surprised a linter didn't find this, nor `import io` a few lines above.\r\n\r\n...\r\n\r\nAha, it's because of `exclude: ^src/blib2to3/` for Flake8 in pre-commit.\r\n\r\n```suggestion\r\nfrom typing import Any, Union, cast\r\n```",
      "comment_id": 2524685255,
      "user": "hugovk",
      "created_at": "2025-11-13T19:30:31Z",
      "url": "https://github.com/psf/black/pull/4842#discussion_r2524685255"
    },
    {
      "repo": "psf/black",
      "pr_number": 4842,
      "file_path": "src/blib2to3/pgen2/parse.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,7 +12,7 @@\n \n from collections.abc import Callable, Iterator\n from contextlib import contextmanager\n-from typing import TYPE_CHECKING, Any, Optional, Union, cast\n+from typing import TYPE_CHECKING, Any, Union, cast",
      "comment": "```suggestion\r\nfrom typing import TYPE_CHECKING, Union, cast\r\n```",
      "comment_id": 2524686650,
      "user": "hugovk",
      "created_at": "2025-11-13T19:31:03Z",
      "url": "https://github.com/psf/black/pull/4842#discussion_r2524686650"
    },
    {
      "repo": "psf/black",
      "pr_number": 4805,
      "file_path": "tests/data/cases/pep_750.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,7 @@\n+# flags: --minimum-version=3.14",
      "comment": "Totally random person here with T-String issues in black :)\r\n\r\nConsider adding test case for multi-line t-strings as well (as in t\"\"\" \"\"\"), because I am using some tools that have an issue specifically with this construction.",
      "comment_id": 2463885032,
      "user": "matgrioni",
      "created_at": "2025-10-26T15:41:03Z",
      "url": "https://github.com/psf/black/pull/4805#discussion_r2463885032"
    },
    {
      "repo": "psf/black",
      "pr_number": 4805,
      "file_path": "tests/data/cases/pep_750.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,7 @@\n+# flags: --minimum-version=3.14",
      "comment": "Will do! They do work just fine, I'm currently working on making t strings work inside f strings, but yes the test file needs a lot more cases which I plan on adding.",
      "comment_id": 2463885638,
      "user": "tusharsadhwani",
      "created_at": "2025-10-26T15:42:23Z",
      "url": "https://github.com/psf/black/pull/4805#discussion_r2463885638"
    },
    {
      "repo": "psf/black",
      "pr_number": 4774,
      "file_path": "src/blackd/client.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,94 @@\n+from typing import Optional\n+\n+import aiohttp\n+from aiohttp.typedefs import StrOrURL\n+\n+import black\n+\n+_DEFAULT_HEADERS = {\"Content-Type\": \"text/plain; charset=utf-8\"}\n+\n+\n+class BlackDClient:\n+    def __init__(\n+        self,\n+        url: StrOrURL = \"http://localhost:9090\",\n+        line_length: Optional[int] = None,\n+        skip_source_first_line: bool = False,\n+        skip_string_normalization: bool = False,\n+        skip_magic_trailing_comma: bool = False,\n+        preview: bool = False,\n+        fast: bool = False,\n+        python_variant: Optional[str] = None,\n+        diff: bool = False,\n+        headers: Optional[dict[str, str]] = None,\n+    ):\n+        \"\"\"\n+        Initialize a BlackDClient object.\n+        :param url: The URL of the BlackD server.\n+        :param line_length: The maximum line length.\n+            Corresponds to the ``--line-length`` CLI option.\n+        :param skip_source_first_line: True to skip the first line of the source.\n+            Corresponds to the ``--skip-string-normalization`` CLI option.",
      "comment": "The documentation for `skip_source_first_line` incorrectly references the `--skip-string-normalization` CLI option. It should reference the `--skip-source-first-line` CLI option.\n```suggestion\n            Corresponds to the ``--skip-source-first-line`` CLI option.\n```",
      "comment_id": 2424796729,
      "user": "Copilot",
      "created_at": "2025-10-12T19:29:34Z",
      "url": "https://github.com/psf/black/pull/4774#discussion_r2424796729"
    },
    {
      "repo": "psf/black",
      "pr_number": 4774,
      "file_path": "tests/test_blackd.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,3 +221,114 @@ async def test_single_character(self) -> None:\n         response = await self.client.post(\"/\", data=\"1\")\n         self.assertEqual(await response.text(), \"1\\n\")\n         self.assertEqual(response.status, 200)\n+\n+\n+@pytest.mark.blackd\n+class BlackDClientTestCase(AioHTTPTestCase):\n+    def tearDown(self) -> None:\n+        # Work around https://github.com/python/cpython/issues/124706\n+        gc.collect()\n+        super().tearDown()\n+\n+    async def get_application(self) -> web.Application:\n+        return blackd.make_app()\n+\n+    async def test_unformated_code(self) -> None:",
      "comment": "Corrected spelling of 'unformated' to 'unformatted'.\n```suggestion\n    async def test_unformatted_code(self) -> None:\n```",
      "comment_id": 2424796755,
      "user": "Copilot",
      "created_at": "2025-10-12T19:29:35Z",
      "url": "https://github.com/psf/black/pull/4774#discussion_r2424796755"
    },
    {
      "repo": "psf/black",
      "pr_number": 4774,
      "file_path": "tests/test_blackd.py",
      "line": 244,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,3 +221,114 @@ async def test_single_character(self) -> None:\n         response = await self.client.post(\"/\", data=\"1\")\n         self.assertEqual(await response.text(), \"1\\n\")\n         self.assertEqual(response.status, 200)\n+\n+\n+@pytest.mark.blackd\n+class BlackDClientTestCase(AioHTTPTestCase):\n+    def tearDown(self) -> None:\n+        # Work around https://github.com/python/cpython/issues/124706\n+        gc.collect()\n+        super().tearDown()\n+\n+    async def get_application(self) -> web.Application:\n+        return blackd.make_app()\n+\n+    async def test_unformated_code(self) -> None:\n+        client = blackd.client.BlackDClient(self.client.make_url(\"/\"))\n+        unformatted_code = \"def hello(): print('Hello, World!')\"\n+        expected = 'def hello():\\n    print(\"Hello, World!\")\\n'\n+        formatted_code = await client.format_code(unformatted_code)\n+\n+        self.assertEqual(formatted_code, expected)\n+\n+    async def test_formated_code(self) -> None:",
      "comment": "Corrected spelling of 'formated' to 'formatted'.\n```suggestion\n    async def test_formatted_code(self) -> None:\n```",
      "comment_id": 2424796768,
      "user": "Copilot",
      "created_at": "2025-10-12T19:29:35Z",
      "url": "https://github.com/psf/black/pull/4774#discussion_r2424796768"
    },
    {
      "repo": "psf/black",
      "pr_number": 4800,
      "file_path": "src/black/comments.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,6 +321,117 @@ def generate_ignored_nodes(\n             container = container.next_sibling\n \n \n+def _find_compound_statement_context(\n+    parent: Optional[LN],\n+) -> tuple[Optional[Node], Optional[Node]]:",
      "comment": "Do we need to return two items if the `compound_parent` always equals `suite_node.parent`? I feel like it's currently a little ambiguous what's being returned here and it could be simplified.",
      "comment_id": 2443489119,
      "user": "cobaltt7",
      "created_at": "2025-10-19T20:58:24Z",
      "url": "https://github.com/psf/black/pull/4800#discussion_r2443489119"
    },
    {
      "repo": "psf/black",
      "pr_number": 4800,
      "file_path": "src/black/comments.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,6 +321,117 @@ def generate_ignored_nodes(\n             container = container.next_sibling\n \n \n+def _find_compound_statement_context(\n+    parent: Optional[LN],\n+) -> tuple[Optional[Node], Optional[Node]]:\n+    \"\"\"Find compound statement and suite nodes for fmt: skip handling.\"\"\"\n+    if parent is None or parent.type != syms.simple_stmt:\n+        return None, None\n+\n+    # Case 1: simple_stmt -> suite -> compound_stmt (after reformatting)",
      "comment": "Could you update this comment to be more specific what this case looks like in the code being formatted? It's not immediately obvious to me from reading it.",
      "comment_id": 2443489415,
      "user": "cobaltt7",
      "created_at": "2025-10-19T20:59:09Z",
      "url": "https://github.com/psf/black/pull/4800#discussion_r2443489415"
    },
    {
      "repo": "psf/black",
      "pr_number": 4800,
      "file_path": "src/black/comments.py",
      "line": 375,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,6 +321,117 @@ def generate_ignored_nodes(\n             container = container.next_sibling\n \n \n+def _find_compound_statement_context(\n+    parent: Optional[LN],\n+) -> tuple[Optional[Node], Optional[Node]]:\n+    \"\"\"Find compound statement and suite nodes for fmt: skip handling.\"\"\"\n+    if parent is None or parent.type != syms.simple_stmt:\n+        return None, None\n+\n+    # Case 1: simple_stmt -> suite -> compound_stmt (after reformatting)\n+    if (\n+        parent.parent is not None\n+        and parent.parent.type == syms.suite\n+        and parent.parent.parent is not None\n+    ):\n+        assert isinstance(parent.parent, Node)\n+        suite_node = parent.parent\n+        assert isinstance(suite_node.parent, Node)\n+        compound_parent = suite_node.parent\n+        return compound_parent, suite_node\n+\n+    # Case 2: simple_stmt -> compound_stmt (original structure)\n+    compound_types = (\n+        syms.if_stmt,\n+        syms.while_stmt,\n+        syms.for_stmt,\n+        syms.try_stmt,\n+        syms.with_stmt,\n+        syms.funcdef,\n+        syms.classdef,\n+    )\n+    if parent.parent is not None and parent.parent.type in compound_types:\n+        assert isinstance(parent.parent, Node)\n+        compound_parent = parent.parent\n+        # In original single-line structure, the simple_stmt IS the body\n+        assert isinstance(parent, Node)  # simple_stmt is always a Node\n+        return compound_parent, parent\n+\n+    return None, None\n+\n+\n+def _get_compound_statement_header(\n+    compound_parent: Node, suite_node: Node, parent: LN\n+) -> list[LN]:\n+    \"\"\"Get header nodes for compound statement if it should be preserved.\"\"\"\n+    compound_types = (\n+        syms.if_stmt,\n+        syms.while_stmt,\n+        syms.for_stmt,\n+        syms.try_stmt,\n+        syms.with_stmt,\n+        syms.funcdef,\n+        syms.classdef,\n+    )",
      "comment": "Could `STATEMENT` from `nodes.py` be used? (Both here and above) It includes a few types that aren't included here, though. I'm not sure if that was an oversight, if they just aren't applicable here, or if it was intentional and they would cause issues.\n\nIf you do need this separate type, could it be brought to the top level (and possibly moving it to nodes.py itself) to avoid duplication?",
      "comment_id": 2443490995,
      "user": "cobaltt7",
      "created_at": "2025-10-19T21:02:49Z",
      "url": "https://github.com/psf/black/pull/4800#discussion_r2443490995"
    },
    {
      "repo": "psf/black",
      "pr_number": 4800,
      "file_path": "src/black/comments.py",
      "line": 381,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,6 +321,117 @@ def generate_ignored_nodes(\n             container = container.next_sibling\n \n \n+def _find_compound_statement_context(\n+    parent: Optional[LN],\n+) -> tuple[Optional[Node], Optional[Node]]:\n+    \"\"\"Find compound statement and suite nodes for fmt: skip handling.\"\"\"\n+    if parent is None or parent.type != syms.simple_stmt:\n+        return None, None\n+\n+    # Case 1: simple_stmt -> suite -> compound_stmt (after reformatting)\n+    if (\n+        parent.parent is not None\n+        and parent.parent.type == syms.suite\n+        and parent.parent.parent is not None\n+    ):\n+        assert isinstance(parent.parent, Node)\n+        suite_node = parent.parent\n+        assert isinstance(suite_node.parent, Node)\n+        compound_parent = suite_node.parent\n+        return compound_parent, suite_node\n+\n+    # Case 2: simple_stmt -> compound_stmt (original structure)\n+    compound_types = (\n+        syms.if_stmt,\n+        syms.while_stmt,\n+        syms.for_stmt,\n+        syms.try_stmt,\n+        syms.with_stmt,\n+        syms.funcdef,\n+        syms.classdef,\n+    )\n+    if parent.parent is not None and parent.parent.type in compound_types:\n+        assert isinstance(parent.parent, Node)\n+        compound_parent = parent.parent\n+        # In original single-line structure, the simple_stmt IS the body\n+        assert isinstance(parent, Node)  # simple_stmt is always a Node\n+        return compound_parent, parent\n+\n+    return None, None\n+\n+\n+def _get_compound_statement_header(\n+    compound_parent: Node, suite_node: Node, parent: LN\n+) -> list[LN]:\n+    \"\"\"Get header nodes for compound statement if it should be preserved.\"\"\"\n+    compound_types = (\n+        syms.if_stmt,\n+        syms.while_stmt,\n+        syms.for_stmt,\n+        syms.try_stmt,\n+        syms.with_stmt,\n+        syms.funcdef,\n+        syms.classdef,\n+    )\n+    if compound_parent.type not in compound_types:\n+        return []\n+\n+    # Check if the body contains semicolon-separated statements\n+    has_semicolon = False\n+    if suite_node.type == syms.suite:",
      "comment": "There are two `if`/`else`s checking `suite_node.type == syms.suite`. Is there a reason for them to be separated?",
      "comment_id": 2443492781,
      "user": "cobaltt7",
      "created_at": "2025-10-19T21:06:45Z",
      "url": "https://github.com/psf/black/pull/4800#discussion_r2443492781"
    },
    {
      "repo": "psf/black",
      "pr_number": 4803,
      "file_path": "src/black/__init__.py",
      "line": 514,
      "side": "RIGHT",
      "diff_hunk": "@@ -505,6 +505,15 @@ def validate_regex(\n     callback=read_pyproject_toml,\n     help=\"Read configuration options from a configuration file.\",\n )\n+@click.option(\n+    \"--no-cache\",\n+    is_flag=True,\n+    help=(\n+        \"Do not use the cache when formatting files. This forces Black to reformat all\"\n+        \" files and not skip any unchanged file Also prevents Black from updating the\"\n+        \" cache after formatting.\"",
      "comment": "Nitpick\n```suggestion\n        \"Skip reading and writing the cache, forcing Black to reformat all\"\n         \" included files.\"\n```",
      "comment_id": 2448001661,
      "user": "cobaltt7",
      "created_at": "2025-10-21T12:26:35Z",
      "url": "https://github.com/psf/black/pull/4803#discussion_r2448001661"
    },
    {
      "repo": "psf/black",
      "pr_number": 4803,
      "file_path": "tests/test_black.py",
      "line": 2236,
      "side": "RIGHT",
      "diff_hunk": "@@ -2233,6 +2233,24 @@ def test_no_cache_when_stdin(self) -> None:\n             cache_file = get_cache_file(mode)\n             assert not cache_file.exists()\n \n+    def test_no_cache_flag_prevents_writes(self) -> None:",
      "comment": "Could you also add a test for `format_many`?\n\nAlso, does this work when configured from `pyproject.toml`? I'm not sure how easy a test would be for that.",
      "comment_id": 2448008312,
      "user": "cobaltt7",
      "created_at": "2025-10-21T12:27:59Z",
      "url": "https://github.com/psf/black/pull/4803#discussion_r2448008312"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/comments.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,9 +160,18 @@ def make_comment(content: str) -> str:\n     if (\n         content\n         and content[0] == \"\\N{NO-BREAK SPACE}\"\n-        and not content.lstrip().startswith(\"type:\")\n+        and not is_type_comment_string(\"# \" + content.lstrip(), mode=mode)\n     ):\n         content = \" \" + content[1:]  # Replace NBSP by a simple space\n+    if (\n+        Preview.standardize_type_comments in mode\n+        and content\n+        and \"\\N{NO-BREAK SPACE}\" not in content\n+        and is_type_comment_string(\"# \" + content.lstrip(), mode=mode)",
      "comment": "```suggestion\r\n        and is_type_comment_string(\"# \" + content, mode=mode)\r\n```\r\n\r\nJust for the sake of conciseness - `.lstrip()` is already run within `is_type_comment_string()`\r\n\r\nI think it makes sense to keep it as-is on L163, since there we might still be on stable style and can't rely on `is_type_comment_string()` to strip it.",
      "comment_id": 2223946087,
      "user": "cobaltt7",
      "created_at": "2025-07-22T22:30:06Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2223946087"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/comments.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,9 +160,18 @@ def make_comment(content: str) -> str:\n     if (\n         content\n         and content[0] == \"\\N{NO-BREAK SPACE}\"\n-        and not content.lstrip().startswith(\"type:\")\n+        and not is_type_comment_string(\"# \" + content.lstrip(), mode=mode)\n     ):\n         content = \" \" + content[1:]  # Replace NBSP by a simple space\n+    if (\n+        Preview.standardize_type_comments in mode\n+        and content\n+        and \"\\N{NO-BREAK SPACE}\" not in content\n+        and is_type_comment_string(\"# \" + content.lstrip(), mode=mode)\n+    ):\n+        type_part, value_part = content.strip().split(\":\", 1)",
      "comment": "```suggestion\r\n        type_part, value_part = content.split(\":\", 1)\r\n```\r\nThe `.strip()` here is unnecessary as both parts will be stripped individually",
      "comment_id": 2223946778,
      "user": "cobaltt7",
      "created_at": "2025-07-22T22:30:48Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2223946778"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/mode.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,3 +286,18 @@ def get_cache_key(self) -> str:\n             features_and_magics,\n         ]\n         return \".\".join(parts)\n+\n+    def __hash__(self) -> int:",
      "comment": "Why is this necessary in the context of this PR? And as Jelle asked on #4467, could we instead make dataclass generate the hash method?",
      "comment_id": 2223951158,
      "user": "cobaltt7",
      "created_at": "2025-07-22T22:34:46Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2223951158"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/mode.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,3 +286,18 @@ def get_cache_key(self) -> str:\n             features_and_magics,\n         ]\n         return \".\".join(parts)\n+\n+    def __hash__(self) -> int:",
      "comment": "In [src/black/comments.py#L84](https://github.com/ranjodhsingh1729/black/blob/b7abcd43774514a50e14c609b6584d865c804742/src/black/comments.py#L84), adding mode as a parameter to an @lru_cache-decorated function caused it to be hashed \u2014 which is why Mode needed to be hashable.\r\n\r\nI initially tried converting the sets in Mode to frozensets, but if a regular set was passed in, it still raised a TypeError because the instance wasn\u2019t fully hashable. So to avoid a more intrusive change, I went with a custom `__hash__` implementation, similar to what was done in #4467.\r\n\r\nWhile revisiting this today, I came across [this StackOverflow thread](https://stackoverflow.com/questions/51199031/python-3-dataclass-initialization), which gave me the idea of using `__post_init__` along with `object.__setattr__` to convert passed-in sets to frozensets before any hashing occurs. (I have tested this and it works)\r\n\r\nIf you're okay with this approach, I can make the necessary changes and also address the extra strip() calls you pointed out.",
      "comment_id": 2224338596,
      "user": "ranjodhsingh1729",
      "created_at": "2025-07-23T04:49:15Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2224338596"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/mode.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,3 +286,18 @@ def get_cache_key(self) -> str:\n             features_and_magics,\n         ]\n         return \".\".join(parts)\n+\n+    def __hash__(self) -> int:",
      "comment": "It would be easier to remove `lru_cache` from `make_comment`, and either add manual coaching or create an internal function that doesn't take `mode` within that function and put the lru_cache on that instead.\n\nI don't think that method cares about every aspect of `mode` when it's doing the caching.",
      "comment_id": 2224349638,
      "user": "tusharsadhwani",
      "created_at": "2025-07-23T04:58:54Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2224349638"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/mode.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,3 +286,18 @@ def get_cache_key(self) -> str:\n             features_and_magics,\n         ]\n         return \".\".join(parts)\n+\n+    def __hash__(self) -> int:",
      "comment": "I'm good with either approach. That said, updating the `Mode` class does feel like a more future-proof solution\u2014if we ever need to pass mode into a cached function later on, we likely wouldn\u2019t need to change anything further.\r\n\r\nThat does make me curious though\u2014why isn\u2019t `mode` global? I\u2019m sure there\u2019s a good reason; it just hasn\u2019t clicked for me yet.",
      "comment_id": 2224432020,
      "user": "ranjodhsingh1729",
      "created_at": "2025-07-23T05:48:49Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2224432020"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/mode.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,3 +286,18 @@ def get_cache_key(self) -> str:\n             features_and_magics,\n         ]\n         return \".\".join(parts)\n+\n+    def __hash__(self) -> int:",
      "comment": "IMO adding `__hash__` is the best solution for being more future-proof and less intrusive.",
      "comment_id": 2226676820,
      "user": "cobaltt7",
      "created_at": "2025-07-23T20:58:46Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2226676820"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/mode.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,3 +286,18 @@ def get_cache_key(self) -> str:\n             features_and_magics,\n         ]\n         return \".\".join(parts)\n+\n+    def __hash__(self) -> int:",
      "comment": "This is how `Mode` would be modified :) if we use dataclass to generate hash:-\r\n\r\n```\r\n-@dataclass\r\n+@dataclass(frozen=True)\r\n class Mode:\r\n-    target_versions: set[TargetVersion] = field(default_factory=set)\r\n+    target_versions: frozenset[TargetVersion] = field(default_factory=frozenset)\r\n     line_length: int = DEFAULT_LINE_LENGTH\r\n     string_normalization: bool = True\r\n     is_pyi: bool = False\r\n     is_ipynb: bool = False\r\n     skip_source_first_line: bool = False\r\n     magic_trailing_comma: bool = True\r\n-    python_cell_magics: set[str] = field(default_factory=set)\r\n+    python_cell_magics: frozenset[str] = field(default_factory=frozenset)\r\n     preview: bool = False\r\n     unstable: bool = False\r\n-    enabled_features: set[Preview] = field(default_factory=set)\r\n+    enabled_features: frozenset[Preview] = field(default_factory=frozenset)\r\n+\r\n+    def __post_init__(self):\r\n+        object.__setattr__(self, 'target_versions', frozenset(self.target_versions))\r\n+        object.__setattr__(self, 'python_cell_magics', frozenset(self.python_cell_magics))\r\n+        object.__setattr__(self, 'enabled_features', frozenset(self.enabled_features))\r\n```\r\n\r\nRest of the class remains as is.\r\n",
      "comment_id": 2227158747,
      "user": "ranjodhsingh1729",
      "created_at": "2025-07-24T02:14:32Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2227158747"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/mode.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,3 +286,18 @@ def get_cache_key(self) -> str:\n             features_and_magics,\n         ]\n         return \".\".join(parts)\n+\n+    def __hash__(self) -> int:",
      "comment": "That also seems like a good approach - @tusharsadhwani what do you think?",
      "comment_id": 2228692993,
      "user": "cobaltt7",
      "created_at": "2025-07-24T14:28:31Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2228692993"
    },
    {
      "repo": "psf/black",
      "pr_number": 4645,
      "file_path": "src/black/mode.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,3 +286,18 @@ def get_cache_key(self) -> str:\n             features_and_magics,\n         ]\n         return \".\".join(parts)\n+\n+    def __hash__(self) -> int:",
      "comment": "Hi @tusharsadhwani\r\n\r\nI meant to ask this earlier but totally forgot \ud83d\ude05 \u2014  this doesn't warrant a immediate response, just something that crossed my mind.\r\n\r\nIf we put `@lru_cache` on an inner function that doesn\u2019t get `mode` passed explicitly and instead relies on it from the enclosing scope, wouldn\u2019t that cause issues if `mode` needed to change in the future? I know that currently `mode` doesn\u2019t change mid-execution, but if it ever did, wouldn\u2019t the cached function just keep returning the same result, ignoring the updated `mode`?\r\n\r\nIt seems like a sensible assumption to me that `mode` wouldn\u2019t need to change mid-execution, so would it maybe make more sense to just freeze it instead?\r\n\r\nI may be missing something. What do you think?",
      "comment_id": 2251778603,
      "user": "ranjodhsingh1729",
      "created_at": "2025-08-04T15:04:29Z",
      "url": "https://github.com/psf/black/pull/4645#discussion_r2251778603"
    },
    {
      "repo": "psf/black",
      "pr_number": 4777,
      "file_path": "src/black/linegen.py",
      "line": 839,
      "side": "RIGHT",
      "diff_hunk": "@@ -834,7 +834,10 @@ def left_hand_split(\n                 current_leaves = tail_leaves if body_leaves else head_leaves\n             current_leaves.append(leaf)\n             if current_leaves is head_leaves:\n-                if leaf.type == leaf_type:\n+                if leaf.type == leaf_type and (\n+                    Preview.fix_type_expansion_split\n+                    and not (leaf_type == token.LPAR and depth > 0)",
      "comment": "```suggestion\n                    Preview.fix_type_expansion_split not in mode\n                    or not (leaf_type == token.LPAR and depth > 0)\n```\nThat should be it, looks like the function already takes `mode` as a parameter, so we can just use it.",
      "comment_id": 2407572374,
      "user": "MeGaGiGaGon",
      "created_at": "2025-10-06T17:23:12Z",
      "url": "https://github.com/psf/black/pull/4777#discussion_r2407572374"
    },
    {
      "repo": "psf/black",
      "pr_number": 4750,
      "file_path": "scripts/generate_schema.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -38,6 +40,9 @@ def generate_schema_from_click(\n         result[name][\"description\"] = param.help\n \n         if param.default is not None and not param.multiple:\n+            if Version(imp_version(\"click\")) >= Version(\"8.3.0\"):",
      "comment": "Could also do something like `hasattr(click, \"_utils\") and hasattr(click._utils, \"UNSET\")`, though I guess it will still need a mypy type ignore. The current code is fine with me too.\r\n\r\nNormally I'd be concerned about breaking future users if click removes or moves the private object later, but this is just an internal script; if it breaks later we can just fix it and users won't be affected.",
      "comment_id": 2360971482,
      "user": "JelleZijlstra",
      "created_at": "2025-09-18T19:55:56Z",
      "url": "https://github.com/psf/black/pull/4750#discussion_r2360971482"
    },
    {
      "repo": "psf/black",
      "pr_number": 4750,
      "file_path": "scripts/generate_schema.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -38,6 +40,9 @@ def generate_schema_from_click(\n         result[name][\"description\"] = param.help\n \n         if param.default is not None and not param.multiple:\n+            if Version(imp_version(\"click\")) >= Version(\"8.3.0\"):",
      "comment": "I searched around for a while but I don't see a better way of doing it that doesn't involve a mypy ignore, so :shrug:.\r\nI like the current code since it says that whatever the problem/change is, it starts in click 8.3.0.",
      "comment_id": 2361209373,
      "user": "MeGaGiGaGon",
      "created_at": "2025-09-18T21:10:59Z",
      "url": "https://github.com/psf/black/pull/4750#discussion_r2361209373"
    },
    {
      "repo": "psf/black",
      "pr_number": 4699,
      "file_path": "src/black/__init__.py",
      "line": 1244,
      "side": "RIGHT",
      "diff_hunk": "@@ -1241,10 +1241,7 @@ def _format_str_once(\n     elt = EmptyLineTracker(mode=mode)\n     split_line_features = {\n         feature\n-        for feature in {\n-            Feature.TRAILING_COMMA_IN_CALL,\n-            Feature.TRAILING_COMMA_IN_DEF,\n-        }\n+        for feature in {Feature.TRAILING_COMMA_IN_CALL, Feature.TRAILING_COMMA_IN_DEF}",
      "comment": "Was this a result from the change in the PR? I would expect this code to remain unchanged because of the magic trailing comma.",
      "comment_id": 2199354449,
      "user": "JelleZijlstra",
      "created_at": "2025-07-11T02:37:38Z",
      "url": "https://github.com/psf/black/pull/4699#discussion_r2199354449"
    },
    {
      "repo": "psf/black",
      "pr_number": 4699,
      "file_path": "src/black/comments.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -446,9 +446,8 @@ def _contains_fmt_skip_comment(comment_line: str, mode: Mode) -> bool:\n         ],\n         *[\n             _COMMENT_PREFIX + comment.strip()\n-            for comment in comment_line.strip(_COMMENT_PREFIX).split(\n-                _COMMENT_LIST_SEPARATOR\n-            )\n+            for comment",
      "comment": "I sort of feel the old formatting was better here; \"for ... in\" feels like a single unit that shouldn't be split up.",
      "comment_id": 2199357819,
      "user": "JelleZijlstra",
      "created_at": "2025-07-11T02:40:53Z",
      "url": "https://github.com/psf/black/pull/4699#discussion_r2199357819"
    },
    {
      "repo": "psf/black",
      "pr_number": 4739,
      "file_path": "src/black/lines.py",
      "line": 490,
      "side": "RIGHT",
      "diff_hunk": "@@ -484,10 +484,10 @@ def __str__(self) -> str:\n         leaves = iter(self.leaves)\n         first = next(leaves)\n         res = f\"{first.prefix}{indent}{first.value}\"\n-        for leaf in leaves:\n-            res += str(leaf)\n-        for comment in itertools.chain.from_iterable(self.comments.values()):\n-            res += str(comment)\n+        res += ''.join(str(leaf) for leaf in leaves)\n+        comments_iter = itertools.chain.from_iterable(self.comments.values())\n+        comments = [str(comment) for comment in comments_iter]\n+        res += ''.join(comments)",
      "comment": "```suggestion\r\n        res += \"\".join(str(leaf) for leaf in leaves)\r\n        comments_iter = itertools.chain.from_iterable(self.comments.values())\r\n        comments = [str(comment) for comment in comments_iter]\r\n        res += \"\".join(comments)\r\n```\r\nThe Black style uses double quotes, which is the main source of CI failing\r\n(there's also a longstanding issue #4674 but that can be ignored)",
      "comment_id": 2312665967,
      "user": "cobaltt7",
      "created_at": "2025-08-31T23:07:00Z",
      "url": "https://github.com/psf/black/pull/4739#discussion_r2312665967"
    },
    {
      "repo": "psf/black",
      "pr_number": 4720,
      "file_path": "tests/data/cases/remove_braces_around_except.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+# flags: --preview --minimum-version=3.14",
      "comment": "Could we also have a test that also runs on --preview but with a lower minimum version to ensure no invalid code is created?",
      "comment_id": 2243154051,
      "user": "cobaltt7",
      "created_at": "2025-07-30T15:53:50Z",
      "url": "https://github.com/psf/black/pull/4720#discussion_r2243154051"
    },
    {
      "repo": "psf/black",
      "pr_number": 4720,
      "file_path": "tests/data/cases/remove_braces_around_except.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+# flags: --preview --minimum-version=3.14",
      "comment": "I've added a test, and it actually helped catch an issue \u2014 I suspect it's the same one causing the PyPy3.9 macOS build to fail, but I'll know for sure after pushing.\r\n\r\nThe problem is that when mode.target_versions is empty, supports_feature ends up evaluating to all([]), which returns True. That means supports_feature(empty_set, some_feature) incorrectly returns True, and Black removes parentheses from except types even on older Python versions. ~Modifying support_feature causes multiple tests to fail which seem to be relying this quirk so i just check before calling it.~ (Sorry it was something else)\r\n\r\nSince the only new syntax in Python 3.14 is the PEP 758, the only reliable way to detect target as python3.14 is by looking for unparenthesized except expressions. I've built a mechanism to do that \u2014 it detects one unparenthesized except expression and when in preview mode it unparenthesizes all. Should i add this?\r\n\r\nThe alternative would be to skip detection entirely and only apply the change when --target-version is explicitly set to 3.14 or higher. (which i was trying out when i stumbled on #4721).",
      "comment_id": 2244995368,
      "user": "ranjodhsingh1729",
      "created_at": "2025-07-31T10:30:21Z",
      "url": "https://github.com/psf/black/pull/4720#discussion_r2244995368"
    },
    {
      "repo": "psf/black",
      "pr_number": 4720,
      "file_path": "tests/data/cases/remove_braces_around_except.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+# flags: --preview --minimum-version=3.14",
      "comment": "All set! I've added the tests along with the detection mechanism. The previously failing checks\u2014the diff shades and the PyPy3.9 macOS build\u2014are now passing too.",
      "comment_id": 2249231102,
      "user": "ranjodhsingh1729",
      "created_at": "2025-08-02T12:26:39Z",
      "url": "https://github.com/psf/black/pull/4720#discussion_r2249231102"
    },
    {
      "repo": "psf/black",
      "pr_number": 4680,
      "file_path": "src/black/trans.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1307,7 +1307,7 @@ def _prefer_paren_wrap_match(LL: list[Leaf]) -> Optional[int]:\n def iter_fexpr_spans(s: str) -> Iterator[tuple[int, int]]:\n     \"\"\"\n     Yields spans corresponding to expressions in a given f-string.\n-    Spans are half-open ranges (left inclusive, right exclusive).\n+    Spans are closed ranges (left and right inclusive).",
      "comment": "this isn't right, the spans are half-open ranges. See e.g. https://github.com/psf/black/blob/8310a118ba6690fef55aaf8d67c967852b4c997e/tests/test_trans.py#L26",
      "comment_id": 2173635817,
      "user": "hauntsaninja",
      "created_at": "2025-06-29T07:49:16Z",
      "url": "https://github.com/psf/black/pull/4680#discussion_r2173635817"
    },
    {
      "repo": "psf/black",
      "pr_number": 4680,
      "file_path": "src/black/trans.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1307,7 +1307,7 @@ def _prefer_paren_wrap_match(LL: list[Leaf]) -> Optional[int]:\n def iter_fexpr_spans(s: str) -> Iterator[tuple[int, int]]:\n     \"\"\"\n     Yields spans corresponding to expressions in a given f-string.\n-    Spans are half-open ranges (left inclusive, right exclusive).\n+    Spans are closed ranges (left and right inclusive).",
      "comment": "```\r\n>>> \"\"\"text {var} text\"\"\"[5]\r\n'{'\r\n>>> \"\"\"text {var} text\"\"\"[10]\r\n' '\r\n>>> \"\"\"text {var} text\"\"\"[5:10]\r\n'{var}'\r\n```",
      "comment_id": 2173637144,
      "user": "hauntsaninja",
      "created_at": "2025-06-29T07:53:32Z",
      "url": "https://github.com/psf/black/pull/4680#discussion_r2173637144"
    },
    {
      "repo": "psf/black",
      "pr_number": 4680,
      "file_path": "src/black/trans.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1307,7 +1307,7 @@ def _prefer_paren_wrap_match(LL: list[Leaf]) -> Optional[int]:\n def iter_fexpr_spans(s: str) -> Iterator[tuple[int, int]]:\n     \"\"\"\n     Yields spans corresponding to expressions in a given f-string.\n-    Spans are half-open ranges (left inclusive, right exclusive).\n+    Spans are closed ranges (left and right inclusive).",
      "comment": "Looks like I also got confused by the ranges \ud83d\ude13 fixed",
      "comment_id": 2173824627,
      "user": "MeGaGiGaGon",
      "created_at": "2025-06-29T16:36:12Z",
      "url": "https://github.com/psf/black/pull/4680#discussion_r2173824627"
    },
    {
      "repo": "psf/black",
      "pr_number": 4694,
      "file_path": "src/black/linegen.py",
      "line": 576,
      "side": "LEFT",
      "diff_hunk": "@@ -573,31 +573,30 @@ def __post_init__(self) -> None:\n         self.current_line = Line(mode=self.mode)\n \n         v = self.visit_stmt\n-        \u00d8: set[str] = set()",
      "comment": "Let's keep this, we've refused several PRs getting rid of it. Using Unicode identifiers helps force the ecosystem to support them.",
      "comment_id": 2145080260,
      "user": "JelleZijlstra",
      "created_at": "2025-06-13T13:19:25Z",
      "url": "https://github.com/psf/black/pull/4694#discussion_r2145080260"
    },
    {
      "repo": "psf/black",
      "pr_number": 4694,
      "file_path": "src/black/strings.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -355,7 +355,7 @@ def char_width(char: str) -> int:\n         elif codepoint > end_codepoint:\n             lowest = idx + 1\n         else:\n-            return 0 if width < 0 else width\n+            return max(width, 0)",
      "comment": "This is likely slower than the old code though I don't know whether it matters. I do believe we call this function a lot though.",
      "comment_id": 2145081900,
      "user": "JelleZijlstra",
      "created_at": "2025-06-13T13:20:20Z",
      "url": "https://github.com/psf/black/pull/4694#discussion_r2145081900"
    },
    {
      "repo": "psf/black",
      "pr_number": 4694,
      "file_path": "src/black/linegen.py",
      "line": 576,
      "side": "LEFT",
      "diff_hunk": "@@ -573,31 +573,30 @@ def __post_init__(self) -> None:\n         self.current_line = Line(mode=self.mode)\n \n         v = self.visit_stmt\n-        \u00d8: set[str] = set()",
      "comment": "Oops, I didn't know. Sounds good in that case, reverted",
      "comment_id": 2145311476,
      "user": "MeGaGiGaGon",
      "created_at": "2025-06-13T15:13:40Z",
      "url": "https://github.com/psf/black/pull/4694#discussion_r2145311476"
    },
    {
      "repo": "psf/black",
      "pr_number": 4694,
      "file_path": "src/black/strings.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -355,7 +355,7 @@ def char_width(char: str) -> int:\n         elif codepoint > end_codepoint:\n             lowest = idx + 1\n         else:\n-            return 0 if width < 0 else width\n+            return max(width, 0)",
      "comment": "Sounds good, this change was on the edge of inclusion anyways, so reverted.",
      "comment_id": 2145312326,
      "user": "MeGaGiGaGon",
      "created_at": "2025-06-13T15:14:12Z",
      "url": "https://github.com/psf/black/pull/4694#discussion_r2145312326"
    },
    {
      "repo": "psf/black",
      "pr_number": 4663,
      "file_path": "tests/test_black.py",
      "line": 2067,
      "side": "RIGHT",
      "diff_hunk": "@@ -2064,6 +2064,20 @@ def test_lines_with_leading_tabs_expanded(self) -> None:\n         assert lines_with_leading_tabs_expanded(\"\\t\\tx\") == [f\"{tab}{tab}x\"]\n         assert lines_with_leading_tabs_expanded(\"\\tx\\n  y\") == [f\"{tab}x\", \"  y\"]\n \n+    def test_carrige_return_edge_cases(self) -> None:",
      "comment": "```suggestion\r\n    def test_carriage_return_edge_cases(self) -> None:\r\n```",
      "comment_id": 2075575280,
      "user": "JelleZijlstra",
      "created_at": "2025-05-06T14:13:29Z",
      "url": "https://github.com/psf/black/pull/4663#discussion_r2075575280"
    },
    {
      "repo": "psf/black",
      "pr_number": 4685,
      "file_path": "src/blib2to3/pgen2/driver.py",
      "line": 153,
      "side": "LEFT",
      "diff_hunk": "@@ -149,9 +149,7 @@ def parse_tokens(self, tokens: Iterable[TokenInfo], debug: bool = False) -> NL:\n                 type = grammar.opmap[value]\n             if debug:\n                 assert type is not None\n-                self.logger.debug(\n-                    \"%s %r (prefix=%r)\", token.tok_name[type], value, prefix",
      "comment": "This is better to keep as is, since the log probably won't be executed and the previous code avoids creating the string.",
      "comment_id": 2131115531,
      "user": "JelleZijlstra",
      "created_at": "2025-06-06T00:37:56Z",
      "url": "https://github.com/psf/black/pull/4685#discussion_r2131115531"
    },
    {
      "repo": "psf/black",
      "pr_number": 4685,
      "file_path": "src/blib2to3/pgen2/driver.py",
      "line": 153,
      "side": "LEFT",
      "diff_hunk": "@@ -149,9 +149,7 @@ def parse_tokens(self, tokens: Iterable[TokenInfo], debug: bool = False) -> NL:\n                 type = grammar.opmap[value]\n             if debug:\n                 assert type is not None\n-                self.logger.debug(\n-                    \"%s %r (prefix=%r)\", token.tok_name[type], value, prefix",
      "comment": "I did consider that, but since it\u2019s behind the `if debug:` my thoughts were the log level would always be at debug if that was reached - is that not right?",
      "comment_id": 2131132341,
      "user": "MeGaGiGaGon",
      "created_at": "2025-06-06T00:42:57Z",
      "url": "https://github.com/psf/black/pull/4685#discussion_r2131132341"
    },
    {
      "repo": "psf/black",
      "pr_number": 4685,
      "file_path": "src/blib2to3/pgen2/driver.py",
      "line": 153,
      "side": "LEFT",
      "diff_hunk": "@@ -149,9 +149,7 @@ def parse_tokens(self, tokens: Iterable[TokenInfo], debug: bool = False) -> NL:\n                 type = grammar.opmap[value]\n             if debug:\n                 assert type is not None\n-                self.logger.debug(\n-                    \"%s %r (prefix=%r)\", token.tok_name[type], value, prefix",
      "comment": "I think we always pass debug as True, look in `black/parsing.py` for the two calls to `parse_string`.\r\n\r\nWhich is also questionable, maybe we should change that and get some perf win.",
      "comment_id": 2131236491,
      "user": "JelleZijlstra",
      "created_at": "2025-06-06T01:15:54Z",
      "url": "https://github.com/psf/black/pull/4685#discussion_r2131236491"
    },
    {
      "repo": "psf/black",
      "pr_number": 4685,
      "file_path": "src/blib2to3/pgen2/driver.py",
      "line": 153,
      "side": "LEFT",
      "diff_hunk": "@@ -149,9 +149,7 @@ def parse_tokens(self, tokens: Iterable[TokenInfo], debug: bool = False) -> NL:\n                 type = grammar.opmap[value]\n             if debug:\n                 assert type is not None\n-                self.logger.debug(\n-                    \"%s %r (prefix=%r)\", token.tok_name[type], value, prefix",
      "comment": "Hm, just a guess but since it uses the logger instead of print is that so that the log level can deal with it? But another question: is there even a way for the user to get that output? Since I've never been able to get it to output even with like `-v`",
      "comment_id": 2131254295,
      "user": "MeGaGiGaGon",
      "created_at": "2025-06-06T01:22:04Z",
      "url": "https://github.com/psf/black/pull/4685#discussion_r2131254295"
    },
    {
      "repo": "psf/black",
      "pr_number": 4685,
      "file_path": "src/blib2to3/pgen2/driver.py",
      "line": 153,
      "side": "LEFT",
      "diff_hunk": "@@ -149,9 +149,7 @@ def parse_tokens(self, tokens: Iterable[TokenInfo], debug: bool = False) -> NL:\n                 type = grammar.opmap[value]\n             if debug:\n                 assert type is not None\n-                self.logger.debug(\n-                    \"%s %r (prefix=%r)\", token.tok_name[type], value, prefix",
      "comment": "Yeah I don't think so, you'd need to manually grab the blib2to3 logger and set the log level probably. I think this code is just useless.\r\n\r\nMaybe in a separate PR you can make it so parsing.py stops passing True for this debug argument.",
      "comment_id": 2131260517,
      "user": "JelleZijlstra",
      "created_at": "2025-06-06T01:24:15Z",
      "url": "https://github.com/psf/black/pull/4685#discussion_r2131260517"
    },
    {
      "repo": "psf/black",
      "pr_number": 4673,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,7 +113,17 @@ def transform_whitespace(\n         and prev_token.type not in (TokenType.nl, TokenType.newline)\n     ):\n         token_str = source[token.start_index : token.end_index]\n-        if token_str.startswith(\"\\\\\\n\"):\n+        if token_str.startswith(\"\\\\\\r\\n\"):",
      "comment": "Could you add a unit test? Probably something like `black.format_str(\"\\\\\\r\\n\")` and assert it behaves sanely.",
      "comment_id": 2117191140,
      "user": "JelleZijlstra",
      "created_at": "2025-05-31T04:00:20Z",
      "url": "https://github.com/psf/black/pull/4673#discussion_r2117191140"
    },
    {
      "repo": "psf/black",
      "pr_number": 4214,
      "file_path": "tests/data/cases/remove_redundant_parens_in_case_guard.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,24 @@\n+# flags: --minimum-version=3.10 --preview\n+\n+match 1:\n+    case _ if (True):\n+        pass\n+\n+\n+match 1:\n+    case _ if (\n+        True",
      "comment": "Add tests with a comment inside the parentheses in various places",
      "comment_id": 1480389574,
      "user": "JelleZijlstra",
      "created_at": "2024-02-06T18:42:23Z",
      "url": "https://github.com/psf/black/pull/4214#discussion_r1480389574"
    },
    {
      "repo": "psf/black",
      "pr_number": 4646,
      "file_path": "tests/data/cases/context_managers_39.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,6 +89,26 @@ async def func():\n with (x, y) as z:\n     pass\n \n+\n+# don't remove the brackets here, it changes the meaning of the code.\n+# even tough the code will always trigger a runtime error",
      "comment": "```suggestion\r\n# even though the code will always trigger a runtime error\r\n```",
      "comment_id": 2034386546,
      "user": "JelleZijlstra",
      "created_at": "2025-04-09T03:38:46Z",
      "url": "https://github.com/psf/black/pull/4646#discussion_r2034386546"
    },
    {
      "repo": "psf/black",
      "pr_number": 4646,
      "file_path": "tests/data/cases/context_managers_39.py",
      "line": 208,
      "side": "RIGHT",
      "diff_hunk": "@@ -182,3 +202,23 @@ async def func():\n # don't remove the brackets here, it changes the meaning of the code.\n with (x, y) as z:\n     pass\n+\n+\n+# don't remove the brackets here, it changes the meaning of the code.\n+# even tough the code will always trigger a runtime error",
      "comment": "```suggestion\r\n# even though the code will always trigger a runtime error\r\n```",
      "comment_id": 2034396806,
      "user": "JelleZijlstra",
      "created_at": "2025-04-09T03:55:11Z",
      "url": "https://github.com/psf/black/pull/4646#discussion_r2034396806"
    },
    {
      "repo": "psf/black",
      "pr_number": 4634,
      "file_path": "tests/data/cases/pep_572_py39.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,3 +5,7 @@\n # We better not remove the parentheses here (since it's a 3.10 feature)\n x[(a := 1)]\n x[(a := 1), (b := 3)]\n+\n+# don't remove the brackets here, it changes the meaning of the code.",
      "comment": "This test seems like the wrong place, it's about PEP 572 (walrus expressions). Maybe move it to one of the `context_managers_*` tests.",
      "comment_id": 2022108248,
      "user": "JelleZijlstra",
      "created_at": "2025-04-01T04:11:29Z",
      "url": "https://github.com/psf/black/pull/4634#discussion_r2022108248"
    },
    {
      "repo": "psf/black",
      "pr_number": 4536,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,1070 +43,218 @@\n     FSTRING_MIDDLE,\n     FSTRING_START,\n     INDENT,\n-    LBRACE,\n     NAME,\n     NEWLINE,\n     NL,\n     NUMBER,\n     OP,\n-    RBRACE,\n     STRING,\n     tok_name,\n )\n \n __author__ = \"Ka-Ping Yee <ping@lfw.org>\"\n __credits__ = \"GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip Montanaro\"\n \n-import re\n-from codecs import BOM_UTF8, lookup\n+import pytokens\n+from pytokens import TokenType\n \n-from . import token\n+from . import token as _token\n \n-__all__ = [x for x in dir(token) if x[0] != \"_\"] + [\n+__all__ = [x for x in dir(_token) if x[0] != \"_\"] + [\n     \"tokenize\",\n     \"generate_tokens\",\n     \"untokenize\",\n ]\n-del token\n-\n-\n-def group(*choices: str) -> str:\n-    return \"(\" + \"|\".join(choices) + \")\"\n-\n-\n-def any(*choices: str) -> str:\n-    return group(*choices) + \"*\"\n-\n-\n-def maybe(*choices: str) -> str:\n-    return group(*choices) + \"?\"\n-\n-\n-def _combinations(*l: str) -> set[str]:\n-    return {x + y for x in l for y in l + (\"\",) if x.casefold() != y.casefold()}\n-\n-\n-Whitespace = r\"[ \\f\\t]*\"\n-Comment = r\"#[^\\r\\n]*\"\n-Ignore = Whitespace + any(r\"\\\\\\r?\\n\" + Whitespace) + maybe(Comment)\n-Name = (  # this is invalid but it's fine because Name comes after Number in all groups\n-    r\"[^\\s#\\(\\)\\[\\]\\{\\}+\\-*/!@$%^&=|;:'\\\",\\.<>/?`~\\\\]+\"\n-)\n-\n-Binnumber = r\"0[bB]_?[01]+(?:_[01]+)*\"\n-Hexnumber = r\"0[xX]_?[\\da-fA-F]+(?:_[\\da-fA-F]+)*[lL]?\"\n-Octnumber = r\"0[oO]?_?[0-7]+(?:_[0-7]+)*[lL]?\"\n-Decnumber = group(r\"[1-9]\\d*(?:_\\d+)*[lL]?\", \"0[lL]?\")\n-Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber)\n-Exponent = r\"[eE][-+]?\\d+(?:_\\d+)*\"\n-Pointfloat = group(r\"\\d+(?:_\\d+)*\\.(?:\\d+(?:_\\d+)*)?\", r\"\\.\\d+(?:_\\d+)*\") + maybe(\n-    Exponent\n-)\n-Expfloat = r\"\\d+(?:_\\d+)*\" + Exponent\n-Floatnumber = group(Pointfloat, Expfloat)\n-Imagnumber = group(r\"\\d+(?:_\\d+)*[jJ]\", Floatnumber + r\"[jJ]\")\n-Number = group(Imagnumber, Floatnumber, Intnumber)\n-\n-# Tail end of ' string.\n-Single = r\"(?:\\\\.|[^'\\\\])*'\"\n-# Tail end of \" string.\n-Double = r'(?:\\\\.|[^\"\\\\])*\"'\n-# Tail end of ''' string.\n-Single3 = r\"(?:\\\\.|'(?!'')|[^'\\\\])*'''\"\n-# Tail end of \"\"\" string.\n-Double3 = r'(?:\\\\.|\"(?!\"\")|[^\"\\\\])*\"\"\"'\n-_litprefix = r\"(?:[uUrRbB]|[rR][bB]|[bBuU][rR])?\"\n-_fstringlitprefix = r\"(?:rF|FR|Fr|fr|RF|F|rf|f|Rf|fR)\"\n-Triple = group(\n-    _litprefix + \"'''\",\n-    _litprefix + '\"\"\"',\n-    _fstringlitprefix + '\"\"\"',\n-    _fstringlitprefix + \"'''\",\n-)\n-\n-# beginning of a single quoted f-string. must not end with `{{` or `\\N{`\n-SingleLbrace = r\"(?:\\\\N{|{{|\\\\'|[^\\n'{])*(?<!\\\\N)({)(?!{)\"\n-DoubleLbrace = r'(?:\\\\N{|{{|\\\\\"|[^\\n\"{])*(?<!\\\\N)({)(?!{)'\n-\n-# beginning of a triple quoted f-string. must not end with `{{` or `\\N{`\n-Single3Lbrace = r\"(?:\\\\N{|{{|\\\\'|'(?!'')|[^'{])*(?<!\\\\N){(?!{)\"\n-Double3Lbrace = r'(?:\\\\N{|{{|\\\\\"|\"(?!\"\")|[^\"{])*(?<!\\\\N){(?!{)'\n-\n-# ! format specifier inside an fstring brace, ensure it's not a `!=` token\n-Bang = Whitespace + group(\"!\") + r\"(?!=)\"\n-bang = re.compile(Bang)\n-Colon = Whitespace + group(\":\")\n-colon = re.compile(Colon)\n-\n-FstringMiddleAfterColon = group(Whitespace + r\".*?\") + group(\"{\", \"}\")\n-fstring_middle_after_colon = re.compile(FstringMiddleAfterColon)\n-\n-# Because of leftmost-then-longest match semantics, be sure to put the\n-# longest operators first (e.g., if = came before ==, == would get\n-# recognized as two instances of =).\n-Operator = group(\n-    r\"\\*\\*=?\",\n-    r\">>=?\",\n-    r\"<<=?\",\n-    r\"<>\",\n-    r\"!=\",\n-    r\"//=?\",\n-    r\"->\",\n-    r\"[+\\-*/%&@|^=<>:]=?\",\n-    r\"~\",\n-)\n-\n-Bracket = \"[][(){}]\"\n-Special = group(r\"\\r?\\n\", r\"[:;.,`@]\")\n-Funny = group(Operator, Bracket, Special)\n-\n-_string_middle_single = r\"(?:[^\\n'\\\\]|\\\\.)*\"\n-_string_middle_double = r'(?:[^\\n\"\\\\]|\\\\.)*'\n-\n-# FSTRING_MIDDLE and LBRACE, must not end with a `{{` or `\\N{`\n-_fstring_middle_single = SingleLbrace\n-_fstring_middle_double = DoubleLbrace\n-\n-# First (or only) line of ' or \" string.\n-ContStr = group(\n-    _litprefix + \"'\" + _string_middle_single + group(\"'\", r\"\\\\\\r?\\n\"),\n-    _litprefix + '\"' + _string_middle_double + group('\"', r\"\\\\\\r?\\n\"),\n-    group(_fstringlitprefix + \"'\") + _fstring_middle_single,\n-    group(_fstringlitprefix + '\"') + _fstring_middle_double,\n-    group(_fstringlitprefix + \"'\") + _string_middle_single + group(\"'\", r\"\\\\\\r?\\n\"),\n-    group(_fstringlitprefix + '\"') + _string_middle_double + group('\"', r\"\\\\\\r?\\n\"),\n-)\n-PseudoExtras = group(r\"\\\\\\r?\\n\", Comment, Triple)\n-PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n-\n-pseudoprog: Final = re.compile(PseudoToken, re.UNICODE)\n-\n-singleprog = re.compile(Single)\n-singleprog_plus_lbrace = re.compile(group(SingleLbrace, Single))\n-doubleprog = re.compile(Double)\n-doubleprog_plus_lbrace = re.compile(group(DoubleLbrace, Double))\n-\n-single3prog = re.compile(Single3)\n-single3prog_plus_lbrace = re.compile(group(Single3Lbrace, Single3))\n-double3prog = re.compile(Double3)\n-double3prog_plus_lbrace = re.compile(group(Double3Lbrace, Double3))\n-\n-_strprefixes = _combinations(\"r\", \"R\", \"b\", \"B\") | {\"u\", \"U\", \"ur\", \"uR\", \"Ur\", \"UR\"}\n-_fstring_prefixes = _combinations(\"r\", \"R\", \"f\", \"F\") - {\"r\", \"R\"}\n-\n-endprogs: Final = {\n-    \"'\": singleprog,\n-    '\"': doubleprog,\n-    \"'''\": single3prog,\n-    '\"\"\"': double3prog,\n-    **{f\"{prefix}'\": singleprog for prefix in _strprefixes},\n-    **{f'{prefix}\"': doubleprog for prefix in _strprefixes},\n-    **{f\"{prefix}'\": singleprog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f'{prefix}\"': doubleprog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f\"{prefix}'''\": single3prog for prefix in _strprefixes},\n-    **{f'{prefix}\"\"\"': double3prog for prefix in _strprefixes},\n-    **{f\"{prefix}'''\": single3prog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f'{prefix}\"\"\"': double3prog_plus_lbrace for prefix in _fstring_prefixes},\n-}\n-\n-triple_quoted: Final = (\n-    {\"'''\", '\"\"\"'}\n-    | {f\"{prefix}'''\" for prefix in _strprefixes | _fstring_prefixes}\n-    | {f'{prefix}\"\"\"' for prefix in _strprefixes | _fstring_prefixes}\n-)\n-single_quoted: Final = (\n-    {\"'\", '\"'}\n-    | {f\"{prefix}'\" for prefix in _strprefixes | _fstring_prefixes}\n-    | {f'{prefix}\"' for prefix in _strprefixes | _fstring_prefixes}\n-)\n-fstring_prefix: Final = tuple(\n-    {f\"{prefix}'\" for prefix in _fstring_prefixes}\n-    | {f'{prefix}\"' for prefix in _fstring_prefixes}\n-    | {f\"{prefix}'''\" for prefix in _fstring_prefixes}\n-    | {f'{prefix}\"\"\"' for prefix in _fstring_prefixes}\n-)\n-\n-tabsize = 8\n-\n-\n-class TokenError(Exception):\n-    pass\n-\n-\n-class StopTokenizing(Exception):\n-    pass\n-\n+del _token\n \n Coord = tuple[int, int]\n+TokenInfo = tuple[int, str, Coord, Coord, str]\n+\n+TOKEN_TYPE_MAP = {\n+    TokenType.indent: INDENT,\n+    TokenType.dedent: DEDENT,\n+    TokenType.newline: NEWLINE,\n+    TokenType.nl: NL,\n+    TokenType.comment: COMMENT,\n+    TokenType.semicolon: OP,\n+    TokenType.lparen: OP,\n+    TokenType.rparen: OP,\n+    TokenType.lbracket: OP,\n+    TokenType.rbracket: OP,\n+    TokenType.lbrace: OP,\n+    TokenType.rbrace: OP,\n+    TokenType.colon: OP,\n+    TokenType.op: OP,\n+    TokenType.identifier: NAME,\n+    TokenType.number: NUMBER,\n+    TokenType.string: STRING,\n+    TokenType.fstring_start: FSTRING_START,\n+    TokenType.fstring_middle: FSTRING_MIDDLE,\n+    TokenType.fstring_end: FSTRING_END,\n+    TokenType.endmarker: ENDMARKER,\n+}\n \n \n-def printtoken(\n-    type: int, token: str, srow_col: Coord, erow_col: Coord, line: str\n-) -> None:  # for testing\n-    (srow, scol) = srow_col\n-    (erow, ecol) = erow_col\n-    print(\n-        \"%d,%d-%d,%d:\\t%s\\t%s\" % (srow, scol, erow, ecol, tok_name[type], repr(token))\n-    )\n-\n-\n-TokenEater = Callable[[int, str, Coord, Coord, str], None]\n-\n-\n-def tokenize(readline: Callable[[], str], tokeneater: TokenEater = printtoken) -> None:\n-    \"\"\"\n-    The tokenize() function accepts two parameters: one representing the\n-    input stream, and one providing an output mechanism for tokenize().\n+class TokenError(Exception): ...\n \n-    The first parameter, readline, must be a callable object which provides\n-    the same interface as the readline() method of built-in file objects.\n-    Each call to the function should return one line of input as a string.\n \n-    The second parameter, tokeneater, must also be a callable object. It is\n-    called once for each token, with five arguments, corresponding to the\n-    tuples generated by generate_tokens().\n+def transform_whitespace(\n+    token: pytokens.Token, source: str, prev_token: Optional[pytokens.Token]\n+) -> pytokens.Token:\n+    r\"\"\"\n+    Black treats `\\\\\\n` at the end of a line as a 'NL' token, while it",
      "comment": "That doesn't sound particularly intentional, I'd be open to changing Black to remove this divergence.",
      "comment_id": 1911876773,
      "user": "JelleZijlstra",
      "created_at": "2025-01-11T04:30:30Z",
      "url": "https://github.com/psf/black/pull/4536#discussion_r1911876773"
    },
    {
      "repo": "psf/black",
      "pr_number": 4536,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,1070 +43,218 @@\n     FSTRING_MIDDLE,\n     FSTRING_START,\n     INDENT,\n-    LBRACE,\n     NAME,\n     NEWLINE,\n     NL,\n     NUMBER,\n     OP,\n-    RBRACE,\n     STRING,\n     tok_name,\n )\n \n __author__ = \"Ka-Ping Yee <ping@lfw.org>\"\n __credits__ = \"GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip Montanaro\"\n \n-import re\n-from codecs import BOM_UTF8, lookup\n+import pytokens\n+from pytokens import TokenType\n \n-from . import token\n+from . import token as _token\n \n-__all__ = [x for x in dir(token) if x[0] != \"_\"] + [\n+__all__ = [x for x in dir(_token) if x[0] != \"_\"] + [\n     \"tokenize\",\n     \"generate_tokens\",\n     \"untokenize\",\n ]\n-del token\n-\n-\n-def group(*choices: str) -> str:\n-    return \"(\" + \"|\".join(choices) + \")\"\n-\n-\n-def any(*choices: str) -> str:\n-    return group(*choices) + \"*\"\n-\n-\n-def maybe(*choices: str) -> str:\n-    return group(*choices) + \"?\"\n-\n-\n-def _combinations(*l: str) -> set[str]:\n-    return {x + y for x in l for y in l + (\"\",) if x.casefold() != y.casefold()}\n-\n-\n-Whitespace = r\"[ \\f\\t]*\"\n-Comment = r\"#[^\\r\\n]*\"\n-Ignore = Whitespace + any(r\"\\\\\\r?\\n\" + Whitespace) + maybe(Comment)\n-Name = (  # this is invalid but it's fine because Name comes after Number in all groups\n-    r\"[^\\s#\\(\\)\\[\\]\\{\\}+\\-*/!@$%^&=|;:'\\\",\\.<>/?`~\\\\]+\"\n-)\n-\n-Binnumber = r\"0[bB]_?[01]+(?:_[01]+)*\"\n-Hexnumber = r\"0[xX]_?[\\da-fA-F]+(?:_[\\da-fA-F]+)*[lL]?\"\n-Octnumber = r\"0[oO]?_?[0-7]+(?:_[0-7]+)*[lL]?\"\n-Decnumber = group(r\"[1-9]\\d*(?:_\\d+)*[lL]?\", \"0[lL]?\")\n-Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber)\n-Exponent = r\"[eE][-+]?\\d+(?:_\\d+)*\"\n-Pointfloat = group(r\"\\d+(?:_\\d+)*\\.(?:\\d+(?:_\\d+)*)?\", r\"\\.\\d+(?:_\\d+)*\") + maybe(\n-    Exponent\n-)\n-Expfloat = r\"\\d+(?:_\\d+)*\" + Exponent\n-Floatnumber = group(Pointfloat, Expfloat)\n-Imagnumber = group(r\"\\d+(?:_\\d+)*[jJ]\", Floatnumber + r\"[jJ]\")\n-Number = group(Imagnumber, Floatnumber, Intnumber)\n-\n-# Tail end of ' string.\n-Single = r\"(?:\\\\.|[^'\\\\])*'\"\n-# Tail end of \" string.\n-Double = r'(?:\\\\.|[^\"\\\\])*\"'\n-# Tail end of ''' string.\n-Single3 = r\"(?:\\\\.|'(?!'')|[^'\\\\])*'''\"\n-# Tail end of \"\"\" string.\n-Double3 = r'(?:\\\\.|\"(?!\"\")|[^\"\\\\])*\"\"\"'\n-_litprefix = r\"(?:[uUrRbB]|[rR][bB]|[bBuU][rR])?\"\n-_fstringlitprefix = r\"(?:rF|FR|Fr|fr|RF|F|rf|f|Rf|fR)\"\n-Triple = group(\n-    _litprefix + \"'''\",\n-    _litprefix + '\"\"\"',\n-    _fstringlitprefix + '\"\"\"',\n-    _fstringlitprefix + \"'''\",\n-)\n-\n-# beginning of a single quoted f-string. must not end with `{{` or `\\N{`\n-SingleLbrace = r\"(?:\\\\N{|{{|\\\\'|[^\\n'{])*(?<!\\\\N)({)(?!{)\"\n-DoubleLbrace = r'(?:\\\\N{|{{|\\\\\"|[^\\n\"{])*(?<!\\\\N)({)(?!{)'\n-\n-# beginning of a triple quoted f-string. must not end with `{{` or `\\N{`\n-Single3Lbrace = r\"(?:\\\\N{|{{|\\\\'|'(?!'')|[^'{])*(?<!\\\\N){(?!{)\"\n-Double3Lbrace = r'(?:\\\\N{|{{|\\\\\"|\"(?!\"\")|[^\"{])*(?<!\\\\N){(?!{)'\n-\n-# ! format specifier inside an fstring brace, ensure it's not a `!=` token\n-Bang = Whitespace + group(\"!\") + r\"(?!=)\"\n-bang = re.compile(Bang)\n-Colon = Whitespace + group(\":\")\n-colon = re.compile(Colon)\n-\n-FstringMiddleAfterColon = group(Whitespace + r\".*?\") + group(\"{\", \"}\")\n-fstring_middle_after_colon = re.compile(FstringMiddleAfterColon)\n-\n-# Because of leftmost-then-longest match semantics, be sure to put the\n-# longest operators first (e.g., if = came before ==, == would get\n-# recognized as two instances of =).\n-Operator = group(\n-    r\"\\*\\*=?\",\n-    r\">>=?\",\n-    r\"<<=?\",\n-    r\"<>\",\n-    r\"!=\",\n-    r\"//=?\",\n-    r\"->\",\n-    r\"[+\\-*/%&@|^=<>:]=?\",\n-    r\"~\",\n-)\n-\n-Bracket = \"[][(){}]\"\n-Special = group(r\"\\r?\\n\", r\"[:;.,`@]\")\n-Funny = group(Operator, Bracket, Special)\n-\n-_string_middle_single = r\"(?:[^\\n'\\\\]|\\\\.)*\"\n-_string_middle_double = r'(?:[^\\n\"\\\\]|\\\\.)*'\n-\n-# FSTRING_MIDDLE and LBRACE, must not end with a `{{` or `\\N{`\n-_fstring_middle_single = SingleLbrace\n-_fstring_middle_double = DoubleLbrace\n-\n-# First (or only) line of ' or \" string.\n-ContStr = group(\n-    _litprefix + \"'\" + _string_middle_single + group(\"'\", r\"\\\\\\r?\\n\"),\n-    _litprefix + '\"' + _string_middle_double + group('\"', r\"\\\\\\r?\\n\"),\n-    group(_fstringlitprefix + \"'\") + _fstring_middle_single,\n-    group(_fstringlitprefix + '\"') + _fstring_middle_double,\n-    group(_fstringlitprefix + \"'\") + _string_middle_single + group(\"'\", r\"\\\\\\r?\\n\"),\n-    group(_fstringlitprefix + '\"') + _string_middle_double + group('\"', r\"\\\\\\r?\\n\"),\n-)\n-PseudoExtras = group(r\"\\\\\\r?\\n\", Comment, Triple)\n-PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n-\n-pseudoprog: Final = re.compile(PseudoToken, re.UNICODE)\n-\n-singleprog = re.compile(Single)\n-singleprog_plus_lbrace = re.compile(group(SingleLbrace, Single))\n-doubleprog = re.compile(Double)\n-doubleprog_plus_lbrace = re.compile(group(DoubleLbrace, Double))\n-\n-single3prog = re.compile(Single3)\n-single3prog_plus_lbrace = re.compile(group(Single3Lbrace, Single3))\n-double3prog = re.compile(Double3)\n-double3prog_plus_lbrace = re.compile(group(Double3Lbrace, Double3))\n-\n-_strprefixes = _combinations(\"r\", \"R\", \"b\", \"B\") | {\"u\", \"U\", \"ur\", \"uR\", \"Ur\", \"UR\"}\n-_fstring_prefixes = _combinations(\"r\", \"R\", \"f\", \"F\") - {\"r\", \"R\"}\n-\n-endprogs: Final = {\n-    \"'\": singleprog,\n-    '\"': doubleprog,\n-    \"'''\": single3prog,\n-    '\"\"\"': double3prog,\n-    **{f\"{prefix}'\": singleprog for prefix in _strprefixes},\n-    **{f'{prefix}\"': doubleprog for prefix in _strprefixes},\n-    **{f\"{prefix}'\": singleprog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f'{prefix}\"': doubleprog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f\"{prefix}'''\": single3prog for prefix in _strprefixes},\n-    **{f'{prefix}\"\"\"': double3prog for prefix in _strprefixes},\n-    **{f\"{prefix}'''\": single3prog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f'{prefix}\"\"\"': double3prog_plus_lbrace for prefix in _fstring_prefixes},\n-}\n-\n-triple_quoted: Final = (\n-    {\"'''\", '\"\"\"'}\n-    | {f\"{prefix}'''\" for prefix in _strprefixes | _fstring_prefixes}\n-    | {f'{prefix}\"\"\"' for prefix in _strprefixes | _fstring_prefixes}\n-)\n-single_quoted: Final = (\n-    {\"'\", '\"'}\n-    | {f\"{prefix}'\" for prefix in _strprefixes | _fstring_prefixes}\n-    | {f'{prefix}\"' for prefix in _strprefixes | _fstring_prefixes}\n-)\n-fstring_prefix: Final = tuple(\n-    {f\"{prefix}'\" for prefix in _fstring_prefixes}\n-    | {f'{prefix}\"' for prefix in _fstring_prefixes}\n-    | {f\"{prefix}'''\" for prefix in _fstring_prefixes}\n-    | {f'{prefix}\"\"\"' for prefix in _fstring_prefixes}\n-)\n-\n-tabsize = 8\n-\n-\n-class TokenError(Exception):\n-    pass\n-\n-\n-class StopTokenizing(Exception):\n-    pass\n-\n+del _token\n \n Coord = tuple[int, int]\n+TokenInfo = tuple[int, str, Coord, Coord, str]\n+\n+TOKEN_TYPE_MAP = {\n+    TokenType.indent: INDENT,\n+    TokenType.dedent: DEDENT,\n+    TokenType.newline: NEWLINE,\n+    TokenType.nl: NL,\n+    TokenType.comment: COMMENT,\n+    TokenType.semicolon: OP,\n+    TokenType.lparen: OP,\n+    TokenType.rparen: OP,\n+    TokenType.lbracket: OP,\n+    TokenType.rbracket: OP,\n+    TokenType.lbrace: OP,\n+    TokenType.rbrace: OP,\n+    TokenType.colon: OP,\n+    TokenType.op: OP,\n+    TokenType.identifier: NAME,\n+    TokenType.number: NUMBER,\n+    TokenType.string: STRING,\n+    TokenType.fstring_start: FSTRING_START,\n+    TokenType.fstring_middle: FSTRING_MIDDLE,\n+    TokenType.fstring_end: FSTRING_END,\n+    TokenType.endmarker: ENDMARKER,\n+}\n \n \n-def printtoken(\n-    type: int, token: str, srow_col: Coord, erow_col: Coord, line: str\n-) -> None:  # for testing\n-    (srow, scol) = srow_col\n-    (erow, ecol) = erow_col\n-    print(\n-        \"%d,%d-%d,%d:\\t%s\\t%s\" % (srow, scol, erow, ecol, tok_name[type], repr(token))\n-    )\n-\n-\n-TokenEater = Callable[[int, str, Coord, Coord, str], None]\n-\n-\n-def tokenize(readline: Callable[[], str], tokeneater: TokenEater = printtoken) -> None:\n-    \"\"\"\n-    The tokenize() function accepts two parameters: one representing the\n-    input stream, and one providing an output mechanism for tokenize().\n+class TokenError(Exception): ...\n \n-    The first parameter, readline, must be a callable object which provides\n-    the same interface as the readline() method of built-in file objects.\n-    Each call to the function should return one line of input as a string.\n \n-    The second parameter, tokeneater, must also be a callable object. It is\n-    called once for each token, with five arguments, corresponding to the\n-    tuples generated by generate_tokens().\n+def transform_whitespace(\n+    token: pytokens.Token, source: str, prev_token: Optional[pytokens.Token]\n+) -> pytokens.Token:\n+    r\"\"\"\n+    Black treats `\\\\\\n` at the end of a line as a 'NL' token, while it",
      "comment": "Feel free to! I can give you a test case with the expected behaviour.",
      "comment_id": 1911877761,
      "user": "tusharsadhwani",
      "created_at": "2025-01-11T04:34:55Z",
      "url": "https://github.com/psf/black/pull/4536#discussion_r1911877761"
    },
    {
      "repo": "psf/black",
      "pr_number": 4536,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,1070 +43,218 @@\n     FSTRING_MIDDLE,\n     FSTRING_START,\n     INDENT,\n-    LBRACE,\n     NAME,\n     NEWLINE,\n     NL,\n     NUMBER,\n     OP,\n-    RBRACE,\n     STRING,\n     tok_name,\n )\n \n __author__ = \"Ka-Ping Yee <ping@lfw.org>\"\n __credits__ = \"GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip Montanaro\"\n \n-import re\n-from codecs import BOM_UTF8, lookup\n+import pytokens\n+from pytokens import TokenType\n \n-from . import token\n+from . import token as _token\n \n-__all__ = [x for x in dir(token) if x[0] != \"_\"] + [\n+__all__ = [x for x in dir(_token) if x[0] != \"_\"] + [\n     \"tokenize\",\n     \"generate_tokens\",\n     \"untokenize\",\n ]\n-del token\n-\n-\n-def group(*choices: str) -> str:\n-    return \"(\" + \"|\".join(choices) + \")\"\n-\n-\n-def any(*choices: str) -> str:\n-    return group(*choices) + \"*\"\n-\n-\n-def maybe(*choices: str) -> str:\n-    return group(*choices) + \"?\"\n-\n-\n-def _combinations(*l: str) -> set[str]:\n-    return {x + y for x in l for y in l + (\"\",) if x.casefold() != y.casefold()}\n-\n-\n-Whitespace = r\"[ \\f\\t]*\"\n-Comment = r\"#[^\\r\\n]*\"\n-Ignore = Whitespace + any(r\"\\\\\\r?\\n\" + Whitespace) + maybe(Comment)\n-Name = (  # this is invalid but it's fine because Name comes after Number in all groups\n-    r\"[^\\s#\\(\\)\\[\\]\\{\\}+\\-*/!@$%^&=|;:'\\\",\\.<>/?`~\\\\]+\"\n-)\n-\n-Binnumber = r\"0[bB]_?[01]+(?:_[01]+)*\"\n-Hexnumber = r\"0[xX]_?[\\da-fA-F]+(?:_[\\da-fA-F]+)*[lL]?\"\n-Octnumber = r\"0[oO]?_?[0-7]+(?:_[0-7]+)*[lL]?\"\n-Decnumber = group(r\"[1-9]\\d*(?:_\\d+)*[lL]?\", \"0[lL]?\")\n-Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber)\n-Exponent = r\"[eE][-+]?\\d+(?:_\\d+)*\"\n-Pointfloat = group(r\"\\d+(?:_\\d+)*\\.(?:\\d+(?:_\\d+)*)?\", r\"\\.\\d+(?:_\\d+)*\") + maybe(\n-    Exponent\n-)\n-Expfloat = r\"\\d+(?:_\\d+)*\" + Exponent\n-Floatnumber = group(Pointfloat, Expfloat)\n-Imagnumber = group(r\"\\d+(?:_\\d+)*[jJ]\", Floatnumber + r\"[jJ]\")\n-Number = group(Imagnumber, Floatnumber, Intnumber)\n-\n-# Tail end of ' string.\n-Single = r\"(?:\\\\.|[^'\\\\])*'\"\n-# Tail end of \" string.\n-Double = r'(?:\\\\.|[^\"\\\\])*\"'\n-# Tail end of ''' string.\n-Single3 = r\"(?:\\\\.|'(?!'')|[^'\\\\])*'''\"\n-# Tail end of \"\"\" string.\n-Double3 = r'(?:\\\\.|\"(?!\"\")|[^\"\\\\])*\"\"\"'\n-_litprefix = r\"(?:[uUrRbB]|[rR][bB]|[bBuU][rR])?\"\n-_fstringlitprefix = r\"(?:rF|FR|Fr|fr|RF|F|rf|f|Rf|fR)\"\n-Triple = group(\n-    _litprefix + \"'''\",\n-    _litprefix + '\"\"\"',\n-    _fstringlitprefix + '\"\"\"',\n-    _fstringlitprefix + \"'''\",\n-)\n-\n-# beginning of a single quoted f-string. must not end with `{{` or `\\N{`\n-SingleLbrace = r\"(?:\\\\N{|{{|\\\\'|[^\\n'{])*(?<!\\\\N)({)(?!{)\"\n-DoubleLbrace = r'(?:\\\\N{|{{|\\\\\"|[^\\n\"{])*(?<!\\\\N)({)(?!{)'\n-\n-# beginning of a triple quoted f-string. must not end with `{{` or `\\N{`\n-Single3Lbrace = r\"(?:\\\\N{|{{|\\\\'|'(?!'')|[^'{])*(?<!\\\\N){(?!{)\"\n-Double3Lbrace = r'(?:\\\\N{|{{|\\\\\"|\"(?!\"\")|[^\"{])*(?<!\\\\N){(?!{)'\n-\n-# ! format specifier inside an fstring brace, ensure it's not a `!=` token\n-Bang = Whitespace + group(\"!\") + r\"(?!=)\"\n-bang = re.compile(Bang)\n-Colon = Whitespace + group(\":\")\n-colon = re.compile(Colon)\n-\n-FstringMiddleAfterColon = group(Whitespace + r\".*?\") + group(\"{\", \"}\")\n-fstring_middle_after_colon = re.compile(FstringMiddleAfterColon)\n-\n-# Because of leftmost-then-longest match semantics, be sure to put the\n-# longest operators first (e.g., if = came before ==, == would get\n-# recognized as two instances of =).\n-Operator = group(\n-    r\"\\*\\*=?\",\n-    r\">>=?\",\n-    r\"<<=?\",\n-    r\"<>\",\n-    r\"!=\",\n-    r\"//=?\",\n-    r\"->\",\n-    r\"[+\\-*/%&@|^=<>:]=?\",\n-    r\"~\",\n-)\n-\n-Bracket = \"[][(){}]\"\n-Special = group(r\"\\r?\\n\", r\"[:;.,`@]\")\n-Funny = group(Operator, Bracket, Special)\n-\n-_string_middle_single = r\"(?:[^\\n'\\\\]|\\\\.)*\"\n-_string_middle_double = r'(?:[^\\n\"\\\\]|\\\\.)*'\n-\n-# FSTRING_MIDDLE and LBRACE, must not end with a `{{` or `\\N{`\n-_fstring_middle_single = SingleLbrace\n-_fstring_middle_double = DoubleLbrace\n-\n-# First (or only) line of ' or \" string.\n-ContStr = group(\n-    _litprefix + \"'\" + _string_middle_single + group(\"'\", r\"\\\\\\r?\\n\"),\n-    _litprefix + '\"' + _string_middle_double + group('\"', r\"\\\\\\r?\\n\"),\n-    group(_fstringlitprefix + \"'\") + _fstring_middle_single,\n-    group(_fstringlitprefix + '\"') + _fstring_middle_double,\n-    group(_fstringlitprefix + \"'\") + _string_middle_single + group(\"'\", r\"\\\\\\r?\\n\"),\n-    group(_fstringlitprefix + '\"') + _string_middle_double + group('\"', r\"\\\\\\r?\\n\"),\n-)\n-PseudoExtras = group(r\"\\\\\\r?\\n\", Comment, Triple)\n-PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n-\n-pseudoprog: Final = re.compile(PseudoToken, re.UNICODE)\n-\n-singleprog = re.compile(Single)\n-singleprog_plus_lbrace = re.compile(group(SingleLbrace, Single))\n-doubleprog = re.compile(Double)\n-doubleprog_plus_lbrace = re.compile(group(DoubleLbrace, Double))\n-\n-single3prog = re.compile(Single3)\n-single3prog_plus_lbrace = re.compile(group(Single3Lbrace, Single3))\n-double3prog = re.compile(Double3)\n-double3prog_plus_lbrace = re.compile(group(Double3Lbrace, Double3))\n-\n-_strprefixes = _combinations(\"r\", \"R\", \"b\", \"B\") | {\"u\", \"U\", \"ur\", \"uR\", \"Ur\", \"UR\"}\n-_fstring_prefixes = _combinations(\"r\", \"R\", \"f\", \"F\") - {\"r\", \"R\"}\n-\n-endprogs: Final = {\n-    \"'\": singleprog,\n-    '\"': doubleprog,\n-    \"'''\": single3prog,\n-    '\"\"\"': double3prog,\n-    **{f\"{prefix}'\": singleprog for prefix in _strprefixes},\n-    **{f'{prefix}\"': doubleprog for prefix in _strprefixes},\n-    **{f\"{prefix}'\": singleprog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f'{prefix}\"': doubleprog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f\"{prefix}'''\": single3prog for prefix in _strprefixes},\n-    **{f'{prefix}\"\"\"': double3prog for prefix in _strprefixes},\n-    **{f\"{prefix}'''\": single3prog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f'{prefix}\"\"\"': double3prog_plus_lbrace for prefix in _fstring_prefixes},\n-}\n-\n-triple_quoted: Final = (\n-    {\"'''\", '\"\"\"'}\n-    | {f\"{prefix}'''\" for prefix in _strprefixes | _fstring_prefixes}\n-    | {f'{prefix}\"\"\"' for prefix in _strprefixes | _fstring_prefixes}\n-)\n-single_quoted: Final = (\n-    {\"'\", '\"'}\n-    | {f\"{prefix}'\" for prefix in _strprefixes | _fstring_prefixes}\n-    | {f'{prefix}\"' for prefix in _strprefixes | _fstring_prefixes}\n-)\n-fstring_prefix: Final = tuple(\n-    {f\"{prefix}'\" for prefix in _fstring_prefixes}\n-    | {f'{prefix}\"' for prefix in _fstring_prefixes}\n-    | {f\"{prefix}'''\" for prefix in _fstring_prefixes}\n-    | {f'{prefix}\"\"\"' for prefix in _fstring_prefixes}\n-)\n-\n-tabsize = 8\n-\n-\n-class TokenError(Exception):\n-    pass\n-\n-\n-class StopTokenizing(Exception):\n-    pass\n-\n+del _token\n \n Coord = tuple[int, int]\n+TokenInfo = tuple[int, str, Coord, Coord, str]\n+\n+TOKEN_TYPE_MAP = {\n+    TokenType.indent: INDENT,\n+    TokenType.dedent: DEDENT,\n+    TokenType.newline: NEWLINE,\n+    TokenType.nl: NL,\n+    TokenType.comment: COMMENT,\n+    TokenType.semicolon: OP,\n+    TokenType.lparen: OP,\n+    TokenType.rparen: OP,\n+    TokenType.lbracket: OP,\n+    TokenType.rbracket: OP,\n+    TokenType.lbrace: OP,\n+    TokenType.rbrace: OP,\n+    TokenType.colon: OP,\n+    TokenType.op: OP,\n+    TokenType.identifier: NAME,\n+    TokenType.number: NUMBER,\n+    TokenType.string: STRING,\n+    TokenType.fstring_start: FSTRING_START,\n+    TokenType.fstring_middle: FSTRING_MIDDLE,\n+    TokenType.fstring_end: FSTRING_END,\n+    TokenType.endmarker: ENDMARKER,\n+}\n \n \n-def printtoken(\n-    type: int, token: str, srow_col: Coord, erow_col: Coord, line: str\n-) -> None:  # for testing\n-    (srow, scol) = srow_col\n-    (erow, ecol) = erow_col\n-    print(\n-        \"%d,%d-%d,%d:\\t%s\\t%s\" % (srow, scol, erow, ecol, tok_name[type], repr(token))\n-    )\n-\n-\n-TokenEater = Callable[[int, str, Coord, Coord, str], None]\n-\n-\n-def tokenize(readline: Callable[[], str], tokeneater: TokenEater = printtoken) -> None:\n-    \"\"\"\n-    The tokenize() function accepts two parameters: one representing the\n-    input stream, and one providing an output mechanism for tokenize().\n+class TokenError(Exception): ...\n \n-    The first parameter, readline, must be a callable object which provides\n-    the same interface as the readline() method of built-in file objects.\n-    Each call to the function should return one line of input as a string.\n \n-    The second parameter, tokeneater, must also be a callable object. It is\n-    called once for each token, with five arguments, corresponding to the\n-    tuples generated by generate_tokens().\n+def transform_whitespace(\n+    token: pytokens.Token, source: str, prev_token: Optional[pytokens.Token]\n+) -> pytokens.Token:\n+    r\"\"\"\n+    Black treats `\\\\\\n` at the end of a line as a 'NL' token, while it",
      "comment": "So, this is enough as a test case actually:\r\n\r\n```python\r\na \\\r\n  b\r\n```\r\n\r\nBut, the reason this probably exists is to support formatting [this file](https://github.com/psf/black/blob/main/tests/data/cases/backslash_before_indent.py):\r\n\r\n```python\r\nclass Plotter:\r\n\\\r\n    pass\r\n\r\nclass AnotherCase:\r\n  \\\r\n    \"\"\"Some\r\n    \\\r\n    Docstring\r\n    \"\"\"\r\n```",
      "comment_id": 1912059676,
      "user": "tusharsadhwani",
      "created_at": "2025-01-11T14:32:32Z",
      "url": "https://github.com/psf/black/pull/4536#discussion_r1912059676"
    },
    {
      "repo": "psf/black",
      "pr_number": 4536,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,1070 +43,218 @@\n     FSTRING_MIDDLE,\n     FSTRING_START,\n     INDENT,\n-    LBRACE,\n     NAME,\n     NEWLINE,\n     NL,\n     NUMBER,\n     OP,\n-    RBRACE,\n     STRING,\n     tok_name,\n )\n \n __author__ = \"Ka-Ping Yee <ping@lfw.org>\"\n __credits__ = \"GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip Montanaro\"\n \n-import re\n-from codecs import BOM_UTF8, lookup\n+import pytokens\n+from pytokens import TokenType\n \n-from . import token\n+from . import token as _token\n \n-__all__ = [x for x in dir(token) if x[0] != \"_\"] + [\n+__all__ = [x for x in dir(_token) if x[0] != \"_\"] + [\n     \"tokenize\",\n     \"generate_tokens\",\n     \"untokenize\",\n ]\n-del token\n-\n-\n-def group(*choices: str) -> str:\n-    return \"(\" + \"|\".join(choices) + \")\"\n-\n-\n-def any(*choices: str) -> str:\n-    return group(*choices) + \"*\"\n-\n-\n-def maybe(*choices: str) -> str:\n-    return group(*choices) + \"?\"\n-\n-\n-def _combinations(*l: str) -> set[str]:\n-    return {x + y for x in l for y in l + (\"\",) if x.casefold() != y.casefold()}\n-\n-\n-Whitespace = r\"[ \\f\\t]*\"\n-Comment = r\"#[^\\r\\n]*\"\n-Ignore = Whitespace + any(r\"\\\\\\r?\\n\" + Whitespace) + maybe(Comment)\n-Name = (  # this is invalid but it's fine because Name comes after Number in all groups\n-    r\"[^\\s#\\(\\)\\[\\]\\{\\}+\\-*/!@$%^&=|;:'\\\",\\.<>/?`~\\\\]+\"\n-)\n-\n-Binnumber = r\"0[bB]_?[01]+(?:_[01]+)*\"\n-Hexnumber = r\"0[xX]_?[\\da-fA-F]+(?:_[\\da-fA-F]+)*[lL]?\"\n-Octnumber = r\"0[oO]?_?[0-7]+(?:_[0-7]+)*[lL]?\"\n-Decnumber = group(r\"[1-9]\\d*(?:_\\d+)*[lL]?\", \"0[lL]?\")\n-Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber)\n-Exponent = r\"[eE][-+]?\\d+(?:_\\d+)*\"\n-Pointfloat = group(r\"\\d+(?:_\\d+)*\\.(?:\\d+(?:_\\d+)*)?\", r\"\\.\\d+(?:_\\d+)*\") + maybe(\n-    Exponent\n-)\n-Expfloat = r\"\\d+(?:_\\d+)*\" + Exponent\n-Floatnumber = group(Pointfloat, Expfloat)\n-Imagnumber = group(r\"\\d+(?:_\\d+)*[jJ]\", Floatnumber + r\"[jJ]\")\n-Number = group(Imagnumber, Floatnumber, Intnumber)\n-\n-# Tail end of ' string.\n-Single = r\"(?:\\\\.|[^'\\\\])*'\"\n-# Tail end of \" string.\n-Double = r'(?:\\\\.|[^\"\\\\])*\"'\n-# Tail end of ''' string.\n-Single3 = r\"(?:\\\\.|'(?!'')|[^'\\\\])*'''\"\n-# Tail end of \"\"\" string.\n-Double3 = r'(?:\\\\.|\"(?!\"\")|[^\"\\\\])*\"\"\"'\n-_litprefix = r\"(?:[uUrRbB]|[rR][bB]|[bBuU][rR])?\"\n-_fstringlitprefix = r\"(?:rF|FR|Fr|fr|RF|F|rf|f|Rf|fR)\"\n-Triple = group(\n-    _litprefix + \"'''\",\n-    _litprefix + '\"\"\"',\n-    _fstringlitprefix + '\"\"\"',\n-    _fstringlitprefix + \"'''\",\n-)\n-\n-# beginning of a single quoted f-string. must not end with `{{` or `\\N{`\n-SingleLbrace = r\"(?:\\\\N{|{{|\\\\'|[^\\n'{])*(?<!\\\\N)({)(?!{)\"\n-DoubleLbrace = r'(?:\\\\N{|{{|\\\\\"|[^\\n\"{])*(?<!\\\\N)({)(?!{)'\n-\n-# beginning of a triple quoted f-string. must not end with `{{` or `\\N{`\n-Single3Lbrace = r\"(?:\\\\N{|{{|\\\\'|'(?!'')|[^'{])*(?<!\\\\N){(?!{)\"\n-Double3Lbrace = r'(?:\\\\N{|{{|\\\\\"|\"(?!\"\")|[^\"{])*(?<!\\\\N){(?!{)'\n-\n-# ! format specifier inside an fstring brace, ensure it's not a `!=` token\n-Bang = Whitespace + group(\"!\") + r\"(?!=)\"\n-bang = re.compile(Bang)\n-Colon = Whitespace + group(\":\")\n-colon = re.compile(Colon)\n-\n-FstringMiddleAfterColon = group(Whitespace + r\".*?\") + group(\"{\", \"}\")\n-fstring_middle_after_colon = re.compile(FstringMiddleAfterColon)\n-\n-# Because of leftmost-then-longest match semantics, be sure to put the\n-# longest operators first (e.g., if = came before ==, == would get\n-# recognized as two instances of =).\n-Operator = group(\n-    r\"\\*\\*=?\",\n-    r\">>=?\",\n-    r\"<<=?\",\n-    r\"<>\",\n-    r\"!=\",\n-    r\"//=?\",\n-    r\"->\",\n-    r\"[+\\-*/%&@|^=<>:]=?\",\n-    r\"~\",\n-)\n-\n-Bracket = \"[][(){}]\"\n-Special = group(r\"\\r?\\n\", r\"[:;.,`@]\")\n-Funny = group(Operator, Bracket, Special)\n-\n-_string_middle_single = r\"(?:[^\\n'\\\\]|\\\\.)*\"\n-_string_middle_double = r'(?:[^\\n\"\\\\]|\\\\.)*'\n-\n-# FSTRING_MIDDLE and LBRACE, must not end with a `{{` or `\\N{`\n-_fstring_middle_single = SingleLbrace\n-_fstring_middle_double = DoubleLbrace\n-\n-# First (or only) line of ' or \" string.\n-ContStr = group(\n-    _litprefix + \"'\" + _string_middle_single + group(\"'\", r\"\\\\\\r?\\n\"),\n-    _litprefix + '\"' + _string_middle_double + group('\"', r\"\\\\\\r?\\n\"),\n-    group(_fstringlitprefix + \"'\") + _fstring_middle_single,\n-    group(_fstringlitprefix + '\"') + _fstring_middle_double,\n-    group(_fstringlitprefix + \"'\") + _string_middle_single + group(\"'\", r\"\\\\\\r?\\n\"),\n-    group(_fstringlitprefix + '\"') + _string_middle_double + group('\"', r\"\\\\\\r?\\n\"),\n-)\n-PseudoExtras = group(r\"\\\\\\r?\\n\", Comment, Triple)\n-PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)\n-\n-pseudoprog: Final = re.compile(PseudoToken, re.UNICODE)\n-\n-singleprog = re.compile(Single)\n-singleprog_plus_lbrace = re.compile(group(SingleLbrace, Single))\n-doubleprog = re.compile(Double)\n-doubleprog_plus_lbrace = re.compile(group(DoubleLbrace, Double))\n-\n-single3prog = re.compile(Single3)\n-single3prog_plus_lbrace = re.compile(group(Single3Lbrace, Single3))\n-double3prog = re.compile(Double3)\n-double3prog_plus_lbrace = re.compile(group(Double3Lbrace, Double3))\n-\n-_strprefixes = _combinations(\"r\", \"R\", \"b\", \"B\") | {\"u\", \"U\", \"ur\", \"uR\", \"Ur\", \"UR\"}\n-_fstring_prefixes = _combinations(\"r\", \"R\", \"f\", \"F\") - {\"r\", \"R\"}\n-\n-endprogs: Final = {\n-    \"'\": singleprog,\n-    '\"': doubleprog,\n-    \"'''\": single3prog,\n-    '\"\"\"': double3prog,\n-    **{f\"{prefix}'\": singleprog for prefix in _strprefixes},\n-    **{f'{prefix}\"': doubleprog for prefix in _strprefixes},\n-    **{f\"{prefix}'\": singleprog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f'{prefix}\"': doubleprog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f\"{prefix}'''\": single3prog for prefix in _strprefixes},\n-    **{f'{prefix}\"\"\"': double3prog for prefix in _strprefixes},\n-    **{f\"{prefix}'''\": single3prog_plus_lbrace for prefix in _fstring_prefixes},\n-    **{f'{prefix}\"\"\"': double3prog_plus_lbrace for prefix in _fstring_prefixes},\n-}\n-\n-triple_quoted: Final = (\n-    {\"'''\", '\"\"\"'}\n-    | {f\"{prefix}'''\" for prefix in _strprefixes | _fstring_prefixes}\n-    | {f'{prefix}\"\"\"' for prefix in _strprefixes | _fstring_prefixes}\n-)\n-single_quoted: Final = (\n-    {\"'\", '\"'}\n-    | {f\"{prefix}'\" for prefix in _strprefixes | _fstring_prefixes}\n-    | {f'{prefix}\"' for prefix in _strprefixes | _fstring_prefixes}\n-)\n-fstring_prefix: Final = tuple(\n-    {f\"{prefix}'\" for prefix in _fstring_prefixes}\n-    | {f'{prefix}\"' for prefix in _fstring_prefixes}\n-    | {f\"{prefix}'''\" for prefix in _fstring_prefixes}\n-    | {f'{prefix}\"\"\"' for prefix in _fstring_prefixes}\n-)\n-\n-tabsize = 8\n-\n-\n-class TokenError(Exception):\n-    pass\n-\n-\n-class StopTokenizing(Exception):\n-    pass\n-\n+del _token\n \n Coord = tuple[int, int]\n+TokenInfo = tuple[int, str, Coord, Coord, str]\n+\n+TOKEN_TYPE_MAP = {\n+    TokenType.indent: INDENT,\n+    TokenType.dedent: DEDENT,\n+    TokenType.newline: NEWLINE,\n+    TokenType.nl: NL,\n+    TokenType.comment: COMMENT,\n+    TokenType.semicolon: OP,\n+    TokenType.lparen: OP,\n+    TokenType.rparen: OP,\n+    TokenType.lbracket: OP,\n+    TokenType.rbracket: OP,\n+    TokenType.lbrace: OP,\n+    TokenType.rbrace: OP,\n+    TokenType.colon: OP,\n+    TokenType.op: OP,\n+    TokenType.identifier: NAME,\n+    TokenType.number: NUMBER,\n+    TokenType.string: STRING,\n+    TokenType.fstring_start: FSTRING_START,\n+    TokenType.fstring_middle: FSTRING_MIDDLE,\n+    TokenType.fstring_end: FSTRING_END,\n+    TokenType.endmarker: ENDMARKER,\n+}\n \n \n-def printtoken(\n-    type: int, token: str, srow_col: Coord, erow_col: Coord, line: str\n-) -> None:  # for testing\n-    (srow, scol) = srow_col\n-    (erow, ecol) = erow_col\n-    print(\n-        \"%d,%d-%d,%d:\\t%s\\t%s\" % (srow, scol, erow, ecol, tok_name[type], repr(token))\n-    )\n-\n-\n-TokenEater = Callable[[int, str, Coord, Coord, str], None]\n-\n-\n-def tokenize(readline: Callable[[], str], tokeneater: TokenEater = printtoken) -> None:\n-    \"\"\"\n-    The tokenize() function accepts two parameters: one representing the\n-    input stream, and one providing an output mechanism for tokenize().\n+class TokenError(Exception): ...\n \n-    The first parameter, readline, must be a callable object which provides\n-    the same interface as the readline() method of built-in file objects.\n-    Each call to the function should return one line of input as a string.\n \n-    The second parameter, tokeneater, must also be a callable object. It is\n-    called once for each token, with five arguments, corresponding to the\n-    tuples generated by generate_tokens().\n+def transform_whitespace(\n+    token: pytokens.Token, source: str, prev_token: Optional[pytokens.Token]\n+) -> pytokens.Token:\n+    r\"\"\"\n+    Black treats `\\\\\\n` at the end of a line as a 'NL' token, while it",
      "comment": "I tried removing this edge case, but it just seems to break the backslash before indent test case. Let's just keep it as-is for now and try to fix it later?",
      "comment_id": 1968337538,
      "user": "tusharsadhwani",
      "created_at": "2025-02-24T19:58:20Z",
      "url": "https://github.com/psf/black/pull/4536#discussion_r1968337538"
    },
    {
      "repo": "psf/black",
      "pr_number": 1116,
      "file_path": "black.py",
      "line": 637,
      "side": "RIGHT",
      "diff_hunk": "@@ -629,7 +629,12 @@ def format_file_in_place(\n     `mode` and `fast` options are passed to :func:`format_file_contents`.\n     \"\"\"\n     if src.suffix == \".pyi\":\n-        mode = evolve(mode, is_pyi=True)\n+        mode = FileMode(\n+            mode.target_versions,\n+            mode.line_length,\n+            mode.string_normalization,\n+            is_pyi=True,\n+        )",
      "comment": "I think you can use `dataclasses.replace(mode, is_pyi=True)`, which is kind of more idiomatic.",
      "comment_id": 340375699,
      "user": "ilevkivskyi",
      "created_at": "2019-10-29T23:39:11Z",
      "url": "https://github.com/psf/black/pull/1116#discussion_r340375699"
    },
    {
      "repo": "psf/black",
      "pr_number": 1116,
      "file_path": "black.py",
      "line": 1040,
      "side": "RIGHT",
      "diff_hunk": "@@ -1028,11 +1033,11 @@ class BracketTracker:\n     \"\"\"Keeps track of brackets on a line.\"\"\"\n \n     depth: int = 0\n-    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)\n-    delimiters: Dict[LeafID, Priority] = Factory(dict)\n+    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = field(default_factory=dict)\n+    delimiters: Dict[LeafID, Priority] = field(default_factory=dict)\n     previous: Optional[Leaf] = None\n-    _for_loop_depths: List[int] = Factory(list)\n-    _lambda_argument_depths: List[int] = Factory(list)\n+    _for_loop_depths: List[int] = field(default_factory=list)\n+    _lambda_argument_depths: List[int] = field(default_factory=list)",
      "comment": "_Maybe_ it makes sense to define a helper:\r\n```python\r\ndef Factory(fn):\r\n    return field(default_factory=fn)\r\n```\r\nto minimize the size of the diff? Not sure however what looks better.",
      "comment_id": 340377009,
      "user": "ilevkivskyi",
      "created_at": "2019-10-29T23:44:14Z",
      "url": "https://github.com/psf/black/pull/1116#discussion_r340377009"
    },
    {
      "repo": "psf/black",
      "pr_number": 1116,
      "file_path": "black.py",
      "line": 1040,
      "side": "RIGHT",
      "diff_hunk": "@@ -1028,11 +1033,11 @@ class BracketTracker:\n     \"\"\"Keeps track of brackets on a line.\"\"\"\n \n     depth: int = 0\n-    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)\n-    delimiters: Dict[LeafID, Priority] = Factory(dict)\n+    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = field(default_factory=dict)\n+    delimiters: Dict[LeafID, Priority] = field(default_factory=dict)\n     previous: Optional[Leaf] = None\n-    _for_loop_depths: List[int] = Factory(list)\n-    _lambda_argument_depths: List[int] = Factory(list)\n+    _for_loop_depths: List[int] = field(default_factory=list)\n+    _lambda_argument_depths: List[int] = field(default_factory=list)",
      "comment": "I think this code is fine. I'd rather use dataclasses idiomatically than minimize diff size.",
      "comment_id": 340382754,
      "user": "JelleZijlstra",
      "created_at": "2019-10-30T00:09:40Z",
      "url": "https://github.com/psf/black/pull/1116#discussion_r340382754"
    },
    {
      "repo": "psf/black",
      "pr_number": 1116,
      "file_path": "black.py",
      "line": 632,
      "side": "RIGHT",
      "diff_hunk": "@@ -629,7 +629,7 @@ def format_file_in_place(\n     `mode` and `fast` options are passed to :func:`format_file_contents`.\n     \"\"\"\n     if src.suffix == \".pyi\":\n-        mode = evolve(mode, is_pyi=True)\n+        mode = mode.replace(is_pyi=True)",
      "comment": "it's actually `dataclasses.replace`, a global function (presumably so dataclasses don't inject a `.replace` method everywhere)",
      "comment_id": 340383085,
      "user": "JelleZijlstra",
      "created_at": "2019-10-30T00:11:05Z",
      "url": "https://github.com/psf/black/pull/1116#discussion_r340383085"
    },
    {
      "repo": "psf/black",
      "pr_number": 1116,
      "file_path": "black.py",
      "line": 1166,
      "side": "RIGHT",
      "diff_hunk": "@@ -1160,9 +1160,11 @@ class Line:\n     \"\"\"Holds leaves and comments. Can be printed with `str(line)`.\"\"\"\n \n     depth: int = 0\n-    leaves: List[Leaf] = Factory(list)\n-    comments: Dict[LeafID, List[Leaf]] = Factory(dict)  # keys ordered like `leaves`\n-    bracket_tracker: BracketTracker = Factory(BracketTracker)\n+    leaves: List[Leaf] = field(default_factory=list)\n+    comments: Dict[LeafID, List[Leaf]] = field(\n+        default_factory=dict\n+    )  # keys ordered like `leaves`",
      "comment": "Can you put this comment on the previous line by itself instead? (I'd personally prefer if Black did that automatically in this case.)",
      "comment_id": 340383203,
      "user": "JelleZijlstra",
      "created_at": "2019-10-30T00:11:41Z",
      "url": "https://github.com/psf/black/pull/1116#discussion_r340383203"
    },
    {
      "repo": "psf/black",
      "pr_number": 1116,
      "file_path": "setup.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,7 +42,8 @@ def get_long_description() -> str:\n         \"typed-ast>=1.4.0\",\n         \"regex\",\n         \"pathspec>=0.6, <1\",\n-    ],\n+    ]\n+    + ([\"dataclasses>=0.6\"] if sys.version_info < (3, 7) else []),",
      "comment": "Prefer to do it like in https://github.com/python/typing/commit/f254d69c56920819b4211f47fdaba6472097dc5c",
      "comment_id": 340383374,
      "user": "JelleZijlstra",
      "created_at": "2019-10-30T00:12:35Z",
      "url": "https://github.com/psf/black/pull/1116#discussion_r340383374"
    },
    {
      "repo": "psf/black",
      "pr_number": 4552,
      "file_path": "tests/data/cases/fmtskip10.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1 @@\n+def foo(): return \"mock\"  # fmt: skip",
      "comment": "```suggestion\r\ndef foo(): return \"mock\"  # fmt: skip\r\nif True: print(\"yay\")  # fmt: skip\r\nfor i in range(10): print(i)  # fmt: skip\r\n```\r\nLooks to also fix #3682 so this adds two examples from that as test cases. The other issues not fixed by this PR in #3682 look to have been fixed by something in the 03-15-2024 release, probably #4248, so it should be good to add to the close-on-merge list for this PR along with #4535\r\n(To do that, edit the opening description to include\r\nFixes #3682\r\nFixes #4535\r\n)",
      "comment_id": 1921030071,
      "user": "MeGaGiGaGon",
      "created_at": "2025-01-18T09:34:59Z",
      "url": "https://github.com/psf/black/pull/4552#discussion_r1921030071"
    },
    {
      "repo": "psf/black",
      "pr_number": 4552,
      "file_path": "tests/data/cases/fmtskip10.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1 @@\n+def foo(): return \"mock\"  # fmt: skip",
      "comment": "Thanks for the review.\r\n\r\nI added the suggested tests + some extra ones.\r\nI also mentioned #3682 on the PR description as suggested.",
      "comment_id": 1921118400,
      "user": "Pedro-Muller29",
      "created_at": "2025-01-18T17:57:13Z",
      "url": "https://github.com/psf/black/pull/4552#discussion_r1921118400"
    },
    {
      "repo": "psf/black",
      "pr_number": 4552,
      "file_path": "src/black/comments.py",
      "line": 330,
      "side": "RIGHT",
      "diff_hunk": "@@ -313,31 +313,74 @@ def generate_ignored_nodes(\n \n \n def _generate_ignored_nodes_from_fmt_skip(\n-    leaf: Leaf, comment: ProtoComment\n+    leaf: Leaf, comment: ProtoComment, mode: Mode\n ) -> Iterator[LN]:\n     \"\"\"Generate all leaves that should be ignored by the `# fmt: skip` from `leaf`.\"\"\"\n     prev_sibling = leaf.prev_sibling\n     parent = leaf.parent\n+    ignored_nodes: list[LN] = []\n     # Need to properly format the leaf prefix to compare it to comment.value,\n     # which is also formatted\n     comments = list_comments(leaf.prefix, is_endmarker=False)\n     if not comments or comment.value != comments[0].value:\n         return\n     if prev_sibling is not None:\n         leaf.prefix = \"\"\n-        siblings = [prev_sibling]\n-        while \"\\n\" not in prev_sibling.prefix and prev_sibling.prev_sibling is not None:\n-            prev_sibling = prev_sibling.prev_sibling\n-            siblings.insert(0, prev_sibling)\n-        yield from siblings\n+\n+        if Preview.multiline_string_handling not in mode:",
      "comment": "Yep, you are absolutely right.\r\n\r\nSorry for missing this. This was the reason for the tests failing in `--preview` mode (the `multiline_string_handling` is an unstable feature).",
      "comment_id": 1922381641,
      "user": "Pedro-Muller29",
      "created_at": "2025-01-20T13:09:47Z",
      "url": "https://github.com/psf/black/pull/4552#discussion_r1922381641"
    },
    {
      "repo": "psf/black",
      "pr_number": 4462,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 317,
      "side": "RIGHT",
      "diff_hunk": "@@ -276,6 +306,21 @@ def unmask_cell(src: str, replacements: list[Replacement]) -> str:\n     return src\n \n \n+def _get_code_start(src: str) -> str:\n+    \"\"\"Provides the first line where the code starts.\n+\n+    Iterates over lines of code until it finds the first line that doesn't\n+    contain only empty spaces and comments. It removes any empty spaces at the\n+    start of the line and returns it. If such line doesn't exist, it returns an\n+    empty string.\n+    \"\"\"\n+    for match in re.finditer(\".+\", src):",
      "comment": "```suggestion\r\n    for match in src.splitlines():\r\n```\r\nAny reason not to use this?",
      "comment_id": 1765197690,
      "user": "JelleZijlstra",
      "created_at": "2024-09-18T14:45:45Z",
      "url": "https://github.com/psf/black/pull/4462#discussion_r1765197690"
    },
    {
      "repo": "psf/black",
      "pr_number": 4462,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 317,
      "side": "RIGHT",
      "diff_hunk": "@@ -276,6 +306,21 @@ def unmask_cell(src: str, replacements: list[Replacement]) -> str:\n     return src\n \n \n+def _get_code_start(src: str) -> str:\n+    \"\"\"Provides the first line where the code starts.\n+\n+    Iterates over lines of code until it finds the first line that doesn't\n+    contain only empty spaces and comments. It removes any empty spaces at the\n+    start of the line and returns it. If such line doesn't exist, it returns an\n+    empty string.\n+    \"\"\"\n+    for match in re.finditer(\".+\", src):",
      "comment": "There might be a slight performance difference because `re.finditer` will stop splitting string once the first line with code is found while `src.splitlines()` will always split the entire string by lines. But I haven't benchmarked anything and this probably won't affect much the performance of the entire formatting process.\r\n\r\nI'm also ok with switching to `src.splitlines()` if that is the preferred way.",
      "comment_id": 1765230879,
      "user": "AleksMat",
      "created_at": "2024-09-18T15:00:38Z",
      "url": "https://github.com/psf/black/pull/4462#discussion_r1765230879"
    },
    {
      "repo": "psf/black",
      "pr_number": 4577,
      "file_path": "tests/test_black.py",
      "line": 119,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,7 +116,10 @@ class BlackRunner(CliRunner):\n     \"\"\"Make sure STDOUT and STDERR are kept separate when testing Black via its CLI.\"\"\"\n \n     def __init__(self) -> None:\n-        super().__init__(mix_stderr=False)\n+        if Version(imp_version('click')) >= Version('8.2.0'):",
      "comment": "```suggestion\r\n        if Version(imp_version(\"click\")) >= Version(\"8.2.0\"):\r\n```\r\nCI is unhappy because the quotes get reformatted to double quotes, but I think it should be gtg after this.",
      "comment_id": 1956769705,
      "user": "MeGaGiGaGon",
      "created_at": "2025-02-14T22:06:24Z",
      "url": "https://github.com/psf/black/pull/4577#discussion_r1956769705"
    },
    {
      "repo": "psf/black",
      "pr_number": 4377,
      "file_path": "tests/data/cases/preview_long_dict_values_2.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,147 @@\n+# flags: --unstable\n+\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": (\n+        \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxx{xx}xxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\"\n+    )\n+}\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxx{xx}xxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\",\n+}\n+x = {\n+    \"foo\": (bar),\n+    \"foo\": bar,\n+    \"foo\": xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx,\n+}\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": (\n+        \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxx\"\n+    )\n+}\n+\n+# Function calls as keys\n+tasks = {\n+    get_key_name(foo, bar, baz,): src,\n+    loop.run_in_executor(): src,\n+    loop.run_in_executor(xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx): src,\n+    loop.run_in_executor(xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxx): src,\n+    loop.run_in_executor(): xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\n+}\n+\n+# Dictionary comprehensions\n+tasks = {\n+    key_name: xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\n+    for src in sources\n+}\n+tasks = {key_name: foobar for src in sources}\n+tasks = {get_key_name(foo, bar, baz,): src for src in sources}\n+tasks = {\n+    get_key_name(): xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\n+    for src in sources\n+}\n+tasks = {\n+    get_key_name(): foobar\n+    for src in sources\n+}\n+\n+# Delimiters inside the value\n+def foo():\n+    def bar():\n+        x = {\n+            common.models.DateTimeField: (\n+                datetime(2020, 1, 31, tzinfo=utc) + timedelta(days=i)\n+            ),\n+        }\n+        x = {\n+            common.models.DateTimeField: datetime(2020, 1, 31, tzinfo=utc) + timedelta(\n+                days=i\n+            ),\n+        }\n+        x = {\n+            \"foobar\": (\n+                123 + 456\n+            ),\n+        }\n+\n+\n+# output\n+\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": (\n+        \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxx{xx}xxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\"\n+    )\n+}\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": (\n+        \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxx{xx}xxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\"\n+    ),\n+}\n+x = {\n+    \"foo\": bar,\n+    \"foo\": bar,\n+    \"foo\": (\n+        xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\n+    ),\n+}\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxx\"\n+}\n+\n+# Function calls as keys\n+tasks = {\n+    get_key_name(\n+        foo,\n+        bar,\n+        baz,\n+    ): src,\n+    loop.run_in_executor(): src,\n+    loop.run_in_executor(xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx): src,\n+    loop.run_in_executor(\n+        xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxx\n+    ): src,",
      "comment": "~~This test is currently failing due to #1657, will try to fix that in a separate PR before this one is merged~~\r\nTurned out to be an unrelated issue",
      "comment_id": 1630238267,
      "user": "cobaltt7",
      "created_at": "2024-06-06T20:58:52Z",
      "url": "https://github.com/psf/black/pull/4377#discussion_r1630238267"
    },
    {
      "repo": "psf/black",
      "pr_number": 4377,
      "file_path": "tests/data/cases/preview_long_dict_values_2.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,147 @@\n+# flags: --unstable\n+\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": (\n+        \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxx{xx}xxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\"\n+    )\n+}\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxx{xx}xxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\",\n+}\n+x = {\n+    \"foo\": (bar),\n+    \"foo\": bar,\n+    \"foo\": xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx,\n+}\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": (\n+        \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxx\"\n+    )\n+}\n+\n+# Function calls as keys\n+tasks = {\n+    get_key_name(foo, bar, baz,): src,\n+    loop.run_in_executor(): src,\n+    loop.run_in_executor(xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx): src,\n+    loop.run_in_executor(xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxx): src,\n+    loop.run_in_executor(): xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\n+}\n+\n+# Dictionary comprehensions\n+tasks = {\n+    key_name: xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\n+    for src in sources\n+}\n+tasks = {key_name: foobar for src in sources}\n+tasks = {get_key_name(foo, bar, baz,): src for src in sources}\n+tasks = {\n+    get_key_name(): xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\n+    for src in sources\n+}\n+tasks = {\n+    get_key_name(): foobar\n+    for src in sources\n+}\n+\n+# Delimiters inside the value\n+def foo():\n+    def bar():\n+        x = {\n+            common.models.DateTimeField: (\n+                datetime(2020, 1, 31, tzinfo=utc) + timedelta(days=i)\n+            ),\n+        }\n+        x = {\n+            common.models.DateTimeField: datetime(2020, 1, 31, tzinfo=utc) + timedelta(\n+                days=i\n+            ),\n+        }\n+        x = {\n+            \"foobar\": (\n+                123 + 456\n+            ),\n+        }\n+\n+\n+# output\n+\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": (\n+        \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxx{xx}xxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\"\n+    )\n+}\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": (\n+        \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxx{xx}xxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\"\n+    ),\n+}\n+x = {\n+    \"foo\": bar,\n+    \"foo\": bar,\n+    \"foo\": (\n+        xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxxxxxx_xxxxxxxxxxxx_xxxx\n+    ),\n+}\n+x = {\n+    \"xx_xxxxx_xxxxxxxxxx_xxxxxxxxx_xx\": \"xx:xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxx\"\n+}\n+\n+# Function calls as keys\n+tasks = {\n+    get_key_name(\n+        foo,\n+        bar,\n+        baz,\n+    ): src,\n+    loop.run_in_executor(): src,\n+    loop.run_in_executor(xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx): src,\n+    loop.run_in_executor(\n+        xx_xxxxxxxxxxxxxxxxx_xxxxx_xxxxxxx_xxxxxxxxxxxxxx_xxxxx_xxxxx\n+    ): src,",
      "comment": "Also why format_self fails:\r\nhttps://github.com/psf/black/blob/b677a643c5322b6af2dbca1f8f7a4f8c98e732aa/src/black/concurrency.py#L154-L158",
      "comment_id": 1637067487,
      "user": "cobaltt7",
      "created_at": "2024-06-12T20:47:57Z",
      "url": "https://github.com/psf/black/pull/4377#discussion_r1637067487"
    },
    {
      "repo": "psf/black",
      "pr_number": 4269,
      "file_path": "src/black/linegen.py",
      "line": 1314,
      "side": "RIGHT",
      "diff_hunk": "@@ -1310,6 +1310,17 @@ def normalize_invisible_parens(  # noqa: C901\n                 child, parens_after={\"case\"}, mode=mode, features=features\n             )\n \n+        # Fixes a bug where invisible parens are not properly wrapped around\n+        # if statement when line is too long.",
      "comment": "```suggestion\r\n        # Add parentheses around if guards in case blocks\r\n```",
      "comment_id": 1522170589,
      "user": "JelleZijlstra",
      "created_at": "2024-03-12T22:03:03Z",
      "url": "https://github.com/psf/black/pull/4269#discussion_r1522170589"
    },
    {
      "repo": "psf/black",
      "pr_number": 4269,
      "file_path": "tests/data/cases/pattern_matching_with_if_stmt.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+# flags: --preview --minimum-version=3.10\n+match \"test\":",
      "comment": "Can you add some test cases where there are comments inside existing parentheses? That often causes us grief. Something like this:\r\n\r\n```\r\nmatch match:\r\n    case case if (True # some comment\r\n    ):\r\n        pass\r\n```",
      "comment_id": 1522171947,
      "user": "JelleZijlstra",
      "created_at": "2024-03-12T22:04:32Z",
      "url": "https://github.com/psf/black/pull/4269#discussion_r1522171947"
    },
    {
      "repo": "psf/black",
      "pr_number": 4269,
      "file_path": "tests/data/cases/pattern_matching_with_if_stmt.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+# flags: --preview --minimum-version=3.10\n+match \"test\":",
      "comment": "Note the `with line-length=1` part. That happens in production too: https://black.vercel.app/?version=main&state=_Td6WFoAAATm1rRGAgAhARYAAAB0L-Wj4ACgAGddAD2IimZxl1N_WmBasjhgIp6QLGDHMEqd7_9GPuZidp8Xgwq_Pjz0403YCzqV5LN_bzUhCM4zzUe4MOiUzBZKKVWtbCBHDK1ePRRxhpRUs8epyuKOCYVT26y790ipGGDrjrDj2VLCkQAAACeMpDur05NRAAGDAaEBAABMjwSSscRn-wIAAAAABFla\r\n\r\nI make it run all tests with `--line-length=1` because it's a good way to find additional crashes. Such crashes can often also appear with a more reasonable line length if the code is deeply nested.",
      "comment_id": 1523102525,
      "user": "JelleZijlstra",
      "created_at": "2024-03-13T12:03:16Z",
      "url": "https://github.com/psf/black/pull/4269#discussion_r1523102525"
    },
    {
      "repo": "psf/black",
      "pr_number": 4269,
      "file_path": "tests/data/cases/pattern_matching_with_if_stmt.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+# flags: --preview --minimum-version=3.10\n+match \"test\":",
      "comment": "Looks like there are still no tests with comments inside the if parentheses. I think such tests are important because comments in inopportune places often lead to crashes in Black.",
      "comment_id": 1525670100,
      "user": "JelleZijlstra",
      "created_at": "2024-03-15T01:57:23Z",
      "url": "https://github.com/psf/black/pull/4269#discussion_r1525670100"
    },
    {
      "repo": "psf/black",
      "pr_number": 4269,
      "file_path": "tests/data/cases/pattern_matching_with_if_stmt.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+# flags: --preview --minimum-version=3.10\n+match \"test\":",
      "comment": "Thanks for the insights! Yes, I haven't committed any new tests yet. The latest commit was just to incorporate your suggestions on descriptions. \r\n\r\nI agree this should be tested thoroughly, I did test a few cases like the ones below, while other thing seems to work fine, the `case case if True:` test case at the end would cause a crash, this one would actually crush even without the modifications on this PR (the crushed test I mentioned above was tested on current main branch). I need some more time to figure out why the `case case if (...)` caused a crash in Black's tests. I can open a new issue for this specific crash and write a PR later if you agree (since it's a crash not directly related to this issue) so that the fix for this issue can be merged. Alternatively I can investigate a bit more to incorporate this `case case if (...)` test in this PR.\r\n\r\n```\r\n    case \"test\" if (True  # some comment\r\n        ):\r\n        pass  # some comment\r\n    case cases if (True  # some comment\r\n                   ):\r\n        pass  # some comment\r\n    case match if (True  # some comment\r\n                   ):\r\n        pass  # some comment\r\n    case case if True:\r\n        pass\r\n```",
      "comment_id": 1525718659,
      "user": "rdrll",
      "created_at": "2024-03-15T03:36:49Z",
      "url": "https://github.com/psf/black/pull/4269#discussion_r1525718659"
    },
    {
      "repo": "psf/black",
      "pr_number": 4269,
      "file_path": "tests/data/cases/pattern_matching_with_if_stmt.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+# flags: --preview --minimum-version=3.10\n+match \"test\":",
      "comment": "Sure, if it's not new to this PR, it's fine to open a new issue. Thanks for investigating!",
      "comment_id": 1525722958,
      "user": "JelleZijlstra",
      "created_at": "2024-03-15T03:46:22Z",
      "url": "https://github.com/psf/black/pull/4269#discussion_r1525722958"
    },
    {
      "repo": "psf/black",
      "pr_number": 4269,
      "file_path": "tests/data/cases/pattern_matching_with_if_stmt.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+# flags: --preview --minimum-version=3.10\n+match \"test\":",
      "comment": "Gotcha, I'll open a new issue and commit the new tests soon. Thanks!",
      "comment_id": 1525726837,
      "user": "rdrll",
      "created_at": "2024-03-15T03:55:29Z",
      "url": "https://github.com/psf/black/pull/4269#discussion_r1525726837"
    },
    {
      "repo": "psf/black",
      "pr_number": 4530,
      "file_path": "tests/data/cases/type_params.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,6 +13,13 @@ def it_gets_worse[WhatIsTheLongestTypeVarNameYouCanThinkOfEnoughToMakeBlackSplit\n \n def magic[Trailing, Comma,](): pass\n \n+class Foo:",
      "comment": "This file is meant for PEP 695 syntax, which your new test doesn't use. Therefore, it's also run in 3.12+ mode. I couldn't find a better file to put it, so I'd suggest adding a new test file, maybe `annotation.py`.",
      "comment_id": 1876843542,
      "user": "JelleZijlstra",
      "created_at": "2024-12-09T22:19:20Z",
      "url": "https://github.com/psf/black/pull/4530#discussion_r1876843542"
    },
    {
      "repo": "psf/black",
      "pr_number": 2229,
      "file_path": "src/black/files.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,8 +119,13 @@ def get_gitignore(root: Path) -> PathSpec:\n     gitignore = root / \".gitignore\"\n     lines: List[str] = []\n     if gitignore.is_file():\n-        with gitignore.open() as gf:\n+        with open(gitignore, \"rb\") as buf:\n+            srcbuf = io.BytesIO(buf.read())\n+            encoding, _ = tokenize.detect_encoding(srcbuf.readline)",
      "comment": "`tokenize.detect_encoding` detects the encoding based on the approach used in Python files (`# encoding: utf-8` comments), so I don't think this works for gitignore files.",
      "comment_id": 632066309,
      "user": "JelleZijlstra",
      "created_at": "2021-05-13T19:55:56Z",
      "url": "https://github.com/psf/black/pull/2229#discussion_r632066309"
    },
    {
      "repo": "psf/black",
      "pr_number": 2229,
      "file_path": "src/black/files.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,8 +119,13 @@ def get_gitignore(root: Path) -> PathSpec:\n     gitignore = root / \".gitignore\"\n     lines: List[str] = []\n     if gitignore.is_file():\n-        with gitignore.open() as gf:\n+        with open(gitignore, \"rb\") as buf:\n+            srcbuf = io.BytesIO(buf.read())\n+            encoding, _ = tokenize.detect_encoding(srcbuf.readline)",
      "comment": "And the reason why this code works also well in @temeddix's case is that `tokenize.detect_encoding` returns `utf-8` if no encoding indicator was found. So in a way this is an overengineered way of saying `open(gitignore, \"r\", encoding=\"utf-8\")`. https://docs.python.org/3/library/tokenize.html#tokenize.detect_encoding",
      "comment_id": 632125744,
      "user": "ichard26",
      "created_at": "2021-05-13T21:48:57Z",
      "url": "https://github.com/psf/black/pull/2229#discussion_r632125744"
    },
    {
      "repo": "psf/black",
      "pr_number": 4498,
      "file_path": "tests/data/cases/preview_long_strings.py",
      "line": 312,
      "side": "LEFT",
      "diff_hunk": "@@ -309,16 +309,12 @@ def foo():\n \n log.info(f\"Skipping: {desc['db_id']=} {desc['ms_name']} {money=} {dte=} {pos_share=} {desc['status']=} {desc['exposure_max']=}\")\n \n-log.info(f'Skipping: {desc[\"db_id\"]} {foo(\"bar\",x=123)} {\"foo\" != \"bar\"} {(x := \"abc=\")} {pos_share=} {desc[\"status\"]} {desc[\"exposure_max\"]}')",
      "comment": "Let's keep these but adjust the output formatting. That way, we at least keep testing that these don't crash.",
      "comment_id": 1812852156,
      "user": "JelleZijlstra",
      "created_at": "2024-10-23T14:04:57Z",
      "url": "https://github.com/psf/black/pull/4498#discussion_r1812852156"
    },
    {
      "repo": "psf/black",
      "pr_number": 4498,
      "file_path": "src/black/trans.py",
      "line": 860,
      "side": "RIGHT",
      "diff_hunk": "@@ -854,6 +857,11 @@ def _validate_msg(line: Line, string_idx: int) -> TResult[None]:\n \n             set_of_prefixes.add(prefix)\n \n+            if \"f\" in prefix and leaf.value[-1] != QUOTE:",
      "comment": "This seems a bit too strong; perhaps we could do it only if there are any nested quotes in the string.",
      "comment_id": 1812863068,
      "user": "JelleZijlstra",
      "created_at": "2024-10-23T14:09:45Z",
      "url": "https://github.com/psf/black/pull/4498#discussion_r1812863068"
    },
    {
      "repo": "psf/black",
      "pr_number": 4498,
      "file_path": "src/black/trans.py",
      "line": 860,
      "side": "RIGHT",
      "diff_hunk": "@@ -854,6 +857,11 @@ def _validate_msg(line: Line, string_idx: int) -> TResult[None]:\n \n             set_of_prefixes.add(prefix)\n \n+            if \"f\" in prefix and leaf.value[-1] != QUOTE:",
      "comment": "I changed it to only reject if it would both change the quote type and there are nested quotes in the string. That makes only 3 tests regress, instead of the many more before. I still feel like the ability to do this at all is a workaround, but I can also see not wanting to regress too much functionality.",
      "comment_id": 1830204895,
      "user": "MeGaGiGaGon",
      "created_at": "2024-11-05T23:25:46Z",
      "url": "https://github.com/psf/black/pull/4498#discussion_r1830204895"
    },
    {
      "repo": "psf/black",
      "pr_number": 4312,
      "file_path": "tests/data/cases/preview_remove_lone_list_item_parens.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+# flags: --unstable\n+items = [(123)]",
      "comment": "Add a test containing a generator expression, to make sure we don't turn it into a listcomp:\r\n\r\n```\r\n>>> [(x for x in [1])]\r\n[<generator object <genexpr> at 0x104277400>]\r\n>>> [x for x in [1]]\r\n[1]\r\n```\r\n\r\nAlso add tests with comments in various places (e.g., after the opening paren, before the closing paren). Such cases tend to expose bugs in Black.",
      "comment_id": 1791242373,
      "user": "JelleZijlstra",
      "created_at": "2024-10-08T05:56:44Z",
      "url": "https://github.com/psf/black/pull/4312#discussion_r1791242373"
    },
    {
      "repo": "psf/black",
      "pr_number": 4452,
      "file_path": "src/black/__init__.py",
      "line": 552,
      "side": "RIGHT",
      "diff_hunk": "@@ -549,6 +549,7 @@ def main(  # noqa: C901\n     \"\"\"The uncompromising code formatter.\"\"\"\n     ctx.ensure_object(dict)\n \n+    assert sys.version_info >= (3, 9), \"Black requires Python 3.9+\"",
      "comment": "Why is this added? This wasn't needed in the `__init__.py` file for previous minimum versions. Python version requirements are handled by `requires-python` in [pyproject.toml](https://github.com/psf/black/blob/main/pyproject.toml), and that was already correctly changed in this commit. ",
      "comment_id": 1792633417,
      "user": "jtmedley",
      "created_at": "2024-10-09T00:03:49Z",
      "url": "https://github.com/psf/black/pull/4452#discussion_r1792633417"
    },
    {
      "repo": "psf/black",
      "pr_number": 4452,
      "file_path": "src/black/__init__.py",
      "line": 552,
      "side": "RIGHT",
      "diff_hunk": "@@ -549,6 +549,7 @@ def main(  # noqa: C901\n     \"\"\"The uncompromising code formatter.\"\"\"\n     ctx.ensure_object(dict)\n \n+    assert sys.version_info >= (3, 9), \"Black requires Python 3.9+\"",
      "comment": "It's harmless enough, Black is definitely broken on 3.8, I have dev environments lying around with random Python versions. Is it causing you some issue?",
      "comment_id": 1792686970,
      "user": "hauntsaninja",
      "created_at": "2024-10-09T01:54:37Z",
      "url": "https://github.com/psf/black/pull/4452#discussion_r1792686970"
    },
    {
      "repo": "psf/black",
      "pr_number": 3994,
      "file_path": "tests/data/cases/remove_await_parens.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,6 +80,15 @@ async def main():\n async def main():\n     await (yield)\n \n+async def main():\n+    await (a ** b)\n+\n+async def main():",
      "comment": "These two cases were already fine, but I added them for completeness",
      "comment_id": 1375173135,
      "user": "JelleZijlstra",
      "created_at": "2023-10-28T05:32:41Z",
      "url": "https://github.com/psf/black/pull/3994#discussion_r1375173135"
    },
    {
      "repo": "psf/black",
      "pr_number": 3994,
      "file_path": "src/black/linegen.py",
      "line": 1362,
      "side": "RIGHT",
      "diff_hunk": "@@ -1354,14 +1354,18 @@ def remove_await_parens(node: Node) -> None:\n                 if bracket_contents.type != syms.power:\n                     ensure_visible(opening_bracket)\n                     ensure_visible(closing_bracket)\n-                elif (\n-                    bracket_contents.type == syms.power\n-                    and bracket_contents.children[0].type == token.AWAIT\n-                ):\n-                    ensure_visible(opening_bracket)\n-                    ensure_visible(closing_bracket)\n-                    # If we are in a nested await then recurse down.\n-                    remove_await_parens(bracket_contents)\n+                elif bracket_contents.type == syms.power:\n+                    if bracket_contents.children[0].type == token.AWAIT:\n+                        ensure_visible(opening_bracket)\n+                        ensure_visible(closing_bracket)\n+                        # If we are in a nested await then recurse down.\n+                        remove_await_parens(bracket_contents)",
      "comment": "When do we need to manually make this recursive call?",
      "comment_id": 1377198046,
      "user": "hauntsaninja",
      "created_at": "2023-10-31T08:13:09Z",
      "url": "https://github.com/psf/black/pull/3994#discussion_r1377198046"
    },
    {
      "repo": "psf/black",
      "pr_number": 3994,
      "file_path": "src/black/linegen.py",
      "line": 1362,
      "side": "RIGHT",
      "diff_hunk": "@@ -1354,14 +1354,18 @@ def remove_await_parens(node: Node) -> None:\n                 if bracket_contents.type != syms.power:\n                     ensure_visible(opening_bracket)\n                     ensure_visible(closing_bracket)\n-                elif (\n-                    bracket_contents.type == syms.power\n-                    and bracket_contents.children[0].type == token.AWAIT\n-                ):\n-                    ensure_visible(opening_bracket)\n-                    ensure_visible(closing_bracket)\n-                    # If we are in a nested await then recurse down.\n-                    remove_await_parens(bracket_contents)\n+                elif bracket_contents.type == syms.power:\n+                    if bracket_contents.children[0].type == token.AWAIT:\n+                        ensure_visible(opening_bracket)\n+                        ensure_visible(closing_bracket)\n+                        # If we are in a nested await then recurse down.\n+                        remove_await_parens(bracket_contents)",
      "comment": "Seems like we don't, all the tests pass if I remove it. We'll visit nested awaits anyway because this is invoked from a visitor. It also isn't necessary for removing multiple pairs of parens; we have tests for that.",
      "comment_id": 1381127708,
      "user": "JelleZijlstra",
      "created_at": "2023-11-03T03:26:33Z",
      "url": "https://github.com/psf/black/pull/3994#discussion_r1381127708"
    },
    {
      "repo": "psf/black",
      "pr_number": 4104,
      "file_path": "tests/test_black.py",
      "line": 928,
      "side": "RIGHT",
      "diff_hunk": "@@ -874,71 +875,88 @@ def test_get_features_used_decorator(self) -> None:\n             )\n \n     def test_get_features_used(self) -> None:\n-        node = black.lib2to3_parse(\"def f(*, arg): ...\\n\")\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"def f(*, arg,): ...\\n\")\n-        self.assertEqual(black.get_features_used(node), {Feature.TRAILING_COMMA_IN_DEF})\n-        node = black.lib2to3_parse(\"f(*arg,)\\n\")\n-        self.assertEqual(\n-            black.get_features_used(node), {Feature.TRAILING_COMMA_IN_CALL}\n+        self.check_features_used(\"def f(*, arg): ...\\n\", set())\n+        self.check_features_used(\n+            \"def f(*, arg,): ...\\n\", {Feature.TRAILING_COMMA_IN_DEF}\n         )\n-        node = black.lib2to3_parse(\"def f(*, arg): f'string'\\n\")\n-        self.assertEqual(black.get_features_used(node), {Feature.F_STRINGS})\n-        node = black.lib2to3_parse(\"123_456\\n\")\n-        self.assertEqual(black.get_features_used(node), {Feature.NUMERIC_UNDERSCORES})\n-        node = black.lib2to3_parse(\"123456\\n\")\n-        self.assertEqual(black.get_features_used(node), set())\n+        self.check_features_used(\"f(*arg,)\\n\", {Feature.TRAILING_COMMA_IN_CALL})\n+        self.check_features_used(\"def f(*, arg): f'string'\\n\", {Feature.F_STRINGS})\n+        self.check_features_used(\"123_456\\n\", {Feature.NUMERIC_UNDERSCORES})\n+        self.check_features_used(\"123456\\n\", set())\n+\n         source, expected = read_data(\"cases\", \"function\")\n-        node = black.lib2to3_parse(source)\n         expected_features = {\n             Feature.TRAILING_COMMA_IN_CALL,\n             Feature.TRAILING_COMMA_IN_DEF,\n             Feature.F_STRINGS,\n         }\n-        self.assertEqual(black.get_features_used(node), expected_features)\n-        node = black.lib2to3_parse(expected)\n-        self.assertEqual(black.get_features_used(node), expected_features)\n+        self.check_features_used(source, expected_features)\n+        self.check_features_used(expected, expected_features)\n+\n         source, expected = read_data(\"cases\", \"expression\")\n-        node = black.lib2to3_parse(source)\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(expected)\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"lambda a, /, b: ...\")\n-        self.assertEqual(black.get_features_used(node), {Feature.POS_ONLY_ARGUMENTS})\n-        node = black.lib2to3_parse(\"def fn(a, /, b): ...\")\n-        self.assertEqual(black.get_features_used(node), {Feature.POS_ONLY_ARGUMENTS})\n-        node = black.lib2to3_parse(\"def fn(): yield a, b\")\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"def fn(): return a, b\")\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"def fn(): yield *b, c\")\n-        self.assertEqual(black.get_features_used(node), {Feature.UNPACKING_ON_FLOW})\n-        node = black.lib2to3_parse(\"def fn(): return a, *b, c\")\n-        self.assertEqual(black.get_features_used(node), {Feature.UNPACKING_ON_FLOW})\n-        node = black.lib2to3_parse(\"x = a, *b, c\")\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"x: Any = regular\")\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"x: Any = (regular, regular)\")\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"x: Any = Complex(Type(1))[something]\")\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"x: Tuple[int, ...] = a, b, c\")\n-        self.assertEqual(\n-            black.get_features_used(node), {Feature.ANN_ASSIGN_EXTENDED_RHS}\n+        self.check_features_used(source, set())\n+        self.check_features_used(expected, set())\n+\n+        self.check_features_used(\"lambda a, /, b: ...\\n\", {Feature.POS_ONLY_ARGUMENTS})\n+        self.check_features_used(\"def fn(a, /, b): ...\", {Feature.POS_ONLY_ARGUMENTS})\n+\n+        self.check_features_used(\"def fn(): yield a, b\", set())\n+        self.check_features_used(\"def fn(): return a, b\", set())\n+        self.check_features_used(\"def fn(): yield *b, c\", {Feature.UNPACKING_ON_FLOW})\n+        self.check_features_used(\n+            \"def fn(): return a, *b, c\", {Feature.UNPACKING_ON_FLOW}\n         )\n-        node = black.lib2to3_parse(\"try: pass\\nexcept Something: pass\")\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"try: pass\\nexcept (*Something,): pass\")\n-        self.assertEqual(black.get_features_used(node), set())\n-        node = black.lib2to3_parse(\"try: pass\\nexcept *Group: pass\")\n-        self.assertEqual(black.get_features_used(node), {Feature.EXCEPT_STAR})\n-        node = black.lib2to3_parse(\"a[*b]\")\n-        self.assertEqual(black.get_features_used(node), {Feature.VARIADIC_GENERICS})\n-        node = black.lib2to3_parse(\"a[x, *y(), z] = t\")\n-        self.assertEqual(black.get_features_used(node), {Feature.VARIADIC_GENERICS})\n-        node = black.lib2to3_parse(\"def fn(*args: *T): pass\")\n-        self.assertEqual(black.get_features_used(node), {Feature.VARIADIC_GENERICS})\n+        self.check_features_used(\"x = a, *b, c\", set())\n+\n+        self.check_features_used(\"x: Any = regular\", set())\n+        self.check_features_used(\"x: Any = (regular, regular)\", set())\n+        self.check_features_used(\"x: Any = Complex(Type(1))[something]\", set())\n+        self.check_features_used(\n+            \"x: Tuple[int, ...] = a, b, c\", {Feature.ANN_ASSIGN_EXTENDED_RHS}\n+        )\n+\n+        self.check_features_used(\"try: pass\\nexcept Something: pass\", set())\n+        self.check_features_used(\"try: pass\\nexcept (*Something,): pass\", set())\n+        self.check_features_used(\n+            \"try: pass\\nexcept *Group: pass\", {Feature.EXCEPT_STAR}\n+        )\n+\n+        self.check_features_used(\"a[*b]\", {Feature.VARIADIC_GENERICS})\n+        self.check_features_used(\"a[x, *y(), z] = t\", {Feature.VARIADIC_GENERICS})\n+        self.check_features_used(\"def fn(*args: *T): pass\", {Feature.VARIADIC_GENERICS})\n+\n+        self.check_features_used(\"with a: pass\", set())",
      "comment": "These are the new tests. Several of them would have previously failed. The case that I ran into in one of our tests was\r\n\r\n```\r\nwith (x := await a, y := await b):\r\n        pass\r\n```\r\n",
      "comment_id": 1423408962,
      "user": "JelleZijlstra",
      "created_at": "2023-12-12T05:08:14Z",
      "url": "https://github.com/psf/black/pull/4104#discussion_r1423408962"
    },
    {
      "repo": "psf/black",
      "pr_number": 4096,
      "file_path": "src/black/mode.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,11 @@ class Preview(Enum):\n     allow_form_feeds = auto()\n \n \n+UNSTABLE_FEATURES: Set[Preview] = {\n+    Preview.string_processing,\n+}",
      "comment": "Would it be more prudent to instead have a set of \"approved\" preview features, and check that, rather than expecting someone to remember to add new features to this set before they're \"ready\" to include in the preview style?",
      "comment_id": 1451064503,
      "user": "amyreese",
      "created_at": "2024-01-13T01:00:57Z",
      "url": "https://github.com/psf/black/pull/4096#discussion_r1451064503"
    },
    {
      "repo": "psf/black",
      "pr_number": 4096,
      "file_path": "src/black/mode.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,11 @@ class Preview(Enum):\n     allow_form_feeds = auto()\n \n \n+UNSTABLE_FEATURES: Set[Preview] = {\n+    Preview.string_processing,\n+}",
      "comment": "The intention is that new features go into the \"approved\" set by default (the approval is that we merge the PR). We'd put features in \"unstable\" only in the hopefully rare case where they are problematic in some way. ",
      "comment_id": 1451064974,
      "user": "JelleZijlstra",
      "created_at": "2024-01-13T01:02:24Z",
      "url": "https://github.com/psf/black/pull/4096#discussion_r1451064974"
    },
    {
      "repo": "psf/black",
      "pr_number": 4096,
      "file_path": "src/black/mode.py",
      "line": 223,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,12 +218,15 @@ def __contains__(self, feature: Preview) -> bool:\n         \"\"\"\n         Provide `Preview.FEATURE in Mode` syntax that mirrors the ``preview`` flag.\n \n-        The argument is not checked and features are not differentiated.\n-        They only exist to make development easier by clarifying intent.\n+        In unstable mode, all features are enabled. In preview mode, all features\n+        except those in UNSTABLE_FEATURES are enabled. For legacy reasons, the\n+        string_processing feature has its own flag, which is deprecated.",
      "comment": "Question- what's the policy around deprecated flags? When is `--experimental-string-processing` expected to be removed?",
      "comment_id": 1465779760,
      "user": "cobaltt7",
      "created_at": "2024-01-25T02:50:24Z",
      "url": "https://github.com/psf/black/pull/4096#discussion_r1465779760"
    },
    {
      "repo": "psf/black",
      "pr_number": 4096,
      "file_path": "src/black/mode.py",
      "line": 223,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,12 +218,15 @@ def __contains__(self, feature: Preview) -> bool:\n         \"\"\"\n         Provide `Preview.FEATURE in Mode` syntax that mirrors the ``preview`` flag.\n \n-        The argument is not checked and features are not differentiated.\n-        They only exist to make development easier by clarifying intent.\n+        In unstable mode, all features are enabled. In preview mode, all features\n+        except those in UNSTABLE_FEATURES are enabled. For legacy reasons, the\n+        string_processing feature has its own flag, which is deprecated.",
      "comment": "There isn't a real policy. That flag has been deprecated since 2022 so I think it's about time it goes away.",
      "comment_id": 1466423297,
      "user": "JelleZijlstra",
      "created_at": "2024-01-25T14:02:41Z",
      "url": "https://github.com/psf/black/pull/4096#discussion_r1466423297"
    },
    {
      "repo": "psf/black",
      "pr_number": 4096,
      "file_path": "src/black/__init__.py",
      "line": 320,
      "side": "RIGHT",
      "diff_hunk": "@@ -300,6 +306,26 @@ def validate_regex(\n         \" functionality in the next major release.\"\n     ),\n )\n+@click.option(\n+    \"--unstable\",\n+    is_flag=True,\n+    help=(\n+        \"Enable potentially disruptive style changes that have known bugs or are not\"\n+        \" currently expected to make it into the stable style Black's next major\"\n+        \" release. Implies --preview.\"\n+    ),\n+)\n+@click.option(\n+    \"--enable-unstable-feature\",\n+    type=click.Choice([v.name for v in UNSTABLE_FEATURES]),",
      "comment": "It could be worth it to be more permissive here, so folks can set `--enable-unstable-feature hug_parens` and forget about it for a year. But I think that much bother is probably fine for preview...",
      "comment_id": 1466942632,
      "user": "hauntsaninja",
      "created_at": "2024-01-25T20:46:51Z",
      "url": "https://github.com/psf/black/pull/4096#discussion_r1466942632"
    },
    {
      "repo": "psf/black",
      "pr_number": 4096,
      "file_path": "src/black/__init__.py",
      "line": 320,
      "side": "RIGHT",
      "diff_hunk": "@@ -300,6 +306,26 @@ def validate_regex(\n         \" functionality in the next major release.\"\n     ),\n )\n+@click.option(\n+    \"--unstable\",\n+    is_flag=True,\n+    help=(\n+        \"Enable potentially disruptive style changes that have known bugs or are not\"\n+        \" currently expected to make it into the stable style Black's next major\"\n+        \" release. Implies --preview.\"\n+    ),\n+)\n+@click.option(\n+    \"--enable-unstable-feature\",\n+    type=click.Choice([v.name for v in UNSTABLE_FEATURES]),",
      "comment": "I think that's actually fine since we only allow `--enable-unstable-feature` if you also have `--preview`, so setting it for a flag that's in preview is a no-op. I'll change this.",
      "comment_id": 1467095693,
      "user": "JelleZijlstra",
      "created_at": "2024-01-26T00:06:40Z",
      "url": "https://github.com/psf/black/pull/4096#discussion_r1467095693"
    },
    {
      "repo": "psf/black",
      "pr_number": 4060,
      "file_path": "src/black/lines.py",
      "line": 687,
      "side": "RIGHT",
      "diff_hunk": "@@ -684,18 +684,14 @@ def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n                 return 0, 1\n             return before, 1\n \n+        # In preview mode, always allow blank lines, except right before a function",
      "comment": "Btw a few lines up we have `and current_line.is_triple_quoted_string`. Should that also use `is_docstring`? Seems preferable to have consistent behaviour for single quote docstrings as well",
      "comment_id": 1404646891,
      "user": "hauntsaninja",
      "created_at": "2023-11-24T21:19:27Z",
      "url": "https://github.com/psf/black/pull/4060#discussion_r1404646891"
    },
    {
      "repo": "psf/black",
      "pr_number": 4060,
      "file_path": "src/black/lines.py",
      "line": 687,
      "side": "RIGHT",
      "diff_hunk": "@@ -684,18 +684,14 @@ def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n                 return 0, 1\n             return before, 1\n \n+        # In preview mode, always allow blank lines, except right before a function",
      "comment": "Yeah I don't really understand why we sometimes use one and sometimes the other. I'll merge this first and then maybe make another preview style change harmonizing between these two.",
      "comment_id": 1421669830,
      "user": "JelleZijlstra",
      "created_at": "2023-12-10T01:46:39Z",
      "url": "https://github.com/psf/black/pull/4060#discussion_r1421669830"
    },
    {
      "repo": "psf/black",
      "pr_number": 4415,
      "file_path": "src/black/files.py",
      "line": 312,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,6 +309,8 @@ def _path_is_ignored(\n     for gitignore_path, pattern in gitignore_dict.items():\n         try:\n             relative_path = path.relative_to(gitignore_path).as_posix()\n+            if path.is_dir():",
      "comment": "Any way we could test that this works as expected?",
      "comment_id": 1691415853,
      "user": "JelleZijlstra",
      "created_at": "2024-07-25T13:09:26Z",
      "url": "https://github.com/psf/black/pull/4415#discussion_r1691415853"
    },
    {
      "repo": "psf/black",
      "pr_number": 4423,
      "file_path": "tests/test_tokenize.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,120 @@\n+\"\"\"Tests for the blib2to3 tokenizer.\"\"\"\n+\n+import io\n+import sys\n+import textwrap\n+from dataclasses import dataclass\n+from typing import List\n+\n+import black\n+from blib2to3.pgen2 import token, tokenize\n+\n+\n+@dataclass\n+class Token:\n+    type: str\n+    string: str\n+    start: tokenize.Coord\n+    end: tokenize.Coord\n+\n+\n+def get_tokens(text: str) -> List[Token]:\n+    \"\"\"Return the tokens produced by the tokenizer.\"\"\"\n+    readline = io.StringIO(text).readline\n+    tokens: List[Token] = []\n+\n+    def tokeneater(\n+        type: int, string: str, start: tokenize.Coord, end: tokenize.Coord, line: str\n+    ) -> None:\n+        tokens.append(Token(token.tok_name[type], string, start, end))\n+\n+    tokenize.tokenize(readline, tokeneater)\n+    return tokens\n+\n+\n+def assert_tokenizes(text: str, tokens: List[Token]) -> None:\n+    \"\"\"Assert that the tokenizer produces the expected tokens.\"\"\"\n+    actual_tokens = get_tokens(text)\n+    assert actual_tokens == tokens\n+\n+\n+def test_simple() -> None:\n+    assert_tokenizes(\n+        \"1\",\n+        [Token(\"NUMBER\", \"1\", (1, 0), (1, 1)), Token(\"ENDMARKER\", \"\", (2, 0), (2, 0))],\n+    )\n+    assert_tokenizes(\n+        \"'a'\",\n+        [\n+            Token(\"STRING\", \"'a'\", (1, 0), (1, 3)),\n+            Token(\"ENDMARKER\", \"\", (2, 0), (2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        \"a\",\n+        [Token(\"NAME\", \"a\", (1, 0), (1, 1)), Token(\"ENDMARKER\", \"\", (2, 0), (2, 0))],\n+    )\n+\n+\n+def test_fstring() -> None:\n+    assert_tokenizes(\n+        'f\"x\"',\n+        [\n+            Token(\"FSTRING_START\", 'f\"', (1, 0), (1, 2)),\n+            Token(\"FSTRING_MIDDLE\", \"x\", (1, 2), (1, 3)),\n+            Token(\"FSTRING_END\", '\"', (1, 3), (1, 4)),\n+            Token(\"ENDMARKER\", \"\", (2, 0), (2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        'f\"{x}\"',\n+        [\n+            Token(\"FSTRING_START\", 'f\"', (1, 0), (1, 2)),\n+            Token(\"FSTRING_MIDDLE\", \"\", (1, 2), (1, 2)),\n+            Token(\"LBRACE\", \"{\", (1, 2), (1, 3)),\n+            Token(\"NAME\", \"x\", (1, 3), (1, 4)),\n+            Token(\"RBRACE\", \"}\", (1, 4), (1, 5)),\n+            Token(\"FSTRING_MIDDLE\", \"\", (1, 5), (1, 5)),\n+            Token(\"FSTRING_END\", '\"', (1, 5), (1, 6)),\n+            Token(\"ENDMARKER\", \"\", (2, 0), (2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        'f\"{x:y}\"\\n',\n+        [\n+            Token(type=\"FSTRING_START\", string='f\"', start=(1, 0), end=(1, 2)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"\", start=(1, 2), end=(1, 2)),\n+            Token(type=\"LBRACE\", string=\"{\", start=(1, 2), end=(1, 3)),\n+            Token(type=\"NAME\", string=\"x\", start=(1, 3), end=(1, 4)),\n+            Token(type=\"OP\", string=\":\", start=(1, 4), end=(1, 5)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"y\", start=(1, 5), end=(1, 6)),\n+            Token(type=\"RBRACE\", string=\"}\", start=(1, 6), end=(1, 7)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"\", start=(1, 7), end=(1, 7)),\n+            Token(type=\"FSTRING_END\", string='\"', start=(1, 7), end=(1, 8)),\n+            Token(type=\"NEWLINE\", string=\"\\n\", start=(1, 8), end=(1, 9)),\n+            Token(type=\"ENDMARKER\", string=\"\", start=(2, 0), end=(2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        'f\"x\\\\\\n{a}\"\\n',\n+        [\n+            Token(type=\"FSTRING_START\", string='f\"', start=(1, 0), end=(1, 2)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"x\\\\\\n\", start=(1, 2), end=(2, 0)),\n+            Token(type=\"LBRACE\", string=\"{\", start=(2, 0), end=(2, 1)),\n+            Token(type=\"NAME\", string=\"a\", start=(2, 1), end=(2, 2)),\n+            Token(type=\"RBRACE\", string=\"}\", start=(2, 2), end=(2, 3)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"\", start=(2, 3), end=(2, 3)),\n+            Token(type=\"FSTRING_END\", string='\"', start=(2, 3), end=(2, 4)),\n+            Token(type=\"NEWLINE\", string=\"\\n\", start=(2, 4), end=(2, 5)),\n+            Token(type=\"ENDMARKER\", string=\"\", start=(3, 0), end=(3, 0)),\n+        ],\n+    )\n+\n+\n+# Run \"echo some code | python tests/test_tokenize.py\" to generate test cases.\n+if __name__ == \"__main__\":\n+    code = sys.stdin.read()\n+    tokens = get_tokens(code)\n+    text = f\"assert_tokenizes({code!r}, {tokens!r})\"",
      "comment": "consider using the builtin `tokenize` module for generating tests? that way you don't have to verify the locations before adding the test.",
      "comment_id": 1700590218,
      "user": "tusharsadhwani",
      "created_at": "2024-08-01T17:55:49Z",
      "url": "https://github.com/psf/black/pull/4423#discussion_r1700590218"
    },
    {
      "repo": "psf/black",
      "pr_number": 4423,
      "file_path": "tests/test_tokenize.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,120 @@\n+\"\"\"Tests for the blib2to3 tokenizer.\"\"\"\n+\n+import io\n+import sys\n+import textwrap\n+from dataclasses import dataclass\n+from typing import List\n+\n+import black\n+from blib2to3.pgen2 import token, tokenize\n+\n+\n+@dataclass\n+class Token:\n+    type: str\n+    string: str\n+    start: tokenize.Coord\n+    end: tokenize.Coord\n+\n+\n+def get_tokens(text: str) -> List[Token]:\n+    \"\"\"Return the tokens produced by the tokenizer.\"\"\"\n+    readline = io.StringIO(text).readline\n+    tokens: List[Token] = []\n+\n+    def tokeneater(\n+        type: int, string: str, start: tokenize.Coord, end: tokenize.Coord, line: str\n+    ) -> None:\n+        tokens.append(Token(token.tok_name[type], string, start, end))\n+\n+    tokenize.tokenize(readline, tokeneater)\n+    return tokens\n+\n+\n+def assert_tokenizes(text: str, tokens: List[Token]) -> None:\n+    \"\"\"Assert that the tokenizer produces the expected tokens.\"\"\"\n+    actual_tokens = get_tokens(text)\n+    assert actual_tokens == tokens\n+\n+\n+def test_simple() -> None:\n+    assert_tokenizes(\n+        \"1\",\n+        [Token(\"NUMBER\", \"1\", (1, 0), (1, 1)), Token(\"ENDMARKER\", \"\", (2, 0), (2, 0))],\n+    )\n+    assert_tokenizes(\n+        \"'a'\",\n+        [\n+            Token(\"STRING\", \"'a'\", (1, 0), (1, 3)),\n+            Token(\"ENDMARKER\", \"\", (2, 0), (2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        \"a\",\n+        [Token(\"NAME\", \"a\", (1, 0), (1, 1)), Token(\"ENDMARKER\", \"\", (2, 0), (2, 0))],\n+    )\n+\n+\n+def test_fstring() -> None:\n+    assert_tokenizes(\n+        'f\"x\"',\n+        [\n+            Token(\"FSTRING_START\", 'f\"', (1, 0), (1, 2)),\n+            Token(\"FSTRING_MIDDLE\", \"x\", (1, 2), (1, 3)),\n+            Token(\"FSTRING_END\", '\"', (1, 3), (1, 4)),\n+            Token(\"ENDMARKER\", \"\", (2, 0), (2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        'f\"{x}\"',\n+        [\n+            Token(\"FSTRING_START\", 'f\"', (1, 0), (1, 2)),\n+            Token(\"FSTRING_MIDDLE\", \"\", (1, 2), (1, 2)),\n+            Token(\"LBRACE\", \"{\", (1, 2), (1, 3)),\n+            Token(\"NAME\", \"x\", (1, 3), (1, 4)),\n+            Token(\"RBRACE\", \"}\", (1, 4), (1, 5)),\n+            Token(\"FSTRING_MIDDLE\", \"\", (1, 5), (1, 5)),\n+            Token(\"FSTRING_END\", '\"', (1, 5), (1, 6)),\n+            Token(\"ENDMARKER\", \"\", (2, 0), (2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        'f\"{x:y}\"\\n',\n+        [\n+            Token(type=\"FSTRING_START\", string='f\"', start=(1, 0), end=(1, 2)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"\", start=(1, 2), end=(1, 2)),\n+            Token(type=\"LBRACE\", string=\"{\", start=(1, 2), end=(1, 3)),\n+            Token(type=\"NAME\", string=\"x\", start=(1, 3), end=(1, 4)),\n+            Token(type=\"OP\", string=\":\", start=(1, 4), end=(1, 5)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"y\", start=(1, 5), end=(1, 6)),\n+            Token(type=\"RBRACE\", string=\"}\", start=(1, 6), end=(1, 7)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"\", start=(1, 7), end=(1, 7)),\n+            Token(type=\"FSTRING_END\", string='\"', start=(1, 7), end=(1, 8)),\n+            Token(type=\"NEWLINE\", string=\"\\n\", start=(1, 8), end=(1, 9)),\n+            Token(type=\"ENDMARKER\", string=\"\", start=(2, 0), end=(2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        'f\"x\\\\\\n{a}\"\\n',\n+        [\n+            Token(type=\"FSTRING_START\", string='f\"', start=(1, 0), end=(1, 2)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"x\\\\\\n\", start=(1, 2), end=(2, 0)),\n+            Token(type=\"LBRACE\", string=\"{\", start=(2, 0), end=(2, 1)),\n+            Token(type=\"NAME\", string=\"a\", start=(2, 1), end=(2, 2)),\n+            Token(type=\"RBRACE\", string=\"}\", start=(2, 2), end=(2, 3)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"\", start=(2, 3), end=(2, 3)),\n+            Token(type=\"FSTRING_END\", string='\"', start=(2, 3), end=(2, 4)),\n+            Token(type=\"NEWLINE\", string=\"\\n\", start=(2, 4), end=(2, 5)),\n+            Token(type=\"ENDMARKER\", string=\"\", start=(3, 0), end=(3, 0)),\n+        ],\n+    )\n+\n+\n+# Run \"echo some code | python tests/test_tokenize.py\" to generate test cases.\n+if __name__ == \"__main__\":\n+    code = sys.stdin.read()\n+    tokens = get_tokens(code)\n+    text = f\"assert_tokenizes({code!r}, {tokens!r})\"",
      "comment": "I'm not sure how compatible exactly are the tokens between Python and blib2to3 though.",
      "comment_id": 1700591273,
      "user": "tusharsadhwani",
      "created_at": "2024-08-01T17:56:35Z",
      "url": "https://github.com/psf/black/pull/4423#discussion_r1700591273"
    },
    {
      "repo": "psf/black",
      "pr_number": 4423,
      "file_path": "tests/test_tokenize.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,120 @@\n+\"\"\"Tests for the blib2to3 tokenizer.\"\"\"\n+\n+import io\n+import sys\n+import textwrap\n+from dataclasses import dataclass\n+from typing import List\n+\n+import black\n+from blib2to3.pgen2 import token, tokenize\n+\n+\n+@dataclass\n+class Token:\n+    type: str\n+    string: str\n+    start: tokenize.Coord\n+    end: tokenize.Coord\n+\n+\n+def get_tokens(text: str) -> List[Token]:\n+    \"\"\"Return the tokens produced by the tokenizer.\"\"\"\n+    readline = io.StringIO(text).readline\n+    tokens: List[Token] = []\n+\n+    def tokeneater(\n+        type: int, string: str, start: tokenize.Coord, end: tokenize.Coord, line: str\n+    ) -> None:\n+        tokens.append(Token(token.tok_name[type], string, start, end))\n+\n+    tokenize.tokenize(readline, tokeneater)\n+    return tokens\n+\n+\n+def assert_tokenizes(text: str, tokens: List[Token]) -> None:\n+    \"\"\"Assert that the tokenizer produces the expected tokens.\"\"\"\n+    actual_tokens = get_tokens(text)\n+    assert actual_tokens == tokens\n+\n+\n+def test_simple() -> None:\n+    assert_tokenizes(\n+        \"1\",\n+        [Token(\"NUMBER\", \"1\", (1, 0), (1, 1)), Token(\"ENDMARKER\", \"\", (2, 0), (2, 0))],\n+    )\n+    assert_tokenizes(\n+        \"'a'\",\n+        [\n+            Token(\"STRING\", \"'a'\", (1, 0), (1, 3)),\n+            Token(\"ENDMARKER\", \"\", (2, 0), (2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        \"a\",\n+        [Token(\"NAME\", \"a\", (1, 0), (1, 1)), Token(\"ENDMARKER\", \"\", (2, 0), (2, 0))],\n+    )\n+\n+\n+def test_fstring() -> None:\n+    assert_tokenizes(\n+        'f\"x\"',\n+        [\n+            Token(\"FSTRING_START\", 'f\"', (1, 0), (1, 2)),\n+            Token(\"FSTRING_MIDDLE\", \"x\", (1, 2), (1, 3)),\n+            Token(\"FSTRING_END\", '\"', (1, 3), (1, 4)),\n+            Token(\"ENDMARKER\", \"\", (2, 0), (2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        'f\"{x}\"',\n+        [\n+            Token(\"FSTRING_START\", 'f\"', (1, 0), (1, 2)),\n+            Token(\"FSTRING_MIDDLE\", \"\", (1, 2), (1, 2)),\n+            Token(\"LBRACE\", \"{\", (1, 2), (1, 3)),\n+            Token(\"NAME\", \"x\", (1, 3), (1, 4)),\n+            Token(\"RBRACE\", \"}\", (1, 4), (1, 5)),\n+            Token(\"FSTRING_MIDDLE\", \"\", (1, 5), (1, 5)),\n+            Token(\"FSTRING_END\", '\"', (1, 5), (1, 6)),\n+            Token(\"ENDMARKER\", \"\", (2, 0), (2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        'f\"{x:y}\"\\n',\n+        [\n+            Token(type=\"FSTRING_START\", string='f\"', start=(1, 0), end=(1, 2)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"\", start=(1, 2), end=(1, 2)),\n+            Token(type=\"LBRACE\", string=\"{\", start=(1, 2), end=(1, 3)),\n+            Token(type=\"NAME\", string=\"x\", start=(1, 3), end=(1, 4)),\n+            Token(type=\"OP\", string=\":\", start=(1, 4), end=(1, 5)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"y\", start=(1, 5), end=(1, 6)),\n+            Token(type=\"RBRACE\", string=\"}\", start=(1, 6), end=(1, 7)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"\", start=(1, 7), end=(1, 7)),\n+            Token(type=\"FSTRING_END\", string='\"', start=(1, 7), end=(1, 8)),\n+            Token(type=\"NEWLINE\", string=\"\\n\", start=(1, 8), end=(1, 9)),\n+            Token(type=\"ENDMARKER\", string=\"\", start=(2, 0), end=(2, 0)),\n+        ],\n+    )\n+    assert_tokenizes(\n+        'f\"x\\\\\\n{a}\"\\n',\n+        [\n+            Token(type=\"FSTRING_START\", string='f\"', start=(1, 0), end=(1, 2)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"x\\\\\\n\", start=(1, 2), end=(2, 0)),\n+            Token(type=\"LBRACE\", string=\"{\", start=(2, 0), end=(2, 1)),\n+            Token(type=\"NAME\", string=\"a\", start=(2, 1), end=(2, 2)),\n+            Token(type=\"RBRACE\", string=\"}\", start=(2, 2), end=(2, 3)),\n+            Token(type=\"FSTRING_MIDDLE\", string=\"\", start=(2, 3), end=(2, 3)),\n+            Token(type=\"FSTRING_END\", string='\"', start=(2, 3), end=(2, 4)),\n+            Token(type=\"NEWLINE\", string=\"\\n\", start=(2, 4), end=(2, 5)),\n+            Token(type=\"ENDMARKER\", string=\"\", start=(3, 0), end=(3, 0)),\n+        ],\n+    )\n+\n+\n+# Run \"echo some code | python tests/test_tokenize.py\" to generate test cases.\n+if __name__ == \"__main__\":\n+    code = sys.stdin.read()\n+    tokens = get_tokens(code)\n+    text = f\"assert_tokenizes({code!r}, {tokens!r})\"",
      "comment": "They don't match exactly in all cases (e.g., builtin has an extra encoding token at the beginning). We can try to work towards exact compatibility, but not sure that's necessary.",
      "comment_id": 1700644988,
      "user": "JelleZijlstra",
      "created_at": "2024-08-01T18:33:55Z",
      "url": "https://github.com/psf/black/pull/4423#discussion_r1700644988"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "tests/data/cases/comment_after_escaped_newline.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,5 +14,7 @@ def bob():  # pylint: disable=W9016\n     pass\n \n \n-def bobtwo():  # some comment here\n+def bobtwo():",
      "comment": "hm so the behavior changes here? That's technically against the stability policy.",
      "comment_id": 1589999771,
      "user": "JelleZijlstra",
      "created_at": "2024-05-04T14:42:29Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1589999771"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "tests/data/cases/comment_after_escaped_newline.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,5 +14,7 @@ def bob():  # pylint: disable=W9016\n     pass\n \n \n-def bobtwo():  # some comment here\n+def bobtwo():",
      "comment": "That is true, but it is a very weird edge case (you need spaces a bit less than the next indent level, followed by a slash) and primer shows zero cases.\n\nShould I try and preserve behaviour nonetheless?",
      "comment_id": 1590000012,
      "user": "tusharsadhwani",
      "created_at": "2024-05-04T14:44:53Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1590000012"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "tests/data/cases/comment_after_escaped_newline.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,5 +14,7 @@ def bob():  # pylint: disable=W9016\n     pass\n \n \n-def bobtwo():  # some comment here\n+def bobtwo():",
      "comment": "Actually, this falls under the exception where we can change the formatting of code that hasn't already been Black-formatted. Normally I'm hesitant to use that exception, but this pattern seems unlikely to appear in any real-world code.",
      "comment_id": 1590003594,
      "user": "JelleZijlstra",
      "created_at": "2024-05-04T15:07:47Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1590003594"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 614,
      "side": "RIGHT",
      "diff_hunk": "@@ -608,6 +608,12 @@ def generate_tokens(\n         except StopIteration:\n             line = \"\"\n         lnum += 1\n+\n+        # skip lines that are just a slash, to avoid storing that line's\n+        # indent information.\n+        if not contstr and line.rstrip(\"\\n\").strip(\" \\t\") == \"\\\\\":",
      "comment": "Is this equivalent to just `line.strip() == \"\\\\\"`? Or do we need to care about exotic whitespace characters that are not newline/space/tab?",
      "comment_id": 1590003853,
      "user": "JelleZijlstra",
      "created_at": "2024-05-04T15:10:04Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1590003853"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 614,
      "side": "RIGHT",
      "diff_hunk": "@@ -608,6 +608,12 @@ def generate_tokens(\n         except StopIteration:\n             line = \"\"\n         lnum += 1\n+\n+        # skip lines that are just a slash, to avoid storing that line's\n+        # indent information.\n+        if not contstr and line.rstrip(\"\\n\").strip(\" \\t\") == \"\\\\\":",
      "comment": "I'm not entirely sure, so I tried to be conservative. Does Python normally treat characters like `\\r` or `\\v` as part of indentation?",
      "comment_id": 1590004630,
      "user": "tusharsadhwani",
      "created_at": "2024-05-04T15:16:05Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1590004630"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 614,
      "side": "RIGHT",
      "diff_hunk": "@@ -608,6 +608,12 @@ def generate_tokens(\n         except StopIteration:\n             line = \"\"\n         lnum += 1\n+\n+        # skip lines that are just a slash, to avoid storing that line's\n+        # indent information.\n+        if not contstr and line.rstrip(\"\\n\").strip(\" \\t\") == \"\\\\\":",
      "comment": "Not too sure, there is code in our tokenizer that deals with `\\f` at least. In CPython (`Parser/lexer/lexer.c`) I see some code dealing with `\\r` and with `\\f` (`\\014`).",
      "comment_id": 1590005519,
      "user": "JelleZijlstra",
      "created_at": "2024-05-04T15:21:42Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1590005519"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 614,
      "side": "RIGHT",
      "diff_hunk": "@@ -608,6 +608,12 @@ def generate_tokens(\n         except StopIteration:\n             line = \"\"\n         lnum += 1\n+\n+        # skip lines that are just a slash, to avoid storing that line's\n+        # indent information.\n+        if not contstr and line.rstrip(\"\\n\").strip(\" \\t\") == \"\\\\\":",
      "comment": "```console\r\n$ printf 'def foo():\\n \\t pass' | python -m tokenize\r\n1,0-1,3:            NAME           'def'\r\n1,4-1,7:            NAME           'foo'\r\n1,7-1,8:            OP             '('\r\n1,8-1,9:            OP             ')'\r\n1,9-1,10:           OP             ':'\r\n1,10-1,11:          NEWLINE        '\\n'\r\n2,0-2,3:            INDENT         ' \\t '\r\n2,3-2,7:            NAME           'pass'\r\n2,7-2,8:            NEWLINE        ''\r\n3,0-3,0:            DEDENT         ''\r\n3,0-3,0:            ENDMARKER      ''\r\n\r\n$ printf 'def foo():\\n \\f pass' | python -m tokenize\r\n1,0-1,3:            NAME           'def'\r\n1,4-1,7:            NAME           'foo'\r\n1,7-1,8:            OP             '('\r\n1,8-1,9:            OP             ')'\r\n1,9-1,10:           OP             ':'\r\n1,10-1,11:          NEWLINE        '\\n'\r\n2,0-2,3:            INDENT         ' \\x0c '\r\n2,3-2,7:            NAME           'pass'\r\n2,7-2,8:            NEWLINE        ''\r\n3,0-3,0:            DEDENT         ''\r\n3,0-3,0:            ENDMARKER      ''\r\n\r\n$ printf 'def foo():\\n \\r pass' | python -m tokenize\r\n1,0-1,3:            NAME           'def'\r\n1,4-1,7:            NAME           'foo'\r\n1,7-1,8:            OP             '('\r\n1,8-1,9:            OP             ')'\r\n1,9-1,10:           OP             ':'\r\n1,10-1,11:          NEWLINE        '\\n'\r\n2,1-2,3:            OP             '\\r '\r\n2,3-2,7:            NAME           'pass'\r\n2,7-2,8:            NEWLINE        ''\r\n3,0-3,0:            ENDMARKER      ''\r\n```\r\n\r\nSo `\\f` is infact legitimate indentation, how interesting.",
      "comment_id": 1590005700,
      "user": "tusharsadhwani",
      "created_at": "2024-05-04T15:23:37Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1590005700"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 614,
      "side": "RIGHT",
      "diff_hunk": "@@ -608,6 +608,12 @@ def generate_tokens(\n         except StopIteration:\n             line = \"\"\n         lnum += 1\n+\n+        # skip lines that are just a slash, to avoid storing that line's\n+        # indent information.\n+        if not contstr and line.rstrip(\"\\n\").strip(\" \\t\") == \"\\\\\":",
      "comment": "```console\r\n$ python -c 'print(\"def foo():\\n \\v pass\")' | python -m tokenize\r\n1,0-1,3:            NAME           'def'\r\n1,4-1,7:            NAME           'foo'\r\n1,7-1,8:            OP             '('\r\n1,8-1,9:            OP             ')'\r\n1,9-1,10:           OP             ':'\r\n1,10-1,11:          NEWLINE        '\\n'\r\n2,0-2,1:            INDENT         ' '\r\n<stdin>:2:2: error: invalid non-printable character U+000B\r\n```\r\n\r\n`\\v` is unparseable.\r\n\r\nSo editing the PR to do `.lstrip(' \\t\\f')` should take care of all cases I believe.",
      "comment_id": 1590005951,
      "user": "tusharsadhwani",
      "created_at": "2024-05-04T15:25:05Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1590005951"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 614,
      "side": "RIGHT",
      "diff_hunk": "@@ -608,6 +608,12 @@ def generate_tokens(\n         except StopIteration:\n             line = \"\"\n         lnum += 1\n+\n+        # skip lines that are just a slash, to avoid storing that line's\n+        # indent information.\n+        if not contstr and line.rstrip(\"\\n\").strip(\" \\t\") == \"\\\\\":",
      "comment": "Made changes. The reason I can't do `.strip()` is because `\\` must be at the end of the line. If there's spaces after the backslash it's no longer escaping the newline:\r\n\r\n```console\r\n$ printf 'print(2 + \\\\\\n3)'\r\nprint(2 + \\\r\n3)\r\n\r\n$ printf 'print(2 + \\\\\\n3)' | python3\r\n5\r\n\r\n$ printf 'print(2 + \\\\ \\n3)' | python3\r\n  File \"<stdin>\", line 1\r\n    print(2 + \\\r\n               ^\r\nSyntaxError: unexpected character after line continuation character\r\n```",
      "comment_id": 1590010955,
      "user": "tusharsadhwani",
      "created_at": "2024-05-04T16:03:55Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1590010955"
    },
    {
      "repo": "psf/black",
      "pr_number": 4343,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 614,
      "side": "RIGHT",
      "diff_hunk": "@@ -608,6 +608,12 @@ def generate_tokens(\n         except StopIteration:\n             line = \"\"\n         lnum += 1\n+\n+        # skip lines that are just a slash, to avoid storing that line's\n+        # indent information.\n+        if not contstr and line.rstrip(\"\\n\").strip(\" \\t\") == \"\\\\\":",
      "comment": "`form_feeds.py` contains a `\f\\f\\` (line 42) that is getting preserved, while the line was being deleted entirely before. Which I think is fine.",
      "comment_id": 1590011682,
      "user": "tusharsadhwani",
      "created_at": "2024-05-04T16:09:39Z",
      "url": "https://github.com/psf/black/pull/4343#discussion_r1590011682"
    },
    {
      "repo": "psf/black",
      "pr_number": 3227,
      "file_path": "src/black/trans.py",
      "line": 588,
      "side": "RIGHT",
      "diff_hunk": "@@ -572,7 +575,20 @@ def make_naked(string: str, string_prefix: str) -> str:\n         string_leaf = Leaf(token.STRING, S_leaf.value.replace(BREAK_MARK, \"\"))\n \n         if atom_node is not None:\n-            replace_child(atom_node, string_leaf)\n+            # If not all children of the atom node are merged (this can happen\n+            # when there is a standalone comment in the middle) ...\n+            if non_string_idx - string_idx < len(atom_node.children):\n+                # We need to replace the old STRING leaves with the new string leaf.\n+                first_child_idx: Optional[int] = None\n+                for idx in range(string_idx, non_string_idx):\n+                    child_idx = LL[idx].remove()\n+                    if first_child_idx is None:\n+                        first_child_idx = child_idx\n+                if first_child_idx is not None:\n+                    atom_node.insert_child(first_child_idx, string_leaf)",
      "comment": "```suggestion\r\n            if non_string_idx - string_idx < len(atom_node.children):\r\n                # We need to replace the old STRING leaves with the new string leaf.\r\n                first_child_idx = LL[string_idx].remove()\r\n                for idx in range(string_idx + 1, non_string_idx):\r\n                    LL[idx].remove()\r\n                atom_node.insert_child(first_child_idx, string_leaf)\r\n```\r\nI'm assuming that `LL[string_idx]` always points to a valid string Leaf here, but this should be a lot clearer.",
      "comment_id": 952030741,
      "user": "ichard26",
      "created_at": "2022-08-23T00:17:00Z",
      "url": "https://github.com/psf/black/pull/3227#discussion_r952030741"
    },
    {
      "repo": "psf/black",
      "pr_number": 3227,
      "file_path": "src/black/trans.py",
      "line": 588,
      "side": "RIGHT",
      "diff_hunk": "@@ -572,7 +575,20 @@ def make_naked(string: str, string_prefix: str) -> str:\n         string_leaf = Leaf(token.STRING, S_leaf.value.replace(BREAK_MARK, \"\"))\n \n         if atom_node is not None:\n-            replace_child(atom_node, string_leaf)\n+            # If not all children of the atom node are merged (this can happen\n+            # when there is a standalone comment in the middle) ...\n+            if non_string_idx - string_idx < len(atom_node.children):\n+                # We need to replace the old STRING leaves with the new string leaf.\n+                first_child_idx: Optional[int] = None\n+                for idx in range(string_idx, non_string_idx):\n+                    child_idx = LL[idx].remove()\n+                    if first_child_idx is None:\n+                        first_child_idx = child_idx\n+                if first_child_idx is not None:\n+                    atom_node.insert_child(first_child_idx, string_leaf)",
      "comment": "great suggestion!\r\n\r\nthe `if first_child_idx is not None:` check is still needed for type checking, as `.remove()` returns an `Optional[int]`, though at runtime it shouldn't be `None`.\r\n\r\ni updated with the latest commit.",
      "comment_id": 952042920,
      "user": "yilei",
      "created_at": "2022-08-23T00:50:20Z",
      "url": "https://github.com/psf/black/pull/3227#discussion_r952042920"
    },
    {
      "repo": "psf/black",
      "pr_number": 3158,
      "file_path": "tests/data/simple_cases/fmtonoff5.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+# Regression test for https://github.com/psf/black/issues/3129.\n+setup(\n+    entry_points={\n+        # fmt: off\n+        \"console_scripts\": [\n+            \"foo-bar\"\n+            \"=foo.bar.:main\",\n+        # fmt: on\n+        ]\n+    },\n+)\n+\n+\n+# Regression test for https://github.com/psf/black/issues/3129.\n+run(\n+    # fmt: off\n+    [\n+        \"ls\",\n+        \"-la\",\n+    ]\n+    # fmt: on\n+    + path\n+    ,",
      "comment": "Hmmm, this is concerning. I looked into it and the problem is that the `+` and `path` leaves are being ignored too. Fixing that with a hacky \"if `child` is a Leaf (so doesn't contain children) and contains a `# fmt: on`, then return\" works, but it breaks this example:\r\n```python\r\nsetup(\r\n    entry_points={\r\n        # fmt: off\r\n        \"console_scripts\": [\r\n            \"foo-bar\"\r\n            \"=foo.bar.:main\",\r\n        # fmt: on\r\n        ]\r\n    },\r\n)\r\n```\r\n... since `]` should be ignored too. Unfortunately looking at the CST structure, I can't see an easy way of differentiating these two cases :/  \r\n\r\nI'd prefer to just reject this (i.e. error out / ignore the formatting directive) as an invalid use of `# fmt: off/on` but then the problem is how do you detect invalid uses of `# fmt: off/on` as it seems non-trivial :(",
      "comment_id": 916295108,
      "user": "ichard26",
      "created_at": "2022-07-07T21:28:54Z",
      "url": "https://github.com/psf/black/pull/3158#discussion_r916295108"
    },
    {
      "repo": "psf/black",
      "pr_number": 4034,
      "file_path": "tests/data/cases/line_ranges_diff_edge_case.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,28 @@\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+\n+# output\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print(\"format me\")\n+print(\"format me\")\n+print(\"format me\")",
      "comment": "Why are these lines formatted? Shouldn't it only format the second and third prints?",
      "comment_id": 1398263369,
      "user": "JelleZijlstra",
      "created_at": "2023-11-18T19:53:41Z",
      "url": "https://github.com/psf/black/pull/4034#discussion_r1398263369"
    },
    {
      "repo": "psf/black",
      "pr_number": 4034,
      "file_path": "tests/data/cases/line_ranges_diff_edge_case.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,28 @@\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+\n+# output\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print(\"format me\")\n+print(\"format me\")\n+print(\"format me\")",
      "comment": "This is caused exactly by the diff algorithm used in `adjusted_lines`. In the second formatting pass, the adjusted lines becomes 12-13 but it should have stayed as 10-11.\r\n\r\nThis PR doesn't fix this underlying issue (I'll file a separate issue if this PR is merged). Until it's really fixed, I'm proposing to skip the stability check (affected by the same issue) to avoid the crash.\r\n\r\nThe edge case is very rare in real code as it requires many same unformatted lines.",
      "comment_id": 1398264754,
      "user": "yilei",
      "created_at": "2023-11-18T20:03:24Z",
      "url": "https://github.com/psf/black/pull/4034#discussion_r1398264754"
    },
    {
      "repo": "psf/black",
      "pr_number": 4034,
      "file_path": "tests/data/cases/line_ranges_diff_edge_case.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,28 @@\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+\n+# output\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print(\"format me\")\n+print(\"format me\")\n+print(\"format me\")",
      "comment": "I see, thanks. Maybe in that case we should put a warning in the docs for now about this bug.",
      "comment_id": 1398264916,
      "user": "JelleZijlstra",
      "created_at": "2023-11-18T20:04:53Z",
      "url": "https://github.com/psf/black/pull/4034#discussion_r1398264916"
    },
    {
      "repo": "psf/black",
      "pr_number": 4034,
      "file_path": "tests/data/cases/line_ranges_diff_edge_case.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,28 @@\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+\n+# output\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print(\"format me\")\n+print(\"format me\")\n+print(\"format me\")",
      "comment": "Agree that this doesn't feel very likely in real code, though @tartley apparently did run into this.",
      "comment_id": 1398265013,
      "user": "JelleZijlstra",
      "created_at": "2023-11-18T20:06:12Z",
      "url": "https://github.com/psf/black/pull/4034#discussion_r1398265013"
    },
    {
      "repo": "psf/black",
      "pr_number": 4034,
      "file_path": "tests/data/cases/line_ranges_diff_edge_case.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,28 @@\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+\n+# output\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print(\"format me\")\n+print(\"format me\")\n+print(\"format me\")",
      "comment": "Updated the doc.\r\n\r\n@tartley can correct me, but #4033 appears to be a \"toy\" example for just trying out the new `--line-ranges` feature. #4052 can also serves the purpose of collecting real world example in case it happens.\r\n\r\nWhat do you think?",
      "comment_id": 1398272728,
      "user": "yilei",
      "created_at": "2023-11-18T21:12:45Z",
      "url": "https://github.com/psf/black/pull/4034#discussion_r1398272728"
    },
    {
      "repo": "psf/black",
      "pr_number": 4034,
      "file_path": "tests/data/cases/line_ranges_diff_edge_case.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,28 @@\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+print ( \"format me\" )\n+\n+# output\n+# flags: --line-ranges=10-11\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines.\n+\n+# Reproducible example for https://github.com/psf/black/issues/4033.\n+# This can be fixed in the future if we use a better diffing algorithm, or make Black\n+# perform formatting in a single pass.\n+\n+print ( \"format me\" )\n+print(\"format me\")\n+print(\"format me\")\n+print(\"format me\")",
      "comment": "Agreed that I only encountered the problem using toy example code. By bad luck the toy example was the first thing I tried `--line-ranges` out on, while trying to integrate the use of it into my editor (e.g. so Vim would call Black on the selected range of lines). Although only a toy example it did genuinely confuse the heck out of me, and convinced me at the time that `--line-ranges` wasn't working for me at all.",
      "comment_id": 1398331258,
      "user": "tartley",
      "created_at": "2023-11-19T06:21:46Z",
      "url": "https://github.com/psf/black/pull/4034#discussion_r1398331258"
    },
    {
      "repo": "psf/black",
      "pr_number": 3368,
      "file_path": "src/black/linegen.py",
      "line": 659,
      "side": "RIGHT",
      "diff_hunk": "@@ -631,6 +644,22 @@ def right_hand_split(\n \n     Note: running this function modifies `bracket_depth` on the leaves of `line`.\n     \"\"\"\n+    rhs_result = _first_right_hand_split(line, omit=omit)\n+    yield from _maybe_split_omitting_optional_parens(\n+        rhs_result, line, line_length, features=features, omit=omit\n+    )\n+\n+\n+def _first_right_hand_split(\n+    line: Line,\n+    omit: Collection[LeafID] = (),\n+) -> _RHSResult:\n+    \"\"\"Split the line into head, body, tail starting with the last bracket pair.\n+\n+    Note: this function should not have side effects. It's replied upon by",
      "comment": "```suggestion\r\n    Note: this function should not have side effects. It's relied upon by\r\n```",
      "comment_id": 1049845794,
      "user": "JelleZijlstra",
      "created_at": "2022-12-15T16:14:21Z",
      "url": "https://github.com/psf/black/pull/3368#discussion_r1049845794"
    },
    {
      "repo": "psf/black",
      "pr_number": 4270,
      "file_path": "src/black/parsing.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,6 +238,9 @@ def stringify_ast(node: ast.AST, depth: int = 0) -> Iterator[str]:\n                 normalized = value.rstrip()\n             else:\n                 normalized = value\n-            yield f\"{'  ' * (depth + 2)}{normalized!r},  # {value.__class__.__name__}\"\n+            yield (\n+                f\"{'    ' * (len(parent_stack) + 2)}{normalized!r},  #\"",
      "comment": "nit: iiuc\r\n```suggestion\r\n                f\"{'    ' * (len(parent_stack) + 1)}{normalized!r},  #\"\r\n```",
      "comment_id": 1518698952,
      "user": "hauntsaninja",
      "created_at": "2024-03-10T01:13:14Z",
      "url": "https://github.com/psf/black/pull/4270#discussion_r1518698952"
    },
    {
      "repo": "psf/black",
      "pr_number": 4270,
      "file_path": "tests/test_black.py",
      "line": 2898,
      "side": "RIGHT",
      "diff_hunk": "@@ -2822,6 +2809,113 @@ def test_format_file_contents(self) -> None:\n             black.format_file_contents(\"x = 1\\n\", fast=True, mode=black.Mode())\n \n \n+class TestASTSafety(BlackBaseTestCase):\n+    def check_ast_equivalence(\n+        self, source: str, dest: str, *, should_fail: bool = False\n+    ) -> None:\n+        # If we get a failure, make sure it's not because the code itself\n+        # is invalid, since that will also cause assert_equivalent() to throw\n+        # ASTSafetyError.\n+        source = textwrap.dedent(source)\n+        dest = textwrap.dedent(dest)\n+        black.parse_ast(source)\n+        black.parse_ast(dest)\n+        if should_fail:\n+            with self.assertRaises(ASTSafetyError):\n+                black.assert_equivalent(source, dest)\n+        else:\n+            black.assert_equivalent(source, dest)\n+\n+    def test_assert_equivalent_basic(self) -> None:\n+        self.check_ast_equivalence(\"{}\", \"None\", should_fail=True)\n+        self.check_ast_equivalence(\"1+2\", \"1    +   2\")\n+        self.check_ast_equivalence(\"hi # comment\", \"hi\")\n+\n+    def test_assert_equivalent_del(self) -> None:\n+        self.check_ast_equivalence(\"del (a, b)\", \"del a, b\")\n+\n+    def test_assert_equivalent_strings(self) -> None:\n+        self.check_ast_equivalence('x = \"x\"', 'x = \" x \"', should_fail=True)\n+        self.check_ast_equivalence(\n+            '''\n+            \"\"\"docstring  \"\"\"\n+            ''',\n+            '''\n+            \"\"\"docstring\"\"\"\n+            ''',\n+        )\n+        self.check_ast_equivalence(\n+            '''\n+            \"\"\"docstring  \"\"\"\n+            ''',\n+            '''\n+            \"\"\"ddocstring\"\"\"\n+            ''',\n+            should_fail=True,\n+        )\n+        self.check_ast_equivalence(\n+            '''\n+            class A:\n+                \"\"\"\n+\n+                docstring\n+\n+\n+                \"\"\"\n+            ''',\n+            '''\n+            class A:\n+                \"\"\"docstring\"\"\"\n+            ''',\n+        )\n+        self.check_ast_equivalence(\n+            \"\"\"\n+            def f():\n+                \" docstring  \"\n+            \"\"\",\n+            '''\n+            def f():\n+                \"\"\"docstring\"\"\"\n+            ''',\n+        )\n+        self.check_ast_equivalence(\n+            \"\"\"\n+            async def f():\n+                \"   docstring  \"\n+            \"\"\",\n+            '''\n+            async def f():\n+                \"\"\"docstring\"\"\"\n+            ''',\n+        )\n+\n+    def test_assert_equivalent_fstring(self) -> None:\n+        major, minor = sys.version_info[:2]\n+        if major < 3 or (major == 3 and minor < 12):\n+            pytest.skip(\"relies on 3.12+ syntax\")\n+        # https://github.com/psf/black/issues/4268\n+        self.check_ast_equivalence(\n+            \"\"\"print(f\"{\"|\".join(['a','b','c'])}\")\"\"\",",
      "comment": "possibly this was meant:\r\n```suggestion\r\n            \"\"\"print(f\"{\"|\".join([a,b,c])}\")\"\"\",\r\n```",
      "comment_id": 1518699065,
      "user": "hauntsaninja",
      "created_at": "2024-03-10T01:15:21Z",
      "url": "https://github.com/psf/black/pull/4270#discussion_r1518699065"
    },
    {
      "repo": "psf/black",
      "pr_number": 4270,
      "file_path": "tests/test_black.py",
      "line": 2898,
      "side": "RIGHT",
      "diff_hunk": "@@ -2822,6 +2809,113 @@ def test_format_file_contents(self) -> None:\n             black.format_file_contents(\"x = 1\\n\", fast=True, mode=black.Mode())\n \n \n+class TestASTSafety(BlackBaseTestCase):\n+    def check_ast_equivalence(\n+        self, source: str, dest: str, *, should_fail: bool = False\n+    ) -> None:\n+        # If we get a failure, make sure it's not because the code itself\n+        # is invalid, since that will also cause assert_equivalent() to throw\n+        # ASTSafetyError.\n+        source = textwrap.dedent(source)\n+        dest = textwrap.dedent(dest)\n+        black.parse_ast(source)\n+        black.parse_ast(dest)\n+        if should_fail:\n+            with self.assertRaises(ASTSafetyError):\n+                black.assert_equivalent(source, dest)\n+        else:\n+            black.assert_equivalent(source, dest)\n+\n+    def test_assert_equivalent_basic(self) -> None:\n+        self.check_ast_equivalence(\"{}\", \"None\", should_fail=True)\n+        self.check_ast_equivalence(\"1+2\", \"1    +   2\")\n+        self.check_ast_equivalence(\"hi # comment\", \"hi\")\n+\n+    def test_assert_equivalent_del(self) -> None:\n+        self.check_ast_equivalence(\"del (a, b)\", \"del a, b\")\n+\n+    def test_assert_equivalent_strings(self) -> None:\n+        self.check_ast_equivalence('x = \"x\"', 'x = \" x \"', should_fail=True)\n+        self.check_ast_equivalence(\n+            '''\n+            \"\"\"docstring  \"\"\"\n+            ''',\n+            '''\n+            \"\"\"docstring\"\"\"\n+            ''',\n+        )\n+        self.check_ast_equivalence(\n+            '''\n+            \"\"\"docstring  \"\"\"\n+            ''',\n+            '''\n+            \"\"\"ddocstring\"\"\"\n+            ''',\n+            should_fail=True,\n+        )\n+        self.check_ast_equivalence(\n+            '''\n+            class A:\n+                \"\"\"\n+\n+                docstring\n+\n+\n+                \"\"\"\n+            ''',\n+            '''\n+            class A:\n+                \"\"\"docstring\"\"\"\n+            ''',\n+        )\n+        self.check_ast_equivalence(\n+            \"\"\"\n+            def f():\n+                \" docstring  \"\n+            \"\"\",\n+            '''\n+            def f():\n+                \"\"\"docstring\"\"\"\n+            ''',\n+        )\n+        self.check_ast_equivalence(\n+            \"\"\"\n+            async def f():\n+                \"   docstring  \"\n+            \"\"\",\n+            '''\n+            async def f():\n+                \"\"\"docstring\"\"\"\n+            ''',\n+        )\n+\n+    def test_assert_equivalent_fstring(self) -> None:\n+        major, minor = sys.version_info[:2]\n+        if major < 3 or (major == 3 and minor < 12):\n+            pytest.skip(\"relies on 3.12+ syntax\")\n+        # https://github.com/psf/black/issues/4268\n+        self.check_ast_equivalence(\n+            \"\"\"print(f\"{\"|\".join(['a','b','c'])}\")\"\"\",",
      "comment": "I confused myself with shell quoting, I thought Black somehow removed the quotes. I'll keep your version so we have two tests.",
      "comment_id": 1518702260,
      "user": "JelleZijlstra",
      "created_at": "2024-03-10T01:33:40Z",
      "url": "https://github.com/psf/black/pull/4270#discussion_r1518702260"
    },
    {
      "repo": "psf/black",
      "pr_number": 4270,
      "file_path": "src/black/parsing.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -110,6 +110,10 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n+class ASTSafetyError(Exception):",
      "comment": "This should probably inherit from `AssertionError` since you are replacing `raise AssertionError` with this new exception.",
      "comment_id": 1597507502,
      "user": "spyoungtech",
      "created_at": "2024-05-11T21:04:18Z",
      "url": "https://github.com/psf/black/pull/4270#discussion_r1597507502"
    },
    {
      "repo": "psf/black",
      "pr_number": 4270,
      "file_path": "src/black/parsing.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -110,6 +110,10 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n+class ASTSafetyError(Exception):",
      "comment": "We don't provide compatibility guarantees for this function. I don't think inheriting from AssertionError makes semantic sense.",
      "comment_id": 1597527834,
      "user": "JelleZijlstra",
      "created_at": "2024-05-12T00:41:55Z",
      "url": "https://github.com/psf/black/pull/4270#discussion_r1597527834"
    },
    {
      "repo": "psf/black",
      "pr_number": 4270,
      "file_path": "src/black/parsing.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -110,6 +110,10 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n+class ASTSafetyError(Exception):",
      "comment": "Thanks for the response. That makes sense considering that many people probably don't use this functionality directly and I maybe agree inheriting from `AssertionError` is odd from a semantic/purity standpoint, even if it's less practical for compatibility (which as you mention is a non-goal here).",
      "comment_id": 1597696533,
      "user": "spyoungtech",
      "created_at": "2024-05-12T19:30:56Z",
      "url": "https://github.com/psf/black/pull/4270#discussion_r1597696533"
    },
    {
      "repo": "psf/black",
      "pr_number": 4346,
      "file_path": "docs/conf.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,6 +32,36 @@ def make_pypi_svg(version: str) -> None:\n         f.write(svg)\n \n \n+def replace_pr_numbers_with_links(content: str) -> str:\n+    \"\"\"Replaces all PR numbers with the corresponding GitHub link.\"\"\"\n+\n+    base_url = \"https://github.com/psf/black/pull/\"\n+    pr_num_regex = re.compile(r\"\\(#(\\d+)\\)\")\n+\n+    def num_to_link(match: re.Match) -> str:\n+        full_match, number = match.group(0, 1)\n+        url = f\"{base_url}{number}\"\n+        return f\"[{full_match}]({url})\"\n+\n+    return pr_num_regex.sub(num_to_link, content)\n+\n+\n+def handle_include_read(\n+        app: Sphinx,",
      "comment": "I guess we're not formatting this file with Black? Let's fix that in a separate PR though.",
      "comment_id": 1589995099,
      "user": "JelleZijlstra",
      "created_at": "2024-05-04T14:19:25Z",
      "url": "https://github.com/psf/black/pull/4346#discussion_r1589995099"
    },
    {
      "repo": "psf/black",
      "pr_number": 4346,
      "file_path": "docs/conf.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,6 +32,36 @@ def make_pypi_svg(version: str) -> None:\n         f.write(svg)\n \n \n+def replace_pr_numbers_with_links(content: str) -> str:\n+    \"\"\"Replaces all PR numbers with the corresponding GitHub link.\"\"\"\n+\n+    base_url = \"https://github.com/psf/black/pull/\"\n+    pr_num_regex = re.compile(r\"\\(#(\\d+)\\)\")\n+\n+    def num_to_link(match: re.Match) -> str:\n+        full_match, number = match.group(0, 1)\n+        url = f\"{base_url}{number}\"\n+        return f\"[{full_match}]({url})\"",
      "comment": "```suggestion\r\n        return f\"([#{number}]({url}))\"\r\n```\r\nLet's not link the parentheses.",
      "comment_id": 1589995312,
      "user": "JelleZijlstra",
      "created_at": "2024-05-04T14:21:35Z",
      "url": "https://github.com/psf/black/pull/4346#discussion_r1589995312"
    },
    {
      "repo": "psf/black",
      "pr_number": 4346,
      "file_path": "docs/conf.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,6 +32,36 @@ def make_pypi_svg(version: str) -> None:\n         f.write(svg)\n \n \n+def replace_pr_numbers_with_links(content: str) -> str:\n+    \"\"\"Replaces all PR numbers with the corresponding GitHub link.\"\"\"\n+\n+    base_url = \"https://github.com/psf/black/pull/\"\n+    pr_num_regex = re.compile(r\"\\(#(\\d+)\\)\")\n+\n+    def num_to_link(match: re.Match) -> str:",
      "comment": "```suggestion\r\n    def num_to_link(match: re.Match[str]) -> str:\r\n```",
      "comment_id": 1589995328,
      "user": "JelleZijlstra",
      "created_at": "2024-05-04T14:21:44Z",
      "url": "https://github.com/psf/black/pull/4346#discussion_r1589995328"
    },
    {
      "repo": "psf/black",
      "pr_number": 4338,
      "file_path": "tests/test_schema.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,7 +5,7 @@\n def test_schema_entrypoint() -> None:\n     if sys.version_info < (3, 10):\n         eps = importlib.metadata.entry_points()[\"validate_pyproject.tool_schema\"]\n-        (black_ep,) = [ep for ep in eps if ep.name == \"black\"]\n+        (black_ep,) = (ep for ep in eps if ep.name == \"black\")",
      "comment": "I know pyupgrade does this but I don't like this change. It feels harder to understand (generator expressions are rarer than listcomps). The genexp might sometimes be faster, but it's unlikely to matter.\r\n\r\nIn this case, the new code appears to be slower for me (benchmark on Linux on 3.9):\r\n\r\n```\r\nIn [8]: eps = importlib.metadata.entry_points()[\"validate_pyproject.tool_schema\"]\r\n\r\nIn [9]: eps\r\nOut[9]: (EntryPoint(name='black', value='black.schema:get_schema', group='validate_pyproject.tool_schema'),)\r\n\r\nIn [10]: %timeit (black_ep,) = [ep for ep in eps if ep.name == \"black\"]\r\n170 ns \u00b1 1.32 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\r\n\r\nIn [11]: %timeit (black_ep,) = (ep for ep in eps if ep.name == \"black\")\r\n232 ns \u00b1 1.61 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\r\n```",
      "comment_id": 1581509973,
      "user": "JelleZijlstra",
      "created_at": "2024-04-26T20:39:32Z",
      "url": "https://github.com/psf/black/pull/4338#discussion_r1581509973"
    },
    {
      "repo": "psf/black",
      "pr_number": 4338,
      "file_path": "scripts/migrate-black.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,7 +51,7 @@ def blackify(base_branch: str, black_command: str, logger: logging.Logger) -> in\n                 \"diff\",\n                 \"--binary\",\n                 \"--find-copies\",\n-                \"%s-black..%s-black\" % (last_commit, commit),\n+                \"{}-black..{}-black\".format(last_commit, commit),",
      "comment": "```suggestion\r\n                f\"{last_commit}-black..{commit}-black\",\r\n```",
      "comment_id": 1581549691,
      "user": "AlexWaygood",
      "created_at": "2024-04-26T21:22:14Z",
      "url": "https://github.com/psf/black/pull/4338#discussion_r1581549691"
    },
    {
      "repo": "psf/black",
      "pr_number": 4338,
      "file_path": "scripts/migrate-black.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,7 +51,7 @@ def blackify(base_branch: str, black_command: str, logger: logging.Logger) -> in\n                 \"diff\",\n                 \"--binary\",\n                 \"--find-copies\",\n-                \"%s-black..%s-black\" % (last_commit, commit),\n+                \"{}-black..{}-black\".format(last_commit, commit),",
      "comment": "If you have any complains about how pyupgarde works please discuss that with pypgrade maintainer(s).\r\nIMO cherry-picking \"what I like/what I don't\" does not make to much sense.\r\n\r\nIt is great value that it is GoodEnough\u2122\ufe0f tool allowing to clean some code cleanups between major python versions.\r\n\r\nYou know that `black` code can be filtered to cut off some legacy tails.\r\nIf you don't like this PR just close it .. really no one will be hurt.\r\n\r\nFYI: in only few weeks 3.8 will be EOSed and with that version can be dropped much more.",
      "comment_id": 1581802266,
      "user": "kloczek",
      "created_at": "2024-04-27T11:01:03Z",
      "url": "https://github.com/psf/black/pull/4338#discussion_r1581802266"
    },
    {
      "repo": "psf/black",
      "pr_number": 4338,
      "file_path": "scripts/migrate-black.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,7 +51,7 @@ def blackify(base_branch: str, black_command: str, logger: logging.Logger) -> in\n                 \"diff\",\n                 \"--binary\",\n                 \"--find-copies\",\n-                \"%s-black..%s-black\" % (last_commit, commit),\n+                \"{}-black..{}-black\".format(last_commit, commit),",
      "comment": "Hi, sorry to hear you're not a fan of my suggestion!\r\n\r\n> IMO cherry-picking \"what I like/what I don't\" does not make to much sense.\r\n\r\nNot sure I agree there -- in my opinion, any proposed change should be considered on its own merits, regardless of whether the change has come about as a result of an autofix or codemod. But I'm not a Black maintainer, so the decision on how best to review this isn't up to me \ud83d\ude0a\r\n\r\n> If you don't like this PR just close it .. really no one will be hurt.\r\n\r\nWell, again, I'm not a maintainer, so I don't personally in fact have this power",
      "comment_id": 1581813987,
      "user": "AlexWaygood",
      "created_at": "2024-04-27T11:39:12Z",
      "url": "https://github.com/psf/black/pull/4338#discussion_r1581813987"
    },
    {
      "repo": "psf/black",
      "pr_number": 4338,
      "file_path": "scripts/migrate-black.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,7 +51,7 @@ def blackify(base_branch: str, black_command: str, logger: logging.Logger) -> in\n                 \"diff\",\n                 \"--binary\",\n                 \"--find-copies\",\n-                \"%s-black..%s-black\" % (last_commit, commit),\n+                \"{}-black..{}-black\".format(last_commit, commit),",
      "comment": "> FYI: in only few weeks 3.8 will be EOSed\r\n\r\nPython 3.8 is scheduled to go End Of Life in October 2024, FWIW, so we have at least six months to go yet",
      "comment_id": 1581816144,
      "user": "AlexWaygood",
      "created_at": "2024-04-27T11:46:07Z",
      "url": "https://github.com/psf/black/pull/4338#discussion_r1581816144"
    },
    {
      "repo": "psf/black",
      "pr_number": 4318,
      "file_path": "tests/data/cases/stub_empty_line.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,7 @@\n+class C:\n+    def f(self):\n+        ",
      "comment": "Maybe add test cases (in the same file) where there are comments in various places around the `...`, e.g. on a line by itself or right after `:`. ",
      "comment_id": 1574211898,
      "user": "JelleZijlstra",
      "created_at": "2024-04-22T06:49:12Z",
      "url": "https://github.com/psf/black/pull/4318#discussion_r1574211898"
    },
    {
      "repo": "psf/black",
      "pr_number": 3822,
      "file_path": "src/black/strings.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -243,6 +243,71 @@ def normalize_string_quotes(s: str) -> str:\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n \n+def normalize_fstring_quotes(\n+    quote: str,\n+    middles: List[Leaf],\n+    is_raw_fstring: bool\n+) -> Tuple[List[Leaf], str]:\n+    \"\"\"Prefer double quotes but only if it doesn't cause more escaping.\n+\n+    Adds or removes backslashes as appropriate.\n+    \"\"\"\n+    if quote == '\"\"\"':\n+        return middles, quote\n+\n+    elif quote == \"'''\":\n+        new_quote = '\"\"\"'\n+    elif quote == '\"':\n+        new_quote = \"'\"\n+    else:\n+        new_quote = '\"'\n+\n+    unescaped_new_quote = _cached_compile(rf\"(([^\\\\]|^)(\\\\\\\\)*){new_quote}\")\n+    escaped_new_quote = _cached_compile(rf\"([^\\\\]|^)\\\\((?:\\\\\\\\)*){new_quote}\")\n+    escaped_orig_quote = _cached_compile(rf\"([^\\\\]|^)\\\\((?:\\\\\\\\)*){quote}\")\n+    if is_raw_fstring:\n+        for middle in middles:\n+            if unescaped_new_quote.search(middle.value):\n+                # There's at least one unescaped new_quote in this raw string\n+                # so converting is impossible\n+                return middles, quote\n+\n+        # Do not introduce or remove backslashes in raw strings, just use double quote\n+        return middles, '\"'\n+\n+    new_segments = []\n+    for middle in middles:\n+        segment = middle.value\n+        # remove unnecessary escapes\n+        new_segment = sub_twice(escaped_new_quote, rf\"\\1\\2{new_quote}\", segment)\n+        if segment != new_segment:\n+            # Consider the string without unnecessary escapes as the original\n+            middle.value = new_segment\n+\n+        new_segment = sub_twice(escaped_orig_quote, rf\"\\1\\2{quote}\", new_segment)\n+        new_segment = sub_twice(unescaped_new_quote, rf\"\\1\\\\{new_quote}\", new_segment)\n+        new_segments.append(new_segment)\n+\n+\n+    if new_quote == '\"\"\"' and new_segments[-1][-1:] == '\"':",
      "comment": "```suggestion\r\n    if new_quote == '\"\"\"' and new_segments[-1].endswith('\"'):\r\n```",
      "comment_id": 1375160229,
      "user": "JelleZijlstra",
      "created_at": "2023-10-28T03:59:37Z",
      "url": "https://github.com/psf/black/pull/3822#discussion_r1375160229"
    },
    {
      "repo": "psf/black",
      "pr_number": 3822,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 471,
      "side": "RIGHT",
      "diff_hunk": "@@ -418,6 +467,15 @@ def untokenize(iterable: Iterable[TokenInfo]) -> str:\n     return ut.untokenize(iterable)\n \n \n+def is_fstring_start(token: str) -> bool:\n+    # TODO: builtins.any is shadowed :(",
      "comment": "Would suggest adding `import builtins` and using `builtins.any`.",
      "comment_id": 1375160362,
      "user": "JelleZijlstra",
      "created_at": "2023-10-28T04:00:53Z",
      "url": "https://github.com/psf/black/pull/3822#discussion_r1375160362"
    },
    {
      "repo": "psf/black",
      "pr_number": 3822,
      "file_path": "src/blib2to3/pgen2/driver.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,7 +167,9 @@ def parse_tokens(self, tokens: Iterable[GoodTokenInfo], debug: bool = False) ->\n             if type in {token.INDENT, token.DEDENT}:\n                 prefix = _prefix\n             lineno, column = end\n-            if value.endswith(\"\\n\"):\n+            # FSTRING_MIDDLE is the only character that can end with a newline, and",
      "comment": "```suggestion\r\n            # FSTRING_MIDDLE is the only token that can end with a newline, and\r\n```",
      "comment_id": 1486266779,
      "user": "JelleZijlstra",
      "created_at": "2024-02-12T14:32:34Z",
      "url": "https://github.com/psf/black/pull/3822#discussion_r1486266779"
    },
    {
      "repo": "psf/black",
      "pr_number": 3822,
      "file_path": "tests/util.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -237,7 +237,7 @@ def get_flags_parser() -> argparse.ArgumentParser:\n         \"--target-version\",\n         action=\"append\",\n         type=lambda val: TargetVersion[val.upper()],\n-        default=(),\n+        default=[],",
      "comment": "this was causing some mypy issue locally. I'll check once again.",
      "comment_id": 1486275756,
      "user": "tusharsadhwani",
      "created_at": "2024-02-12T14:39:02Z",
      "url": "https://github.com/psf/black/pull/3822#discussion_r1486275756"
    },
    {
      "repo": "psf/black",
      "pr_number": 3822,
      "file_path": "src/black/strings.py",
      "line": 219,
      "side": "RIGHT",
      "diff_hunk": "@@ -217,6 +216,7 @@ def normalize_string_quotes(s: str) -> str:\n             s = f\"{prefix}{orig_quote}{body}{orig_quote}\"\n         new_body = sub_twice(escaped_orig_quote, rf\"\\1\\2{orig_quote}\", new_body)\n         new_body = sub_twice(unescaped_new_quote, rf\"\\1\\\\{new_quote}\", new_body)\n+    # TODO: can probably be removed",
      "comment": "removing it seems to fail tests, so i'm keeping the code.",
      "comment_id": 1548636573,
      "user": "tusharsadhwani",
      "created_at": "2024-04-02T21:33:57Z",
      "url": "https://github.com/psf/black/pull/3822#discussion_r1548636573"
    },
    {
      "repo": "psf/black",
      "pr_number": 3822,
      "file_path": "tests/data/cases/pep_701.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,216 @@\n+# flags: --minimum-version=3.12\n+x = f\"foo\"\n+x = f'foo'\n+x = f\"\"\"foo\"\"\"\n+x = f'''foo'''\n+x = f\"foo {{ bar {{ baz\"\n+x = f\"foo {{ {2 + 2}bar {{ baz\"\n+x = f'foo {{ {2 + 2}bar {{ baz'\n+x = f\"\"\"foo {{ {2 + 2}bar {{ baz\"\"\"\n+x = f'''foo {{ {2 + 2}bar {{ baz'''\n+\n+# edge case: FSTRING_MIDDLE containing only whitespace should not be stripped\n+x = f\"{a} {b}\"\n+\n+x = f\"foo {\n+    2 + 2\n+} bar baz\"\n+\n+x = f\"foo {{ {\"a  {2 + 2}  b\"}bar {{ baz\"\n+x = f\"foo {{ {f'a  {2 + 2}  b'}bar {{ baz\"\n+x = f\"foo {{ {f\"a  {2 + 2}  b\"}bar {{ baz\"\n+\n+x = f\"foo {{ {f'a  {f\"a  {2 + 2}  b\"}  b'}bar {{ baz\"\n+x = f\"foo {{ {f\"a  {f\"a  {2 + 2}  b\"}  b\"}bar {{ baz\"\n+\n+x = \"\"\"foo {{ {2 + 2}bar\n+baz\"\"\"\n+\n+\n+x = f\"\"\"foo {{ {2 + 2}bar {{ baz\"\"\"\n+\n+x = f\"\"\"foo {{ {\n+    2 + 2\n+}bar {{ baz\"\"\"\n+\n+\n+x = f\"\"\"foo {{ {\n+    2 + 2\n+}bar\n+baz\"\"\"\n+\n+x = f\"\"\"foo {{ a\n+    foo {2 + 2}bar {{ baz\n+\n+    x = f\"foo {{ {\n+        2 + 2  # comment\n+    }bar\"\n+\n+    {{ baz\n+\n+    }} buzz\n+\n+    {print(\"abc\" + \"def\"\n+)}\n+abc\"\"\"\n+\n+# edge case: end triple quotes at index zero\n+f\"\"\"foo {2+2} bar\n+\"\"\"\n+\n+f' \\' {f\"'\"} \\' '\n+f\" \\\" {f'\"'} \\\" \"\n+\n+x = f\"a{2+2:=^72}b\"\n+x = f\"a{2+2:x}b\"\n+\n+rf'foo'\n+rf'{foo}'\n+\n+f\"{x:{y}d}\"\n+\n+x = f\"a{2+2:=^{x}}b\"\n+x = f\"a{2+2:=^{foo(x+y**2):something else}}b\"\n+x = f\"a{2+2:=^{foo(x+y**2):something else}one more}b\"\n+f'{(abc:=10)}'\n+\n+f\"This is a really long string, but just make sure that you reflow fstrings {\n+    2+2:d\n+}\"\n+f\"This is a really long string, but just make sure that you reflow fstrings correctly {2+2:d}\"\n+\n+f\"{2+2=}\"\n+f\"{2+2    =    }\"\n+f\"{     2      +     2    =    }\"\n+\n+# TODO:\n+# f\"\"\"foo {",
      "comment": "Is it easy to fix this TODO in Black? I checked and this syntax works in 3.11 and with current Black, so it would be a regression if we start failing on it.",
      "comment_id": 1574261793,
      "user": "JelleZijlstra",
      "created_at": "2024-04-22T07:31:49Z",
      "url": "https://github.com/psf/black/pull/3822#discussion_r1574261793"
    },
    {
      "repo": "psf/black",
      "pr_number": 3822,
      "file_path": "tests/data/cases/pep_701.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,216 @@\n+# flags: --minimum-version=3.12\n+x = f\"foo\"\n+x = f'foo'\n+x = f\"\"\"foo\"\"\"\n+x = f'''foo'''\n+x = f\"foo {{ bar {{ baz\"\n+x = f\"foo {{ {2 + 2}bar {{ baz\"\n+x = f'foo {{ {2 + 2}bar {{ baz'\n+x = f\"\"\"foo {{ {2 + 2}bar {{ baz\"\"\"\n+x = f'''foo {{ {2 + 2}bar {{ baz'''\n+\n+# edge case: FSTRING_MIDDLE containing only whitespace should not be stripped\n+x = f\"{a} {b}\"\n+\n+x = f\"foo {\n+    2 + 2\n+} bar baz\"\n+\n+x = f\"foo {{ {\"a  {2 + 2}  b\"}bar {{ baz\"\n+x = f\"foo {{ {f'a  {2 + 2}  b'}bar {{ baz\"\n+x = f\"foo {{ {f\"a  {2 + 2}  b\"}bar {{ baz\"\n+\n+x = f\"foo {{ {f'a  {f\"a  {2 + 2}  b\"}  b'}bar {{ baz\"\n+x = f\"foo {{ {f\"a  {f\"a  {2 + 2}  b\"}  b\"}bar {{ baz\"\n+\n+x = \"\"\"foo {{ {2 + 2}bar\n+baz\"\"\"\n+\n+\n+x = f\"\"\"foo {{ {2 + 2}bar {{ baz\"\"\"\n+\n+x = f\"\"\"foo {{ {\n+    2 + 2\n+}bar {{ baz\"\"\"\n+\n+\n+x = f\"\"\"foo {{ {\n+    2 + 2\n+}bar\n+baz\"\"\"\n+\n+x = f\"\"\"foo {{ a\n+    foo {2 + 2}bar {{ baz\n+\n+    x = f\"foo {{ {\n+        2 + 2  # comment\n+    }bar\"\n+\n+    {{ baz\n+\n+    }} buzz\n+\n+    {print(\"abc\" + \"def\"\n+)}\n+abc\"\"\"\n+\n+# edge case: end triple quotes at index zero\n+f\"\"\"foo {2+2} bar\n+\"\"\"\n+\n+f' \\' {f\"'\"} \\' '\n+f\" \\\" {f'\"'} \\\" \"\n+\n+x = f\"a{2+2:=^72}b\"\n+x = f\"a{2+2:x}b\"\n+\n+rf'foo'\n+rf'{foo}'\n+\n+f\"{x:{y}d}\"\n+\n+x = f\"a{2+2:=^{x}}b\"\n+x = f\"a{2+2:=^{foo(x+y**2):something else}}b\"\n+x = f\"a{2+2:=^{foo(x+y**2):something else}one more}b\"\n+f'{(abc:=10)}'\n+\n+f\"This is a really long string, but just make sure that you reflow fstrings {\n+    2+2:d",
      "comment": "This is a SyntaxError in 3.12.0 but not 3.12.1, I suppose due to python/cpython#112059. Ran into this because I ran the test suite on 3.12.0 and it failed.\r\n\r\nNo change requested, but it seems possible this will cause trouble again in the future.",
      "comment_id": 1574263809,
      "user": "JelleZijlstra",
      "created_at": "2024-04-22T07:33:27Z",
      "url": "https://github.com/psf/black/pull/3822#discussion_r1574263809"
    },
    {
      "repo": "psf/black",
      "pr_number": 3822,
      "file_path": "tests/data/cases/pep_701.py",
      "line": 108,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,216 @@\n+# flags: --minimum-version=3.12\n+x = f\"foo\"\n+x = f'foo'\n+x = f\"\"\"foo\"\"\"\n+x = f'''foo'''\n+x = f\"foo {{ bar {{ baz\"\n+x = f\"foo {{ {2 + 2}bar {{ baz\"\n+x = f'foo {{ {2 + 2}bar {{ baz'\n+x = f\"\"\"foo {{ {2 + 2}bar {{ baz\"\"\"\n+x = f'''foo {{ {2 + 2}bar {{ baz'''\n+\n+# edge case: FSTRING_MIDDLE containing only whitespace should not be stripped\n+x = f\"{a} {b}\"\n+\n+x = f\"foo {\n+    2 + 2\n+} bar baz\"\n+\n+x = f\"foo {{ {\"a  {2 + 2}  b\"}bar {{ baz\"\n+x = f\"foo {{ {f'a  {2 + 2}  b'}bar {{ baz\"\n+x = f\"foo {{ {f\"a  {2 + 2}  b\"}bar {{ baz\"\n+\n+x = f\"foo {{ {f'a  {f\"a  {2 + 2}  b\"}  b'}bar {{ baz\"\n+x = f\"foo {{ {f\"a  {f\"a  {2 + 2}  b\"}  b\"}bar {{ baz\"\n+\n+x = \"\"\"foo {{ {2 + 2}bar\n+baz\"\"\"\n+\n+\n+x = f\"\"\"foo {{ {2 + 2}bar {{ baz\"\"\"\n+\n+x = f\"\"\"foo {{ {\n+    2 + 2\n+}bar {{ baz\"\"\"\n+\n+\n+x = f\"\"\"foo {{ {\n+    2 + 2\n+}bar\n+baz\"\"\"\n+\n+x = f\"\"\"foo {{ a\n+    foo {2 + 2}bar {{ baz\n+\n+    x = f\"foo {{ {\n+        2 + 2  # comment\n+    }bar\"\n+\n+    {{ baz\n+\n+    }} buzz\n+\n+    {print(\"abc\" + \"def\"\n+)}\n+abc\"\"\"\n+\n+# edge case: end triple quotes at index zero\n+f\"\"\"foo {2+2} bar\n+\"\"\"\n+\n+f' \\' {f\"'\"} \\' '\n+f\" \\\" {f'\"'} \\\" \"\n+\n+x = f\"a{2+2:=^72}b\"\n+x = f\"a{2+2:x}b\"\n+\n+rf'foo'\n+rf'{foo}'\n+\n+f\"{x:{y}d}\"\n+\n+x = f\"a{2+2:=^{x}}b\"\n+x = f\"a{2+2:=^{foo(x+y**2):something else}}b\"\n+x = f\"a{2+2:=^{foo(x+y**2):something else}one more}b\"\n+f'{(abc:=10)}'\n+\n+f\"This is a really long string, but just make sure that you reflow fstrings {\n+    2+2:d\n+}\"\n+f\"This is a really long string, but just make sure that you reflow fstrings correctly {2+2:d}\"\n+\n+f\"{2+2=}\"\n+f\"{2+2    =    }\"\n+f\"{     2      +     2    =    }\"\n+\n+# TODO:\n+# f\"\"\"foo {\n+#     datetime.datetime.now():%Y\n+# %m\n+# %d\n+# }\"\"\"\n+\n+raise ValueError(\n+                \"xxxxxxxxxxxIncorrect --line-ranges format, expect START-END, found\"\n+                f\" {lines_str!r}\"\n+            )\n+\n+f\"`escape` only permitted in {{'html', 'latex', 'latex-math'}}, \\\n+got {escape}\"\n+\n+x = f'\\N{GREEK CAPITAL LETTER DELTA} \\N{SNOWMAN} {x}'\n+fr'\\{{\\}}'\n+\n+f\"\"\"\n+    WITH {f'''\n+    {1}_cte AS ()'''}\n+\"\"\"\n+",
      "comment": "Suggest adding this test case:\r\n\r\n```\r\nf\"{\r\nX\r\n!r\r\n}\"\r\n```\r\n\r\nIt works already, but good to cover it in the test suite.",
      "comment_id": 1574266882,
      "user": "JelleZijlstra",
      "created_at": "2024-04-22T07:35:46Z",
      "url": "https://github.com/psf/black/pull/3822#discussion_r1574266882"
    },
    {
      "repo": "psf/black",
      "pr_number": 4294,
      "file_path": "action/main.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,12 +15,101 @@\n JUPYTER = os.getenv(\"INPUT_JUPYTER\") == \"true\"\n BLACK_ARGS = os.getenv(\"INPUT_BLACK_ARGS\", default=\"\")\n VERSION = os.getenv(\"INPUT_VERSION\", default=\"\")\n+USE_PYPROJECT = os.getenv(\"INPUT_USE_PYPROJECT\") == \"true\"\n+\n+BLACK_VERSION_RE = re.compile(r\"^black([^A-Z0-9._-]+.*)$\", re.IGNORECASE)\n+EXTRAS_RE = re.compile(r\"\\[.*\\]\")\n+\n+\n+def determine_version_specifier() -> str:\n+    \"\"\"Determine the version of Black to install.\n+\n+    The version can be specified either via the `with.version` input or via the\n+    pyproject.toml file if `with.use_pyproject` is set to `true`.\n+    \"\"\"\n+    if USE_PYPROJECT and VERSION:\n+        print(\n+            \"::error::'with.version' and 'with.use_pyproject' inputs are \"\n+            \"mutually exclusive.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+    if USE_PYPROJECT:\n+        return read_version_specifier_from_pyproject()\n+    elif VERSION and VERSION[0] in \"0123456789\":\n+        return f\"=={VERSION}\"\n+    else:\n+        return VERSION\n+\n+\n+def read_version_specifier_from_pyproject() -> str:\n+    if sys.version_info < (3, 11):\n+        print(\n+            \"::error::'with.use_pyproject' input requires Python 3.11 or later.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+\n+    import tomllib  # type: ignore[import-not-found,unreachable]\n+\n+    try:\n+        with Path(\"pyproject.toml\").open(\"rb\") as fp:\n+            pyproject = tomllib.load(fp)\n+    except FileNotFoundError:\n+        print(\n+            \"::error::'with.use_pyproject' input requires a pyproject.toml file.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+\n+    version = pyproject.get(\"tool\", {}).get(\"black\", {}).get(\"required-version\")\n+    if version is not None:\n+        return f\"=={version}\"\n+\n+    arrays = [\n+        pyproject.get(\"project\", {}).get(\"dependencies\"),\n+        *pyproject.get(\"project\", {}).get(\"optional-dependencies\", {}).values(),\n+    ]\n+    for array in arrays:\n+        version = find_black_version_in_array(array)\n+        if version is not None:\n+            break\n+\n+    if version is None:\n+        print(\n+            \"::error::'black' dependency missing from pyproject.toml.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+\n+    return version\n+\n+\n+def find_black_version_in_array(array: object) -> Union[str, None]:\n+    if not isinstance(array, list):\n+        return None\n+    try:\n+        for item in array:\n+            # Rudimentary PEP 508 parsing.\n+            item = item.split(\";\")[0]\n+            item = EXTRAS_RE.sub(\"\", item).strip()\n+            if item == \"black\":\n+                return \"\"",
      "comment": "Would it make more sense to continue here? It looks like below we ultimately end up ignoring the empty string anyway and using the action version instead.",
      "comment_id": 1551549753,
      "user": "JelleZijlstra",
      "created_at": "2024-04-04T12:09:09Z",
      "url": "https://github.com/psf/black/pull/4294#discussion_r1551549753"
    },
    {
      "repo": "psf/black",
      "pr_number": 4294,
      "file_path": "action/main.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,12 +15,101 @@\n JUPYTER = os.getenv(\"INPUT_JUPYTER\") == \"true\"\n BLACK_ARGS = os.getenv(\"INPUT_BLACK_ARGS\", default=\"\")\n VERSION = os.getenv(\"INPUT_VERSION\", default=\"\")\n+USE_PYPROJECT = os.getenv(\"INPUT_USE_PYPROJECT\") == \"true\"\n+\n+BLACK_VERSION_RE = re.compile(r\"^black([^A-Z0-9._-]+.*)$\", re.IGNORECASE)\n+EXTRAS_RE = re.compile(r\"\\[.*\\]\")\n+\n+\n+def determine_version_specifier() -> str:\n+    \"\"\"Determine the version of Black to install.\n+\n+    The version can be specified either via the `with.version` input or via the\n+    pyproject.toml file if `with.use_pyproject` is set to `true`.\n+    \"\"\"\n+    if USE_PYPROJECT and VERSION:\n+        print(\n+            \"::error::'with.version' and 'with.use_pyproject' inputs are \"\n+            \"mutually exclusive.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+    if USE_PYPROJECT:\n+        return read_version_specifier_from_pyproject()\n+    elif VERSION and VERSION[0] in \"0123456789\":\n+        return f\"=={VERSION}\"\n+    else:\n+        return VERSION\n+\n+\n+def read_version_specifier_from_pyproject() -> str:\n+    if sys.version_info < (3, 11):\n+        print(\n+            \"::error::'with.use_pyproject' input requires Python 3.11 or later.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+\n+    import tomllib  # type: ignore[import-not-found,unreachable]\n+\n+    try:\n+        with Path(\"pyproject.toml\").open(\"rb\") as fp:\n+            pyproject = tomllib.load(fp)\n+    except FileNotFoundError:\n+        print(\n+            \"::error::'with.use_pyproject' input requires a pyproject.toml file.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+\n+    version = pyproject.get(\"tool\", {}).get(\"black\", {}).get(\"required-version\")\n+    if version is not None:\n+        return f\"=={version}\"\n+\n+    arrays = [\n+        pyproject.get(\"project\", {}).get(\"dependencies\"),\n+        *pyproject.get(\"project\", {}).get(\"optional-dependencies\", {}).values(),\n+    ]\n+    for array in arrays:\n+        version = find_black_version_in_array(array)\n+        if version is not None:\n+            break\n+\n+    if version is None:\n+        print(\n+            \"::error::'black' dependency missing from pyproject.toml.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+\n+    return version\n+\n+\n+def find_black_version_in_array(array: object) -> Union[str, None]:\n+    if not isinstance(array, list):\n+        return None\n+    try:\n+        for item in array:\n+            # Rudimentary PEP 508 parsing.\n+            item = item.split(\";\")[0]\n+            item = EXTRAS_RE.sub(\"\", item).strip()\n+            if item == \"black\":\n+                return \"\"",
      "comment": "If you trace it all the way back to `read_version_specifier_from_pyproject()`, there is a difference: Due to returning `\"\"`, we don't generate an error in the action, but use the action's default behavior (use the latest version). If we'd return `None`, this would cause an error when using just `black` as a requirement.",
      "comment_id": 1551593537,
      "user": "srittau",
      "created_at": "2024-04-04T12:33:31Z",
      "url": "https://github.com/psf/black/pull/4294#discussion_r1551593537"
    },
    {
      "repo": "psf/black",
      "pr_number": 4294,
      "file_path": "action/main.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,12 +15,101 @@\n JUPYTER = os.getenv(\"INPUT_JUPYTER\") == \"true\"\n BLACK_ARGS = os.getenv(\"INPUT_BLACK_ARGS\", default=\"\")\n VERSION = os.getenv(\"INPUT_VERSION\", default=\"\")\n+USE_PYPROJECT = os.getenv(\"INPUT_USE_PYPROJECT\") == \"true\"\n+\n+BLACK_VERSION_RE = re.compile(r\"^black([^A-Z0-9._-]+.*)$\", re.IGNORECASE)\n+EXTRAS_RE = re.compile(r\"\\[.*\\]\")\n+\n+\n+def determine_version_specifier() -> str:\n+    \"\"\"Determine the version of Black to install.\n+\n+    The version can be specified either via the `with.version` input or via the\n+    pyproject.toml file if `with.use_pyproject` is set to `true`.\n+    \"\"\"\n+    if USE_PYPROJECT and VERSION:\n+        print(\n+            \"::error::'with.version' and 'with.use_pyproject' inputs are \"\n+            \"mutually exclusive.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+    if USE_PYPROJECT:\n+        return read_version_specifier_from_pyproject()\n+    elif VERSION and VERSION[0] in \"0123456789\":\n+        return f\"=={VERSION}\"\n+    else:\n+        return VERSION\n+\n+\n+def read_version_specifier_from_pyproject() -> str:\n+    if sys.version_info < (3, 11):\n+        print(\n+            \"::error::'with.use_pyproject' input requires Python 3.11 or later.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+\n+    import tomllib  # type: ignore[import-not-found,unreachable]\n+\n+    try:\n+        with Path(\"pyproject.toml\").open(\"rb\") as fp:\n+            pyproject = tomllib.load(fp)\n+    except FileNotFoundError:\n+        print(\n+            \"::error::'with.use_pyproject' input requires a pyproject.toml file.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+\n+    version = pyproject.get(\"tool\", {}).get(\"black\", {}).get(\"required-version\")\n+    if version is not None:\n+        return f\"=={version}\"\n+\n+    arrays = [\n+        pyproject.get(\"project\", {}).get(\"dependencies\"),\n+        *pyproject.get(\"project\", {}).get(\"optional-dependencies\", {}).values(),\n+    ]\n+    for array in arrays:\n+        version = find_black_version_in_array(array)\n+        if version is not None:\n+            break\n+\n+    if version is None:\n+        print(\n+            \"::error::'black' dependency missing from pyproject.toml.\",\n+            file=sys.stderr,\n+            flush=True,\n+        )\n+        sys.exit(1)\n+\n+    return version\n+\n+\n+def find_black_version_in_array(array: object) -> Union[str, None]:\n+    if not isinstance(array, list):\n+        return None\n+    try:\n+        for item in array:\n+            # Rudimentary PEP 508 parsing.\n+            item = item.split(\";\")[0]\n+            item = EXTRAS_RE.sub(\"\", item).strip()\n+            if item == \"black\":\n+                return \"\"",
      "comment": "Maybe showing an error is the right behavior? In this situation, the user set `use_pyproject` to true, meaning they expect us to infer the version from pyproject.toml, but we aren't able to do so.",
      "comment_id": 1551596882,
      "user": "JelleZijlstra",
      "created_at": "2024-04-04T12:36:11Z",
      "url": "https://github.com/psf/black/pull/4294#discussion_r1551596882"
    },
    {
      "repo": "psf/black",
      "pr_number": 3932,
      "file_path": "tests/data/module_docstring_1.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,25 @@\n+\"\"\"Single line module-level docstring should be followed by single newline.\"\"\"",
      "comment": "I don't think we'll run this test as it's not in `simple_cases/`.",
      "comment_id": 1349698647,
      "user": "JelleZijlstra",
      "created_at": "2023-10-08T13:36:59Z",
      "url": "https://github.com/psf/black/pull/3932#discussion_r1349698647"
    },
    {
      "repo": "psf/black",
      "pr_number": 3932,
      "file_path": "tests/data/module_docstring_1.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,25 @@\n+\"\"\"Single line module-level docstring should be followed by single newline.\"\"\"",
      "comment": "Moved the tests to ``preview/`` to make sure they run under preview mode. They executed now with `pytest -k module_docstring`.\r\n\r\nAlso added another two tests cases of which I thought the original PR didn't really have a good test:\r\n1. A file that already has a new line in-between the docstring and the rest of code and\r\n2. A file that has no lines in between the docstring and the rest of code and should thus get one",
      "comment_id": 1349711462,
      "user": "DanielNoord",
      "created_at": "2023-10-08T15:08:27Z",
      "url": "https://github.com/psf/black/pull/3932#discussion_r1349711462"
    },
    {
      "repo": "psf/black",
      "pr_number": 4273,
      "file_path": "tests/test_ranges.py",
      "line": 241,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,3 +183,60 @@ def test_diffs(lines: List[Tuple[int, int]], adjusted: List[Tuple[int, int]]) ->\n 12. # last line changed\n \"\"\"\n     assert adjusted == adjusted_lines(lines, original_source, modified_source)\n+\n+\n+@pytest.mark.parametrize(\n+    \"lines,sanitized\",\n+    [\n+        (\n+            [(1, 4)],\n+            [(1, 4)],\n+        ),\n+        (\n+            [(2, 3)],\n+            [(2, 3)],\n+        ),\n+        (\n+            [(2, 10)],\n+            [(2, 4)],\n+        ),\n+        (\n+            [(0, 3)],\n+            [(1, 3)],\n+        ),\n+        (\n+            [(0, 10)],\n+            [(1, 4)],\n+        ),\n+        (\n+            [(-2, 3)],\n+            [(1, 3)],\n+        ),\n+        (\n+            [(0, 0)],\n+            [],\n+        ),\n+        (\n+            [(-2, -1)],\n+            [],\n+        ),\n+        (\n+            [(-1, 0)],\n+            [],\n+        ),\n+        (\n+            [(3, 1), (1, 3), (5, 6)],\n+            [(1, 3)],\n+        ),\n+    ],\n+)\n+def test_sanitize(\n+    lines: List[Tuple[int, int]], sanitized: List[Tuple[int, int]]\n+) -> None:\n+    source = \"\"\"\\\n+1. import re\n+2. def func(arg1,\n+3.   arg2, arg3):\n+4.   pass\n+\"\"\"",
      "comment": "Can you also add a case for source not ending with a newline?",
      "comment_id": 1525384400,
      "user": "yilei",
      "created_at": "2024-03-14T19:22:33Z",
      "url": "https://github.com/psf/black/pull/4273#discussion_r1525384400"
    },
    {
      "repo": "psf/black",
      "pr_number": 4273,
      "file_path": "tests/data/cases/line_ranges_outside_source.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,41 @@\n+# flags: --line-ranges=5000-6000\n+# NOTE: If you need to modify this file, pay special attention to the --line-ranges=\n+# flag above as it's formatting specifically these lines, in this case none.\n+def foo1(parameter_1, parameter_2, parameter_3, parameter_4, parameter_5, parameter_6, parameter_7): pass\n+def foo2(parameter_1, parameter_2, parameter_3, parameter_4, parameter_5, parameter_6, parameter_7): pass\n+def foo3(parameter_1, parameter_2, parameter_3, parameter_4, parameter_5, parameter_6, parameter_7): pass\n+def foo4(parameter_1, parameter_2, parameter_3, parameter_4, parameter_5, parameter_6, parameter_7): pass\n+\n+# Adding some unformated code covering a wide range of syntaxes.",
      "comment": "I would simply remove the lines below, as this test case just need to verify a completely out-of-range input doesn't format",
      "comment_id": 1525385851,
      "user": "yilei",
      "created_at": "2024-03-14T19:23:31Z",
      "url": "https://github.com/psf/black/pull/4273#discussion_r1525385851"
    },
    {
      "repo": "psf/black",
      "pr_number": 4273,
      "file_path": "src/black/ranges.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,6 +45,32 @@ def is_valid_line_range(lines: Tuple[int, int]) -> bool:\n     return not lines or lines[0] <= lines[1]\n \n \n+def sanitized_lines(\n+    lines: Collection[Tuple[int, int]], src_contents: str\n+) -> Collection[Tuple[int, int]]:\n+    \"\"\"Returns the valid line ranges for the given source.\n+\n+    This removes ranges that are entirely outside the valid lines.\n+\n+    Other ranges are normalized so that the start values are at least 1 and the\n+    end values are at most the (1-based) index of the last source line.\n+    \"\"\"\n+    if not src_contents:\n+        return []\n+    good_lines = []\n+    src_line_count = len(src_contents.splitlines())",
      "comment": "Not too strong an opinion, it can be more efficient to do a `count(\"\\n\")` but then you also need to add `1` when it doesn't end with a new line.",
      "comment_id": 1525389872,
      "user": "yilei",
      "created_at": "2024-03-14T19:26:27Z",
      "url": "https://github.com/psf/black/pull/4273#discussion_r1525389872"
    },
    {
      "repo": "psf/black",
      "pr_number": 4273,
      "file_path": "src/black/ranges.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,6 +45,32 @@ def is_valid_line_range(lines: Tuple[int, int]) -> bool:\n     return not lines or lines[0] <= lines[1]\n \n \n+def sanitized_lines(\n+    lines: Collection[Tuple[int, int]], src_contents: str\n+) -> Collection[Tuple[int, int]]:\n+    \"\"\"Returns the valid line ranges for the given source.\n+\n+    This removes ranges that are entirely outside the valid lines.\n+\n+    Other ranges are normalized so that the start values are at least 1 and the\n+    end values are at most the (1-based) index of the last source line.\n+    \"\"\"\n+    if not src_contents:\n+        return []\n+    good_lines = []\n+    src_line_count = len(src_contents.splitlines())",
      "comment": "Oh, that's really quite a difference\r\n```sh\r\n$ python -m timeit -n 10000 -s \"f = open('src/black/__init__.py'); src=f.read(); f.close()\" \"len(src.splitlines())\"\r\n10000 loops, best of 5: 171 usec per loop\r\n$ python -m timeit -n 10000 -s \"f = open('src/black/__init__.py'); src=f.read(); f.close()\" \"src.count('\\n')\"  \r\n10000 loops, best of 5: 36.6 usec per loop\r\n```\r\nI resisted the temptation to write `src_contents.count(\"\\n\") + src_contents[-1] != \"\\n\"` :smile: ",
      "comment_id": 1525483224,
      "user": "sumezulike",
      "created_at": "2024-03-14T21:00:05Z",
      "url": "https://github.com/psf/black/pull/4273#discussion_r1525483224"
    },
    {
      "repo": "psf/black",
      "pr_number": 4106,
      "file_path": "src/black/mode.py",
      "line": 171,
      "side": "RIGHT",
      "diff_hunk": "@@ -168,35 +168,14 @@ def supports_feature(target_versions: Set[TargetVersion], feature: Feature) -> b\n class Preview(Enum):\n     \"\"\"Individual preview style features.\"\"\"\n \n-    add_trailing_comma_consistently = auto()\n-    blank_line_after_nested_stub_class = auto()\n-    blank_line_between_nested_and_def_stub_file = auto()\n     hex_codes_in_unicode_sequences = auto()",
      "comment": "I believe there's a mistake in the changelog or the flag here is a leftover. The changelog mentions that the hex normalisation shipped, but the preview flag still exists in the code.",
      "comment_id": 1485962615,
      "user": "MichaReiser",
      "created_at": "2024-02-12T10:06:19Z",
      "url": "https://github.com/psf/black/pull/4106#discussion_r1485962615"
    },
    {
      "repo": "psf/black",
      "pr_number": 4106,
      "file_path": "src/black/mode.py",
      "line": 171,
      "side": "RIGHT",
      "diff_hunk": "@@ -168,35 +168,14 @@ def supports_feature(target_versions: Set[TargetVersion], feature: Feature) -> b\n class Preview(Enum):\n     \"\"\"Individual preview style features.\"\"\"\n \n-    add_trailing_comma_consistently = auto()\n-    blank_line_after_nested_stub_class = auto()\n-    blank_line_between_nested_and_def_stub_file = auto()\n     hex_codes_in_unicode_sequences = auto()",
      "comment": "Oops, you're right. I must have confused myself somewhere. I guess this preview feature will have to wait another year.",
      "comment_id": 1486253837,
      "user": "JelleZijlstra",
      "created_at": "2024-02-12T14:23:37Z",
      "url": "https://github.com/psf/black/pull/4106#discussion_r1486253837"
    },
    {
      "repo": "psf/black",
      "pr_number": 4202,
      "file_path": "src/black/linegen.py",
      "line": 1055,
      "side": "RIGHT",
      "diff_hunk": "@@ -1050,22 +1051,9 @@ def bracket_split_build_line(\n                     )\n                     for leaf in leaves\n                 )\n-                # In particular, don't add one within a parenthesized return annotation.\n-                # Unfortunately the indicator we're in a return annotation (RARROW) may\n-                # be defined directly in the parent node, the parent of the parent ...\n-                # and so on depending on how complex the return annotation is.\n-                # This isn't perfect and there's some false negatives but they are in\n-                # contexts were a comma is actually fine.\n-                and not any(\n-                    node.prev_sibling.type == RARROW\n-                    for node in (\n-                        leaves[0].parent,\n-                        getattr(leaves[0].parent, \"parent\", None),\n-                    )\n-                    if isinstance(node, Node) and isinstance(node.prev_sibling, Leaf)\n-                )\n-                # Except the false negatives above for PEP 604 unions where we\n-                # can't add the comma.\n+                # Don't add one inside parenthesized return annotations\n+                and not get_annotation_type(leaves[0]) == \"return\"",
      "comment": "```suggestion\r\n                and get_annotation_type(leaves[0]) != \"return\"\r\n```",
      "comment_id": 1475576405,
      "user": "JelleZijlstra",
      "created_at": "2024-02-02T05:57:12Z",
      "url": "https://github.com/psf/black/pull/4202#discussion_r1475576405"
    },
    {
      "repo": "psf/black",
      "pr_number": 4202,
      "file_path": "src/black/nodes.py",
      "line": 965,
      "side": "RIGHT",
      "diff_hunk": "@@ -951,16 +962,21 @@ def is_number_token(nl: NL) -> TypeGuard[Leaf]:\n     return nl.type == token.NUMBER\n \n \n-def is_part_of_annotation(leaf: Leaf) -> bool:\n-    \"\"\"Returns whether this leaf is part of type annotations.\"\"\"\n+def get_annotation_type(leaf: Leaf) -> Optional[Literal[\"return\", \"param\"]]:",
      "comment": "```suggestion\r\ndef get_annotation_type(leaf: Leaf) -> Literal[\"return\", \"param\", None]:\r\n```",
      "comment_id": 1475576746,
      "user": "JelleZijlstra",
      "created_at": "2024-02-02T05:57:44Z",
      "url": "https://github.com/psf/black/pull/4202#discussion_r1475576746"
    },
    {
      "repo": "psf/black",
      "pr_number": 4222,
      "file_path": "src/black/__init__.py",
      "line": 737,
      "side": "RIGHT",
      "diff_hunk": "@@ -734,6 +734,7 @@ def get_sources(\n     \"\"\"Compute the set of files to be formatted.\"\"\"\n     sources: Set[Path] = set()\n \n+    assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"",
      "comment": "We have a similar assert in `gen_python_files` (which this usually calls)",
      "comment_id": 1485529796,
      "user": "hauntsaninja",
      "created_at": "2024-02-11T08:27:50Z",
      "url": "https://github.com/psf/black/pull/4222#discussion_r1485529796"
    },
    {
      "repo": "psf/black",
      "pr_number": 4222,
      "file_path": "src/black/__init__.py",
      "line": 753,
      "side": "RIGHT",
      "diff_hunk": "@@ -749,11 +750,12 @@ def get_sources(\n \n         # Compare the logic here to the logic in `gen_python_files`.\n         if is_stdin or path.is_file():\n-            root_relative_path = get_root_relative_path(path, root, report)\n-\n-            if root_relative_path is None:\n+            if resolves_outside_root_or_cannot_stat(path, root, report):",
      "comment": "As you may have guessed from the name, the difference between this and `get_root_relative_path` (from #4161) is the `.resolve()`",
      "comment_id": 1485530331,
      "user": "hauntsaninja",
      "created_at": "2024-02-11T08:29:24Z",
      "url": "https://github.com/psf/black/pull/4222#discussion_r1485530331"
    },
    {
      "repo": "psf/black",
      "pr_number": 4222,
      "file_path": "src/black/files.py",
      "line": 294,
      "side": "RIGHT",
      "diff_hunk": "@@ -266,27 +271,31 @@ def resolves_outside_root_or_cannot_stat(\n     try:\n         if sys.version_info < (3, 8, 6):\n             path = path.absolute()  # https://bugs.python.org/issue33660\n-        resolved_path = path.resolve()\n-        return get_root_relative_path(resolved_path, root, report) is None\n+        resolved_path = _cached_resolve(path)\n     except OSError as e:\n         if report:\n             report.path_ignored(path, f\"cannot be read because {e}\")\n         return True\n-\n-\n-def get_root_relative_path(\n-    path: Path,\n-    root: Path,\n-    report: Optional[Report] = None,\n-) -> Optional[str]:\n-    \"\"\"Returns the file path relative to the 'root' directory\"\"\"\n     try:\n-        root_relative_path = path.absolute().relative_to(root).as_posix()\n+        resolved_path.relative_to(root).as_posix()\n     except ValueError:\n         if report:\n             report.path_ignored(path, f\"is a symbolic link that points outside {root}\")\n-        return None\n-    return root_relative_path\n+        return True\n+    return False\n+\n+\n+def best_effort_relative_path(path: Path, root: Path) -> Path:\n+    # Precondition: resolves_outside_root_or_cannot_stat(path, root) is False\n+    try:\n+        return path.absolute().relative_to(root)\n+    except ValueError:\n+        pass\n+    root_parent = next((p for p in path.parents if _cached_resolve(p) == root), None)",
      "comment": "I added `_cached_resolve` mainly in case this loop x many input files is expensive",
      "comment_id": 1485531287,
      "user": "hauntsaninja",
      "created_at": "2024-02-11T08:32:03Z",
      "url": "https://github.com/psf/black/pull/4222#discussion_r1485531287"
    },
    {
      "repo": "psf/black",
      "pr_number": 4222,
      "file_path": "src/black/files.py",
      "line": 351,
      "side": "RIGHT",
      "diff_hunk": "@@ -339,7 +348,8 @@ def gen_python_files(\n \n     assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"\n     for child in paths:\n-        root_relative_path = child.absolute().relative_to(root).as_posix()\n+        assert child.is_absolute()",
      "comment": "Not new, this should be guaranteed by `path = root / (path.resolve().relative_to(root))` in `get_sources`",
      "comment_id": 1485531462,
      "user": "hauntsaninja",
      "created_at": "2024-02-11T08:32:32Z",
      "url": "https://github.com/psf/black/pull/4222#discussion_r1485531462"
    },
    {
      "repo": "psf/black",
      "pr_number": 4222,
      "file_path": "tests/test_black.py",
      "line": 2700,
      "side": "RIGHT",
      "diff_hunk": "@@ -2626,39 +2626,100 @@ def test_symlinks(self) -> None:\n         outside_root_symlink.resolve.assert_called_once()\n         ignored_symlink.resolve.assert_not_called()\n \n+    def test_get_sources_symlink_and_force_exclude(self) -> None:\n+        with TemporaryDirectory() as tempdir:\n+            tmp = Path(tempdir).resolve()\n+            actual = tmp / \"actual\"\n+            actual.mkdir()\n+            symlink = tmp / \"symlink\"\n+            symlink.symlink_to(actual)\n+\n+            actual_proj = actual / \"project\"\n+            actual_proj.mkdir()\n+            (actual_proj / \"module.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n+\n+            symlink_proj = symlink / \"project\"\n+\n+            with change_directory(symlink_proj):\n+                assert_collected_sources(\n+                    src=[\"module.py\"],\n+                    root=symlink_proj.resolve(),\n+                    expected=[\"module.py\"],\n+                )\n+\n+                absolute_module = symlink_proj / \"module.py\"\n+                assert_collected_sources(\n+                    src=[absolute_module],\n+                    root=symlink_proj.resolve(),\n+                    expected=[absolute_module],\n+                )\n+\n+                # a few tricky tests for force_exclude\n+                flat_symlink = symlink_proj / \"symlink_module.py\"\n+                flat_symlink.symlink_to(actual_proj / \"module.py\")\n+                assert_collected_sources(\n+                    src=[flat_symlink],\n+                    root=symlink_proj.resolve(),\n+                    force_exclude=r\"/symlink_module.py\",\n+                    expected=[],\n+                )\n+\n+                target = actual_proj / \"target\"\n+                target.mkdir()\n+                (target / \"another.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n+                (symlink_proj / \"nested\").symlink_to(target)\n+\n+                assert_collected_sources(\n+                    src=[symlink_proj / \"nested\" / \"another.py\"],\n+                    root=symlink_proj.resolve(),\n+                    force_exclude=r\"nested\",\n+                    expected=[],\n+                )\n+                assert_collected_sources(\n+                    src=[symlink_proj / \"nested\" / \"another.py\"],\n+                    root=symlink_proj.resolve(),\n+                    force_exclude=r\"target\",\n+                    expected=[symlink_proj / \"nested\" / \"another.py\"],\n+                )\n+\n     def test_get_sources_with_stdin_symlink_outside_root(\n         self,\n     ) -> None:\n         path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n         stdin_filename = str(path / \"b/exclude/a.py\")\n         outside_root_symlink = Path(\"/target_directory/a.py\")\n+        root = Path(\"target_dir/\").resolve().absolute()\n         with patch(\"pathlib.Path.resolve\", return_value=outside_root_symlink):\n             assert_collected_sources(\n-                root=Path(\"target_directory/\"),\n+                root=root,\n                 src=[\"-\"],\n                 expected=[],\n                 stdin_filename=stdin_filename,\n             )\n \n-    @patch(\"black.find_project_root\", lambda *args: (THIS_DIR.resolve(), None))\n     def test_get_sources_with_stdin(self) -> None:",
      "comment": "Not really related, but while I was here I removed some monkeypatching since it's not needed. We probably do a little too much mocking, so the new tests touch the file system",
      "comment_id": 1485540342,
      "user": "hauntsaninja",
      "created_at": "2024-02-11T08:58:34Z",
      "url": "https://github.com/psf/black/pull/4222#discussion_r1485540342"
    },
    {
      "repo": "psf/black",
      "pr_number": 4222,
      "file_path": "src/black/__init__.py",
      "line": 753,
      "side": "RIGHT",
      "diff_hunk": "@@ -749,11 +750,12 @@ def get_sources(\n \n         # Compare the logic here to the logic in `gen_python_files`.\n         if is_stdin or path.is_file():\n-            root_relative_path = get_root_relative_path(path, root, report)\n-\n-            if root_relative_path is None:\n+            if resolves_outside_root_or_cannot_stat(path, root, report):",
      "comment": "This helped me located where the filtering happens and I just added `sources.add(path)` before the old \"continue\"in line 755/756 and my problem was solved.\r\nTho this, if you need, I can still test it against my case where my home folder `~` was set to a symlink like `/homes/user` -> `/external/homes/user`. Please don't hesitate to tell me if you need any help! Thanks for the great work again!",
      "comment_id": 1485559255,
      "user": "PabloLION",
      "created_at": "2024-02-11T09:52:50Z",
      "url": "https://github.com/psf/black/pull/4222#discussion_r1485559255"
    },
    {
      "repo": "psf/black",
      "pr_number": 4222,
      "file_path": "tests/test_black.py",
      "line": 2691,
      "side": "RIGHT",
      "diff_hunk": "@@ -2626,39 +2626,100 @@ def test_symlinks(self) -> None:\n         outside_root_symlink.resolve.assert_called_once()\n         ignored_symlink.resolve.assert_not_called()\n \n+    def test_get_sources_symlink_and_force_exclude(self) -> None:\n+        with TemporaryDirectory() as tempdir:\n+            tmp = Path(tempdir).resolve()\n+            actual = tmp / \"actual\"\n+            actual.mkdir()\n+            symlink = tmp / \"symlink\"\n+            symlink.symlink_to(actual)\n+\n+            actual_proj = actual / \"project\"\n+            actual_proj.mkdir()\n+            (actual_proj / \"module.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n+\n+            symlink_proj = symlink / \"project\"\n+\n+            with change_directory(symlink_proj):\n+                assert_collected_sources(\n+                    src=[\"module.py\"],\n+                    root=symlink_proj.resolve(),\n+                    expected=[\"module.py\"],\n+                )\n+\n+                absolute_module = symlink_proj / \"module.py\"\n+                assert_collected_sources(\n+                    src=[absolute_module],\n+                    root=symlink_proj.resolve(),\n+                    expected=[absolute_module],\n+                )\n+\n+                # a few tricky tests for force_exclude\n+                flat_symlink = symlink_proj / \"symlink_module.py\"\n+                flat_symlink.symlink_to(actual_proj / \"module.py\")\n+                assert_collected_sources(\n+                    src=[flat_symlink],\n+                    root=symlink_proj.resolve(),\n+                    force_exclude=r\"/symlink_module.py\",\n+                    expected=[],\n+                )\n+\n+                target = actual_proj / \"target\"\n+                target.mkdir()\n+                (target / \"another.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n+                (symlink_proj / \"nested\").symlink_to(target)\n+\n+                assert_collected_sources(\n+                    src=[symlink_proj / \"nested\" / \"another.py\"],\n+                    root=symlink_proj.resolve(),\n+                    force_exclude=r\"nested\",\n+                    expected=[],\n+                )\n+                assert_collected_sources(\n+                    src=[symlink_proj / \"nested\" / \"another.py\"],\n+                    root=symlink_proj.resolve(),\n+                    force_exclude=r\"target\",\n+                    expected=[symlink_proj / \"nested\" / \"another.py\"],\n+                )\n+\n     def test_get_sources_with_stdin_symlink_outside_root(\n         self,\n     ) -> None:\n         path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n         stdin_filename = str(path / \"b/exclude/a.py\")\n         outside_root_symlink = Path(\"/target_directory/a.py\")\n+        root = Path(\"target_dir/\").resolve().absolute()",
      "comment": "`target_dir` is right. Rename doesn't affect semantics, I did it to make the test clearer, the relevant difference is `/target_directory` is absolute and so is outside root",
      "comment_id": 1485666469,
      "user": "hauntsaninja",
      "created_at": "2024-02-11T21:18:35Z",
      "url": "https://github.com/psf/black/pull/4222#discussion_r1485666469"
    },
    {
      "repo": "psf/black",
      "pr_number": 4222,
      "file_path": "tests/test_black.py",
      "line": 2691,
      "side": "RIGHT",
      "diff_hunk": "@@ -2626,39 +2626,100 @@ def test_symlinks(self) -> None:\n         outside_root_symlink.resolve.assert_called_once()\n         ignored_symlink.resolve.assert_not_called()\n \n+    def test_get_sources_symlink_and_force_exclude(self) -> None:\n+        with TemporaryDirectory() as tempdir:\n+            tmp = Path(tempdir).resolve()\n+            actual = tmp / \"actual\"\n+            actual.mkdir()\n+            symlink = tmp / \"symlink\"\n+            symlink.symlink_to(actual)\n+\n+            actual_proj = actual / \"project\"\n+            actual_proj.mkdir()\n+            (actual_proj / \"module.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n+\n+            symlink_proj = symlink / \"project\"\n+\n+            with change_directory(symlink_proj):\n+                assert_collected_sources(\n+                    src=[\"module.py\"],\n+                    root=symlink_proj.resolve(),\n+                    expected=[\"module.py\"],\n+                )\n+\n+                absolute_module = symlink_proj / \"module.py\"\n+                assert_collected_sources(\n+                    src=[absolute_module],\n+                    root=symlink_proj.resolve(),\n+                    expected=[absolute_module],\n+                )\n+\n+                # a few tricky tests for force_exclude\n+                flat_symlink = symlink_proj / \"symlink_module.py\"\n+                flat_symlink.symlink_to(actual_proj / \"module.py\")\n+                assert_collected_sources(\n+                    src=[flat_symlink],\n+                    root=symlink_proj.resolve(),\n+                    force_exclude=r\"/symlink_module.py\",\n+                    expected=[],\n+                )\n+\n+                target = actual_proj / \"target\"\n+                target.mkdir()\n+                (target / \"another.py\").write_text(\"print('hello')\", encoding=\"utf-8\")\n+                (symlink_proj / \"nested\").symlink_to(target)\n+\n+                assert_collected_sources(\n+                    src=[symlink_proj / \"nested\" / \"another.py\"],\n+                    root=symlink_proj.resolve(),\n+                    force_exclude=r\"nested\",\n+                    expected=[],\n+                )\n+                assert_collected_sources(\n+                    src=[symlink_proj / \"nested\" / \"another.py\"],\n+                    root=symlink_proj.resolve(),\n+                    force_exclude=r\"target\",\n+                    expected=[symlink_proj / \"nested\" / \"another.py\"],\n+                )\n+\n     def test_get_sources_with_stdin_symlink_outside_root(\n         self,\n     ) -> None:\n         path = THIS_DIR / \"data\" / \"include_exclude_tests\"\n         stdin_filename = str(path / \"b/exclude/a.py\")\n         outside_root_symlink = Path(\"/target_directory/a.py\")\n+        root = Path(\"target_dir/\").resolve().absolute()",
      "comment": "I see, it would have been slightly clearer if you used two names that didn't look like one was a variant of the other, e.g. `target_dir1` and `target_dir2`. What you have now is fine too though.",
      "comment_id": 1485673062,
      "user": "JelleZijlstra",
      "created_at": "2024-02-11T22:01:00Z",
      "url": "https://github.com/psf/black/pull/4222#discussion_r1485673062"
    },
    {
      "repo": "psf/black",
      "pr_number": 4222,
      "file_path": "src/black/files.py",
      "line": 280,
      "side": "RIGHT",
      "diff_hunk": "@@ -266,27 +271,31 @@ def resolves_outside_root_or_cannot_stat(\n     try:\n         if sys.version_info < (3, 8, 6):\n             path = path.absolute()  # https://bugs.python.org/issue33660\n-        resolved_path = path.resolve()\n-        return get_root_relative_path(resolved_path, root, report) is None\n+        resolved_path = _cached_resolve(path)\n     except OSError as e:\n         if report:\n             report.path_ignored(path, f\"cannot be read because {e}\")\n         return True\n-\n-\n-def get_root_relative_path(\n-    path: Path,\n-    root: Path,\n-    report: Optional[Report] = None,\n-) -> Optional[str]:\n-    \"\"\"Returns the file path relative to the 'root' directory\"\"\"\n     try:\n-        root_relative_path = path.absolute().relative_to(root).as_posix()\n+        resolved_path.relative_to(root).as_posix()",
      "comment": "```suggestion\r\n        resolved_path.relative_to(root)\r\n```\r\nDoesn't look like `.as_posix()` should ever throw.",
      "comment_id": 1485673487,
      "user": "JelleZijlstra",
      "created_at": "2024-02-11T22:03:40Z",
      "url": "https://github.com/psf/black/pull/4222#discussion_r1485673487"
    },
    {
      "repo": "psf/black",
      "pr_number": 4221,
      "file_path": "src/black/__init__.py",
      "line": 783,
      "side": "LEFT",
      "diff_hunk": "@@ -780,7 +777,7 @@ def get_sources(\n                 continue\n \n             if verbose:\n-                out(f'Found input source: \"{normalized_path}\"', fg=\"blue\")",
      "comment": "We don't use the value of normalized_path, we do `sources.add(path)`, so no point logging it",
      "comment_id": 1485420085,
      "user": "hauntsaninja",
      "created_at": "2024-02-11T02:03:38Z",
      "url": "https://github.com/psf/black/pull/4221#discussion_r1485420085"
    },
    {
      "repo": "psf/black",
      "pr_number": 4221,
      "file_path": "tests/test_black.py",
      "line": 1771,
      "side": "RIGHT",
      "diff_hunk": "@@ -1760,12 +1760,15 @@ def test_bpo_33660_workaround(self) -> None:\n             return\n \n         # https://bugs.python.org/issue33660\n+        # Can be removed when we drop support for Python 3.8.5\n         root = Path(\"/\")\n         with change_directory(root):\n             path = Path(\"workspace\") / \"project\"\n             report = black.Report(verbose=True)\n-            normalized_path = black.normalize_path_maybe_ignore(path, root, report)\n-            self.assertEqual(normalized_path, \"workspace/project\")\n+            resolves_outside = black.resolves_outside_root_or_cannot_stat(\n+                path, root, report\n+            )\n+            self.assertEqual(resolves_outside, False)",
      "comment": "```suggestion\r\n            self.assertIs(resolves_outside, False)\r\n```",
      "comment_id": 1485459139,
      "user": "JelleZijlstra",
      "created_at": "2024-02-11T04:11:20Z",
      "url": "https://github.com/psf/black/pull/4221#discussion_r1485459139"
    },
    {
      "repo": "psf/black",
      "pr_number": 4181,
      "file_path": "scripts/generate_schema.py",
      "line": 68,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,72 @@\n+import json\n+from typing import IO, Any\n+\n+import click\n+\n+import black\n+\n+\n+def generate_schema_from_click(\n+    cmd: click.Command,\n+) -> dict[str, Any]:\n+    result: dict[str, dict[str, Any]] = {}\n+    for param in cmd.params:\n+        if not isinstance(param, click.Option) or param.is_eager:\n+            continue\n+\n+        assert param.name\n+        name = param.name.replace(\"_\", \"-\")\n+\n+        result[name] = {}\n+\n+        match param.type:\n+            case click.types.IntParamType():\n+                result[name][\"type\"] = \"integer\"\n+            case click.types.StringParamType() | click.types.Path():\n+                result[name][\"type\"] = \"string\"\n+            case click.types.Choice(choices=choices):\n+                result[name][\"enum\"] = choices\n+            case click.types.BoolParamType():\n+                result[name][\"type\"] = \"boolean\"\n+            case _:\n+                msg = f\"{param.type!r} not a known type for {param}\"\n+                raise TypeError(msg)\n+\n+        if param.multiple:\n+            result[name] = {\"type\": \"array\", \"items\": result[name]}\n+\n+        result[name][\"description\"] = param.help\n+\n+        if param.default is not None and not param.multiple:\n+            result[name][\"default\"] = param.default\n+\n+    return result\n+\n+\n+@click.command(context_settings={\"help_option_names\": [\"-h\", \"--help\"]})\n+@click.option(\"--schemastore\", is_flag=True, help=\"SchemaStore format\")\n+@click.option(\"--outfile\", type=click.File(mode=\"w\"), help=\"Write to file\")\n+def main(schemastore: bool, outfile: IO[str]) -> None:\n+    properties = generate_schema_from_click(black.main)\n+    del properties[\"line-ranges\"]\n+\n+    schema: dict[str, Any] = {\n+        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n+        \"$id\": (\n+            \"https://github.com/psf/black/blob/main/black/resources/black.schema.json\"\n+        ),\n+        \"$comment\": \"black table in pyproject.toml\",\n+        \"type\": \"object\",\n+        \"additionalProperties\": False,\n+        \"properties\": properties,\n+    }\n+\n+    if schemastore:\n+        schema[\"$id\"] = (\"https://json.schemastore.org/partial-black.json\",)\n+        schema[\"properties\"][\"enable-unstable-feature\"][\"items\"] = {\"type\": \"string\"}",
      "comment": "```suggestion\r\n        # The precise list of unstable features may change frequently, so don't bother putting it in SchemaStore\r\n        schema[\"properties\"][\"enable-unstable-feature\"][\"items\"] = {\"type\": \"string\"}\r\n```",
      "comment_id": 1468511652,
      "user": "JelleZijlstra",
      "created_at": "2024-01-27T15:51:10Z",
      "url": "https://github.com/psf/black/pull/4181#discussion_r1468511652"
    },
    {
      "repo": "psf/black",
      "pr_number": 4181,
      "file_path": "scripts/generate_schema.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,72 @@\n+import json\n+from typing import IO, Any\n+\n+import click\n+\n+import black\n+\n+\n+def generate_schema_from_click(\n+    cmd: click.Command,\n+) -> dict[str, Any]:\n+    result: dict[str, dict[str, Any]] = {}\n+    for param in cmd.params:\n+        if not isinstance(param, click.Option) or param.is_eager:\n+            continue\n+\n+        assert param.name\n+        name = param.name.replace(\"_\", \"-\")\n+\n+        result[name] = {}\n+\n+        match param.type:\n+            case click.types.IntParamType():\n+                result[name][\"type\"] = \"integer\"\n+            case click.types.StringParamType() | click.types.Path():\n+                result[name][\"type\"] = \"string\"\n+            case click.types.Choice(choices=choices):\n+                result[name][\"enum\"] = choices\n+            case click.types.BoolParamType():\n+                result[name][\"type\"] = \"boolean\"\n+            case _:\n+                msg = f\"{param.type!r} not a known type for {param}\"\n+                raise TypeError(msg)\n+\n+        if param.multiple:\n+            result[name] = {\"type\": \"array\", \"items\": result[name]}\n+\n+        result[name][\"description\"] = param.help\n+\n+        if param.default is not None and not param.multiple:\n+            result[name][\"default\"] = param.default\n+\n+    return result\n+\n+\n+@click.command(context_settings={\"help_option_names\": [\"-h\", \"--help\"]})\n+@click.option(\"--schemastore\", is_flag=True, help=\"SchemaStore format\")\n+@click.option(\"--outfile\", type=click.File(mode=\"w\"), help=\"Write to file\")\n+def main(schemastore: bool, outfile: IO[str]) -> None:\n+    properties = generate_schema_from_click(black.main)\n+    del properties[\"line-ranges\"]\n+\n+    schema: dict[str, Any] = {\n+        \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n+        \"$id\": (\n+            \"https://github.com/psf/black/blob/main/black/resources/black.schema.json\"\n+        ),\n+        \"$comment\": \"black table in pyproject.toml\",",
      "comment": "```suggestion\r\n        \"$comment\": \"tool.black table in pyproject.toml\",\r\n```",
      "comment_id": 1468512349,
      "user": "JelleZijlstra",
      "created_at": "2024-01-27T15:51:36Z",
      "url": "https://github.com/psf/black/pull/4181#discussion_r1468512349"
    },
    {
      "repo": "psf/black",
      "pr_number": 4181,
      "file_path": "src/black/schema.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+import importlib.resources\n+import json\n+import sys\n+from typing import Any\n+\n+\n+def get_schema(tool_name: str = \"cibuildwheel\") -> Any:\n+    \"Get the stored complete schema for black's settings.\"",
      "comment": "```suggestion\r\n    \"\"\"Get the stored complete schema for black's settings.\"\"\"\r\n```",
      "comment_id": 1468513233,
      "user": "JelleZijlstra",
      "created_at": "2024-01-27T15:54:42Z",
      "url": "https://github.com/psf/black/pull/4181#discussion_r1468513233"
    },
    {
      "repo": "psf/black",
      "pr_number": 4181,
      "file_path": "src/black/schema.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+import importlib.resources\n+import json\n+import sys\n+from typing import Any\n+\n+\n+def get_schema(tool_name: str = \"cibuildwheel\") -> Any:",
      "comment": "```suggestion\r\ndef get_schema(tool_name: str = \"black\") -> Any:\r\n```",
      "comment_id": 1468516056,
      "user": "henryiii",
      "created_at": "2024-01-27T16:10:20Z",
      "url": "https://github.com/psf/black/pull/4181#discussion_r1468516056"
    },
    {
      "repo": "psf/black",
      "pr_number": 4181,
      "file_path": "src/black/schema.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+import importlib.resources\n+import json\n+import sys\n+from typing import Any\n+\n+\n+def get_schema(tool_name: str = \"cibuildwheel\") -> Any:\n+    \"Get the stored complete schema for black's settings.\"\n+    assert tool_name == \"black\", \"Only black is supported.\"",
      "comment": "There\u2019s a small, tiny chance I might have started from the file I wrote for cibuildwheel\u2026",
      "comment_id": 1468516184,
      "user": "henryiii",
      "created_at": "2024-01-27T16:11:02Z",
      "url": "https://github.com/psf/black/pull/4181#discussion_r1468516184"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "tests/data/cases/power_op_spacing.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,3 +1,8 @@\n+m2 = None if not isinstance(dist, Normal) else \u03bc** 2 + \u03c3 * 2\n+m3 = None if not isinstance(dist, Normal) else \u03bc**2 + \u03c3 * 2\n+m4 = None if not isinstance(dist, Normal) else s**2 + \u03c3 * 2",
      "comment": "```suggestion\r\nm2 = None if not isinstance(dist, Normal) else m** 2 + s * 2\r\nm3 = None if not isinstance(dist, Normal) else m**2 + s * 2\r\nm4 = None if not isinstance(dist, Normal) else s**2 + s * 2\r\n```\r\nReplace the Greek letters with Latin ones. If there is something unusual going on in a test, then readers will naturally think the test is about that unusual thing. In this case the Greek doesn't matter, so use less unusual characters.",
      "comment_id": 1468510210,
      "user": "JelleZijlstra",
      "created_at": "2024-01-27T15:42:22Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1468510210"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "tests/data/cases/power_op_spacing.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +83,11 @@ def function_dont_replace_spaces():\n \n \n # output\n+m2 = None if not isinstance(dist, Normal) else \u03bc**2 + \u03c3 * 2\n+m3 = None if not isinstance(dist, Normal) else \u03bc**2 + \u03c3 * 2\n+m4 = None if not isinstance(dist, Normal) else s**2 + \u03c3 * 2\n+m5 = obj.method(another_obj.method()).attribute ** 2\n+m6 = None if ... else \u03bc**2 + \u03c3**2",
      "comment": "```suggestion\r\nm2 = None if not isinstance(dist, Normal) else m**2 + s * 2\r\nm3 = None if not isinstance(dist, Normal) else m**2 + s * 2\r\nm4 = None if not isinstance(dist, Normal) else s**2 + s * 2\r\nm5 = obj.method(another_obj.method()).attribute ** 2\r\nm6 = None if ... else m**2 + s**2\r\n```",
      "comment_id": 1468510364,
      "user": "JelleZijlstra",
      "created_at": "2024-01-27T15:42:52Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1468510364"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "tests/data/cases/power_op_spacing.py",
      "line": 5,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,3 +1,8 @@\n+m2 = None if not isinstance(dist, Normal) else \u03bc** 2 + \u03c3 * 2\n+m3 = None if not isinstance(dist, Normal) else \u03bc**2 + \u03c3 * 2\n+m4 = None if not isinstance(dist, Normal) else s**2 + \u03c3 * 2\n+m5 = obj.method(another_obj.method()).attribute **2\n+m6 = None if ... else \u03bc**2 + \u03c3**2",
      "comment": "```suggestion\r\nm6 = None if ... else m**2 + s**2\r\n```",
      "comment_id": 1468510550,
      "user": "JelleZijlstra",
      "created_at": "2024-01-27T15:43:37Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1468510550"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "src/black/trans.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -94,43 +94,30 @@ def hug_power_op(\n     else:\n         raise CannotTransform(\"No doublestar token was found in the line.\")\n \n-    def is_simple_lookup(index: int, step: Literal[1, -1]) -> bool:\n+    def is_simple_lookup(index: int, kind: Literal[1, -1]) -> bool:\n         # Brackets and parentheses indicate calls, subscripts, etc. ...\n         # basically stuff that doesn't count as \"simple\". Only a NAME lookup\n         # or dotted lookup (eg. NAME.NAME) is OK.\n-        if step == -1:\n-            disallowed = {token.RPAR, token.RSQB}\n+        if kind == -1:\n+            return handle_is_simple_look_up_prev(line, index, {token.RPAR, token.RSQB})\n         else:\n-            disallowed = {token.LPAR, token.LSQB}\n-\n-        while 0 <= index < len(line.leaves):\n-            current = line.leaves[index]\n-            if current.type in disallowed:\n-                return False\n-            if current.type not in {token.NAME, token.DOT} or current.value == \"for\":\n-                # If the current token isn't disallowed, we'll assume this is simple as\n-                # only the disallowed tokens are semantically attached to this lookup\n-                # expression we're checking. Also, stop early if we hit the 'for' bit\n-                # of a comprehension.\n-                return True\n-\n-            index += step\n-\n-        return True\n+            return handle_is_simple_lookup_forward(\n+                line, index, {token.LPAR, token.LSQB}\n+            )\n \n-    def is_simple_operand(index: int, kind: Literal[\"base\", \"exponent\"]) -> bool:\n+    def is_simple_operand(index: int, kind: Literal[1, -1]) -> bool:\n         # An operand is considered \"simple\" if's a NAME, a numeric CONSTANT, a simple\n         # lookup (see above), with or without a preceding unary operator.\n         start = line.leaves[index]\n         if start.type in {token.NAME, token.NUMBER}:\n-            return is_simple_lookup(index, step=(1 if kind == \"exponent\" else -1))\n+            return is_simple_lookup(index, kind)\n \n         if start.type in {token.PLUS, token.MINUS, token.TILDE}:\n             if line.leaves[index + 1].type in {token.NAME, token.NUMBER}:\n                 # step is always one as bases with a preceding unary op will be checked",
      "comment": "```suggestion\r\n                # kind is always one as bases with a preceding unary op will be checked\r\n```",
      "comment_id": 1468510681,
      "user": "JelleZijlstra",
      "created_at": "2024-01-27T15:44:21Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1468510681"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "src/black/trans.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,6 +149,73 @@ def is_simple_operand(index: int, kind: Literal[\"base\", \"exponent\"]) -> bool:\n     yield new_line\n \n \n+def handle_is_simple_look_up_prev(line: Line, index: int, disallowed: Set[int]) -> bool:\n+    \"\"\"\n+    Handling the determination of is_simple_lookup for the lines prior to\n+    the doublestar token. This is required because of the need to isolate the chained\n+    expression to determine the bracket or parenthesis belong to the single expression.\n+    \"\"\"\n+    contains_disallowed = False\n+    chain = []\n+\n+    while 0 <= index < len(line.leaves):\n+        current = line.leaves[index]\n+        chain.append(current)\n+        if not contains_disallowed and current.type in disallowed:\n+            contains_disallowed = True\n+        if not is_expression_chained(chain):\n+            return not contains_disallowed\n+\n+        index += -1\n+\n+    return True\n+\n+\n+def handle_is_simple_lookup_forward(\n+    line: Line, index: int, disallowed: Set[int]\n+) -> bool:\n+    \"\"\"\n+    Handling decision is_simple_lookup for the lines prior to the doublestar token.",
      "comment": "This docstring looks wrong, shouldn't it say behind the doublestar?",
      "comment_id": 1468511075,
      "user": "JelleZijlstra",
      "created_at": "2024-01-27T15:47:10Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1468511075"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "src/black/trans.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,6 +149,73 @@ def is_simple_operand(index: int, kind: Literal[\"base\", \"exponent\"]) -> bool:\n     yield new_line\n \n \n+def handle_is_simple_look_up_prev(line: Line, index: int, disallowed: Set[int]) -> bool:\n+    \"\"\"\n+    Handling the determination of is_simple_lookup for the lines prior to\n+    the doublestar token. This is required because of the need to isolate the chained\n+    expression to determine the bracket or parenthesis belong to the single expression.\n+    \"\"\"\n+    contains_disallowed = False\n+    chain = []\n+\n+    while 0 <= index < len(line.leaves):\n+        current = line.leaves[index]\n+        chain.append(current)\n+        if not contains_disallowed and current.type in disallowed:\n+            contains_disallowed = True\n+        if not is_expression_chained(chain):\n+            return not contains_disallowed\n+\n+        index += -1\n+\n+    return True\n+\n+\n+def handle_is_simple_lookup_forward(\n+    line: Line, index: int, disallowed: Set[int]\n+) -> bool:\n+    \"\"\"\n+    Handling decision is_simple_lookup for the lines prior to the doublestar token.\n+    This function is simplified to keep consistent with the prior logic and the forward\n+    case are more straightforward and do not need to care about chained expressions.\n+    \"\"\"\n+    while 0 <= index < len(line.leaves):\n+        current = line.leaves[index]\n+        if current.type in disallowed:\n+            return False\n+        if current.type not in {token.NAME, token.DOT} or current.value == \"for\":",
      "comment": "Check that the leaf is of the right type before checking its value.",
      "comment_id": 1468511217,
      "user": "JelleZijlstra",
      "created_at": "2024-01-27T15:47:58Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1468511217"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "src/black/trans.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,6 +149,73 @@ def is_simple_operand(index: int, kind: Literal[\"base\", \"exponent\"]) -> bool:\n     yield new_line\n \n \n+def handle_is_simple_look_up_prev(line: Line, index: int, disallowed: Set[int]) -> bool:\n+    \"\"\"\n+    Handling the determination of is_simple_lookup for the lines prior to\n+    the doublestar token. This is required because of the need to isolate the chained\n+    expression to determine the bracket or parenthesis belong to the single expression.\n+    \"\"\"\n+    contains_disallowed = False\n+    chain = []\n+\n+    while 0 <= index < len(line.leaves):\n+        current = line.leaves[index]\n+        chain.append(current)\n+        if not contains_disallowed and current.type in disallowed:\n+            contains_disallowed = True\n+        if not is_expression_chained(chain):\n+            return not contains_disallowed\n+\n+        index += -1\n+\n+    return True\n+\n+\n+def handle_is_simple_lookup_forward(\n+    line: Line, index: int, disallowed: Set[int]\n+) -> bool:\n+    \"\"\"\n+    Handling decision is_simple_lookup for the lines prior to the doublestar token.\n+    This function is simplified to keep consistent with the prior logic and the forward\n+    case are more straightforward and do not need to care about chained expressions.\n+    \"\"\"\n+    while 0 <= index < len(line.leaves):\n+        current = line.leaves[index]\n+        if current.type in disallowed:\n+            return False\n+        if current.type not in {token.NAME, token.DOT} or current.value == \"for\":",
      "comment": "I wanted to reserve the logic for checking the front of the operation the previous implemented. But I can go ahead and ensure it will be a `token.NAME` before checking the value.",
      "comment_id": 1468772697,
      "user": "wannieman98",
      "created_at": "2024-01-28T07:13:20Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1468772697"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "src/black/trans.py",
      "line": 208,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,6 +155,99 @@ def is_simple_operand(index: int, kind: Literal[\"base\", \"exponent\"]) -> bool:\n     yield new_line\n \n \n+def original_is_simple_lookup_func(\n+    line: Line, index: int, step: Literal[1, -1]\n+) -> bool:\n+    if step == -1:\n+        disallowed = {token.RPAR, token.RSQB}\n+    else:\n+        disallowed = {token.LPAR, token.LSQB}\n+\n+    while 0 <= index < len(line.leaves):\n+        current = line.leaves[index]\n+        if current.type in disallowed:\n+            return False\n+        if current.type not in {token.NAME, token.DOT} or current.value == \"for\":\n+            # If the current token isn't disallowed, we'll assume this is\n+            # simple as only the disallowed tokens are semantically\n+            # attached to this lookup expression we're checking. Also,\n+            # stop early if we hit the 'for' bit of a comprehension.\n+            return True\n+\n+        index += step\n+\n+    return True\n+\n+\n+def handle_is_simple_look_up_prev(line: Line, index: int, disallowed: Set[int]) -> bool:\n+    \"\"\"\n+    Handling the determination of is_simple_lookup for the lines prior to the doublestar\n+    token. This is required because of the need to isolate the chained expression\n+    to determine the bracket or parenthesis belong to the single expression.\n+    \"\"\"\n+    contains_disallowed = False\n+    chain = []\n+\n+    while 0 <= index < len(line.leaves):\n+        current = line.leaves[index]\n+        chain.append(current)\n+        if not contains_disallowed and current.type in disallowed:\n+            contains_disallowed = True\n+        if not is_expression_chained(chain):\n+            return not contains_disallowed\n+\n+        index -= 1\n+\n+    return True\n+\n+\n+def handle_is_simple_lookup_forward(\n+    line: Line, index: int, disallowed: Set[int]\n+) -> bool:\n+    \"\"\"\n+    Handling decision is_simple_lookup for the lines behind to the doublestar token.",
      "comment": "```suggestion\r\n    Handling decision is_simple_lookup for the lines behind the doublestar token.\r\n```",
      "comment_id": 1472244424,
      "user": "JelleZijlstra",
      "created_at": "2024-01-31T02:51:07Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1472244424"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "src/black/mode.py",
      "line": 180,
      "side": "RIGHT",
      "diff_hunk": "@@ -177,6 +177,7 @@ class Preview(Enum):\n     wrap_long_dict_values_in_parens = auto()\n     multiline_string_handling = auto()\n     typed_params_trailing_comma = auto()\n+    is_simple_lookup_for_doublestar_expression = auto()",
      "comment": "Could you add this feature to the documentation in `future-style.md`, where we now list all preview features? The description can just be something like \"fix line length computation for certain expressions that involve the power operator\".",
      "comment_id": 1472245306,
      "user": "JelleZijlstra",
      "created_at": "2024-01-31T02:52:48Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1472245306"
    },
    {
      "repo": "psf/black",
      "pr_number": 4154,
      "file_path": "tests/data/cases/is_simple_lookup_for_doublestar_expression.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,14 @@\n+# flags: --preview\n+m2 = None if not isinstance(dist, Normal) else m** 2 + s * 2\n+m3 = None if not isinstance(dist, Normal) else m**2 + s * 2\n+m4 = None if not isinstance(dist, Normal) else s**2 + s * 2",
      "comment": "You are right, they are testing the same thing I'll remove the duplicate test.",
      "comment_id": 1477632836,
      "user": "wannieman98",
      "created_at": "2024-02-05T03:32:21Z",
      "url": "https://github.com/psf/black/pull/4154#discussion_r1477632836"
    },
    {
      "repo": "psf/black",
      "pr_number": 4185,
      "file_path": "src/black/linegen.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -477,13 +477,15 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n                 last_line_length = len(lines[-1]) if docstring else 0\n \n                 # If adding closing quotes would cause the last line to exceed\n-                # the maximum line length then put a line break before the\n-                # closing quotes\n+                # the maximum line length, and the closing quote is not\n+                # prefixed by a newline then put a line break before\n+                # the closing quotes\n                 if (\n                     len(lines) > 1\n                     and last_line_length + quote_len > self.mode.line_length\n                     and len(indent) + quote_len <= self.mode.line_length\n                     and not has_trailing_backslash\n+                    and not leaf.value[-4] == \"\\n\"",
      "comment": "This will need to be gated to the preview style (see #4164 for a recent example).",
      "comment_id": 1468742573,
      "user": "JelleZijlstra",
      "created_at": "2024-01-28T04:27:05Z",
      "url": "https://github.com/psf/black/pull/4185#discussion_r1468742573"
    },
    {
      "repo": "psf/black",
      "pr_number": 4185,
      "file_path": "src/black/mode.py",
      "line": 180,
      "side": "RIGHT",
      "diff_hunk": "@@ -177,6 +177,7 @@ class Preview(Enum):\n     wrap_long_dict_values_in_parens = auto()\n     multiline_string_handling = auto()\n     typed_params_trailing_comma = auto()\n+    docstring_check_for_newline = auto()",
      "comment": "Could you document this in future-style.md? (I have a PR in #4187 that will enforce this.)",
      "comment_id": 1472245952,
      "user": "JelleZijlstra",
      "created_at": "2024-01-31T02:54:04Z",
      "url": "https://github.com/psf/black/pull/4185#discussion_r1472245952"
    },
    {
      "repo": "psf/black",
      "pr_number": 4185,
      "file_path": "src/black/linegen.py",
      "line": 491,
      "side": "RIGHT",
      "diff_hunk": "@@ -477,15 +477,22 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n                 last_line_length = len(lines[-1]) if docstring else 0\n \n                 # If adding closing quotes would cause the last line to exceed\n-                # the maximum line length then put a line break before the\n-                # closing quotes\n+                # the maximum line length, and the closing quote is not\n+                # prefixed by a newline then put a line break before\n+                # the closing quotes\n                 if (\n                     len(lines) > 1\n                     and last_line_length + quote_len > self.mode.line_length\n                     and len(indent) + quote_len <= self.mode.line_length\n                     and not has_trailing_backslash\n                 ):\n-                    leaf.value = prefix + quote + docstring + \"\\n\" + indent + quote\n+                    if (\n+                        Preview.docstring_check_for_newline in self.mode\n+                        and leaf.value[-4] == \"\\n\"",
      "comment": "```suggestion\r\n                        and leaf.value[-1 - quote_len] == \"\\n\"\r\n```",
      "comment_id": 1472246317,
      "user": "JelleZijlstra",
      "created_at": "2024-01-31T02:54:51Z",
      "url": "https://github.com/psf/black/pull/4185#discussion_r1472246317"
    },
    {
      "repo": "psf/black",
      "pr_number": 4185,
      "file_path": "src/black/mode.py",
      "line": 180,
      "side": "RIGHT",
      "diff_hunk": "@@ -177,6 +177,7 @@ class Preview(Enum):\n     wrap_long_dict_values_in_parens = auto()\n     multiline_string_handling = auto()\n     typed_params_trailing_comma = auto()\n+    docstring_check_for_newline = auto()",
      "comment": "Yep, it is in there now. I do apologize for missing that.",
      "comment_id": 1472267431,
      "user": "veryslowcode",
      "created_at": "2024-01-31T03:38:43Z",
      "url": "https://github.com/psf/black/pull/4185#discussion_r1472267431"
    },
    {
      "repo": "psf/black",
      "pr_number": 4164,
      "file_path": "src/black/linegen.py",
      "line": 1082,
      "side": "RIGHT",
      "diff_hunk": "@@ -1074,7 +1075,14 @@ def bracket_split_build_line(\n             no_commas = (\n                 original.is_def\n                 and opening_bracket.value == \"(\"\n-                and not any(leaf.type == token.COMMA for leaf in leaves)\n+                and not any(\n+                    leaf.type == token.COMMA\n+                    and (\n+                        Preview.typed_params_trailing_comma not in original.mode\n+                        or not is_part_of_annotation(leaf)",
      "comment": "Can we use `is_part_of_annotation` to simplify some of the logic in the next check too? Lines 1092-1099?",
      "comment_id": 1466017458,
      "user": "hauntsaninja",
      "created_at": "2024-01-25T08:38:58Z",
      "url": "https://github.com/psf/black/pull/4164#discussion_r1466017458"
    },
    {
      "repo": "psf/black",
      "pr_number": 4164,
      "file_path": "src/black/linegen.py",
      "line": 1082,
      "side": "RIGHT",
      "diff_hunk": "@@ -1074,7 +1075,14 @@ def bracket_split_build_line(\n             no_commas = (\n                 original.is_def\n                 and opening_bracket.value == \"(\"\n-                and not any(leaf.type == token.COMMA for leaf in leaves)\n+                and not any(\n+                    leaf.type == token.COMMA\n+                    and (\n+                        Preview.typed_params_trailing_comma not in original.mode\n+                        or not is_part_of_annotation(leaf)",
      "comment": "I tried, but it ended up adding a lot of unrelated changes to this PR since `is_part_of_annotation` currently checks for both return and parameter annotations. I can do that refactor in a future PR.",
      "comment_id": 1466689991,
      "user": "cobaltt7",
      "created_at": "2024-01-25T17:11:38Z",
      "url": "https://github.com/psf/black/pull/4164#discussion_r1466689991"
    },
    {
      "repo": "psf/black",
      "pr_number": 4165,
      "file_path": "src/black/__init__.py",
      "line": 195,
      "side": "RIGHT",
      "diff_hunk": "@@ -181,6 +186,15 @@ def read_pyproject_toml(\n     return value\n \n \n+def spellcheck_pyproject_toml_keys(\n+    ctx: click.Context, config_keys: List[str], config_file_path: str\n+) -> None:\n+    available_config_options = {param.name for param in ctx.command.params}\n+    for key in config_keys:\n+        if key not in available_config_options:\n+            raise InvalidConfigKey(f\"Invalid key {key} in {config_file_path}\")",
      "comment": "If there are multiple invalid keys, could you make the error message list them all at once? That makes for a better debugging experience, since otherwise if you have N invalid keys you have to run Black N times to see them all.",
      "comment_id": 1465451778,
      "user": "JelleZijlstra",
      "created_at": "2024-01-24T19:40:06Z",
      "url": "https://github.com/psf/black/pull/4165#discussion_r1465451778"
    },
    {
      "repo": "psf/black",
      "pr_number": 4167,
      "file_path": "src/black/lines.py",
      "line": 628,
      "side": "RIGHT",
      "diff_hunk": "@@ -623,9 +619,23 @@ def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n         user_had_newline = bool(before)\n         depth = current_line.depth\n \n+        # Mutate self.previous_defs, remainder of this function should be pure\n         previous_def = None\n         while self.previous_defs and self.previous_defs[-1].depth >= depth:\n             previous_def = self.previous_defs.pop()\n+        if current_line.is_decorator or current_line.is_def or current_line.is_class:\n+            if not current_line.is_decorator:\n+                self.previous_defs.append(current_line)",
      "comment": "```suggestion\r\n        if current_line.is_def or current_line.is_class:\r\n            self.previous_defs.append(current_line)\r\n```\r\nThis should be equivalent unless I'm missing something",
      "comment_id": 1466372859,
      "user": "JelleZijlstra",
      "created_at": "2024-01-25T13:21:48Z",
      "url": "https://github.com/psf/black/pull/4167#discussion_r1466372859"
    },
    {
      "repo": "psf/black",
      "pr_number": 4167,
      "file_path": "src/black/lines.py",
      "line": 628,
      "side": "RIGHT",
      "diff_hunk": "@@ -623,9 +619,23 @@ def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n         user_had_newline = bool(before)\n         depth = current_line.depth\n \n+        # Mutate self.previous_defs, remainder of this function should be pure\n         previous_def = None\n         while self.previous_defs and self.previous_defs[-1].depth >= depth:\n             previous_def = self.previous_defs.pop()\n+        if current_line.is_decorator or current_line.is_def or current_line.is_class:\n+            if not current_line.is_decorator:\n+                self.previous_defs.append(current_line)",
      "comment": "Thanks, fixed. Logic was previously inside `_maybe_empty_lines_for_class_or_def` and I'd just copied the guard around that function call.",
      "comment_id": 1466972158,
      "user": "hauntsaninja",
      "created_at": "2024-01-25T21:19:05Z",
      "url": "https://github.com/psf/black/pull/4167#discussion_r1466972158"
    },
    {
      "repo": "psf/black",
      "pr_number": 4146,
      "file_path": "src/black/comments.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -88,7 +89,8 @@ def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:\n     form_feed = False\n     for index, full_line in enumerate(re.split(\"\\r?\\n\", prefix)):\n         consumed += len(full_line) + 1  # adding the length of the split '\\n'\n-        line = full_line.lstrip()\n+        match = re.match(r\"^(\\s*)(\\S.*|)$\", full_line)\n+        whitespace, line = (\"  \", full_line) if match is None else match.groups()",
      "comment": "The regex should always match, right? If so, would be clearer to add an assert.",
      "comment_id": 1460027478,
      "user": "JelleZijlstra",
      "created_at": "2024-01-19T23:58:59Z",
      "url": "https://github.com/psf/black/pull/4146#discussion_r1460027478"
    },
    {
      "repo": "psf/black",
      "pr_number": 4155,
      "file_path": "src/black/linegen.py",
      "line": 1559,
      "side": "RIGHT",
      "diff_hunk": "@@ -1545,6 +1555,10 @@ def maybe_make_parens_invisible_in_atom(\n             and max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY\n         )\n         or is_tuple_containing_walrus(node)\n+        or (\n+            Preview.wrap_long_dict_values_in_parens in mode",
      "comment": "Do we need the preview check? Intuitively I'd think we shouldn't because we'll almost always cause a crash if we remove the parens around a walrus.",
      "comment_id": 1454470336,
      "user": "JelleZijlstra",
      "created_at": "2024-01-17T03:23:06Z",
      "url": "https://github.com/psf/black/pull/4155#discussion_r1454470336"
    },
    {
      "repo": "psf/black",
      "pr_number": 4132,
      "file_path": "src/black/nodes.py",
      "line": 745,
      "side": "RIGHT",
      "diff_hunk": "@@ -742,10 +742,6 @@ def is_multiline_string(leaf: Leaf) -> bool:\n     return has_triple_quotes(leaf.value) and \"\\n\" in leaf.value\n \n \n-def is_funcdef(node: Node) -> bool:\n-    return node.type == syms.funcdef\n-\n-\n def is_function_or_class(node: Node) -> bool:",
      "comment": "This function is suspicious since many async defs don't have async_funcdef, but this can be subject for different PR\r\n\r\nedit: https://github.com/psf/black/pull/4133",
      "comment_id": 1437923223,
      "user": "hauntsaninja",
      "created_at": "2023-12-28T23:47:53Z",
      "url": "https://github.com/psf/black/pull/4132#discussion_r1437923223"
    },
    {
      "repo": "psf/black",
      "pr_number": 4095,
      "file_path": "src/black/strings.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,6 +63,8 @@ def lines_with_leading_tabs_expanded(s: str) -> List[str]:\n             )\n         else:\n             lines.append(line)\n+    if s.endswith(\"\\n\"):",
      "comment": "This was necessary so that we don't remove the newline at the end of a module docstring.",
      "comment_id": 1421677523,
      "user": "JelleZijlstra",
      "created_at": "2023-12-10T03:26:27Z",
      "url": "https://github.com/psf/black/pull/4095#discussion_r1421677523"
    },
    {
      "repo": "psf/black",
      "pr_number": 4076,
      "file_path": "src/black/__init__.py",
      "line": 274,
      "side": "RIGHT",
      "diff_hunk": "@@ -270,7 +271,7 @@ def validate_regex(\n     \"-x\",\n     \"--skip-source-first-line\",\n     is_flag=True,\n-    help=\"Skip the first line of the source code.\",\n+    help=\"Skip formatting the first line of the source code.\",",
      "comment": "I think the previous wording is better. We don't just skip formatting the first line; we skip even parsing it.",
      "comment_id": 1408478527,
      "user": "JelleZijlstra",
      "created_at": "2023-11-28T22:07:42Z",
      "url": "https://github.com/psf/black/pull/4076#discussion_r1408478527"
    },
    {
      "repo": "psf/black",
      "pr_number": 4076,
      "file_path": "src/black/__init__.py",
      "line": 441,
      "side": "RIGHT",
      "diff_hunk": "@@ -404,26 +416,30 @@ def validate_regex(\n     type=click.IntRange(min=1),\n     default=None,\n     help=(\n-        \"Number of parallel workers [default: BLACK_NUM_WORKERS environment variable \"\n-        \"or number of CPUs in the system]\"\n+        \"When Black formats multiple files, it may use a process pool to speed up\"\n+        \" formatting. This option controls the number of parallel workers. This can\"\n+        \" also be specified via the BLACK_NUM_WORKERS environment variable. Defaults\"\n+        \" to the number of CPUs in the system.\"\n     ),\n )\n @click.option(\n     \"-q\",\n     \"--quiet\",\n     is_flag=True,\n     help=(\n-        \"Don't emit non-error messages to stderr. Errors are still emitted; silence\"\n-        \" those with 2>/dev/null.\"\n+        \"Stop emitting all non-critical output. Error messages will still be emitted\"\n+        \" (which can Error messages will still be emitted (which can silenced by\"\n+        \" 2>/dev/null).\"\n     ),\n )\n @click.option(\n     \"-v\",\n     \"--verbose\",\n     is_flag=True,\n     help=(\n-        \"Also emit messages to stderr about files that were not changed or were ignored\"\n-        \" due to exclusion patterns.\"\n+        \"Emit messages about files that were not changed or were ignored due to\"\n+        \" exclusion patterns. If Black is using a configuration file, a blue message\"",
      "comment": "I feel like we shouldn't specify color in our text.",
      "comment_id": 1408481162,
      "user": "JelleZijlstra",
      "created_at": "2023-11-28T22:10:57Z",
      "url": "https://github.com/psf/black/pull/4076#discussion_r1408481162"
    },
    {
      "repo": "psf/black",
      "pr_number": 4010,
      "file_path": "tests/data/cases/preview_prefer_rhs_split.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -84,3 +84,14 @@\n ) or (\n     isinstance(some_other_var, BaseClass) and table.something != table.some_other_thing\n )\n+\n+# Multiple targets\n+a = b = (",
      "comment": "We should also consider cases where one of the assignment targets is a long string and the RHS is short (`a = bbbbbbbbbbbbbb = c`).",
      "comment_id": 1377858185,
      "user": "JelleZijlstra",
      "created_at": "2023-10-31T16:21:34Z",
      "url": "https://github.com/psf/black/pull/4010#discussion_r1377858185"
    },
    {
      "repo": "psf/black",
      "pr_number": 4010,
      "file_path": "src/black/linegen.py",
      "line": 943,
      "side": "RIGHT",
      "diff_hunk": "@@ -919,10 +931,20 @@ def _maybe_split_omitting_optional_parens(\n             yield result\n \n \n-def _prefer_split_rhs_oop(rhs_oop: RHSResult, mode: Mode) -> bool:\n+def _prefer_split_rhs_oop_over_rhs(\n+    rhs_oop: RHSResult, rhs: RHSResult, mode: Mode\n+) -> bool:\n     \"\"\"\n-    Returns whether we should prefer the result from a split omitting optional parens.\n+    Returns whether we should prefer the result from a split omitting optional parens\n+    (rhs_oop) over the original (rhs).\n     \"\"\"\n+    # If we have multiple targets, we prefer more `=`s on the head vs pushing them to\n+    # the body\n+    lhs_equal_count = [leaf.type for leaf in rhs.head.leaves].count(token.EQUAL)",
      "comment": "```suggestion\r\n    rhs_equal_count = [leaf.type for leaf in rhs.head.leaves].count(token.EQUAL)\r\n```\r\nNot sure where the \"lhs\" comes from here?",
      "comment_id": 1381148529,
      "user": "JelleZijlstra",
      "created_at": "2023-11-03T04:25:52Z",
      "url": "https://github.com/psf/black/pull/4010#discussion_r1381148529"
    },
    {
      "repo": "psf/black",
      "pr_number": 4010,
      "file_path": "src/black/linegen.py",
      "line": 943,
      "side": "RIGHT",
      "diff_hunk": "@@ -919,10 +931,20 @@ def _maybe_split_omitting_optional_parens(\n             yield result\n \n \n-def _prefer_split_rhs_oop(rhs_oop: RHSResult, mode: Mode) -> bool:\n+def _prefer_split_rhs_oop_over_rhs(\n+    rhs_oop: RHSResult, rhs: RHSResult, mode: Mode\n+) -> bool:\n     \"\"\"\n-    Returns whether we should prefer the result from a split omitting optional parens.\n+    Returns whether we should prefer the result from a split omitting optional parens\n+    (rhs_oop) over the original (rhs).\n     \"\"\"\n+    # If we have multiple targets, we prefer more `=`s on the head vs pushing them to\n+    # the body\n+    lhs_equal_count = [leaf.type for leaf in rhs.head.leaves].count(token.EQUAL)",
      "comment": "The thought process was, that rhs.head becomes the lhs in the cases where we have multiple assignments. But yeah, better to stick with `rhs_head`. \ud83d\udc4d ",
      "comment_id": 1381379037,
      "user": "henriholopainen",
      "created_at": "2023-11-03T09:23:18Z",
      "url": "https://github.com/psf/black/pull/4010#discussion_r1381379037"
    },
    {
      "repo": "psf/black",
      "pr_number": 4021,
      "file_path": "src/black/linegen.py",
      "line": 998,
      "side": "LEFT",
      "diff_hunk": "@@ -996,8 +997,6 @@ def bracket_split_build_line(\n         result.inside_brackets = True\n         result.depth += 1\n         if leaves:\n-            # Since body is a new indent level, remove spurious leading whitespace.\n-            normalize_prefix(leaves[0], inside_brackets=True)",
      "comment": "For the record on this one: removing this didn't change anything in the test suite. I traced it back, and I got all the way to the initial commit before I found a version of black where removing this made a test fail. git bisect showed that it was changes in whitespace handling in commit da3c2f358208dc9838c63d57b66c89e164eb241a that made this superfluous.",
      "comment_id": 1385913194,
      "user": "tungol",
      "created_at": "2023-11-08T03:18:34Z",
      "url": "https://github.com/psf/black/pull/4021#discussion_r1385913194"
    },
    {
      "repo": "psf/black",
      "pr_number": 4012,
      "file_path": "src/black/lines.py",
      "line": 206,
      "side": "LEFT",
      "diff_hunk": "@@ -200,9 +200,9 @@ def is_triple_quoted_string(self) -> bool:\n         value = self.leaves[0].value\n         if value.startswith(('\"\"\"', \"'''\")):\n             return True\n-        if Preview.accept_raw_docstrings in self.mode and value.startswith(\n-            (\"r'''\", 'r\"\"\"', \"R'''\", 'R\"\"\"')",
      "comment": "Perhaps the rule should be that if the inner collection fits on a single line, we keep the parentheses with the inner collection.",
      "comment_id": 1384284154,
      "user": "JelleZijlstra",
      "created_at": "2023-11-07T02:38:58Z",
      "url": "https://github.com/psf/black/pull/4012#discussion_r1384284154"
    },
    {
      "repo": "psf/black",
      "pr_number": 4012,
      "file_path": "src/black/lines.py",
      "line": 206,
      "side": "LEFT",
      "diff_hunk": "@@ -200,9 +200,9 @@ def is_triple_quoted_string(self) -> bool:\n         value = self.leaves[0].value\n         if value.startswith(('\"\"\"', \"'''\")):\n             return True\n-        if Preview.accept_raw_docstrings in self.mode and value.startswith(\n-            (\"r'''\", 'r\"\"\"', \"R'''\", 'R\"\"\"')",
      "comment": "Agreed. Updated so it no longer hugs if the pre-hugged version fits on a single line.",
      "comment_id": 1384345368,
      "user": "yilei",
      "created_at": "2023-11-07T04:02:18Z",
      "url": "https://github.com/psf/black/pull/4012#discussion_r1384345368"
    },
    {
      "repo": "psf/black",
      "pr_number": 4049,
      "file_path": "tests/optional.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,7 +26,15 @@\n     from pytest import StashKey\n except ImportError:\n     # pytest < 7\n-    from _pytest.store import StoreKey as StashKey  # type: ignore[import, no-redef]\n+    #\n+    # \"isort: skip\" is needed or it moves the \"type: ignore\" to the following line\n+    # becuase of the line length, and then mypy complains.",
      "comment": "```suggestion\r\n    # because of the line length, and then mypy complains.\r\n```",
      "comment_id": 1398225253,
      "user": "JelleZijlstra",
      "created_at": "2023-11-18T15:14:27Z",
      "url": "https://github.com/psf/black/pull/4049#discussion_r1398225253"
    },
    {
      "repo": "psf/black",
      "pr_number": 4024,
      "file_path": "src/black/linegen.py",
      "line": 1265,
      "side": "RIGHT",
      "diff_hunk": "@@ -1260,6 +1260,13 @@ def normalize_invisible_parens(\n                 child, parens_after=parens_after, mode=mode, features=features\n             )\n \n+        # Fixes a bug where invisible parens are not properly wrapped around\n+        # case blocks.\n+        if isinstance(child, Node) and child.type == syms.case_block:",
      "comment": "You also need to gate these code changes on the preview style. Look for similar checks like `if Preview.fix_power_op_line_length in mode`. In the test you'll want to add `# flags: --preview`.",
      "comment_id": 1382726125,
      "user": "JelleZijlstra",
      "created_at": "2023-11-06T02:25:49Z",
      "url": "https://github.com/psf/black/pull/4024#discussion_r1382726125"
    },
    {
      "repo": "psf/black",
      "pr_number": 4024,
      "file_path": "src/black/linegen.py",
      "line": 1265,
      "side": "RIGHT",
      "diff_hunk": "@@ -1260,6 +1260,13 @@ def normalize_invisible_parens(\n                 child, parens_after=parens_after, mode=mode, features=features\n             )\n \n+        # Fixes a bug where invisible parens are not properly wrapped around\n+        # case blocks.\n+        if isinstance(child, Node) and child.type == syms.case_block:",
      "comment": "Thanks for the guidance! I've made the modifications!",
      "comment_id": 1382772665,
      "user": "rdrll",
      "created_at": "2023-11-06T04:35:11Z",
      "url": "https://github.com/psf/black/pull/4024#discussion_r1382772665"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/__init__.py",
      "line": 1352,
      "side": "RIGHT",
      "diff_hunk": "@@ -1343,6 +1343,37 @@ def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:\n     return imports\n \n \n+def _is_diff_from_string_quote_types(diff: str) -> bool:\n+    \"\"\"\n+    Returns True if the diff contains only changes in strings where quotes change from\n+    ' -> \" or \" -> '. For example\n+\n+    -                    'desc[\"status\"]=',  # str\n+    +                    \"desc['status']=\",  # str",
      "comment": "I don't think we should do this, as it changes visible output (due to the debug f-string). It's unlikely that people rely on that, sure, but I really don't want running Black to affect the output of a program.",
      "comment_id": 1377782958,
      "user": "JelleZijlstra",
      "created_at": "2023-10-31T15:31:16Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1377782958"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/__init__.py",
      "line": 1352,
      "side": "RIGHT",
      "diff_hunk": "@@ -1343,6 +1343,37 @@ def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:\n     return imports\n \n \n+def _is_diff_from_string_quote_types(diff: str) -> bool:\n+    \"\"\"\n+    Returns True if the diff contains only changes in strings where quotes change from\n+    ' -> \" or \" -> '. For example\n+\n+    -                    'desc[\"status\"]=',  # str\n+    +                    \"desc['status']=\",  # str",
      "comment": "Valid point! Would inconsistent behaviour between\r\n\r\n```\r\nf'foo {x[\"bar\"]}'\r\n-->\r\nf\"foo {x['bar']}\"\r\n```\r\n\r\nand\r\n\r\n```\r\nf'foo {x[\"bar\"]=}'\r\n-->\r\nf'foo {x[\"bar\"]=}'\r\n```\r\n\r\nbe acceptable?",
      "comment_id": 1377866529,
      "user": "henriholopainen",
      "created_at": "2023-10-31T16:27:38Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1377866529"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/__init__.py",
      "line": 1352,
      "side": "RIGHT",
      "diff_hunk": "@@ -1343,6 +1343,37 @@ def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:\n     return imports\n \n \n+def _is_diff_from_string_quote_types(diff: str) -> bool:\n+    \"\"\"\n+    Returns True if the diff contains only changes in strings where quotes change from\n+    ' -> \" or \" -> '. For example\n+\n+    -                    'desc[\"status\"]=',  # str\n+    +                    \"desc['status']=\",  # str",
      "comment": "Excellent point, I think the second revision's solution is way better. \ud83d\ude4f",
      "comment_id": 1378070052,
      "user": "henriholopainen",
      "created_at": "2023-10-31T19:23:08Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1378070052"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/trans.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -590,11 +590,21 @@ def make_naked(string: str, string_prefix: str) -> str:\n             \"\"\"\n             assert_is_leaf_string(string)\n             if \"f\" in string_prefix:\n-                string = _toggle_fexpr_quotes(string, QUOTE)\n-                # After quotes toggling, quotes in expressions won't be escaped\n-                # because quotes can't be reused in f-strings. So we can simply\n-                # let the escaping logic below run without knowing f-string\n-                # expressions.\n+                f_expressions = (\n+                    string[span[0] : span[1]] for span in iter_fexpr_spans(string)\n+                )\n+                expressions_contain_printable_quotes = any(\n+                    re.search(r\".*[\\'\\\"].*=\", expression)",
      "comment": "Something like this could avoid false triggering on `f\"{x == y}\"`\r\n```suggestion\r\n                    re.fullmatch(r\".*[\\'\\\"].*=\\s*\", expression)\r\n```",
      "comment_id": 1378236718,
      "user": "hauntsaninja",
      "created_at": "2023-10-31T22:57:12Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1378236718"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/trans.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -590,11 +590,21 @@ def make_naked(string: str, string_prefix: str) -> str:\n             \"\"\"\n             assert_is_leaf_string(string)\n             if \"f\" in string_prefix:\n-                string = _toggle_fexpr_quotes(string, QUOTE)\n-                # After quotes toggling, quotes in expressions won't be escaped\n-                # because quotes can't be reused in f-strings. So we can simply\n-                # let the escaping logic below run without knowing f-string\n-                # expressions.\n+                f_expressions = (\n+                    string[span[0] : span[1]] for span in iter_fexpr_spans(string)\n+                )\n+                expressions_contain_printable_quotes = any(\n+                    re.search(r\".*[\\'\\\"].*=\", expression)",
      "comment": "`f'{foo[\"bar\"]=:.2f}'` would still be a problem. Maybe `re.fullmatch(r\"{.*[\\'\\\"][^=]*=[^=]*}\", expression)`?",
      "comment_id": 1378256992,
      "user": "henriholopainen",
      "created_at": "2023-10-31T23:31:34Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1378256992"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/trans.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -590,11 +590,21 @@ def make_naked(string: str, string_prefix: str) -> str:\n             \"\"\"\n             assert_is_leaf_string(string)\n             if \"f\" in string_prefix:\n-                string = _toggle_fexpr_quotes(string, QUOTE)\n-                # After quotes toggling, quotes in expressions won't be escaped\n-                # because quotes can't be reused in f-strings. So we can simply\n-                # let the escaping logic below run without knowing f-string\n-                # expressions.\n+                f_expressions = (\n+                    string[span[0] : span[1]] for span in iter_fexpr_spans(string)\n+                )\n+                expressions_contain_printable_quotes = any(\n+                    re.search(r\".*[\\'\\\"].*=\", expression)",
      "comment": "Oh good point. I think that won't work with `!=` and `:=` and so on. I think maybe let's just keep this as in the current version of the PR and revisit when PEP 701 support is landed",
      "comment_id": 1378259931,
      "user": "hauntsaninja",
      "created_at": "2023-10-31T23:38:14Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1378259931"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/trans.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -590,11 +590,21 @@ def make_naked(string: str, string_prefix: str) -> str:\n             \"\"\"\n             assert_is_leaf_string(string)\n             if \"f\" in string_prefix:\n-                string = _toggle_fexpr_quotes(string, QUOTE)\n-                # After quotes toggling, quotes in expressions won't be escaped\n-                # because quotes can't be reused in f-strings. So we can simply\n-                # let the escaping logic below run without knowing f-string\n-                # expressions.\n+                f_expressions = (\n+                    string[span[0] : span[1]] for span in iter_fexpr_spans(string)\n+                )\n+                expressions_contain_printable_quotes = any(\n+                    re.search(r\".*[\\'\\\"].*=\", expression)",
      "comment": "This catches a little too much:\r\n\r\n```\r\n% black --line-length=20 --preview -c \"log.info(f'{\\\"a\\\" == \\\"b\\\"} aaaaaa aa aa aa')\"                  \r\nlog.info(\r\n    f'{\"a\" == \"b\"} aaaaaa'\r\n    \" aa aa aa\"\r\n)\r\n```\r\n\r\nHere I'd expect the quotes to get reversed.",
      "comment_id": 1381145623,
      "user": "JelleZijlstra",
      "created_at": "2023-11-03T04:18:54Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1381145623"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "tests/data/cases/preview_long_strings.py",
      "line": 317,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,6 +305,15 @@ def foo():\n # Test case of an outer string' parens enclose an inner string's parens.\n call(body=(\"%s %s\" % ((\",\".join(items)), suffix)))\n \n+log.info(f'Skipping: {desc[\"db_id\"]=} {desc[\"ms_name\"]} {money=} {dte=} {pos_share=} {desc[\"status\"]=} {desc[\"exposure_max\"]=}')\n+\n+log.info(f\"Skipping: {desc['db_id']=} {desc['ms_name']} {money=} {dte=} {pos_share=} {desc['status']=} {desc['exposure_max']=}\")\n+\n+log.info(f'Skipping: {desc[\"db_id\"]} {desc[\"ms_name\"]} {money=} {dte=} {pos_share=} {desc[\"status\"]} {desc[\"exposure_max\"]}')\n+\n+log.info(f'Skipping: {foo(\"asdf\")=} {desc[\"ms_name\"]} {money=} {dte=} {pos_share=} {desc[\"status\"]} {desc[\"exposure_max\"]}')\n+\n+log.info(f'Skipping: {  longer_longer_longer_longer_longer_longer_name   [ \"db_id\" ]      [ \"another_key\" ]   =  :  .3f }')\n ",
      "comment": "Add some test cases involving triple quotes, e.g.\r\n\r\n```\r\n% black --line-length=20 --preview -c \"log.info(f'''{\\\"a\\\" == 'b'} aaaaaa aa aa aa aa aa aa aa''')\"\r\nlog.info(\r\n    f\"\"\"{\"a\" == 'b'} aaaaaa aa aa aa aa aa aa aa\"\"\"\r\n)\r\n```\r\n",
      "comment_id": 1381146044,
      "user": "JelleZijlstra",
      "created_at": "2023-11-03T04:19:59Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1381146044"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/trans.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -590,11 +590,21 @@ def make_naked(string: str, string_prefix: str) -> str:\n             \"\"\"\n             assert_is_leaf_string(string)\n             if \"f\" in string_prefix:\n-                string = _toggle_fexpr_quotes(string, QUOTE)\n-                # After quotes toggling, quotes in expressions won't be escaped\n-                # because quotes can't be reused in f-strings. So we can simply\n-                # let the escaping logic below run without knowing f-string\n-                # expressions.\n+                f_expressions = (\n+                    string[span[0] : span[1]] for span in iter_fexpr_spans(string)\n+                )\n+                expressions_contain_printable_quotes = any(\n+                    re.search(r\".*[\\'\\\"].*=\", expression)",
      "comment": "Nice catch! Also `{ \"a\" == \"b\"= }` is valid, as is `{ \"a\" == \"b\" == \"c\" ... = }`. I'll try to find a better regex.",
      "comment_id": 1381249675,
      "user": "henriholopainen",
      "created_at": "2023-11-03T07:52:11Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1381249675"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/trans.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -590,11 +590,21 @@ def make_naked(string: str, string_prefix: str) -> str:\n             \"\"\"\n             assert_is_leaf_string(string)\n             if \"f\" in string_prefix:\n-                string = _toggle_fexpr_quotes(string, QUOTE)\n-                # After quotes toggling, quotes in expressions won't be escaped\n-                # because quotes can't be reused in f-strings. So we can simply\n-                # let the escaping logic below run without knowing f-string\n-                # expressions.\n+                f_expressions = (\n+                    string[span[0] : span[1]] for span in iter_fexpr_spans(string)\n+                )\n+                expressions_contain_printable_quotes = any(\n+                    re.search(r\".*[\\'\\\"].*=\", expression)",
      "comment": "Like in https://github.com/psf/black/pull/4005/files#r1378259931 I'm fine with the regex as is \u2014 we can revisit with PEP 701 support. Although we should add some test cases for these.\r\n\r\nI don't see a way to do it without negative lookbehind, something like `.*[\\'\\\"].*(?<![=!:])=` maybe",
      "comment_id": 1381274326,
      "user": "hauntsaninja",
      "created_at": "2023-11-03T08:17:32Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1381274326"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/trans.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -590,11 +590,21 @@ def make_naked(string: str, string_prefix: str) -> str:\n             \"\"\"\n             assert_is_leaf_string(string)\n             if \"f\" in string_prefix:\n-                string = _toggle_fexpr_quotes(string, QUOTE)\n-                # After quotes toggling, quotes in expressions won't be escaped\n-                # because quotes can't be reused in f-strings. So we can simply\n-                # let the escaping logic below run without knowing f-string\n-                # expressions.\n+                f_expressions = (\n+                    string[span[0] : span[1]] for span in iter_fexpr_spans(string)\n+                )\n+                expressions_contain_printable_quotes = any(\n+                    re.search(r\".*[\\'\\\"].*=\", expression)",
      "comment": "Yeah, currently looking at `.*[\\'\\\"].*(?<![!:=])={1}(?!=)(?![^\\s:])`",
      "comment_id": 1381293948,
      "user": "henriholopainen",
      "created_at": "2023-11-03T08:34:36Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1381293948"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "src/black/trans.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -590,11 +590,21 @@ def make_naked(string: str, string_prefix: str) -> str:\n             \"\"\"\n             assert_is_leaf_string(string)\n             if \"f\" in string_prefix:\n-                string = _toggle_fexpr_quotes(string, QUOTE)\n-                # After quotes toggling, quotes in expressions won't be escaped\n-                # because quotes can't be reused in f-strings. So we can simply\n-                # let the escaping logic below run without knowing f-string\n-                # expressions.\n+                f_expressions = (\n+                    string[span[0] : span[1]] for span in iter_fexpr_spans(string)\n+                )\n+                expressions_contain_printable_quotes = any(\n+                    re.search(r\".*[\\'\\\"].*=\", expression)",
      "comment": "And maybe it's better to be more consistent, even if the regex becomes a bit more complex",
      "comment_id": 1381296109,
      "user": "henriholopainen",
      "created_at": "2023-11-03T08:36:13Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1381296109"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "tests/data/cases/preview_long_strings.py",
      "line": 317,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,6 +305,15 @@ def foo():\n # Test case of an outer string' parens enclose an inner string's parens.\n call(body=(\"%s %s\" % ((\",\".join(items)), suffix)))\n \n+log.info(f'Skipping: {desc[\"db_id\"]=} {desc[\"ms_name\"]} {money=} {dte=} {pos_share=} {desc[\"status\"]=} {desc[\"exposure_max\"]=}')\n+\n+log.info(f\"Skipping: {desc['db_id']=} {desc['ms_name']} {money=} {dte=} {pos_share=} {desc['status']=} {desc['exposure_max']=}\")\n+\n+log.info(f'Skipping: {desc[\"db_id\"]} {desc[\"ms_name\"]} {money=} {dte=} {pos_share=} {desc[\"status\"]} {desc[\"exposure_max\"]}')\n+\n+log.info(f'Skipping: {foo(\"asdf\")=} {desc[\"ms_name\"]} {money=} {dte=} {pos_share=} {desc[\"status\"]} {desc[\"exposure_max\"]}')\n+\n+log.info(f'Skipping: {  longer_longer_longer_longer_longer_longer_name   [ \"db_id\" ]      [ \"another_key\" ]   =  :  .3f }')\n ",
      "comment": "I don't think your example is valid, as f-strings are not supposed to have backslashes inside the expressions. I wonder why the `-c` option allows this.",
      "comment_id": 1381325943,
      "user": "henriholopainen",
      "created_at": "2023-11-03T09:01:46Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1381325943"
    },
    {
      "repo": "psf/black",
      "pr_number": 4005,
      "file_path": "tests/data/cases/preview_long_strings.py",
      "line": 317,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,6 +305,15 @@ def foo():\n # Test case of an outer string' parens enclose an inner string's parens.\n call(body=(\"%s %s\" % ((\",\".join(items)), suffix)))\n \n+log.info(f'Skipping: {desc[\"db_id\"]=} {desc[\"ms_name\"]} {money=} {dte=} {pos_share=} {desc[\"status\"]=} {desc[\"exposure_max\"]=}')\n+\n+log.info(f\"Skipping: {desc['db_id']=} {desc['ms_name']} {money=} {dte=} {pos_share=} {desc['status']=} {desc['exposure_max']=}\")\n+\n+log.info(f'Skipping: {desc[\"db_id\"]} {desc[\"ms_name\"]} {money=} {dte=} {pos_share=} {desc[\"status\"]} {desc[\"exposure_max\"]}')\n+\n+log.info(f'Skipping: {foo(\"asdf\")=} {desc[\"ms_name\"]} {money=} {dte=} {pos_share=} {desc[\"status\"]} {desc[\"exposure_max\"]}')\n+\n+log.info(f'Skipping: {  longer_longer_longer_longer_longer_longer_name   [ \"db_id\" ]      [ \"another_key\" ]   =  :  .3f }')\n ",
      "comment": "These backslashes are handled by the shell, not Python. (This was on a Mac; on Windows you'd probably need different quoting.)",
      "comment_id": 1382009370,
      "user": "JelleZijlstra",
      "created_at": "2023-11-03T17:26:03Z",
      "url": "https://github.com/psf/black/pull/4005#discussion_r1382009370"
    },
    {
      "repo": "psf/black",
      "pr_number": 4020,
      "file_path": "src/black/ranges.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,496 @@\n+\"\"\"Functions related to Black's formatting by line ranges feature.\"\"\"\n+\n+import difflib\n+from dataclasses import dataclass\n+from typing import Collection, Iterator, List, Sequence, Set, Tuple, Union\n+\n+from black.nodes import (\n+    LN,\n+    STANDALONE_COMMENT,\n+    Leaf,\n+    Node,\n+    Visitor,\n+    first_leaf,\n+    furthest_ancestor_with_last_leaf,\n+    last_leaf,\n+    syms,\n+)\n+from blib2to3.pgen2.token import ASYNC, NEWLINE\n+\n+\n+def parse_line_ranges(line_ranges: Sequence[str]) -> List[Tuple[int, int]]:\n+    lines: List[Tuple[int, int]] = []\n+    for lines_str in line_ranges:\n+        parts = lines_str.split(\"-\")\n+        if len(parts) != 2:\n+            raise ValueError(\n+                \"Incorrect --line-ranges format, expect 'START-END', found\"\n+                f\" {lines_str!r}\"\n+            )\n+        try:\n+            start = int(parts[0])\n+            end = int(parts[1])\n+        except ValueError:\n+            raise ValueError(\n+                \"Incorrect --line-ranges value, expect integer ranges, found\"\n+                f\" {lines_str!r}\"\n+            ) from None\n+        else:\n+            lines.append((start, end))\n+    return lines\n+\n+\n+def is_valid_line_range(lines: Tuple[int, int]) -> bool:\n+    \"\"\"Returns whether the line range is valid.\"\"\"\n+    return not lines or lines[0] <= lines[1]\n+\n+\n+def adjusted_lines(\n+    lines: Collection[Tuple[int, int]],\n+    original_source: str,\n+    modified_source: str,\n+) -> List[Tuple[int, int]]:\n+    \"\"\"Returns the adjusted line ranges based on edits from the original code.\n+\n+    This computes the new line ranges by diffing original_source and\n+    modified_source, and adjust each range based on how the range overlaps with\n+    the diffs.\n+\n+    Note the diff can contain lines outside of the original line ranges. This can\n+    happen when the formatting has to be done in adjacent to maintain consistent\n+    local results. For example:\n+\n+    1. def my_func(arg1, arg2,\n+    2.             arg3,):\n+    3.   pass\n+\n+    If it restricts to line 2-2, it can't simply reformat line 2, it also has\n+    to reformat line 1:\n+\n+    1. def my_func(\n+    2.     arg1,\n+    3.     arg2,\n+    4.     arg3,\n+    5. ):\n+    6.   pass\n+\n+    In this case, we will expand the line ranges to also include the whole diff\n+    block.\n+\n+    Args:\n+      lines: a collection of line ranges.\n+      original_source: the original source.\n+      modified_source: the modified source.\n+    \"\"\"\n+    lines_mappings = _calculate_lines_mappings(original_source, modified_source)\n+\n+    new_lines = []\n+    # Keep an index of the current search. Since the lines and lines_mappings are\n+    # sorted, this makes the search complexity linear.\n+    current_mapping_index = 0\n+    for start, end in sorted(lines):\n+        start_mapping_index = _find_lines_mapping_index(\n+            start,\n+            lines_mappings,\n+            current_mapping_index,\n+        )\n+        end_mapping_index = _find_lines_mapping_index(\n+            end,\n+            lines_mappings,\n+            start_mapping_index,\n+        )\n+        current_mapping_index = start_mapping_index\n+        if start_mapping_index >= len(lines_mappings) or end_mapping_index >= len(\n+            lines_mappings\n+        ):\n+            # Protect against invalid inputs.\n+            continue\n+        start_mapping = lines_mappings[start_mapping_index]\n+        end_mapping = lines_mappings[end_mapping_index]\n+        if start_mapping.is_changed_block:\n+            # When the line falls into a changed block, expands to the whole block.\n+            new_start = start_mapping.modified_start\n+        else:\n+            new_start = (\n+                start - start_mapping.original_start + start_mapping.modified_start\n+            )\n+        if end_mapping.is_changed_block:\n+            # When the line falls into a changed block, expands to the whole block.\n+            new_end = end_mapping.modified_end\n+        else:\n+            new_end = end - end_mapping.original_start + end_mapping.modified_start\n+        new_range = (new_start, new_end)\n+        if is_valid_line_range(new_range):\n+            new_lines.append(new_range)\n+    return new_lines\n+\n+\n+def convert_unchanged_lines(src_node: Node, lines: Collection[Tuple[int, int]]) -> None:\n+    \"\"\"Converts unchanged lines to STANDALONE_COMMENT.\n+\n+    The idea is similar to `# fmt: on/off` is implemented. It also converts the",
      "comment": "```suggestion\r\n    The idea is similar to how `# fmt: on/off` is implemented. It also converts the\r\n```",
      "comment_id": 1384222809,
      "user": "JelleZijlstra",
      "created_at": "2023-11-07T01:04:42Z",
      "url": "https://github.com/psf/black/pull/4020#discussion_r1384222809"
    },
    {
      "repo": "psf/black",
      "pr_number": 4020,
      "file_path": "src/black/ranges.py",
      "line": 420,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,496 @@\n+\"\"\"Functions related to Black's formatting by line ranges feature.\"\"\"\n+\n+import difflib\n+from dataclasses import dataclass\n+from typing import Collection, Iterator, List, Sequence, Set, Tuple, Union\n+\n+from black.nodes import (\n+    LN,\n+    STANDALONE_COMMENT,\n+    Leaf,\n+    Node,\n+    Visitor,\n+    first_leaf,\n+    furthest_ancestor_with_last_leaf,\n+    last_leaf,\n+    syms,\n+)\n+from blib2to3.pgen2.token import ASYNC, NEWLINE\n+\n+\n+def parse_line_ranges(line_ranges: Sequence[str]) -> List[Tuple[int, int]]:\n+    lines: List[Tuple[int, int]] = []\n+    for lines_str in line_ranges:\n+        parts = lines_str.split(\"-\")\n+        if len(parts) != 2:\n+            raise ValueError(\n+                \"Incorrect --line-ranges format, expect 'START-END', found\"\n+                f\" {lines_str!r}\"\n+            )\n+        try:\n+            start = int(parts[0])\n+            end = int(parts[1])\n+        except ValueError:\n+            raise ValueError(\n+                \"Incorrect --line-ranges value, expect integer ranges, found\"\n+                f\" {lines_str!r}\"\n+            ) from None\n+        else:\n+            lines.append((start, end))\n+    return lines\n+\n+\n+def is_valid_line_range(lines: Tuple[int, int]) -> bool:\n+    \"\"\"Returns whether the line range is valid.\"\"\"\n+    return not lines or lines[0] <= lines[1]\n+\n+\n+def adjusted_lines(\n+    lines: Collection[Tuple[int, int]],\n+    original_source: str,\n+    modified_source: str,\n+) -> List[Tuple[int, int]]:\n+    \"\"\"Returns the adjusted line ranges based on edits from the original code.\n+\n+    This computes the new line ranges by diffing original_source and\n+    modified_source, and adjust each range based on how the range overlaps with\n+    the diffs.\n+\n+    Note the diff can contain lines outside of the original line ranges. This can\n+    happen when the formatting has to be done in adjacent to maintain consistent\n+    local results. For example:\n+\n+    1. def my_func(arg1, arg2,\n+    2.             arg3,):\n+    3.   pass\n+\n+    If it restricts to line 2-2, it can't simply reformat line 2, it also has\n+    to reformat line 1:\n+\n+    1. def my_func(\n+    2.     arg1,\n+    3.     arg2,\n+    4.     arg3,\n+    5. ):\n+    6.   pass\n+\n+    In this case, we will expand the line ranges to also include the whole diff\n+    block.\n+\n+    Args:\n+      lines: a collection of line ranges.\n+      original_source: the original source.\n+      modified_source: the modified source.\n+    \"\"\"\n+    lines_mappings = _calculate_lines_mappings(original_source, modified_source)\n+\n+    new_lines = []\n+    # Keep an index of the current search. Since the lines and lines_mappings are\n+    # sorted, this makes the search complexity linear.\n+    current_mapping_index = 0\n+    for start, end in sorted(lines):\n+        start_mapping_index = _find_lines_mapping_index(\n+            start,\n+            lines_mappings,\n+            current_mapping_index,\n+        )\n+        end_mapping_index = _find_lines_mapping_index(\n+            end,\n+            lines_mappings,\n+            start_mapping_index,\n+        )\n+        current_mapping_index = start_mapping_index\n+        if start_mapping_index >= len(lines_mappings) or end_mapping_index >= len(\n+            lines_mappings\n+        ):\n+            # Protect against invalid inputs.\n+            continue\n+        start_mapping = lines_mappings[start_mapping_index]\n+        end_mapping = lines_mappings[end_mapping_index]\n+        if start_mapping.is_changed_block:\n+            # When the line falls into a changed block, expands to the whole block.\n+            new_start = start_mapping.modified_start\n+        else:\n+            new_start = (\n+                start - start_mapping.original_start + start_mapping.modified_start\n+            )\n+        if end_mapping.is_changed_block:\n+            # When the line falls into a changed block, expands to the whole block.\n+            new_end = end_mapping.modified_end\n+        else:\n+            new_end = end - end_mapping.original_start + end_mapping.modified_start\n+        new_range = (new_start, new_end)\n+        if is_valid_line_range(new_range):\n+            new_lines.append(new_range)\n+    return new_lines\n+\n+\n+def convert_unchanged_lines(src_node: Node, lines: Collection[Tuple[int, int]]) -> None:\n+    \"\"\"Converts unchanged lines to STANDALONE_COMMENT.\n+\n+    The idea is similar to `# fmt: on/off` is implemented. It also converts the\n+    nodes between those markers as a single `STANDALONE_COMMENT` leaf node with\n+    the unformatted code as its value. `STANDALONE_COMMENT` is a \"fake\" token\n+    that will be formatted as-is with its prefix normalized.\n+\n+    Here we perform two passes:\n+\n+    1. Visit the top-level statements, and convert them to a single\n+       `STANDALONE_COMMENT` when unchanged. This speeds up formatting when some\n+       of the top-level statements aren't changed.\n+    2. Convert unchanged \"unwrapped lines\" to `STANDALONE_COMMENT` nodes line by\n+       line. \"unwrapped lines\" are divided by the `NEWLINE` token. e.g. a\n+       multi-line statement is *one* \"unwrapped line\" that ends with `NEWLINE`,\n+       even though this statement itself can span multiple lines, and the\n+       tokenizer only sees the last '\\n' as the `NEWLINE` token.\n+\n+    NOTE: During pass (2), comment prefixes and indentations are ALWAYS\n+    normalized even when the lines aren't changed. This is fixable by moving\n+    more formatting to pass (1). However, it's hard to get it correct when\n+    incorrect indentations are used. So we defer this to future optimizations.\n+    \"\"\"\n+    lines_set: Set[int] = set()\n+    for start, end in lines:\n+        lines_set.update(range(start, end + 1))\n+    visitor = _TopLevelStatementsVisitor(lines_set)\n+    _ = list(visitor.visit(src_node))  # Consume all results.\n+    _convert_unchanged_line_by_line(src_node, lines_set)\n+\n+\n+def _contains_standalone_comment(node: LN) -> bool:\n+    if isinstance(node, Leaf):\n+        return node.type == STANDALONE_COMMENT\n+    else:\n+        for child in node.children:\n+            if _contains_standalone_comment(child):\n+                return True\n+        return False\n+\n+\n+class _TopLevelStatementsVisitor(Visitor[None]):\n+    \"\"\"\n+    A node visitor that converts unchanged top-level statements to\n+    STANDALONE_COMMENT.\n+\n+    This is used in addition to _convert_unchanged_lines_by_flatterning, to\n+    speed up formatting when there are unchanged top-level\n+    classes/functions/statements.\n+    \"\"\"\n+\n+    def __init__(self, lines_set: Set[int]):\n+        self._lines_set = lines_set\n+\n+    def visit_simple_stmt(self, node: Node) -> Iterator[None]:\n+        # This is only called for top-level statements, since `visit_suite`\n+        # won't visit its children nodes.\n+        yield from []\n+        newline_leaf = last_leaf(node)\n+        if not newline_leaf:\n+            return\n+        assert (\n+            newline_leaf.type == NEWLINE\n+        ), f\"Unexpectedly found leaf.type={newline_leaf.type}\"\n+        # We need to find the furthest ancestor with the NEWLINE as the last\n+        # leaf, since a `suite` can simply be a `simple_stmt` when it puts\n+        # its body on the same line. Example: `if cond: pass`.\n+        ancestor = furthest_ancestor_with_last_leaf(newline_leaf)\n+        if not _get_line_range(ancestor).intersection(self._lines_set):\n+            _convert_node_to_standalone_comment(ancestor)\n+\n+    def visit_suite(self, node: Node) -> Iterator[None]:\n+        yield from []\n+        # If there is a STANDALONE_COMMENT node, it means parts of the node tree\n+        # have fmt on/off/skip markers. Those STANDALONE_COMMENT nodes can't\n+        # be simply converted by calling str(node). So we just don't convert\n+        # here.\n+        if _contains_standalone_comment(node):\n+            return\n+        # Find the semantic parent of this suite. For `async_stmt` and\n+        # `async_funcdef`, the ASYNC token is defined on a separate level by the\n+        # grammar.\n+        semantic_parent = node.parent\n+        if semantic_parent is not None:\n+            if (\n+                semantic_parent.prev_sibling is not None\n+                and semantic_parent.prev_sibling.type == ASYNC\n+            ):\n+                semantic_parent = semantic_parent.parent\n+        if semantic_parent is not None and not _get_line_range(\n+            semantic_parent\n+        ).intersection(self._lines_set):\n+            _convert_node_to_standalone_comment(semantic_parent)\n+\n+\n+def _convert_unchanged_line_by_line(node: Node, lines_set: Set[int]) -> None:\n+    \"\"\"Converts unchanged to STANDALONE_COMMENT line by line.\"\"\"\n+    for leaf in node.leaves():\n+        if leaf.type != NEWLINE:\n+            # We only consider \"unwrapped lines\", which are divided by the NEWLINE\n+            # token.\n+            continue\n+        if leaf.parent and leaf.parent.type == syms.match_stmt:\n+            # The `suite` node is defined as:\n+            #   match_stmt: \"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT\n+            # Here we need to check `subject_expr`. The `case_block+` will be\n+            # checked by their own NEWLINEs.\n+            nodes_to_ignore: List[LN] = []\n+            prev_sibling = leaf.prev_sibling\n+            while prev_sibling:\n+                nodes_to_ignore.insert(0, prev_sibling)\n+                prev_sibling = prev_sibling.prev_sibling\n+            if not _get_line_range(nodes_to_ignore).intersection(lines_set):\n+                _convert_nodes_to_standalone_comment(nodes_to_ignore, newline=leaf)\n+        elif leaf.parent and leaf.parent.type == syms.suite:\n+            # The `suite` node is defined as:\n+            #   suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT\n+            # We will check `simple_stmt` and `stmt+` separately against the lines set\n+            parent_sibling = leaf.parent.prev_sibling\n+            nodes_to_ignore = []\n+            while parent_sibling and not parent_sibling.type == syms.suite:\n+                # NOTE: Multiple suite nodes can exist as siblings in e.g. `if_stmt`.\n+                nodes_to_ignore.insert(0, parent_sibling)\n+                parent_sibling = parent_sibling.prev_sibling\n+            # Special case for `async_stmt` and `async_funcdef` where the ASYNC\n+            # token is on the grandparent node.\n+            grandparent = leaf.parent.parent\n+            if (\n+                grandparent is not None\n+                and grandparent.prev_sibling is not None\n+                and grandparent.prev_sibling.type == ASYNC\n+            ):\n+                nodes_to_ignore.insert(0, grandparent.prev_sibling)\n+            if not _get_line_range(nodes_to_ignore).intersection(lines_set):\n+                _convert_nodes_to_standalone_comment(nodes_to_ignore, newline=leaf)\n+        else:\n+            ancestor = furthest_ancestor_with_last_leaf(leaf)\n+            # Consider multiple decorators as a whole block, as their\n+            # newlines have different behaviors than the rest of the grammar.\n+            if (\n+                ancestor.type == syms.decorator\n+                and ancestor.parent\n+                and ancestor.parent.type == syms.decorators\n+            ):\n+                ancestor = ancestor.parent\n+            if not _get_line_range(ancestor).intersection(lines_set):\n+                _convert_node_to_standalone_comment(ancestor)\n+\n+\n+def _convert_node_to_standalone_comment(node: LN) -> None:\n+    \"\"\"Convert node to STANDALONE_COMMENT by modifying the tree inline.\"\"\"\n+    parent = node.parent\n+    if not parent:\n+        return\n+    first = first_leaf(node)\n+    last = last_leaf(node)\n+    if not first or not last:\n+        return\n+    if first is last:\n+        # This can happen on the following edge cases:\n+        # 1. A block of `# fmt: off/on` code except the `# fmt: on` is placed\n+        #    on the end of the last line instead of on a new line.\n+        # 2. A single backslash on its own line followed by a comment line.\n+        # Ideally we don't want to format them when not requested, but fixing\n+        # isn't easy. These cases are also badly formatted code, so it isn't\n+        # too bad we reformat them.\n+        return\n+    # The prefix contains comments and indentation whitespaces. They are\n+    # reformatted accordingly to the correct indentation level.\n+    # This also means the indentation will be changed on the unchanged lines, and\n+    # this is actually required to not break incremental reformatting.\n+    prefix = first.prefix\n+    first.prefix = \"\"\n+    index = node.remove()\n+    if index is not None:\n+        # Remove the '\\n', as STANDALONE_COMMENT will have '\\n' appended when\n+        # genearting the formatted code.\n+        value = str(node)[:-1]\n+        parent.insert_child(\n+            index,\n+            Leaf(\n+                STANDALONE_COMMENT,\n+                value,\n+                prefix=prefix,\n+                fmt_pass_converted_first_leaf=first,\n+            ),\n+        )\n+\n+\n+def _convert_nodes_to_standalone_comment(nodes: Sequence[LN], *, newline: Leaf) -> None:\n+    \"\"\"Convert nodes to STANDALONE_COMMENT by modifying the tree inline.\"\"\"\n+    if not nodes:\n+        return\n+    parent = nodes[0].parent\n+    first = first_leaf(nodes[0])\n+    if not parent or not first:\n+        return\n+    prefix = first.prefix\n+    first.prefix = \"\"\n+    value = \"\".join(str(node) for node in nodes)\n+    # The prefix comment on the NEWLINE leaf is the trailing comment of the statement.\n+    if newline.prefix:\n+        value += newline.prefix\n+        newline.prefix = \"\"\n+    index = nodes[0].remove()\n+    for node in nodes[1:]:\n+        node.remove()\n+    if index is not None:\n+        parent.insert_child(\n+            index,\n+            Leaf(\n+                STANDALONE_COMMENT,\n+                value,\n+                prefix=prefix,\n+                fmt_pass_converted_first_leaf=first,\n+            ),\n+        )\n+\n+\n+def _leaf_line_end(leaf: Leaf) -> int:\n+    \"\"\"Returns the line number of the leaf node's last line.\"\"\"\n+    if leaf.type == NEWLINE:\n+        return leaf.lineno\n+    else:\n+        # Leaf nodes like multiline strings can occupy multiple lines.\n+        return leaf.lineno + str(leaf).count(\"\\n\")\n+\n+\n+def _get_line_range(node_or_nodes: Union[LN, List[LN]]) -> Set[int]:\n+    \"\"\"Returns the line range of this node or list of nodes.\"\"\"\n+    if isinstance(node_or_nodes, list):\n+        nodes = node_or_nodes\n+        if not nodes:\n+            return set()\n+        first = first_leaf(nodes[0])\n+        last = last_leaf(nodes[-1])\n+        if first and last:\n+            line_start = first.lineno\n+            line_end = _leaf_line_end(last)\n+            return set(range(line_start, line_end + 1))\n+        else:\n+            return set()\n+    else:\n+        node = node_or_nodes\n+        if isinstance(node, Leaf):\n+            return set(range(node.lineno, _leaf_line_end(node) + 1))\n+        else:\n+            first = first_leaf(node)\n+            last = last_leaf(node)\n+            if first and last:\n+                return set(range(first.lineno, _leaf_line_end(last) + 1))\n+            else:\n+                return set()\n+\n+\n+@dataclass\n+class _LinesMapping:\n+    \"\"\"1-based lines mapping from original source to modified source.\n+\n+    Lines [original_start, original_end] from original source\n+    are mapped to [modified_start, modified_end].\n+\n+    The ranges are inclusive on both ends.\n+    \"\"\"\n+\n+    original_start: int\n+    original_end: int\n+    modified_start: int\n+    modified_end: int\n+    # Whether this range corresponds to a changed block, or an unchanged block.\n+    is_changed_block: bool\n+\n+\n+def _calculate_lines_mappings(\n+    original_source: str,\n+    modified_source: str,\n+) -> Sequence[_LinesMapping]:\n+    \"\"\"Returns a sequence of _LinesMapping by diffing the sources.\n+\n+    For example, given the following diff:\n+        import re\n+      - def func(arg1,\n+      -   arg2, arg3):\n+      + def func(arg1, arg2, arg3):\n+          pass\n+    It returns the following mappings:\n+      original -> modified\n+       (1, 1)  ->  (1, 1), is_changed_block=False (the \"import re\" line)\n+       (2, 3)  ->  (2, 2), is_changed_block=True (the diff)\n+       (4, 4)  ->  (3, 3), is_changed_block=False (the \"pass\" line)\n+\n+    You can think this visually as if it brings up a side-by-side diff, and tries",
      "comment": "```suggestion\r\n    You can think of this visually as if it brings up a side-by-side diff, and tries\r\n```",
      "comment_id": 1384224401,
      "user": "JelleZijlstra",
      "created_at": "2023-11-07T01:08:06Z",
      "url": "https://github.com/psf/black/pull/4020#discussion_r1384224401"
    },
    {
      "repo": "psf/black",
      "pr_number": 4020,
      "file_path": "tests/test_ranges.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,185 @@\n+\"\"\"Test the ink_adjusted_lines module.\"\"\"",
      "comment": "```suggestion\r\n\"\"\"Test the black.ranges module.\"\"\"\r\n```",
      "comment_id": 1384230619,
      "user": "JelleZijlstra",
      "created_at": "2023-11-07T01:20:45Z",
      "url": "https://github.com/psf/black/pull/4020#discussion_r1384230619"
    },
    {
      "repo": "psf/black",
      "pr_number": 3964,
      "file_path": "tests/data/cases/preview_hug_parens_with_braces_and_square_brackets.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,79 @@\n+# flags: --preview\n+def foo_brackets(request):\n+    return JsonResponse(",
      "comment": "Ideas for additional tests:\r\n\r\n- Test that comments in various places are preserved (e.g., after the opening `(` or before the closing `)`)\r\n- Test where the argument is a list comprehension\r\n- Test where the argument is a set literal",
      "comment_id": 1367979776,
      "user": "JelleZijlstra",
      "created_at": "2023-10-22T22:28:32Z",
      "url": "https://github.com/psf/black/pull/3964#discussion_r1367979776"
    },
    {
      "repo": "psf/black",
      "pr_number": 3964,
      "file_path": "src/black/linegen.py",
      "line": 823,
      "side": "RIGHT",
      "diff_hunk": "@@ -815,6 +815,19 @@ def _first_right_hand_split(\n     tail_leaves.reverse()\n     body_leaves.reverse()\n     head_leaves.reverse()\n+\n+    if Preview.hug_parens_with_braces_and_square_brackets in line.mode:\n+        if (\n+            tail_leaves[0].type == token.RPAR\n+            and tail_leaves[0].value\n+            and tail_leaves[0].opening_bracket is head_leaves[-1]",
      "comment": "```suggestion\r\n            and tail_leaves[0].opening_bracket == head_leaves[-1]\r\n```\r\nI don't think we can guarantee identity",
      "comment_id": 1370293545,
      "user": "JelleZijlstra",
      "created_at": "2023-10-24T14:32:00Z",
      "url": "https://github.com/psf/black/pull/3964#discussion_r1370293545"
    },
    {
      "repo": "psf/black",
      "pr_number": 3964,
      "file_path": "src/black/linegen.py",
      "line": 825,
      "side": "RIGHT",
      "diff_hunk": "@@ -815,6 +815,19 @@ def _first_right_hand_split(\n     tail_leaves.reverse()\n     body_leaves.reverse()\n     head_leaves.reverse()\n+\n+    if Preview.hug_parens_with_braces_and_square_brackets in line.mode:\n+        if (\n+            tail_leaves[0].type == token.RPAR\n+            and tail_leaves[0].value\n+            and tail_leaves[0].opening_bracket is head_leaves[-1]\n+            and body_leaves[-1].type in [token.RBRACE, token.RSQB]\n+            and body_leaves[-1].opening_bracket is body_leaves[0]",
      "comment": "```suggestion\r\n            and body_leaves[-1].opening_bracket == body_leaves[0]\r\n```",
      "comment_id": 1370293808,
      "user": "JelleZijlstra",
      "created_at": "2023-10-24T14:32:08Z",
      "url": "https://github.com/psf/black/pull/3964#discussion_r1370293808"
    },
    {
      "repo": "psf/black",
      "pr_number": 3964,
      "file_path": "src/black/linegen.py",
      "line": 825,
      "side": "RIGHT",
      "diff_hunk": "@@ -815,6 +815,19 @@ def _first_right_hand_split(\n     tail_leaves.reverse()\n     body_leaves.reverse()\n     head_leaves.reverse()\n+\n+    if Preview.hug_parens_with_braces_and_square_brackets in line.mode:\n+        if (\n+            tail_leaves[0].type == token.RPAR\n+            and tail_leaves[0].value\n+            and tail_leaves[0].opening_bracket is head_leaves[-1]\n+            and body_leaves[-1].type in [token.RBRACE, token.RSQB]\n+            and body_leaves[-1].opening_bracket is body_leaves[0]",
      "comment": "If we don't check for identity here, cases like\r\n\r\n```\r\nbaaaaaaaaaaaaar([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], {x}, \"a string\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\r\n```\r\n\r\nwill format to\r\n\r\n```\r\nbaaaaaaaaaaaaar([\r\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10], {x}, \"a string\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10\r\n])\r\n```\r\n\r\nwhich is not something we want.",
      "comment_id": 1370790382,
      "user": "henriholopainen",
      "created_at": "2023-10-24T20:43:50Z",
      "url": "https://github.com/psf/black/pull/3964#discussion_r1370790382"
    },
    {
      "repo": "psf/black",
      "pr_number": 3964,
      "file_path": "src/black/linegen.py",
      "line": 823,
      "side": "RIGHT",
      "diff_hunk": "@@ -815,6 +815,19 @@ def _first_right_hand_split(\n     tail_leaves.reverse()\n     body_leaves.reverse()\n     head_leaves.reverse()\n+\n+    if Preview.hug_parens_with_braces_and_square_brackets in line.mode:\n+        if (\n+            tail_leaves[0].type == token.RPAR\n+            and tail_leaves[0].value\n+            and tail_leaves[0].opening_bracket is head_leaves[-1]",
      "comment": "Why not? The whole `omit` system in `_first_right_hand_split` seems to rely on `id(leaf)`, so the leaf objects should be stable and thus identity comparisons should be safe also here. Or am I missing something?",
      "comment_id": 1370792796,
      "user": "henriholopainen",
      "created_at": "2023-10-24T20:46:27Z",
      "url": "https://github.com/psf/black/pull/3964#discussion_r1370792796"
    },
    {
      "repo": "psf/black",
      "pr_number": 4016,
      "file_path": "src/black/lines.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,7 +102,11 @@ def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:\n         Raises ValueError when any `leaf` is appended after a standalone comment\n         or when a standalone comment is not the first leaf on the line.\n         \"\"\"\n-        if self.bracket_tracker.depth == 0:\n+        if (\n+            self.bracket_tracker.depth == 0\n+            or self.bracket_tracker._for_loop_depths",
      "comment": "We should make these attributes public if we're using them outside the class.",
      "comment_id": 1384261566,
      "user": "JelleZijlstra",
      "created_at": "2023-11-07T02:07:48Z",
      "url": "https://github.com/psf/black/pull/4016#discussion_r1384261566"
    },
    {
      "repo": "psf/black",
      "pr_number": 4019,
      "file_path": "src/black/nodes.py",
      "line": 532,
      "side": "RIGHT",
      "diff_hunk": "@@ -529,7 +529,7 @@ def is_docstring(leaf: Leaf) -> bool:\n         return False\n \n     prefix = get_string_prefix(leaf.value)\n-    if \"b\" in prefix or \"B\" in prefix:\n+    if \"b\" in prefix or \"B\" in prefix or \"f\" in prefix or \"F\" in prefix:",
      "comment": "Might be slightly cleaner?\r\n\r\n```suggestion\r\n    if set(prefix).intersection(\"bBfF\"):\r\n```",
      "comment_id": 1381270784,
      "user": "AlexWaygood",
      "created_at": "2023-11-03T08:13:36Z",
      "url": "https://github.com/psf/black/pull/4019#discussion_r1381270784"
    },
    {
      "repo": "psf/black",
      "pr_number": 3992,
      "file_path": "tests/data/cases/preview_hug_parens_with_braces_and_square_brackets.py",
      "line": 140,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +137,10 @@ def foo_square_brackets(request):\n     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], {x}, \"a string\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n )\n \n+foo(*[\"long long long long long line\", \"long long long long long line\", \"long long long long long line\"])",
      "comment": "Can you also add tests for `**` unpacking (as mentioned by @Avasam)?",
      "comment_id": 1375143545,
      "user": "JelleZijlstra",
      "created_at": "2023-10-28T01:36:13Z",
      "url": "https://github.com/psf/black/pull/3992#discussion_r1375143545"
    },
    {
      "repo": "psf/black",
      "pr_number": 3992,
      "file_path": "tests/data/cases/preview_hug_parens_with_braces_and_square_brackets.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +137,19 @@ def foo_square_brackets(request):\n     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], {x}, \"a string\", [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n )\n \n+foo(*[\"long long long long long line\", \"long long long long long line\", \"long long long long long line\"])\n+\n+foo(*[str(i) for i in range(100000000000000000000000000000000000000000000000000000000000)])\n+\n+foo(",
      "comment": "Also test a dict comprehension for completeness (like the one in cache.py).",
      "comment_id": 1375328402,
      "user": "JelleZijlstra",
      "created_at": "2023-10-28T22:18:08Z",
      "url": "https://github.com/psf/black/pull/3992#discussion_r1375328402"
    },
    {
      "repo": "psf/black",
      "pr_number": 3974,
      "file_path": "release.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,243 @@\n+#!/usr/bin/env python3\n+\n+from __future__ import annotations\n+\n+\"\"\"\n+Tool to help automate changes needed in commits during and after releases\n+\"\"\"\n+\n+import argparse\n+import logging\n+import sys\n+from datetime import datetime\n+from pathlib import Path\n+from subprocess import PIPE, run\n+from typing import List\n+\n+LOG = logging.getLogger(__name__)\n+NEW_VERSION_CHANGELOG_TEMPLATE = \"\"\"\\\n+## Unreleased\n+\n+### Highlights\n+\n+<!-- Include any especially major or disruptive changes here -->\n+\n+### Stable style\n+\n+<!-- Changes that affect Black's stable style -->\n+\n+### Preview style\n+\n+<!-- Changes that affect Black's preview style -->\n+\n+### Configuration\n+\n+<!-- Changes to how Black can be configured -->\n+\n+### Packaging\n+\n+<!-- Changes to how Black is packaged, such as dependency requirements -->\n+\n+### Parser\n+\n+<!-- Changes to the parser or to version autodetection -->\n+\n+### Performance\n+\n+<!-- Changes that improve Black's performance. -->\n+\n+### Output\n+\n+<!-- Changes to Black's terminal output and error messages -->\n+\n+### _Blackd_\n+\n+<!-- Changes to blackd -->\n+\n+### Integrations\n+\n+<!-- For example, Docker, GitHub Actions, pre-commit, editors -->\n+\n+### Documentation\n+\n+<!-- Major changes to documentation and policies. Small docs changes\n+     don't need a changelog entry. -->\n+\"\"\"\n+\n+\n+class NoGitTagsError(Exception): ...  # noqa: E701,E761\n+\n+\n+# TODO: Do better with alpha + beta releases\n+# Maybe we vendor packaging library\n+def get_git_tags(versions_only: bool = True) -> List[str]:\n+    \"\"\"Pull out all tags or calvers only\"\"\"\n+    cp = run([\"git\", \"tag\"], stdout=PIPE, stderr=PIPE, check=True, encoding=\"utf8\")\n+    if not cp.stdout:\n+        LOG.error(f\"Returned no git tags stdout: {cp.stderr}\")\n+        raise NoGitTagsError\n+    git_tags = cp.stdout.splitlines()\n+    if versions_only:\n+        return [t for t in git_tags if t[0].isdigit()]\n+    return git_tags\n+\n+\n+def int_calver(calver: str) -> int:\n+    \"\"\"Convert a calver string into an hex base 16 integer for sorting",
      "comment": "I don't think this does hex, not sure what the docstring is talking about.\r\n\r\nAlso, won't this sort incorrectly in some cases? 23.10.0 -> 23100, 24.1.0 -> 2410, the second is smaller.\r\n\r\nI think we can just do something like `tuple(map(int, calver.split(\".\")))`.",
      "comment_id": 1375145855,
      "user": "JelleZijlstra",
      "created_at": "2023-10-28T01:53:47Z",
      "url": "https://github.com/psf/black/pull/3974#discussion_r1375145855"
    },
    {
      "repo": "psf/black",
      "pr_number": 3974,
      "file_path": "release.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,243 @@\n+#!/usr/bin/env python3",
      "comment": "Maybe put this in the `scripts/` directory to keep the top-level a little tidier",
      "comment_id": 1375146325,
      "user": "JelleZijlstra",
      "created_at": "2023-10-28T01:56:50Z",
      "url": "https://github.com/psf/black/pull/3974#discussion_r1375146325"
    },
    {
      "repo": "psf/black",
      "pr_number": 3936,
      "file_path": "src/blackd/__init__.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,7 +74,7 @@ def main(bind_host: str, bind_port: int) -> None:\n     app = make_app()\n     ver = black.__version__\n     black.out(f\"blackd version {ver} listening on {bind_host} port {bind_port}\")\n-    web.run_app(app, host=bind_host, port=bind_port, handle_signals=True, print=None)\n+    web.run_app(app, host=bind_host, port=bind_port, handle_signals=True, print=None)  # type: ignore[arg-type]",
      "comment": "`print` argument accepts `Callable[..., None] = print` \r\ni.e. \r\n```zsh\r\nsrc/blackd/__init__.py:77:81: error: Argument \"print\" to \"run_app\" has incompatible type \"None\"; expected \"Callable[..., None]\"  [arg-type]\r\n\r\n```",
      "comment_id": 1351195362,
      "user": "acharles7",
      "created_at": "2023-10-10T02:03:18Z",
      "url": "https://github.com/psf/black/pull/3936#discussion_r1351195362"
    },
    {
      "repo": "psf/black",
      "pr_number": 3936,
      "file_path": "src/blackd/__init__.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,7 +74,7 @@ def main(bind_host: str, bind_port: int) -> None:\n     app = make_app()\n     ver = black.__version__\n     black.out(f\"blackd version {ver} listening on {bind_host} port {bind_port}\")\n-    web.run_app(app, host=bind_host, port=bind_port, handle_signals=True, print=None)\n+    web.run_app(app, host=bind_host, port=bind_port, handle_signals=True, print=None)  # type: ignore[arg-type]",
      "comment": "Seems like this is fixed on master: https://github.com/aio-libs/aiohttp/blob/30850babb43a8e28dd2df036776c62fd613d3d89/aiohttp/web.py#L453C5-L453C5. Can you add a comment saying that aiohttp had an incorrect annotation and that it will be fixed once aiohttp releases that code?",
      "comment_id": 1353940452,
      "user": "JelleZijlstra",
      "created_at": "2023-10-11T03:05:02Z",
      "url": "https://github.com/psf/black/pull/3936#discussion_r1353940452"
    },
    {
      "repo": "psf/black",
      "pr_number": 3938,
      "file_path": "src/black/concurrency.py",
      "line": 176,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,7 +172,11 @@ async def schedule_formatting(\n             if task.cancelled():\n                 cancelled.append(task)\n             elif task.exception():\n-                report.failed(src, str(task.exception()))\n+                exc = task.exception()\n+                assert exc is not None",
      "comment": "Use a walrus so you can avoid the assert?\r\n\r\n`elif exc := task.exception():`",
      "comment_id": 1351138454,
      "user": "JelleZijlstra",
      "created_at": "2023-10-10T01:40:06Z",
      "url": "https://github.com/psf/black/pull/3938#discussion_r1351138454"
    },
    {
      "repo": "psf/black",
      "pr_number": 3931,
      "file_path": "tests/test_black.py",
      "line": 214,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,8 +211,8 @@ def test_piping_diff(self) -> None:\n             r\"(STDIN|STDOUT)\\t\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d\\d\\d\\d\"\n             r\"\\+\\d\\d:\\d\\d\"\n         )\n-        source, _ = read_data(\"simple_cases\", \"expression.py\")\n-        expected, _ = read_data(\"simple_cases\", \"expression.diff\")\n+        source, _ = read_data(\"cases\", \"expression.py\")",
      "comment": "Possibly the test cases in this file that use `read_data()` should be cleaned up, especially those using the `cases` directory, but that can wait for another PR.",
      "comment_id": 1349598755,
      "user": "JelleZijlstra",
      "created_at": "2023-10-07T23:44:21Z",
      "url": "https://github.com/psf/black/pull/3931#discussion_r1349598755"
    },
    {
      "repo": "psf/black",
      "pr_number": 3902,
      "file_path": "tests/conftest.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -1 +1,28 @@\n+import pytest\n+\n pytest_plugins = [\"tests.optional\"]\n+\n+PRINT_FULL_TREE: bool = False\n+PRINT_TREE_DIFF: bool = True\n+\n+\n+def pytest_addoption(parser: pytest.Parser) -> None:\n+    parser.addoption(\n+        \"--print-full-tree\",\n+        action=\"store_true\",\n+        default=False,\n+        help=\"print full CST trees on failed tests\",",
      "comment": "```suggestion\r\n        help=\"print full syntax trees on failed tests\",\r\n```\r\n\"CST trees\" is redundant as the T stands for tree. Better to avoid the technical term here actually.",
      "comment_id": 1337239346,
      "user": "JelleZijlstra",
      "created_at": "2023-09-26T13:45:35Z",
      "url": "https://github.com/psf/black/pull/3902#discussion_r1337239346"
    },
    {
      "repo": "psf/black",
      "pr_number": 3902,
      "file_path": "tests/conftest.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -1 +1,28 @@\n+import pytest\n+\n pytest_plugins = [\"tests.optional\"]\n+\n+PRINT_FULL_TREE: bool = False\n+PRINT_TREE_DIFF: bool = True\n+\n+\n+def pytest_addoption(parser: pytest.Parser) -> None:\n+    parser.addoption(\n+        \"--print-full-tree\",\n+        action=\"store_true\",\n+        default=False,\n+        help=\"print full CST trees on failed tests\",\n+    )\n+    parser.addoption(\n+        \"--print-tree-diff\",\n+        action=\"store_true\",\n+        default=True,\n+        help=\"print diff of CST trees on failed tests\",",
      "comment": "```suggestion\r\n        help=\"print diff of syntax trees on failed tests\",\r\n```",
      "comment_id": 1337239558,
      "user": "JelleZijlstra",
      "created_at": "2023-09-26T13:45:42Z",
      "url": "https://github.com/psf/black/pull/3902#discussion_r1337239558"
    },
    {
      "repo": "psf/black",
      "pr_number": 3902,
      "file_path": "tests/util.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,31 +34,32 @@\n \n \n def _assert_format_equal(expected: str, actual: str) -> None:\n-    ast_print = not os.environ.get(\"SKIP_AST_PRINT\")\n-    ast_print_diff = not os.environ.get(\"SKIP_AST_PRINT_DIFF\")\n-    if actual != expected and (ast_print or ast_print_diff):\n+    # need to import inside the function for the monkeypatching tests to work",
      "comment": "Another approach which should work and I think is cleaner is to do `from . import conftest` in the global scope, and then use the qualified names like `conftest.PRINT_FULL_TREE` here.",
      "comment_id": 1337242361,
      "user": "JelleZijlstra",
      "created_at": "2023-09-26T13:47:28Z",
      "url": "https://github.com/psf/black/pull/3902#discussion_r1337242361"
    },
    {
      "repo": "psf/black",
      "pr_number": 3862,
      "file_path": "src/black/lines.py",
      "line": 719,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,6 +709,17 @@ def _maybe_empty_lines_for_class_or_def(  # noqa: C901\n                     newlines = 0\n                 else:\n                     newlines = 1\n+            # Remove case `self.previous_line.depth > current_line.depth` below when\n+            # this becomes stable.\n+            #\n+            # Don't inspect the previous line if it's part of the body of the previous\n+            # statement in the same level, we always want a blank line if there's\n+            # something with a body preceding.\n+            elif (\n+                Preview.blank_line_between_nested_and_def_stub_file",
      "comment": "```suggestion\r\n                Preview.blank_line_between_nested_and_def_stub_file in current_line.mode\r\n```",
      "comment_id": 1320004090,
      "user": "JelleZijlstra",
      "created_at": "2023-09-08T15:17:18Z",
      "url": "https://github.com/psf/black/pull/3862#discussion_r1320004090"
    },
    {
      "repo": "psf/black",
      "pr_number": 3821,
      "file_path": "src/black/cache.py",
      "line": 100,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,61 +44,103 @@ def get_cache_dir() -> Path:\n CACHE_DIR = get_cache_dir()\n \n \n-def read_cache(mode: Mode) -> Cache:\n-    \"\"\"Read the cache if it exists and is well formed.\n-\n-    If it is not well formed, the call to write_cache later should resolve the issue.\n-    \"\"\"\n-    cache_file = get_cache_file(mode)\n-    if not cache_file.exists():\n-        return {}\n-\n-    with cache_file.open(\"rb\") as fobj:\n-        try:\n-            cache: Cache = pickle.load(fobj)\n-        except (pickle.UnpicklingError, ValueError, IndexError):\n-            return {}\n-\n-    return cache\n-\n-\n def get_cache_file(mode: Mode) -> Path:\n     return CACHE_DIR / f\"cache.{mode.get_cache_key()}.pickle\"\n \n \n-def get_cache_info(path: Path) -> CacheInfo:\n-    \"\"\"Return the information used to check if a file is already formatted or not.\"\"\"\n-    stat = path.stat()\n-    return stat.st_mtime, stat.st_size\n-\n+@dataclass\n+class Cache:\n+    mode: Mode\n+    cache_file: Path\n+    file_data: Dict[str, FileData] = field(default_factory=dict)\n+\n+    @classmethod\n+    def read(cls, mode: Mode) -> Self:\n+        \"\"\"Read the cache if it exists and is well formed.\n+\n+        If it is not well formed, the call to write later should\n+        resolve the issue.\n+        \"\"\"\n+        cache_file = get_cache_file(mode)\n+        if not cache_file.exists():\n+            return cls(mode, cache_file)\n+\n+        with cache_file.open(\"rb\") as fobj:\n+            try:\n+                file_data: Dict[str, FileData] = pickle.load(fobj)\n+            except (pickle.UnpicklingError, ValueError, IndexError):\n+                return cls(mode, cache_file)\n+\n+        return cls(mode, cache_file, file_data)\n+\n+    @staticmethod\n+    def hash_digest(path: Path) -> str:\n+        \"\"\"Return hash digest for path.\"\"\"\n+\n+        with open(path, \"rb\") as fp:\n+            data = fp.read()\n+        return hashlib.sha256(data).hexdigest()\n+\n+    @staticmethod\n+    def get_file_data(path: Path) -> FileData:\n+        \"\"\"Return file data for path.\"\"\"\n+\n+        stat = path.stat()\n+        hash = Cache.hash_digest(path)\n+        return FileData(stat.st_mtime, stat.st_size, hash)\n+\n+    def is_changed(self, source: Path) -> bool:\n+        \"\"\"Check if source has changed compared to cached version.\"\"\"\n+        res_src = source.resolve()\n+        old = self.file_data.get(str(res_src))\n+        if old is None:\n+            return True\n+\n+        st = res_src.stat()\n+        if st.st_size != old.st_size or int(st.st_mtime) != int(old.st_mtime):",
      "comment": "Can we do `if st.st_size != old.st_size: return True`? This way we only do the hashing if the mtimes don't line up",
      "comment_id": 1292507782,
      "user": "hauntsaninja",
      "created_at": "2023-08-12T21:44:35Z",
      "url": "https://github.com/psf/black/pull/3821#discussion_r1292507782"
    },
    {
      "repo": "psf/black",
      "pr_number": 3821,
      "file_path": "src/black/cache.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,61 +44,103 @@ def get_cache_dir() -> Path:\n CACHE_DIR = get_cache_dir()\n \n \n-def read_cache(mode: Mode) -> Cache:\n-    \"\"\"Read the cache if it exists and is well formed.\n-\n-    If it is not well formed, the call to write_cache later should resolve the issue.\n-    \"\"\"\n-    cache_file = get_cache_file(mode)\n-    if not cache_file.exists():\n-        return {}\n-\n-    with cache_file.open(\"rb\") as fobj:\n-        try:\n-            cache: Cache = pickle.load(fobj)\n-        except (pickle.UnpicklingError, ValueError, IndexError):\n-            return {}\n-\n-    return cache\n-\n-\n def get_cache_file(mode: Mode) -> Path:\n     return CACHE_DIR / f\"cache.{mode.get_cache_key()}.pickle\"\n \n \n-def get_cache_info(path: Path) -> CacheInfo:\n-    \"\"\"Return the information used to check if a file is already formatted or not.\"\"\"\n-    stat = path.stat()\n-    return stat.st_mtime, stat.st_size\n-\n+@dataclass\n+class Cache:\n+    mode: Mode\n+    cache_file: Path\n+    file_data: Dict[str, FileData] = field(default_factory=dict)\n+\n+    @classmethod\n+    def read(cls, mode: Mode) -> Self:\n+        \"\"\"Read the cache if it exists and is well formed.\n+\n+        If it is not well formed, the call to write later should\n+        resolve the issue.\n+        \"\"\"\n+        cache_file = get_cache_file(mode)\n+        if not cache_file.exists():\n+            return cls(mode, cache_file)\n+\n+        with cache_file.open(\"rb\") as fobj:\n+            try:\n+                file_data: Dict[str, FileData] = pickle.load(fobj)\n+            except (pickle.UnpicklingError, ValueError, IndexError):\n+                return cls(mode, cache_file)\n+\n+        return cls(mode, cache_file, file_data)\n+\n+    @staticmethod\n+    def hash_digest(path: Path) -> str:\n+        \"\"\"Return hash digest for path.\"\"\"\n+\n+        with open(path, \"rb\") as fp:\n+            data = fp.read()\n+        return hashlib.sha256(data).hexdigest()\n+\n+    @staticmethod\n+    def get_file_data(path: Path) -> FileData:\n+        \"\"\"Return file data for path.\"\"\"\n+\n+        stat = path.stat()\n+        hash = Cache.hash_digest(path)\n+        return FileData(stat.st_mtime, stat.st_size, hash)\n+\n+    def is_changed(self, source: Path) -> bool:\n+        \"\"\"Check if source has changed compared to cached version.\"\"\"\n+        res_src = source.resolve()\n+        old = self.file_data.get(str(res_src))\n+        if old is None:\n+            return True\n+\n+        st = res_src.stat()\n+        if st.st_size != old.st_size or int(st.st_mtime) != int(old.st_mtime):\n+            new_hash = Cache.hash_digest(res_src)\n+            if st.st_size != old.st_size or new_hash != old.hash:\n+                return True\n+        return False\n+\n+    def filtered_cached(self, sources: Iterable[Path]) -> Tuple[Set[Path], Set[Path]]:\n+        \"\"\"Split an iterable of paths in `sources` into two sets.\n+\n+        The first contains paths of files that modified on disk or are not in the\n+        cache. The other contains paths to non-modified files.\n+        \"\"\"\n+        changed: Set[Path] = set()\n+        done: Set[Path] = set()\n+        for src in sources:\n+            res_src = src.resolve()\n+            old = self.file_data.get(str(res_src))\n+            st = res_src.stat()\n+\n+            if old is None:\n+                changed.add(src)\n+                continue\n+            elif st.st_size != old.st_size or int(st.st_mtime) != int(old.st_mtime):\n+                new_hash = Cache.hash_digest(res_src)\n+                if st.st_size != old.st_size or new_hash != old.hash:\n+                    changed.add(src)\n+                    continue\n+            done.add(src)\n+        return changed, done\n \n-def filter_cached(cache: Cache, sources: Iterable[Path]) -> Tuple[Set[Path], Set[Path]]:\n-    \"\"\"Split an iterable of paths in `sources` into two sets.\n+    def update(self, sources: Iterable[Path]) -> None:",
      "comment": "nit: can we name this something that makes it clearer it doesn't write? I'm also not seeing where we benefit from the separation, so maybe we should just make this write?",
      "comment_id": 1292517862,
      "user": "hauntsaninja",
      "created_at": "2023-08-12T22:14:09Z",
      "url": "https://github.com/psf/black/pull/3821#discussion_r1292517862"
    },
    {
      "repo": "psf/black",
      "pr_number": 3821,
      "file_path": "src/black/cache.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,61 +44,103 @@ def get_cache_dir() -> Path:\n CACHE_DIR = get_cache_dir()\n \n \n-def read_cache(mode: Mode) -> Cache:\n-    \"\"\"Read the cache if it exists and is well formed.\n-\n-    If it is not well formed, the call to write_cache later should resolve the issue.\n-    \"\"\"\n-    cache_file = get_cache_file(mode)\n-    if not cache_file.exists():\n-        return {}\n-\n-    with cache_file.open(\"rb\") as fobj:\n-        try:\n-            cache: Cache = pickle.load(fobj)\n-        except (pickle.UnpicklingError, ValueError, IndexError):\n-            return {}\n-\n-    return cache\n-\n-\n def get_cache_file(mode: Mode) -> Path:\n     return CACHE_DIR / f\"cache.{mode.get_cache_key()}.pickle\"\n \n \n-def get_cache_info(path: Path) -> CacheInfo:\n-    \"\"\"Return the information used to check if a file is already formatted or not.\"\"\"\n-    stat = path.stat()\n-    return stat.st_mtime, stat.st_size\n-\n+@dataclass\n+class Cache:\n+    mode: Mode\n+    cache_file: Path\n+    file_data: Dict[str, FileData] = field(default_factory=dict)\n+\n+    @classmethod\n+    def read(cls, mode: Mode) -> Self:\n+        \"\"\"Read the cache if it exists and is well formed.\n+\n+        If it is not well formed, the call to write later should\n+        resolve the issue.\n+        \"\"\"\n+        cache_file = get_cache_file(mode)\n+        if not cache_file.exists():\n+            return cls(mode, cache_file)\n+\n+        with cache_file.open(\"rb\") as fobj:\n+            try:\n+                file_data: Dict[str, FileData] = pickle.load(fobj)\n+            except (pickle.UnpicklingError, ValueError, IndexError):\n+                return cls(mode, cache_file)\n+\n+        return cls(mode, cache_file, file_data)\n+\n+    @staticmethod\n+    def hash_digest(path: Path) -> str:\n+        \"\"\"Return hash digest for path.\"\"\"\n+\n+        with open(path, \"rb\") as fp:\n+            data = fp.read()\n+        return hashlib.sha256(data).hexdigest()",
      "comment": "`sha256` works well for mypy. I would stick with it in this case.\r\nhttps://github.com/python/mypy/blob/v1.5.1/mypy/util.py#L501-L510",
      "comment_id": 1292749167,
      "user": "cdce8p",
      "created_at": "2023-08-13T10:35:09Z",
      "url": "https://github.com/psf/black/pull/3821#discussion_r1292749167"
    },
    {
      "repo": "psf/black",
      "pr_number": 3821,
      "file_path": "tests/test_black.py",
      "line": 2007,
      "side": "RIGHT",
      "diff_hunk": "@@ -1979,31 +1980,32 @@ def test_cache_multiple_files(self) -> None:\n             one.write_text(\"print('hello')\", encoding=\"utf-8\")\n             two = (workspace / \"two.py\").resolve()\n             two.write_text(\"print('hello')\", encoding=\"utf-8\")\n-            black.write_cache({}, [one], mode)\n+            cache = black.Cache.read(mode)\n+            cache.write([one])\n             invokeBlack([str(workspace)])\n             assert one.read_text(encoding=\"utf-8\") == \"print('hello')\"\n             assert two.read_text(encoding=\"utf-8\") == 'print(\"hello\")\\n'\n-            cache = black.read_cache(mode)\n-            assert str(one) in cache\n-            assert str(two) in cache\n+            cache = black.Cache.read(mode)\n+            assert not cache.is_changed(one)\n+            assert not cache.is_changed(two)\n \n     @pytest.mark.parametrize(\"color\", [False, True], ids=[\"no-color\", \"with-color\"])\n     def test_no_cache_when_writeback_diff(self, color: bool) -> None:\n         mode = DEFAULT_MODE\n         with cache_dir() as workspace:\n             src = (workspace / \"test.py\").resolve()\n             src.write_text(\"print('hello')\", encoding=\"utf-8\")\n-            with patch(\"black.read_cache\") as read_cache, patch(\n-                \"black.write_cache\"\n+            with patch.object(black.Cache, \"read\") as read_cache, patch.object(\n+                black.Cache, \"write\"\n             ) as write_cache:\n                 cmd = [str(src), \"--diff\"]\n                 if color:\n                     cmd.append(\"--color\")\n                 invokeBlack(cmd)\n                 cache_file = get_cache_file(mode)\n                 assert cache_file.exists() is False\n+                read_cache.assert_called_once()",
      "comment": "This is a change in behaviour from eagerly reading the cache. Doesn't seem like a big deal",
      "comment_id": 1294274095,
      "user": "hauntsaninja",
      "created_at": "2023-08-15T07:25:11Z",
      "url": "https://github.com/psf/black/pull/3821#discussion_r1294274095"
    },
    {
      "repo": "psf/black",
      "pr_number": 3821,
      "file_path": "tests/test_black.py",
      "line": 2069,
      "side": "RIGHT",
      "diff_hunk": "@@ -2057,21 +2059,65 @@ def test_filter_cached(self) -> None:\n             uncached.touch()\n             cached.touch()\n             cached_but_changed.touch()\n-            cache = {\n-                str(cached): black.get_cache_info(cached),\n-                str(cached_but_changed): (0.0, 0),\n-            }\n-            todo, done = black.cache.filter_cached(\n-                cache, {uncached, cached, cached_but_changed}\n-            )\n+            cache = black.Cache.read(DEFAULT_MODE)\n+\n+            orig_func = black.Cache.get_file_data\n+\n+            def wrapped_func(path: Path) -> FileData:\n+                if path == cached:\n+                    return orig_func(path)\n+                return FileData(0.0, 0, \"\")",
      "comment": "nit:\r\n```suggestion\r\n                if path == cached_but_changed:\r\n                    return FileData(0.0, 0, \"\")\r\n                raise AssertionError\r\n```",
      "comment_id": 1294274809,
      "user": "hauntsaninja",
      "created_at": "2023-08-15T07:26:08Z",
      "url": "https://github.com/psf/black/pull/3821#discussion_r1294274809"
    },
    {
      "repo": "psf/black",
      "pr_number": 3821,
      "file_path": "tests/test_black.py",
      "line": 2007,
      "side": "RIGHT",
      "diff_hunk": "@@ -1979,31 +1980,32 @@ def test_cache_multiple_files(self) -> None:\n             one.write_text(\"print('hello')\", encoding=\"utf-8\")\n             two = (workspace / \"two.py\").resolve()\n             two.write_text(\"print('hello')\", encoding=\"utf-8\")\n-            black.write_cache({}, [one], mode)\n+            cache = black.Cache.read(mode)\n+            cache.write([one])\n             invokeBlack([str(workspace)])\n             assert one.read_text(encoding=\"utf-8\") == \"print('hello')\"\n             assert two.read_text(encoding=\"utf-8\") == 'print(\"hello\")\\n'\n-            cache = black.read_cache(mode)\n-            assert str(one) in cache\n-            assert str(two) in cache\n+            cache = black.Cache.read(mode)\n+            assert not cache.is_changed(one)\n+            assert not cache.is_changed(two)\n \n     @pytest.mark.parametrize(\"color\", [False, True], ids=[\"no-color\", \"with-color\"])\n     def test_no_cache_when_writeback_diff(self, color: bool) -> None:\n         mode = DEFAULT_MODE\n         with cache_dir() as workspace:\n             src = (workspace / \"test.py\").resolve()\n             src.write_text(\"print('hello')\", encoding=\"utf-8\")\n-            with patch(\"black.read_cache\") as read_cache, patch(\n-                \"black.write_cache\"\n+            with patch.object(black.Cache, \"read\") as read_cache, patch.object(\n+                black.Cache, \"write\"\n             ) as write_cache:\n                 cmd = [str(src), \"--diff\"]\n                 if color:\n                     cmd.append(\"--color\")\n                 invokeBlack(cmd)\n                 cache_file = get_cache_file(mode)\n                 assert cache_file.exists() is False\n+                read_cache.assert_called_once()",
      "comment": "Yeah, this was a result of initializing the cache with `cache = Cache.read(mode)`.  Technically it did one unnecessary read in some cases.\r\n\r\nChanging it wasn't too difficult. I just pushed 85b4a91c1b9dc70cb53af2dc37c9eaf4b985e453 to delay the cache read.",
      "comment_id": 1294300828,
      "user": "cdce8p",
      "created_at": "2023-08-15T07:59:51Z",
      "url": "https://github.com/psf/black/pull/3821#discussion_r1294300828"
    },
    {
      "repo": "psf/black",
      "pr_number": 3821,
      "file_path": "src/black/cache.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,61 +44,93 @@ def get_cache_dir() -> Path:\n CACHE_DIR = get_cache_dir()\n \n \n-def read_cache(mode: Mode) -> Cache:\n-    \"\"\"Read the cache if it exists and is well formed.\n-\n-    If it is not well formed, the call to write_cache later should resolve the issue.\n-    \"\"\"\n-    cache_file = get_cache_file(mode)\n-    if not cache_file.exists():\n-        return {}\n-\n-    with cache_file.open(\"rb\") as fobj:\n-        try:\n-            cache: Cache = pickle.load(fobj)\n-        except (pickle.UnpicklingError, ValueError, IndexError):\n-            return {}\n-\n-    return cache\n-\n-\n def get_cache_file(mode: Mode) -> Path:\n     return CACHE_DIR / f\"cache.{mode.get_cache_key()}.pickle\"\n \n \n-def get_cache_info(path: Path) -> CacheInfo:\n-    \"\"\"Return the information used to check if a file is already formatted or not.\"\"\"\n-    stat = path.stat()\n-    return stat.st_mtime, stat.st_size\n-\n-\n-def filter_cached(cache: Cache, sources: Iterable[Path]) -> Tuple[Set[Path], Set[Path]]:\n-    \"\"\"Split an iterable of paths in `sources` into two sets.\n-\n-    The first contains paths of files that modified on disk or are not in the\n-    cache. The other contains paths to non-modified files.\n-    \"\"\"\n-    todo, done = set(), set()\n-    for src in sources:\n-        res_src = src.resolve()\n-        if cache.get(str(res_src)) != get_cache_info(res_src):\n-            todo.add(src)\n-        else:\n-            done.add(src)\n-    return todo, done\n-\n-\n-def write_cache(cache: Cache, sources: Iterable[Path], mode: Mode) -> None:\n-    \"\"\"Update the cache file.\"\"\"\n-    cache_file = get_cache_file(mode)\n-    try:\n-        CACHE_DIR.mkdir(parents=True, exist_ok=True)\n-        new_cache = {\n-            **cache,\n-            **{str(src.resolve()): get_cache_info(src) for src in sources},\n-        }\n-        with tempfile.NamedTemporaryFile(dir=str(cache_file.parent), delete=False) as f:\n-            pickle.dump(new_cache, f, protocol=4)\n-        os.replace(f.name, cache_file)\n-    except OSError:\n-        pass\n+@dataclass\n+class Cache:\n+    mode: Mode\n+    cache_file: Path\n+    file_data: Dict[str, FileData] = field(default_factory=dict)\n+\n+    @classmethod\n+    def read(cls, mode: Mode) -> Self:\n+        \"\"\"Read the cache if it exists and is well formed.\n+\n+        If it is not well formed, the call to write later should\n+        resolve the issue.\n+        \"\"\"\n+        cache_file = get_cache_file(mode)\n+        if not cache_file.exists():\n+            return cls(mode, cache_file)\n+\n+        with cache_file.open(\"rb\") as fobj:\n+            try:\n+                file_data: Dict[str, FileData] = pickle.load(fobj)\n+            except (pickle.UnpicklingError, ValueError, IndexError):\n+                return cls(mode, cache_file)\n+\n+        return cls(mode, cache_file, file_data)\n+\n+    @staticmethod\n+    def hash_digest(path: Path) -> str:\n+        \"\"\"Return hash digest for path.\"\"\"\n+\n+        with open(path, \"rb\") as fp:\n+            data = fp.read()",
      "comment": "```suggestion\r\n        data = path.read_bytes()\r\n```",
      "comment_id": 1298853835,
      "user": "JelleZijlstra",
      "created_at": "2023-08-18T20:46:18Z",
      "url": "https://github.com/psf/black/pull/3821#discussion_r1298853835"
    },
    {
      "repo": "psf/black",
      "pr_number": 3821,
      "file_path": "src/black/cache.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,61 +44,93 @@ def get_cache_dir() -> Path:\n CACHE_DIR = get_cache_dir()\n \n \n-def read_cache(mode: Mode) -> Cache:\n-    \"\"\"Read the cache if it exists and is well formed.\n-\n-    If it is not well formed, the call to write_cache later should resolve the issue.\n-    \"\"\"\n-    cache_file = get_cache_file(mode)\n-    if not cache_file.exists():\n-        return {}\n-\n-    with cache_file.open(\"rb\") as fobj:\n-        try:\n-            cache: Cache = pickle.load(fobj)\n-        except (pickle.UnpicklingError, ValueError, IndexError):\n-            return {}\n-\n-    return cache\n-\n-\n def get_cache_file(mode: Mode) -> Path:\n     return CACHE_DIR / f\"cache.{mode.get_cache_key()}.pickle\"\n \n \n-def get_cache_info(path: Path) -> CacheInfo:\n-    \"\"\"Return the information used to check if a file is already formatted or not.\"\"\"\n-    stat = path.stat()\n-    return stat.st_mtime, stat.st_size\n-\n-\n-def filter_cached(cache: Cache, sources: Iterable[Path]) -> Tuple[Set[Path], Set[Path]]:\n-    \"\"\"Split an iterable of paths in `sources` into two sets.\n-\n-    The first contains paths of files that modified on disk or are not in the\n-    cache. The other contains paths to non-modified files.\n-    \"\"\"\n-    todo, done = set(), set()\n-    for src in sources:\n-        res_src = src.resolve()\n-        if cache.get(str(res_src)) != get_cache_info(res_src):\n-            todo.add(src)\n-        else:\n-            done.add(src)\n-    return todo, done\n-\n-\n-def write_cache(cache: Cache, sources: Iterable[Path], mode: Mode) -> None:\n-    \"\"\"Update the cache file.\"\"\"\n-    cache_file = get_cache_file(mode)\n-    try:\n-        CACHE_DIR.mkdir(parents=True, exist_ok=True)\n-        new_cache = {\n-            **cache,\n-            **{str(src.resolve()): get_cache_info(src) for src in sources},\n-        }\n-        with tempfile.NamedTemporaryFile(dir=str(cache_file.parent), delete=False) as f:\n-            pickle.dump(new_cache, f, protocol=4)\n-        os.replace(f.name, cache_file)\n-    except OSError:\n-        pass\n+@dataclass\n+class Cache:\n+    mode: Mode\n+    cache_file: Path\n+    file_data: Dict[str, FileData] = field(default_factory=dict)\n+\n+    @classmethod\n+    def read(cls, mode: Mode) -> Self:\n+        \"\"\"Read the cache if it exists and is well formed.\n+\n+        If it is not well formed, the call to write later should\n+        resolve the issue.\n+        \"\"\"\n+        cache_file = get_cache_file(mode)\n+        if not cache_file.exists():\n+            return cls(mode, cache_file)\n+\n+        with cache_file.open(\"rb\") as fobj:\n+            try:\n+                file_data: Dict[str, FileData] = pickle.load(fobj)\n+            except (pickle.UnpicklingError, ValueError, IndexError):\n+                return cls(mode, cache_file)\n+\n+        return cls(mode, cache_file, file_data)\n+\n+    @staticmethod\n+    def hash_digest(path: Path) -> str:\n+        \"\"\"Return hash digest for path.\"\"\"\n+\n+        with open(path, \"rb\") as fp:\n+            data = fp.read()\n+        return hashlib.sha256(data).hexdigest()\n+\n+    @staticmethod\n+    def get_file_data(path: Path) -> FileData:",
      "comment": "Why not a global function? staticmethods often feel a bit useless.",
      "comment_id": 1298854710,
      "user": "JelleZijlstra",
      "created_at": "2023-08-18T20:47:43Z",
      "url": "https://github.com/psf/black/pull/3821#discussion_r1298854710"
    },
    {
      "repo": "psf/black",
      "pr_number": 3821,
      "file_path": "src/black/cache.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,61 +44,93 @@ def get_cache_dir() -> Path:\n CACHE_DIR = get_cache_dir()\n \n \n-def read_cache(mode: Mode) -> Cache:\n-    \"\"\"Read the cache if it exists and is well formed.\n-\n-    If it is not well formed, the call to write_cache later should resolve the issue.\n-    \"\"\"\n-    cache_file = get_cache_file(mode)\n-    if not cache_file.exists():\n-        return {}\n-\n-    with cache_file.open(\"rb\") as fobj:\n-        try:\n-            cache: Cache = pickle.load(fobj)\n-        except (pickle.UnpicklingError, ValueError, IndexError):\n-            return {}\n-\n-    return cache\n-\n-\n def get_cache_file(mode: Mode) -> Path:\n     return CACHE_DIR / f\"cache.{mode.get_cache_key()}.pickle\"\n \n \n-def get_cache_info(path: Path) -> CacheInfo:\n-    \"\"\"Return the information used to check if a file is already formatted or not.\"\"\"\n-    stat = path.stat()\n-    return stat.st_mtime, stat.st_size\n-\n-\n-def filter_cached(cache: Cache, sources: Iterable[Path]) -> Tuple[Set[Path], Set[Path]]:\n-    \"\"\"Split an iterable of paths in `sources` into two sets.\n-\n-    The first contains paths of files that modified on disk or are not in the\n-    cache. The other contains paths to non-modified files.\n-    \"\"\"\n-    todo, done = set(), set()\n-    for src in sources:\n-        res_src = src.resolve()\n-        if cache.get(str(res_src)) != get_cache_info(res_src):\n-            todo.add(src)\n-        else:\n-            done.add(src)\n-    return todo, done\n-\n-\n-def write_cache(cache: Cache, sources: Iterable[Path], mode: Mode) -> None:\n-    \"\"\"Update the cache file.\"\"\"\n-    cache_file = get_cache_file(mode)\n-    try:\n-        CACHE_DIR.mkdir(parents=True, exist_ok=True)\n-        new_cache = {\n-            **cache,\n-            **{str(src.resolve()): get_cache_info(src) for src in sources},\n-        }\n-        with tempfile.NamedTemporaryFile(dir=str(cache_file.parent), delete=False) as f:\n-            pickle.dump(new_cache, f, protocol=4)\n-        os.replace(f.name, cache_file)\n-    except OSError:\n-        pass\n+@dataclass\n+class Cache:\n+    mode: Mode\n+    cache_file: Path\n+    file_data: Dict[str, FileData] = field(default_factory=dict)\n+\n+    @classmethod\n+    def read(cls, mode: Mode) -> Self:\n+        \"\"\"Read the cache if it exists and is well formed.\n+\n+        If it is not well formed, the call to write later should\n+        resolve the issue.\n+        \"\"\"\n+        cache_file = get_cache_file(mode)\n+        if not cache_file.exists():\n+            return cls(mode, cache_file)\n+\n+        with cache_file.open(\"rb\") as fobj:\n+            try:\n+                file_data: Dict[str, FileData] = pickle.load(fobj)\n+            except (pickle.UnpicklingError, ValueError, IndexError):\n+                return cls(mode, cache_file)\n+\n+        return cls(mode, cache_file, file_data)\n+\n+    @staticmethod\n+    def hash_digest(path: Path) -> str:\n+        \"\"\"Return hash digest for path.\"\"\"\n+\n+        with open(path, \"rb\") as fp:\n+            data = fp.read()\n+        return hashlib.sha256(data).hexdigest()\n+\n+    @staticmethod\n+    def get_file_data(path: Path) -> FileData:",
      "comment": "I like it here as it helps to group these methods nicely. Obviously personal preference. Though, if you want me to change it, I can do that too.",
      "comment_id": 1298966295,
      "user": "cdce8p",
      "created_at": "2023-08-19T00:38:28Z",
      "url": "https://github.com/psf/black/pull/3821#discussion_r1298966295"
    },
    {
      "repo": "psf/black",
      "pr_number": 3558,
      "file_path": "src/blackd/__init__.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,11 +146,13 @@ async def handle(request: web.Request, executor: Executor) -> web.Response:\n         )\n \n         # Preserve CRLF line endings\n-        if req_str[req_str.find(\"\\n\") - 1] == \"\\r\":\n+        nl = req_str.find(\"\\n\")\n+        if nl > 0 and req_str[nl - 1] == \"\\r\":\n             formatted_str = formatted_str.replace(\"\\n\", \"\\r\\n\")\n             # If, after swapping line endings, nothing changed, then say so\n             if formatted_str == req_str:\n                 raise black.NothingChanged\n+        del nl",
      "comment": "This is a bit of a premature optimisation, isn't it? ",
      "comment_id": 1102426789,
      "user": "zsol",
      "created_at": "2023-02-10T08:26:12Z",
      "url": "https://github.com/psf/black/pull/3558#discussion_r1102426789"
    },
    {
      "repo": "psf/black",
      "pr_number": 3558,
      "file_path": "src/blackd/__init__.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,11 +146,13 @@ async def handle(request: web.Request, executor: Executor) -> web.Response:\n         )\n \n         # Preserve CRLF line endings\n-        if req_str[req_str.find(\"\\n\") - 1] == \"\\r\":\n+        nl = req_str.find(\"\\n\")\n+        if nl > 0 and req_str[nl - 1] == \"\\r\":\n             formatted_str = formatted_str.replace(\"\\n\", \"\\r\\n\")\n             # If, after swapping line endings, nothing changed, then say so\n             if formatted_str == req_str:\n                 raise black.NothingChanged\n+        del nl",
      "comment": "Oh okay, I was just deleting it so there wasn't random variables floating around, I'll remove it.",
      "comment_id": 1102434608,
      "user": "KotlinIsland",
      "created_at": "2023-02-10T08:34:31Z",
      "url": "https://github.com/psf/black/pull/3558#discussion_r1102434608"
    },
    {
      "repo": "psf/black",
      "pr_number": 3796,
      "file_path": "src/black/lines.py",
      "line": 733,
      "side": "RIGHT",
      "diff_hunk": "@@ -714,7 +725,14 @@ def _maybe_empty_lines_for_class_or_def(\n             else:\n                 newlines = 0\n         else:\n-            newlines = 1 if current_line.depth else 2\n+            if (\n+                Preview.dummy_implementations in self.mode\n+                and self.previous_line.is_stub_def\n+                and (current_line.is_stub_def or current_line.is_decorator)\n+            ):\n+                newlines = user_hint_before",
      "comment": "This is perhaps controversial, but it allows users to group things as they want (e.g. in the test case, dummy and other are grouped separately) and solves some lookahead problems when dealing with decorators",
      "comment_id": 1271341873,
      "user": "hauntsaninja",
      "created_at": "2023-07-22T20:52:41Z",
      "url": "https://github.com/psf/black/pull/3796#discussion_r1271341873"
    },
    {
      "repo": "psf/black",
      "pr_number": 3796,
      "file_path": "src/black/lines.py",
      "line": 589,
      "side": "RIGHT",
      "diff_hunk": "@@ -578,6 +585,8 @@ def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n             first_leaf.prefix = \"\"\n         else:\n             before = 0\n+\n+        user_hint_before = before",
      "comment": "(Note that this has already been min-ed with max_allowed)",
      "comment_id": 1271342210,
      "user": "hauntsaninja",
      "created_at": "2023-07-22T20:56:41Z",
      "url": "https://github.com/psf/black/pull/3796#discussion_r1271342210"
    },
    {
      "repo": "psf/black",
      "pr_number": 3796,
      "file_path": "src/black/lines.py",
      "line": 171,
      "side": "RIGHT",
      "diff_hunk": "@@ -165,6 +165,13 @@ def is_def(self) -> bool:\n             and second_leaf.value == \"def\"\n         )\n \n+    @property\n+    def is_stub_def(self) -> bool:\n+        \"\"\"Is this line a function definition with a body consisting only of \"...\"?\"\"\"\n+        return self.is_def and self.leaves[-3:] == [",
      "comment": "Doesn't this also match something like `def f(x): y = ...`?",
      "comment_id": 1271364012,
      "user": "JelleZijlstra",
      "created_at": "2023-07-23T00:37:22Z",
      "url": "https://github.com/psf/black/pull/3796#discussion_r1271364012"
    },
    {
      "repo": "psf/black",
      "pr_number": 3796,
      "file_path": "tests/data/preview/dummy_implementations.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,71 @@\n+from typing import NoReturn, Protocol, Union, overload\n+\n+\n+def dummy(a): ...\n+def other(b): ...\n+\n+\n+@overload\n+def a(arg: int) -> int: ...\n+@overload",
      "comment": "Add a test where there are blank lines between overloads in the input.",
      "comment_id": 1271364116,
      "user": "JelleZijlstra",
      "created_at": "2023-07-23T00:38:43Z",
      "url": "https://github.com/psf/black/pull/3796#discussion_r1271364116"
    },
    {
      "repo": "psf/black",
      "pr_number": 3796,
      "file_path": "src/black/lines.py",
      "line": 171,
      "side": "RIGHT",
      "diff_hunk": "@@ -165,6 +165,13 @@ def is_def(self) -> bool:\n             and second_leaf.value == \"def\"\n         )\n \n+    @property\n+    def is_stub_def(self) -> bool:\n+        \"\"\"Is this line a function definition with a body consisting only of \"...\"?\"\"\"\n+        return self.is_def and self.leaves[-3:] == [",
      "comment": "Yes, this is true (and true for the is `is_stub_class` heuristic above as well). I've made the heuristic slightly better by including the colon. I didn't see anything adverse in the diff shades output.\r\n\r\nAlso note some of the pyi code we now use in linegen.py will trigger in some cases involving other statements, although it's not unreasonable when it happens.",
      "comment_id": 1271371026,
      "user": "hauntsaninja",
      "created_at": "2023-07-23T02:24:21Z",
      "url": "https://github.com/psf/black/pull/3796#discussion_r1271371026"
    },
    {
      "repo": "psf/black",
      "pr_number": 3759,
      "file_path": "action/main.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,5 +74,6 @@\n         stderr=STDOUT,\n         encoding=\"utf-8\",\n     )\n+shutil.rmtree(ENV_PATH)",
      "comment": "Is it worth passing `ignore_errors=True` to this call? An error is unlikely, but it also shouldn't fail the entire action IMO.",
      "comment_id": 1266000018,
      "user": "ichard26",
      "created_at": "2023-07-17T23:21:37Z",
      "url": "https://github.com/psf/black/pull/3759#discussion_r1266000018"
    },
    {
      "repo": "psf/black",
      "pr_number": 3759,
      "file_path": "action/main.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,5 +74,6 @@\n         stderr=STDOUT,\n         encoding=\"utf-8\",\n     )\n+shutil.rmtree(ENV_PATH)",
      "comment": "I agree, I think an error is unlikely but yeah shouldn't fail the entire action.",
      "comment_id": 1267434992,
      "user": "cjproud",
      "created_at": "2023-07-19T01:19:19Z",
      "url": "https://github.com/psf/black/pull/3759#discussion_r1267434992"
    },
    {
      "repo": "psf/black",
      "pr_number": 3797,
      "file_path": "src/black/lines.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,7 +49,7 @@\n class Line:\n     \"\"\"Holds leaves and comments. Can be printed with `str(line)`.\"\"\"\n \n-    mode: Mode\n+    mode: Mode = field(repr=False)",
      "comment": "This makes debugging much less verbose; plenty of other opportunities to see what the mode is.",
      "comment_id": 1264988716,
      "user": "hauntsaninja",
      "created_at": "2023-07-17T07:44:56Z",
      "url": "https://github.com/psf/black/pull/3797#discussion_r1264988716"
    },
    {
      "repo": "psf/black",
      "pr_number": 3745,
      "file_path": "tests/data/simple_cases/ignore_pyi.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,41 @@\n+def f():  # type: ignore\n+    ...\n+\n+class x:  # some comment\n+    ...\n+\n+class y:\n+    ...  # comment\n+\n+# whitespace doesn't matter (note the next line has a trailing space and tab)\n+class z:        \n+    ...\n+\n+def g():\n+    # hi\n+    ...\n+\n+def h():\n+    ...\n+    # bye\n+\n+# output\n+\n+def f():  # type: ignore\n+    ...\n+\n+class x:  # some comment\n+    ...\n+\n+class y: ...  # comment\n+\n+# whitespace doesn't matter (note the next line has a trailing space and tab)\n+class z: ...\n+\n+def g():\n+    # hi\n+    ...\n+\n+def h():\n+    ...\n+    # bye",
      "comment": "Arguably we could turn this into `def h(): ...  # bye`, but that's more complicated to implement and if the user put it on a separate line, we might as well keep it there.",
      "comment_id": 1239310658,
      "user": "JelleZijlstra",
      "created_at": "2023-06-23T04:34:40Z",
      "url": "https://github.com/psf/black/pull/3745#discussion_r1239310658"
    },
    {
      "repo": "psf/black",
      "pr_number": 3773,
      "file_path": "src/black/parsing.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -208,15 +208,18 @@ def stringify_ast(node: ast.AST, depth: int = 0) -> Iterator[str]:\n \n         else:\n             normalized: object\n-            # Constant strings may be indented across newlines, if they are\n-            # docstrings; fold spaces after newlines when comparing. Similarly,\n-            # trailing and leading space may be removed.\n             if (\n                 isinstance(node, ast.Constant)\n                 and field == \"value\"\n                 and isinstance(value, str)\n             ):\n+                # Constant strings may be indented across newlines, if they are\n+                # docstrings; fold spaces after newlines when comparing. Similarly,\n+                # trailing and leading space may be removed.\n                 normalized = _normalize(\"\\n\", value)\n+            elif field == \"type_comment\" and isinstance(value, str):\n+                # Trailing spaces in type comments are removed.",
      "comment": "Interesting that we apparently do not remove trailing tabs, only spaces. That might be a bug?\r\n\r\nIn any case, this change looks good, thanks!",
      "comment_id": 1257558777,
      "user": "JelleZijlstra",
      "created_at": "2023-07-09T22:41:19Z",
      "url": "https://github.com/psf/black/pull/3773#discussion_r1257558777"
    },
    {
      "repo": "psf/black",
      "pr_number": 3773,
      "file_path": "src/black/parsing.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -208,15 +208,18 @@ def stringify_ast(node: ast.AST, depth: int = 0) -> Iterator[str]:\n \n         else:\n             normalized: object\n-            # Constant strings may be indented across newlines, if they are\n-            # docstrings; fold spaces after newlines when comparing. Similarly,\n-            # trailing and leading space may be removed.\n             if (\n                 isinstance(node, ast.Constant)\n                 and field == \"value\"\n                 and isinstance(value, str)\n             ):\n+                # Constant strings may be indented across newlines, if they are\n+                # docstrings; fold spaces after newlines when comparing. Similarly,\n+                # trailing and leading space may be removed.\n                 normalized = _normalize(\"\\n\", value)\n+            elif field == \"type_comment\" and isinstance(value, str):\n+                # Trailing spaces in type comments are removed.",
      "comment": "Oh, we do remove tabs. Sorry, I forgot those exist.",
      "comment_id": 1257561231,
      "user": "hauntsaninja",
      "created_at": "2023-07-09T22:47:02Z",
      "url": "https://github.com/psf/black/pull/3773#discussion_r1257561231"
    },
    {
      "repo": "psf/black",
      "pr_number": 3773,
      "file_path": "src/black/parsing.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -208,15 +208,18 @@ def stringify_ast(node: ast.AST, depth: int = 0) -> Iterator[str]:\n \n         else:\n             normalized: object\n-            # Constant strings may be indented across newlines, if they are\n-            # docstrings; fold spaces after newlines when comparing. Similarly,\n-            # trailing and leading space may be removed.\n             if (\n                 isinstance(node, ast.Constant)\n                 and field == \"value\"\n                 and isinstance(value, str)\n             ):\n+                # Constant strings may be indented across newlines, if they are\n+                # docstrings; fold spaces after newlines when comparing. Similarly,\n+                # trailing and leading space may be removed.\n                 normalized = _normalize(\"\\n\", value)\n+            elif field == \"type_comment\" and isinstance(value, str):\n+                # Trailing spaces in type comments are removed.",
      "comment": "To be clear we actually *don't* strip trailing tabs:\r\n\r\n```\r\n(py311) jelle@m2mb-jelle black % black -c \"x = int # type: int\\t\"     \r\nx = int  # type: int\\t\r\n(py311) jelle@m2mb-jelle black % black -c \"x = int # type: int   \"\r\nx = int # type: int   \r\nerror: cannot format <string>: INTERNAL ERROR: Black produced code that is not equivalent to the source.  Please report a bug on https://github.com/psf/black/issues.  This diff might be helpful: /var/folders/hh/hdb5qd2x3v51v6l0gknpfjfr0000gp/T/blk_7xu6fnsp.log\r\n```",
      "comment_id": 1257561292,
      "user": "JelleZijlstra",
      "created_at": "2023-07-09T22:47:09Z",
      "url": "https://github.com/psf/black/pull/3773#discussion_r1257561292"
    },
    {
      "repo": "psf/black",
      "pr_number": 3773,
      "file_path": "src/black/parsing.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -208,15 +208,18 @@ def stringify_ast(node: ast.AST, depth: int = 0) -> Iterator[str]:\n \n         else:\n             normalized: object\n-            # Constant strings may be indented across newlines, if they are\n-            # docstrings; fold spaces after newlines when comparing. Similarly,\n-            # trailing and leading space may be removed.\n             if (\n                 isinstance(node, ast.Constant)\n                 and field == \"value\"\n                 and isinstance(value, str)\n             ):\n+                # Constant strings may be indented across newlines, if they are\n+                # docstrings; fold spaces after newlines when comparing. Similarly,\n+                # trailing and leading space may be removed.\n                 normalized = _normalize(\"\\n\", value)\n+            elif field == \"type_comment\" and isinstance(value, str):\n+                # Trailing spaces in type comments are removed.",
      "comment": "Oh wait, that's not actually a tab, is it? Just a \\t in the comment.",
      "comment_id": 1257561423,
      "user": "JelleZijlstra",
      "created_at": "2023-07-09T22:47:31Z",
      "url": "https://github.com/psf/black/pull/3773#discussion_r1257561423"
    },
    {
      "repo": "psf/black",
      "pr_number": 3773,
      "file_path": "src/black/parsing.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -208,15 +208,18 @@ def stringify_ast(node: ast.AST, depth: int = 0) -> Iterator[str]:\n \n         else:\n             normalized: object\n-            # Constant strings may be indented across newlines, if they are\n-            # docstrings; fold spaces after newlines when comparing. Similarly,\n-            # trailing and leading space may be removed.\n             if (\n                 isinstance(node, ast.Constant)\n                 and field == \"value\"\n                 and isinstance(value, str)\n             ):\n+                # Constant strings may be indented across newlines, if they are\n+                # docstrings; fold spaces after newlines when comparing. Similarly,\n+                # trailing and leading space may be removed.\n                 normalized = _normalize(\"\\n\", value)\n+            elif field == \"type_comment\" and isinstance(value, str):\n+                # Trailing spaces in type comments are removed.",
      "comment": "Yeah, that's not a tab. `black -c $'x = int # type: int\\t'`",
      "comment_id": 1257561569,
      "user": "hauntsaninja",
      "created_at": "2023-07-09T22:48:55Z",
      "url": "https://github.com/psf/black/pull/3773#discussion_r1257561569"
    },
    {
      "repo": "psf/black",
      "pr_number": 3751,
      "file_path": "src/black/files.py",
      "line": 286,
      "side": "RIGHT",
      "diff_hunk": "@@ -276,15 +276,24 @@ def normalize_path_maybe_ignore(\n     return root_relative_path\n \n \n-def path_is_ignored(\n-    path: Path, gitignore_dict: Dict[Path, PathSpec], report: Report\n+def _path_is_ignored(\n+    root_relative_path: str,\n+    root: Path,\n+    gitignore_dict: Dict[Path, PathSpec],\n+    report: Report,\n ) -> bool:\n+    path = root / root_relative_path\n+    # Note that this logic is sensitive to the ordering of gitignore_dict. Callers must",
      "comment": "Is it? Looks like we check all entries either way.",
      "comment_id": 1241206081,
      "user": "JelleZijlstra",
      "created_at": "2023-06-25T14:27:45Z",
      "url": "https://github.com/psf/black/pull/3751#discussion_r1241206081"
    },
    {
      "repo": "psf/black",
      "pr_number": 3751,
      "file_path": "src/black/files.py",
      "line": 286,
      "side": "RIGHT",
      "diff_hunk": "@@ -276,15 +276,24 @@ def normalize_path_maybe_ignore(\n     return root_relative_path\n \n \n-def path_is_ignored(\n-    path: Path, gitignore_dict: Dict[Path, PathSpec], report: Report\n+def _path_is_ignored(\n+    root_relative_path: str,\n+    root: Path,\n+    gitignore_dict: Dict[Path, PathSpec],\n+    report: Report,\n ) -> bool:\n+    path = root / root_relative_path\n+    # Note that this logic is sensitive to the ordering of gitignore_dict. Callers must",
      "comment": "I might be being really dumb, but I think it is, because of the break on L285 / L292. You can hit that in the case of symlinks.\r\n\r\nI also think it's maybe a little questionable to be applying gitignore to the resolved file rather than the symlink when formatting the symlink (e.g. a gitignored symlink can now affect what gets formatted), but whatever.",
      "comment_id": 1241280644,
      "user": "hauntsaninja",
      "created_at": "2023-06-25T20:20:39Z",
      "url": "https://github.com/psf/black/pull/3751#discussion_r1241280644"
    },
    {
      "repo": "psf/black",
      "pr_number": 3751,
      "file_path": "src/black/files.py",
      "line": 286,
      "side": "RIGHT",
      "diff_hunk": "@@ -276,15 +276,24 @@ def normalize_path_maybe_ignore(\n     return root_relative_path\n \n \n-def path_is_ignored(\n-    path: Path, gitignore_dict: Dict[Path, PathSpec], report: Report\n+def _path_is_ignored(\n+    root_relative_path: str,\n+    root: Path,\n+    gitignore_dict: Dict[Path, PathSpec],\n+    report: Report,\n ) -> bool:\n+    path = root / root_relative_path\n+    # Note that this logic is sensitive to the ordering of gitignore_dict. Callers must",
      "comment": "OK I stared at the code some more and this does make sense now. (I thought it mattered only for broken symlinks, but that's not the case.)\r\n\r\nWe pass a dict here that gets built separately for every directory, since we look for `.gitignore` in every directory, so given a directory structure `root/a/b/c.py`, the dict will contain `root/.gitignore`, `root/a/.gitignore`, `root/a/b/.gitignore` in that order. The `break` happens for the first path where the symlink points outside the directory, so it makes sense to ignore all subsequent gitignores as they definitely won't match either.\r\n\r\nAgree that it probably makes more sense to apply gitignore *before* resolving symlinks, but that's something do in a separate PR.",
      "comment_id": 1257552324,
      "user": "JelleZijlstra",
      "created_at": "2023-07-09T22:22:57Z",
      "url": "https://github.com/psf/black/pull/3751#discussion_r1257552324"
    },
    {
      "repo": "psf/black",
      "pr_number": 3740,
      "file_path": "src/black/linegen.py",
      "line": 1406,
      "side": "RIGHT",
      "diff_hunk": "@@ -1399,8 +1399,14 @@ def maybe_make_parens_invisible_in_atom(\n     if is_lpar_token(first) and is_rpar_token(last):\n         middle = node.children[1]\n         # make parentheses invisible\n-        first.value = \"\"\n-        last.value = \"\"\n+        if (\n+            not node.children[1]\n+            .prefix.strip()\n+            .replace(\" \", \"\")\n+            .startswith(\"#type:ignore\")",
      "comment": "Umm I don't think I can directly replace code here with the `is_type_comment()` function, as the function expect a `leaf` as input and check on its `value` field, while here the comment is as a `node`'s prefix (node.children[1] is still a node), I tried to find some existing function to convert this prefix string into a `leaf`, but I haven't found one yet...  Any further guidance would be really helpful!",
      "comment_id": 1238067858,
      "user": "rdrll",
      "created_at": "2023-06-22T06:43:02Z",
      "url": "https://github.com/psf/black/pull/3740#discussion_r1238067858"
    },
    {
      "repo": "psf/black",
      "pr_number": 3740,
      "file_path": "src/black/linegen.py",
      "line": 1406,
      "side": "RIGHT",
      "diff_hunk": "@@ -1399,8 +1399,14 @@ def maybe_make_parens_invisible_in_atom(\n     if is_lpar_token(first) and is_rpar_token(last):\n         middle = node.children[1]\n         # make parentheses invisible\n-        first.value = \"\"\n-        last.value = \"\"\n+        if (\n+            not node.children[1]\n+            .prefix.strip()\n+            .replace(\" \", \"\")\n+            .startswith(\"#type:ignore\")",
      "comment": "That's true, the interface doesn't apply. However, there is also a difference in behavior: the other function specifically looks for `# type: ignore`, but this one also allows `# type:ignore`. Mypy allows both so I think your solution is better, but we should be consistent (see also #2501 which asks us to format type-ignore comments).\r\n\r\nI think we should:\r\n- Add a new function, say `is_type_ignore_comment_string`, that takes a `str` and returns whether it's a type ignore comment. It should ignore whitespace.\r\n- Split `is_type_comment()` into `is_type_comment()` and `is_type_ignore_comment()`\r\n- Use `is_type_ignore_comment_string()` both here and from `is_type_ignore_comment()`.",
      "comment_id": 1239290798,
      "user": "JelleZijlstra",
      "created_at": "2023-06-23T03:45:53Z",
      "url": "https://github.com/psf/black/pull/3740#discussion_r1239290798"
    },
    {
      "repo": "psf/black",
      "pr_number": 3740,
      "file_path": "src/black/linegen.py",
      "line": 1403,
      "side": "RIGHT",
      "diff_hunk": "@@ -1399,8 +1399,14 @@ def maybe_make_parens_invisible_in_atom(\n     if is_lpar_token(first) and is_rpar_token(last):\n         middle = node.children[1]\n         # make parentheses invisible\n-        first.value = \"\"\n-        last.value = \"\"\n+        if (\n+            not node.children[1]",
      "comment": "```suggestion\r\n            not middle\r\n```\r\nUse the existing variable",
      "comment_id": 1239290905,
      "user": "JelleZijlstra",
      "created_at": "2023-06-23T03:46:09Z",
      "url": "https://github.com/psf/black/pull/3740#discussion_r1239290905"
    },
    {
      "repo": "psf/black",
      "pr_number": 3740,
      "file_path": "src/black/linegen.py",
      "line": 1406,
      "side": "RIGHT",
      "diff_hunk": "@@ -1399,8 +1399,14 @@ def maybe_make_parens_invisible_in_atom(\n     if is_lpar_token(first) and is_rpar_token(last):\n         middle = node.children[1]\n         # make parentheses invisible\n-        first.value = \"\"\n-        last.value = \"\"\n+        if (\n+            not node.children[1]\n+            .prefix.strip()\n+            .replace(\" \", \"\")\n+            .startswith(\"#type:ignore\")",
      "comment": "We also discussed this in #3339. I think for now let's not worry about `type:ignore` without the space and handle only `# type: ignore` with a space. We can figure out how to deal with the spacing issue in the other PR.",
      "comment_id": 1239306744,
      "user": "JelleZijlstra",
      "created_at": "2023-06-23T04:25:07Z",
      "url": "https://github.com/psf/black/pull/3740#discussion_r1239306744"
    },
    {
      "repo": "psf/black",
      "pr_number": 3740,
      "file_path": "src/black/linegen.py",
      "line": 1406,
      "side": "RIGHT",
      "diff_hunk": "@@ -1399,8 +1399,14 @@ def maybe_make_parens_invisible_in_atom(\n     if is_lpar_token(first) and is_rpar_token(last):\n         middle = node.children[1]\n         # make parentheses invisible\n-        first.value = \"\"\n-        last.value = \"\"\n+        if (\n+            not node.children[1]\n+            .prefix.strip()\n+            .replace(\" \", \"\")\n+            .startswith(\"#type:ignore\")",
      "comment": "Gotcha! Thanks for the guidance on design! I'll then keep it consistent with the rest part of Black to only handle the with-space case.\r\n\r\nJust to clarify my understanding - when you suggest splitting `is_type_comment()` into `is_type_comment()` and `is_type_ignore_comment()`, does that mean we will be using the original `is_type_comment()` to handle non-ignore type of comments and use the new `is_type_ignore_comment()` to handle ignore-type of comments? (so all current usage of `is_type_comment()` for ignore-type comments will be using the new one instead)\r\n\r\nBtw, I noticed that in #3339, it's been mentioned that the type comment is a deprecated feature, I tried to search for information on this deprecation but couldn't quite find where Python states about this deprecation. I'm wondering if you know if there's a particular PEP doc or other places that states it's a deprecated feature? I think it would also be beneficial to have this discussion documented here for future reference.",
      "comment_id": 1239548151,
      "user": "rdrll",
      "created_at": "2023-06-23T08:48:31Z",
      "url": "https://github.com/psf/black/pull/3740#discussion_r1239548151"
    },
    {
      "repo": "psf/black",
      "pr_number": 3740,
      "file_path": "src/black/linegen.py",
      "line": 1406,
      "side": "RIGHT",
      "diff_hunk": "@@ -1399,8 +1399,14 @@ def maybe_make_parens_invisible_in_atom(\n     if is_lpar_token(first) and is_rpar_token(last):\n         middle = node.children[1]\n         # make parentheses invisible\n-        first.value = \"\"\n-        last.value = \"\"\n+        if (\n+            not node.children[1]\n+            .prefix.strip()\n+            .replace(\" \", \"\")\n+            .startswith(\"#type:ignore\")",
      "comment": "Currently `is_type_comment()` takes a `suffix` argument, which is always passed as either `\"\"` or `\" ignore\"`. Calls that use the former should stay as `is_type_coment()`, and calls that use the latter use `is_type_ignore_comment()`.\r\n\r\nWhat's deprecated-ish is using type comments for type annotations like `x: []  # type: List[str]`. This was a compatibility feature introduced in PEP 484 for compatibility with Python 2 and Python 3.5, but it's not needed in modern versions of Python. Therefore, we're thinking of deprecating mypy support for it: python/mypy#12947. However, `# type: ignore` has no such replacement and it's here to stay.",
      "comment_id": 1239886436,
      "user": "JelleZijlstra",
      "created_at": "2023-06-23T14:24:31Z",
      "url": "https://github.com/psf/black/pull/3740#discussion_r1239886436"
    },
    {
      "repo": "psf/black",
      "pr_number": 3740,
      "file_path": "src/black/linegen.py",
      "line": 1406,
      "side": "RIGHT",
      "diff_hunk": "@@ -1399,8 +1399,14 @@ def maybe_make_parens_invisible_in_atom(\n     if is_lpar_token(first) and is_rpar_token(last):\n         middle = node.children[1]\n         # make parentheses invisible\n-        first.value = \"\"\n-        last.value = \"\"\n+        if (\n+            not node.children[1]\n+            .prefix.strip()\n+            .replace(\" \", \"\")\n+            .startswith(\"#type:ignore\")",
      "comment": "I have updated the code. I also removed the optional string parameter `suffix` in `is_type_coment()`, This parameter was only used to pass in `\"ignore\"`, and since the handling of ignore comments is now done by the new function `is_type_ignore_comment()`, there is no need to keep this parameter. Also, considering that `is_type_comment()` is responsible for handling only general types comments and there are plans to deprecate its support in the future, I added a note to its docstring stating that it might be deprecated in the future.",
      "comment_id": 1240906410,
      "user": "rdrll",
      "created_at": "2023-06-24T17:31:23Z",
      "url": "https://github.com/psf/black/pull/3740#discussion_r1240906410"
    },
    {
      "repo": "psf/black",
      "pr_number": 3748,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,8 +58,11 @@ class Replacement:\n @lru_cache()\n def jupyter_dependencies_are_installed(*, verbose: bool, quiet: bool) -> bool:\n     try:\n-        import IPython  # noqa:F401\n+        # isort: off",
      "comment": "```suggestion\r\n        # tokenize_rt is less commonly installed than IPython, and IPython is expensive to import,\r\n        # so import tokenize_rt first.\r\n        # isort: off\r\n```\r\nSo future readers know why we're doing this",
      "comment_id": 1240965547,
      "user": "JelleZijlstra",
      "created_at": "2023-06-24T23:02:46Z",
      "url": "https://github.com/psf/black/pull/3748#discussion_r1240965547"
    },
    {
      "repo": "psf/black",
      "pr_number": 3749,
      "file_path": "src/black/__init__.py",
      "line": 634,
      "side": "RIGHT",
      "diff_hunk": "@@ -653,7 +633,11 @@ def get_sources(\n         if is_stdin or p.is_file():\n             normalized_path = normalize_path_maybe_ignore(p, ctx.obj[\"root\"], report)",
      "comment": "Seems like the mypyc build is broken here (see the diff-shades output in CI); it infers None for this variable.",
      "comment_id": 1240965743,
      "user": "JelleZijlstra",
      "created_at": "2023-06-24T23:04:48Z",
      "url": "https://github.com/psf/black/pull/3749#discussion_r1240965743"
    },
    {
      "repo": "psf/black",
      "pr_number": 3688,
      "file_path": "action/main.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,7 +32,7 @@\n                 describe_name = line[len(\"describe-name: \") :].rstrip()\n                 break\n     if not describe_name:\n-        print(\"::error::Failed to detect action version.\", flush=True)\n+        sys.stderr.write(\"::error::Failed to detect action version.\")",
      "comment": "Do we care about the newline here you've removed? If so I recommend sticking with print cause I believe it will send correct newline in windows ...\n```suggestion\n        print(\"::error::Failed to detect action version.\", file=sys.stderr, flush=True)\n```\n",
      "comment_id": 1193007666,
      "user": "cooperlees",
      "created_at": "2023-05-13T15:59:43Z",
      "url": "https://github.com/psf/black/pull/3688#discussion_r1193007666"
    },
    {
      "repo": "psf/black",
      "pr_number": 3688,
      "file_path": "action/main.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,7 +32,7 @@\n                 describe_name = line[len(\"describe-name: \") :].rstrip()\n                 break\n     if not describe_name:\n-        print(\"::error::Failed to detect action version.\", flush=True)\n+        sys.stderr.write(\"::error::Failed to detect action version.\")",
      "comment": "It does need to be written to stderr so as errors do not appear in the job summary part (which won't parse it correctly) but the annotation one, like this:\r\n<img width=\"472\" alt=\"screenshot-2023-05-13-1815\" src=\"https://github.com/psf/black/assets/814931/f41040a1-3a28-4c2f-b611-40bb5fcb31da\">\r\nI've updated the PR with your feedback",
      "comment_id": 1193010321,
      "user": "tieum",
      "created_at": "2023-05-13T16:23:14Z",
      "url": "https://github.com/psf/black/pull/3688#discussion_r1193010321"
    },
    {
      "repo": "psf/black",
      "pr_number": 826,
      "file_path": "black.py",
      "line": 2109,
      "side": "RIGHT",
      "diff_hunk": "@@ -2161,6 +2106,22 @@ def make_comment(content: str) -> str:\n     return \"#\" + content\n \n \n+def _line_has_trailing_comma(l: Line) -> bool:",
      "comment": "This turned into `is_collection_with_optional_trailing_comma` as a property on Line.\r\n\r\n(Standalone tests for `is_collection_with_optional_trailing_comma` should be coming soon, but I wanted to get feedback from Travis on the rest of the CI status...)",
      "comment_id": 282119903,
      "user": "durin42",
      "created_at": "2019-05-08T15:27:29Z",
      "url": "https://github.com/psf/black/pull/826#discussion_r282119903"
    },
    {
      "repo": "psf/black",
      "pr_number": 826,
      "file_path": "tests/data/comments2.py",
      "line": 145,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +142,7 @@ def inline_comments_in_brackets_ruin_everything():\n         syms.simple_stmt,\n         [\n             Node(statement, result),\n-            Leaf(token.NEWLINE, '\\n'),  # FIXME: \\r\\n?\n+            Leaf(token.NEWLINE, '\\n')  # FIXME: \\r\\n?",
      "comment": "What caused this change? Black should put a trailing comma here.",
      "comment_id": 282331164,
      "user": "JelleZijlstra",
      "created_at": "2019-05-09T03:59:36Z",
      "url": "https://github.com/psf/black/pull/826#discussion_r282331164"
    },
    {
      "repo": "psf/black",
      "pr_number": 826,
      "file_path": "tests/data/comments2.py",
      "line": 145,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +142,7 @@ def inline_comments_in_brackets_ruin_everything():\n         syms.simple_stmt,\n         [\n             Node(statement, result),\n-            Leaf(token.NEWLINE, '\\n'),  # FIXME: \\r\\n?\n+            Leaf(token.NEWLINE, '\\n')  # FIXME: \\r\\n?",
      "comment": "You're right, but you're commenting on the pre-formatted part of the test case, not the result. The spirit of the test appeared to be that the comment moved correctly with the collapsed line, so I removed the trailing comma in the input.",
      "comment_id": 282331592,
      "user": "durin42",
      "created_at": "2019-05-09T04:02:53Z",
      "url": "https://github.com/psf/black/pull/826#discussion_r282331592"
    },
    {
      "repo": "psf/black",
      "pr_number": 826,
      "file_path": "tests/data/comments2.py",
      "line": 145,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +142,7 @@ def inline_comments_in_brackets_ruin_everything():\n         syms.simple_stmt,\n         [\n             Node(statement, result),\n-            Leaf(token.NEWLINE, '\\n'),  # FIXME: \\r\\n?\n+            Leaf(token.NEWLINE, '\\n')  # FIXME: \\r\\n?",
      "comment": "Thanks! Sorry for that, it's not always easy to tell from changes in the test suite what is actually changing.",
      "comment_id": 282331786,
      "user": "JelleZijlstra",
      "created_at": "2019-05-09T04:04:38Z",
      "url": "https://github.com/psf/black/pull/826#discussion_r282331786"
    },
    {
      "repo": "psf/black",
      "pr_number": 826,
      "file_path": "tests/data/function.py",
      "line": 233,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,7 +230,7 @@ def trailing_comma():\n     }\n \n \n-def f(a, **kwargs) -> A:\n+def f(a, **kwargs,) -> A:",
      "comment": "Is this intended?  I don\u2019t think human devs would write a one-line function signature like this.",
      "comment_id": 292184883,
      "user": "merwok",
      "created_at": "2019-06-10T20:47:36Z",
      "url": "https://github.com/psf/black/pull/826#discussion_r292184883"
    },
    {
      "repo": "psf/black",
      "pr_number": 826,
      "file_path": "tests/data/function.py",
      "line": 233,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,7 +230,7 @@ def trailing_comma():\n     }\n \n \n-def f(a, **kwargs) -> A:\n+def f(a, **kwargs,) -> A:",
      "comment": "I don't see it as avoidable: we're now preserving trailing commas, and it's pretty hard to remove them only in function signatures as far as I can tell. I'm very open to suggestions, but as you say I don't think human devs would write a function like this so it's moot.",
      "comment_id": 292959211,
      "user": "durin42",
      "created_at": "2019-06-12T14:53:50Z",
      "url": "https://github.com/psf/black/pull/826#discussion_r292959211"
    },
    {
      "repo": "psf/black",
      "pr_number": 826,
      "file_path": "tests/data/fmtonoff.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,7 +150,7 @@ def single_literal_yapf_disable():\n     BAZ = {\n         (1, 2, 3, 4),\n         (5, 6, 7, 8),\n-        (9, 10, 11, 12),\n+        (9, 10, 11, 12)\n     }  # yapf: disable",
      "comment": "You're commenting on the input side. To preserve the spirit of the test, I had to make a change to the input so that things would still get formatted.",
      "comment_id": 292960020,
      "user": "durin42",
      "created_at": "2019-06-12T14:55:15Z",
      "url": "https://github.com/psf/black/pull/826#discussion_r292960020"
    },
    {
      "repo": "psf/black",
      "pr_number": 826,
      "file_path": "tests/data/function.py",
      "line": 233,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,7 +230,7 @@ def trailing_comma():\n     }\n \n \n-def f(a, **kwargs) -> A:\n+def f(a, **kwargs,) -> A:",
      "comment": "Preserving seems ok!  Even if people have to point that out in code review if it happens, there is still a lot of time saved and arguments avoided thanks to all the other things that black changes.\r\n\r\nThanks for replying!",
      "comment_id": 293048722,
      "user": "merwok",
      "created_at": "2019-06-12T18:10:14Z",
      "url": "https://github.com/psf/black/pull/826#discussion_r293048722"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/strings.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,8 +4,9 @@\n \n import re\n import sys\n+import unicodedata\n from functools import lru_cache\n-from typing import List, Pattern\n+from typing import List, Pattern, Text",
      "comment": "Text is only relevant for Python 2/3 compatibility. Black is Python 3-only, so just use `str`.",
      "comment_id": 1051422796,
      "user": "JelleZijlstra",
      "created_at": "2022-12-17T16:01:05Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1051422796"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/strings.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,8 +4,9 @@\n \n import re\n import sys\n+import unicodedata\n from functools import lru_cache\n-from typing import List, Pattern\n+from typing import List, Pattern, Text",
      "comment": "Instead of importing `typing.Text`, I replaced `Text` with `str`!",
      "comment_id": 1051428821,
      "user": "dahlia",
      "created_at": "2022-12-17T17:02:25Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1051428821"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/lines.py",
      "line": 722,
      "side": "RIGHT",
      "diff_hunk": "@@ -718,7 +719,7 @@ def is_line_short_enough(line: Line, *, line_length: int, line_str: str = \"\") ->\n     if not line_str:\n         line_str = line_to_string(line)\n     return (\n-        len(line_str) <= line_length\n+        str_width(line_str) <= line_length",
      "comment": "This change appears to affect the stable style. It must be made in the preview style only. (The trans.py code is already preview-only so no need to change anything there.)",
      "comment_id": 1056728812,
      "user": "JelleZijlstra",
      "created_at": "2022-12-24T04:28:50Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1056728812"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/trans.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +73,8 @@ class CannotTransform(Exception):\n TResult = Result[T, CannotTransform]  # (T)ransform Result\n TMatchResult = TResult[Index]\n \n+SPLIT_SAFE_CHARS = frozenset([\"\\u3001\", \"\\u3002\", \"\\uff0c\"])  # East Asian stops",
      "comment": "I see the motivation for this change but it feels separate from the width change, so it should be called out separately in the changelog.",
      "comment_id": 1056729887,
      "user": "JelleZijlstra",
      "created_at": "2022-12-24T04:35:09Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1056729887"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/lines.py",
      "line": 722,
      "side": "RIGHT",
      "diff_hunk": "@@ -718,7 +719,7 @@ def is_line_short_enough(line: Line, *, line_length: int, line_str: str = \"\") ->\n     if not line_str:\n         line_str = line_to_string(line)\n     return (\n-        len(line_str) <= line_length\n+        str_width(line_str) <= line_length",
      "comment": "Would it be a good idea to let `is_line_short_enough()` to take `mode: Mode` instead of `line_length: int`?  Or would it be better to just add a new parameter `preview: bool` to the function?",
      "comment_id": 1056983734,
      "user": "dahlia",
      "created_at": "2022-12-25T18:08:33Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1056983734"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/lines.py",
      "line": 722,
      "side": "RIGHT",
      "diff_hunk": "@@ -718,7 +719,7 @@ def is_line_short_enough(line: Line, *, line_length: int, line_str: str = \"\") ->\n     if not line_str:\n         line_str = line_to_string(line)\n     return (\n-        len(line_str) <= line_length\n+        str_width(line_str) <= line_length",
      "comment": "I just added a new keyword parameter `preview: bool`.  Please let me know if it's not appropriate.",
      "comment_id": 1056991216,
      "user": "dahlia",
      "created_at": "2022-12-25T19:40:12Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1056991216"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/strings.py",
      "line": 259,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +237,40 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def char_width(char: str) -> int:\n+    \"\"\"Return the width of a single character as it would be displayed in a\n+    terminal or editor (which respects Unicode East Asian Width).\n+\n+    Full width characters are counted as 2, while half width characters are\n+    counted as 1.\n+    \"\"\"\n+    return 2 if unicodedata.east_asian_width(char) in (\"F\", \"W\") else 1\n+\n+\n+def str_width(line_str: str) -> int:\n+    \"\"\"Return the width of `line_str` as it would be displayed in a terminal\n+    or editor (which respects Unicode East Asian Width).\n+\n+    You could utilize this function to determine, for example, if a string\n+    is too wide to display in a terminal or editor.\n+    \"\"\"\n+    if line_str.isalpha():",
      "comment": "```suggestion\r\n    if line_str.isascii():\r\n```\r\n`isascii` is O(1) in CPython because string objects store internally whether they're ASCII-only. `isalpha` has to actually loop over the string. It's also not obvious that `isalpha` is correct; I'd have to look up whether any East Asian characters are counted as \"alpha\" for Unicode purposes.",
      "comment_id": 1059159577,
      "user": "JelleZijlstra",
      "created_at": "2022-12-29T21:45:54Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1059159577"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/strings.py",
      "line": 259,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +237,40 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def char_width(char: str) -> int:\n+    \"\"\"Return the width of a single character as it would be displayed in a\n+    terminal or editor (which respects Unicode East Asian Width).\n+\n+    Full width characters are counted as 2, while half width characters are\n+    counted as 1.\n+    \"\"\"\n+    return 2 if unicodedata.east_asian_width(char) in (\"F\", \"W\") else 1\n+\n+\n+def str_width(line_str: str) -> int:\n+    \"\"\"Return the width of `line_str` as it would be displayed in a terminal\n+    or editor (which respects Unicode East Asian Width).\n+\n+    You could utilize this function to determine, for example, if a string\n+    is too wide to display in a terminal or editor.\n+    \"\"\"\n+    if line_str.isalpha():",
      "comment": "Actually, it was not intended, but just a typo.  I amended the commit!",
      "comment_id": 1059313370,
      "user": "dahlia",
      "created_at": "2022-12-30T09:40:30Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1059313370"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/strings.py",
      "line": 259,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +237,40 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def char_width(char: str) -> int:\n+    \"\"\"Return the width of a single character as it would be displayed in a\n+    terminal or editor (which respects Unicode East Asian Width).\n+\n+    Full width characters are counted as 2, while half width characters are\n+    counted as 1.\n+    \"\"\"\n+    return 2 if unicodedata.east_asian_width(char) in (\"F\", \"W\") else 1\n+\n+\n+def str_width(line_str: str) -> int:\n+    \"\"\"Return the width of `line_str` as it would be displayed in a terminal\n+    or editor (which respects Unicode East Asian Width).\n+\n+    You could utilize this function to determine, for example, if a string\n+    is too wide to display in a terminal or editor.\n+    \"\"\"\n+    if line_str.isalpha():",
      "comment": "strictly speaking `isascii` does not ensure a string width being the same as its length since `\\u0000`~`\\u001f` are control characters with no width. But that should not be a problem for formatting code",
      "comment_id": 1062985596,
      "user": "ZeroRin",
      "created_at": "2023-01-05T23:40:35Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1062985596"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "src/black/strings.py",
      "line": 277,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +238,57 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+@lru_cache(maxsize=4096)\n+def char_width(char: str) -> int:\n+    \"\"\"Return the width of a single character as it would be displayed in a\n+    terminal or editor (which respects Unicode East Asian Width).\n+\n+    Full width characters are counted as 2, while half width characters are\n+    counted as 1.  Also control characters are counted as 0.\n+    \"\"\"\n+    table = WIDTH_TABLE\n+    codepoint = ord(char)\n+    highest = len(table) - 1\n+    lowest = 0\n+    idx = highest // 2\n+    while True:\n+        start_codepoint, end_codepoint, width = table[idx]\n+        if codepoint < start_codepoint:\n+            highest = idx - 1\n+        elif codepoint > end_codepoint:\n+            lowest = idx + 1\n+        else:\n+            return 0 if width < 0 else width\n+        if highest < lowest:\n+            break\n+        idx = (highest + lowest) // 2\n+    return 1\n+\n+\n+def str_width(line_str: str) -> int:\n+    \"\"\"Return the width of `line_str` as it would be displayed in a terminal\n+    or editor (which respects Unicode East Asian Width).\n+\n+    You could utilize this function to determine, for example, if a string\n+    is too wide to display in a terminal or editor.\n+    \"\"\"\n+    if COMMON_SINGLE_WIDTH_CHARS.match(line_str):",
      "comment": "The reason I suggested `.isascii()` specifically is that thanks to a peculiarity of how strings are implemented, it can just look at an internal flag on the string object and so it takes O(1) time. Therefore, it's significantly faster than other similar-seeming methods like `isalpha()`, which in turn are quite a bit faster than running the regex engine.\r\n\r\nTo demonstrate:\r\n```\r\nIn [3]: COMMON_SINGLE_WIDTH_CHARS: Final = re.compile(r\"^[\\x20-\\x7e\\xa0-\\u02ff]*$\")\r\n\r\nIn [4]: s = \"a\" * 40\r\n\r\nIn [5]: %timeit COMMON_SINGLE_WIDTH_CHARS.match(s)\r\n229 ns \u00b1 0.664 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\r\n\r\nIn [6]: %timeit s.isascii()\r\n11.5 ns \u00b1 0.0159 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000,000 loops each)\r\n\r\nIn [7]: %timeit s.isalpha()\r\n\r\n79.2 ns \u00b1 0.102 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\r\n```\r\n\r\nSo `isascii` is about 20x faster than this regex.\r\n\r\nIf we use `isascii`, we'll no longer identify control chars as width 0. But I think that might be the right call anyway, because many editors will display control-chars (e.g. here is VSCode on a file with all the ASCII-range characters):\r\n\r\n<img width=\"249\" alt=\"Screen Shot 2023-01-20 at 4 27 06 AM\" src=\"https://user-images.githubusercontent.com/906600/213694759-56f4fa44-378a-4dfb-846a-ccb689048fa0.png\">\r\n\r\nSo I think we should stick with `isascii`.",
      "comment_id": 1082455953,
      "user": "JelleZijlstra",
      "created_at": "2023-01-20T12:28:50Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1082455953"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "scripts/make_width_table.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,50 @@\n+import sys\n+from os.path import basename, dirname, join\n+from typing import Iterable, Tuple\n+\n+from wcwidth import wcwidth\n+\n+\n+def make_width_table() -> Iterable[Tuple[int, int, int]]:\n+    start_codepoint = -1\n+    end_codepoint = -1\n+    range_width = -2\n+    for codepoint in range(0, sys.maxunicode + 1):\n+        width = wcwidth(chr(codepoint))\n+        if width == 1:\n+            continue\n+        if start_codepoint < 0:\n+            start_codepoint = codepoint\n+            range_width = width\n+        elif width != range_width or codepoint != end_codepoint + 1:\n+            yield (start_codepoint, end_codepoint, range_width)\n+            start_codepoint = codepoint\n+            range_width = width\n+        end_codepoint = codepoint\n+    if start_codepoint >= 0:\n+        yield (start_codepoint, end_codepoint, range_width)\n+\n+\n+def main() -> None:\n+    table_path = join(dirname(__file__), \"..\", \"src\", \"black\", \"_width_table.py\")\n+    with open(table_path, \"w\") as f:\n+        f.write(\n+            f\"\"\"# Generated by {basename(__file__)}\n+import sys",
      "comment": "The output should include the version of relevant tools that was used to generate this. I think that can include:\r\n\r\n- wcwidth\r\n- The Unicode version that wcwidth uses\r\n- The Python version, if wcwidth relies on the Unicode DB that comes bundled with Python",
      "comment_id": 1082464127,
      "user": "JelleZijlstra",
      "created_at": "2023-01-20T12:34:16Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1082464127"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "scripts/make_width_table.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,50 @@\n+import sys",
      "comment": "Please add a docstring explaining what this file does and when it should be run.",
      "comment_id": 1082464453,
      "user": "JelleZijlstra",
      "created_at": "2023-01-20T12:34:30Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1082464453"
    },
    {
      "repo": "psf/black",
      "pr_number": 3445,
      "file_path": "scripts/make_width_table.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+\"\"\"Generates a width table for Unicode characters.\n+\n+This script generates a width table for Unicode characters that are not\n+narrow (width 1). The table is written to src/black/_width_table.py (note\n+that although this file is generated, it is checked into Git) and is used\n+by the char_width() function in src/black/strings.py.\n+\n+You should run this script when you upgrade wcwidth, which is expected to\n+happen when a new Unicode version is released. The generated table contains\n+the version of wcwidth and Unicode that it was generated for.\n+\n+In order to run this script, you need to install the latest version of wcwidth.\n+You can do this by running:\n+\n+    pip install -U wcwidth\n+\n+\"\"\"\n+import sys\n+from os.path import basename, dirname, join\n+from typing import Iterable, Tuple\n+\n+import wcwidth\n+\n+\n+def make_width_table() -> Iterable[Tuple[int, int, int]]:\n+    start_codepoint = -1\n+    end_codepoint = -1\n+    range_width = -2\n+    for codepoint in range(0, sys.maxunicode + 1):\n+        width = wcwidth.wcwidth(chr(codepoint))\n+        if width == 1:",
      "comment": "Should we also ignore width = 0 here? That would be consistent with the `isascii` check.\r\n\r\nI think for Black's purposes we can treat width-0 characters like width-1, in the expectation that editors will display the character in some way.",
      "comment_id": 1098587472,
      "user": "JelleZijlstra",
      "created_at": "2023-02-07T12:20:49Z",
      "url": "https://github.com/psf/black/pull/3445#discussion_r1098587472"
    },
    {
      "repo": "psf/black",
      "pr_number": 3594,
      "file_path": "tests/test_black.py",
      "line": 1941,
      "side": "RIGHT",
      "diff_hunk": "@@ -1938,6 +1938,14 @@ def test_equivalency_ast_parse_failure_includes_error(self) -> None:\n         err.match(\"invalid character\")\n         err.match(r\"\\(<unknown>, line 1\\)\")\n \n+    def test_type_comment_syntax_error(self) -> None:",
      "comment": "Would prefer a test in test_format.py where we don't have to write a new test function.",
      "comment_id": 1125509460,
      "user": "JelleZijlstra",
      "created_at": "2023-03-04T18:04:06Z",
      "url": "https://github.com/psf/black/pull/3594#discussion_r1125509460"
    },
    {
      "repo": "psf/black",
      "pr_number": 3594,
      "file_path": "src/black/parsing.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -175,11 +180,17 @@ def parse_ast(src: str) -> Union[ast.AST, ast3.AST]:\n     first_error = \"\"\n     for version in sorted(versions, reverse=True):\n         try:\n-            return parse_single_version(src, version)\n+            return parse_single_version(src, version, type_comments=True)\n         except SyntaxError as e:\n             if not first_error:\n                 first_error = str(e)\n \n+            # Try to parse without type comments",
      "comment": "Need to think more about whether we should have a separate loop instead. I *think* that should never affect behavior, just performance.",
      "comment_id": 1125509570,
      "user": "JelleZijlstra",
      "created_at": "2023-03-04T18:05:06Z",
      "url": "https://github.com/psf/black/pull/3594#discussion_r1125509570"
    },
    {
      "repo": "psf/black",
      "pr_number": 3594,
      "file_path": "src/black/parsing.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,24 +148,29 @@ def lib2to3_unparse(node: Node) -> str:\n \n \n def parse_single_version(\n-    src: str, version: Tuple[int, int]\n+    src: str, version: Tuple[int, int], type_comments: bool",
      "comment": "```suggestion\r\n    src: str, version: Tuple[int, int], *, type_comments: bool\r\n```\r\nLet's make it keyword-only",
      "comment_id": 1125509626,
      "user": "JelleZijlstra",
      "created_at": "2023-03-04T18:05:20Z",
      "url": "https://github.com/psf/black/pull/3594#discussion_r1125509626"
    },
    {
      "repo": "psf/black",
      "pr_number": 3594,
      "file_path": "src/black/parsing.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -175,11 +180,17 @@ def parse_ast(src: str) -> Union[ast.AST, ast3.AST]:\n     first_error = \"\"\n     for version in sorted(versions, reverse=True):\n         try:\n-            return parse_single_version(src, version)\n+            return parse_single_version(src, version, type_comments=True)\n         except SyntaxError as e:\n             if not first_error:\n                 first_error = str(e)\n \n+            # Try to parse without type comments",
      "comment": "I'll move it to an outer for loop anyway. Just for guaranteed backwards compatibility.",
      "comment_id": 1125686561,
      "user": "tusharsadhwani",
      "created_at": "2023-03-05T15:30:28Z",
      "url": "https://github.com/psf/black/pull/3594#discussion_r1125686561"
    },
    {
      "repo": "psf/black",
      "pr_number": 3462,
      "file_path": "src/black/brackets.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,9 +76,12 @@ def mark(self, leaf: Leaf) -> None:\n         within brackets a given leaf is. 0 means there are no enclosing brackets\n         that started on this line.\n \n-        If a leaf is itself a closing bracket, it receives an `opening_bracket`\n-        field that it forms a pair with. This is a one-directional link to\n-        avoid reference cycles.\n+        If a leaf is itself a closing bracket and there is a matching opening\n+        bracket earlier, it receives an `opening_bracket` field that it forms a",
      "comment": "```suggestion\r\n        bracket earlier, it receives an `opening_bracket` field with which it forms a\r\n```",
      "comment_id": 1052941652,
      "user": "JelleZijlstra",
      "created_at": "2022-12-20T06:14:35Z",
      "url": "https://github.com/psf/black/pull/3462#discussion_r1052941652"
    },
    {
      "repo": "psf/black",
      "pr_number": 3462,
      "file_path": "src/black/brackets.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,17 +90,18 @@ def mark(self, leaf: Leaf) -> None:\n         if leaf.type == token.COMMENT:\n             return\n \n+        if (\n+            self.depth == 0\n+            and leaf.type in CLOSING_BRACKETS\n+            and (self.depth, leaf.type) not in self.bracket_match\n+        ):\n+            return\n+\n         self.maybe_decrement_after_for_loop_variable(leaf)\n         self.maybe_decrement_after_lambda_arguments(leaf)\n         if leaf.type in CLOSING_BRACKETS:\n             self.depth -= 1\n-            try:\n-                opening_bracket = self.bracket_match.pop((self.depth, leaf.type))\n-            except KeyError as e:\n-                raise BracketMatchError(\n-                    \"Unable to match a closing bracket to the following opening\"\n-                    f\" bracket: {leaf}\"\n-                ) from e\n+            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))",
      "comment": "Why not keep the BracketMatchError? Seems like it makes for a better error message.",
      "comment_id": 1052942197,
      "user": "JelleZijlstra",
      "created_at": "2022-12-20T06:15:32Z",
      "url": "https://github.com/psf/black/pull/3462#discussion_r1052942197"
    },
    {
      "repo": "psf/black",
      "pr_number": 3609,
      "file_path": "src/black/nodes.py",
      "line": 810,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,13 +789,30 @@ def is_import(leaf: Leaf) -> bool:\n     )\n \n \n-def is_with_stmt(leaf: Leaf) -> bool:\n-    \"\"\"Return True if the given leaf starts a with statement.\"\"\"\n+def is_with_or_async_with_stmt(leaf: Leaf) -> bool:\n+    \"\"\"Return True if the given leaf starts a with or async with statement.\"\"\"\n     return bool(\n         leaf.type == token.NAME\n         and leaf.value == \"with\"\n         and leaf.parent\n         and leaf.parent.type == syms.with_stmt\n+    ) or bool(\n+        leaf.type == token.ASYNC\n+        and leaf.next_sibling\n+        and leaf.next_sibling.type == syms.with_stmt\n+    )\n+\n+\n+def is_async_stmt_or_funcdef(leaf: Leaf) -> bool:\n+    \"\"\"Return True if the given leaf starts an async def/for/with statement.\n+\n+    Note that `async def` can be either an `async_stmt` or `async_funcdef`,\n+    the later is used when it has decorators.",
      "comment": "```suggestion\r\n    the latter is used when it has decorators.\r\n```",
      "comment_id": 1139276788,
      "user": "JelleZijlstra",
      "created_at": "2023-03-16T19:39:29Z",
      "url": "https://github.com/psf/black/pull/3609#discussion_r1139276788"
    },
    {
      "repo": "psf/black",
      "pr_number": 1879,
      "file_path": "tests/data/multiline_strings.py",
      "line": 140,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+\"\"\"cow\n+say\"\"\",\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"dove\n+    coo\"\"\" % \"cowabunga\"))\n+call(3, textwrap.dedent(\"\"\"cow\n+    moo\"\"\" % \"cowabunga\"), \"dogsay\")\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"crow\n+    caw\"\"\" % \"cowabunga\"),)\n+call(3, textwrap.dedent(\"\"\"cat\n+    meow\"\"\" % \"cowabunga\"), {\"dog\", \"say\"})\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"horse\n+    neigh\"\"\" % \"cowabunga\"))\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"pig\n+    oink\"\"\" % \"cowabunga\"),)\n+textwrap.dedent(\"\"\"A one-line triple-quoted string.\"\"\")\n+textwrap.dedent(\"\"\"A two-line triple-quoted string\n+since it goes to the next line.\"\"\")\n+textwrap.dedent(\"\"\"A three-line triple-quoted string\n+that not only goes to the next line\n+but also goes one line beyond.\"\"\")\n+textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\")\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\"))\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {config_filename} file contents.\n+\"\"\".format(\"config_filename\", config_filename)))\n+# Another use case\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\")\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\",)\n+\n+MULTILINE = \"\"\"\n+foo\n+\"\"\".replace(\"\\n\", \"\")\n+generated_readme = lambda project_name: \"\"\"\n+{}\n+\n+<Add content here!>\n+\"\"\".strip().format(project_name)\n+parser.usage += \"\"\"\n+Custom extra help summary.\n+\n+Extra test:\n+- with\n+- bullets\n+\"\"\"\n+\n+\n+def get_stuff(cr, value):\n+    # original\n+    cr.execute(\"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+    \"\"\", [value])\n+    return cr.fetchone()\n+\n+\n+def get_stuff(cr, value):\n+    # preferred\n+    cr.execute(\n+        \"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+        \"\"\",\n+        [value],\n+    )\n+    return cr.fetchone()\n+\n+\n+call(arg1, arg2, \"\"\"\n+short\n+\"\"\", arg3=True)\n+test_vectors = [\n+    \"one-liner\\n\",\n+    \"two\\nliner\\n\",\n+    \"\"\"expressed\n+as a three line\n+mulitline string\"\"\",\n+]\n+\n+_wat = re.compile(\n+    r\"\"\"\n+    regex\n+    \"\"\",\n+    re.MULTILINE | re.VERBOSE,\n+)\n+dis_c_instance_method = \"\"\"\\\n+%3d           0 LOAD_FAST                1 (x)\n+              2 LOAD_CONST               1 (1)\n+              4 COMPARE_OP               2 (==)\n+              6 LOAD_FAST                0 (self)\n+              8 STORE_ATTR               0 (x)\n+             10 LOAD_CONST               0 (None)\n+             12 RETURN_VALUE\n+\"\"\" % (_C.__init__.__code__.co_firstlineno + 1,)\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually {verb} the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {file_type} file contents.\n+\"\"\".format(verb=\"using\", file_type=\"test\")))\n+{\"\"\"cow\n+moos\"\"\"}\n+[\"\"\"cow\n+moos\"\"\"]\n+[\"\"\"cow\n+moos\"\"\", \"\"\"dog\n+woofs\n+and\n+barks\"\"\"]\n+def dastardly_default_value(\n+    cow: String = json.loads(\"\"\"this\n+is\n+quite\n+the\n+dastadardly\n+value!\"\"\"),\n+    **kwargs,\n+):\n+    pass\n+# output",
      "comment": "I'd prefer more newlines around the `# output` comment so it's easier to find\r\n```suggestion\r\n\r\n# output\r\n\r\n```",
      "comment_id": 547573204,
      "user": "JelleZijlstra",
      "created_at": "2020-12-23T00:35:30Z",
      "url": "https://github.com/psf/black/pull/1879#discussion_r547573204"
    },
    {
      "repo": "psf/black",
      "pr_number": 1879,
      "file_path": "tests/data/multiline_strings.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+\"\"\"cow\n+say\"\"\",\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"dove\n+    coo\"\"\" % \"cowabunga\"))\n+call(3, textwrap.dedent(\"\"\"cow\n+    moo\"\"\" % \"cowabunga\"), \"dogsay\")\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"crow\n+    caw\"\"\" % \"cowabunga\"),)\n+call(3, textwrap.dedent(\"\"\"cat\n+    meow\"\"\" % \"cowabunga\"), {\"dog\", \"say\"})\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"horse\n+    neigh\"\"\" % \"cowabunga\"))\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"pig\n+    oink\"\"\" % \"cowabunga\"),)\n+textwrap.dedent(\"\"\"A one-line triple-quoted string.\"\"\")\n+textwrap.dedent(\"\"\"A two-line triple-quoted string\n+since it goes to the next line.\"\"\")\n+textwrap.dedent(\"\"\"A three-line triple-quoted string\n+that not only goes to the next line\n+but also goes one line beyond.\"\"\")\n+textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\")\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\"))\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {config_filename} file contents.\n+\"\"\".format(\"config_filename\", config_filename)))\n+# Another use case\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\")\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\",)\n+\n+MULTILINE = \"\"\"\n+foo\n+\"\"\".replace(\"\\n\", \"\")\n+generated_readme = lambda project_name: \"\"\"\n+{}\n+\n+<Add content here!>\n+\"\"\".strip().format(project_name)\n+parser.usage += \"\"\"\n+Custom extra help summary.\n+\n+Extra test:\n+- with\n+- bullets\n+\"\"\"\n+\n+\n+def get_stuff(cr, value):\n+    # original\n+    cr.execute(\"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+    \"\"\", [value])\n+    return cr.fetchone()\n+\n+\n+def get_stuff(cr, value):\n+    # preferred\n+    cr.execute(\n+        \"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+        \"\"\",\n+        [value],\n+    )\n+    return cr.fetchone()\n+\n+\n+call(arg1, arg2, \"\"\"\n+short\n+\"\"\", arg3=True)\n+test_vectors = [\n+    \"one-liner\\n\",\n+    \"two\\nliner\\n\",\n+    \"\"\"expressed\n+as a three line\n+mulitline string\"\"\",\n+]\n+\n+_wat = re.compile(\n+    r\"\"\"\n+    regex\n+    \"\"\",\n+    re.MULTILINE | re.VERBOSE,\n+)\n+dis_c_instance_method = \"\"\"\\\n+%3d           0 LOAD_FAST                1 (x)\n+              2 LOAD_CONST               1 (1)\n+              4 COMPARE_OP               2 (==)\n+              6 LOAD_FAST                0 (self)\n+              8 STORE_ATTR               0 (x)\n+             10 LOAD_CONST               0 (None)\n+             12 RETURN_VALUE\n+\"\"\" % (_C.__init__.__code__.co_firstlineno + 1,)\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually {verb} the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {file_type} file contents.\n+\"\"\".format(verb=\"using\", file_type=\"test\")))\n+{\"\"\"cow\n+moos\"\"\"}\n+[\"\"\"cow\n+moos\"\"\"]\n+[\"\"\"cow\n+moos\"\"\", \"\"\"dog\n+woofs\n+and\n+barks\"\"\"]\n+def dastardly_default_value(\n+    cow: String = json.loads(\"\"\"this\n+is\n+quite\n+the\n+dastadardly\n+value!\"\"\"),\n+    **kwargs,\n+):\n+    pass\n+# output\n+\"\"\"cow\n+say\"\"\",\n+call(\n+    3,\n+    \"dogsay\",\n+    textwrap.dedent(\"\"\"dove\n+    coo\"\"\" % \"cowabunga\"),\n+)\n+call(\n+    3,\n+    textwrap.dedent(\"\"\"cow",
      "comment": "I feel like it'd be better to put the argument to `dedent()` on a separate line here, so it's easier to count the arguments to `call()`. But there's definitely some cases below where it makes more sense not to put a single multiline string argument on separate lines, so I'm open to persuasion otherwise.",
      "comment_id": 547574202,
      "user": "JelleZijlstra",
      "created_at": "2020-12-23T00:38:53Z",
      "url": "https://github.com/psf/black/pull/1879#discussion_r547574202"
    },
    {
      "repo": "psf/black",
      "pr_number": 1879,
      "file_path": "tests/data/multiline_strings.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+\"\"\"cow\n+say\"\"\",\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"dove\n+    coo\"\"\" % \"cowabunga\"))\n+call(3, textwrap.dedent(\"\"\"cow\n+    moo\"\"\" % \"cowabunga\"), \"dogsay\")\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"crow\n+    caw\"\"\" % \"cowabunga\"),)\n+call(3, textwrap.dedent(\"\"\"cat\n+    meow\"\"\" % \"cowabunga\"), {\"dog\", \"say\"})\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"horse\n+    neigh\"\"\" % \"cowabunga\"))\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"pig\n+    oink\"\"\" % \"cowabunga\"),)\n+textwrap.dedent(\"\"\"A one-line triple-quoted string.\"\"\")\n+textwrap.dedent(\"\"\"A two-line triple-quoted string\n+since it goes to the next line.\"\"\")\n+textwrap.dedent(\"\"\"A three-line triple-quoted string\n+that not only goes to the next line\n+but also goes one line beyond.\"\"\")\n+textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\")\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\"))\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {config_filename} file contents.\n+\"\"\".format(\"config_filename\", config_filename)))\n+# Another use case\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\")\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\",)\n+\n+MULTILINE = \"\"\"\n+foo\n+\"\"\".replace(\"\\n\", \"\")\n+generated_readme = lambda project_name: \"\"\"\n+{}\n+\n+<Add content here!>\n+\"\"\".strip().format(project_name)\n+parser.usage += \"\"\"\n+Custom extra help summary.\n+\n+Extra test:\n+- with\n+- bullets\n+\"\"\"\n+\n+\n+def get_stuff(cr, value):\n+    # original\n+    cr.execute(\"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+    \"\"\", [value])\n+    return cr.fetchone()\n+\n+\n+def get_stuff(cr, value):\n+    # preferred\n+    cr.execute(\n+        \"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+        \"\"\",\n+        [value],\n+    )\n+    return cr.fetchone()\n+\n+\n+call(arg1, arg2, \"\"\"\n+short\n+\"\"\", arg3=True)\n+test_vectors = [\n+    \"one-liner\\n\",\n+    \"two\\nliner\\n\",\n+    \"\"\"expressed\n+as a three line\n+mulitline string\"\"\",\n+]\n+\n+_wat = re.compile(\n+    r\"\"\"\n+    regex\n+    \"\"\",\n+    re.MULTILINE | re.VERBOSE,\n+)\n+dis_c_instance_method = \"\"\"\\\n+%3d           0 LOAD_FAST                1 (x)\n+              2 LOAD_CONST               1 (1)\n+              4 COMPARE_OP               2 (==)\n+              6 LOAD_FAST                0 (self)\n+              8 STORE_ATTR               0 (x)\n+             10 LOAD_CONST               0 (None)\n+             12 RETURN_VALUE\n+\"\"\" % (_C.__init__.__code__.co_firstlineno + 1,)\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually {verb} the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {file_type} file contents.\n+\"\"\".format(verb=\"using\", file_type=\"test\")))\n+{\"\"\"cow\n+moos\"\"\"}\n+[\"\"\"cow\n+moos\"\"\"]\n+[\"\"\"cow\n+moos\"\"\", \"\"\"dog\n+woofs\n+and\n+barks\"\"\"]\n+def dastardly_default_value(\n+    cow: String = json.loads(\"\"\"this\n+is\n+quite\n+the\n+dastadardly\n+value!\"\"\"),\n+    **kwargs,\n+):\n+    pass\n+# output\n+\"\"\"cow\n+say\"\"\",\n+call(\n+    3,\n+    \"dogsay\",\n+    textwrap.dedent(\"\"\"dove\n+    coo\"\"\" % \"cowabunga\"),\n+)\n+call(\n+    3,\n+    textwrap.dedent(\"\"\"cow",
      "comment": "This change is probably to fix Black's handling of the following code:\r\n\r\n```python3\r\ntextwrap.dedent(\"\"\"\\\r\n    Hello, I am\r\n    a multiline string used with\r\n    a common idiom\r\n\"\"\")\r\n```\r\n\r\nRight now Black transforms it to:\r\n\r\n```python3\r\ntextwrap.dedent(\r\n    \"\"\"\\\r\n    Hello, I am\r\n    a multiline string used with\r\n    a common idiom\r\n\"\"\"\r\n)\r\n```\r\n\r\nAnd this PR causes Black leave the code untouched.\r\n\r\nAlthough I do agree that it would look better to have the multiline string argument on a separate line when there's more than one argument in the call. But then again, I don't know if that's even possible with our current Visitor design. \r\n\r\nedit: if the argument-count dependent formatting is dumb or impossible, consider me +0.5 for keeping PR behaviour.",
      "comment_id": 547603011,
      "user": "ichard26",
      "created_at": "2020-12-23T02:20:13Z",
      "url": "https://github.com/psf/black/pull/1879#discussion_r547603011"
    },
    {
      "repo": "psf/black",
      "pr_number": 1879,
      "file_path": "tests/test_black.py",
      "line": 369,
      "side": "RIGHT",
      "diff_hunk": "@@ -359,6 +359,14 @@ def test_string_quotes(self) -> None:\n         black.assert_equivalent(source, not_normalized)\n         black.assert_stable(source, not_normalized, mode=mode)\n \n+    @patch(\"black.dump_to_file\", dump_to_stderr)\n+    def test_multiline_strings(self) -> None:\n+        source, expected = read_data(\"multiline_strings\")\n+        actual = fs(source)\n+        self.assertFormatEqual(expected, actual)\n+        black.assert_equivalent(source, actual)\n+        black.assert_stable(source, actual, DEFAULT_MODE)\n+",
      "comment": "Since PR #1785, writing simple tests like this one is quite easier. Just make the test data and add its normalized name (i.e. strip the `.py` suffix) in the SIMPLE cases list in `tests/test_format.py`.\r\n\r\n[I've done this for you in a PR](https://github.com/lyft/black/pull/1) against your branch since I can't suggest changes on lines/files you didn't modify yet I need to suggest a single addition in such a file :/",
      "comment_id": 548781715,
      "user": "ichard26",
      "created_at": "2020-12-25T02:27:46Z",
      "url": "https://github.com/psf/black/pull/1879#discussion_r548781715"
    },
    {
      "repo": "psf/black",
      "pr_number": 1879,
      "file_path": "tests/data/preview/multiline_strings.py",
      "line": 158,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,340 @@\n+\"\"\"cow\n+say\"\"\",\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"dove\n+    coo\"\"\" % \"cowabunga\"))\n+call(3, textwrap.dedent(\"\"\"cow\n+    moo\"\"\" % \"cowabunga\"), \"dogsay\")\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"crow\n+    caw\"\"\" % \"cowabunga\"),)\n+call(3, textwrap.dedent(\"\"\"cat\n+    meow\"\"\" % \"cowabunga\"), {\"dog\", \"say\"})\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"horse\n+    neigh\"\"\" % \"cowabunga\"))\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"pig\n+    oink\"\"\" % \"cowabunga\"),)\n+textwrap.dedent(\"\"\"A one-line triple-quoted string.\"\"\")\n+textwrap.dedent(\"\"\"A two-line triple-quoted string\n+since it goes to the next line.\"\"\")\n+textwrap.dedent(\"\"\"A three-line triple-quoted string\n+that not only goes to the next line\n+but also goes one line beyond.\"\"\")\n+textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\")\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\"))\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {config_filename} file contents.\n+\"\"\".format(\"config_filename\", config_filename)))\n+# Another use case\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\")\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\",)\n+\n+MULTILINE = \"\"\"\n+foo\n+\"\"\".replace(\"\\n\", \"\")\n+generated_readme = lambda project_name: \"\"\"\n+{}\n+\n+<Add content here!>\n+\"\"\".strip().format(project_name)\n+parser.usage += \"\"\"\n+Custom extra help summary.\n+\n+Extra test:\n+- with\n+- bullets\n+\"\"\"\n+\n+\n+def get_stuff(cr, value):\n+    # original\n+    cr.execute(\"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+    \"\"\", [value])\n+    return cr.fetchone()\n+\n+\n+def get_stuff(cr, value):\n+    # preferred\n+    cr.execute(\n+        \"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+        \"\"\",\n+        [value],\n+    )\n+    return cr.fetchone()\n+\n+\n+call(arg1, arg2, \"\"\"\n+short\n+\"\"\", arg3=True)\n+test_vectors = [\n+    \"one-liner\\n\",\n+    \"two\\nliner\\n\",\n+    \"\"\"expressed\n+as a three line\n+mulitline string\"\"\",\n+]\n+\n+_wat = re.compile(\n+    r\"\"\"\n+    regex\n+    \"\"\",\n+    re.MULTILINE | re.VERBOSE,\n+)\n+dis_c_instance_method = \"\"\"\\\n+%3d           0 LOAD_FAST                1 (x)\n+              2 LOAD_CONST               1 (1)\n+              4 COMPARE_OP               2 (==)\n+              6 LOAD_FAST                0 (self)\n+              8 STORE_ATTR               0 (x)\n+             10 LOAD_CONST               0 (None)\n+             12 RETURN_VALUE\n+\"\"\" % (_C.__init__.__code__.co_firstlineno + 1,)\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually {verb} the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {file_type} file contents.\n+\"\"\".format(verb=\"using\", file_type=\"test\")))\n+{\"\"\"cow\n+moos\"\"\"}\n+[\"\"\"cow\n+moos\"\"\"]\n+[\"\"\"cow\n+moos\"\"\", \"\"\"dog\n+woofs\n+and\n+barks\"\"\"]\n+def dastardly_default_value(\n+    cow: String = json.loads(\"\"\"this\n+is\n+quite\n+the\n+dastadardly\n+value!\"\"\"),\n+    **kwargs,\n+):\n+    pass\n+\n+print(f\"\"\"\n+    This {animal}\n+    moos and barks\n+{animal} say\n+\"\"\")\n+msg = f\"\"\"The arguments {bad_arguments} were passed in.\n+Please use `--build-option` instead,\n+`--global-option` is reserved to flags like `--verbose` or `--quiet`.\n+\"\"\"\n+\n+# output\n+\"\"\"cow\n+say\"\"\",\n+call(\n+    3,\n+    \"dogsay\",\n+    textwrap.dedent(\"\"\"dove\n+    coo\"\"\" % \"cowabunga\"),",
      "comment": "It's *probably* not much, but could we also have just one test for a case where the indent doesn't match? So perhaps\r\n\r\n```suggestion\r\n    textwrap.dedent(\"\"\"dove\r\n  coo\"\"\" % \"cowabunga\"),\r\n```",
      "comment_id": 1069991735,
      "user": "felix-hilden",
      "created_at": "2023-01-13T20:24:44Z",
      "url": "https://github.com/psf/black/pull/1879#discussion_r1069991735"
    },
    {
      "repo": "psf/black",
      "pr_number": 1879,
      "file_path": "tests/data/preview/multiline_strings.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,340 @@\n+\"\"\"cow\n+say\"\"\",\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"dove\n+    coo\"\"\" % \"cowabunga\"))\n+call(3, textwrap.dedent(\"\"\"cow\n+    moo\"\"\" % \"cowabunga\"), \"dogsay\")\n+call(3, \"dogsay\", textwrap.dedent(\"\"\"crow\n+    caw\"\"\" % \"cowabunga\"),)\n+call(3, textwrap.dedent(\"\"\"cat\n+    meow\"\"\" % \"cowabunga\"), {\"dog\", \"say\"})\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"horse\n+    neigh\"\"\" % \"cowabunga\"))\n+call(3, {\"dog\", \"say\"}, textwrap.dedent(\"\"\"pig\n+    oink\"\"\" % \"cowabunga\"),)\n+textwrap.dedent(\"\"\"A one-line triple-quoted string.\"\"\")\n+textwrap.dedent(\"\"\"A two-line triple-quoted string\n+since it goes to the next line.\"\"\")\n+textwrap.dedent(\"\"\"A three-line triple-quoted string\n+that not only goes to the next line\n+but also goes one line beyond.\"\"\")\n+textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\")\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\"))\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {config_filename} file contents.\n+\"\"\".format(\"config_filename\", config_filename)))\n+# Another use case\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\")\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\",)\n+\n+MULTILINE = \"\"\"\n+foo\n+\"\"\".replace(\"\\n\", \"\")\n+generated_readme = lambda project_name: \"\"\"\n+{}\n+\n+<Add content here!>\n+\"\"\".strip().format(project_name)\n+parser.usage += \"\"\"\n+Custom extra help summary.\n+\n+Extra test:\n+- with\n+- bullets\n+\"\"\"\n+\n+\n+def get_stuff(cr, value):\n+    # original\n+    cr.execute(\"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+    \"\"\", [value])\n+    return cr.fetchone()\n+\n+\n+def get_stuff(cr, value):\n+    # preferred\n+    cr.execute(\n+        \"\"\"\n+        SELECT whatever\n+          FROM some_table t\n+         WHERE id = %s\n+        \"\"\",\n+        [value],\n+    )\n+    return cr.fetchone()\n+\n+\n+call(arg1, arg2, \"\"\"\n+short\n+\"\"\", arg3=True)\n+test_vectors = [\n+    \"one-liner\\n\",\n+    \"two\\nliner\\n\",\n+    \"\"\"expressed\n+as a three line\n+mulitline string\"\"\",\n+]\n+\n+_wat = re.compile(\n+    r\"\"\"\n+    regex\n+    \"\"\",\n+    re.MULTILINE | re.VERBOSE,\n+)\n+dis_c_instance_method = \"\"\"\\\n+%3d           0 LOAD_FAST                1 (x)\n+              2 LOAD_CONST               1 (1)\n+              4 COMPARE_OP               2 (==)\n+              6 LOAD_FAST                0 (self)\n+              8 STORE_ATTR               0 (x)\n+             10 LOAD_CONST               0 (None)\n+             12 RETURN_VALUE\n+\"\"\" % (_C.__init__.__code__.co_firstlineno + 1,)\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually {verb} the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {file_type} file contents.\n+\"\"\".format(verb=\"using\", file_type=\"test\")))\n+{\"\"\"cow\n+moos\"\"\"}\n+[\"\"\"cow\n+moos\"\"\"]\n+[\"\"\"cow\n+moos\"\"\", \"\"\"dog\n+woofs\n+and\n+barks\"\"\"]\n+def dastardly_default_value(\n+    cow: String = json.loads(\"\"\"this\n+is\n+quite\n+the\n+dastadardly\n+value!\"\"\"),\n+    **kwargs,\n+):\n+    pass\n+\n+print(f\"\"\"\n+    This {animal}\n+    moos and barks\n+{animal} say\n+\"\"\")\n+msg = f\"\"\"The arguments {bad_arguments} were passed in.\n+Please use `--build-option` instead,\n+`--global-option` is reserved to flags like `--verbose` or `--quiet`.\n+\"\"\"\n+\n+# output\n+\"\"\"cow\n+say\"\"\",\n+call(\n+    3,\n+    \"dogsay\",\n+    textwrap.dedent(\"\"\"dove\n+    coo\"\"\" % \"cowabunga\"),\n+)\n+call(\n+    3,\n+    textwrap.dedent(\"\"\"cow\n+    moo\"\"\" % \"cowabunga\"),\n+    \"dogsay\",\n+)\n+call(\n+    3,\n+    \"dogsay\",\n+    textwrap.dedent(\"\"\"crow\n+    caw\"\"\" % \"cowabunga\"),\n+)\n+call(\n+    3,\n+    textwrap.dedent(\"\"\"cat\n+    meow\"\"\" % \"cowabunga\"),\n+    {\"dog\", \"say\"},\n+)\n+call(\n+    3,\n+    {\"dog\", \"say\"},\n+    textwrap.dedent(\"\"\"horse\n+    neigh\"\"\" % \"cowabunga\"),\n+)\n+call(\n+    3,\n+    {\"dog\", \"say\"},\n+    textwrap.dedent(\"\"\"pig\n+    oink\"\"\" % \"cowabunga\"),\n+)\n+textwrap.dedent(\"\"\"A one-line triple-quoted string.\"\"\")\n+textwrap.dedent(\"\"\"A two-line triple-quoted string\n+since it goes to the next line.\"\"\")\n+textwrap.dedent(\"\"\"A three-line triple-quoted string\n+that not only goes to the next line\n+but also goes one line beyond.\"\"\")\n+textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\")\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. file contents.\n+\"\"\"))\n+path.write_text(textwrap.dedent(\"\"\"\\\n+    A triple-quoted string\n+    actually leveraging the textwrap.dedent functionality\n+    that ends in a trailing newline,\n+    representing e.g. {config_filename} file contents.\n+\"\"\".format(\"config_filename\", config_filename)))\n+# Another use case\n+data = yaml.load(\"\"\"\\\n+a: 1\n+b: 2\n+\"\"\")\n+data = yaml.load(\n+    \"\"\"\\\n+a: 1\n+b: 2\n+\"\"\",\n+)",
      "comment": "Also, could we have this, but the other way around? So from exploded (but without comma) to the simplified `load(\"\"\"\\...` Basically the case we advertise first in the documentation \ud83d\ude04",
      "comment_id": 1069995089,
      "user": "felix-hilden",
      "created_at": "2023-01-13T20:27:06Z",
      "url": "https://github.com/psf/black/pull/1879#discussion_r1069995089"
    },
    {
      "repo": "psf/black",
      "pr_number": 1879,
      "file_path": "src/black/lines.py",
      "line": 740,
      "side": "RIGHT",
      "diff_hunk": "@@ -711,18 +714,85 @@ def append_leaves(\n             new_line.append(comment_leaf, preformatted=True)\n \n \n-def is_line_short_enough(line: Line, *, line_length: int, line_str: str = \"\") -> bool:\n-    \"\"\"Return True if `line` is no longer than `line_length`.\n-\n+def is_line_short_enough(  # noqa: C901\n+    line: Line, *, mode: Mode, line_str: str = \"\"\n+) -> bool:\n+    \"\"\"For non-multiline strings, return True if `line` is no longer than `line_length`.\n+    For multiline strings, looks at the context around `line` to determine\n+    if it should be inlined or split up.\n     Uses the provided `line_str` rendering, if any, otherwise computes a new one.\n     \"\"\"\n     if not line_str:\n         line_str = line_to_string(line)\n-    return (\n-        len(line_str) <= line_length\n-        and \"\\n\" not in line_str  # multiline strings\n-        and not line.contains_standalone_comments()\n-    )\n+\n+    if Preview.multiline_string_handling not in mode:\n+        return (\n+            len(line_str) <= mode.line_length\n+            and \"\\n\" not in line_str  # multiline strings\n+            and not line.contains_standalone_comments()\n+        )\n+\n+    if line.contains_standalone_comments():\n+        return False\n+    if \"\\n\" not in line_str:\n+        # No multiline strings (MLS) present\n+        return len(line_str) <= mode.line_length\n+    else:",
      "comment": "NIT: since the above ifs are return-guards, we could just dedent this. But that's me being super picky \ud83d\ude05 only if you like it!",
      "comment_id": 1070013734,
      "user": "felix-hilden",
      "created_at": "2023-01-13T20:40:54Z",
      "url": "https://github.com/psf/black/pull/1879#discussion_r1070013734"
    },
    {
      "repo": "psf/black",
      "pr_number": 3430,
      "file_path": "src/black/linegen.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -389,19 +389,18 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n                 # We need to find the length of the last line of the docstring\n                 # to find if we can add the closing quotes to the line without\n                 # exceeding the maximum line length.\n-                # If docstring is one line, then we need to add the length\n-                # of the indent, prefix, and starting quotes. Ending quotes are\n-                # handled later.\n+                # If docstring is one line, we don't put the closing quotes on a\n+                # separate line because it looks ugly (#3320).\n                 lines = docstring.splitlines()\n                 last_line_length = len(lines[-1]) if docstring else 0\n \n-                if len(lines) == 1:\n-                    last_line_length += len(indent) + len(prefix) + quote_len\n-\n                 # If adding closing quotes would cause the last line to exceed\n                 # the maximum line length then put a line break before the\n                 # closing quotes\n-                if last_line_length + quote_len > self.mode.line_length:\n+                if (\n+                    len(lines) > 1\n+                    and last_line_length + quote_len > self.mode.line_length\n+                ):",
      "comment": "Why does this not take indentation into account when determining whether the line length would be violated? ",
      "comment_id": 1046657339,
      "user": "ichard26",
      "created_at": "2022-12-13T04:50:29Z",
      "url": "https://github.com/psf/black/pull/3430#discussion_r1046657339"
    },
    {
      "repo": "psf/black",
      "pr_number": 3430,
      "file_path": "src/black/linegen.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -389,19 +389,18 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n                 # We need to find the length of the last line of the docstring\n                 # to find if we can add the closing quotes to the line without\n                 # exceeding the maximum line length.\n-                # If docstring is one line, then we need to add the length\n-                # of the indent, prefix, and starting quotes. Ending quotes are\n-                # handled later.\n+                # If docstring is one line, we don't put the closing quotes on a\n+                # separate line because it looks ugly (#3320).\n                 lines = docstring.splitlines()\n                 last_line_length = len(lines[-1]) if docstring else 0\n \n-                if len(lines) == 1:\n-                    last_line_length += len(indent) + len(prefix) + quote_len\n-\n                 # If adding closing quotes would cause the last line to exceed\n                 # the maximum line length then put a line break before the\n                 # closing quotes\n-                if last_line_length + quote_len > self.mode.line_length:\n+                if (\n+                    len(lines) > 1\n+                    and last_line_length + quote_len > self.mode.line_length\n+                ):",
      "comment": "Oh hmm, sometimes it does take into account the indentation. Looks like `lines` doesn't contain what I expected it to. Nothing here makes sense :)",
      "comment_id": 1046659192,
      "user": "ichard26",
      "created_at": "2022-12-13T04:54:39Z",
      "url": "https://github.com/psf/black/pull/3430#discussion_r1046659192"
    },
    {
      "repo": "psf/black",
      "pr_number": 3589,
      "file_path": "src/black/lines.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -119,6 +120,11 @@ def is_import(self) -> bool:\n         \"\"\"Is this an import line?\"\"\"\n         return bool(self) and is_import(self.leaves[0])\n \n+    @property\n+    def is_with_stmt(self) -> bool:\n+        \"\"\"Is this an with_stmt line?\"\"\"",
      "comment": "```suggestion\r\n        \"\"\"Is this a with_stmt line?\"\"\"\r\n```",
      "comment_id": 1121129617,
      "user": "JelleZijlstra",
      "created_at": "2023-03-01T04:32:34Z",
      "url": "https://github.com/psf/black/pull/3589#discussion_r1121129617"
    },
    {
      "repo": "psf/black",
      "pr_number": 3589,
      "file_path": "src/black/nodes.py",
      "line": 796,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,6 +789,16 @@ def is_import(leaf: Leaf) -> bool:\n     )\n \n \n+def is_with_stmt(leaf: Leaf) -> bool:\n+    \"\"\"Return True if the given leaf starts a with statement.\"\"\"\n+    return bool(\n+        leaf.type == token.NAME\n+        and leaf.value == \"with\"",
      "comment": "Does this also cover `async with`? We should treat both of these the same.",
      "comment_id": 1121131041,
      "user": "JelleZijlstra",
      "created_at": "2023-03-01T04:34:55Z",
      "url": "https://github.com/psf/black/pull/3589#discussion_r1121131041"
    },
    {
      "repo": "psf/black",
      "pr_number": 3589,
      "file_path": "src/black/nodes.py",
      "line": 796,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,6 +789,16 @@ def is_import(leaf: Leaf) -> bool:\n     )\n \n \n+def is_with_stmt(leaf: Leaf) -> bool:\n+    \"\"\"Return True if the given leaf starts a with statement.\"\"\"\n+    return bool(\n+        leaf.type == token.NAME\n+        and leaf.value == \"with\"",
      "comment": "Good catch! Turns out `async with` isn't handled at all in #3489. It has a different code path [here](https://github.com/psf/black/blob/25d886f52c2bbbb58386ac8050f4e67952507bc7/src/black/linegen.py#L289) so the code I'm touching in this PR isn't called at all.\r\n\r\nI filed #3591, will address separately.",
      "comment_id": 1121158558,
      "user": "yilei",
      "created_at": "2023-03-01T05:15:12Z",
      "url": "https://github.com/psf/black/pull/3589#discussion_r1121158558"
    },
    {
      "repo": "psf/black",
      "pr_number": 3035,
      "file_path": "src/black/mode.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,6 +148,7 @@ class Preview(Enum):\n     one_element_subscript = auto()\n     annotation_parens = auto()\n     long_docstring_quotes_on_newline = auto()\n+    remove_def_trailing_newline = auto()",
      "comment": "```suggestion\r\n    remove_block_trailing_newline = auto()\r\n```\r\nNIT: If we want to be fully, pedantically accurate \ud83d\ude04",
      "comment_id": 881369864,
      "user": "felix-hilden",
      "created_at": "2022-05-25T08:27:32Z",
      "url": "https://github.com/psf/black/pull/3035#discussion_r881369864"
    },
    {
      "repo": "psf/black",
      "pr_number": 3393,
      "file_path": "tests/data/simple_cases/function_trailing_comma.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,5 +1,11 @@\n def f(a,):\n     d = {'key': 'value',}\n+    e = {",
      "comment": "Can you add similar test cases using set, tuple, and list literals?",
      "comment_id": 1049142717,
      "user": "JelleZijlstra",
      "created_at": "2022-12-15T02:03:09Z",
      "url": "https://github.com/psf/black/pull/3393#discussion_r1049142717"
    },
    {
      "repo": "psf/black",
      "pr_number": 3393,
      "file_path": "tests/data/simple_cases/function_trailing_comma.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,5 +1,11 @@\n def f(a,):\n     d = {'key': 'value',}\n+    e = {",
      "comment": "Thanks for the comment. Yes, I've just added those.",
      "comment_id": 1051881246,
      "user": "mainj12",
      "created_at": "2022-12-19T07:26:39Z",
      "url": "https://github.com/psf/black/pull/3393#discussion_r1051881246"
    },
    {
      "repo": "psf/black",
      "pr_number": 3393,
      "file_path": "tests/data/simple_cases/function_trailing_comma.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +92,34 @@ def f(\n     d = {\n         \"key\": \"value\",\n     }\n+    e = {\n+        \"a\": fun(msg, \"ts\"),\n+        \"longggggggggggggggid\": ...,\n+        \"longgggggggggggggggggggkey\": ...,\n+        \"created\": ...,\n+        # \"longkey\": ...\n+    }\n+    f = [\n+        arg1,\n+        arg2,\n+        arg3,\n+        arg4,",
      "comment": "This seems short enough to fit in one line, so it's a little weird to me that we don't. However, current behavior is already to put everything on its own line and that seems fine, so let's leave it as is.",
      "comment_id": 1059161250,
      "user": "JelleZijlstra",
      "created_at": "2022-12-29T21:52:38Z",
      "url": "https://github.com/psf/black/pull/3393#discussion_r1059161250"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,14 +106,91 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse the requires-python field to determine Black's target version.\n+\n+    If the field cannot be parsed, returns None.\n+    \"\"\"\n+    try:\n+        return parse_req_python_version(requires_python)\n+    except InvalidVersion:\n+        pass\n+    try:\n+        return parse_req_python_specifier(requires_python)\n+    except InvalidSpecifier:\n+        pass\n+    return None\n+\n+\n+def parse_req_python_version(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a version string (i.e. ``\"3.7\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.version.InvalidVersion error.\n+    \"\"\"\n+    version = Version(requires_python)",
      "comment": "Oh I suppose it throws InvalidVersion in that case. That raises the question of when this raises `InvalidVersion` and when it returns None, if both of those represent an invalid version.",
      "comment_id": 945054466,
      "user": "JelleZijlstra",
      "created_at": "2022-08-13T03:45:52Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r945054466"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,14 +106,91 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse the requires-python field to determine Black's target version.\n+\n+    If the field cannot be parsed, returns None.\n+    \"\"\"\n+    try:\n+        return parse_req_python_version(requires_python)\n+    except InvalidVersion:\n+        pass\n+    try:\n+        return parse_req_python_specifier(requires_python)\n+    except InvalidSpecifier:\n+        pass\n+    return None\n+\n+\n+def parse_req_python_version(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a version string (i.e. ``\"3.7\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.version.InvalidVersion error.\n+    \"\"\"\n+    version = Version(requires_python)",
      "comment": "In this case, `InvalidVersion` represents an invalid version value entered for the `requires-python` field. We return None if the version is valid, but cannot be mapped to one of Black's TargetVersions. I updated the docstrings to clarify.\r\n\r\nI created a separate function `parse_req_python` which handles the `Invalid` exceptions; I wanted to keep each function short to match the style of the other code in the module.",
      "comment_id": 945105139,
      "user": "stinodego",
      "created_at": "2022-08-13T07:13:23Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r945105139"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,14 +106,93 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python",
      "comment": "```suggestion\r\n    return project_metadata.get(\"requires-python\", None)\r\n```",
      "comment_id": 946130919,
      "user": "felix-hilden",
      "created_at": "2022-08-15T21:12:47Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r946130919"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1373,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,35 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    def test_infer_target_version(self) -> None:\n+        for version, expected in [\n+            (\"3.6\", TargetVersion.PY36),\n+            (\"3.11.0rc1\", TargetVersion.PY311),\n+            (\">=3.10\", TargetVersion.PY310),\n+            (\">3.6,<3.10\", TargetVersion.PY37),\n+            (\"==3.8.*\", TargetVersion.PY38),\n+            # (\">=3.8.6\", TargetVersion.PY38),  # Doesn't work yet",
      "comment": "Can we ignore/drop the patch version? Guess not at least easily, but a hack could be to construct a `SpecifierSet` using version strings with the patch sliced out, e.g. `v.split(\".\")[:2]` or something horrible.",
      "comment_id": 946135688,
      "user": "felix-hilden",
      "created_at": "2022-08-15T21:19:34Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r946135688"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,14 +106,93 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python",
      "comment": "Unfortunately, mypy doesn't like your suggestion:\r\n\r\n```\r\nerror: Returning Any from function declared to return \"Optional[str]\"  [no-any-return]\r\n```\r\n\r\nThat's why I explicitly cast it to an optional string.",
      "comment_id": 947219634,
      "user": "stinodego",
      "created_at": "2022-08-16T20:25:28Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r947219634"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1373,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,35 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    def test_infer_target_version(self) -> None:\n+        for version, expected in [\n+            (\"3.6\", TargetVersion.PY36),\n+            (\"3.11.0rc1\", TargetVersion.PY311),\n+            (\">=3.10\", TargetVersion.PY310),\n+            (\">3.6,<3.10\", TargetVersion.PY37),\n+            (\"==3.8.*\", TargetVersion.PY38),\n+            # (\">=3.8.6\", TargetVersion.PY38),  # Doesn't work yet",
      "comment": "I added a function with some black magic that does exactly that (but there were a bunch of special cases I had to handle). Now it covers all the cases I could think of!",
      "comment_id": 947220660,
      "user": "stinodego",
      "created_at": "2022-08-16T20:26:47Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r947220660"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1407,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,39 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    def test_infer_target_version(self) -> None:\n+        for version, expected in [\n+            (\"3.6\", TargetVersion.PY36),\n+            (\"3.11.0rc1\", TargetVersion.PY311),\n+            (\">=3.10\", TargetVersion.PY310),\n+            (\">3.6,<3.10\", TargetVersion.PY37),\n+            (\"==3.8.*\", TargetVersion.PY38),",
      "comment": "Can the star be in major/minor? Stupid but haven't checked.",
      "comment_id": 947294699,
      "user": "felix-hilden",
      "created_at": "2022-08-16T22:18:18Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r947294699"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1562,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,39 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:",
      "comment": "This would be a good place for pytest parameterise instead of a loop!",
      "comment_id": 956748457,
      "user": "felix-hilden",
      "created_at": "2022-08-28T15:53:37Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r956748457"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1562,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,39 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:",
      "comment": "That would be great, but unfortunately, `parametrize` doesn't work within this `BlackTestCase` class. It's a different testing framework.\r\n\r\nNot sure why the tests are set up like this - there are different test files that do use normal pytest functions and parametrize - but for now I have to resort to this loop \ud83d\ude1e ",
      "comment_id": 956749203,
      "user": "stinodego",
      "created_at": "2022-08-28T16:00:08Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r956749203"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1407,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,39 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    def test_infer_target_version(self) -> None:\n+        for version, expected in [\n+            (\"3.6\", TargetVersion.PY36),\n+            (\"3.11.0rc1\", TargetVersion.PY311),\n+            (\">=3.10\", TargetVersion.PY310),\n+            (\">3.6,<3.10\", TargetVersion.PY37),\n+            (\"==3.8.*\", TargetVersion.PY38),",
      "comment": "Technically, you could specify `==3.*`. That would allow any Python 3 version. It would result in `TargetVersion.PY33` (the minimum version supported by Black).",
      "comment_id": 956749819,
      "user": "stinodego",
      "created_at": "2022-08-28T16:04:44Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r956749819"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1573,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,39 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    def test_infer_target_version(self) -> None:",
      "comment": "See my other comment. Unfortunately, not possible in this testing framework \ud83d\ude15 ",
      "comment_id": 956749945,
      "user": "stinodego",
      "created_at": "2022-08-28T16:05:34Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r956749945"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1407,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,39 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    def test_infer_target_version(self) -> None:\n+        for version, expected in [\n+            (\"3.6\", TargetVersion.PY36),\n+            (\"3.11.0rc1\", TargetVersion.PY311),\n+            (\">=3.10\", TargetVersion.PY310),\n+            (\">3.6,<3.10\", TargetVersion.PY37),\n+            (\"==3.8.*\", TargetVersion.PY38),",
      "comment": "Let's add a test case for this as well @stinodego!",
      "comment_id": 980095689,
      "user": "isidentical",
      "created_at": "2022-09-26T14:19:00Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r980095689"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 179,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse the requires-python field to determine Black's target version.\n+\n+    If the field cannot be parsed, returns None.\n+    \"\"\"\n+    try:\n+        return parse_req_python_version(requires_python)\n+    except InvalidVersion:\n+        pass\n+    try:\n+        return parse_req_python_specifier(requires_python)\n+    except InvalidSpecifier:\n+        pass\n+    return None\n+\n+\n+def parse_req_python_version(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a version string (i.e. ``\"3.7\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.version.InvalidVersion error.\n+    If the parsed version cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    version = Version(requires_python)\n+    try:\n+        return TargetVersion(version.release[1])\n+    except (IndexError, ValueError):\n+        return None\n+\n+\n+def parse_req_python_specifier(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a specifier string (i.e. ``\">=3.7,<3.10\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.specifiers.InvalidSpecifier error.\n+    If the parsed specifier cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    specifier_set = strip_specifier_set(SpecifierSet(requires_python))\n+\n+    if not specifier_set:\n+        return None",
      "comment": "```suggestion\r\n    specifier_set = strip_specifier_set(SpecifierSet(requires_python))\r\n    if not specifier_set:\r\n        return None\r\n```",
      "comment_id": 995287693,
      "user": "ichard26",
      "created_at": "2022-10-14T02:44:31Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r995287693"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse the requires-python field to determine Black's target version.\n+\n+    If the field cannot be parsed, returns None.\n+    \"\"\"\n+    try:\n+        return parse_req_python_version(requires_python)\n+    except InvalidVersion:\n+        pass\n+    try:\n+        return parse_req_python_specifier(requires_python)\n+    except InvalidSpecifier:\n+        pass\n+    return None\n+\n+\n+def parse_req_python_version(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a version string (i.e. ``\"3.7\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.version.InvalidVersion error.\n+    If the parsed version cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    version = Version(requires_python)\n+    try:\n+        return TargetVersion(version.release[1])\n+    except (IndexError, ValueError):\n+        return None\n+\n+\n+def parse_req_python_specifier(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a specifier string (i.e. ``\">=3.7,<3.10\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.specifiers.InvalidSpecifier error.\n+    If the parsed specifier cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    specifier_set = strip_specifier_set(SpecifierSet(requires_python))\n+\n+    if not specifier_set:\n+        return None\n+\n+    target_version_map = {f\"3.{v.value}\": v for v in TargetVersion}\n+    compatible_versions = specifier_set.filter(target_version_map)",
      "comment": "Is it worth sorting here just in case packaging stops preserving order or we mess up the target version definition order?",
      "comment_id": 995289254,
      "user": "ichard26",
      "created_at": "2022-10-14T02:47:55Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r995289254"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python",
      "comment": "I'd prefer merging `get_req_python` into `infer_target_version` since IMO this module is gaining way too many tiny functions that it's actually hurting readability.",
      "comment_id": 996201056,
      "user": "ichard26",
      "created_at": "2022-10-14T22:43:20Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r996201056"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:",
      "comment": "Same thing here, this code _might_ read better if this was merged into `infer_target_version`. I'm less sure about merging this function compared to `get_req_python` though so exercise your judgement.",
      "comment_id": 996202526,
      "user": "ichard26",
      "created_at": "2022-10-14T22:47:56Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r996202526"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1411,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,40 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    def test_infer_target_version(self) -> None:\n+        for version, expected in [\n+            (\"3.6\", TargetVersion.PY36),\n+            (\"3.11.0rc1\", TargetVersion.PY311),\n+            (\">=3.10\", TargetVersion.PY310),\n+            (\">3.6,<3.10\", TargetVersion.PY37),\n+            (\"==3.8.*\", TargetVersion.PY38),\n+            (\"==3.*\", TargetVersion.PY33),\n+            (\">=3.8.6\", TargetVersion.PY38),\n+            (\"> 3.7.4, != 3.8.8\", TargetVersion.PY37),\n+            (\">3.7,!=3.8\", TargetVersion.PY39),",
      "comment": "```suggestion\r\n            (\">3.7,!=3.8\", TargetVersion.PY39),\r\n            (\"!=3.3,!=3.5\", TargetVersion.PY35),\r\n```",
      "comment_id": 996206205,
      "user": "ichard26",
      "created_at": "2022-10-14T23:00:29Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r996206205"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 177,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse the requires-python field to determine Black's target version.\n+\n+    If the field cannot be parsed, returns None.\n+    \"\"\"\n+    try:\n+        return parse_req_python_version(requires_python)\n+    except InvalidVersion:\n+        pass\n+    try:\n+        return parse_req_python_specifier(requires_python)\n+    except InvalidSpecifier:\n+        pass\n+    return None\n+\n+\n+def parse_req_python_version(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a version string (i.e. ``\"3.7\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.version.InvalidVersion error.\n+    If the parsed version cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    version = Version(requires_python)\n+    try:\n+        return TargetVersion(version.release[1])\n+    except (IndexError, ValueError):\n+        return None\n+\n+\n+def parse_req_python_specifier(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a specifier string (i.e. ``\">=3.7,<3.10\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.specifiers.InvalidSpecifier error.\n+    If the parsed specifier cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    specifier_set = strip_specifier_set(SpecifierSet(requires_python))",
      "comment": "Black will blow up with `Error: Could not open file '/home/ichard26/programming/oss/black/pyproject.toml': Error reading configuration file: Invalid version: 'a'` if you set a specifier set that has an invalid specifier version (eg. `>=3.7,!=a`).\r\n\r\nGiven the defensive style of the rest of the logic, it's probably best to return None if `InvalidVersion` is raised here. The other option is to only ignore invalid specifiers by catching `InvalidVersion` in `strip_specifier_set`'s loop.",
      "comment_id": 996212469,
      "user": "ichard26",
      "created_at": "2022-10-14T23:23:28Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r996212469"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:",
      "comment": "I merged this and the other function into `infer_target_version` locally. Lemme know what you think:\r\n\r\n```python\r\ndef infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\r\n    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\r\n\r\n    Currently only supports the PyPA standard format (PEP 621):\r\n    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\r\n\r\n    If target version cannot be inferred, returns None.\r\n    \"\"\"\r\n    project_metadata = pyproject_toml.get(\"project\", {})\r\n    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\r\n    if requires_python is not None:\r\n        try:\r\n            return parse_req_python_version(requires_python)\r\n        except InvalidVersion:\r\n            pass\r\n        try:\r\n            return parse_req_python_specifier(requires_python)\r\n        except InvalidSpecifier:\r\n            pass\r\n\r\n    return None\r\n```",
      "comment_id": 996213633,
      "user": "ichard26",
      "created_at": "2022-10-14T23:28:21Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r996213633"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/__init__.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,8 +218,10 @@ def validate_regex(\n     callback=target_version_option_callback,\n     multiple=True,\n     help=(\n-        \"Python versions that should be supported by Black's output. [default: per-file\"\n-        \" auto-detection]\"\n+        \"Minimum Python version that should be supported by Black's output. By default,\"\n+        \" Black will try to infer this from the project metadata in pyproject.toml. If\"\n+        \" this does not yield conclusive results, Black will use per-file\"\n+        \" auto-detection.\"",
      "comment": "Good call to document the per-file auto-detection fallback!",
      "comment_id": 996213862,
      "user": "ichard26",
      "created_at": "2022-10-14T23:29:31Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r996213862"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python",
      "comment": "I fully agree. I will follow your suggestion below.",
      "comment_id": 998477876,
      "user": "stinodego",
      "created_at": "2022-10-18T16:43:39Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r998477876"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:",
      "comment": "Much better this way! Added a commit with this change.",
      "comment_id": 998491252,
      "user": "stinodego",
      "created_at": "2022-10-18T16:57:15Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r998491252"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 177,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse the requires-python field to determine Black's target version.\n+\n+    If the field cannot be parsed, returns None.\n+    \"\"\"\n+    try:\n+        return parse_req_python_version(requires_python)\n+    except InvalidVersion:\n+        pass\n+    try:\n+        return parse_req_python_specifier(requires_python)\n+    except InvalidSpecifier:\n+        pass\n+    return None\n+\n+\n+def parse_req_python_version(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a version string (i.e. ``\"3.7\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.version.InvalidVersion error.\n+    If the parsed version cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    version = Version(requires_python)\n+    try:\n+        return TargetVersion(version.release[1])\n+    except (IndexError, ValueError):\n+        return None\n+\n+\n+def parse_req_python_specifier(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a specifier string (i.e. ``\">=3.7,<3.10\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.specifiers.InvalidSpecifier error.\n+    If the parsed specifier cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    specifier_set = strip_specifier_set(SpecifierSet(requires_python))",
      "comment": "Good catch - let's indeed return None in this case. I will figure out how to do this nicely and add a commit for this.",
      "comment_id": 998504405,
      "user": "stinodego",
      "created_at": "2022-10-18T17:10:48Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r998504405"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1411,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,40 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    def test_infer_target_version(self) -> None:\n+        for version, expected in [\n+            (\"3.6\", TargetVersion.PY36),\n+            (\"3.11.0rc1\", TargetVersion.PY311),\n+            (\">=3.10\", TargetVersion.PY310),\n+            (\">3.6,<3.10\", TargetVersion.PY37),\n+            (\"==3.8.*\", TargetVersion.PY38),\n+            (\"==3.*\", TargetVersion.PY33),\n+            (\">=3.8.6\", TargetVersion.PY38),\n+            (\"> 3.7.4, != 3.8.8\", TargetVersion.PY37),\n+            (\">3.7,!=3.8\", TargetVersion.PY39),",
      "comment": "Your test case doesn't work (returns TargetVersion.PY34). I think you meant `\"!=3.3,!=3.4\"`. I added this test case in a new commit.",
      "comment_id": 998512385,
      "user": "stinodego",
      "created_at": "2022-10-18T17:19:35Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r998512385"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse the requires-python field to determine Black's target version.\n+\n+    If the field cannot be parsed, returns None.\n+    \"\"\"\n+    try:\n+        return parse_req_python_version(requires_python)\n+    except InvalidVersion:\n+        pass\n+    try:\n+        return parse_req_python_specifier(requires_python)\n+    except InvalidSpecifier:\n+        pass\n+    return None\n+\n+\n+def parse_req_python_version(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a version string (i.e. ``\"3.7\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.version.InvalidVersion error.\n+    If the parsed version cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    version = Version(requires_python)\n+    try:\n+        return TargetVersion(version.release[1])\n+    except (IndexError, ValueError):\n+        return None\n+\n+\n+def parse_req_python_specifier(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a specifier string (i.e. ``\">=3.7,<3.10\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.specifiers.InvalidSpecifier error.\n+    If the parsed specifier cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    specifier_set = strip_specifier_set(SpecifierSet(requires_python))\n+\n+    if not specifier_set:\n+        return None\n+\n+    target_version_map = {f\"3.{v.value}\": v for v in TargetVersion}\n+    compatible_versions = specifier_set.filter(target_version_map)",
      "comment": "It's possible, but it's a very minor performance hit. I think it's worth it, though it's slightly inelegant implementation-wise. I'll implement this in a new commit.\r\n\r\nEDIT: Since we will be inferring the whole list of target versions, this comment is actually no longer relevant.",
      "comment_id": 998544306,
      "user": "stinodego",
      "created_at": "2022-10-18T17:50:22Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r998544306"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1411,
      "side": "RIGHT",
      "diff_hunk": "@@ -1352,6 +1352,40 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    def test_infer_target_version(self) -> None:\n+        for version, expected in [\n+            (\"3.6\", TargetVersion.PY36),\n+            (\"3.11.0rc1\", TargetVersion.PY311),\n+            (\">=3.10\", TargetVersion.PY310),\n+            (\">3.6,<3.10\", TargetVersion.PY37),\n+            (\"==3.8.*\", TargetVersion.PY38),\n+            (\"==3.*\", TargetVersion.PY33),\n+            (\">=3.8.6\", TargetVersion.PY38),\n+            (\"> 3.7.4, != 3.8.8\", TargetVersion.PY37),\n+            (\">3.7,!=3.8\", TargetVersion.PY39),",
      "comment": "Ah whoops, my bad. I definitely meant that, thanks!",
      "comment_id": 1019781009,
      "user": "ichard26",
      "created_at": "2022-11-11T02:40:29Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r1019781009"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "src/black/files.py",
      "line": 177,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +111,123 @@ def find_pyproject_toml(path_search_start: Tuple[str, ...]) -> Optional[str]:\n \n @mypyc_attr(patchable=True)\n def parse_pyproject_toml(path_config: str) -> Dict[str, Any]:\n-    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black\n+    \"\"\"Parse a pyproject toml file, pulling out relevant parts for Black.\n \n-    If parsing fails, will raise a tomllib.TOMLDecodeError\n+    If parsing fails, will raise a tomllib.TOMLDecodeError.\n     \"\"\"\n     with open(path_config, \"rb\") as f:\n         pyproject_toml = tomllib.load(f)\n-    config = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n-    return {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+    config: Dict[str, Any] = pyproject_toml.get(\"tool\", {}).get(\"black\", {})\n+    config = {k.replace(\"--\", \"\").replace(\"-\", \"_\"): v for k, v in config.items()}\n+\n+    if \"target_version\" not in config:\n+        inferred_target_version = infer_target_version(pyproject_toml)\n+        if inferred_target_version is not None:\n+            config[\"target_version\"] = [inferred_target_version.name.lower()]\n+\n+    return config\n+\n+\n+def infer_target_version(pyproject_toml: Dict[str, Any]) -> Optional[TargetVersion]:\n+    \"\"\"Infer Black's target version from the project metadata in pyproject.toml.\n+\n+    If target version cannot be inferred, returns None.\n+    \"\"\"\n+    requires_python = get_req_python(pyproject_toml)\n+    if requires_python is not None:\n+        return parse_req_python(requires_python)\n+    return None\n+\n+\n+def get_req_python(pyproject_toml: Dict[str, Any]) -> Optional[str]:\n+    \"\"\"Get the required Python version from the project metadata.\n+\n+    Currently only supports the PyPA standard format:\n+    https://packaging.python.org/en/latest/specifications/declaring-project-metadata/#requires-python\n+\n+    If the field is not present or cannot be parsed, returns None.\n+    \"\"\"\n+    project_metadata = pyproject_toml.get(\"project\", {})\n+    requires_python: Optional[str] = project_metadata.get(\"requires-python\", None)\n+    return requires_python\n+\n+\n+def parse_req_python(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse the requires-python field to determine Black's target version.\n+\n+    If the field cannot be parsed, returns None.\n+    \"\"\"\n+    try:\n+        return parse_req_python_version(requires_python)\n+    except InvalidVersion:\n+        pass\n+    try:\n+        return parse_req_python_specifier(requires_python)\n+    except InvalidSpecifier:\n+        pass\n+    return None\n+\n+\n+def parse_req_python_version(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a version string (i.e. ``\"3.7\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.version.InvalidVersion error.\n+    If the parsed version cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    version = Version(requires_python)\n+    try:\n+        return TargetVersion(version.release[1])\n+    except (IndexError, ValueError):\n+        return None\n+\n+\n+def parse_req_python_specifier(requires_python: str) -> Optional[TargetVersion]:\n+    \"\"\"Parse a specifier string (i.e. ``\">=3.7,<3.10\"``) to a TargetVersion.\n+\n+    If parsing fails, will raise a packaging.specifiers.InvalidSpecifier error.\n+    If the parsed specifier cannot be mapped to a valid TargetVersion, returns None.\n+    \"\"\"\n+    specifier_set = strip_specifier_set(SpecifierSet(requires_python))",
      "comment": "Hi, I don't think this was fully addressed, `>3.7,!=a` still crashes Black with a similar error message. ",
      "comment_id": 1019785352,
      "user": "ichard26",
      "created_at": "2022-11-11T02:51:55Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r1019785352"
    },
    {
      "repo": "psf/black",
      "pr_number": 3219,
      "file_path": "tests/test_black.py",
      "line": 1526,
      "side": "RIGHT",
      "diff_hunk": "@@ -1512,6 +1512,73 @@ def test_parse_pyproject_toml(self) -> None:\n         self.assertEqual(config[\"exclude\"], r\"\\.pyi?$\")\n         self.assertEqual(config[\"include\"], r\"\\.py?$\")\n \n+    def test_parse_pyproject_toml_project_metadata(self) -> None:\n+        for test_toml, expected in [\n+            (\"only_black_pyproject.toml\", [\"py310\"]),\n+            (\"only_metadata_pyproject.toml\", [\"py37\", \"py38\", \"py39\", \"py310\"]),\n+            (\"neither_pyproject.toml\", None),\n+            (\"both_pyproject.toml\", [\"py310\"]),\n+        ]:\n+            test_toml_file = THIS_DIR / \"data\" / \"project_metadata\" / test_toml\n+            config = black.parse_pyproject_toml(str(test_toml_file))\n+            self.assertEqual(config.get(\"target_version\"), expected)\n+\n+    @pytest.mark.filterwarnings(\"ignore::DeprecationWarning\")",
      "comment": "We create invalid specifiers to test the code, which causes `packaging` to throw a DeprecationWarning. So in order to test that these invalid specifiers return `None` as expected, we need to ignore these warnings.",
      "comment_id": 1024368572,
      "user": "stinodego",
      "created_at": "2022-11-16T18:32:14Z",
      "url": "https://github.com/psf/black/pull/3219#discussion_r1024368572"
    },
    {
      "repo": "psf/black",
      "pr_number": 3467,
      "file_path": "src/black/trans.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -198,14 +198,19 @@ def __init__(self, line_length: int, normalize_strings: bool) -> None:\n     def do_match(self, line: Line) -> TMatchResult:\n         \"\"\"\n         Returns:\n-            * Ok(string_idx) such that `line.leaves[string_idx]` is our target\n-            string, if a match was able to be made.\n+            * Ok(string_indices) such that for each index, `line.leaves[index]`\n+            is our target string if a match was able to be made. For\n+            transformers that don't result in more lines (e.g. StringMerger,\n+            StringParenStripper), multiple matches and transforms are done at\n+            once to reduce the complexity.\n                 OR\n-            * Err(CannotTransform), if a match was not able to be made.\n+            * Err(CannotTransform), if no match was not able to be made.",
      "comment": "```suggestion\r\n            * Err(CannotTransform), if no match could be made.\r\n```\r\nI think the old wording was correct, but this suggested wording is more clear.",
      "comment_id": 1053738989,
      "user": "JelleZijlstra",
      "created_at": "2022-12-20T20:54:11Z",
      "url": "https://github.com/psf/black/pull/3467#discussion_r1053738989"
    },
    {
      "repo": "psf/black",
      "pr_number": 3467,
      "file_path": "src/black/trans.py",
      "line": 381,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,30 +376,50 @@ def do_match(self, line: Line) -> TMatchResult:\n \n         is_valid_index = is_valid_index_factory(LL)\n \n-        for i, leaf in enumerate(LL):\n+        string_indices = []\n+        idx = 0\n+        while is_valid_index(idx):",
      "comment": "Probably best for another PR, but there may be an optimization opportunity here. `is_valid_index(idx)` is basically equivalent to `idx < len(LL)`, but it does so through some indirection and a nested function. According to Jukka mypyc isn't good at compiling nested functions, so this code may get a good speedup if we just use `idx < len(LL)`.",
      "comment_id": 1056631693,
      "user": "JelleZijlstra",
      "created_at": "2022-12-23T20:11:14Z",
      "url": "https://github.com/psf/black/pull/3467#discussion_r1056631693"
    },
    {
      "repo": "psf/black",
      "pr_number": 3467,
      "file_path": "src/black/trans.py",
      "line": 381,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,30 +376,50 @@ def do_match(self, line: Line) -> TMatchResult:\n \n         is_valid_index = is_valid_index_factory(LL)\n \n-        for i, leaf in enumerate(LL):\n+        string_indices = []\n+        idx = 0\n+        while is_valid_index(idx):",
      "comment": "I tried this (https://github.com/JelleZijlstra/black/commit/9b1f0b11ffd449d6cbf9f2326e316257a707a008) but didn't see a significant difference under ESP, though I didn't do rigorous benchmarking.",
      "comment_id": 1056658119,
      "user": "JelleZijlstra",
      "created_at": "2022-12-23T21:40:10Z",
      "url": "https://github.com/psf/black/pull/3467#discussion_r1056658119"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/linegen.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -255,6 +260,10 @@ def visit_factor(self, node: Node) -> Iterator[Line]:\n         yield from self.visit_default(node)\n \n     def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n+        if Preview.hex_codes_in_unicode_sequences in self.mode:\n+            # Preview style only",
      "comment": "```suggestion\r\n```\r\nNo biggie, but the line above is pretty clear",
      "comment_id": 826156088,
      "user": "felix-hilden",
      "created_at": "2022-03-14T16:35:30Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r826156088"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/mode.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -128,6 +128,7 @@ class Preview(Enum):\n \n     string_processing = auto()\n     hug_simple_powers = auto()\n+    hex_codes_in_unicode_sequences = auto()",
      "comment": "```suggestion\r\n    hex_codes_in_unicode_sequences = auto()\r\n```\r\nThis reminded me: the power hugging didn't end up in preview, so we might as well remove it here.",
      "comment_id": 826157670,
      "user": "felix-hilden",
      "created_at": "2022-03-14T16:37:03Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r826157670"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 252,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +246,30 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"",
      "comment": "This will have to be thought out still, as [this comment](https://github.com/psf/black/issues/2067#issuecomment-1024993814) points out. My two cents: I prefer upper case, and since Black formats hex numbers to upper already I think it would be consistent. The Python repr argument is solid too, but we should think about changing hex literals as well then.",
      "comment_id": 826165374,
      "user": "felix-hilden",
      "created_at": "2022-03-14T16:44:47Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r826165374"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/mode.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -128,6 +128,7 @@ class Preview(Enum):\n \n     string_processing = auto()\n     hug_simple_powers = auto()\n+    hex_codes_in_unicode_sequences = auto()",
      "comment": "I will open a separate PR for this, in case this takes time to get merged, hopefully not \ud83e\udd1e\ud83c\udffb ",
      "comment_id": 826835740,
      "user": "Shivansh-007",
      "created_at": "2022-03-15T10:54:51Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r826835740"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 256,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +246,31 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"\n+    text = leaf.value\n+    prefix = get_string_prefix(text)\n+\n+    def replace(m: Match[AnyStr]) -> str:",
      "comment": "```suggestion\r\n    def replace(m: Match[str]) -> str:\r\n```\r\nSeems like you only handle strs here, not bytes. You can also remove a bunch of the str() calls below.",
      "comment_id": 827591576,
      "user": "JelleZijlstra",
      "created_at": "2022-03-16T03:18:09Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r827591576"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,6 +20,14 @@\n     r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", re.DOTALL\n )\n FIRST_NON_WHITESPACE_RE: Final = re.compile(r\"\\s*\\t+\\s*(\\S)\")\n+UNICODE_RE = re.compile(",
      "comment": "Should probably also make this Final.\r\n\r\nAnd using `re.MULTILINE` might be nice so you can put comments inside the regex.",
      "comment_id": 827592379,
      "user": "JelleZijlstra",
      "created_at": "2022-03-16T03:20:19Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r827592379"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,6 +20,14 @@\n     r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", re.DOTALL\n )\n FIRST_NON_WHITESPACE_RE: Final = re.compile(r\"\\s*\\t+\\s*(\\S)\")\n+UNICODE_RE = re.compile(\n+    r\"(\\\\+)(\"\n+    r\"(u([a-zA-Z0-9]{4}))\"  # Formatting 16-bit unicodes i.e. \\uxxxx",
      "comment": "Can remove the word \"formatting\", and \"unicodes\" isn't a thing, just say \"characters\" like https://docs.python.org/3.10/reference/lexical_analysis.html#string-and-bytes-literals ",
      "comment_id": 827593491,
      "user": "JelleZijlstra",
      "created_at": "2022-03-16T03:23:33Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r827593491"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 252,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +246,30 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"",
      "comment": "I'd rather not change hex numbers, we already changed our mind there a few times.",
      "comment_id": 827593743,
      "user": "JelleZijlstra",
      "created_at": "2022-03-16T03:24:10Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r827593743"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,6 +20,15 @@\n     r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", re.DOTALL\n )\n FIRST_NON_WHITESPACE_RE: Final = re.compile(r\"\\s*\\t+\\s*(\\S)\")\n+UNICODE_RE: Final = re.compile(\n+    r\"(\\\\+)(\"\n+    r\"(u([a-zA-Z0-9]{4}))\"  # Character with 16-bit hex value xxxx\n+    r\"|(U([a-zA-Z0-9]{0,8}))\"  # Character with 32-bit hex value xxxxxxxx\n+    r\"|(x([a-zA-Z0-9]{2}))\"  # Character with hex value hh\n+    r\"|(N\\{([a-zA-Z0-9]{2})\\})\"  # Character named name in the Unicode database\n+    r\")\",\n+    re.MULTILINE,",
      "comment": "Sorry, I actually meant re.VERBOSE (https://docs.python.org/3/library/re.html#re.VERBOSE), which allows you to put comments and whitespace in the regex itself. re.MULTILINE isn't useful.",
      "comment_id": 827611370,
      "user": "JelleZijlstra",
      "created_at": "2022-03-16T04:15:36Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r827611370"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,6 +20,15 @@\n     r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", re.DOTALL\n )\n FIRST_NON_WHITESPACE_RE: Final = re.compile(r\"\\s*\\t+\\s*(\\S)\")\n+UNICODE_RE: Final = re.compile(\n+    r\"(\\\\+)(\"\n+    r\"(u([a-zA-Z0-9]{4}))\"  # Character with 16-bit hex value xxxx\n+    r\"|(U([a-zA-Z0-9]{0,8}))\"  # Character with 32-bit hex value xxxxxxxx\n+    r\"|(x([a-zA-Z0-9]{2}))\"  # Character with hex value hh\n+    r\"|(N\\{([a-zA-Z0-9]{2})\\})\"  # Character named name in the Unicode database\n+    r\")\",\n+    re.MULTILINE,",
      "comment": "You actually got me there once originally. Done \ud83d\udc4d\ud83c\udffb ",
      "comment_id": 827618801,
      "user": "Shivansh-007",
      "created_at": "2022-03-16T04:36:36Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r827618801"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 252,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +246,30 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"",
      "comment": "So if we're not changing numbers (which I agree with), do y'all share the concern for consistency?",
      "comment_id": 834000484,
      "user": "felix-hilden",
      "created_at": "2022-03-24T07:37:06Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r834000484"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 255,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +247,31 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"\n+    text = leaf.value\n+    prefix = get_string_prefix(text)",
      "comment": "why not return early if this contains a `r` ?\r\n\r\n```python\r\nif \"r\" in get_string_prefix(text).lower():\r\n    return\r\n```\r\n",
      "comment_id": 834783704,
      "user": "ichard26",
      "created_at": "2022-03-24T22:30:12Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r834783704"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +247,31 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"\n+    text = leaf.value\n+    prefix = get_string_prefix(text)\n+\n+    def replace(m: Match[str]) -> str:\n+        groups = m.groups()\n+        back_slashes = groups[0]\n+\n+        if len(back_slashes) % 2 == 0 or prefix == \"r\":",
      "comment": "I'd prefer if you did `not` instead of comparing to zero :)\r\n\r\n(I only feel comfortable making this suggestion since I have other meaningful suggestions :stuck_out_tongue:)",
      "comment_id": 834784163,
      "user": "ichard26",
      "created_at": "2022-03-24T22:30:40Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r834784163"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +247,31 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"\n+    text = leaf.value\n+    prefix = get_string_prefix(text)\n+\n+    def replace(m: Match[str]) -> str:\n+        groups = m.groups()\n+        back_slashes = groups[0]\n+\n+        if len(back_slashes) % 2 == 0 or prefix == \"r\":",
      "comment": "This raw string check is too strict, you need to check for a `r` in a lowercased prefix, otherwise both of these cases crash with an AST safety error:\r\n\r\n```python\r\nno_touch = R\"\\xA1\"\r\n```\r\n\r\n```python\r\nno_touch = fr\"\\xA1\"\r\n```",
      "comment_id": 834785136,
      "user": "ichard26",
      "created_at": "2022-03-24T22:31:50Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r834785136"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,6 +20,15 @@\n     r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", re.DOTALL\n )\n FIRST_NON_WHITESPACE_RE: Final = re.compile(r\"\\s*\\t+\\s*(\\S)\")\n+UNICODE_RE: Final = re.compile(",
      "comment": "Please rename this variable to something more specific, maybe `UNICODE_ESCAPE_RE`?",
      "comment_id": 834786340,
      "user": "ichard26",
      "created_at": "2022-03-24T22:34:11Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r834786340"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +247,31 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"\n+    text = leaf.value\n+    prefix = get_string_prefix(text)\n+\n+    def replace(m: Match[str]) -> str:\n+        groups = m.groups()\n+        back_slashes = groups[0]\n+\n+        if len(back_slashes) % 2 == 0 or prefix == \"r\":",
      "comment": "For what it's worth I prefer `== 0` over relying on implicit boolean behavior. I've seen too many bugs where simple boolean conversions turned out to be the wrong thing.",
      "comment_id": 834791627,
      "user": "JelleZijlstra",
      "created_at": "2022-03-24T22:44:59Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r834791627"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +247,31 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"\n+    text = leaf.value\n+    prefix = get_string_prefix(text)\n+\n+    def replace(m: Match[str]) -> str:\n+        groups = m.groups()\n+        back_slashes = groups[0]\n+\n+        if len(back_slashes) % 2 == 0 or prefix == \"r\":",
      "comment": "I'll note that this would be unnecessary if the other r-prefix related suggestion was implemented.",
      "comment_id": 846872347,
      "user": "ichard26",
      "created_at": "2022-04-11T00:18:33Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r846872347"
    },
    {
      "repo": "psf/black",
      "pr_number": 2916,
      "file_path": "src/black/strings.py",
      "line": 252,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,3 +246,30 @@ def normalize_string_quotes(s: str) -> str:\n         return s  # Prefer double quotes\n \n     return f\"{prefix}{new_quote}{new_body}{new_quote}\"\n+\n+\n+def normalize_unicode_escape_sequences(leaf: Leaf) -> None:\n+    \"\"\"Replace hex codes in Unicode escape sequences with lowercase representation.\"\"\"",
      "comment": "My comments read a bit ambiguously. So to be clear, I'm proposing that we switch the formatting to be upper case to be consistent with hex numbers. Y'all in?",
      "comment_id": 910924562,
      "user": "felix-hilden",
      "created_at": "2022-06-30T11:44:32Z",
      "url": "https://github.com/psf/black/pull/2916#discussion_r910924562"
    },
    {
      "repo": "psf/black",
      "pr_number": 3489,
      "file_path": "tests/data/preview_context_managers/auto_detect/features_3_8.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,18 @@\n+# This file doesn't used any Python 3.9+ only grammars.",
      "comment": "Can you test that something like `with (a): pass` doesn't get autodetected as 3.9+?",
      "comment_id": 1066454062,
      "user": "JelleZijlstra",
      "created_at": "2023-01-10T23:55:07Z",
      "url": "https://github.com/psf/black/pull/3489#discussion_r1066454062"
    },
    {
      "repo": "psf/black",
      "pr_number": 3473,
      "file_path": "tests/data/py_38/pep_572_remove_parens.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,3 +123,23 @@ def a():\n def this_is_so_dumb() -> (please := no):\n     pass\n \n+\n+async def await_the_walrus():\n+    with (x := y):\n+        pass\n+\n+    with (x := y) as z, (a := b) as c:\n+        pass\n+\n+    with (x := await y):\n+        pass\n+\n+    with (x := await a, y := await b):\n+        pass\n+\n+    # Ideally we should remove one set of parentheses\n+    with ((x := await a, y := await b)):\n+        pass",
      "comment": "We do under the preview style! Is this data file using the preview style?",
      "comment_id": 1057364849,
      "user": "ichard26",
      "created_at": "2022-12-26T23:58:20Z",
      "url": "https://github.com/psf/black/pull/3473#discussion_r1057364849"
    },
    {
      "repo": "psf/black",
      "pr_number": 3473,
      "file_path": "tests/data/py_38/pep_572_remove_parens.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,3 +123,23 @@ def a():\n def this_is_so_dumb() -> (please := no):\n     pass\n \n+\n+async def await_the_walrus():\n+    with (x := y):\n+        pass\n+\n+    with (x := y) as z, (a := b) as c:\n+        pass\n+\n+    with (x := await y):\n+        pass\n+\n+    with (x := await a, y := await b):\n+        pass\n+\n+    # Ideally we should remove one set of parentheses\n+    with ((x := await a, y := await b)):\n+        pass",
      "comment": "That seems fine, since the main purpose of this test is to make sure we don't crash on this case. We can always change the exact test output when that part of the preview style becomes stable.",
      "comment_id": 1057396263,
      "user": "JelleZijlstra",
      "created_at": "2022-12-27T01:47:12Z",
      "url": "https://github.com/psf/black/pull/3473#discussion_r1057396263"
    },
    {
      "repo": "psf/black",
      "pr_number": 3451,
      "file_path": "tests/test_format.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,13 @@ def test_docstring_no_string_normalization() -> None:\n     assert_format(source, expected, mode)\n \n \n+def test_docstring_line_length_6() -> None:\n+    \"\"\"Like test_docstring but with string normalization off.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"Like test_docstring but with line length set to 6.\"\"\"\r\n```",
      "comment_id": 1052804574,
      "user": "JelleZijlstra",
      "created_at": "2022-12-20T02:07:05Z",
      "url": "https://github.com/psf/black/pull/3451#discussion_r1052804574"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 335,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                leaf.value = prefix + quote + docstring + quote\n+            else:",
      "comment": "This should be the other way around, no? The idea is that if preview is enabled, we do the new thing.",
      "comment_id": 865291195,
      "user": "felix-hilden",
      "created_at": "2022-05-04T20:01:09Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865291195"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 310,
      "side": "LEFT",
      "diff_hunk": "@@ -305,9 +305,9 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n             quote_len = 1 if docstring[1] != quote_char else 3\n             docstring = docstring[quote_len:-quote_len]\n             docstring_started_empty = not docstring\n+            indent = \" \" * 4 * self.current_line.depth\n \n             if is_multiline_string(leaf):\n-                indent = \" \" * 4 * self.current_line.depth",
      "comment": "This should most likely also have the preview check, or I've missed some context.",
      "comment_id": 865293300,
      "user": "felix-hilden",
      "created_at": "2022-05-04T20:02:26Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865293300"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 310,
      "side": "LEFT",
      "diff_hunk": "@@ -305,9 +305,9 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n             quote_len = 1 if docstring[1] != quote_char else 3\n             docstring = docstring[quote_len:-quote_len]\n             docstring_started_empty = not docstring\n+            indent = \" \" * 4 * self.current_line.depth\n \n             if is_multiline_string(leaf):\n-                indent = \" \" * 4 * self.current_line.depth",
      "comment": "It doesn't make any difference to the output, as if it is a multiline string then it's identical, and otherwise indent doesn't get used. I can put it in the preview if you like? Is the idea of the preview to keep all the code the same unless previewing or just keep the formatting the same?",
      "comment_id": 865326552,
      "user": "idorrington92",
      "created_at": "2022-05-04T20:23:25Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865326552"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 335,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                leaf.value = prefix + quote + docstring + quote\n+            else:",
      "comment": "I've fixed this now. Changed a test to have the old incorrect formatting as well",
      "comment_id": 865338786,
      "user": "idorrington92",
      "created_at": "2022-05-04T20:30:09Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865338786"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 310,
      "side": "LEFT",
      "diff_hunk": "@@ -305,9 +305,9 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n             quote_len = 1 if docstring[1] != quote_char else 3\n             docstring = docstring[quote_len:-quote_len]\n             docstring_started_empty = not docstring\n+            indent = \" \" * 4 * self.current_line.depth\n \n             if is_multiline_string(leaf):\n-                indent = \" \" * 4 * self.current_line.depth",
      "comment": "Right, that was the missing context then \ud83d\ude04 It's a-ok! Having all refactors in preview would be.. not good. Just the formatting \ud83d\udc4d ",
      "comment_id": 865339874,
      "user": "felix-hilden",
      "created_at": "2022-05-04T20:31:23Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865339874"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 335,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                leaf.value = prefix + quote + docstring + quote\n+            else:",
      "comment": "Please add the tests to a dedicated file and name that file [here](https://github.com/psf/black/blob/main/tests/test_format.py#L80) so we can test with preview on!",
      "comment_id": 865343587,
      "user": "felix-hilden",
      "created_at": "2022-05-04T20:35:42Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865343587"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 335,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                leaf.value = prefix + quote + docstring + quote\n+            else:",
      "comment": "Do you want the tests in the new file and the old file?",
      "comment_id": 865376246,
      "user": "idorrington92",
      "created_at": "2022-05-04T20:52:18Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865376246"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 335,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                leaf.value = prefix + quote + docstring + quote\n+            else:",
      "comment": "I assume you want the old tests as well so I've kept them in",
      "comment_id": 865380356,
      "user": "idorrington92",
      "created_at": "2022-05-04T20:58:11Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865380356"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "tests/test_format.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,6 +91,7 @@\n     \"one_element_subscript\",\n     \"remove_await_parens\",\n     \"return_annotation_brackets\",\n+    \"docstring2\",",
      "comment": "```suggestion\r\n    \"docstring_preview\",\r\n```\r\nor `docstring_quotes` or similar if we want to be more precise. Would make it more explicit why the files were split.",
      "comment_id": 865380828,
      "user": "felix-hilden",
      "created_at": "2022-05-04T20:58:48Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865380828"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                # Put closing quotes on new line if max line length exceeded\n+                last_line_length = len(docstring.splitlines()[-1]) if docstring else 0\n+\n+                # Make the docstring apart from the closing quotes, which happen below\n+                docstring = prefix + quote + docstring\n+                if (\n+                    len(indent) + len(prefix) + 2 * len(quote) + last_line_length\n+                    <= self.mode.line_length\n+                ):",
      "comment": "I've tried to think this through, but I'm not 100 % still. Wouldn't this be incorrect if we had a multiline docstring whose last line was just acceptable? We would sum the prefix and quote length to it and refuse to add quotes at the end.\r\n\r\n```python\r\ndef foo():\r\n    \"\"\"first line---------------------------------------------------------------\r\n\r\n    second line--------------------------------------------------------------\"\"\"\r\n```\r\n\r\nIn any case, a test about this would be nice too.",
      "comment_id": 865383225,
      "user": "felix-hilden",
      "created_at": "2022-05-04T21:02:18Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865383225"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                # Put closing quotes on new line if max line length exceeded\n+                last_line_length = len(docstring.splitlines()[-1]) if docstring else 0\n+\n+                # Make the docstring apart from the closing quotes, which happen below\n+                docstring = prefix + quote + docstring\n+                if (\n+                    len(indent) + len(prefix) + 2 * len(quote) + last_line_length\n+                    <= self.mode.line_length\n+                ):",
      "comment": "You were right. There were two issues with my original code, the last_line_length actually included the indent for docstrings of more than one line. I fixed this issue by using lstrip first. The other issue is that if the docstring has more than one line then we only have one set of quotes so we shouldn't multiply it by two. The logic is a bit more complicated now, but I've added the example above as a test and it works fine now. \r\n\r\nThanks for the good spot :p ",
      "comment_id": 865406160,
      "user": "idorrington92",
      "created_at": "2022-05-04T21:37:50Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865406160"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                # Put closing quotes on new line if max line length exceeded\n+                last_line_length = len(docstring.splitlines()[-1]) if docstring else 0\n+\n+                # Make the docstring apart from the closing quotes, which happen below\n+                docstring = prefix + quote + docstring\n+                if (\n+                    len(indent) + len(prefix) + 2 * len(quote) + last_line_length\n+                    <= self.mode.line_length\n+                ):",
      "comment": "Nice \ud83d\udc4d looking at the new code: are you sure that the prefix doesn't affect the calculation similarly? Should we instead only calculate the line length once? Since we only really care about the last one, perhaps something like:\r\n\r\n```python\r\nlines = docstring.splitlines()\r\nlast_line_len = len(lines[-1])\r\nif len(lines) == 1:\r\n    last_line_len += len(indent) + len(prefix) + quote_len\r\n\r\nif last_line_len + quote_len > max_len:\r\n    # add newline\r\n...\r\n```\r\n\r\nI'm not sure how the indentation matters if we strip it only to add it back. Maybe that could simplify it a bit. But I might be disregarding some details.",
      "comment_id": 865418930,
      "user": "felix-hilden",
      "created_at": "2022-05-04T21:57:47Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r865418930"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                # Put closing quotes on new line if max line length exceeded\n+                last_line_length = len(docstring.splitlines()[-1]) if docstring else 0\n+\n+                # Make the docstring apart from the closing quotes, which happen below\n+                docstring = prefix + quote + docstring\n+                if (\n+                    len(indent) + len(prefix) + 2 * len(quote) + last_line_length\n+                    <= self.mode.line_length\n+                ):",
      "comment": "I was pretty tired when working on this last night, that's my excuse for missing the prefix :p \r\nI think it's all sorted now. I've added some tests with prefixes now just to be sure. I've also refactored it how you suggest and added in some (possibly excessive) comments to explain exactly why we're doing all this.\r\n\r\nThanks for your help :) ",
      "comment_id": 866307872,
      "user": "idorrington92",
      "created_at": "2022-05-05T20:56:40Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r866307872"
    },
    {
      "repo": "psf/black",
      "pr_number": 3044,
      "file_path": "src/black/linegen.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -329,7 +329,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n \n             # We could enforce triple quotes at this point.\n             quote = quote_char * quote_len\n-            leaf.value = prefix + quote + docstring + quote\n+\n+            if Preview.long_docstring_quotes_on_newline in self.mode:\n+                # Put closing quotes on new line if max line length exceeded\n+                last_line_length = len(docstring.splitlines()[-1]) if docstring else 0\n+\n+                # Make the docstring apart from the closing quotes, which happen below\n+                docstring = prefix + quote + docstring\n+                if (\n+                    len(indent) + len(prefix) + 2 * len(quote) + last_line_length\n+                    <= self.mode.line_length\n+                ):",
      "comment": "No worries! Thanks for being so quick with the edits \ud83d\udc4d",
      "comment_id": 866528324,
      "user": "felix-hilden",
      "created_at": "2022-05-06T06:36:11Z",
      "url": "https://github.com/psf/black/pull/3044#discussion_r866528324"
    },
    {
      "repo": "psf/black",
      "pr_number": 3474,
      "file_path": "tests/data/preview/prefer_rhs_split.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +50,7 @@\n     forth_item,\n     fifth_item,\n     last_item_very_loooooong,\n-) = everyting = some_loooooog_function_name(\n+) = everything = some_loooooog_function_name(",
      "comment": "```suggestion\r\n) = everything = some_looooong_function_name(\r\n```\r\nWhile we're changing this",
      "comment_id": 1056998085,
      "user": "JelleZijlstra",
      "created_at": "2022-12-25T21:08:47Z",
      "url": "https://github.com/psf/black/pull/3474#discussion_r1056998085"
    },
    {
      "repo": "psf/black",
      "pr_number": 3423,
      "file_path": "tests/util.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,12 +71,46 @@ def assert_format(\n     safety guards so they don't just crash with a SyntaxError. Please note this is\n     separate from TargetVerson Mode configuration.\n     \"\"\"\n+    _assert_format_inner(\n+        source, expected, mode, fast=fast, minimum_version=minimum_version\n+    )\n+\n+    # For both preview and non-preview tests, ensure that Black doesn't crash on\n+    # this code, but don't pass \"expected\" because the precise output may differ.\n+    _assert_format_inner(\n+        source,\n+        None,\n+        replace(mode, preview=not mode.preview),\n+        fast=fast,\n+        minimum_version=minimum_version,\n+    )\n+    # Similarly, setting line length to 1 is a good way to catch\n+    # stability bugs. But only in non-preview mode because preview mode\n+    # currently has a lot of line length 1 bugs.\n+    _assert_format_inner(\n+        source,\n+        None,\n+        replace(mode, preview=False, line_length=1),\n+        fast=fast,\n+        minimum_version=minimum_version,\n+    )\n+\n+\n+def _assert_format_inner(\n+    source: str,\n+    expected: Optional[str] = None,\n+    mode: black.Mode = DEFAULT_MODE,\n+    *,\n+    fast: bool = False,\n+    minimum_version: Optional[Tuple[int, int]] = None,\n+) -> None:\n     actual = black.format_str(source, mode=mode)\n-    _assert_format_equal(expected, actual)\n+    if expected is not None:\n+        _assert_format_equal(expected, actual)\n     # It's not useful to run safety checks if we're expecting no changes anyway. The\n     # assertion right above will raise if reality does actually make changes. This just\n     # avoids wasted CPU cycles.",
      "comment": "```suggestion\r\n```\r\nUnfortunately this optimization is now gone and I can't find a way to bring it back :(",
      "comment_id": 1047983856,
      "user": "ichard26",
      "created_at": "2022-12-14T03:46:27Z",
      "url": "https://github.com/psf/black/pull/3423#discussion_r1047983856"
    },
    {
      "repo": "psf/black",
      "pr_number": 3440,
      "file_path": "src/black/trans.py",
      "line": 1963,
      "side": "RIGHT",
      "diff_hunk": "@@ -1951,6 +1954,25 @@ def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n                     f\" (left_leaves={left_leaves}, right_leaves={right_leaves})\"\n                 )\n                 old_rpar_leaf = right_leaves.pop()\n+            elif right_leaves and right_leaves[-1].type == token.RPAR:\n+                # Special case for lambda expressions as dict's value, e.g.:\n+                #     my_dict = {\n+                #        \"key\": lambda x: f\"formatted: {x},\n+                #     }\n+                # After wrapping the dict's value with parentheses, the string is\n+                # followed by a RPAR but it's opening bracket is lambda's, not",
      "comment": "```suggestion\r\n                # followed by a RPAR but its opening bracket is lambda's, not\r\n```",
      "comment_id": 1049137001,
      "user": "JelleZijlstra",
      "created_at": "2022-12-15T01:53:44Z",
      "url": "https://github.com/psf/black/pull/3440#discussion_r1049137001"
    },
    {
      "repo": "psf/black",
      "pr_number": 3440,
      "file_path": "src/black/trans.py",
      "line": 1856,
      "side": "RIGHT",
      "diff_hunk": "@@ -1841,22 +1843,23 @@ def _assign_match(LL: List[Leaf]) -> Optional[int]:\n         return None\n \n     @staticmethod\n-    def _dict_match(LL: List[Leaf]) -> Optional[int]:\n+    def _dict_or_lambda_match(LL: List[Leaf]) -> Optional[int]:\n         \"\"\"\n         Returns:\n             string_idx such that @LL[string_idx] is equal to our target (i.e.\n             matched) string, if this line matches the dictionary key assignment\n-            statement requirements listed in the 'Requirements' section of this\n-            classes' docstring.\n+            statement or lambda expression requirements listed in the\n+            'Requirements' section of this classes' docstring.\n                 OR\n             None, otherwise.\n         \"\"\"\n-        # If this line is apart of a dictionary key assignment...\n-        if syms.dictsetmaker in [parent_type(LL[0]), parent_type(LL[0].parent)]:\n+        # If this line is apart of a dictionary key assignment or lambda expression...",
      "comment": "```suggestion\r\n        # If this line is a part of a dictionary key assignment or lambda expression...\r\n```",
      "comment_id": 1049137090,
      "user": "JelleZijlstra",
      "created_at": "2022-12-15T01:53:59Z",
      "url": "https://github.com/psf/black/pull/3440#discussion_r1049137090"
    },
    {
      "repo": "psf/black",
      "pr_number": 3370,
      "file_path": "src/black/linegen.py",
      "line": 758,
      "side": "RIGHT",
      "diff_hunk": "@@ -715,15 +739,23 @@ def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None\n \n \n def bracket_split_build_line(\n-    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False\n+    leaves: List[Leaf],\n+    original: Line,\n+    opening_bracket: Leaf,\n+    *,\n+    component: _BracketSplitComponent,\n ) -> Line:\n     \"\"\"Return a new line with given `leaves` and respective comments from `original`.\n \n-    If `is_body` is True, the result line is one-indented inside brackets and as such\n-    has its first leaf's prefix normalized and a trailing comma added when expected.\n+    If it's the head component, brackets will be tracked so trailing commas are\n+    respected.\n+\n+    If it's the body component, the result line is one-indented inside brackets and as\n+    such has its first leaf's prefix normalized and a trailing comma added when\n+    expected.\n     \"\"\"\n     result = Line(mode=original.mode, depth=original.depth)\n-    if is_body:\n+    if component == _BracketSplitComponent.body:",
      "comment": "```suggestion\r\n    if component is _BracketSplitComponent.body:\r\n```\r\nNit: use `is` for comparing enums.",
      "comment_id": 1016849457,
      "user": "JelleZijlstra",
      "created_at": "2022-11-08T16:19:38Z",
      "url": "https://github.com/psf/black/pull/3370#discussion_r1016849457"
    },
    {
      "repo": "psf/black",
      "pr_number": 3370,
      "file_path": "src/black/linegen.py",
      "line": 799,
      "side": "RIGHT",
      "diff_hunk": "@@ -761,12 +793,24 @@ def bracket_split_build_line(\n                         leaves.insert(i + 1, new_comma)\n                     break\n \n+    leaves_to_track: Set[LeafID] = set()\n+    if (\n+        Preview.handle_trailing_commas_in_head in original.mode\n+        and component == _BracketSplitComponent.head",
      "comment": "```suggestion\r\n        and component is _BracketSplitComponent.head\r\n```",
      "comment_id": 1016849625,
      "user": "JelleZijlstra",
      "created_at": "2022-11-08T16:19:47Z",
      "url": "https://github.com/psf/black/pull/3370#discussion_r1016849625"
    },
    {
      "repo": "psf/black",
      "pr_number": 3370,
      "file_path": "src/black/linegen.py",
      "line": 811,
      "side": "RIGHT",
      "diff_hunk": "@@ -761,12 +793,24 @@ def bracket_split_build_line(\n                         leaves.insert(i + 1, new_comma)\n                     break\n \n+    leaves_to_track: Set[LeafID] = set()\n+    if (\n+        Preview.handle_trailing_commas_in_head in original.mode\n+        and component == _BracketSplitComponent.head\n+    ):\n+        leaves_to_track = get_leaves_inside_matching_brackets(leaves)\n     # Populate the line\n     for leaf in leaves:\n-        result.append(leaf, preformatted=True)\n+        result.append(\n+            leaf,\n+            preformatted=True,\n+            track_bracket=id(leaf) in leaves_to_track,\n+        )\n         for comment_after in original.comments_after(leaf):\n             result.append(comment_after, preformatted=True)\n-    if is_body and should_split_line(result, opening_bracket):\n+    if component == _BracketSplitComponent.body and should_split_line(",
      "comment": "```suggestion\r\n    if component is _BracketSplitComponent.body and should_split_line(\r\n```",
      "comment_id": 1016849798,
      "user": "JelleZijlstra",
      "created_at": "2022-11-08T16:19:57Z",
      "url": "https://github.com/psf/black/pull/3370#discussion_r1016849798"
    },
    {
      "repo": "psf/black",
      "pr_number": 3307,
      "file_path": "src/black/trans.py",
      "line": 1067,
      "side": "RIGHT",
      "diff_hunk": "@@ -1062,6 +1062,7 @@ def _prefer_paren_wrap_match(LL: List[Leaf]) -> Optional[int]:\n             syms.listmaker,\n             syms.dictsetmaker,\n             syms.testlist_gexp,\n+            syms.arglist,\n         ]\n         # If the string is an immediate child of a list/set/tuple literal...",
      "comment": "Should update this comment.\r\n\r\nAlso, since we're now adding parens in basically all contexts, could we get rid of `matching_nodes` entirely?",
      "comment_id": 1005127662,
      "user": "JelleZijlstra",
      "created_at": "2022-10-26T01:33:25Z",
      "url": "https://github.com/psf/black/pull/3307#discussion_r1005127662"
    },
    {
      "repo": "psf/black",
      "pr_number": 3348,
      "file_path": "tests/test_black.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,6 +154,27 @@ def test_empty_ff(self) -> None:\n             os.unlink(tmp_file)\n         self.assertFormatEqual(expected, actual)\n \n+    @patch(\"black.dump_to_file\", dump_to_stderr)\n+    def test_one_empty_line(self) -> None:\n+        for nl in [\"\\n\", \"\\r\\n\"]:\n+            source = expected = nl\n+            actual = fs(source)\n+            self.assertFormatEqual(expected, actual)\n+            black.assert_equivalent(source, actual)\n+            black.assert_stable(source, actual, DEFAULT_MODE)\n+\n+    def test_one_empty_line_ff(self) -> None:\n+        for nl in [\"\\n\", \"\\r\\n\"]:\n+            expected = nl\n+            tmp_file = Path(black.dump_to_file(nl))\n+            try:\n+                self.assertFalse(ff(tmp_file, write_back=black.WriteBack.YES))\n+                with open(tmp_file, \"rb\") as f:\n+                    actual = f.read().decode(\"utf8\")\n+            finally:\n+                os.unlink(tmp_file)\n+            self.assertFormatEqual(expected, actual)",
      "comment": "The tests failing on Windows seem to confirm that writing a newline actually writes a `\\r\\n` instead of `\\n`.\r\n\r\n```\r\nExpected tree:\r\nfile_input\r\n  ENDMARKER '\\n' ''\r\n/file_input\r\nActual tree:\r\nfile_input\r\n  ENDMARKER '\\r\\n' ''\r\n/file_input\r\n```\r\n\r\nI'm getting this on Windows:\r\n\r\n```python\r\n>>> with open(\"temp.py\", \"w\") as f:\r\n...     f.write(\"\\n\")\r\n...\r\n1\r\n>>>\r\n>>> with open(\"temp.py\", \"rb\") as f:\r\n...     print(f.read())\r\n...\r\nb'\\r\\n'                \r\n```",
      "comment_id": 1002233432,
      "user": "aaossa",
      "created_at": "2022-10-21T22:55:42Z",
      "url": "https://github.com/psf/black/pull/3348#discussion_r1002233432"
    },
    {
      "repo": "psf/black",
      "pr_number": 3348,
      "file_path": "tests/test_black.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,6 +154,27 @@ def test_empty_ff(self) -> None:\n             os.unlink(tmp_file)\n         self.assertFormatEqual(expected, actual)\n \n+    @patch(\"black.dump_to_file\", dump_to_stderr)\n+    def test_one_empty_line(self) -> None:\n+        for nl in [\"\\n\", \"\\r\\n\"]:\n+            source = expected = nl\n+            actual = fs(source)\n+            self.assertFormatEqual(expected, actual)\n+            black.assert_equivalent(source, actual)\n+            black.assert_stable(source, actual, DEFAULT_MODE)\n+\n+    def test_one_empty_line_ff(self) -> None:\n+        for nl in [\"\\n\", \"\\r\\n\"]:\n+            expected = nl\n+            tmp_file = Path(black.dump_to_file(nl))\n+            try:\n+                self.assertFalse(ff(tmp_file, write_back=black.WriteBack.YES))\n+                with open(tmp_file, \"rb\") as f:\n+                    actual = f.read().decode(\"utf8\")\n+            finally:\n+                os.unlink(tmp_file)\n+            self.assertFormatEqual(expected, actual)",
      "comment": "The issue goes away if the file is written in binary mode:\r\n\r\n```python\r\n>>> with open(\"temp.py\", \"wb\") as f:\r\n...     f.write(b\"\\n\")\r\n...\r\n1\r\n>>> with open(\"temp.py\", \"rb\") as f:\r\n...     print(f.read())\r\n...\r\nb'\\n'                \r\n```\r\n\r\nI'll keep investigating. This may be affecting other tests without us noticing, because behavior on Windows might be tested incorrectly",
      "comment_id": 1002235414,
      "user": "aaossa",
      "created_at": "2022-10-21T22:58:51Z",
      "url": "https://github.com/psf/black/pull/3348#discussion_r1002235414"
    },
    {
      "repo": "psf/black",
      "pr_number": 3348,
      "file_path": "tests/test_black.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,6 +154,27 @@ def test_empty_ff(self) -> None:\n             os.unlink(tmp_file)\n         self.assertFormatEqual(expected, actual)\n \n+    @patch(\"black.dump_to_file\", dump_to_stderr)\n+    def test_one_empty_line(self) -> None:\n+        for nl in [\"\\n\", \"\\r\\n\"]:\n+            source = expected = nl\n+            actual = fs(source)\n+            self.assertFormatEqual(expected, actual)\n+            black.assert_equivalent(source, actual)\n+            black.assert_stable(source, actual, DEFAULT_MODE)\n+\n+    def test_one_empty_line_ff(self) -> None:\n+        for nl in [\"\\n\", \"\\r\\n\"]:\n+            expected = nl\n+            tmp_file = Path(black.dump_to_file(nl))\n+            try:\n+                self.assertFalse(ff(tmp_file, write_back=black.WriteBack.YES))\n+                with open(tmp_file, \"rb\") as f:\n+                    actual = f.read().decode(\"utf8\")\n+            finally:\n+                os.unlink(tmp_file)\n+            self.assertFormatEqual(expected, actual)",
      "comment": "Ok, so if I change `dump_to_file` to writing files in binary mode, all the tests are passed (for Ubuntu, Windows, and macOS). The downside is that in Windows, it might introduce an unexpected behavior, because under normal conditions we expect `dump_to_file` to write files using the correct newline (`\\r\\n`). I'm not sure if this is a bug.\r\n\r\nAnother solution could be write the file directly in the test that makes the \"bug\" visible, but might be non-intuitive. In the meantime, I'll remove the commit that tested this. This is the change that I applied (described in the first paragraph):\r\n\r\n```diff\r\ndiff --git a/src/black/output.py b/src/black/output.py\r\nindex f4c17f28ea..19a178e89d 100644\r\n--- a/src/black/output.py\r\n+++ b/src/black/output.py\r\n@@ -96,10 +96,10 @@ def color_diff(contents: str) -> str:\r\n def dump_to_file(*output: str, ensure_final_newline: bool = True) -> str:\r\n     \"\"\"Dump `output` to a temporary file. Return path to the file.\"\"\"\r\n     with tempfile.NamedTemporaryFile(\r\n-        mode=\"w\", prefix=\"blk_\", suffix=\".log\", delete=False, encoding=\"utf8\"\r\n+        mode=\"wb\", prefix=\"blk_\", suffix=\".log\", delete=False\r\n     ) as f:\r\n         for lines in output:\r\n-            f.write(lines)\r\n+            f.write(lines.encode(\"utf8\"))\r\n             if ensure_final_newline and lines and lines[-1] != \"\\n\":\r\n-                f.write(\"\\n\")\r\n+                f.write(\"\\n\".encode(\"utf8\"))\r\n     return f.name\r\n```",
      "comment_id": 1002268435,
      "user": "aaossa",
      "created_at": "2022-10-22T00:08:34Z",
      "url": "https://github.com/psf/black/pull/3348#discussion_r1002268435"
    },
    {
      "repo": "psf/black",
      "pr_number": 3348,
      "file_path": "tests/test_black.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,6 +154,27 @@ def test_empty_ff(self) -> None:\n             os.unlink(tmp_file)\n         self.assertFormatEqual(expected, actual)\n \n+    @patch(\"black.dump_to_file\", dump_to_stderr)\n+    def test_one_empty_line(self) -> None:\n+        for nl in [\"\\n\", \"\\r\\n\"]:\n+            source = expected = nl\n+            actual = fs(source)\n+            self.assertFormatEqual(expected, actual)\n+            black.assert_equivalent(source, actual)\n+            black.assert_stable(source, actual, DEFAULT_MODE)\n+\n+    def test_one_empty_line_ff(self) -> None:\n+        for nl in [\"\\n\", \"\\r\\n\"]:\n+            expected = nl\n+            tmp_file = Path(black.dump_to_file(nl))\n+            try:\n+                self.assertFalse(ff(tmp_file, write_back=black.WriteBack.YES))\n+                with open(tmp_file, \"rb\") as f:\n+                    actual = f.read().decode(\"utf8\")\n+            finally:\n+                os.unlink(tmp_file)\n+            self.assertFormatEqual(expected, actual)",
      "comment": "Patched the test by explicitly rewriting the temporary file in binary mode on Windows only:\r\n\r\n```diff\r\ndiff --git a/tests/test_black.py b/tests/test_black.py\r\nindex b49830f..9ae17af 100644\r\n--- a/tests/test_black.py\r\n+++ b/tests/test_black.py\r\n@@ -167,6 +167,12 @@ class BlackTestCase(BlackBaseTestCase):\r\n         for nl in [\"\\n\", \"\\r\\n\"]:\r\n             expected = nl\r\n             tmp_file = Path(black.dump_to_file(nl))\r\n+            if system() == \"Windows\":\r\n+                # Writing files in text mode automatically uses the system newline,\r\n+                # but in this case we don't want this for testing reasons. See:\r\n+                # https://github.com/psf/black/pull/3348\r\n+                with open(tmp_file, \"wb\") as f:\r\n+                    f.write(nl.encode(\"utf-8\"))\r\n             try:\r\n                 self.assertFalse(ff(tmp_file, write_back=black.WriteBack.YES))\r\n                 with open(tmp_file, \"rb\") as f:\r\n```",
      "comment_id": 1003705066,
      "user": "aaossa",
      "created_at": "2022-10-24T20:06:22Z",
      "url": "https://github.com/psf/black/pull/3348#discussion_r1003705066"
    },
    {
      "repo": "psf/black",
      "pr_number": 3348,
      "file_path": "src/black/__init__.py",
      "line": 1112,
      "side": "RIGHT",
      "diff_hunk": "@@ -1103,6 +1106,11 @@ def _format_str_once(src_contents: str, *, mode: Mode) -> str:\n     dst_contents = []\n     for block in dst_blocks:\n         dst_contents.extend(block.all_lines())\n+    if mode.preview and not dst_contents:\n+        normalized_content, _, newline = decode_bytes(src_contents.encode(\"utf-8\"))",
      "comment": "This feels a bit janky to using `decode_bytes` like this, but I can't think of anything better. Could we add a comment to this whole logic explaining what it does?",
      "comment_id": 1019774015,
      "user": "ichard26",
      "created_at": "2022-11-11T02:22:05Z",
      "url": "https://github.com/psf/black/pull/3348#discussion_r1019774015"
    },
    {
      "repo": "psf/black",
      "pr_number": 3348,
      "file_path": "tests/test_black.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,6 +154,37 @@ def test_empty_ff(self) -> None:\n             os.unlink(tmp_file)\n         self.assertFormatEqual(expected, actual)\n \n+    @patch(\"black.dump_to_file\", dump_to_stderr)\n+    def test_one_empty_line(self) -> None:\n+        mode = black.Mode(preview=True)\n+        for nl in [\"\\n\", \"\\r\\n\"]:\n+            source = expected = nl\n+            actual = fs(source, mode=mode)",
      "comment": "Could we use `tests.util.assert_format()` to clean this up? ",
      "comment_id": 1019775518,
      "user": "ichard26",
      "created_at": "2022-11-11T02:26:00Z",
      "url": "https://github.com/psf/black/pull/3348#discussion_r1019775518"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,15 +211,27 @@ def gen_python_files(\n \n     `report` is where output about exclusions goes.\n     \"\"\"\n+\n+    def is_ignored(\n+        gitignore_dict: Dict[Path, PathSpec], child: Path, report: Report\n+    ) -> bool:\n+        for _dir, _gitignore in gitignore_dict.items():\n+            relative_path = normalize_path_maybe_ignore(child, _dir, report)\n+            if relative_path is None:\n+                continue",
      "comment": "Seems like `return False` is a better alternative since a symlink that goes back inside root should be ignored (at least seems to be ignored now).\r\n\r\n**EDIT:** Seems like that case would already be ignored, but I thinks it's better to stop execution when necessary",
      "comment_id": 998047050,
      "user": "aaossa",
      "created_at": "2022-10-18T10:54:52Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r998047050"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,15 +211,27 @@ def gen_python_files(\n \n     `report` is where output about exclusions goes.\n     \"\"\"\n+\n+    def is_ignored(\n+        gitignore_dict: Dict[Path, PathSpec], child: Path, report: Report\n+    ) -> bool:\n+        for _dir, _gitignore in gitignore_dict.items():\n+            relative_path = normalize_path_maybe_ignore(child, _dir, report)\n+            if relative_path is None:\n+                continue",
      "comment": "Yeah, seems like the `continue` produces additional unnecessary output. I'll replace it with `break` so that the function returns `False`",
      "comment_id": 1000839355,
      "user": "aaossa",
      "created_at": "2022-10-20T16:06:47Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1000839355"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 263,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,6 +256,11 @@ def gen_python_files(\n         if child.is_dir():\n             # If gitignore is None, gitignore usage is disabled, while a Falsey\n             # gitignore is when the directory doesn't have a .gitignore file.\n+            if gitignore is None:\n+                _gitignore = None\n+            else:\n+                _gitignore = gitignore.copy()\n+                _gitignore[child] = get_gitignore(child)",
      "comment": "I'll also use the path from root (`root / child`) to the corresponding .gitignore. This solves producing additional and incorrect output when running black on a directory \ud83d\udc4c Change also applied on `src/black/__init__.py` (key `p` in the `_gitignore` dictionary was changed to `root / p`)",
      "comment_id": 1000877023,
      "user": "aaossa",
      "created_at": "2022-10-20T16:43:03Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1000877023"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "tests/test_black.py",
      "line": 2059,
      "side": "RIGHT",
      "diff_hunk": "@@ -2056,6 +2056,24 @@ def test_invalid_nested_gitignore(self) -> None:\n         gitignore = path / \"a\" / \".gitignore\"\n         assert f\"Could not parse {gitignore}\" in result.stderr_bytes.decode()\n \n+    def test_gitignore_that_ignores_subfolders(self) -> None:",
      "comment": "Added a test case where the target folder was different to the root.",
      "comment_id": 1000885840,
      "user": "aaossa",
      "created_at": "2022-10-20T16:52:25Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1000885840"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/__init__.py",
      "line": 668,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,14 +662,14 @@ def get_sources(\n         elif p.is_dir():\n             if exclude is None:\n                 exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n-                gitignore = get_gitignore(root)\n+                root_gitignore = get_gitignore(root)\n                 p_gitignore = get_gitignore(p)\n                 # No need to use p's gitignore if it is identical to root's gitignore\n                 # (i.e. root and p point to the same directory).",
      "comment": "What if there are more than two levels? For example, we're formatting `a/b/c/` and `a/.gitignore/`, `a/b/.gitignore`, and `a/b/c/.gitignore` all exist.",
      "comment_id": 1005120484,
      "user": "JelleZijlstra",
      "created_at": "2022-10-26T01:14:20Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1005120484"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,15 +211,27 @@ def gen_python_files(\n \n     `report` is where output about exclusions goes.\n     \"\"\"\n+\n+    def is_ignored(",
      "comment": "Doesn't seem like this needs to be a nested function.",
      "comment_id": 1005120876,
      "user": "JelleZijlstra",
      "created_at": "2022-10-26T01:15:15Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1005120876"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -198,7 +198,7 @@ def gen_python_files(\n     extend_exclude: Optional[Pattern[str]],\n     force_exclude: Optional[Pattern[str]],\n     report: Report,\n-    gitignore: Optional[PathSpec],\n+    gitignore: Optional[Dict[Path, PathSpec]],",
      "comment": "Would suggest renaming this to `gitignore_dict` for clarity. Also, no reason to keep this Optional, we can just use an empty dict if there's no gitignores.",
      "comment_id": 1005121008,
      "user": "JelleZijlstra",
      "created_at": "2022-10-26T01:15:43Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1005121008"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 263,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,6 +256,11 @@ def gen_python_files(\n         if child.is_dir():\n             # If gitignore is None, gitignore usage is disabled, while a Falsey\n             # gitignore is when the directory doesn't have a .gitignore file.\n+            if gitignore is None:\n+                _gitignore = None\n+            else:\n+                _gitignore = gitignore.copy()\n+                _gitignore[root / child] = get_gitignore(child)",
      "comment": "Can do `new_gitignore = {**gitignore, root / child: get_gitignore(child)}`.\r\n\r\nI'd avoid using leading underscores for locals; better to give an informative name.",
      "comment_id": 1005121770,
      "user": "JelleZijlstra",
      "created_at": "2022-10-26T01:17:41Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1005121770"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/__init__.py",
      "line": 668,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,14 +662,14 @@ def get_sources(\n         elif p.is_dir():\n             if exclude is None:\n                 exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n-                gitignore = get_gitignore(root)\n+                root_gitignore = get_gitignore(root)\n                 p_gitignore = get_gitignore(p)\n                 # No need to use p's gitignore if it is identical to root's gitignore\n                 # (i.e. root and p point to the same directory).",
      "comment": "Good question. Right now, if the command is `black a/b/c/` then `a/b/.gitignore` is completely skipped while `a/.gitignore` and `a/b/c/.gitignore` are captured by `root_gitignore` and `p_gitignore`, respectively. What's the expected behavior?",
      "comment_id": 1006116521,
      "user": "aaossa",
      "created_at": "2022-10-26T19:41:27Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1006116521"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -198,7 +198,7 @@ def gen_python_files(\n     extend_exclude: Optional[Pattern[str]],\n     force_exclude: Optional[Pattern[str]],\n     report: Report,\n-    gitignore: Optional[PathSpec],\n+    gitignore: Optional[Dict[Path, PathSpec]],",
      "comment": "`gitignore` can be `None` if `exclude` is not `None`. In that case, no gitignore is considered at any level. I though that this is the expected behavior while reading the code. If `get_sources` receives a value for `exclude`, what's the expected behavior?\r\n\r\nAbout renaming the variable: I agree \ud83d\udc4d ",
      "comment_id": 1006118586,
      "user": "aaossa",
      "created_at": "2022-10-26T19:43:56Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1006118586"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,15 +211,27 @@ def gen_python_files(\n \n     `report` is where output about exclusions goes.\n     \"\"\"\n+\n+    def is_ignored(",
      "comment": "Using a nested function allows me to short-circuit if a match is found and break the outer loop (`for child in paths:`) with its result. Using `continue` in an inner loop just jumps to the next iteration in that loop. Using `break` might help, but how to know if there was actually a match or not (breaking because `relative_path is None` or because there was a match)? I think that using a nested function makes it easier to read/understand.",
      "comment_id": 1006124768,
      "user": "aaossa",
      "created_at": "2022-10-26T19:50:58Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1006124768"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/__init__.py",
      "line": 668,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,14 +662,14 @@ def get_sources(\n         elif p.is_dir():\n             if exclude is None:\n                 exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n-                gitignore = get_gitignore(root)\n+                root_gitignore = get_gitignore(root)\n                 p_gitignore = get_gitignore(p)\n                 # No need to use p's gitignore if it is identical to root's gitignore\n                 # (i.e. root and p point to the same directory).",
      "comment": "Should this be a separate issue/PR? If its an undefined behavior, then it should be documented properly I think ",
      "comment_id": 1012088079,
      "user": "aaossa",
      "created_at": "2022-11-02T17:25:13Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1012088079"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/__init__.py",
      "line": 669,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,14 +662,14 @@ def get_sources(\n         elif p.is_dir():\n             if exclude is None:\n                 exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n-                gitignore = get_gitignore(root)\n+                root_gitignore = get_gitignore(root)\n                 p_gitignore = get_gitignore(p)\n                 # No need to use p's gitignore if it is identical to root's gitignore\n                 # (i.e. root and p point to the same directory).\n-                if gitignore != p_gitignore:\n-                    gitignore += p_gitignore\n-            else:\n-                gitignore = None\n+                if root_gitignore == p_gitignore:",
      "comment": "Check if this is still necessary. If two set of rules are equal, it's still possible that they produce different results because they're in different locations. Might be better to compare the paths ",
      "comment_id": 1012742057,
      "user": "aaossa",
      "created_at": "2022-11-03T10:46:28Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1012742057"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/__init__.py",
      "line": 668,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,14 +662,14 @@ def get_sources(\n         elif p.is_dir():\n             if exclude is None:\n                 exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n-                gitignore = get_gitignore(root)\n+                root_gitignore = get_gitignore(root)\n                 p_gitignore = get_gitignore(p)\n                 # No need to use p's gitignore if it is identical to root's gitignore\n                 # (i.e. root and p point to the same directory).",
      "comment": "> What if there are more than two levels? For example, we're formatting `a/b/c/` and `a/.gitignore/`, `a/b/.gitignore`, and `a/b/c/.gitignore` all exist.\r\n\r\nThe current behavior seems to be that `black a/b/c` only detects `a/b/c/.gitignore` and completely ignores other gitignore files. This PR implements the same behavior",
      "comment_id": 1014983053,
      "user": "aaossa",
      "created_at": "2022-11-07T03:53:49Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1014983053"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 223,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,15 +211,27 @@ def gen_python_files(\n \n     `report` is where output about exclusions goes.\n     \"\"\"\n+\n+    def is_ignored(\n+        gitignore_dict: Dict[Path, PathSpec], child: Path, report: Report\n+    ) -> bool:\n+        for _dir, _gitignore in gitignore_dict.items():\n+            relative_path = normalize_path_maybe_ignore(child, _dir, report)\n+            if relative_path is None:\n+                break\n+            if _gitignore is not None and _gitignore.match_file(relative_path):\n+                report.path_ignored(child, \"matches the .gitignore file content\")",
      "comment": "Maybe include the (full) path to the .gitignore file that matched?",
      "comment_id": 1014987492,
      "user": "aaossa",
      "created_at": "2022-11-07T04:07:32Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1014987492"
    },
    {
      "repo": "psf/black",
      "pr_number": 3338,
      "file_path": "src/black/files.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,15 +211,27 @@ def gen_python_files(\n \n     `report` is where output about exclusions goes.\n     \"\"\"\n+\n+    def is_ignored(",
      "comment": "I'm suggesting to make it a separate top-level function, wouldn't that be possible?",
      "comment_id": 1016124285,
      "user": "JelleZijlstra",
      "created_at": "2022-11-08T04:09:17Z",
      "url": "https://github.com/psf/black/pull/3338#discussion_r1016124285"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 630,
      "side": "RIGHT",
      "diff_hunk": "@@ -625,6 +625,9 @@ def get_sources(\n     sources: Set[Path] = set()\n     root = ctx.obj[\"root\"]\n \n+    _exclude = exclude",
      "comment": "Not sure how to fix the mypy check:\r\n\r\n```\r\nsrc/black/__init__.py:681:21: error: Argument 4 to \"gen_python_files\" has incompatible type \"Optional[Pattern[str]]\"; expected \"Pattern[str]\"  [arg-type]\r\n```\r\n\r\nThe complain comes because `exclude` has type `Optional[Pattern[str]]`, so `_exclude` should have the same type while `gen_python_files` always expects a `Pattern[str]`.\r\n\r\nBut in the case that `exclude` is `None` (and therefore `_exclude` too), the value of `_exclude` then changes to `Pattern[str]`, so the value passed to `gen_python_files` will never be `None`. Any ideas?",
      "comment_id": 997119695,
      "user": "aaossa",
      "created_at": "2022-10-17T14:15:13Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r997119695"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 630,
      "side": "RIGHT",
      "diff_hunk": "@@ -625,6 +625,9 @@ def get_sources(\n     sources: Set[Path] = set()\n     root = ctx.obj[\"root\"]\n \n+    _exclude = exclude",
      "comment": "Maybe use[ `typing.cast`](https://docs.python.org/3/library/typing.html#typing.cast) when passing the value to `gen_python_files`? `cast(Pattern[str], _exclude)`. Feels bad but should make mypy happy as we know the value should never be `None`.\r\n\r\nCheck this snippet on [mypy playground](https://mypy-play.net/?mypy=latest&python=3.7). This is a small reproduction of the issue at hand: mypy does not see that `backup` (`_exclude`) will never be `None`:\r\n\r\n```python\r\nfrom typing import Optional, cast\r\n\r\n\r\ndef function(arg: Optional[str]) -> str:\r\n    backup = arg\r\n    if arg is None:\r\n        if backup is None:\r\n            backup = \"\"\r\n    # return cast(str, backup)\r\n    return backup\r\n\r\nfunction(None)\r\nfunction(\"a\")\r\n```",
      "comment_id": 997472953,
      "user": "aaossa",
      "created_at": "2022-10-17T20:18:59Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r997472953"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 630,
      "side": "RIGHT",
      "diff_hunk": "@@ -625,6 +625,9 @@ def get_sources(\n     sources: Set[Path] = set()\n     root = ctx.obj[\"root\"]\n \n+    _exclude = exclude",
      "comment": "Decided to add `cast(Pattern[str], _exclude)` when passing the value to `gen_python_files`",
      "comment_id": 1000787055,
      "user": "aaossa",
      "created_at": "2022-10-20T15:25:43Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r1000787055"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 630,
      "side": "RIGHT",
      "diff_hunk": "@@ -625,6 +626,9 @@ def get_sources(\n     sources: Set[Path] = set()\n     root = ctx.obj[\"root\"]\n \n+    _exclude = exclude\n+    _gitignore = gitignore = None",
      "comment": "> `src/black/__init__.py:630: error: Local variable \"gitignore\" has inferred type None; add an annotation`\r\n\r\nSolving by adding type annotation: `#type: Optional[PathSpec]`",
      "comment_id": 1000991034,
      "user": "aaossa",
      "created_at": "2022-10-20T18:36:19Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r1000991034"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -659,25 +664,27 @@ def get_sources(\n             sources.add(p)\n         elif p.is_dir():\n             if exclude is None:\n-                exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n-                gitignore = get_gitignore(root)\n+                if _exclude is None:\n+                    _exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n+                if gitignore is None:\n+                    gitignore = get_gitignore(root)\n                 p_gitignore = get_gitignore(p)\n                 # No need to use p's gitignore if it is identical to root's gitignore\n                 # (i.e. root and p point to the same directory).\n-                if gitignore != p_gitignore:\n-                    gitignore += p_gitignore\n-            else:\n-                gitignore = None\n+                if gitignore == p_gitignore:\n+                    _gitignore = gitignore\n+                else:\n+                    _gitignore = gitignore + p_gitignore\n             sources.update(\n                 gen_python_files(\n                     p.iterdir(),\n                     ctx.obj[\"root\"],\n                     include,\n-                    exclude,\n+                    cast(Pattern[str], _exclude),",
      "comment": "Instead of casting, we should assert that _exclude is not None. cast is unsafe.",
      "comment_id": 1005125547,
      "user": "JelleZijlstra",
      "created_at": "2022-10-26T01:27:56Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r1005125547"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 630,
      "side": "RIGHT",
      "diff_hunk": "@@ -625,6 +627,9 @@ def get_sources(\n     sources: Set[Path] = set()\n     root = ctx.obj[\"root\"]\n \n+    _exclude = exclude",
      "comment": "Wouldn't it be simpler to do the initialization (`re_compile_maybe_verbose(DEFAULT_EXCLUDES)` and `get_gitignore(root)`) here? We may waste a little time in the case where we formatting stdin only, but we avoid the confusing `_`-prefixed variables.",
      "comment_id": 1005126288,
      "user": "JelleZijlstra",
      "created_at": "2022-10-26T01:30:03Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r1005126288"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 630,
      "side": "RIGHT",
      "diff_hunk": "@@ -625,6 +627,9 @@ def get_sources(\n     sources: Set[Path] = set()\n     root = ctx.obj[\"root\"]\n \n+    _exclude = exclude",
      "comment": "Yes, it's simpler and I did not do that trying to avoid calculating values that might end up not being used, but if that's OK, I'll give it a try",
      "comment_id": 1006127203,
      "user": "aaossa",
      "created_at": "2022-10-26T19:53:53Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r1006127203"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -659,25 +664,27 @@ def get_sources(\n             sources.add(p)\n         elif p.is_dir():\n             if exclude is None:\n-                exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n-                gitignore = get_gitignore(root)\n+                if _exclude is None:\n+                    _exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n+                if gitignore is None:\n+                    gitignore = get_gitignore(root)\n                 p_gitignore = get_gitignore(p)\n                 # No need to use p's gitignore if it is identical to root's gitignore\n                 # (i.e. root and p point to the same directory).\n-                if gitignore != p_gitignore:\n-                    gitignore += p_gitignore\n-            else:\n-                gitignore = None\n+                if gitignore == p_gitignore:\n+                    _gitignore = gitignore\n+                else:\n+                    _gitignore = gitignore + p_gitignore\n             sources.update(\n                 gen_python_files(\n                     p.iterdir(),\n                     ctx.obj[\"root\"],\n                     include,\n-                    exclude,\n+                    cast(Pattern[str], _exclude),",
      "comment": "I'm not sure how to assert that. The value will never be `None`, but is a limitation (?) of mypy https://github.com/psf/black/pull/3336/files#r997119695\r\n\r\nBut, this issue should go away if we just initialize `_exclude` as `re_compile_maybe_verbose(DEFAULT_EXCLUDES)`, as you suggested. Then, casting nor asserting should be necessary (mypy will correctly identify `_exclude` as `Pattern[str]`)",
      "comment_id": 1006131541,
      "user": "aaossa",
      "created_at": "2022-10-26T19:59:14Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r1006131541"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 632,
      "side": "RIGHT",
      "diff_hunk": "@@ -625,6 +626,11 @@ def get_sources(\n     sources: Set[Path] = set()\n     root = ctx.obj[\"root\"]\n \n+    exclude_is_None = exclude is None\n+    exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES) if exclude is None else exclude\n+    gitignore = None  # type: Optional[PathSpec]\n+    root_gitignore = get_gitignore(root)",
      "comment": "```suggestion\r\n    using_default_exclude = exclude is None\r\n    exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES) if exclude is None else exclude\r\n    gitignore: Optional[PathSpec] = None\r\n    root_gitignore = get_gitignore(root)\r\n```",
      "comment_id": 1014763975,
      "user": "ichard26",
      "created_at": "2022-11-06T03:42:38Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r1014763975"
    },
    {
      "repo": "psf/black",
      "pr_number": 3336,
      "file_path": "src/black/__init__.py",
      "line": 667,
      "side": "RIGHT",
      "diff_hunk": "@@ -658,16 +664,14 @@ def get_sources(\n \n             sources.add(p)\n         elif p.is_dir():\n-            if exclude is None:\n-                exclude = re_compile_maybe_verbose(DEFAULT_EXCLUDES)\n-                gitignore = get_gitignore(root)\n+            if exclude_is_None:",
      "comment": "```suggestion\r\n            if using_default_exclude:\r\n```",
      "comment_id": 1014764031,
      "user": "ichard26",
      "created_at": "2022-11-06T03:43:40Z",
      "url": "https://github.com/psf/black/pull/3336#discussion_r1014764031"
    },
    {
      "repo": "psf/black",
      "pr_number": 3302,
      "file_path": "src/black/lines.py",
      "line": 510,
      "side": "RIGHT",
      "diff_hunk": "@@ -458,33 +480,55 @@ class EmptyLineTracker:\n     are consumed by `maybe_empty_lines()` and included in the computation.\n     \"\"\"\n \n-    is_pyi: bool = False\n+    mode: Mode\n     previous_line: Optional[Line] = None\n-    previous_after: int = 0\n+    previous_block: Optional[LinesBlock] = None\n     previous_defs: List[int] = field(default_factory=list)\n+    semantic_leading_comment: Optional[LinesBlock] = None\n \n-    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n+    def maybe_empty_lines(self, current_line: Line) -> LinesBlock:\n         \"\"\"Return the number of extra empty lines before and after the `current_line`.\n \n         This is for separating `def`, `async def` and `class` with extra empty\n         lines (two on module-level).\n         \"\"\"\n         before, after = self._maybe_empty_lines(current_line)\n+        previous_after = self.previous_block.after if self.previous_block else 0\n         before = (\n             # Black should not insert empty lines at the beginning\n             # of the file\n             0\n             if self.previous_line is None\n-            else before - self.previous_after\n+            else before - previous_after\n         )\n-        self.previous_after = after\n+        block = LinesBlock(\n+            mode=self.mode,\n+            previous_block=self.previous_block,\n+            is_class=current_line.is_class,\n+        )\n+        block.before = before\n+        block.after = after",
      "comment": "```suggestion\r\n            is_class=current_line.is_class,\r\n            before=before,\r\n            after=after,\r\n        )\r\n```\r\n\r\nBetter to avoid modifying the object after creation.",
      "comment_id": 989482225,
      "user": "JelleZijlstra",
      "created_at": "2022-10-06T21:05:43Z",
      "url": "https://github.com/psf/black/pull/3302#discussion_r989482225"
    },
    {
      "repo": "psf/black",
      "pr_number": 3302,
      "file_path": "tests/data/preview/comments9.py",
      "line": 5,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,240 @@\n+# Test for https://github.com/psf/black/issues/246.\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+def function():",
      "comment": "Could we also test two lines of comments? I'd expect them both to be moved.",
      "comment_id": 990391878,
      "user": "felix-hilden",
      "created_at": "2022-10-07T18:19:45Z",
      "url": "https://github.com/psf/black/pull/3302#discussion_r990391878"
    },
    {
      "repo": "psf/black",
      "pr_number": 3302,
      "file_path": "tests/data/preview/comments9.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,240 @@\n+# Test for https://github.com/psf/black/issues/246.\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+def function():\n+    pass\n+\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+async def async_function():\n+    pass\n+\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+class MyClass:\n+    pass\n+\n+\n+some = statement\n+# This should be stick to the statement above\n+\n+# This should be split from the above by two lines\n+class MyClassWithComplexLeadingComments:\n+    pass\n+\n+\n+class ClassWithDocstring:\n+    \"\"\"A docstring.\"\"\"\n+# Leading comment after a class with just a docstring\n+class MyClassAfterAnotherClassWithDocstring:\n+    pass\n+\n+\n+some = statement\n+# leading 1\n+@deco1\n+# leading 2\n+# leading 2 extra\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+# leading 4\n+def decorated():\n+    pass\n+\n+\n+some = statement\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+\n+# leading 3 that already has an empty line\n+@deco3\n+# leading 4\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+some = statement\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+\n+# leading 4 that already has an empty line\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+def main():\n+    if a:\n+        # Leading comment before inline function\n+        def inline():\n+            pass\n+        # Another leading comment\n+        def another_inline():\n+            pass\n+    else:\n+        # More leading comments\n+        def inline_after_else():\n+            pass\n+\n+\n+if a:\n+    # Leading comment before \"top-level inline\" function\n+    def top_level_quote_inline():\n+        pass\n+    # Another leading comment\n+    def another_top_level_quote_inline_inline():\n+        pass\n+else:\n+    # More leading comments\n+    def top_level_quote_inline_after_else():\n+        pass\n+\n+\n+class MyClass:\n+    # First method has no empty lines between bare class def.\n+    # More comments.\n+    def first_method(self):\n+        pass\n+\n+\n+# output\n+\n+\n+# Test for https://github.com/psf/black/issues/246.\n+\n+some = statement\n+\n+\n+# This comment should be split from the statement above by two lines.\n+def function():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# This comment should be split from the statement above by two lines.\n+async def async_function():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# This comment should be split from the statement above by two lines.\n+class MyClass:\n+    pass\n+\n+\n+some = statement\n+# This should be stick to the statement above\n+\n+\n+# This should be split from the above by two lines\n+class MyClassWithComplexLeadingComments:\n+    pass\n+\n+\n+class ClassWithDocstring:\n+    \"\"\"A docstring.\"\"\"\n+\n+\n+# Leading comment after a class with just a docstring\n+class MyClassAfterAnotherClassWithDocstring:\n+    pass\n+\n+\n+some = statement\n+\n+\n+# leading 1\n+@deco1\n+# leading 2\n+# leading 2 extra\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+# leading 4\n+def decorated():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+\n+# leading 3 that already has an empty line\n+@deco3\n+# leading 4\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+\n+# leading 4 that already has an empty line\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+def main():\n+    if a:\n+\n+        # Leading comment before inline function",
      "comment": "Adding an empty line is consistent with inline functions without leading comments, just like module-level functions with leading comments:\r\n\r\n```python\r\ndef function():\r\n    if a:\r\n\r\n        def inline():\r\n            pass\r\n\r\n        def another_inline():\r\n            pass\r\n```",
      "comment_id": 990526802,
      "user": "yilei",
      "created_at": "2022-10-07T22:11:21Z",
      "url": "https://github.com/psf/black/pull/3302#discussion_r990526802"
    },
    {
      "repo": "psf/black",
      "pr_number": 3302,
      "file_path": "tests/data/preview/comments9.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,240 @@\n+# Test for https://github.com/psf/black/issues/246.\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+def function():\n+    pass\n+\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+async def async_function():\n+    pass\n+\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+class MyClass:\n+    pass\n+\n+\n+some = statement\n+# This should be stick to the statement above\n+\n+# This should be split from the above by two lines\n+class MyClassWithComplexLeadingComments:\n+    pass\n+\n+\n+class ClassWithDocstring:\n+    \"\"\"A docstring.\"\"\"\n+# Leading comment after a class with just a docstring\n+class MyClassAfterAnotherClassWithDocstring:\n+    pass\n+\n+\n+some = statement\n+# leading 1\n+@deco1\n+# leading 2\n+# leading 2 extra\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+# leading 4\n+def decorated():\n+    pass\n+\n+\n+some = statement\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+\n+# leading 3 that already has an empty line\n+@deco3\n+# leading 4\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+some = statement\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+\n+# leading 4 that already has an empty line\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+def main():\n+    if a:\n+        # Leading comment before inline function\n+        def inline():\n+            pass\n+        # Another leading comment\n+        def another_inline():\n+            pass\n+    else:\n+        # More leading comments\n+        def inline_after_else():\n+            pass\n+\n+\n+if a:\n+    # Leading comment before \"top-level inline\" function\n+    def top_level_quote_inline():\n+        pass\n+    # Another leading comment\n+    def another_top_level_quote_inline_inline():\n+        pass\n+else:\n+    # More leading comments\n+    def top_level_quote_inline_after_else():\n+        pass\n+\n+\n+class MyClass:\n+    # First method has no empty lines between bare class def.\n+    # More comments.\n+    def first_method(self):\n+        pass\n+\n+\n+# output\n+\n+\n+# Test for https://github.com/psf/black/issues/246.\n+\n+some = statement\n+\n+\n+# This comment should be split from the statement above by two lines.\n+def function():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# This comment should be split from the statement above by two lines.\n+async def async_function():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# This comment should be split from the statement above by two lines.\n+class MyClass:\n+    pass\n+\n+\n+some = statement\n+# This should be stick to the statement above\n+\n+\n+# This should be split from the above by two lines\n+class MyClassWithComplexLeadingComments:\n+    pass\n+\n+\n+class ClassWithDocstring:\n+    \"\"\"A docstring.\"\"\"\n+\n+\n+# Leading comment after a class with just a docstring\n+class MyClassAfterAnotherClassWithDocstring:\n+    pass\n+\n+\n+some = statement\n+\n+\n+# leading 1\n+@deco1\n+# leading 2\n+# leading 2 extra\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+# leading 4\n+def decorated():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+\n+# leading 3 that already has an empty line\n+@deco3\n+# leading 4\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+\n+# leading 4 that already has an empty line\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+def main():\n+    if a:\n+\n+        # Leading comment before inline function",
      "comment": "i.e. this is fixing https://github.com/psf/black/issues/3300",
      "comment_id": 990553216,
      "user": "yilei",
      "created_at": "2022-10-07T23:44:40Z",
      "url": "https://github.com/psf/black/pull/3302#discussion_r990553216"
    },
    {
      "repo": "psf/black",
      "pr_number": 3302,
      "file_path": "tests/data/preview/comments9.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,240 @@\n+# Test for https://github.com/psf/black/issues/246.\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+def function():\n+    pass\n+\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+async def async_function():\n+    pass\n+\n+\n+some = statement\n+# This comment should be split from the statement above by two lines.\n+class MyClass:\n+    pass\n+\n+\n+some = statement\n+# This should be stick to the statement above\n+\n+# This should be split from the above by two lines\n+class MyClassWithComplexLeadingComments:\n+    pass\n+\n+\n+class ClassWithDocstring:\n+    \"\"\"A docstring.\"\"\"\n+# Leading comment after a class with just a docstring\n+class MyClassAfterAnotherClassWithDocstring:\n+    pass\n+\n+\n+some = statement\n+# leading 1\n+@deco1\n+# leading 2\n+# leading 2 extra\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+# leading 4\n+def decorated():\n+    pass\n+\n+\n+some = statement\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+\n+# leading 3 that already has an empty line\n+@deco3\n+# leading 4\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+some = statement\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+\n+# leading 4 that already has an empty line\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+def main():\n+    if a:\n+        # Leading comment before inline function\n+        def inline():\n+            pass\n+        # Another leading comment\n+        def another_inline():\n+            pass\n+    else:\n+        # More leading comments\n+        def inline_after_else():\n+            pass\n+\n+\n+if a:\n+    # Leading comment before \"top-level inline\" function\n+    def top_level_quote_inline():\n+        pass\n+    # Another leading comment\n+    def another_top_level_quote_inline_inline():\n+        pass\n+else:\n+    # More leading comments\n+    def top_level_quote_inline_after_else():\n+        pass\n+\n+\n+class MyClass:\n+    # First method has no empty lines between bare class def.\n+    # More comments.\n+    def first_method(self):\n+        pass\n+\n+\n+# output\n+\n+\n+# Test for https://github.com/psf/black/issues/246.\n+\n+some = statement\n+\n+\n+# This comment should be split from the statement above by two lines.\n+def function():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# This comment should be split from the statement above by two lines.\n+async def async_function():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# This comment should be split from the statement above by two lines.\n+class MyClass:\n+    pass\n+\n+\n+some = statement\n+# This should be stick to the statement above\n+\n+\n+# This should be split from the above by two lines\n+class MyClassWithComplexLeadingComments:\n+    pass\n+\n+\n+class ClassWithDocstring:\n+    \"\"\"A docstring.\"\"\"\n+\n+\n+# Leading comment after a class with just a docstring\n+class MyClassAfterAnotherClassWithDocstring:\n+    pass\n+\n+\n+some = statement\n+\n+\n+# leading 1\n+@deco1\n+# leading 2\n+# leading 2 extra\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+# leading 4\n+def decorated():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+\n+# leading 3 that already has an empty line\n+@deco3\n+# leading 4\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+some = statement\n+\n+\n+# leading 1\n+@deco1\n+# leading 2\n+@deco2(with_args=True)\n+# leading 3\n+@deco3\n+\n+# leading 4 that already has an empty line\n+def decorated_with_split_leading_comments():\n+    pass\n+\n+\n+def main():\n+    if a:\n+\n+        # Leading comment before inline function",
      "comment": "This PR now keeps the behavior for inner function after block open.",
      "comment_id": 996385599,
      "user": "yilei",
      "created_at": "2022-10-16T04:13:39Z",
      "url": "https://github.com/psf/black/pull/3302#discussion_r996385599"
    },
    {
      "repo": "psf/black",
      "pr_number": 3299,
      "file_path": "tests/test_black.py",
      "line": 344,
      "side": "RIGHT",
      "diff_hunk": "@@ -341,6 +341,20 @@ def test_string_quotes(self) -> None:\n         black.assert_equivalent(source, not_normalized)\n         black.assert_stable(source, not_normalized, mode=mode)\n \n+    def test_skip_source_first_line(self) -> None:",
      "comment": "Add a test case where there is some valid code after the first line.\r\n\r\nAlso, what if the file doesn't use `\\n` to separate lines?",
      "comment_id": 986915876,
      "user": "JelleZijlstra",
      "created_at": "2022-10-04T14:08:11Z",
      "url": "https://github.com/psf/black/pull/3299#discussion_r986915876"
    },
    {
      "repo": "psf/black",
      "pr_number": 3299,
      "file_path": "tests/test_black.py",
      "line": 344,
      "side": "RIGHT",
      "diff_hunk": "@@ -341,6 +341,20 @@ def test_string_quotes(self) -> None:\n         black.assert_equivalent(source, not_normalized)\n         black.assert_stable(source, not_normalized, mode=mode)\n \n+    def test_skip_source_first_line(self) -> None:",
      "comment": "I'll add a valid code after the first line in the test file:\r\n\r\n```python\r\nThis is not valid Python syntax\r\ny = \"This is valid syntax\"\r\n```\r\n\r\nAbout the second concern, it is indeed valid. I solved it by using the `newline` variable that comes from `decode_bytes` since it's already available. But now several Blackd tests fail because the variable is not available when Blackd invokes `black.format_file_contents`.\r\n\r\nhttps://github.com/psf/black/blob/07b68e2425d2caadc2edf8fe021f60a32c6f44a7/src/blackd/__init__.py#L132-L134\r\n\r\nThis seems related to a WIP at #3257 . Maybe a `newline` variable could be defined in Blackd before calling `black.format_file_contents`, using the same check that's implemented in the cited PR, something like:\r\n\r\n```python\r\nif req_str[req_str.find(\"\\n\") - 1] == \"\\r\":\r\n    newline = \"\\r\\n\"\r\nelse:\r\n    newline = \"\\n\"\r\n```\r\n\r\nThat would work for me, because then in this PR I could invoke `black.format_file_contents` as:\r\n\r\n```python\r\nformatted_str = await loop.run_in_executor(\r\n    executor, partial(black.format_file_contents, req_str, fast=fast, mode=mode, newline=newline)\r\n)\r\n```\r\n\r\nShould I wait for #3257 to be merged and then apply this change? A possible patch is using `os.linesep`, but that completely ignores the current approach (Black takes the first newline in the file as a reference)",
      "comment_id": 987133600,
      "user": "aaossa",
      "created_at": "2022-10-04T17:02:51Z",
      "url": "https://github.com/psf/black/pull/3299#discussion_r987133600"
    },
    {
      "repo": "psf/black",
      "pr_number": 3299,
      "file_path": "tests/test_black.py",
      "line": 344,
      "side": "RIGHT",
      "diff_hunk": "@@ -341,6 +341,20 @@ def test_string_quotes(self) -> None:\n         black.assert_equivalent(source, not_normalized)\n         black.assert_stable(source, not_normalized, mode=mode)\n \n+    def test_skip_source_first_line(self) -> None:",
      "comment": "Now that #3257 has been merged, I'll rebase my PR and apply the changes listed above \ud83d\udc4c (Creating the `newline` variable first, pass the argument to `black.format_file_contents`, and use the variable in the code introduced by #3257 ) ",
      "comment_id": 987331954,
      "user": "aaossa",
      "created_at": "2022-10-04T21:08:41Z",
      "url": "https://github.com/psf/black/pull/3299#discussion_r987331954"
    },
    {
      "repo": "psf/black",
      "pr_number": 3299,
      "file_path": "src/black/__init__.py",
      "line": 814,
      "side": "RIGHT",
      "diff_hunk": "@@ -800,6 +811,8 @@ def format_file_in_place(\n         raise ValueError(\n             f\"File '{src}' cannot be parsed as valid Jupyter notebook.\"\n         ) from None\n+    src_contents = header.decode() + src_contents",
      "comment": "Doesn't this need to use the encoding we got from `decode_bytes()`?",
      "comment_id": 989490618,
      "user": "JelleZijlstra",
      "created_at": "2022-10-06T21:18:17Z",
      "url": "https://github.com/psf/black/pull/3299#discussion_r989490618"
    },
    {
      "repo": "psf/black",
      "pr_number": 3299,
      "file_path": "src/black/__init__.py",
      "line": 814,
      "side": "RIGHT",
      "diff_hunk": "@@ -800,6 +811,8 @@ def format_file_in_place(\n         raise ValueError(\n             f\"File '{src}' cannot be parsed as valid Jupyter notebook.\"\n         ) from None\n+    src_contents = header.decode() + src_contents",
      "comment": "You're right, that's a reasonable assumption. I tried to left the encoding as part of the source code only, but using the same encoding here makes sense and should be a better guess than using the default",
      "comment_id": 989492208,
      "user": "aaossa",
      "created_at": "2022-10-06T21:20:53Z",
      "url": "https://github.com/psf/black/pull/3299#discussion_r989492208"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "src/blackd/__init__.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,6 +133,13 @@ async def handle(request: web.Request, executor: Executor) -> web.Response:\n             executor, partial(black.format_file_contents, req_str, fast=fast, mode=mode)\n         )\n \n+        # Preserve CRLF newlines\n+        if req_str[req_str.find(\"\\n\") - 1] == \"\\r\":\n+            formatted_str = formatted_str.replace(\"\\n\", \"\\r\\n\")",
      "comment": "So, am I right in understanding you're only checking the end of the entire posted data? Are intermediate CRLF (`\\r\\n`) are already being preserved? Was blackd only stripping at the end of the returned data?\r\n\r\nIf so, maybe make the comment say that `# Preserve CRLF newline at the end of blackd returned str`",
      "comment_id": 962864335,
      "user": "cooperlees",
      "created_at": "2022-09-05T12:38:26Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r962864335"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "tests/test_blackd.py",
      "line": 218,
      "side": "RIGHT",
      "diff_hunk": "@@ -212,3 +212,13 @@ async def test_cors_headers_present(self) -> None:\n             response = await self.client.post(\"/\", headers={\"Origin\": \"*\"})\n             self.assertIsNotNone(response.headers.get(\"Access-Control-Allow-Origin\"))\n             self.assertIsNotNone(response.headers.get(\"Access-Control-Expose-Headers\"))\n+\n+        @unittest_run_loop\n+        async def test_preserve_newline(self) -> None:\n+            for data in (b\"c\\r\\nc\\r\\n\", b\"l\\nl\\n\"):",
      "comment": "Why doesn't this need to be `AST` parsable data? Do we mock that somewhere?",
      "comment_id": 962883245,
      "user": "cooperlees",
      "created_at": "2022-09-05T12:59:40Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r962883245"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "src/blackd/__init__.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,6 +133,13 @@ async def handle(request: web.Request, executor: Executor) -> web.Response:\n             executor, partial(black.format_file_contents, req_str, fast=fast, mode=mode)\n         )\n \n+        # Preserve CRLF newlines\n+        if req_str[req_str.find(\"\\n\") - 1] == \"\\r\":",
      "comment": "Is it possible to mix `\\n` and `\\r\\n` newlines in a single file? If so, this could change the contents of string literals with `\\n` newlines in them.",
      "comment_id": 962910109,
      "user": "JelleZijlstra",
      "created_at": "2022-09-05T13:29:17Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r962910109"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "src/blackd/__init__.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,6 +133,13 @@ async def handle(request: web.Request, executor: Executor) -> web.Response:\n             executor, partial(black.format_file_contents, req_str, fast=fast, mode=mode)\n         )\n \n+        # Preserve CRLF newlines\n+        if req_str[req_str.find(\"\\n\") - 1] == \"\\r\":",
      "comment": "I think this is what normal black does currently to files, although I'm not certain.",
      "comment_id": 962916501,
      "user": "KotlinIsland",
      "created_at": "2022-09-05T13:36:25Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r962916501"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "src/blackd/__init__.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,6 +133,13 @@ async def handle(request: web.Request, executor: Executor) -> web.Response:\n             executor, partial(black.format_file_contents, req_str, fast=fast, mode=mode)\n         )\n \n+        # Preserve CRLF newlines\n+        if req_str[req_str.find(\"\\n\") - 1] == \"\\r\":\n+            formatted_str = formatted_str.replace(\"\\n\", \"\\r\\n\")",
      "comment": "I'm checking the first `\\n` to see if it was preceded by an `\\r`. If so, replace all `\\n` with `\\r\\n`",
      "comment_id": 962942797,
      "user": "KotlinIsland",
      "created_at": "2022-09-05T14:05:22Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r962942797"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "src/blackd/__init__.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,6 +133,13 @@ async def handle(request: web.Request, executor: Executor) -> web.Response:\n             executor, partial(black.format_file_contents, req_str, fast=fast, mode=mode)\n         )\n \n+        # Preserve CRLF newlines\n+        if req_str[req_str.find(\"\\n\") - 1] == \"\\r\":",
      "comment": "Yeah, I just checked with a mixed file in normal black, and it uses the first newline to rewrite the rest of the file.\r\n\r\nI think formatting while preserving mixed newlines would be extremely difficult and probably a giant waste of effort.\r\n",
      "comment_id": 962949719,
      "user": "KotlinIsland",
      "created_at": "2022-09-05T14:13:13Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r962949719"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "tests/test_blackd.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,3 +209,13 @@ async def test_cors_headers_present(self) -> None:\n         response = await self.client.post(\"/\", headers={\"Origin\": \"*\"})\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Allow-Origin\"))\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Expose-Headers\"))\n+\n+    @unittest_run_loop\n+    async def test_preserve_newline(self) -> None:\n+        for data in (b\"c\\r\\nc\\r\\n\", b\"l\\nl\\n\"):",
      "comment": "Could we also test:\r\n- first is only n, second is rn, and the corresponding expectation\r\n- the other way around",
      "comment_id": 967833938,
      "user": "felix-hilden",
      "created_at": "2022-09-11T14:01:58Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r967833938"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "tests/test_blackd.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,3 +209,13 @@ async def test_cors_headers_present(self) -> None:\n         response = await self.client.post(\"/\", headers={\"Origin\": \"*\"})\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Allow-Origin\"))\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Expose-Headers\"))\n+\n+    @unittest_run_loop\n+    async def test_preserve_newline(self) -> None:\n+        for data in (b\"c\\r\\nc\\r\\n\", b\"l\\nl\\n\"):",
      "comment": "I'm not sure what you mean, could you provide an example please.\n\n```py\n\"a\\na\\r\\n\"\n```\nLike this?\n\nIf so, should the same test be added to normal black(tbh it might already), and should we document the behaviour as well?",
      "comment_id": 967834407,
      "user": "KotlinIsland",
      "created_at": "2022-09-11T14:04:50Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r967834407"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "tests/test_blackd.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,3 +209,13 @@ async def test_cors_headers_present(self) -> None:\n         response = await self.client.post(\"/\", headers={\"Origin\": \"*\"})\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Allow-Origin\"))\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Expose-Headers\"))\n+\n+    @unittest_run_loop\n+    async def test_preserve_newline(self) -> None:\n+        for data in (b\"c\\r\\nc\\r\\n\", b\"l\\nl\\n\"):",
      "comment": "Yep exactly, sorry for the confusion \ud83d\ude05 and `a\\r\\na\\n` At a quick glance, I couldn't find a test with mixed line endings. Only ones like the one you wrote [here](https://github.com/psf/black/blob/main/tests/test_black.py#L1264). But it would be nice, and a short mention on documentation couldn't hurt either, agreed \ud83d\udc4d Just to be explicit.",
      "comment_id": 967837416,
      "user": "felix-hilden",
      "created_at": "2022-09-11T14:25:35Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r967837416"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "tests/test_blackd.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,3 +209,13 @@ async def test_cors_headers_present(self) -> None:\n         response = await self.client.post(\"/\", headers={\"Origin\": \"*\"})\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Allow-Origin\"))\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Expose-Headers\"))\n+\n+    @unittest_run_loop\n+    async def test_preserve_newline(self) -> None:\n+        for data in (b\"c\\r\\nc\\r\\n\", b\"l\\nl\\n\"):",
      "comment": "I have made a sus discovery, black will not normalize newlines if the rest of the file is unchanged. Should I make blackd behave exactly the same? (I think always normalizing is arguably better).",
      "comment_id": 968224382,
      "user": "KotlinIsland",
      "created_at": "2022-09-12T10:04:13Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r968224382"
    },
    {
      "repo": "psf/black",
      "pr_number": 3257,
      "file_path": "tests/test_blackd.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,3 +209,13 @@ async def test_cors_headers_present(self) -> None:\n         response = await self.client.post(\"/\", headers={\"Origin\": \"*\"})\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Allow-Origin\"))\n         self.assertIsNotNone(response.headers.get(\"Access-Control-Expose-Headers\"))\n+\n+    @unittest_run_loop\n+    async def test_preserve_newline(self) -> None:\n+        for data in (b\"c\\r\\nc\\r\\n\", b\"l\\nl\\n\"):",
      "comment": "I added tests for both blackd and black, and updated the docs.",
      "comment_id": 968232539,
      "user": "KotlinIsland",
      "created_at": "2022-09-12T10:12:27Z",
      "url": "https://github.com/psf/black/pull/3257#discussion_r968232539"
    },
    {
      "repo": "psf/black",
      "pr_number": 3286,
      "file_path": "src/black/comments.py",
      "line": 273,
      "side": "RIGHT",
      "diff_hunk": "@@ -270,8 +270,7 @@ def _generate_ignored_nodes_from_fmt_skip(\n         while \"\\n\" not in prev_sibling.prefix and prev_sibling.prev_sibling is not None:\n             prev_sibling = prev_sibling.prev_sibling\n             siblings.insert(0, prev_sibling)\n-        for sibling in siblings:\n-            yield sibling\n+        yield from siblings",
      "comment": "No, the code is equivalent (IIRC there are subtle differences around exception handling but those don't matter here).",
      "comment_id": 979483685,
      "user": "JelleZijlstra",
      "created_at": "2022-09-26T00:23:19Z",
      "url": "https://github.com/psf/black/pull/3286#discussion_r979483685"
    },
    {
      "repo": "psf/black",
      "pr_number": 3286,
      "file_path": "src/black/trans.py",
      "line": 1259,
      "side": "RIGHT",
      "diff_hunk": "@@ -1256,7 +1256,7 @@ def do_transform(self, line: Line, string_idx: int) -> Iterator[TResult[Line]]:\n \n         string_op_leaves = self._get_string_operator_leaves(LL)\n         string_op_leaves_length = (\n-            sum([len(str(prefix_leaf)) for prefix_leaf in string_op_leaves]) + 1\n+            sum(len(str(prefix_leaf)) for prefix_leaf in string_op_leaves) + 1",
      "comment": "Not sure what this has to do with 3.6 but I'll take it.",
      "comment_id": 979483776,
      "user": "JelleZijlstra",
      "created_at": "2022-09-26T00:23:54Z",
      "url": "https://github.com/psf/black/pull/3286#discussion_r979483776"
    },
    {
      "repo": "psf/black",
      "pr_number": 3281,
      "file_path": "tests/data/simple_cases/fmtonoff5.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,3 +34,125 @@ def test_func():\n         return True\n \n     return False\n+\n+\n+# Regression test for https://github.com/psf/black/issues/2567.\n+if True:\n+    # fmt: off\n+    for _ in range(1):",
      "comment": "```suggestion\r\n    for _ in range( 1 ):\r\n```\r\nTo test that this part isn't formatted",
      "comment_id": 978195852,
      "user": "JelleZijlstra",
      "created_at": "2022-09-23T01:11:04Z",
      "url": "https://github.com/psf/black/pull/3281#discussion_r978195852"
    },
    {
      "repo": "psf/black",
      "pr_number": 3265,
      "file_path": "action/main.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,9 +14,10 @@\n \n run([sys.executable, \"-m\", \"venv\", str(ENV_PATH)], check=True)\n \n-req = \"black[colorama]\"\n-if VERSION:\n-    req += f\"=={VERSION}\"\n+version_specifier = VERSION\n+if VERSION and VERSION[0] in \"0123456789\":",
      "comment": "```suggestion\r\nif VERSION and VERSION[0].isdigit():\r\n```",
      "comment_id": 966400877,
      "user": "JelleZijlstra",
      "created_at": "2022-09-08T20:40:27Z",
      "url": "https://github.com/psf/black/pull/3265#discussion_r966400877"
    },
    {
      "repo": "psf/black",
      "pr_number": 3265,
      "file_path": "action/main.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,9 +14,10 @@\n \n run([sys.executable, \"-m\", \"venv\", str(ENV_PATH)], check=True)\n \n-req = \"black[colorama]\"\n-if VERSION:\n-    req += f\"=={VERSION}\"\n+version_specifier = VERSION\n+if VERSION and VERSION[0] in \"0123456789\":",
      "comment": "I could do `VERSION[0].isdecimal()` here though that's rather wide due to it supporting all Unicode characters in the Unicode General Category \u201cNd\u201d. Personally, I tend to avoid isdecimal/isdigit/isnumeric methods because they evaluate to True for more than I actually want but I can change this.",
      "comment_id": 966403275,
      "user": "Jackenmen",
      "created_at": "2022-09-08T20:43:49Z",
      "url": "https://github.com/psf/black/pull/3265#discussion_r966403275"
    },
    {
      "repo": "psf/black",
      "pr_number": 3265,
      "file_path": "action/main.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,9 +14,10 @@\n \n run([sys.executable, \"-m\", \"venv\", str(ENV_PATH)], check=True)\n \n-req = \"black[colorama]\"\n-if VERSION:\n-    req += f\"=={VERSION}\"\n+version_specifier = VERSION\n+if VERSION and VERSION[0] in \"0123456789\":",
      "comment": "Ah damn, I didn't notice this comment before I made mine :smile: I can change it, though I would like to note that isdecimal is less wide check than isdigit so it might be better choice if we're switching it.",
      "comment_id": 966405255,
      "user": "Jackenmen",
      "created_at": "2022-09-08T20:46:29Z",
      "url": "https://github.com/psf/black/pull/3265#discussion_r966405255"
    },
    {
      "repo": "psf/black",
      "pr_number": 3265,
      "file_path": "action/main.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,9 +14,10 @@\n \n run([sys.executable, \"-m\", \"venv\", str(ENV_PATH)], check=True)\n \n-req = \"black[colorama]\"\n-if VERSION:\n-    req += f\"=={VERSION}\"\n+version_specifier = VERSION\n+if VERSION and VERSION[0] in \"0123456789\":",
      "comment": "I guess it's fine either way, since we only care about recognising version specifier characters, which won't be decimal or digits. But no biggie.",
      "comment_id": 967840290,
      "user": "felix-hilden",
      "created_at": "2022-09-11T14:45:58Z",
      "url": "https://github.com/psf/black/pull/3265#discussion_r967840290"
    },
    {
      "repo": "psf/black",
      "pr_number": 3265,
      "file_path": "action/main.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,9 +14,10 @@\n \n run([sys.executable, \"-m\", \"venv\", str(ENV_PATH)], check=True)\n \n-req = \"black[colorama]\"\n-if VERSION:\n-    req += f\"=={VERSION}\"\n+version_specifier = VERSION\n+if VERSION and VERSION[0] in \"0123456789\":",
      "comment": "Do packaging tools normalize non-ascii digits? If so, I'd prefer `isdecimal()` otherwise I'd prefer being stricter.",
      "comment_id": 967928636,
      "user": "ichard26",
      "created_at": "2022-09-12T01:40:16Z",
      "url": "https://github.com/psf/black/pull/3265#discussion_r967928636"
    },
    {
      "repo": "psf/black",
      "pr_number": 3265,
      "file_path": "action/main.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,9 +14,10 @@\n \n run([sys.executable, \"-m\", \"venv\", str(ENV_PATH)], check=True)\n \n-req = \"black[colorama]\"\n-if VERSION:\n-    req += f\"=={VERSION}\"\n+version_specifier = VERSION\n+if VERSION and VERSION[0] in \"0123456789\":",
      "comment": "`pip` doesn't handle Unicode numbers:\r\n```\r\n\u276f pip install 'black==\u0968\u0968.\u0967'\r\nERROR: Could not find a version that satisfies the requirement black==\u0968\u0968.\u0967 (from versions: 18.3a0, 18.3a1, 18.3a2, 18.3a3, 18.3a4, 18.4a0, 18.4a1, 18.4a2, 18.4a3, 18.4a4, 18.5b0, 18.5b1, 18.6b0, 18.6b1, 18.6b2, 18.6b3, 18.6b4, 18.9b0, 19.3b0, 19.10b0, 20.8b0, 20.8b1, 21.4b0, 21.4b1, 21.4b2, 21.5b0, 21.5b1, 21.5b2, 21.6b0, 21.7b0, 21.8b0, 21.9b0, 21.10b0, 21.11b0, 21.11b1, 21.12b0, 22.1.0, 22.3.0, 22.6.0, 22.8.0)\r\nERROR: No matching distribution found for black==\u0968\u0968.\u0967\r\n```\r\n\r\nSo in the end, it shouldn't matter whether we use `isdecimal()` or the `in` check as it will fail anyway.",
      "comment_id": 967932127,
      "user": "Jackenmen",
      "created_at": "2022-09-12T01:54:02Z",
      "url": "https://github.com/psf/black/pull/3265#discussion_r967932127"
    },
    {
      "repo": "psf/black",
      "pr_number": 3162,
      "file_path": "tests/data/preview/long_strings.py",
      "line": 654,
      "side": "RIGHT",
      "diff_hunk": "@@ -512,23 +568,31 @@ def foo():\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",\n+    (\n+        \"This is a really long string argument to a function that has a trailing comma\"\n+        \" which should NOT be there.\"\n+    ),\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",  # comment after comma\n+    (  # comment after comma\n+        \"This is a really long string argument to a function that has a trailing comma\"\n+        \" which should NOT be there.\"\n+    ),\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",\n+    (\n+        \"This is a really long string argument to a function that has a trailing comma\"\n+        \" which should NOT be there.\"\n+    ),\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",  # comment after comma\n+    (  # comment after comma",
      "comment": "hm, it seems like this comment gets moved to the beginning? That's unfortunate.",
      "comment_id": 924001042,
      "user": "JelleZijlstra",
      "created_at": "2022-07-19T02:21:03Z",
      "url": "https://github.com/psf/black/pull/3162#discussion_r924001042"
    },
    {
      "repo": "psf/black",
      "pr_number": 3162,
      "file_path": "tests/data/preview/long_strings.py",
      "line": 654,
      "side": "RIGHT",
      "diff_hunk": "@@ -512,23 +568,31 @@ def foo():\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",\n+    (\n+        \"This is a really long string argument to a function that has a trailing comma\"\n+        \" which should NOT be there.\"\n+    ),\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",  # comment after comma\n+    (  # comment after comma\n+        \"This is a really long string argument to a function that has a trailing comma\"\n+        \" which should NOT be there.\"\n+    ),\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",\n+    (\n+        \"This is a really long string argument to a function that has a trailing comma\"\n+        \" which should NOT be there.\"\n+    ),\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",  # comment after comma\n+    (  # comment after comma",
      "comment": "yeah, i'm actually not sure where the comment should go. there is another existing example:\r\n\r\nhttps://github.com/psf/black/blob/1b6de7b0a33b568f71ff86e0e5fef6d4c479c2b7/tests/data/preview/long_strings.py#L91\r\n\r\nhttps://github.com/psf/black/blob/1b6de7b0a33b568f71ff86e0e5fef6d4c479c2b7/tests/data/preview/long_strings.py#L447-L450\r\n\r\nthat throws the comment to the opening paren, which is the same behavior here.\r\n\r\nlooks like it was introduced in https://github.com/psf/black/pull/1132, but it's unclear whether this behavior is intentionally designed or not.\r\n\r\nthoughts?",
      "comment_id": 924004829,
      "user": "yilei",
      "created_at": "2022-07-19T02:31:21Z",
      "url": "https://github.com/psf/black/pull/3162#discussion_r924004829"
    },
    {
      "repo": "psf/black",
      "pr_number": 3162,
      "file_path": "tests/data/preview/long_strings.py",
      "line": 654,
      "side": "RIGHT",
      "diff_hunk": "@@ -512,23 +568,31 @@ def foo():\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",\n+    (\n+        \"This is a really long string argument to a function that has a trailing comma\"\n+        \" which should NOT be there.\"\n+    ),\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",  # comment after comma\n+    (  # comment after comma\n+        \"This is a really long string argument to a function that has a trailing comma\"\n+        \" which should NOT be there.\"\n+    ),\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",\n+    (\n+        \"This is a really long string argument to a function that has a trailing comma\"\n+        \" which should NOT be there.\"\n+    ),\n )\n \n func_with_bad_comma(\n-    \"This is a really long string argument to a function that has a trailing comma\"\n-    \" which should NOT be there.\",  # comment after comma\n+    (  # comment after comma",
      "comment": "I see, thanks. Maybe we can fix this, but seems like the issue is independent from this PR.",
      "comment_id": 924012025,
      "user": "JelleZijlstra",
      "created_at": "2022-07-19T02:50:26Z",
      "url": "https://github.com/psf/black/pull/3162#discussion_r924012025"
    },
    {
      "repo": "psf/black",
      "pr_number": 3162,
      "file_path": "tests/data/preview/long_strings.py",
      "line": 381,
      "side": "RIGHT",
      "diff_hunk": "@@ -345,6 +359,71 @@ def foo():\n     % (\"soooo\", 2),\n }\n \n+L1 = [\n+    \"The is a short string\",\n+    (\n+        \"This is a really long string that can't possibly be expected to fit all\"\n+        \" together on one line. Also it is inside a list literal, so it's expected to\"\n+        \" be wrapped in parens when spliting to avoid implicit str concatenation.\"\n+    ),\n+    short_call(\"arg\", {\"key\": \"value\"}),\n+    (\n+        \"This is another really really (not really) long string that also can't be\"\n+        \" expected to fit on one line and is, like the other string, inside a list\"\n+        \" literal.\"\n+    ),\n+    \"parens should be stripped for short string in list\",\n+]\n+\n+L2 = [\n+    \"This is a really long string that can't be expected to fit in one line and is the\"\n+    \" only child of a list literal.\"\n+]",
      "comment": "I would've thought this would be wrapped too, but it isn't because there isn't a trailing comma. Not sure if that's intentional or simply an oversight. It's probably better to keep it unwrapped though.",
      "comment_id": 956253486,
      "user": "ichard26",
      "created_at": "2022-08-26T17:25:46Z",
      "url": "https://github.com/psf/black/pull/3162#discussion_r956253486"
    },
    {
      "repo": "psf/black",
      "pr_number": 3162,
      "file_path": "tests/data/preview/long_strings.py",
      "line": 381,
      "side": "RIGHT",
      "diff_hunk": "@@ -345,6 +359,71 @@ def foo():\n     % (\"soooo\", 2),\n }\n \n+L1 = [\n+    \"The is a short string\",\n+    (\n+        \"This is a really long string that can't possibly be expected to fit all\"\n+        \" together on one line. Also it is inside a list literal, so it's expected to\"\n+        \" be wrapped in parens when spliting to avoid implicit str concatenation.\"\n+    ),\n+    short_call(\"arg\", {\"key\": \"value\"}),\n+    (\n+        \"This is another really really (not really) long string that also can't be\"\n+        \" expected to fit on one line and is, like the other string, inside a list\"\n+        \" literal.\"\n+    ),\n+    \"parens should be stripped for short string in list\",\n+]\n+\n+L2 = [\n+    \"This is a really long string that can't be expected to fit in one line and is the\"\n+    \" only child of a list literal.\"\n+]",
      "comment": "yes this is intentional as implemented in this PR.",
      "comment_id": 956281667,
      "user": "yilei",
      "created_at": "2022-08-26T17:54:48Z",
      "url": "https://github.com/psf/black/pull/3162#discussion_r956281667"
    },
    {
      "repo": "psf/black",
      "pr_number": 3211,
      "file_path": "src/black/__init__.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,10 +90,10 @@\n from blib2to3.pgen2 import token\n from blib2to3.pytree import Leaf, Node\n \n-if TYPE_CHECKING:\n-    from concurrent.futures import Executor\n-\n COMPILED = Path(__file__).suffix in (\".pyd\", \".so\")\n+DEFAULT_WORKERS: Final = os.cpu_count()",
      "comment": "Hm this does a syscall at startup, we may want to put it into a cached-forever function instead.",
      "comment_id": 945055239,
      "user": "JelleZijlstra",
      "created_at": "2022-08-13T03:48:03Z",
      "url": "https://github.com/psf/black/pull/3211#discussion_r945055239"
    },
    {
      "repo": "psf/black",
      "pr_number": 3211,
      "file_path": "src/black/__init__.py",
      "line": 1373,
      "side": "RIGHT",
      "diff_hunk": "@@ -1495,8 +1369,14 @@ def patch_click() -> None:\n \n \n def patched_main() -> None:\n-    maybe_install_uvloop()\n-    freeze_support()\n+    global __BLACK_MAIN_CALLED__\n+    __BLACK_MAIN_CALLED__ = True",
      "comment": "Instead of this global, what if we return early in `maybe_install_uvloop` if uvloop is already in sys.modules?\r\n\r\nOr we could just call it unconditionally. It's only called once per formatting run and it's pretty fast:\r\n\r\n```\r\nIn [14]: %timeit black.concurrency.maybe_install_uvloop()\r\n1.67 \u00b5s \u00b1 30.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\r\n```",
      "comment_id": 945056978,
      "user": "JelleZijlstra",
      "created_at": "2022-08-13T03:52:26Z",
      "url": "https://github.com/psf/black/pull/3211#discussion_r945056978"
    },
    {
      "repo": "psf/black",
      "pr_number": 3211,
      "file_path": "src/black/__init__.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,10 +90,10 @@\n from blib2to3.pgen2 import token\n from blib2to3.pytree import Leaf, Node\n \n-if TYPE_CHECKING:\n-    from concurrent.futures import Executor\n-\n COMPILED = Path(__file__).suffix in (\".pyd\", \".so\")\n+DEFAULT_WORKERS: Final = os.cpu_count()",
      "comment": "Though then again\r\n\r\n```\r\nIn [16]: %timeit os.cpu_count()\r\n1.05 \u00b5s \u00b1 10.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\r\n```",
      "comment_id": 945057637,
      "user": "JelleZijlstra",
      "created_at": "2022-08-13T03:53:58Z",
      "url": "https://github.com/psf/black/pull/3211#discussion_r945057637"
    },
    {
      "repo": "psf/black",
      "pr_number": 3211,
      "file_path": "src/black/concurrency.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,3 +71,129 @@ def shutdown(loop: asyncio.AbstractEventLoop) -> None:\n         cf_logger = logging.getLogger(\"concurrent.futures\")\n         cf_logger.setLevel(logging.CRITICAL)\n         loop.close()\n+\n+\n+# diff-shades depends on being to monkeypatch this function to operate. I know it's\n+# not ideal, but this shouldn't cause any issues ... hopefully. ~ichard26\n+@mypyc_attr(patchable=True)\n+def reformat_many(\n+    sources: Set[Path],\n+    fast: bool,\n+    write_back: WriteBack,\n+    mode: Mode,\n+    report: Report,\n+    workers: Optional[int],\n+) -> None:\n+    \"\"\"Reformat multiple files using a ProcessPoolExecutor.\"\"\"\n+    maybe_install_uvloop()",
      "comment": "I chose to keep the helper function instead of always attempting an import of uvloop in the module scope just as insurance if we ever accidentally break the invariant `black.concurrency` should only be imported via `black.main` if there's more than one file to format.",
      "comment_id": 945174355,
      "user": "ichard26",
      "created_at": "2022-08-13T17:59:32Z",
      "url": "https://github.com/psf/black/pull/3211#discussion_r945174355"
    },
    {
      "repo": "psf/black",
      "pr_number": 3216,
      "file_path": "src/black/__init__.py",
      "line": 478,
      "side": "RIGHT",
      "diff_hunk": "@@ -469,7 +469,13 @@ def main(  # noqa: C901\n         out(main.get_usage(ctx) + \"\\n\\nOne of 'SRC' or 'code' is required.\")\n         ctx.exit(1)\n \n-    root, method = find_project_root(src) if code is None else (None, None)\n+    if stdin_filename is not None:\n+        src_with_stdin_filename = tuple(stdin_filename if s == \"-\" else s for s in src)\n+    else:\n+        src_with_stdin_filename = src\n+    root, method = (\n+        find_project_root(src_with_stdin_filename) if code is None else (None, None)\n+    )",
      "comment": "```suggestion\r\n    if stdin_filename is not None:\r\n        src = tuple(stdin_filename if s == \"-\" else s for s in src)\r\n\r\n    root, method = find_project_root(src) if code is None else (None, None)\r\n```\r\n\r\nPerhaps we could make the above work below as well.\r\n\r\nAlso, I was unaware how passing multiple stdin placeholders works, but for `- - -` etc stdin is only read once (or does closing it prevent further reads, guess so), and with other files `-` is read as a filename. So it is safe to assume that there will only be one to convert. Or maybe we'll have to even guard against weird use, not sure what would be best.\r\n\r\nYeah, tests would be nice \ud83d\udc4d",
      "comment_id": 946081183,
      "user": "felix-hilden",
      "created_at": "2022-08-15T20:02:02Z",
      "url": "https://github.com/psf/black/pull/3216#discussion_r946081183"
    },
    {
      "repo": "psf/black",
      "pr_number": 3234,
      "file_path": "tests/test_blackd.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,195 +8,199 @@\n \n from tests.util import DETERMINISTIC_HEADER, read_data\n ",
      "comment": "I think you can use https://docs.pytest.org/en/7.1.x/how-to/skipping.html#skip-all-test-functions-of-a-class-or-module so you don't have to indent the whole thing",
      "comment_id": 950762184,
      "user": "JelleZijlstra",
      "created_at": "2022-08-20T23:45:48Z",
      "url": "https://github.com/psf/black/pull/3234#discussion_r950762184"
    },
    {
      "repo": "psf/black",
      "pr_number": 3209,
      "file_path": "src/black/lines.py",
      "line": 311,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,8 +303,22 @@ def has_magic_trailing_comma(\n \n             if not ensure_removable:\n                 return True\n+\n             comma = self.leaves[-1]\n-            return bool(comma.parent and comma.parent.type == syms.listmaker)\n+            if comma.parent is None:\n+                return False\n+            if Preview.skip_magic_trailing_comma_in_subscript in self.mode:\n+                return bool(",
      "comment": "```suggestion\r\n                return (\r\n```\r\nNit, but all the elements in the or are already bools.",
      "comment_id": 945047926,
      "user": "JelleZijlstra",
      "created_at": "2022-08-13T03:30:00Z",
      "url": "https://github.com/psf/black/pull/3209#discussion_r945047926"
    },
    {
      "repo": "psf/black",
      "pr_number": 3217,
      "file_path": "src/blackd/__init__.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,6 +32,7 @@\n PYTHON_VARIANT_HEADER = \"X-Python-Variant\"\n SKIP_STRING_NORMALIZATION_HEADER = \"X-Skip-String-Normalization\"\n SKIP_MAGIC_TRAILING_COMMA = \"X-Skip-Magic-Trailing-Comma\"\n+PREVIEW = \"X-PREVIEW\"",
      "comment": "```suggestion\r\nPREVIEW = \"X-Preview\"\r\n```\r\nI know HTTP headers are case-insensitive, but we might as make it consistent with the other constants :)",
      "comment_id": 943974559,
      "user": "ichard26",
      "created_at": "2022-08-11T22:01:57Z",
      "url": "https://github.com/psf/black/pull/3217#discussion_r943974559"
    },
    {
      "repo": "psf/black",
      "pr_number": 3215,
      "file_path": "tests/test_black.py",
      "line": 313,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,6 +310,24 @@ def test_detect_pos_only_arguments(self) -> None:\n         versions = black.detect_target_versions(root)\n         self.assertIn(black.TargetVersion.PY38, versions)\n \n+    def test_detect_debug_f_strings(self) -> None:",
      "comment": "Can you also include a couple of normal cases like the ones in here (not all of them, a couple should be enough)\r\n\r\nhttps://github.com/python/cpython/blob/71c3d649b5a0324c6eb01f9ad025c1e102b82bba/Lib/test/test_fstring.py#L1262-L1291",
      "comment_id": 942606052,
      "user": "isidentical",
      "created_at": "2022-08-10T15:36:54Z",
      "url": "https://github.com/psf/black/pull/3215#discussion_r942606052"
    },
    {
      "repo": "psf/black",
      "pr_number": 3215,
      "file_path": "src/black/__init__.py",
      "line": 1267,
      "side": "RIGHT",
      "diff_hunk": "@@ -1261,6 +1263,11 @@ def get_features_used(  # noqa: C901\n             value_head = n.value[:2]\n             if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                 features.add(Feature.F_STRINGS)\n+                if Feature.DEBUG_F_STRINGS not in features:\n+                    for span_beg, span_end in iter_fexpr_spans(n.value):",
      "comment": "Is this an expensive function, or is its speed negligible? If it is a bit slow, we could also add a more naive check above (\"=\" in n.value) to only include f-strings with equal signs (which should reduce the number of calls to this function by a lot). If it is not too expensive, I think it is alright to keep it as is.",
      "comment_id": 942608883,
      "user": "isidentical",
      "created_at": "2022-08-10T15:39:36Z",
      "url": "https://github.com/psf/black/pull/3215#discussion_r942608883"
    },
    {
      "repo": "psf/black",
      "pr_number": 3215,
      "file_path": "src/black/__init__.py",
      "line": 1267,
      "side": "RIGHT",
      "diff_hunk": "@@ -1261,6 +1263,11 @@ def get_features_used(  # noqa: C901\n             value_head = n.value[:2]\n             if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                 features.add(Feature.F_STRINGS)\n+                if Feature.DEBUG_F_STRINGS not in features:\n+                    for span_beg, span_end in iter_fexpr_spans(n.value):",
      "comment": "It is not too expensive, it's a single loop over the value. mypyc should also compile it well.",
      "comment_id": 942777049,
      "user": "hauntsaninja",
      "created_at": "2022-08-10T18:36:45Z",
      "url": "https://github.com/psf/black/pull/3215#discussion_r942777049"
    },
    {
      "repo": "psf/black",
      "pr_number": 3193,
      "file_path": "src/blib2to3/pgen2/driver.py",
      "line": 271,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,14 +263,13 @@ def load_grammar(\n         logger = logging.getLogger(__name__)\n     gp = _generate_pickle_name(gt) if gp is None else gp\n     if force or not _newer(gp, gt):\n-        logger.info(\"Generating grammar tables from %s\", gt)\n         g: grammar.Grammar = pgen.generate_grammar(gt)\n         if save:\n-            logger.info(\"Writing grammar tables to %s\", gp)\n             try:\n                 g.dump(gp)\n-            except OSError as e:\n-                logger.info(\"Writing failed: %s\", e)\n+            except OSError:\n+                # Ignore error, caching is not vital.",
      "comment": "Should we make it debug? Could be handy to debug a caching issue one day? Should we also log the OSError type / messing in said debug message?\r\n\r\n```suggestion\r\n                # Ignore error, as caching is not vital.\r\n```",
      "comment_id": 932260410,
      "user": "cooperlees",
      "created_at": "2022-07-28T14:03:17Z",
      "url": "https://github.com/psf/black/pull/3193#discussion_r932260410"
    },
    {
      "repo": "psf/black",
      "pr_number": 2740,
      "file_path": "src/black/mode.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,77 +29,45 @@ class TargetVersion(Enum):\n     PY39 = 9\n     PY310 = 10\n \n-    def is_python2(self) -> bool:\n-        return self is TargetVersion.PY27\n-\n \n class Feature(Enum):",
      "comment": "Unrelated, but should we use `enum.auto()` to avoid numbering features ourselves?",
      "comment_id": 777249811,
      "user": "felix-hilden",
      "created_at": "2022-01-02T20:16:22Z",
      "url": "https://github.com/psf/black/pull/2740#discussion_r777249811"
    },
    {
      "repo": "psf/black",
      "pr_number": 2740,
      "file_path": "src/black/strings.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -138,17 +138,17 @@ def assert_is_leaf_string(string: str) -> None:\n     ), f\"{set(string[:quote_idx])} is NOT a subset of {set(STRING_PREFIX_CHARS)}.\"\n \n \n-def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n-    \"\"\"Make all string prefixes lowercase.\n-\n-    If remove_u_prefix is given, also removes any u prefix from the string.\n-    \"\"\"\n+def normalize_string_prefix(s: str) -> str:\n+    \"\"\"Make all string prefixes lowercase.\"\"\"\n     match = STRING_PREFIX_RE.match(s)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n-    new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n-    if remove_u_prefix:\n-        new_prefix = new_prefix.replace(\"u\", \"\")\n+    new_prefix = (\n+        orig_prefix.replace(\"F\", \"f\")\n+        .replace(\"B\", \"b\")\n+        .replace(\"U\", \"u\")\n+        .replace(\"u\", \"\")\n+    )",
      "comment": "```suggestion\r\n    new_prefix = orig_prefix.lower().replace(\"u\", \"\")\r\n```\r\nRemind me again, is r/R just because of [MagicPython](https://github.com/MagicStack/MagicPython)? It doesn't seem that popular anymore. I hate \"R\" and surely Pygments is the standard \ud83d\ude04 ",
      "comment_id": 777250760,
      "user": "felix-hilden",
      "created_at": "2022-01-02T20:28:30Z",
      "url": "https://github.com/psf/black/pull/2740#discussion_r777250760"
    },
    {
      "repo": "psf/black",
      "pr_number": 2740,
      "file_path": "src/black/strings.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -138,17 +138,17 @@ def assert_is_leaf_string(string: str) -> None:\n     ), f\"{set(string[:quote_idx])} is NOT a subset of {set(STRING_PREFIX_CHARS)}.\"\n \n \n-def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n-    \"\"\"Make all string prefixes lowercase.\n-\n-    If remove_u_prefix is given, also removes any u prefix from the string.\n-    \"\"\"\n+def normalize_string_prefix(s: str) -> str:\n+    \"\"\"Make all string prefixes lowercase.\"\"\"\n     match = STRING_PREFIX_RE.match(s)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n-    new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n-    if remove_u_prefix:\n-        new_prefix = new_prefix.replace(\"u\", \"\")\n+    new_prefix = (\n+        orig_prefix.replace(\"F\", \"f\")\n+        .replace(\"B\", \"b\")\n+        .replace(\"U\", \"u\")\n+        .replace(\"u\", \"\")\n+    )",
      "comment": "Yeah I'd prefer to keep this separate as the r vs R distinction isn't specific to Python 2 in any way. We can continue discussion in that issue, thanks for opening it! ",
      "comment_id": 779928465,
      "user": "ichard26",
      "created_at": "2022-01-06T23:15:38Z",
      "url": "https://github.com/psf/black/pull/2740#discussion_r779928465"
    },
    {
      "repo": "psf/black",
      "pr_number": 2740,
      "file_path": "src/black/mode.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,77 +29,45 @@ class TargetVersion(Enum):\n     PY39 = 9\n     PY310 = 10\n \n-    def is_python2(self) -> bool:\n-        return self is TargetVersion.PY27\n-\n \n class Feature(Enum):",
      "comment": "I have no preference, I do like the grouping nature of the current numbering but the empty lines do a good enough job at delimiting groups as well.",
      "comment_id": 779929515,
      "user": "ichard26",
      "created_at": "2022-01-06T23:18:15Z",
      "url": "https://github.com/psf/black/pull/2740#discussion_r779929515"
    },
    {
      "repo": "psf/black",
      "pr_number": 2740,
      "file_path": "src/black/mode.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,77 +29,45 @@ class TargetVersion(Enum):\n     PY39 = 9\n     PY310 = 10\n \n-    def is_python2(self) -> bool:\n-        return self is TargetVersion.PY27\n-\n \n class Feature(Enum):",
      "comment": "Up to you I think. On one hand, changing one value like `unicode literal` here leads to the need to change many others as well, but on the other, there shouldn't be any changes like this on the horizon and the grouping *is* nice, albeit only really impactful on these few lines unless the values are actually used somewhere, which I doubt. *Also* not strictly in the scope of this PR either \ud83d\ude04 but I like the boy scout rule.",
      "comment_id": 779940786,
      "user": "felix-hilden",
      "created_at": "2022-01-06T23:50:25Z",
      "url": "https://github.com/psf/black/pull/2740#discussion_r779940786"
    },
    {
      "repo": "psf/black",
      "pr_number": 2740,
      "file_path": "src/black/mode.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,77 +29,45 @@ class TargetVersion(Enum):\n     PY39 = 9\n     PY310 = 10\n \n-    def is_python2(self) -> bool:\n-        return self is TargetVersion.PY27\n-\n \n class Feature(Enum):",
      "comment": "What you have is fine but I'd just remove what needs removing and not renumber anything.",
      "comment_id": 780387239,
      "user": "JelleZijlstra",
      "created_at": "2022-01-07T16:43:21Z",
      "url": "https://github.com/psf/black/pull/2740#discussion_r780387239"
    },
    {
      "repo": "psf/black",
      "pr_number": 2740,
      "file_path": "src/black/strings.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -138,17 +138,17 @@ def assert_is_leaf_string(string: str) -> None:\n     ), f\"{set(string[:quote_idx])} is NOT a subset of {set(STRING_PREFIX_CHARS)}.\"\n \n \n-def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n-    \"\"\"Make all string prefixes lowercase.\n-\n-    If remove_u_prefix is given, also removes any u prefix from the string.\n-    \"\"\"\n+def normalize_string_prefix(s: str) -> str:\n+    \"\"\"Make all string prefixes lowercase.\"\"\"\n     match = STRING_PREFIX_RE.match(s)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n-    new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n-    if remove_u_prefix:\n-        new_prefix = new_prefix.replace(\"u\", \"\")\n+    new_prefix = (\n+        orig_prefix.replace(\"F\", \"f\")\n+        .replace(\"B\", \"b\")\n+        .replace(\"U\", \"u\")",
      "comment": "```suggestion\r\n        .replace(\"U\", \"\")\r\n```\r\nSlightly more clear and efficient.",
      "comment_id": 780388798,
      "user": "JelleZijlstra",
      "created_at": "2022-01-07T16:45:42Z",
      "url": "https://github.com/psf/black/pull/2740#discussion_r780388798"
    },
    {
      "repo": "psf/black",
      "pr_number": 2740,
      "file_path": "src/black/mode.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,77 +29,45 @@ class TargetVersion(Enum):\n     PY39 = 9\n     PY310 = 10\n \n-    def is_python2(self) -> bool:\n-        return self is TargetVersion.PY27\n-\n \n class Feature(Enum):",
      "comment": "Fair enough, I'll undo the renumbering to preserve git blame.",
      "comment_id": 780796347,
      "user": "ichard26",
      "created_at": "2022-01-09T15:33:09Z",
      "url": "https://github.com/psf/black/pull/2740#discussion_r780796347"
    },
    {
      "repo": "psf/black",
      "pr_number": 2740,
      "file_path": "src/blackd/__init__.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,10 +174,8 @@ def parse_python_variant_header(value: str) -> Tuple[bool, Set[black.TargetVersi\n                     raise InvalidVariantHeader(\"major version must be 2 or 3\")\n                 if len(rest) > 0:\n                     minor = int(rest[0])\n-                    if major == 2 and minor != 7:\n-                        raise InvalidVariantHeader(\n-                            \"minor version must be 7 for Python 2\"\n-                        )\n+                    if major == 2:\n+                        raise InvalidVariantHeader(\"Python 2 is unsupported\")",
      "comment": "```suggestion\r\n                        raise InvalidVariantHeader(\"Python 2 is not supported\")\r\n```\r\nNIT: my bad if it really means something like \"support was removed\", but this sounds off to me.",
      "comment_id": 781126295,
      "user": "felix-hilden",
      "created_at": "2022-01-10T11:52:33Z",
      "url": "https://github.com/psf/black/pull/2740#discussion_r781126295"
    },
    {
      "repo": "psf/black",
      "pr_number": 3188,
      "file_path": "src/black/nodes.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,14 +16,13 @@\n \n from mypy_extensions import mypyc_attr\n \n-# lib2to3 fork\n-from blib2to3.pytree import Node, Leaf, type_repr, NL\n-from blib2to3 import pygram\n-from blib2to3.pgen2 import token\n-\n from black.cache import CACHE_DIR\n from black.strings import has_triple_quotes\n+from blib2to3 import pygram\n+from blib2to3.pgen2 import token\n \n+# lib2to3 fork",
      "comment": "Did this comment cause the next line to be in it's own section? It seems like it would make more sense above all blib2to3 imports.\n\nNote there are a couple of other occurrences of this comment in different files that may need looking at. They could possibly all just be removed though tbh.",
      "comment_id": 931326017,
      "user": "wookie184",
      "created_at": "2022-07-27T17:31:15Z",
      "url": "https://github.com/psf/black/pull/3188#discussion_r931326017"
    },
    {
      "repo": "psf/black",
      "pr_number": 3175,
      "file_path": "tests/test_format.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,6 +28,7 @@ def check_file(\n     assert_format(source, expected, mode, fast=False)\n \n \n+@pytest.mark.filterwarnings(\"ignore:invalid escape sequence.*:DeprecationWarning\")",
      "comment": "this is caused by this example test case:\r\n\r\nhttps://github.com/psf/black/blob/e026701b9a894ef19ad59eb6e394e5f3f7c18fdd/tests/data/simple_cases/docstring.py#L163\r\n\r\nat some point a future python version will cause this test to fail",
      "comment_id": 922679150,
      "user": "graingert",
      "created_at": "2022-07-16T13:15:11Z",
      "url": "https://github.com/psf/black/pull/3175#discussion_r922679150"
    },
    {
      "repo": "psf/black",
      "pr_number": 3175,
      "file_path": "tests/test_format.py",
      "line": 136,
      "side": "RIGHT",
      "diff_hunk": "@@ -132,6 +133,7 @@ def test_python_2_hint() -> None:\n     exc_info.match(black.parsing.PY2_HINT)\n \n \n+@pytest.mark.filterwarnings(\"ignore:invalid escape sequence.*:DeprecationWarning\")",
      "comment": "this is caused by this example test case:\r\n\r\nhttps://github.com/psf/black/blob/e026701b9a894ef19ad59eb6e394e5f3f7c18fdd/tests/data/miscellaneous/docstring_no_string_normalization.py#L107\r\n\r\nat some point a future python version will cause this test to fail",
      "comment_id": 922679307,
      "user": "graingert",
      "created_at": "2022-07-16T13:16:25Z",
      "url": "https://github.com/psf/black/pull/3175#discussion_r922679307"
    },
    {
      "repo": "psf/black",
      "pr_number": 3175,
      "file_path": "tests/test_format.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,6 +28,7 @@ def check_file(\n     assert_format(source, expected, mode, fast=False)\n \n \n+@pytest.mark.filterwarnings(\"ignore:invalid escape sequence.*:DeprecationWarning\")",
      "comment": "or maybe it will just be a warning forever ;) ? https://github.com/python/cpython/issues/77093",
      "comment_id": 922681109,
      "user": "graingert",
      "created_at": "2022-07-16T13:36:23Z",
      "url": "https://github.com/psf/black/pull/3175#discussion_r922681109"
    },
    {
      "repo": "psf/black",
      "pr_number": 3168,
      "file_path": "src/black/linegen.py",
      "line": 298,
      "side": "RIGHT",
      "diff_hunk": "@@ -293,7 +293,24 @@ def visit_STRING(self, leaf: Leaf) -> Iterator[Line]:\n         if is_docstring(leaf) and \"\\\\\\n\" not in leaf.value:\n             # We're ignoring docstrings with backslash newline escapes because changing\n             # indentation of those changes the AST representation of the code.\n-            docstring = normalize_string_prefix(leaf.value)\n+            if Preview.normalize_docstring_quotes_and_prefixes_properly in self.mode:\n+                # There was a bug where --skip-string-normalization wouldn't stop us\n+                # from normalize docstring prefixes. To maintain stability, we can only",
      "comment": "```suggestion\r\n                # from normalizing docstring prefixes. To maintain stability, we can only\r\n```",
      "comment_id": 921625607,
      "user": "JelleZijlstra",
      "created_at": "2022-07-14T22:29:30Z",
      "url": "https://github.com/psf/black/pull/3168#discussion_r921625607"
    },
    {
      "repo": "psf/black",
      "pr_number": 3164,
      "file_path": "src/black/__init__.py",
      "line": 790,
      "side": "RIGHT",
      "diff_hunk": "@@ -788,6 +787,7 @@ def reformat_many(\n         # any good due to the Global Interpreter Lock)\n         executor = ThreadPoolExecutor(max_workers=1)\n \n+    loop = asyncio.new_event_loop()",
      "comment": "```suggestion\r\n    loop = asyncio.new_event_loop()\r\n    asyncio.set_event_loop(loop)\r\n```",
      "comment_id": 920285170,
      "user": "graingert",
      "created_at": "2022-07-13T16:31:53Z",
      "url": "https://github.com/psf/black/pull/3164#discussion_r920285170"
    },
    {
      "repo": "psf/black",
      "pr_number": 3164,
      "file_path": "src/black/__init__.py",
      "line": 790,
      "side": "RIGHT",
      "diff_hunk": "@@ -788,6 +787,7 @@ def reformat_many(\n         # any good due to the Global Interpreter Lock)\n         executor = ThreadPoolExecutor(max_workers=1)\n \n+    loop = asyncio.new_event_loop()",
      "comment": "Then with the corresponding change in the finally block:\r\n```\r\nfinally:\r\n    try:\r\n        shutdown(loop)\r\n    finally:\r\n        asyncio.set_event_loop(None)\r\n```",
      "comment_id": 920286721,
      "user": "graingert",
      "created_at": "2022-07-13T16:33:34Z",
      "url": "https://github.com/psf/black/pull/3164#discussion_r920286721"
    },
    {
      "repo": "psf/black",
      "pr_number": 2879,
      "file_path": "tests/test_format.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,6 +62,7 @@\n ]\n \n PY310_CASES: List[str] = [\n+    \"starred_for_target\",",
      "comment": "Since the PEP 617 was opt-out in 3.9, the given examples are rejected by the official AST when the user starts the python interpreter with `-Xoldparser`. It is why I've added tests to 3.10 group.",
      "comment_id": 804879491,
      "user": "isidentical",
      "created_at": "2022-02-11T17:51:05Z",
      "url": "https://github.com/psf/black/pull/2879#discussion_r804879491"
    },
    {
      "repo": "psf/black",
      "pr_number": 3069,
      "file_path": "src/black/__init__.py",
      "line": 1249,
      "side": "LEFT",
      "diff_hunk": "@@ -1245,8 +1245,7 @@ def get_features_used(  # noqa: C901\n             if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                 features.add(Feature.F_STRINGS)\n \n-        elif n.type == token.NUMBER:\n-            assert isinstance(n, Leaf)",
      "comment": "So is `TypeGuard` is enforced with mypyc? If not, we're missing an assert. (Just wanting to make sure, since I'm not familiar with this)",
      "comment_id": 894988081,
      "user": "felix-hilden",
      "created_at": "2022-06-11T07:07:21Z",
      "url": "https://github.com/psf/black/pull/3069#discussion_r894988081"
    },
    {
      "repo": "psf/black",
      "pr_number": 3069,
      "file_path": "src/black/__init__.py",
      "line": 1249,
      "side": "LEFT",
      "diff_hunk": "@@ -1245,8 +1245,7 @@ def get_features_used(  # noqa: C901\n             if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                 features.add(Feature.F_STRINGS)\n \n-        elif n.type == token.NUMBER:\n-            assert isinstance(n, Leaf)",
      "comment": "I'm not familiar with mypyc, so handling over to @ichard26 for this one",
      "comment_id": 894989525,
      "user": "MarcoGorelli",
      "created_at": "2022-06-11T07:23:03Z",
      "url": "https://github.com/psf/black/pull/3069#discussion_r894989525"
    },
    {
      "repo": "psf/black",
      "pr_number": 3069,
      "file_path": "src/black/__init__.py",
      "line": 1249,
      "side": "LEFT",
      "diff_hunk": "@@ -1245,8 +1245,7 @@ def get_features_used(  # noqa: C901\n             if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                 features.add(Feature.F_STRINGS)\n \n-        elif n.type == token.NUMBER:\n-            assert isinstance(n, Leaf)",
      "comment": "As I understood [the doc](https://mypy.readthedocs.io/en/latest/type_narrowing.html), `TypeGuard` is not equivalent to `isinstance` at runtime \ud83e\udd14 at least without the compilation. Or are we saying that we don't really need it?",
      "comment_id": 894990583,
      "user": "felix-hilden",
      "created_at": "2022-06-11T07:34:07Z",
      "url": "https://github.com/psf/black/pull/3069#discussion_r894990583"
    },
    {
      "repo": "psf/black",
      "pr_number": 3069,
      "file_path": "src/black/__init__.py",
      "line": 1249,
      "side": "LEFT",
      "diff_hunk": "@@ -1245,8 +1245,7 @@ def get_features_used(  # noqa: C901\n             if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                 features.add(Feature.F_STRINGS)\n \n-        elif n.type == token.NUMBER:\n-            assert isinstance(n, Leaf)",
      "comment": "I don't think it's needed, IIUC the `assert` was only there originally as a hint to `mypy`, it's not a condition one would expect to fail at runtime",
      "comment_id": 894991889,
      "user": "MarcoGorelli",
      "created_at": "2022-06-11T07:48:16Z",
      "url": "https://github.com/psf/black/pull/3069#discussion_r894991889"
    },
    {
      "repo": "psf/black",
      "pr_number": 3069,
      "file_path": "src/black/__init__.py",
      "line": 1249,
      "side": "LEFT",
      "diff_hunk": "@@ -1245,8 +1245,7 @@ def get_features_used(  # noqa: C901\n             if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                 features.add(Feature.F_STRINGS)\n \n-        elif n.type == token.NUMBER:\n-            assert isinstance(n, Leaf)",
      "comment": "Oh, I see. If this is the case then consider it resolved!",
      "comment_id": 894992836,
      "user": "felix-hilden",
      "created_at": "2022-06-11T07:58:06Z",
      "url": "https://github.com/psf/black/pull/3069#discussion_r894992836"
    },
    {
      "repo": "psf/black",
      "pr_number": 3069,
      "file_path": "src/black/__init__.py",
      "line": 1249,
      "side": "LEFT",
      "diff_hunk": "@@ -1245,8 +1245,7 @@ def get_features_used(  # noqa: C901\n             if value_head in {'f\"', 'F\"', \"f'\", \"F'\", \"rf\", \"fr\", \"RF\", \"FR\"}:\n                 features.add(Feature.F_STRINGS)\n \n-        elif n.type == token.NUMBER:\n-            assert isinstance(n, Leaf)",
      "comment": "Yeah I don't think it's even possible for this assertion to fail as the CST types representing numbers are always of type `Leaf`. TypeGuard is a cleaner way to tell type checkers that we can narrow a type if a conditional passes. ",
      "comment_id": 895039701,
      "user": "ichard26",
      "created_at": "2022-06-11T15:47:00Z",
      "url": "https://github.com/psf/black/pull/3069#discussion_r895039701"
    },
    {
      "repo": "psf/black",
      "pr_number": 3038,
      "file_path": "scripts/migrate-black.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,83 @@\n+#!/usr/bin/env python3\n+# check out every commit added by the current branch, blackify them,\n+# and generate diffs to reconstruct the original commits, but then\n+# blackified\n+import os\n+import sys\n+from subprocess import check_output, run, Popen, PIPE\n+\n+\n+def git(*args):\n+    return check_output([\"git\"] + list(args)).decode(\"utf8\").strip()\n+\n+\n+def blackify(base_branch, black_command):\n+    current_branch = git(\"branch\", \"--show-current\")\n+\n+    if not current_branch or base_branch == current_branch:\n+        print(\"You need to check out a feature brach to work on\")\n+        return 1\n+\n+    if not os.path.exists(\".git\"):\n+        print(\"Run me in the root of your repo\")\n+        return 1\n+\n+    merge_base = git(\"merge-base\", \"HEAD\", base_branch)\n+    if not merge_base:\n+        print(\"Could not find a common commit for current head and %s\" % base_branch)\n+        return 1\n+\n+    commits = git(\n+        \"log\", \"--reverse\", \"--pretty=format:%H\", \"%s~1..HEAD\" % merge_base\n+    ).split()\n+    for commit in commits:\n+        git(\"checkout\", commit, \"-b\" \"%s-black\" % commit)\n+        check_output(black_command, shell=True)\n+        git(\"commit\", \"-aqm\", \"blackify\")\n+\n+    git(\"checkout\", base_branch, \"-b\" \"%s-black\" % current_branch)\n+\n+    for last_commit, commit in zip(commits, commits[1:]):\n+        allow_empty = (\n+            b\"--allow-empty\" in run([\"git\", \"apply\", \"-h\"], stdout=PIPE).stdout\n+        )\n+        quiet = (\n+            b\"--quiet\" in run([\"git\", \"apply\", \"-h\"], stdout=PIPE).stdout\n+        )\n+        git_diff = Popen(\n+            [\"git\", \"diff\", \"--find-copies\", \"%s-black..%s-black\" % (last_commit, commit)],\n+            stdout=PIPE,\n+        )\n+        git_apply = Popen(\n+            [\n+                \"git\",\n+                \"apply\",\n+            ]\n+            + ([\"--quiet\"] if quiet else [])\n+            + [\n+                \"-3\",\n+                \"--intent-to-add\",\n+            ]\n+            + ([\"--allow-empty\"] if allow_empty else [])\n+            + [\n+                \"-\",\n+            ],\n+            stdin=git_diff.stdout,\n+            stdout=PIPE,\n+        )\n+        git_diff.stdout.close()\n+        git_apply.communicate()\n+        git(\"commit\", \"--allow-empty\", \"-aqC\", commit)\n+\n+    for commit in commits:\n+        git(\"branch\", \"-qD\", \"%s-black\" % commit)\n+\n+\n+if __name__ == \"__main__\":\n+    import argparse\n+\n+    parser = argparse.ArgumentParser()\n+    parser.add_argument(\"base_branch\")\n+    parser.add_argument(\"--black_command\", default=\"black -q .\")",
      "comment": "I'd recommend not using `-q` and piping black's output to a log incase something goes wrong and then we have logs to debug.",
      "comment_id": 862372902,
      "user": "cooperlees",
      "created_at": "2022-04-30T16:24:52Z",
      "url": "https://github.com/psf/black/pull/3038#discussion_r862372902"
    },
    {
      "repo": "psf/black",
      "pr_number": 3038,
      "file_path": "scripts/migrate-black.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,83 @@\n+#!/usr/bin/env python3\n+# check out every commit added by the current branch, blackify them,\n+# and generate diffs to reconstruct the original commits, but then\n+# blackified\n+import os\n+import sys\n+from subprocess import check_output, run, Popen, PIPE\n+\n+\n+def git(*args):\n+    return check_output([\"git\"] + list(args)).decode(\"utf8\").strip()",
      "comment": "Why are you stripping newlines here? Couldn't that messup output?",
      "comment_id": 862373017,
      "user": "cooperlees",
      "created_at": "2022-04-30T16:26:01Z",
      "url": "https://github.com/psf/black/pull/3038#discussion_r862373017"
    },
    {
      "repo": "psf/black",
      "pr_number": 3038,
      "file_path": "scripts/migrate-black.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,83 @@\n+#!/usr/bin/env python3\n+# check out every commit added by the current branch, blackify them,\n+# and generate diffs to reconstruct the original commits, but then\n+# blackified\n+import os\n+import sys\n+from subprocess import check_output, run, Popen, PIPE\n+\n+\n+def git(*args):\n+    return check_output([\"git\"] + list(args)).decode(\"utf8\").strip()\n+\n+\n+def blackify(base_branch, black_command):\n+    current_branch = git(\"branch\", \"--show-current\")\n+\n+    if not current_branch or base_branch == current_branch:\n+        print(\"You need to check out a feature brach to work on\")",
      "comment": "Generally logging message I recommend using a logger from the logging module and writing to stderr - But we can clean that up in a follow up diff.",
      "comment_id": 862373086,
      "user": "cooperlees",
      "created_at": "2022-04-30T16:26:44Z",
      "url": "https://github.com/psf/black/pull/3038#discussion_r862373086"
    },
    {
      "repo": "psf/black",
      "pr_number": 3038,
      "file_path": "scripts/migrate-black.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,83 @@\n+#!/usr/bin/env python3\n+# check out every commit added by the current branch, blackify them,\n+# and generate diffs to reconstruct the original commits, but then\n+# blackified\n+import os\n+import sys\n+from subprocess import check_output, run, Popen, PIPE\n+\n+\n+def git(*args):\n+    return check_output([\"git\"] + list(args)).decode(\"utf8\").strip()\n+\n+\n+def blackify(base_branch, black_command):\n+    current_branch = git(\"branch\", \"--show-current\")\n+\n+    if not current_branch or base_branch == current_branch:\n+        print(\"You need to check out a feature brach to work on\")\n+        return 1\n+\n+    if not os.path.exists(\".git\"):\n+        print(\"Run me in the root of your repo\")\n+        return 1\n+\n+    merge_base = git(\"merge-base\", \"HEAD\", base_branch)\n+    if not merge_base:\n+        print(\"Could not find a common commit for current head and %s\" % base_branch)\n+        return 1\n+\n+    commits = git(\n+        \"log\", \"--reverse\", \"--pretty=format:%H\", \"%s~1..HEAD\" % merge_base\n+    ).split()\n+    for commit in commits:\n+        git(\"checkout\", commit, \"-b\" \"%s-black\" % commit)\n+        check_output(black_command, shell=True)",
      "comment": "```suggestion\r\n        import shlex\r\n        check_output(shlex.split(black_command))\r\n```\r\nShouldn't need shell=True here ...",
      "comment_id": 862373562,
      "user": "cooperlees",
      "created_at": "2022-04-30T16:31:37Z",
      "url": "https://github.com/psf/black/pull/3038#discussion_r862373562"
    },
    {
      "repo": "psf/black",
      "pr_number": 3038,
      "file_path": "scripts/migrate-black.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,83 @@\n+#!/usr/bin/env python3\n+# check out every commit added by the current branch, blackify them,\n+# and generate diffs to reconstruct the original commits, but then\n+# blackified\n+import os\n+import sys\n+from subprocess import check_output, run, Popen, PIPE\n+\n+\n+def git(*args):\n+    return check_output([\"git\"] + list(args)).decode(\"utf8\").strip()\n+\n+\n+def blackify(base_branch, black_command):\n+    current_branch = git(\"branch\", \"--show-current\")\n+\n+    if not current_branch or base_branch == current_branch:\n+        print(\"You need to check out a feature brach to work on\")\n+        return 1\n+\n+    if not os.path.exists(\".git\"):\n+        print(\"Run me in the root of your repo\")\n+        return 1\n+\n+    merge_base = git(\"merge-base\", \"HEAD\", base_branch)\n+    if not merge_base:\n+        print(\"Could not find a common commit for current head and %s\" % base_branch)\n+        return 1\n+\n+    commits = git(\n+        \"log\", \"--reverse\", \"--pretty=format:%H\", \"%s~1..HEAD\" % merge_base\n+    ).split()\n+    for commit in commits:\n+        git(\"checkout\", commit, \"-b\" \"%s-black\" % commit)\n+        check_output(black_command, shell=True)",
      "comment": "the idea was to allow things like `black .; isort .` here",
      "comment_id": 862375210,
      "user": "hbrunn",
      "created_at": "2022-04-30T16:48:22Z",
      "url": "https://github.com/psf/black/pull/3038#discussion_r862375210"
    },
    {
      "repo": "psf/black",
      "pr_number": 3038,
      "file_path": "scripts/migrate-black.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,83 @@\n+#!/usr/bin/env python3\n+# check out every commit added by the current branch, blackify them,\n+# and generate diffs to reconstruct the original commits, but then\n+# blackified\n+import os\n+import sys\n+from subprocess import check_output, run, Popen, PIPE\n+\n+\n+def git(*args):\n+    return check_output([\"git\"] + list(args)).decode(\"utf8\").strip()",
      "comment": "no, but we need to get rid of the whitespace some versions of git add before/after its output",
      "comment_id": 862517451,
      "user": "hbrunn",
      "created_at": "2022-05-01T20:22:28Z",
      "url": "https://github.com/psf/black/pull/3038#discussion_r862517451"
    },
    {
      "repo": "psf/black",
      "pr_number": 3038,
      "file_path": "scripts/migrate-black.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,92 @@\n+#!/usr/bin/env python3\n+# check out every commit added by the current branch, blackify them,\n+# and generate diffs to reconstruct the original commits, but then\n+# blackified\n+import logging\n+import os\n+import sys\n+from subprocess import check_output, run, Popen, PIPE\n+\n+\n+def git(*args):",
      "comment": "`mypy` CI is failing - Can you please type annotate the code since we have very high type coverage elsewhere.",
      "comment_id": 883083889,
      "user": "cooperlees",
      "created_at": "2022-05-26T21:07:10Z",
      "url": "https://github.com/psf/black/pull/3038#discussion_r883083889"
    },
    {
      "repo": "psf/black",
      "pr_number": 3038,
      "file_path": "scripts/migrate-black.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,96 @@\n+#!/usr/bin/env python3\n+# check out every commit added by the current branch, blackify them,\n+# and generate diffs to reconstruct the original commits, but then\n+# blackified\n+import logging\n+import os\n+import sys\n+from collections import abc\n+from subprocess import check_output, run, Popen, PIPE\n+\n+\n+def git(*args: abc.Iterable[str]) -> str:",
      "comment": "```suggestion\r\ndef git(*args: Sequence[str]) -> str:\r\n```",
      "comment_id": 884047621,
      "user": "cooperlees",
      "created_at": "2022-05-28T01:26:36Z",
      "url": "https://github.com/psf/black/pull/3038#discussion_r884047621"
    },
    {
      "repo": "psf/black",
      "pr_number": 3038,
      "file_path": "scripts/migrate-black.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,96 @@\n+#!/usr/bin/env python3\n+# check out every commit added by the current branch, blackify them,\n+# and generate diffs to reconstruct the original commits, but then\n+# blackified\n+import logging\n+import os\n+import sys\n+from collections import abc\n+from subprocess import check_output, run, Popen, PIPE",
      "comment": "```suggestion\r\nfrom subprocess import check_output, run, Popen, PIPE\r\nfrom typing import Sequence\r\n```",
      "comment_id": 884047664,
      "user": "cooperlees",
      "created_at": "2022-05-28T01:26:57Z",
      "url": "https://github.com/psf/black/pull/3038#discussion_r884047664"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_format.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,38 +15,6 @@\n     all_data_cases,\n )\n \n-PY310_CASES: List[str] = [\n-    \"starred_for_target\",\n-    \"pattern_matching_simple\",\n-    \"pattern_matching_complex\",\n-    \"pattern_matching_extras\",\n-    \"pattern_matching_style\",\n-    \"pattern_matching_generic\",\n-    \"parenthesized_context_managers\",\n-]\n-\n-PY311_CASES: List[str] = [\n-    \"pep_654\",\n-    \"pep_654_style\",\n-]\n-\n-PREVIEW_CASES: List[str] = [\n-    # string processing\n-    \"cantfit\",\n-    \"comments7\",\n-    \"comments8\",\n-    \"long_strings\",\n-    \"long_strings__edge_case\",\n-    \"long_strings__regression\",\n-    \"percent_precedence\",\n-    \"remove_except_parens\",\n-    \"remove_for_brackets\",\n-    \"one_element_subscript\",\n-    \"remove_await_parens\",\n-    \"return_annotation_brackets\",\n-    \"docstring_preview\",\n-]\n-\n SOURCES: List[str] = [",
      "comment": "Should we also walk the source directories here and get all of the Python files?",
      "comment_id": 867959884,
      "user": "felix-hilden",
      "created_at": "2022-05-09T12:32:15Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r867959884"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_format.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -164,15 +132,16 @@ def test_remove_with_brackets() -> None:\n     )\n \n \n-@pytest.mark.parametrize(\"filename\", PY310_CASES)\n+@pytest.mark.parametrize(\"filename\", all_data_cases(\"py_310\"))\n def test_python_310(filename: str) -> None:\n     source, expected = read_data(filename)\n     mode = black.Mode(target_versions={black.TargetVersion.PY310})\n     assert_format(source, expected, mode, minimum_version=(3, 10))\n \n \n-def test_python_310_without_target_version() -> None:\n-    source, expected = read_data(\"pattern_matching_simple\")\n+@pytest.mark.parametrize(\"filename\", all_data_cases(\"py_310\"))",
      "comment": "Just noting that this changed, but I guess it can't hurt to test all the cases!",
      "comment_id": 867963978,
      "user": "felix-hilden",
      "created_at": "2022-05-09T12:37:10Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r867963978"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_format.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,38 +15,6 @@\n     all_data_cases,\n )\n \n-PY310_CASES: List[str] = [\n-    \"starred_for_target\",\n-    \"pattern_matching_simple\",\n-    \"pattern_matching_complex\",\n-    \"pattern_matching_extras\",\n-    \"pattern_matching_style\",\n-    \"pattern_matching_generic\",\n-    \"parenthesized_context_managers\",\n-]\n-\n-PY311_CASES: List[str] = [\n-    \"pep_654\",\n-    \"pep_654_style\",\n-]\n-\n-PREVIEW_CASES: List[str] = [\n-    # string processing\n-    \"cantfit\",\n-    \"comments7\",\n-    \"comments8\",\n-    \"long_strings\",\n-    \"long_strings__edge_case\",\n-    \"long_strings__regression\",\n-    \"percent_precedence\",\n-    \"remove_except_parens\",\n-    \"remove_for_brackets\",\n-    \"one_element_subscript\",\n-    \"remove_await_parens\",\n-    \"return_annotation_brackets\",\n-    \"docstring_preview\",\n-]\n-\n SOURCES: List[str] = [",
      "comment": "I believe that the right thing to do is to add the following step/job to the CI process:\r\n\r\n```shell\r\npip install -e .\r\nblack --check src\r\n```\r\n\r\n**This should not be a unit test in my opinion**, but another step/job in the CI process.\r\n\r\nIf you want an example, see what I did for my tool [Statue](https://github.com/saroad2/statue) in the CI process.\r\nIn the end of the CI I added a step called \"Run on self\" that checks that the code of statue pass the static code analysis ran by statue.",
      "comment_id": 867985534,
      "user": "saroad2",
      "created_at": "2022-05-09T13:00:03Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r867985534"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_format.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -164,15 +132,16 @@ def test_remove_with_brackets() -> None:\n     )\n \n \n-@pytest.mark.parametrize(\"filename\", PY310_CASES)\n+@pytest.mark.parametrize(\"filename\", all_data_cases(\"py_310\"))\n def test_python_310(filename: str) -> None:\n     source, expected = read_data(filename)\n     mode = black.Mode(target_versions={black.TargetVersion.PY310})\n     assert_format(source, expected, mode, minimum_version=(3, 10))\n \n \n-def test_python_310_without_target_version() -> None:\n-    source, expected = read_data(\"pattern_matching_simple\")\n+@pytest.mark.parametrize(\"filename\", all_data_cases(\"py_310\"))",
      "comment": "I thought that this is the right thing to do, because the test is not specific for \"pattern_matching_simple\"",
      "comment_id": 867986554,
      "user": "saroad2",
      "created_at": "2022-05-09T13:01:09Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r867986554"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_format.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,38 +15,6 @@\n     all_data_cases,\n )\n \n-PY310_CASES: List[str] = [\n-    \"starred_for_target\",\n-    \"pattern_matching_simple\",\n-    \"pattern_matching_complex\",\n-    \"pattern_matching_extras\",\n-    \"pattern_matching_style\",\n-    \"pattern_matching_generic\",\n-    \"parenthesized_context_managers\",\n-]\n-\n-PY311_CASES: List[str] = [\n-    \"pep_654\",\n-    \"pep_654_style\",\n-]\n-\n-PREVIEW_CASES: List[str] = [\n-    # string processing\n-    \"cantfit\",\n-    \"comments7\",\n-    \"comments8\",\n-    \"long_strings\",\n-    \"long_strings__edge_case\",\n-    \"long_strings__regression\",\n-    \"percent_precedence\",\n-    \"remove_except_parens\",\n-    \"remove_for_brackets\",\n-    \"one_element_subscript\",\n-    \"remove_await_parens\",\n-    \"return_annotation_brackets\",\n-    \"docstring_preview\",\n-]\n-\n SOURCES: List[str] = [",
      "comment": "True, it appears we only check each file with default params, so that would work. I don't have a strong preference for it being in tests or CI. Perhaps [here](https://github.com/psf/black/blob/main/.github/workflows/test.yml#L53) before publishing test results, so that the whole version matrix is tested. Other opinions?",
      "comment_id": 867991728,
      "user": "felix-hilden",
      "created_at": "2022-05-09T13:06:49Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r867991728"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_black.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,7 +159,9 @@ def test_experimental_string_processing_warns(self) -> None:\n         )\n \n     def test_piping(self) -> None:\n-        source, expected = read_data(\"src/black/__init__\", data=False)\n+        source, expected = read_data_from_file(\n+            Path(PROJECT_ROOT / \"src/black/__init__.py\")",
      "comment": "```suggestion\r\n            PROJECT_ROOT / \"src/black/__init__.py\"\r\n```",
      "comment_id": 868100494,
      "user": "felix-hilden",
      "created_at": "2022-05-09T14:49:12Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r868100494"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_black.py",
      "line": 327,
      "side": "RIGHT",
      "diff_hunk": "@@ -320,8 +324,10 @@ def test_string_quotes(self) -> None:\n         black.assert_stable(source, not_normalized, mode=mode)\n \n     def test_skip_magic_trailing_comma(self) -> None:\n-        source, _ = read_data(\"simple_cases/expression.py\")\n-        expected, _ = read_data(\"expression_skip_magic_trailing_comma.diff\")\n+        source, _ = read_data(\"simple_cases\", \"expression.py\")",
      "comment": "```suggestion\r\n        source, _ = read_data(\"simple_cases\", \"expression\")\r\n```",
      "comment_id": 868102252,
      "user": "felix-hilden",
      "created_at": "2022-05-09T14:50:53Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r868102252"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_black.py",
      "line": 764,
      "side": "RIGHT",
      "diff_hunk": "@@ -755,7 +761,7 @@ def test_get_features_used(self) -> None:\n         self.assertEqual(black.get_features_used(node), {Feature.NUMERIC_UNDERSCORES})\n         node = black.lib2to3_parse(\"123456\\n\")\n         self.assertEqual(black.get_features_used(node), set())\n-        source, expected = read_data(\"simple_cases/function.py\")\n+        source, expected = read_data(\"simple_cases\", \"function.py\")",
      "comment": "```suggestion\r\n        source, expected = read_data(\"simple_cases\", \"function\")\r\n```",
      "comment_id": 868102927,
      "user": "felix-hilden",
      "created_at": "2022-05-09T14:51:31Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r868102927"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_black.py",
      "line": 774,
      "side": "RIGHT",
      "diff_hunk": "@@ -765,7 +771,7 @@ def test_get_features_used(self) -> None:\n         self.assertEqual(black.get_features_used(node), expected_features)\n         node = black.lib2to3_parse(expected)\n         self.assertEqual(black.get_features_used(node), expected_features)\n-        source, expected = read_data(\"simple_cases/expression.py\")\n+        source, expected = read_data(\"simple_cases\", \"expression.py\")",
      "comment": "```suggestion\r\n        source, expected = read_data(\"simple_cases\", \"expression\")\r\n```",
      "comment_id": 868103147,
      "user": "felix-hilden",
      "created_at": "2022-05-09T14:51:44Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r868103147"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_black.py",
      "line": 860,
      "side": "RIGHT",
      "diff_hunk": "@@ -851,8 +857,8 @@ def test_get_future_imports(self) -> None:\n \n     @pytest.mark.incompatible_with_mypyc\n     def test_debug_visitor(self) -> None:\n-        source, _ = read_data(\"debug_visitor.py\")\n-        expected, _ = read_data(\"debug_visitor.out\")\n+        source, _ = read_data(\"miscellaneous\", \"debug_visitor.py\")",
      "comment": "```suggestion\r\n        source, _ = read_data(\"miscellaneous\", \"debug_visitor\")\r\n```",
      "comment_id": 868103495,
      "user": "felix-hilden",
      "created_at": "2022-05-09T14:51:58Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r868103495"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_black.py",
      "line": 1463,
      "side": "RIGHT",
      "diff_hunk": "@@ -1454,10 +1460,10 @@ def test_bpo_2142_workaround(self) -> None:\n \n         # https://bugs.python.org/issue2142\n \n-        source, _ = read_data(\"missing_final_newline.py\")\n+        source, _ = read_data(\"miscellaneous\", \"missing_final_newline.py\")",
      "comment": "```suggestion\r\n        source, _ = read_data(\"miscellaneous\", \"missing_final_newline\")\r\n```",
      "comment_id": 868104054,
      "user": "felix-hilden",
      "created_at": "2022-05-09T14:52:29Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r868104054"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_blackd.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,8 +108,8 @@ async def test_blackd_diff(self) -> None:\n             r\"(In|Out)\\t\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d:\\d\\d\\.\\d\\d\\d\\d\\d\\d \\+\\d\\d\\d\\d\"\n         )\n \n-        source, _ = read_data(\"blackd_diff.py\")\n-        expected, _ = read_data(\"blackd_diff.diff\")\n+        source, _ = read_data(\"miscellaneous\", \"blackd_diff.py\")",
      "comment": "```suggestion\r\n        source, _ = read_data(\"miscellaneous\", \"blackd_diff\")\r\n```",
      "comment_id": 868104354,
      "user": "felix-hilden",
      "created_at": "2022-05-09T14:52:46Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r868104354"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_format.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,25 +62,33 @@ def patch_dump_to_file(request: Any) -> Iterator[None]:\n         yield\n \n \n-def check_file(filename: str, mode: black.Mode, *, data: bool = True) -> None:\n-    source, expected = read_data(filename, data=data)\n+def check_file(\n+    subdir: str, filename: str, mode: black.Mode, *, data: bool = True\n+) -> None:\n+    source, expected = read_data(subdir, filename, data=data)\n     assert_format(source, expected, mode, fast=False)\n \n \n @pytest.mark.parametrize(\"filename\", all_data_cases(\"simple_cases\"))\n def test_simple_format(filename: str) -> None:\n-    check_file(filename, DEFAULT_MODE)\n+    check_file(\"simple_cases\", filename, DEFAULT_MODE)\n \n \n-@pytest.mark.parametrize(\"filename\", PREVIEW_CASES)\n+@pytest.mark.parametrize(\"filename\", all_data_cases(\"preview\"))\n def test_preview_format(filename: str) -> None:\n-    check_file(filename, black.Mode(preview=True))\n+    check_file(\"preview\", filename, black.Mode(preview=True))\n+\n+\n+@pytest.mark.parametrize(\"filename\", all_data_cases(\"preview_39\"))\n+def test_preview_minimum_python_39_format(filename: str) -> None:\n+    source, expected = read_data(\"preview_39\", filename)",
      "comment": "If we wanted to, we could try to avoid specifying \"preview_39\" twice (and in other similar places). But they are so close and only twice that I'm not sure if it's worth the effort.",
      "comment_id": 868107000,
      "user": "felix-hilden",
      "created_at": "2022-05-09T14:55:06Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r868107000"
    },
    {
      "repo": "psf/black",
      "pr_number": 3062,
      "file_path": "tests/test_format.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,25 +62,33 @@ def patch_dump_to_file(request: Any) -> Iterator[None]:\n         yield\n \n \n-def check_file(filename: str, mode: black.Mode, *, data: bool = True) -> None:\n-    source, expected = read_data(filename, data=data)\n+def check_file(\n+    subdir: str, filename: str, mode: black.Mode, *, data: bool = True\n+) -> None:\n+    source, expected = read_data(subdir, filename, data=data)\n     assert_format(source, expected, mode, fast=False)\n \n \n @pytest.mark.parametrize(\"filename\", all_data_cases(\"simple_cases\"))\n def test_simple_format(filename: str) -> None:\n-    check_file(filename, DEFAULT_MODE)\n+    check_file(\"simple_cases\", filename, DEFAULT_MODE)\n \n \n-@pytest.mark.parametrize(\"filename\", PREVIEW_CASES)\n+@pytest.mark.parametrize(\"filename\", all_data_cases(\"preview\"))\n def test_preview_format(filename: str) -> None:\n-    check_file(filename, black.Mode(preview=True))\n+    check_file(\"preview\", filename, black.Mode(preview=True))\n+\n+\n+@pytest.mark.parametrize(\"filename\", all_data_cases(\"preview_39\"))\n+def test_preview_minimum_python_39_format(filename: str) -> None:\n+    source, expected = read_data(\"preview_39\", filename)",
      "comment": "We could, but I think it might cause more changes in code.\r\nIt's probably worth another PR.",
      "comment_id": 868295927,
      "user": "saroad2",
      "created_at": "2022-05-09T18:21:23Z",
      "url": "https://github.com/psf/black/pull/3062#discussion_r868295927"
    },
    {
      "repo": "psf/black",
      "pr_number": 3034,
      "file_path": "tests/test_black.py",
      "line": 1171,
      "side": "RIGHT",
      "diff_hunk": "@@ -1168,7 +1168,7 @@ def test_reformat_one_with_stdin_and_existing_path(self) -> None:\n             report = MagicMock()\n             # Even with an existing file, since we are forcing stdin, black\n             # should output to stdout and not modify the file inplace\n-            p = Path(str(THIS_DIR / \"data/collections.py\"))\n+            p = Path(str(THIS_DIR / \"data\" / \"simple_cases\" / \"collections.py\"))",
      "comment": "```suggestion\r\n            p = THIS_DIR / \"data\" / \"simple_cases\" / \"collections.py\"\r\n```\r\nI know this is not your doing, but I'm pretty sure we don't need a double conversion if `THIS_DIR` is a path already \ud83d\ude05",
      "comment_id": 865394555,
      "user": "felix-hilden",
      "created_at": "2022-05-04T21:19:16Z",
      "url": "https://github.com/psf/black/pull/3034#discussion_r865394555"
    },
    {
      "repo": "psf/black",
      "pr_number": 2904,
      "file_path": "tests/test_black.py",
      "line": 2021,
      "side": "LEFT",
      "diff_hunk": "@@ -2014,31 +2032,6 @@ def test_symlink_out_of_root_directory(self) -> None:\n             pytest.fail(f\"`get_python_files_in_dir()` failed: {ve}\")\n         path.iterdir.assert_called_once()\n         child.resolve.assert_called_once()\n-        child.is_symlink.assert_called_once()\n-        # `child` should behave like a strange file which resolved path is clearly\n-        # outside of the `root` directory.\n-        child.is_symlink.return_value = False\n-        with pytest.raises(ValueError):",
      "comment": "So this is a slight behavioral change: _black_ will no longer raise an exception for these _strange files_ (e.g. Windows directory junctions), ignoring them just like symlinks. I don't know of any other _strange_ links, but I can't imagine a benefit in stopping the analysis for any of them.",
      "comment_id": 819304616,
      "user": "yoerg",
      "created_at": "2022-03-04T06:43:27Z",
      "url": "https://github.com/psf/black/pull/2904#discussion_r819304616"
    },
    {
      "repo": "psf/black",
      "pr_number": 3008,
      "file_path": "tests/test_ipynb.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,6 +19,8 @@\n from _pytest.monkeypatch import MonkeyPatch\n from tests.util import DATA_DIR\n \n+with contextlib.suppress(ModuleNotFoundError):",
      "comment": "This won't work well because line 146 will fail if the module isn't available.",
      "comment_id": 847625883,
      "user": "JelleZijlstra",
      "created_at": "2022-04-11T18:36:38Z",
      "url": "https://github.com/psf/black/pull/3008#discussion_r847625883"
    },
    {
      "repo": "psf/black",
      "pr_number": 3008,
      "file_path": "tests/test_ipynb.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,6 +19,8 @@\n from _pytest.monkeypatch import MonkeyPatch\n from tests.util import DATA_DIR\n \n+with contextlib.suppress(ModuleNotFoundError):",
      "comment": "on line 25 there's\r\n```\r\npytest.importorskip(\"IPython\", reason=\"IPython is an optional dependency\")\r\n```\r\nso if `IPython` isn't available, line 146 is never reached",
      "comment_id": 847630686,
      "user": "MarcoGorelli",
      "created_at": "2022-04-11T18:42:44Z",
      "url": "https://github.com/psf/black/pull/3008#discussion_r847630686"
    },
    {
      "repo": "psf/black",
      "pr_number": 2991,
      "file_path": "src/black/linegen.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -226,6 +226,37 @@ def visit_power(self, node: Node) -> Iterator[Line]:\n             ):\n                 wrap_in_parentheses(node, leaf)\n \n+        if (\n+            Preview.remove_redundant_parens in self.mode\n+            and node.children[0].type == token.AWAIT\n+            and len(node.children) > 1\n+        ):\n+            if (\n+                node.children[1].type == syms.atom\n+                and node.children[1].children[0].type == token.LPAR\n+            ):\n+                if maybe_make_parens_invisible_in_atom(\n+                    node.children[1],\n+                    parent=node,\n+                    remove_brackets_around_comma=True,\n+                ):\n+                    wrap_in_parentheses(node, node.children[1], visible=False)\n+                if (\n+                    node.children[1].children[1].type != syms.power\n+                    and isinstance(node.children[1].children[0], Leaf)\n+                    and isinstance(node.children[1].children[-1], Leaf)\n+                ):\n+                    # Since await is an expression\n+                    # it is syntactically possible\n+                    # that someone would write `await (1 % 2)`",
      "comment": "Could you add a test case like this? I can imagine some system where people write `await (set_of_tasks | other_set)` with operator overloading to make the result awaitable.",
      "comment_id": 841814770,
      "user": "JelleZijlstra",
      "created_at": "2022-04-04T14:37:42Z",
      "url": "https://github.com/psf/black/pull/2991#discussion_r841814770"
    },
    {
      "repo": "psf/black",
      "pr_number": 2991,
      "file_path": "tests/data/remove_await_parens.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,154 @@\n+import asyncio\n+\n+# Control example\n+async def main():\n+    await asyncio.sleep(1)\n+\n+# Remove brackets for short coroutine/task\n+async def main():\n+    await (asyncio.sleep(1))\n+\n+async def main():\n+    await (\n+        asyncio.sleep(1)\n+    )\n+\n+async def main():\n+    await (asyncio.sleep(1)\n+    )\n+\n+# Check comments\n+async def main():\n+    await (  # Hello\n+        asyncio.sleep(1)\n+    )\n+\n+async def main():\n+    await (\n+        asyncio.sleep(1)  # Hello\n+    )\n+\n+async def main():\n+    await (\n+        asyncio.sleep(1)\n+    )  # Hello\n+\n+# Long lines\n+async def main():\n+    await asyncio.gather(asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1))\n+\n+# Same as above but with magic trailing comma in function\n+async def main():\n+    await asyncio.gather(asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1), asyncio.sleep(1),)\n+\n+# Cr@zY Br@ck3Tz\n+async def main():\n+    await (\n+        (((((((((((((\n+        (((        (((\n+        (((         (((\n+        (((         (((\n+        (((        (((\n+        ((black(1)))\n+        )))        )))\n+        )))         )))\n+        )))         )))\n+        )))        )))\n+        )))))))))))))\n+    )\n+\n+# Keep brackets around non power operations and nested awaits\n+async def main():\n+    await (set_of_tasks | other_set)\n+\n+async def main():\n+    await (await asyncio.sleep(1))\n+\n+# It's brackets all the way down...\n+async def main():\n+    await (await (asyncio.sleep(1)))\n+\n+async def main():\n+    await (await (await (await (await (asyncio.sleep(1))))))",
      "comment": "Can you try things like `await (yield x)` or `yield (await x)`, just in case?\r\n\r\n(`await (yield from x)` is not allowed I believe)",
      "comment_id": 842260027,
      "user": "JelleZijlstra",
      "created_at": "2022-04-05T01:27:19Z",
      "url": "https://github.com/psf/black/pull/2991#discussion_r842260027"
    },
    {
      "repo": "psf/black",
      "pr_number": 2970,
      "file_path": "src/black/comments.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -214,8 +214,11 @@ def generate_ignored_nodes(\n     container: Optional[LN] = container_of(leaf)\n     if comment.value in FMT_SKIP:\n         prev_sibling = leaf.prev_sibling\n-        if comment.value in leaf.prefix and prev_sibling is not None:\n-            leaf.prefix = leaf.prefix.replace(comment.value, \"\")\n+        # Need to properly format the leaf prefix to compare it to comment.value,\n+        # which is also formatted\n+        comments = list_comments(leaf.prefix, is_endmarker=False, preview=preview)\n+        if comments and comment.value == comments[0].value and prev_sibling is not None:\n+            leaf.prefix = \"\"",
      "comment": "Is setting `leaf.prefix` to empty string here okay? It appears `leaf.prefix` can only ever contain the comment with `# fmt:skip`, but I could be wrong about this.",
      "comment_id": 836807281,
      "user": "siuryan",
      "created_at": "2022-03-28T20:11:07Z",
      "url": "https://github.com/psf/black/pull/2970#discussion_r836807281"
    },
    {
      "repo": "psf/black",
      "pr_number": 2990,
      "file_path": "tests/data/return_annotation_brackets.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,134 @@\n+# Control\n+def double(a: int) -> int:\n+    return 2*a\n+\n+# Remove the brackets\n+def double(a: int) -> (int):",
      "comment": "Also add an example with multiple sets of parens. And maybe for additional fun, what if there is more whitespace between the parentheses?",
      "comment_id": 841126595,
      "user": "JelleZijlstra",
      "created_at": "2022-04-02T22:32:21Z",
      "url": "https://github.com/psf/black/pull/2990#discussion_r841126595"
    },
    {
      "repo": "psf/black",
      "pr_number": 2990,
      "file_path": "tests/data/return_annotation_brackets.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +53,27 @@ def foo(a: int, b: int, c: int,) -> intsdfsafafafdfdsasdfsfsdfasdfafdsafdfdsfasd\n def foo(a: int, b: int, c: int,) -> int:\n     return 2\n \n+# Deeply nested brackets\n+# with *interesting* spacing",
      "comment": "I pray I never meet a developer who likes to write their brackets like these examples \ud83d\ude05 ",
      "comment_id": 841128042,
      "user": "jpy-git",
      "created_at": "2022-04-02T22:51:56Z",
      "url": "https://github.com/psf/black/pull/2990#discussion_r841128042"
    },
    {
      "repo": "psf/black",
      "pr_number": 2990,
      "file_path": "tests/data/return_annotation_brackets.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +53,27 @@ def foo(a: int, b: int, c: int,) -> intsdfsafafafdfdsasdfsfsdfasdfafdsafdfdsfasd\n def foo(a: int, b: int, c: int,) -> int:\n     return 2\n \n+# Deeply nested brackets\n+# with *interesting* spacing",
      "comment": "You missed an opportunity to write ASCII art using weirdly spaced parentheses",
      "comment_id": 841128433,
      "user": "JelleZijlstra",
      "created_at": "2022-04-02T22:56:48Z",
      "url": "https://github.com/psf/black/pull/2990#discussion_r841128433"
    },
    {
      "repo": "psf/black",
      "pr_number": 2997,
      "file_path": "src/black/__init__.py",
      "line": 387,
      "side": "RIGHT",
      "diff_hunk": "@@ -381,7 +382,10 @@ def validate_regex(\n )\n @click.version_option(\n     version=__version__,\n-    message=f\"%(prog)s, %(version)s (compiled: {'yes' if COMPILED else 'no'})\",\n+    message=(\n+        f\"%(prog)s, %(version)s (compiled: {'yes' if COMPILED else 'no'})\\n\"\n+        f\"python, {platform.python_version()} ({platform.python_implementation()})\"",
      "comment": "It might look a bit better if we stick the implementation directly to Python.\r\n\r\n```suggestion\r\n        f\"Python ({platform.python_implementation()}) {platform.python_version()}\"\r\n```",
      "comment_id": 843905624,
      "user": "isidentical",
      "created_at": "2022-04-06T12:44:38Z",
      "url": "https://github.com/psf/black/pull/2997#discussion_r843905624"
    },
    {
      "repo": "psf/black",
      "pr_number": 2997,
      "file_path": "src/black/__init__.py",
      "line": 387,
      "side": "RIGHT",
      "diff_hunk": "@@ -381,7 +382,10 @@ def validate_regex(\n )\n @click.version_option(\n     version=__version__,\n-    message=f\"%(prog)s, %(version)s (compiled: {'yes' if COMPILED else 'no'})\",\n+    message=(\n+        f\"%(prog)s, %(version)s (compiled: {'yes' if COMPILED else 'no'})\\n\"\n+        f\"python, {platform.python_version()} ({platform.python_implementation()})\"",
      "comment": "Fine by me \ud83d\udc4d \r\nWill look like this:\r\n```\r\nblack, 22.1.1.dev56+g421383d.d20220405 (compiled: no)\r\nPython (CPython) 3.9.12\r\n```",
      "comment_id": 843926163,
      "user": "jpy-git",
      "created_at": "2022-04-06T13:05:34Z",
      "url": "https://github.com/psf/black/pull/2997#discussion_r843926163"
    },
    {
      "repo": "psf/black",
      "pr_number": 2926,
      "file_path": "src/black/linegen.py",
      "line": 884,
      "side": "RIGHT",
      "diff_hunk": "@@ -857,24 +878,34 @@ def normalize_invisible_parens(\n             elif not (isinstance(child, Leaf) and is_multiline_string(child)):\n                 wrap_in_parentheses(node, child, visible=False)\n \n-        check_lpar = isinstance(child, Leaf) and child.value in parens_after\n+        comma_check = child.type == token.COMMA if preview else False\n+\n+        check_lpar = (\n+            isinstance(child, Leaf) and child.value in parens_after or comma_check",
      "comment": "```suggestion\r\n            child.value in parens_after if isinstance(child, Leaf) else comma_check\r\n```",
      "comment_id": 832836412,
      "user": "JelleZijlstra",
      "created_at": "2022-03-23T04:27:00Z",
      "url": "https://github.com/psf/black/pull/2926#discussion_r832836412"
    },
    {
      "repo": "psf/black",
      "pr_number": 2926,
      "file_path": "src/black/linegen.py",
      "line": 884,
      "side": "RIGHT",
      "diff_hunk": "@@ -857,24 +878,34 @@ def normalize_invisible_parens(\n             elif not (isinstance(child, Leaf) and is_multiline_string(child)):\n                 wrap_in_parentheses(node, child, visible=False)\n \n-        check_lpar = isinstance(child, Leaf) and child.value in parens_after\n+        comma_check = child.type == token.COMMA if preview else False\n+\n+        check_lpar = (\n+            isinstance(child, Leaf) and child.value in parens_after or comma_check",
      "comment": "@JelleZijlstra I don't think this change is right. A comma is a `Leaf` as well so the comma wouldn't get checked here. The comma check doesn't need the `Leaf` check since it uses `.type` so I can do either of these if it's more clear?\r\n```python\r\nisinstance(child, Leaf) and (child.value in parens_after or comma_check)\r\n```\r\nor\r\n```python\r\ncomma_check or (isinstance(child, Leaf) and (child.value in parens_after or comma_check)\r\n```\r\n",
      "comment_id": 833082659,
      "user": "jpy-git",
      "created_at": "2022-03-23T10:13:00Z",
      "url": "https://github.com/psf/black/pull/2926#discussion_r833082659"
    },
    {
      "repo": "psf/black",
      "pr_number": 2926,
      "file_path": "src/black/linegen.py",
      "line": 884,
      "side": "RIGHT",
      "diff_hunk": "@@ -857,24 +878,34 @@ def normalize_invisible_parens(\n             elif not (isinstance(child, Leaf) and is_multiline_string(child)):\n                 wrap_in_parentheses(node, child, visible=False)\n \n-        check_lpar = isinstance(child, Leaf) and child.value in parens_after\n+        comma_check = child.type == token.COMMA if preview else False\n+\n+        check_lpar = (\n+            isinstance(child, Leaf) and child.value in parens_after or comma_check",
      "comment": "Thanks! Yes I assumed that `x and y or z` is equivalent to `y if x else z`, but that's not always true. Parens would make it more clear.",
      "comment_id": 833362261,
      "user": "JelleZijlstra",
      "created_at": "2022-03-23T14:51:17Z",
      "url": "https://github.com/psf/black/pull/2926#discussion_r833362261"
    },
    {
      "repo": "psf/black",
      "pr_number": 2926,
      "file_path": "src/black/linegen.py",
      "line": 942,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,38 +884,62 @@ def normalize_invisible_parens(\n             elif not (isinstance(child, Leaf) and is_multiline_string(child)):\n                 wrap_in_parentheses(node, child, visible=False)\n \n-        check_lpar = isinstance(child, Leaf) and child.value in parens_after\n+        comma_check = child.type == token.COMMA if preview else False\n+\n+        check_lpar = isinstance(child, Leaf) and (\n+            child.value in parens_after or comma_check\n+        )\n+\n+\n+def remove_with_parens(node: Node, parent: Node) -> None:\n+    \"\"\"Recursively hide optional parens in `with` statements.\"\"\"\n+    if node.type == syms.atom:\n+        if maybe_make_parens_invisible_in_atom(\n+            node,\n+            parent=parent,\n+            remove_brackets_around_comma=True,\n+        ):\n+            wrap_in_parentheses(parent, node, visible=False)\n+        if isinstance(node.children[1], Node):\n+            remove_with_parens(node.children[1], node)\n+    elif node.type == syms.testlist_gexp:\n+        for child in node.children:\n+            if isinstance(child, Node):\n+                remove_with_parens(child, node)\n+    elif node.type == syms.asexpr_test and not any(\n+        leaf.type == token.COLONEQUAL for leaf in node.leaves()\n+    ):\n+        if maybe_make_parens_invisible_in_atom(\n+            node.children[0],\n+            parent=parent,\n+            remove_brackets_around_comma=True,\n+        ):\n+            wrap_in_parentheses(parent, node.children[0], visible=False)\n \n \n def maybe_make_parens_invisible_in_atom(\n     node: LN,\n     parent: LN,\n-    preview: bool = False,\n+    remove_brackets_around_comma: bool = False,\n ) -> bool:\n     \"\"\"If it's safe, make the parens in the atom `node` invisible, recursively.\n     Additionally, remove repeated, adjacent invisible parens from the atom `node`\n     as they are redundant.\n \n     Returns whether the node should itself be wrapped in invisible parentheses.\n-\n     \"\"\"\n-    if (\n-        preview\n-        and parent.type == syms.for_stmt\n-        and isinstance(node.prev_sibling, Leaf)\n-        and node.prev_sibling.type == token.NAME\n-        and node.prev_sibling.value == \"for\"\n-    ):\n-        for_stmt_check = False\n-    else:\n-        for_stmt_check = True\n-\n     if (\n         node.type != syms.atom\n         or is_empty_tuple(node)\n         or is_one_tuple(node)\n         or (is_yield(node) and parent.type != syms.expr_stmt)\n-        or (max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY and for_stmt_check)\n+        or (\n+            # This condition tries to prevent removing non-optional brackets\n+            # around a tuple, however, can be a bit overzealous so we provide\n+            # and option to skip this check for `for` and `with` statements.\n+            not remove_brackets_around_comma\n+            and max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY\n+        )",
      "comment": "So the reason I had the `for_stmt_check`/`with_stmt_check` initially was to disable this check for the reason in the above comment (basically it's hard to cleanly detect a tuple).\r\n\r\nThe issue was that nested brackets are nested atoms so when we recursed into the second level of this function the parent would no longer be `for_stmt` or `with_stmt` so my check would fail and require a second run. I've added an argument to disable this check and then we can just use this when we're removing brackets from `for`/`with` in the main loop.",
      "comment_id": 835092952,
      "user": "jpy-git",
      "created_at": "2022-03-25T09:25:47Z",
      "url": "https://github.com/psf/black/pull/2926#discussion_r835092952"
    },
    {
      "repo": "psf/black",
      "pr_number": 2926,
      "file_path": "src/black/linegen.py",
      "line": 859,
      "side": "RIGHT",
      "diff_hunk": "@@ -840,11 +843,26 @@ def normalize_invisible_parens(\n             check_lpar = True\n \n         if check_lpar:\n-            if child.type == syms.atom:\n+            if (\n+                preview\n+                and child.type == syms.atom\n+                and node.type == syms.for_stmt\n+                and isinstance(child.prev_sibling, Leaf)\n+                and child.prev_sibling.type == token.NAME\n+                and child.prev_sibling.value == \"for\"\n+            ):\n+                if maybe_make_parens_invisible_in_atom(\n+                    child,\n+                    parent=node,\n+                    remove_brackets_around_comma=True,\n+                ):\n+                    wrap_in_parentheses(node, child, visible=False)",
      "comment": "`for` fix is now very simple. Detect the parent is a `for` loop and then remove the brackets using the option to remove around commas as well.",
      "comment_id": 835094009,
      "user": "jpy-git",
      "created_at": "2022-03-25T09:27:05Z",
      "url": "https://github.com/psf/black/pull/2926#discussion_r835094009"
    },
    {
      "repo": "psf/black",
      "pr_number": 2926,
      "file_path": "src/black/linegen.py",
      "line": 917,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,38 +884,62 @@ def normalize_invisible_parens(\n             elif not (isinstance(child, Leaf) and is_multiline_string(child)):\n                 wrap_in_parentheses(node, child, visible=False)\n \n-        check_lpar = isinstance(child, Leaf) and child.value in parens_after\n+        comma_check = child.type == token.COMMA if preview else False\n+\n+        check_lpar = isinstance(child, Leaf) and (\n+            child.value in parens_after or comma_check\n+        )\n+\n+\n+def remove_with_parens(node: Node, parent: Node) -> None:\n+    \"\"\"Recursively hide optional parens in `with` statements.\"\"\"\n+    if node.type == syms.atom:\n+        if maybe_make_parens_invisible_in_atom(\n+            node,\n+            parent=parent,\n+            remove_brackets_around_comma=True,\n+        ):\n+            wrap_in_parentheses(parent, node, visible=False)\n+        if isinstance(node.children[1], Node):\n+            remove_with_parens(node.children[1], node)\n+    elif node.type == syms.testlist_gexp:\n+        for child in node.children:\n+            if isinstance(child, Node):\n+                remove_with_parens(child, node)\n+    elif node.type == syms.asexpr_test and not any(\n+        leaf.type == token.COLONEQUAL for leaf in node.leaves()\n+    ):\n+        if maybe_make_parens_invisible_in_atom(\n+            node.children[0],\n+            parent=parent,\n+            remove_brackets_around_comma=True,\n+        ):\n+            wrap_in_parentheses(parent, node.children[0], visible=False)",
      "comment": "`with` is slightly more complicated to achieve in one pass so I've split this into it's own function.\r\n\r\nBasically the different variations of bracketed with statements give pretty different parse trees so we need to recursively solve this.\r\n\r\n`with (open(\"test.txt\")) as f: ...`: this is an `asexpr_test`\r\n`with (open(\"test.txt\") as f): ...`: this is an `atom` containing an `asexpr_test`\r\n`with (open(\"test.txt\")) as f, (open(\"test.txt\")) as f: ...`: this is `asexpr_test`, `COMMA`, `asexpr_test`\r\n`with (open(\"test.txt\") as f, open(\"test.txt\")) as f: ...`: this is an `atom` containing a `testlist_gexp` which then contains multiple `asexpr_test`s",
      "comment_id": 835099427,
      "user": "jpy-git",
      "created_at": "2022-03-25T09:33:52Z",
      "url": "https://github.com/psf/black/pull/2926#discussion_r835099427"
    },
    {
      "repo": "psf/black",
      "pr_number": 2926,
      "file_path": "tests/data/remove_with_brackets.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,79 @@\n+with (open(\"bla.txt\")):",
      "comment": "Could you add test cases with multiple levels of parentheses here?\r\n\r\n(And probably also foor `for`, in `remove_for_brackets.py`)",
      "comment_id": 841112892,
      "user": "JelleZijlstra",
      "created_at": "2022-04-02T19:51:04Z",
      "url": "https://github.com/psf/black/pull/2926#discussion_r841112892"
    },
    {
      "repo": "psf/black",
      "pr_number": 2926,
      "file_path": "tests/data/remove_with_brackets.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,79 @@\n+with (open(\"bla.txt\")):",
      "comment": "I've added the multi-paren examples for `with` in that last commit \ud83d\udc4d \r\n\r\nFYI I've noted as well that only the context manager can have multiple paren levels so that's why these examples below aren't included in those tests \ud83d\ude04 \r\n```python\r\n# This is valid syntax\r\nwith (open(\"bla.txt\") as f):\r\n    pass\r\n\r\n# This is bad syntax\r\nwith ((open(\"bla.txt\") as f)):\r\n    pass\r\n\r\n# This is valid syntax\r\nwith (open(\"bla.txt\") as f, open(\"bla.txt\") as f):\r\n    pass\r\n\r\n# This is bad syntax\r\nwith ((open(\"bla.txt\") as f, open(\"bla.txt\") as f)):\r\n    pass\r\n```",
      "comment_id": 841116087,
      "user": "jpy-git",
      "created_at": "2022-04-02T20:26:21Z",
      "url": "https://github.com/psf/black/pull/2926#discussion_r841116087"
    },
    {
      "repo": "psf/black",
      "pr_number": 2974,
      "file_path": "tests/test_blackd.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,12 +9,18 @@\n \n try:\n     import blackd\n-    from aiohttp.test_utils import AioHTTPTestCase, unittest_run_loop\n+    from aiohttp.test_utils import AioHTTPTestCase\n     from aiohttp import web\n+except ImportError as e:\n+    raise RuntimeError(\"Please install Black with the 'd' extra\") from e",
      "comment": "The old `has_blackd_deps` logic was doing absolutely nothing useful so instead let's error out with an informative exception.",
      "comment_id": 837940412,
      "user": "ichard26",
      "created_at": "2022-03-29T21:52:01Z",
      "url": "https://github.com/psf/black/pull/2974#discussion_r837940412"
    },
    {
      "repo": "psf/black",
      "pr_number": 2919,
      "file_path": "tests/data/comments8.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,101 @@\n+# The percent-percent comments are Spyder IDE cells.\n+# Both `#%%`` and `# %%` are accepted, so `black` standardises\n+# to the latter.\n+\n+#%%\n+def func():\n+    x = \"\"\"\n+    a really long string\n+    \"\"\"\n+    lcomp3 = [",
      "comment": "Can we shorten this code? The test can focus on just `#%%`, so no need for everything else.",
      "comment_id": 831392122,
      "user": "JelleZijlstra",
      "created_at": "2022-03-21T17:53:42Z",
      "url": "https://github.com/psf/black/pull/2919#discussion_r831392122"
    },
    {
      "repo": "psf/black",
      "pr_number": 2919,
      "file_path": "tests/data/comments8.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,101 @@\n+# The percent-percent comments are Spyder IDE cells.\n+# Both `#%%`` and `# %%` are accepted, so `black` standardises\n+# to the latter.\n+\n+#%%\n+def func():\n+    x = \"\"\"\n+    a really long string\n+    \"\"\"\n+    lcomp3 = [\n+        # This one is actually too long to fit in a single line.\n+        element.split(\"\\n\", 1)[0]\n+        # yup\n+        for element in collection.select_elements()\n+        # right\n+        if element is not None\n+    ]\n+    # Capture each of the exceptions in the MultiError along with each of their causes and contexts\n+    if isinstance(exc_value, MultiError):\n+        embedded = []\n+        for exc in exc_value.exceptions:\n+            if exc not in _seen:\n+                embedded.append(\n+                    # This should be left alone (before)\n+                    traceback.TracebackException.from_exception(\n+                        exc,\n+                        limit=limit,\n+                        lookup_lines=lookup_lines,\n+                        capture_locals=capture_locals,\n+                        # copy the set of _seen exceptions so that duplicates\n+                        # shared between sub-exceptions are not omitted\n+                        _seen=set(_seen),\n+                    )\n+                    # This should be left alone (after)\n+                )\n+\n+    # everything is fine if the expression isn't nested\n+    traceback.TracebackException.from_exception(\n+        exc,\n+        limit=limit,\n+        lookup_lines=lookup_lines,\n+        capture_locals=capture_locals,\n+        # copy the set of _seen exceptions so that duplicates\n+        # shared between sub-exceptions are not omitted\n+        _seen=set(_seen),\n+    )\n+\n+\n+#%%",
      "comment": "Maybe add an input comment that already has a space",
      "comment_id": 831392379,
      "user": "JelleZijlstra",
      "created_at": "2022-03-21T17:54:00Z",
      "url": "https://github.com/psf/black/pull/2919#discussion_r831392379"
    },
    {
      "repo": "psf/black",
      "pr_number": 2919,
      "file_path": "tests/data/comments8.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,101 @@\n+# The percent-percent comments are Spyder IDE cells.\n+# Both `#%%`` and `# %%` are accepted, so `black` standardises\n+# to the latter.\n+\n+#%%\n+def func():\n+    x = \"\"\"\n+    a really long string\n+    \"\"\"\n+    lcomp3 = [",
      "comment": "sure, I was meaning it to be a `--preview` version of `comments3.py` - but shortening it and just testing `# %%` seems fine",
      "comment_id": 831544889,
      "user": "MarcoGorelli",
      "created_at": "2022-03-21T21:09:24Z",
      "url": "https://github.com/psf/black/pull/2919#discussion_r831544889"
    },
    {
      "repo": "psf/black",
      "pr_number": 2939,
      "file_path": "src/black/mode.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,7 @@ class Preview(Enum):\n     \"\"\"Individual preview style features.\"\"\"\n \n     string_processing = auto()\n+    remove_except_parens = auto()",
      "comment": "I currently have a similar PR (#2926) open that handles redundant brackets after `with` statements. \r\n\r\nLooking at the issues there a quite a few of these brackets cases that we'll need to add in so would you rather:\r\na) have a separate preview setting for each case (e.g. `remove_with_parens`, `remove_except_parens`, ...)\r\nor\r\nb) have a single preview setting for all these cases (e.g. `remove_redundant_parens`)\r\n\r\nI'd lean towards a single preview setting (b) since feels a bit cleaner, but happy either way \ud83d\ude04 ",
      "comment_id": 830073890,
      "user": "jpy-git",
      "created_at": "2022-03-18T14:49:26Z",
      "url": "https://github.com/psf/black/pull/2939#discussion_r830073890"
    },
    {
      "repo": "psf/black",
      "pr_number": 2939,
      "file_path": "tests/data/remove_except_parens.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,40 @@\n+# These brackets are redundant, therefore remove.\n+try:\n+    a.something\n+except (AttributeError) as err:",
      "comment": "Can you add a test case where the line is too long, like:\r\n\r\n```\r\nexcept (\r\n    some.really.long.module.over89.chars.Error\r\n) as really_long_name:\r\n```\r\n\r\nI worry that we'll run into instability issues in cases like this.",
      "comment_id": 832841155,
      "user": "JelleZijlstra",
      "created_at": "2022-03-23T04:40:49Z",
      "url": "https://github.com/psf/black/pull/2939#discussion_r832841155"
    },
    {
      "repo": "psf/black",
      "pr_number": 2939,
      "file_path": "tests/data/remove_except_parens.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,40 @@\n+# These brackets are redundant, therefore remove.\n+try:\n+    a.something\n+except (AttributeError) as err:\n+    raise err\n+\n+# This is tuple of exceptions.\n+# Although this could be replaced with just the exception,\n+# we do not remove brackets to preserve AST.\n+try:\n+    a.something\n+except (AttributeError,) as err:\n+    raise err\n+\n+# This is a tuple of exceptions. Do not remove brackets.\n+try:\n+    a.something\n+except (AttributeError, ValueError) as err:",
      "comment": "And here add a case where the tuple is too long to fit in one line.",
      "comment_id": 832841575,
      "user": "JelleZijlstra",
      "created_at": "2022-03-23T04:41:57Z",
      "url": "https://github.com/psf/black/pull/2939#discussion_r832841575"
    },
    {
      "repo": "psf/black",
      "pr_number": 2939,
      "file_path": "tests/data/remove_except_parens.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,40 @@\n+# These brackets are redundant, therefore remove.\n+try:\n+    a.something\n+except (AttributeError) as err:",
      "comment": "I've added these tests and all works as expected \ud83d\ude04 ",
      "comment_id": 833059344,
      "user": "jpy-git",
      "created_at": "2022-03-23T09:49:42Z",
      "url": "https://github.com/psf/black/pull/2939#discussion_r833059344"
    },
    {
      "repo": "psf/black",
      "pr_number": 2939,
      "file_path": "tests/data/remove_except_parens.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,40 @@\n+# These brackets are redundant, therefore remove.\n+try:\n+    a.something\n+except (AttributeError) as err:\n+    raise err\n+\n+# This is tuple of exceptions.\n+# Although this could be replaced with just the exception,\n+# we do not remove brackets to preserve AST.\n+try:\n+    a.something\n+except (AttributeError,) as err:\n+    raise err\n+\n+# This is a tuple of exceptions. Do not remove brackets.\n+try:\n+    a.something\n+except (AttributeError, ValueError) as err:",
      "comment": "Have added one for these as well! \ud83d\ude04 \r\n\r\nNote that for the tuple cases this PR has no impact on existing behaviour. [This](https://github.com/psf/black/blob/5379d4f3f460ec9b7063dd1cc10f437b0edf9ae3/src/black/linegen.py#L877) line detects a comma with the assumption that it indicates a tuple (hence why some of my other PRs add an extra condition here to remove brackets in `with`/`for`) and stops the brackets from being made invisible \ud83d\udc4d\r\n\r\n",
      "comment_id": 833066623,
      "user": "jpy-git",
      "created_at": "2022-03-23T09:56:38Z",
      "url": "https://github.com/psf/black/pull/2939#discussion_r833066623"
    },
    {
      "repo": "psf/black",
      "pr_number": 2945,
      "file_path": "tests/data/remove_for_brackets.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,18 @@\n+# Only remove tuple brackets after `for`\n+for (k, v) in d.items():",
      "comment": "Can you add a test where the for loop target is too long to fit in one line?",
      "comment_id": 833866035,
      "user": "JelleZijlstra",
      "created_at": "2022-03-24T02:32:52Z",
      "url": "https://github.com/psf/black/pull/2945#discussion_r833866035"
    },
    {
      "repo": "psf/black",
      "pr_number": 2942,
      "file_path": "src/black/lines.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -268,6 +273,20 @@ def has_magic_trailing_comma(\n             return True\n \n         if closing.type == token.RSQB:\n+            if (\n+                Preview.one_tuple_type in self.mode\n+                and is_within_annotation(closing)\n+                and closing.opening_bracket\n+                and is_one_tuple_between(closing.opening_bracket, closing, self.leaves)\n+                and closing.parent\n+                and closing.parent.prev_sibling\n+                and (\n+                    list(closing.parent.prev_sibling.leaves())[-1].value\n+                    in (\"tuple\", \"Tuple\")",
      "comment": "Not sure we need this condition, and it's pretty fragile anyway. What if we just do it for all subscripts?",
      "comment_id": 830201396,
      "user": "JelleZijlstra",
      "created_at": "2022-03-18T17:15:33Z",
      "url": "https://github.com/psf/black/pull/2942#discussion_r830201396"
    },
    {
      "repo": "psf/black",
      "pr_number": 2942,
      "file_path": "src/black/lines.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -268,6 +273,20 @@ def has_magic_trailing_comma(\n             return True\n \n         if closing.type == token.RSQB:\n+            if (\n+                Preview.one_tuple_type in self.mode\n+                and is_within_annotation(closing)\n+                and closing.opening_bracket\n+                and is_one_tuple_between(closing.opening_bracket, closing, self.leaves)\n+                and closing.parent\n+                and closing.parent.prev_sibling\n+                and (\n+                    list(closing.parent.prev_sibling.leaves())[-1].value\n+                    in (\"tuple\", \"Tuple\")",
      "comment": "As in anything between the square brackets in a type?\r\n\r\nI'm happy with that as it saves us having to check the previous sibling and simplifies things. I think in reality people will likely only add the trailing comma to tuples anyway.\r\n\r\nAlso it would allow us to also not split on something like: \r\n```python\r\nclass Foo(tuple):\r\n    pass\r\n\r\na: Foo[int,]\r\n```\r\nwhich is a good thing",
      "comment_id": 830207376,
      "user": "jpy-git",
      "created_at": "2022-03-18T17:23:34Z",
      "url": "https://github.com/psf/black/pull/2942#discussion_r830207376"
    },
    {
      "repo": "psf/black",
      "pr_number": 2942,
      "file_path": "src/black/lines.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -268,6 +273,20 @@ def has_magic_trailing_comma(\n             return True\n \n         if closing.type == token.RSQB:\n+            if (\n+                Preview.one_tuple_type in self.mode\n+                and is_within_annotation(closing)\n+                and closing.opening_bracket\n+                and is_one_tuple_between(closing.opening_bracket, closing, self.leaves)\n+                and closing.parent\n+                and closing.parent.prev_sibling\n+                and (\n+                    list(closing.parent.prev_sibling.leaves())[-1].value\n+                    in (\"tuple\", \"Tuple\")",
      "comment": "Or even in a subscript in general (I don't think we can reliably detect types)",
      "comment_id": 830213747,
      "user": "JelleZijlstra",
      "created_at": "2022-03-18T17:32:04Z",
      "url": "https://github.com/psf/black/pull/2942#discussion_r830213747"
    },
    {
      "repo": "psf/black",
      "pr_number": 2942,
      "file_path": "src/black/lines.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -268,6 +273,20 @@ def has_magic_trailing_comma(\n             return True\n \n         if closing.type == token.RSQB:\n+            if (\n+                Preview.one_tuple_type in self.mode\n+                and is_within_annotation(closing)\n+                and closing.opening_bracket\n+                and is_one_tuple_between(closing.opening_bracket, closing, self.leaves)\n+                and closing.parent\n+                and closing.parent.prev_sibling\n+                and (\n+                    list(closing.parent.prev_sibling.leaves())[-1].value\n+                    in (\"tuple\", \"Tuple\")",
      "comment": "good point, it's hard to tell that `a = tuple[int,]` is a type alias since it's not a child of `syms.annassign`. Will adjust to look at general one element subscripts \ud83d\udc4d ",
      "comment_id": 830227307,
      "user": "jpy-git",
      "created_at": "2022-03-18T17:49:37Z",
      "url": "https://github.com/psf/black/pull/2942#discussion_r830227307"
    },
    {
      "repo": "psf/black",
      "pr_number": 2942,
      "file_path": "src/black/lines.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -268,6 +273,20 @@ def has_magic_trailing_comma(\n             return True\n \n         if closing.type == token.RSQB:\n+            if (\n+                Preview.one_tuple_type in self.mode\n+                and is_within_annotation(closing)\n+                and closing.opening_bracket\n+                and is_one_tuple_between(closing.opening_bracket, closing, self.leaves)\n+                and closing.parent\n+                and closing.parent.prev_sibling\n+                and (\n+                    list(closing.parent.prev_sibling.leaves())[-1].value\n+                    in (\"tuple\", \"Tuple\")",
      "comment": "I've updated the code to disable magic-trailing-comma for single-element subscripts in general now",
      "comment_id": 830247023,
      "user": "jpy-git",
      "created_at": "2022-03-18T18:17:02Z",
      "url": "https://github.com/psf/black/pull/2942#discussion_r830247023"
    },
    {
      "repo": "psf/black",
      "pr_number": 2942,
      "file_path": "tests/data/one_element_subscript.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,24 @@\n+# We should not treat the trailing comma",
      "comment": "Can you try some cases like `[int,]` in a list, outside a subscript?",
      "comment_id": 832844144,
      "user": "JelleZijlstra",
      "created_at": "2022-03-23T04:49:24Z",
      "url": "https://github.com/psf/black/pull/2942#discussion_r832844144"
    },
    {
      "repo": "psf/black",
      "pr_number": 2942,
      "file_path": "tests/data/one_element_subscript.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,24 @@\n+# We should not treat the trailing comma",
      "comment": "have added the extra test cases and all looks good \ud83d\ude04 ",
      "comment_id": 833058753,
      "user": "jpy-git",
      "created_at": "2022-03-23T09:49:04Z",
      "url": "https://github.com/psf/black/pull/2942#discussion_r833058753"
    },
    {
      "repo": "psf/black",
      "pr_number": 2928,
      "file_path": "src/black/mode.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -163,7 +162,9 @@ def __contains__(self, feature: Preview) -> bool:\n         \"\"\"\n         if feature is Preview.string_processing:\n             return self.preview or self.experimental_string_processing\n-        return self.preview\n+        # TODO: Remove type ignore comment once preview contains more features\n+        #  than just ESP\n+        return self.preview  # type: ignore",
      "comment": "It thinks this code is unreachable because there's only one enum member.",
      "comment_id": 827580624,
      "user": "JelleZijlstra",
      "created_at": "2022-03-16T02:50:34Z",
      "url": "https://github.com/psf/black/pull/2928#discussion_r827580624"
    },
    {
      "repo": "psf/black",
      "pr_number": 2758,
      "file_path": "src/black/parsing.py",
      "line": 114,
      "side": "LEFT",
      "diff_hunk": "@@ -99,20 +103,21 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n                 faulty_line = lines[lineno - 1]\n             except IndexError:\n                 faulty_line = \"<line number missing in source>\"\n-            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+            errors[grammar.version] = InvalidInput(\n+                f\"Cannot parse: {lineno}:{column}: {faulty_line}\"\n+            )\n \n         except TokenError as te:\n             # In edge cases these are raised; and typically don't have a \"faulty_line\".\n             lineno, column = te.args[1]\n-            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {te.args[0]}\")\n+            errors[grammar.version] = InvalidInput(\n+                f\"Cannot parse: {lineno}:{column}: {te.args[0]}\"\n+            )\n \n     else:\n-        if pygram.python_grammar_soft_keywords not in grammars and matches_grammar(\n-            src_txt, pygram.python_grammar_soft_keywords\n-        ):\n-            original_msg = exc.args[0]\n-            msg = f\"{original_msg}\\n{PY310_HINT}\"",
      "comment": "Resolved: https://github.com/psf/black/pull/2758/commits/3a3ac469b1bb9a56ee7ff73bb4bd4793a825b7b1.",
      "comment_id": 790166906,
      "user": "ichard26",
      "created_at": "2022-01-22T17:46:02Z",
      "url": "https://github.com/psf/black/pull/2758#discussion_r790166906"
    },
    {
      "repo": "psf/black",
      "pr_number": 2832,
      "file_path": "src/black/__init__.py",
      "line": 478,
      "side": "RIGHT",
      "diff_hunk": "@@ -474,7 +474,9 @@ def main(\n                 out(f\"Using configuration in '{config}'.\", fg=\"blue\")\n \n     error_msg = \"Oh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\"\n-    if required_version and required_version != __version__:\n+    if required_version and (\n+        required_version != __version__ or required_version != __version__.split(\".\")[0]",
      "comment": "This is going to always fail when a required version is specified:\r\n```py\r\n__version__ = \"22.01\"\r\nrequired_version = \"22\"\r\n# the if will evaluate to:\r\nif True and (\r\n    \"22\" != \"22.01\"  # True\r\n    or \"22\" != \"22\"  # False\r\n):\r\n```\r\n```py\r\n__version__ = \"22.01\"\r\nrequired_version = \"22.01\"\r\n# the if will evaluate to:\r\nif True and (\r\n    \"22.01\" != \"22\"        # False\r\n    or \"22.01\" != \"22.01\"  # True\r\n):\r\n```",
      "comment_id": 795237427,
      "user": "Jackenmen",
      "created_at": "2022-01-30T19:26:09Z",
      "url": "https://github.com/psf/black/pull/2832#discussion_r795237427"
    },
    {
      "repo": "psf/black",
      "pr_number": 2832,
      "file_path": "src/black/__init__.py",
      "line": 295,
      "side": "RIGHT",
      "diff_hunk": "@@ -291,7 +291,8 @@ def validate_regex(\n     type=str,\n     help=(\n         \"Require a specific version of Black to be running (useful for unifying results\"\n-        \" across many environments e.g. with a pyproject.toml file).\"\n+        \" across many environments e.g. with a pyproject.toml file). It can be only an\"\n+        \" integer representing a major version or an exact version.\"",
      "comment": "```suggestion\r\n        \" across many environments e.g. with a pyproject.toml file). It can be\"\r\n        \" either a major version number or an exact version.\"\r\n```\r\nThis would be a bit clearer to me.",
      "comment_id": 795242236,
      "user": "felix-hilden",
      "created_at": "2022-01-30T20:08:49Z",
      "url": "https://github.com/psf/black/pull/2832#discussion_r795242236"
    },
    {
      "repo": "psf/black",
      "pr_number": 2832,
      "file_path": "tests/test_black.py",
      "line": 1208,
      "side": "RIGHT",
      "diff_hunk": "@@ -1198,6 +1198,20 @@ def test_required_version_matches_version(self) -> None:\n             ignore_config=True,\n         )\n \n+    def test_required_version_matches_partial_version(self) -> None:\n+        self.invokeBlack(\n+            [\"--required-version\", black.__version__.split(\".\")[0], \"-c\", \"0\"],\n+            exit_code=0,\n+            ignore_config=True,\n+        )\n+\n+    def test_required_version_does_not_matches_on_minor_version(self) -> None:",
      "comment": "```suggestion\r\n    def test_required_version_does_not_match_on_minor_version(self) -> None:\r\n```",
      "comment_id": 795244909,
      "user": "felix-hilden",
      "created_at": "2022-01-30T20:33:04Z",
      "url": "https://github.com/psf/black/pull/2832#discussion_r795244909"
    },
    {
      "repo": "psf/black",
      "pr_number": 2823,
      "file_path": "setup.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,7 +114,7 @@ def find_python_files(base: Path) -> List[Path]:\n     },\n     test_suite=\"tests.test_black\",",
      "comment": "Unrelatedly, isn't this wrong now? We have more test files than this.",
      "comment_id": 795065438,
      "user": "JelleZijlstra",
      "created_at": "2022-01-29T15:26:00Z",
      "url": "https://github.com/psf/black/pull/2823#discussion_r795065438"
    },
    {
      "repo": "psf/black",
      "pr_number": 2823,
      "file_path": "setup.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,7 +114,7 @@ def find_python_files(base: Path) -> List[Path]:\n     },\n     test_suite=\"tests.test_black\",",
      "comment": "This is deprecated anyways and does not help pytest. So it can be removed I\u2019m pretty sure.",
      "comment_id": 795065562,
      "user": "cooperlees",
      "created_at": "2022-01-29T15:27:12Z",
      "url": "https://github.com/psf/black/pull/2823#discussion_r795065562"
    },
    {
      "repo": "psf/black",
      "pr_number": 2572,
      "file_path": "src/black/__init__.py",
      "line": 909,
      "side": "RIGHT",
      "diff_hunk": "@@ -906,17 +906,7 @@ def check_stability_and_equivalence(\n     content differently.\n     \"\"\"\n     assert_equivalent(src_contents, dst_contents)\n-\n-    # Forced second pass to work around optional trailing commas (becoming\n-    # forced trailing commas on pass 2) interacting differently with optional\n-    # parentheses.  Admittedly ugly.\n-    dst_contents_pass2 = format_str(dst_contents, mode=mode)\n-    if dst_contents != dst_contents_pass2:\n-        dst_contents = dst_contents_pass2\n-        assert_equivalent(src_contents, dst_contents, pass_num=2)\n-        assert_stable(src_contents, dst_contents, mode=mode)\n-    # Note: no need to explicitly call `assert_stable` if `dst_contents` was\n-    # the same as `dst_contents_pass2`.\n+    assert_stable(src_contents, dst_contents, mode=mode)",
      "comment": "The `pass_num` kwarg in `assert_equivalent` is now unused and could be cleaned up",
      "comment_id": 752008524,
      "user": "hauntsaninja",
      "created_at": "2021-11-18T08:33:01Z",
      "url": "https://github.com/psf/black/pull/2572#discussion_r752008524"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,14 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+            if leaf.type == token.NUMBER and next_leaf.type == syms.trailer:",
      "comment": "AFAIK `trailer` also includes the subscript and the call, e.g `1(duh)` or `1[duh]` would be also parenthesized (even though there is no such use case). I wonder whether we should make a more stricter check and ensure we are in an attribute trailer \ud83e\udd14 ",
      "comment_id": 790305672,
      "user": "isidentical",
      "created_at": "2022-01-23T17:17:32Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r790305672"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "tests/data/use_braces_in_int_method_calls.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,24 @@\n+count = 5 .bit_count()",
      "comment": "What about complex numbers? They don't require parens (`10j.imag` is valid), so it would be good to test that we don't add it.\r\n\r\nSimilarly `0x10.imag` is valid, so let's test that we don't add unnecessary parens.",
      "comment_id": 790413738,
      "user": "JelleZijlstra",
      "created_at": "2022-01-24T04:55:40Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r790413738"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "tests/data/use_braces_in_int_method_calls.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,24 @@\n+count = 5 .bit_count()",
      "comment": "It even works on floats, but on floats, the multiple \"dot operators\" look a bit confusing, so I decided to keep it on floats\r\n```py\r\n>>> 10.1.is_integer()\r\nFalse\r\n```\r\n\r\nYeah will do, `10j.imag` and `0x10.imag` are fine without the parentheses \ud83d\udc4d\ud83c\udffb ",
      "comment_id": 790415559,
      "user": "Shivansh-007",
      "created_at": "2022-01-24T05:02:22Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r790415559"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,14 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+            if leaf.type == token.NUMBER and next_leaf.type == syms.trailer:",
      "comment": "Sorry missed this, yeah I noticed that when I was going through the grammar file but subscript and calls on `token.NUMBER` isn't valid python syntax, so I left that case.\r\n\r\n```gram\r\ntrailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\r\n```",
      "comment_id": 790479258,
      "user": "Shivansh-007",
      "created_at": "2022-01-24T07:45:58Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r790479258"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 209,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,24 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+            if (\n+                isinstance(leaf, Leaf)\n+                and leaf.type == token.NUMBER\n+                and next_leaf.type == syms.trailer\n+                # Integers prefixed by 0x are represented under the hood in just\n+                # the same way as integers that aren't. This means that to Python,\n+                # 0xFF is the same as 255, and there's no way to tell them apart",
      "comment": "If we do this we also have to exclude binary and octal literals.",
      "comment_id": 792226064,
      "user": "JelleZijlstra",
      "created_at": "2022-01-26T00:16:12Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792226064"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,24 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+            if (\n+                isinstance(leaf, Leaf)\n+                and leaf.type == token.NUMBER\n+                and next_leaf.type == syms.trailer\n+                # Integers prefixed by 0x are represented under the hood in just",
      "comment": "I'm not sure why this comment is relevant; at this point the ints are represented as strings.",
      "comment_id": 792226240,
      "user": "JelleZijlstra",
      "created_at": "2022-01-26T00:16:37Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792226240"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "tests/data/use_braces_in_int_method_calls.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,30 @@\n+count = 5 .bit_count()\n+abs = 10 .__abs__()\n+is_integer = 10.5 .is_integer()\n+\n+if 10 .real: ...\n+\n+for number in range(1, 10):\n+    if number.imag: ...\n+\n+exclusive_complex = 10j.imag\n+\n+hex_decimal = 0x10.real",
      "comment": "Should also test all the other kinds of numeric literals:\r\n- octal\r\n- binary\r\n- scientific notation",
      "comment_id": 792227560,
      "user": "JelleZijlstra",
      "created_at": "2022-01-26T00:20:12Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792227560"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "tests/test_black.py",
      "line": 141,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +137,8 @@ def invokeBlack(\n \n \n class BlackTestCase(BlackBaseTestCase):\n+\n+    maxDiff = None",
      "comment": "Forgot to remove this, when running the tests in pycharm, it wasn't showing the diff for the `.diff` tests as the diff between the required diff and actual diff was more than the `maxDiff`. To view the diff, I had to set it to `None`.",
      "comment_id": 792274604,
      "user": "Shivansh-007",
      "created_at": "2022-01-26T02:35:31Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792274604"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 216,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,30 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+\n+            if not isinstance(leaf, Leaf):\n+                continue\n+\n+            value = leaf.value.lower()\n+            if (\n+                leaf.type == token.NUMBER\n+                and next_leaf.type == syms.trailer\n+                # Shouldn't wrap octal literals\n+                and (not value.startswith(\"0o\"))\n+                # Shouldn't wrap binary literals\n+                and (not value.startswith(\"0b\"))\n+                # Shouldn't wrap hexadecimal literals\n+                and (not value.startswith(\"0x\"))",
      "comment": "You can combine all these `value.startswith((\"0x\", \"0b\", \"0o\"))`",
      "comment_id": 792288723,
      "user": "JelleZijlstra",
      "created_at": "2022-01-26T03:21:10Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792288723"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/lines.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,11 +62,21 @@ def append(self, leaf: Leaf, preformatted: bool = False) -> None:\n         if token.COLON == leaf.type and self.is_class_paren_empty:\n             del self.leaves[-2:]\n         if self.leaves and not preformatted:\n-            # Note: at this point leaf.prefix should be empty except for\n-            # imports, for which we only preserve newlines.\n-            leaf.prefix += whitespace(\n-                leaf, complex_subscript=self.is_complex_subscript(leaf)\n-            )\n+            grandparent_leaf = leaf.parent.parent if leaf.parent else None\n+\n+            # It shouldn't add whitespaces after dot operators in expressions",
      "comment": "Looking at this again, shouldn't the logic you're adding be handled in the whitespace() function?\r\n\r\nWhat if you remove the NUMBER check from nodes.py line 311, `if not prevp or prevp.type != token.NUMBER:`?",
      "comment_id": 792295158,
      "user": "JelleZijlstra",
      "created_at": "2022-01-26T03:45:15Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792295158"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 212,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,26 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+\n+            if not isinstance(leaf, Leaf):\n+                continue\n+\n+            value = leaf.value.lower()\n+            if (\n+                leaf.type == token.NUMBER\n+                and next_leaf.type == syms.trailer\n+                # It shouldn't wrap hexadecimal, binary and octal literals\n+                and (not value.startswith((\"0x\", \"0b\", \"0o\")))",
      "comment": "```suggestion\r\n                and not value.startswith((\"0x\", \"0b\", \"0o\"))\r\n```\r\nNIT: let's not have the extra parens",
      "comment_id": 792352629,
      "user": "felix-hilden",
      "created_at": "2022-01-26T06:53:27Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792352629"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 212,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,26 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+\n+            if not isinstance(leaf, Leaf):\n+                continue\n+\n+            value = leaf.value.lower()\n+            if (\n+                leaf.type == token.NUMBER\n+                and next_leaf.type == syms.trailer\n+                # It shouldn't wrap hexadecimal, binary and octal literals\n+                and (not value.startswith((\"0x\", \"0b\", \"0o\")))",
      "comment": "I find the brackets to be more readable than not having them.",
      "comment_id": 792370878,
      "user": "Shivansh-007",
      "created_at": "2022-01-26T07:36:41Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792370878"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,14 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+            if leaf.type == token.NUMBER and next_leaf.type == syms.trailer:",
      "comment": "It is actually a valid syntax, just not valid semantically. So we should probably handle it (check the first child of the trailer, if it is a dot, then it is an attribute access).",
      "comment_id": 792401190,
      "user": "isidentical",
      "created_at": "2022-01-26T08:27:12Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792401190"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,14 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+            if leaf.type == token.NUMBER and next_leaf.type == syms.trailer:",
      "comment": "@Shivansh-007 could you also add a test to verify this behavior? (both for subscript and calls)",
      "comment_id": 792463667,
      "user": "isidentical",
      "created_at": "2022-01-26T09:46:07Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r792463667"
    },
    {
      "repo": "psf/black",
      "pr_number": 2799,
      "file_path": "src/black/linegen.py",
      "line": 212,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,26 @@ def visit_decorators(self, node: Node) -> Iterator[Line]:\n             yield from self.line()\n             yield from self.visit(child)\n \n+    def visit_power(self, node: Node) -> Iterator[Line]:\n+        for idx, leaf in enumerate(node.children[:-1]):\n+            next_leaf = node.children[idx + 1]\n+\n+            if not isinstance(leaf, Leaf):\n+                continue\n+\n+            value = leaf.value.lower()\n+            if (\n+                leaf.type == token.NUMBER\n+                and next_leaf.type == syms.trailer\n+                # It shouldn't wrap hexadecimal, binary and octal literals\n+                and (not value.startswith((\"0x\", \"0b\", \"0o\")))",
      "comment": "I think it would make sense to follow the existing convention as @felix-hilden just said, e.g:\r\n```console\r\n$ grep -rni 'and (not' src/black\r\n$ grep -rni 'and not' src/black\r\nsrc/black/trans.py:346:            and not has_triple_quotes(string_leaf.value)\r\nsrc/black/trans.py:682:                and not is_empty_rpar(LL[next_idx])\r\nsrc/black/trans.py:1228:                and not csplit.has_prefix\r\nsrc/black/trans.py:1416:                and not breaks_unsplittable_expression(i)\r\nsrc/black/trans.py:1421:        while is_valid_index(break_idx - 1) and not passes_all_checks(break_idx):\r\nsrc/black/trans.py:1431:            while is_valid_index(break_idx + 1) and not passes_all_checks(break_idx):\r\nsrc/black/trans.py:1458:        if \"f\" in prefix and not fstring_contains_expr(string):\r\nsrc/black/__init__.py:92:        if check and not diff:\r\nsrc/black/__init__.py:139:    if target_version is not None and not isinstance(target_version, list):\r\nsrc/black/__init__.py:586:            if p.suffix == \".ipynb\" and not jupyter_dependencies_are_installed(\r\nsrc/black/__init__.py:971:    if not fast and not mode.is_ipynb:\r\nsrc/black/__init__.py:1200:            if len(n.children) > 1 and not is_simple_decorator_expression(\r\nsrc/black/linegen.py:332:        and not line.should_split_rhs\r\nsrc/black/linegen.py:333:        and not line.magic_trailing_comma\r\nsrc/black/linegen.py:338:        and not (line.inside_brackets and line.contains_standalone_comments())\r\n[...]\r\n```",
      "comment_id": 793854581,
      "user": "isidentical",
      "created_at": "2022-01-27T17:43:45Z",
      "url": "https://github.com/psf/black/pull/2799#discussion_r793854581"
    },
    {
      "repo": "psf/black",
      "pr_number": 2363,
      "file_path": "tests/test_primer.py",
      "line": 213,
      "side": "RIGHT",
      "diff_hunk": "@@ -210,7 +210,7 @@ def test_async_main(self) -> None:\n             \"no_diff\": False,\n         }\n         with patch(\"black_primer.cli.lib.process_queue\", return_zero):\n-            return_val = loop.run_until_complete(cli.async_main(**args))\n+            return_val = loop.run_until_complete(cli.async_main(**args))  # type: ignore",
      "comment": "Decided to ignore here, because of the dict's convenience",
      "comment_id": 664792700,
      "user": "felix-hilden",
      "created_at": "2021-07-06T18:38:49Z",
      "url": "https://github.com/psf/black/pull/2363#discussion_r664792700"
    },
    {
      "repo": "psf/black",
      "pr_number": 2807,
      "file_path": "src/black/__init__.py",
      "line": 971,
      "side": "RIGHT",
      "diff_hunk": "@@ -968,17 +968,7 @@ def check_stability_and_equivalence(\n     content differently.\n     \"\"\"\n     assert_equivalent(src_contents, dst_contents)\n-\n-    # Forced second pass to work around optional trailing commas (becoming\n-    # forced trailing commas on pass 2) interacting differently with optional\n-    # parentheses.  Admittedly ugly.\n-    dst_contents_pass2 = format_str(dst_contents, mode=mode)\n-    if dst_contents != dst_contents_pass2:\n-        dst_contents = dst_contents_pass2\n-        assert_equivalent(src_contents, dst_contents, pass_num=2)\n-        assert_stable(src_contents, dst_contents, mode=mode)\n-    # Note: no need to explicitly call `assert_stable` if `dst_contents` was\n-    # the same as `dst_contents_pass2`.\n+    assert_stable(src_contents, dst_contents, mode=mode)",
      "comment": "Does assert_stable really need to call `format_str` now?",
      "comment_id": 792093363,
      "user": "ichard26",
      "created_at": "2022-01-25T20:29:18Z",
      "url": "https://github.com/psf/black/pull/2807#discussion_r792093363"
    },
    {
      "repo": "psf/black",
      "pr_number": 2807,
      "file_path": "src/black/__init__.py",
      "line": 971,
      "side": "RIGHT",
      "diff_hunk": "@@ -968,17 +968,7 @@ def check_stability_and_equivalence(\n     content differently.\n     \"\"\"\n     assert_equivalent(src_contents, dst_contents)\n-\n-    # Forced second pass to work around optional trailing commas (becoming\n-    # forced trailing commas on pass 2) interacting differently with optional\n-    # parentheses.  Admittedly ugly.\n-    dst_contents_pass2 = format_str(dst_contents, mode=mode)\n-    if dst_contents != dst_contents_pass2:\n-        dst_contents = dst_contents_pass2\n-        assert_equivalent(src_contents, dst_contents, pass_num=2)\n-        assert_stable(src_contents, dst_contents, mode=mode)\n-    # Note: no need to explicitly call `assert_stable` if `dst_contents` was\n-    # the same as `dst_contents_pass2`.\n+    assert_stable(src_contents, dst_contents, mode=mode)",
      "comment": "I suppose we could call `_format_str_once` instead, but I like the idea of that being a private function that nobody else should call.\r\n\r\nWe still need to call some variant of format_str here in case it's still not stable after the second pass.",
      "comment_id": 792095260,
      "user": "JelleZijlstra",
      "created_at": "2022-01-25T20:32:13Z",
      "url": "https://github.com/psf/black/pull/2807#discussion_r792095260"
    },
    {
      "repo": "psf/black",
      "pr_number": 2807,
      "file_path": "src/black/__init__.py",
      "line": 971,
      "side": "RIGHT",
      "diff_hunk": "@@ -968,17 +968,7 @@ def check_stability_and_equivalence(\n     content differently.\n     \"\"\"\n     assert_equivalent(src_contents, dst_contents)\n-\n-    # Forced second pass to work around optional trailing commas (becoming\n-    # forced trailing commas on pass 2) interacting differently with optional\n-    # parentheses.  Admittedly ugly.\n-    dst_contents_pass2 = format_str(dst_contents, mode=mode)\n-    if dst_contents != dst_contents_pass2:\n-        dst_contents = dst_contents_pass2\n-        assert_equivalent(src_contents, dst_contents, pass_num=2)\n-        assert_stable(src_contents, dst_contents, mode=mode)\n-    # Note: no need to explicitly call `assert_stable` if `dst_contents` was\n-    # the same as `dst_contents_pass2`.\n+    assert_stable(src_contents, dst_contents, mode=mode)",
      "comment": "This is already a bit of stretch but I was concerned about `assert_stable` hiding a stability bug chain of two (one in the main secondary format pass, and then the first under assert_stable's format_str) . I suppose it doesn't matter at this point though.",
      "comment_id": 792097224,
      "user": "ichard26",
      "created_at": "2022-01-25T20:35:23Z",
      "url": "https://github.com/psf/black/pull/2807#discussion_r792097224"
    },
    {
      "repo": "psf/black",
      "pr_number": 2807,
      "file_path": "src/black/__init__.py",
      "line": 971,
      "side": "RIGHT",
      "diff_hunk": "@@ -968,17 +968,7 @@ def check_stability_and_equivalence(\n     content differently.\n     \"\"\"\n     assert_equivalent(src_contents, dst_contents)\n-\n-    # Forced second pass to work around optional trailing commas (becoming\n-    # forced trailing commas on pass 2) interacting differently with optional\n-    # parentheses.  Admittedly ugly.\n-    dst_contents_pass2 = format_str(dst_contents, mode=mode)\n-    if dst_contents != dst_contents_pass2:\n-        dst_contents = dst_contents_pass2\n-        assert_equivalent(src_contents, dst_contents, pass_num=2)\n-        assert_stable(src_contents, dst_contents, mode=mode)\n-    # Note: no need to explicitly call `assert_stable` if `dst_contents` was\n-    # the same as `dst_contents_pass2`.\n+    assert_stable(src_contents, dst_contents, mode=mode)",
      "comment": "Actually, it might hide a cycle, where we move back and forth between two versions deterministically.",
      "comment_id": 792098145,
      "user": "JelleZijlstra",
      "created_at": "2022-01-25T20:36:54Z",
      "url": "https://github.com/psf/black/pull/2807#discussion_r792098145"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "src/black/linegen.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,7 +22,12 @@\n from black.strings import get_string_prefix, fix_docstring\n from black.strings import normalize_string_prefix, normalize_string_quotes\n from black.trans import Transformer, CannotTransform, StringMerger\n-from black.trans import StringSplitter, StringParenWrapper, StringParenStripper\n+from black.trans import (\n+    StringSplitter,\n+    StringParenWrapper,\n+    StringParenStripper,\n+    hug_power_op,\n+)",
      "comment": "NIT: should we add the above imports to this list as well or split this import to multiple statements like currently? Personally, I prefer the parens.",
      "comment_id": 777247279,
      "user": "felix-hilden",
      "created_at": "2022-01-02T19:45:23Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r777247279"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "src/black/trans.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +71,88 @@ def TErr(err_msg: str) -> Err[CannotTransform]:\n     return Err(cant_transform)\n \n \n+def hug_power_op(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n+    \"\"\"A transformer which normalizes spacing around power operators.\"\"\"\n+\n+    # Performance optimization to avoid unnecessary Leaf clones and other ops.\n+    for leaf in line.leaves:\n+        if leaf.type == token.DOUBLESTAR:\n+            break\n+    else:\n+        raise CannotTransform(\"No doublestar token was found in the line.\")\n+\n+    def is_simple_lookup(index: int, step: Literal[1, -1]) -> bool:",
      "comment": "Would it be better to add `line` as a parameter? I'm thinking creating functions every time a power is formatted could be more costly than passing an additional parameter, but honestly I'm not sure how impactful it is.",
      "comment_id": 777247762,
      "user": "felix-hilden",
      "created_at": "2022-01-02T19:50:43Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r777247762"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "src/black/trans.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +71,88 @@ def TErr(err_msg: str) -> Err[CannotTransform]:\n     return Err(cant_transform)\n \n \n+def hug_power_op(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n+    \"\"\"A transformer which normalizes spacing around power operators.\"\"\"\n+\n+    # Performance optimization to avoid unnecessary Leaf clones and other ops.\n+    for leaf in line.leaves:\n+        if leaf.type == token.DOUBLESTAR:\n+            break\n+    else:\n+        raise CannotTransform(\"No doublestar token was found in the line.\")\n+\n+    def is_simple_lookup(index: int, step: Literal[1, -1]) -> bool:",
      "comment": "So for some reason I'm starting to really like nested functions as part of larger functions. The nested functions aren't intended for generic reuse (for now) but are logically a bit more separate if that makes sense. I'm happy to change this bit as I understand this may be not a style most would like.",
      "comment_id": 779933439,
      "user": "ichard26",
      "created_at": "2022-01-06T23:29:09Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r779933439"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "src/black/linegen.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,7 +22,12 @@\n from black.strings import get_string_prefix, fix_docstring\n from black.strings import normalize_string_prefix, normalize_string_quotes\n from black.trans import Transformer, CannotTransform, StringMerger\n-from black.trans import StringSplitter, StringParenWrapper, StringParenStripper\n+from black.trans import (\n+    StringSplitter,\n+    StringParenWrapper,\n+    StringParenStripper,\n+    hug_power_op,\n+)",
      "comment": "Oh I completely missed the trans.py import above this line. I don't have a preference eitherway.",
      "comment_id": 779934163,
      "user": "ichard26",
      "created_at": "2022-01-06T23:31:07Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r779934163"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "src/black/trans.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +71,88 @@ def TErr(err_msg: str) -> Err[CannotTransform]:\n     return Err(cant_transform)\n \n \n+def hug_power_op(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n+    \"\"\"A transformer which normalizes spacing around power operators.\"\"\"\n+\n+    # Performance optimization to avoid unnecessary Leaf clones and other ops.\n+    for leaf in line.leaves:\n+        if leaf.type == token.DOUBLESTAR:\n+            break\n+    else:\n+        raise CannotTransform(\"No doublestar token was found in the line.\")\n+\n+    def is_simple_lookup(index: int, step: Literal[1, -1]) -> bool:",
      "comment": "Fair enough, my intuition would be to make private functions in that case. But style-wise I think it's a matter of taste, I was just more concerned about the potential performance hit with math-heavy code. Haven't tested it at all though \ud83d\ude04",
      "comment_id": 779938242,
      "user": "felix-hilden",
      "created_at": "2022-01-06T23:42:56Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r779938242"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "src/black/linegen.py",
      "line": 354,
      "side": "RIGHT",
      "diff_hunk": "@@ -342,9 +347,9 @@ def transform_line(\n     ):\n         # Only apply basic string preprocessing, since lines shouldn't be split here.\n         if mode.experimental_string_processing:\n-            transformers = [string_merge, string_paren_strip]\n+            transformers = [string_merge, string_paren_strip, hug_power_op]\n         else:\n-            transformers = []\n+            transformers = [hug_power_op]\n     elif line.is_def:\n         transformers = [left_hand_split]",
      "comment": "Should hug_power_op be in here? Maybe it's easier to just unconditionally add it at the end.",
      "comment_id": 780376170,
      "user": "JelleZijlstra",
      "created_at": "2022-01-07T16:26:38Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r780376170"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "src/black/trans.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +71,88 @@ def TErr(err_msg: str) -> Err[CannotTransform]:\n     return Err(cant_transform)\n \n \n+def hug_power_op(line: Line, features: Collection[Feature]) -> Iterator[Line]:\n+    \"\"\"A transformer which normalizes spacing around power operators.\"\"\"\n+\n+    # Performance optimization to avoid unnecessary Leaf clones and other ops.\n+    for leaf in line.leaves:\n+        if leaf.type == token.DOUBLESTAR:\n+            break\n+    else:\n+        raise CannotTransform(\"No doublestar token was found in the line.\")\n+\n+    def is_simple_lookup(index: int, step: Literal[1, -1]) -> bool:\n+        # Brackets and parenthesises indicate calls, subscripts, etc. ...",
      "comment": "```suggestion\r\n        # Brackets and parentheses indicate calls, subscripts, etc. ...\r\n```",
      "comment_id": 780376558,
      "user": "JelleZijlstra",
      "created_at": "2022-01-07T16:27:12Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r780376558"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "tests/data/power_op_spacing.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+def function(**kwargs):\n+    t = a**2 + b**3\n+    return t ** 2\n+\n+\n+def function_replace_spaces(**kwargs):\n+    t = a **2 + b** 3 + c ** 4\n+\n+\n+def function_dont_replace_spaces():\n+    {**a, **b, **c}\n+\n+\n+a = 5**~4\n+b = 5 ** f()\n+c = -(5**2)\n+d = 5 ** f[\"hi\"]\n+e = lazy(lambda **kwargs: 5)\n+f = f() ** 5\n+g = a.b**c.d\n+h = 5 ** funcs.f()\n+i = funcs.f() ** 5\n+j = super().name ** 5\n+k = [(2**idx, value) for idx, value in pairs]\n+l = mod.weights_[0] == pytest.approx(0.95**100, abs=0.001)\n+m = [([2**63], [1, 2**63])]\n+n = count <= 10**5\n+o = settings(max_examples=10**6)\n+p = {(k, k**2): v**2 for k, v in pairs}\n+q = [10**i for i in range(6)]\n+",
      "comment": "A fun case to test might be `1.0.real ** 5.0.real`. I'd say that should not hug but I don't feel strongly if it's easier to implement the other way.",
      "comment_id": 780379422,
      "user": "JelleZijlstra",
      "created_at": "2022-01-07T16:31:22Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r780379422"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "tests/data/power_op_spacing.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+def function(**kwargs):\n+    t = a**2 + b**3\n+    return t ** 2\n+\n+\n+def function_replace_spaces(**kwargs):\n+    t = a **2 + b** 3 + c ** 4\n+\n+\n+def function_dont_replace_spaces():\n+    {**a, **b, **c}\n+\n+\n+a = 5**~4\n+b = 5 ** f()\n+c = -(5**2)\n+d = 5 ** f[\"hi\"]\n+e = lazy(lambda **kwargs: 5)\n+f = f() ** 5\n+g = a.b**c.d\n+h = 5 ** funcs.f()\n+i = funcs.f() ** 5\n+j = super().name ** 5\n+k = [(2**idx, value) for idx, value in pairs]\n+l = mod.weights_[0] == pytest.approx(0.95**100, abs=0.001)\n+m = [([2**63], [1, 2**63])]\n+n = count <= 10**5\n+o = settings(max_examples=10**6)\n+p = {(k, k**2): v**2 for k, v in pairs}\n+q = [10**i for i in range(6)]\n+",
      "comment": "Also could use some tests with float literals instead of int literals.",
      "comment_id": 780379778,
      "user": "JelleZijlstra",
      "created_at": "2022-01-07T16:31:47Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r780379778"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "src/black/linegen.py",
      "line": 354,
      "side": "RIGHT",
      "diff_hunk": "@@ -342,9 +347,9 @@ def transform_line(\n     ):\n         # Only apply basic string preprocessing, since lines shouldn't be split here.\n         if mode.experimental_string_processing:\n-            transformers = [string_merge, string_paren_strip]\n+            transformers = [string_merge, string_paren_strip, hug_power_op]\n         else:\n-            transformers = []\n+            transformers = [hug_power_op]\n     elif line.is_def:\n         transformers = [left_hand_split]",
      "comment": "Ah yeah I forgot that power ops can exist as parameter default expressions, gah. Good catch!",
      "comment_id": 780683386,
      "user": "ichard26",
      "created_at": "2022-01-08T16:26:03Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r780683386"
    },
    {
      "repo": "psf/black",
      "pr_number": 2726,
      "file_path": "tests/data/power_op_spacing.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+def function(**kwargs):\n+    t = a**2 + b**3\n+    return t ** 2\n+\n+\n+def function_replace_spaces(**kwargs):\n+    t = a **2 + b** 3 + c ** 4\n+\n+\n+def function_dont_replace_spaces():\n+    {**a, **b, **c}\n+\n+\n+a = 5**~4\n+b = 5 ** f()\n+c = -(5**2)\n+d = 5 ** f[\"hi\"]\n+e = lazy(lambda **kwargs: 5)\n+f = f() ** 5\n+g = a.b**c.d\n+h = 5 ** funcs.f()\n+i = funcs.f() ** 5\n+j = super().name ** 5\n+k = [(2**idx, value) for idx, value in pairs]\n+l = mod.weights_[0] == pytest.approx(0.95**100, abs=0.001)\n+m = [([2**63], [1, 2**63])]\n+n = count <= 10**5\n+o = settings(max_examples=10**6)\n+p = {(k, k**2): v**2 for k, v in pairs}\n+q = [10**i for i in range(6)]\n+",
      "comment": "I don't care either way but this feels like it goes against the allowance of attribute access in the rule stated above. We could stop hugging attribute access entirely but I'd argue it's more readable once you add other operators:\r\n```python\r\nf = Decimal(10 ** field.max_digits - 1) / (10 ** field.decimal_places) \r\ng = a.b**c.d + factor * 2\r\n\r\n# vs.\r\n\r\nf = Decimal(10**field.max_digits - 1) / (10**field.decimal_places)\r\ng = a.b ** c.d + factor * 2\r\n```\r\n\r\nFor the record making this case not hug should be as simple as:\r\n```diff\r\n@@ -101,6 +101,10 @@ def hug_power_op(line: Line, features: Collection[Feature]) -> Iterator[Line]:\r\n                 # of a comprehension.\r\n                 return True\r\n \r\n+            # Attribute access on numeric constants is also disallowed.\r\n+            if current.type == token.NAME:\r\n+                disallowed.add(token.NUMBER)\r\n+             \r\n             index += step\r\n \r\n         return True\r\n```\r\n\r\n---\r\n\r\n> Also could use some tests with float literals instead of int literals.\r\n\r\nGood idea!",
      "comment_id": 780698460,
      "user": "ichard26",
      "created_at": "2022-01-08T18:49:47Z",
      "url": "https://github.com/psf/black/pull/2726#discussion_r780698460"
    },
    {
      "repo": "psf/black",
      "pr_number": 2804,
      "file_path": "src/black/__init__.py",
      "line": 572,
      "side": "LEFT",
      "diff_hunk": "@@ -569,7 +580,6 @@ def get_sources(\n ) -> Set[Path]:\n     \"\"\"Compute the set of files to be formatted.\"\"\"\n     sources: Set[Path] = set()\n-    path_empty(src, \"No Path provided. Nothing to do \ud83d\ude34\", quiet, verbose, ctx)",
      "comment": "Shouldn't happen anymore because the check is done above.",
      "comment_id": 790599096,
      "user": "felix-hilden",
      "created_at": "2022-01-24T10:24:26Z",
      "url": "https://github.com/psf/black/pull/2804#discussion_r790599096"
    },
    {
      "repo": "psf/black",
      "pr_number": 2804,
      "file_path": "tests/test_black.py",
      "line": 1244,
      "side": "RIGHT",
      "diff_hunk": "@@ -1229,12 +1234,14 @@ def test_invalid_cli_regex(self) -> None:\n \n     def test_required_version_matches_version(self) -> None:\n         self.invokeBlack(\n-            [\"--required-version\", black.__version__], exit_code=0, ignore_config=True\n+            [\"--required-version\", black.__version__, \"-c\", \"0\"],\n+            exit_code=0,\n+            ignore_config=True,\n         )\n \n     def test_required_version_does_not_match_version(self) -> None:\n         self.invokeBlack(\n-            [\"--required-version\", \"20.99b\"], exit_code=1, ignore_config=True\n+            [\"--required-version\", \"20.99b\", \"-c\", \"0\"], exit_code=1, ignore_config=True",
      "comment": "Technically still would succeed without the dummy code, but the exit code can't tell the source. Should we assert on error message?",
      "comment_id": 790599681,
      "user": "felix-hilden",
      "created_at": "2022-01-24T10:25:07Z",
      "url": "https://github.com/psf/black/pull/2804#discussion_r790599681"
    },
    {
      "repo": "psf/black",
      "pr_number": 2804,
      "file_path": "tests/test_black.py",
      "line": 1244,
      "side": "RIGHT",
      "diff_hunk": "@@ -1229,12 +1234,14 @@ def test_invalid_cli_regex(self) -> None:\n \n     def test_required_version_matches_version(self) -> None:\n         self.invokeBlack(\n-            [\"--required-version\", black.__version__], exit_code=0, ignore_config=True\n+            [\"--required-version\", black.__version__, \"-c\", \"0\"],\n+            exit_code=0,\n+            ignore_config=True,\n         )\n \n     def test_required_version_does_not_match_version(self) -> None:\n         self.invokeBlack(\n-            [\"--required-version\", \"20.99b\"], exit_code=1, ignore_config=True\n+            [\"--required-version\", \"20.99b\", \"-c\", \"0\"], exit_code=1, ignore_config=True",
      "comment": "On a second thought, the code is required, because otherwise the error message will be the source requirement. But we could still assert on the error to make sure to avoid mistakes in the future.",
      "comment_id": 790613991,
      "user": "felix-hilden",
      "created_at": "2022-01-24T10:41:27Z",
      "url": "https://github.com/psf/black/pull/2804#discussion_r790613991"
    },
    {
      "repo": "psf/black",
      "pr_number": 2802,
      "file_path": "fuzz.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,6 +33,7 @@\n         line_length=st.just(88) | st.integers(0, 200),\n         string_normalization=st.booleans(),",
      "comment": "```suggestion\r\n        string_normalization=st.booleans(),\r\n        preview=st.booleans(),\r\n```\r\nWhile we're here let's add this too.",
      "comment_id": 790321435,
      "user": "JelleZijlstra",
      "created_at": "2022-01-23T19:40:20Z",
      "url": "https://github.com/psf/black/pull/2802#discussion_r790321435"
    },
    {
      "repo": "psf/black",
      "pr_number": 2786,
      "file_path": "src/black/__init__.py",
      "line": 1320,
      "side": "RIGHT",
      "diff_hunk": "@@ -1315,7 +1315,9 @@ def assert_equivalent(src: str, dst: str, *, pass_num: int = 1) -> None:\n         src_ast = parse_ast(src)\n     except Exception as exc:\n         raise AssertionError(\n-            f\"cannot use --safe with this file; failed to parse source file: {exc}\"\n+            f\"cannot use --safe with this file; failed to parse source file AST: {exc}\"\n+            f\"This could be caused by running black with an older python version \"\n+            f\"that does not support new syntax used in your source file.\"",
      "comment": "This will all get mushed into one line, which probably won't look great.\r\n\r\nNot sure if it's worth it, but maybe we can raise a custom exception class here, and in the top-level code that displays errors to the user format it nicely.",
      "comment_id": 788335393,
      "user": "JelleZijlstra",
      "created_at": "2022-01-20T04:07:53Z",
      "url": "https://github.com/psf/black/pull/2786#discussion_r788335393"
    },
    {
      "repo": "psf/black",
      "pr_number": 2786,
      "file_path": "src/black/__init__.py",
      "line": 1320,
      "side": "RIGHT",
      "diff_hunk": "@@ -1315,7 +1315,9 @@ def assert_equivalent(src: str, dst: str, *, pass_num: int = 1) -> None:\n         src_ast = parse_ast(src)\n     except Exception as exc:\n         raise AssertionError(\n-            f\"cannot use --safe with this file; failed to parse source file: {exc}\"\n+            f\"cannot use --safe with this file; failed to parse source file AST: {exc}\"\n+            f\"This could be caused by running black with an older python version \"\n+            f\"that does not support new syntax used in your source file.\"",
      "comment": "I agree it isn't ideal.\r\nThat is more than I can take on at this time though(Covid/childcare problems).",
      "comment_id": 788815493,
      "user": "emfdavid",
      "created_at": "2022-01-20T14:26:38Z",
      "url": "https://github.com/psf/black/pull/2786#discussion_r788815493"
    },
    {
      "repo": "psf/black",
      "pr_number": 2786,
      "file_path": "src/black/__init__.py",
      "line": 1318,
      "side": "RIGHT",
      "diff_hunk": "@@ -1315,7 +1315,9 @@ def assert_equivalent(src: str, dst: str, *, pass_num: int = 1) -> None:\n         src_ast = parse_ast(src)\n     except Exception as exc:\n         raise AssertionError(\n-            f\"cannot use --safe with this file; failed to parse source file: {exc}\"\n+            f\"cannot use --safe with this file; failed to parse source file AST: {exc}\"",
      "comment": "Perhaps a simpler solution to the problem @JelleZijlstra noticed would be:\r\n```suggestion\r\n            f\"cannot use --safe with this file; failed to parse source file AST: {exc}\\n\"\r\n```",
      "comment_id": 788897322,
      "user": "isidentical",
      "created_at": "2022-01-20T15:48:07Z",
      "url": "https://github.com/psf/black/pull/2786#discussion_r788897322"
    },
    {
      "repo": "psf/black",
      "pr_number": 2786,
      "file_path": "src/black/__init__.py",
      "line": 1319,
      "side": "RIGHT",
      "diff_hunk": "@@ -1315,7 +1315,9 @@ def assert_equivalent(src: str, dst: str, *, pass_num: int = 1) -> None:\n         src_ast = parse_ast(src)\n     except Exception as exc:\n         raise AssertionError(\n-            f\"cannot use --safe with this file; failed to parse source file: {exc}\"\n+            f\"cannot use --safe with this file; failed to parse source file AST: {exc}\\n\"\n+            f\"This could be caused by running black with an older python version \"",
      "comment": "```suggestion\r\n            f\"cannot use --safe with this file; failed to parse source file AST: \"\r\n            f\"{exc}\\n\"\r\n            f\"This could be caused by running black with an older python version \"\r\n```\r\nLine too long for lint",
      "comment_id": 788976593,
      "user": "JelleZijlstra",
      "created_at": "2022-01-20T17:11:13Z",
      "url": "https://github.com/psf/black/pull/2786#discussion_r788976593"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/__init__.py",
      "line": 229,
      "side": "RIGHT",
      "diff_hunk": "@@ -224,6 +224,16 @@ def validate_regex(\n         \"(useful when piping source on standard input).\"\n     ),\n )\n+@click.option(\n+    \"--python-cell-magics\",\n+    multiple=True,",
      "comment": "A bit jarring to write `--python-cell-magics custom1 --python-cell-magics custom2`. Should we use a comma-separated list instead?",
      "comment_id": 778129323,
      "user": "felix-hilden",
      "created_at": "2022-01-04T14:37:00Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r778129323"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "tests/test_ipynb.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -139,6 +140,17 @@ def test_cell_magic_with_magic() -> None:\n     assert result == expected\n \n \n+def test_cell_magic_with_custom_python_magic() -> None:\n+    src = \"%%custom_python_magic -n1 -n2\\nx=2\"\n+    result = format_cell(\n+        src,\n+        fast=True,\n+        mode=replace(JUPYTER_MODE, python_cell_magics={\"custom_python_magic\"}),\n+    )\n+    expected = \"%%custom_python_magic -n1 -n2\\nx = 2\"\n+    assert result == expected",
      "comment": "should there also be a test to check that if you pass some custom magic, then the default Python magics still get formatted?",
      "comment_id": 778134220,
      "user": "MarcoGorelli",
      "created_at": "2022-01-04T14:42:59Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r778134220"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "tests/test_ipynb.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -139,6 +140,17 @@ def test_cell_magic_with_magic() -> None:\n     assert result == expected\n \n \n+def test_cell_magic_with_custom_python_magic() -> None:\n+    src = \"%%custom_python_magic -n1 -n2\\nx=2\"\n+    result = format_cell(\n+        src,\n+        fast=True,\n+        mode=replace(JUPYTER_MODE, python_cell_magics={\"custom_python_magic\"}),\n+    )\n+    expected = \"%%custom_python_magic -n1 -n2\\nx = 2\"\n+    assert result == expected",
      "comment": "Probably, and that when not passing but trying to format custom it isn't formatted \ud83d\udc4d",
      "comment_id": 778135022,
      "user": "felix-hilden",
      "created_at": "2022-01-04T14:44:03Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r778135022"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/__init__.py",
      "line": 229,
      "side": "RIGHT",
      "diff_hunk": "@@ -224,6 +224,16 @@ def validate_regex(\n         \"(useful when piping source on standard input).\"\n     ),\n )\n+@click.option(\n+    \"--python-cell-magics\",\n+    multiple=True,",
      "comment": "Agreed, though this is how `click` supports multiple options out of the box.  This is also how `target-version` takes multiple arguments.  I expect that we would need to introduce a custom callback to support multiple options, which might then also require custom logic when reading from the `pyproject.toml` file.\r\n\r\nMy expectation is that this will rather mostly be used in a configuration file and so perhaps the clunkiness on the command line is acceptable.",
      "comment_id": 778143187,
      "user": "mgmarino",
      "created_at": "2022-01-04T14:54:24Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r778143187"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/mode.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,5 +184,6 @@ def get_cache_key(self) -> str:\n             str(int(self.is_ipynb)),\n             str(int(self.magic_trailing_comma)),\n             str(int(self.experimental_string_processing)),\n+            \",\".join(self.python_cell_magics),",
      "comment": "```suggestion\r\n            \",\".join(sorted(self.python_cell_magics)),\r\n```\r\nSet iteration order is randomized, so this would make the cache key unstable",
      "comment_id": 784458194,
      "user": "JelleZijlstra",
      "created_at": "2022-01-14T02:03:34Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r784458194"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "tests/test_ipynb.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -139,6 +162,41 @@ def test_cell_magic_with_magic() -> None:\n     assert result == expected\n \n \n+@pytest.mark.parametrize(\n+    \"mode, expected_output, expectation\",\n+    [\n+        pytest.param(\n+            JUPYTER_MODE,\n+            \"%%custom_python_magic -n1 -n2\\nx=2\",\n+            pytest.raises(NothingChanged),\n+            id=\"No change when cell magic not registered\",\n+        ),\n+        pytest.param(\n+            replace(JUPYTER_MODE, python_cell_magics={\"cust1\", \"cust1\"}),\n+            \"%%custom_python_magic -n1 -n2\\nx=2\",\n+            pytest.raises(NothingChanged),\n+            id=\"No change when other cell magics registered\",\n+        ),\n+        pytest.param(\n+            replace(JUPYTER_MODE, python_cell_magics={\"custom_python_magic\", \"cust1\"}),\n+            \"%%custom_python_magic -n1 -n2\\nx = 2\",\n+            does_not_raise(),\n+            id=\"Correctly change when cell magic registered\",\n+        ),\n+    ],\n+)\n+def test_cell_magic_with_custom_python_magic(\n+    mode: Mode, expected_output: str, expectation: ContextManager[Any]",
      "comment": "```suggestion\r\n    mode: Mode, expected_output: str, expectation: ContextManager[object]\r\n```\r\nAvoid Any if possible. `object` makes sense if you don't want to do anything with the object.",
      "comment_id": 784458751,
      "user": "JelleZijlstra",
      "created_at": "2022-01-14T02:05:28Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r784458751"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/mode.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,5 +148,6 @@ def get_cache_key(self) -> str:\n             str(int(self.is_ipynb)),\n             str(int(self.magic_trailing_comma)),\n             str(int(self.experimental_string_processing)),\n+            \",\".join(sorted(self.python_cell_magics)),",
      "comment": "At this point I'm a little worried that we might hit some filesystem file name length limits. I assume that Python cell magics are also filesystem safe? can't contain slashes, colons, whatever isn't safe. Worst case we could hash 'em with blake2/3 or something.\r\n\r\nThe cache should fail gracefully but I'm not entirely sure if it does so yeah. This can be resolved separately though. ",
      "comment_id": 786097304,
      "user": "ichard26",
      "created_at": "2022-01-17T15:13:08Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r786097304"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/mode.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,5 +148,6 @@ def get_cache_key(self) -> str:\n             str(int(self.is_ipynb)),\n             str(int(self.magic_trailing_comma)),\n             str(int(self.experimental_string_processing)),\n+            \",\".join(sorted(self.python_cell_magics)),",
      "comment": "Good point. Maybe we can hash the value with some consistent hashing algorithm available in the stdlib.",
      "comment_id": 786103716,
      "user": "JelleZijlstra",
      "created_at": "2022-01-17T15:21:10Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r786103716"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/mode.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,5 +148,6 @@ def get_cache_key(self) -> str:\n             str(int(self.is_ipynb)),\n             str(int(self.magic_trailing_comma)),\n             str(int(self.experimental_string_processing)),\n+            \",\".join(sorted(self.python_cell_magics)),",
      "comment": "I think, in general, most magics are simply function names and so must abide by the corresponding python naming requirements.  But I think there are also ways to generate the magics labeled with an arbitrary string.\r\n\r\nDoes the cache label need to be human readable?  If not, +1 to hashing.  You can also ensure that the name has a set length, and so could apply this to the entire cache string.  We use the following code when hashing arbitrary length strings for file-system caching:\r\n\r\n```python\r\nhashlib.md5(label.encode()).hexdigest()\r\n```",
      "comment_id": 786109828,
      "user": "mgmarino",
      "created_at": "2022-01-17T15:28:50Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r786109828"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/mode.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,5 +148,6 @@ def get_cache_key(self) -> str:\n             str(int(self.is_ipynb)),\n             str(int(self.magic_trailing_comma)),\n             str(int(self.experimental_string_processing)),\n+            \",\".join(sorted(self.python_cell_magics)),",
      "comment": "It doesn't need to be human-readable, though it's helpful for debugging if it's not too bad. The other components of the key should mostly just be ints, so I think we can get away with not hashing them.",
      "comment_id": 786114219,
      "user": "JelleZijlstra",
      "created_at": "2022-01-17T15:34:21Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r786114219"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/mode.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,5 +148,6 @@ def get_cache_key(self) -> str:\n             str(int(self.is_ipynb)),\n             str(int(self.magic_trailing_comma)),\n             str(int(self.experimental_string_processing)),\n+            \",\".join(sorted(self.python_cell_magics)),",
      "comment": "Could you make the change to hashing? Also, there are a few merge conflicts now.",
      "comment_id": 788281442,
      "user": "JelleZijlstra",
      "created_at": "2022-01-20T01:35:39Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r788281442"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/mode.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,5 +148,6 @@ def get_cache_key(self) -> str:\n             str(int(self.is_ipynb)),\n             str(int(self.magic_trailing_comma)),\n             str(int(self.experimental_string_processing)),\n+            \",\".join(sorted(self.python_cell_magics)),",
      "comment": "Of course.  I've done that and resolved the merge conflicts.",
      "comment_id": 788436436,
      "user": "mgmarino",
      "created_at": "2022-01-20T07:24:30Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r788436436"
    },
    {
      "repo": "psf/black",
      "pr_number": 2744,
      "file_path": "src/black/__init__.py",
      "line": 414,
      "side": "RIGHT",
      "diff_hunk": "@@ -401,6 +411,7 @@ def main(\n     fast: bool,\n     pyi: bool,\n     ipynb: bool,\n+    python_cell_magics: List[str],",
      "comment": "```suggestion\r\n    python_cell_magics: Sequence[str],\r\n```\r\nSeems like it's sometimes a tuple at runtime, which makes mypyc unhappy",
      "comment_id": 789250362,
      "user": "JelleZijlstra",
      "created_at": "2022-01-21T00:25:05Z",
      "url": "https://github.com/psf/black/pull/2744#discussion_r789250362"
    },
    {
      "repo": "psf/black",
      "pr_number": 2789,
      "file_path": "src/black/mode.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,6 +125,12 @@ def supports_feature(target_versions: Set[TargetVersion], feature: Feature) -> b\n class Preview(Enum):\n     \"\"\"Individual preview style features.\"\"\"\n \n+    string_processing = auto\n+\n+\n+class Deprecated(UserWarning):",
      "comment": "The builtin `DeprecationWarning` is invisible by default.",
      "comment_id": 789203140,
      "user": "felix-hilden",
      "created_at": "2022-01-20T22:35:19Z",
      "url": "https://github.com/psf/black/pull/2789#discussion_r789203140"
    },
    {
      "repo": "psf/black",
      "pr_number": 2789,
      "file_path": "src/black/mode.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,13 +143,23 @@ class Mode:\n     experimental_string_processing: bool = False\n     preview: bool = False\n \n+    def __post_init__(self) -> None:\n+        if self.experimental_string_processing:\n+            warn(\n+                \"`experimental string processing` has been included in `preview`\"\n+                \" and deprecated. Use `preview` instead.\",\n+                Deprecated,",
      "comment": "The reason I'm using `warnings.warn` and warning *here*, is that if we define the public API soon, then the warning is issued when `Mode` is instantiated. But having it in CLI main works as well. There we could just use Click's output rather than issuing proper warnings.",
      "comment_id": 789203413,
      "user": "felix-hilden",
      "created_at": "2022-01-20T22:35:55Z",
      "url": "https://github.com/psf/black/pull/2789#discussion_r789203413"
    },
    {
      "repo": "psf/black",
      "pr_number": 2789,
      "file_path": "src/black/mode.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,6 +125,12 @@ def supports_feature(target_versions: Set[TargetVersion], feature: Feature) -> b\n class Preview(Enum):\n     \"\"\"Individual preview style features.\"\"\"\n \n+    string_processing = auto",
      "comment": "```suggestion\r\n    string_processing = auto()\r\n```\r\nUnless it's even more magical than I thought",
      "comment_id": 789209351,
      "user": "JelleZijlstra",
      "created_at": "2022-01-20T22:47:24Z",
      "url": "https://github.com/psf/black/pull/2789#discussion_r789209351"
    },
    {
      "repo": "psf/black",
      "pr_number": 2789,
      "file_path": "src/black/mode.py",
      "line": 161,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,13 +143,23 @@ class Mode:\n     experimental_string_processing: bool = False\n     preview: bool = False\n \n+    def __post_init__(self) -> None:\n+        if self.experimental_string_processing:\n+            warn(\n+                \"`experimental string processing` has been included in `preview`\"\n+                \" and deprecated. Use `preview` instead.\",\n+                Deprecated,\n+            )\n+\n     def __contains__(self, feature: Preview) -> bool:\n         \"\"\"\n         Provide `Preview.FEATURE in Mode` syntax that mirrors the ``preview`` flag.\n \n         The argument is not checked and features are not differentiated.\n         They only exist to make development easier by clarifying intent.\n         \"\"\"\n+        if feature == Preview.string_processing:",
      "comment": "```suggestion\r\n        if feature is Preview.string_processing:\r\n```\r\nEnums can be compared by identity",
      "comment_id": 789209582,
      "user": "JelleZijlstra",
      "created_at": "2022-01-20T22:47:49Z",
      "url": "https://github.com/psf/black/pull/2789#discussion_r789209582"
    },
    {
      "repo": "psf/black",
      "pr_number": 2789,
      "file_path": "src/black/mode.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,13 +143,23 @@ class Mode:\n     experimental_string_processing: bool = False\n     preview: bool = False\n \n+    def __post_init__(self) -> None:\n+        if self.experimental_string_processing:\n+            warn(\n+                \"`experimental string processing` has been included in `preview`\"\n+                \" and deprecated. Use `preview` instead.\",\n+                Deprecated,\n+            )\n+\n     def __contains__(self, feature: Preview) -> bool:\n         \"\"\"\n         Provide `Preview.FEATURE in Mode` syntax that mirrors the ``preview`` flag.\n \n         The argument is not checked and features are not differentiated.\n         They only exist to make development easier by clarifying intent.\n         \"\"\"\n+        if feature is Preview.string_processing:\n+            return self.preview or self.experimental_string_processing\n         return self.preview",
      "comment": "Looks like mypy (correctly) detects that this line is unreachable. Maybe to satisfy it we can add a feature we know we'll add to `--preview`, such as power operand hugging.",
      "comment_id": 789215427,
      "user": "JelleZijlstra",
      "created_at": "2022-01-20T22:59:38Z",
      "url": "https://github.com/psf/black/pull/2789#discussion_r789215427"
    },
    {
      "repo": "psf/black",
      "pr_number": 2789,
      "file_path": "src/black/mode.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,13 +143,23 @@ class Mode:\n     experimental_string_processing: bool = False\n     preview: bool = False\n \n+    def __post_init__(self) -> None:\n+        if self.experimental_string_processing:\n+            warn(\n+                \"`experimental string processing` has been included in `preview`\"\n+                \" and deprecated. Use `preview` instead.\",\n+                Deprecated,\n+            )\n+\n     def __contains__(self, feature: Preview) -> bool:\n         \"\"\"\n         Provide `Preview.FEATURE in Mode` syntax that mirrors the ``preview`` flag.\n \n         The argument is not checked and features are not differentiated.\n         They only exist to make development easier by clarifying intent.\n         \"\"\"\n+        if feature is Preview.string_processing:\n+            return self.preview or self.experimental_string_processing\n         return self.preview",
      "comment": "I mean just adding the enum definition, not implement the feature in this PR.",
      "comment_id": 789215604,
      "user": "JelleZijlstra",
      "created_at": "2022-01-20T22:59:58Z",
      "url": "https://github.com/psf/black/pull/2789#discussion_r789215604"
    },
    {
      "repo": "psf/black",
      "pr_number": 2752,
      "file_path": "tests/test_format.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +78,8 @@\n     \"parenthesized_context_managers\",\n ]\n \n+PREVIEW_CASES = []",
      "comment": "I guess `mypy` has some advanced analysis for the test case lists, since the hint isn't needed for other lists. Should I:\r\n\r\n1) add hints for all case lists\r\n2) add it just here and remove it when the first entry is added\r\n3) add test infra later?",
      "comment_id": 780285970,
      "user": "felix-hilden",
      "created_at": "2022-01-07T14:10:53Z",
      "url": "https://github.com/psf/black/pull/2752#discussion_r780285970"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/__init__.py",
      "line": 511,
      "side": "RIGHT",
      "diff_hunk": "@@ -501,10 +507,23 @@ def get_sources(\n     force_exclude: Optional[Pattern[str]],\n     report: \"Report\",\n     stdin_filename: Optional[str],\n-) -> Set[Path]:\n+) -> Tuple[Set[Path], Path]:\n     \"\"\"Compute the set of files to be formatted.\"\"\"",
      "comment": "Let's document here what the second return value means.",
      "comment_id": 739718103,
      "user": "JelleZijlstra",
      "created_at": "2021-10-30T22:02:57Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r739718103"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/files.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,7 +30,7 @@\n \n \n @lru_cache()\n-def find_project_root(srcs: Sequence[str]) -> Path:\n+def find_project_root(srcs: Sequence[str]) -> Tuple[Path, Optional[str]]:\n     \"\"\"Return a directory containing .git, .hg, or pyproject.toml.",
      "comment": "Same here, docstring should say what the rest of the return value is.",
      "comment_id": 739718133,
      "user": "JelleZijlstra",
      "created_at": "2021-10-30T22:03:40Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r739718133"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "tests/test_black.py",
      "line": 1779,
      "side": "RIGHT",
      "diff_hunk": "@@ -1764,7 +1776,7 @@ def test_gitignore_used_as_default(self) -> None:\n         src = [base / \"b/\"]\n         assert_collected_sources(src, expected, extend_exclude=r\"/exclude/\")\n \n-    @patch(\"black.find_project_root\", lambda *args: THIS_DIR.resolve())\n+    @patch(\"black.find_project_root\", lambda *args: (THIS_DIR.resolve(), \"None\"))",
      "comment": "```suggestion\r\n    @patch(\"black.find_project_root\", lambda *args: (THIS_DIR.resolve(), None))\r\n```\r\nThis repeats a bunch of times.",
      "comment_id": 739718202,
      "user": "JelleZijlstra",
      "created_at": "2021-10-30T22:04:54Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r739718202"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/__init__.py",
      "line": 517,
      "side": "RIGHT",
      "diff_hunk": "@@ -501,10 +507,23 @@ def get_sources(\n     force_exclude: Optional[Pattern[str]],\n     report: \"Report\",\n     stdin_filename: Optional[str],\n-) -> Set[Path]:\n+) -> Tuple[Set[Path], Path]:\n     \"\"\"Compute the set of files to be formatted.\"\"\"\n+    root, method = find_project_root(src)\n+\n+    if verbose:\n+        if method:\n+            out(\n+                f\"Identified `{root}` as project root containing a '{method}'.\",",
      "comment": "```suggestion\r\n                f\"Identified `{root}` as project root containing a {method}.\",\r\n```\r\nLooks better than the current output:\r\n```\r\nIdentified `/Users/jelle/py/black` as project root containing a '.git directory'.\r\n```",
      "comment_id": 739719347,
      "user": "JelleZijlstra",
      "created_at": "2021-10-30T22:16:14Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r739719347"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/report.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +13,12 @@\n from black.output import out, err\n \n \n+def root_relative(path: Path, root: Optional[Path]) -> Path:\n+    if not root:\n+        return path\n+    return Path(os.path.relpath(path, start=Path(f\"{root}/../\")))",
      "comment": "`pathlib.Path` does have `p.relative_to`. But this works fine too \ud83d\udc4d ",
      "comment_id": 766382961,
      "user": "felix-hilden",
      "created_at": "2021-12-10T06:49:02Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r766382961"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/report.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +13,12 @@\n from black.output import out, err\n \n \n+def root_relative(path: Path, root: Optional[Path]) -> Path:\n+    if not root:\n+        return path\n+    return Path(os.path.relpath(path, start=Path(f\"{root}/../\")))",
      "comment": "```suggestion\r\n    return path.relative_to(root.parent)\r\n```\r\nwould be the form. So why the parent?",
      "comment_id": 766389397,
      "user": "felix-hilden",
      "created_at": "2021-12-10T06:54:49Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r766389397"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/report.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +13,12 @@\n from black.output import out, err\n \n \n+def root_relative(path: Path, root: Optional[Path]) -> Path:\n+    if not root:\n+        return path\n+    return Path(os.path.relpath(path, start=Path(f\"{root}/../\")))",
      "comment": "Oh I guess we want the root folder to be included?",
      "comment_id": 766389754,
      "user": "felix-hilden",
      "created_at": "2021-12-10T06:55:21Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r766389754"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/report.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +13,12 @@\n from black.output import out, err\n \n \n+def root_relative(path: Path, root: Optional[Path]) -> Path:\n+    if not root:\n+        return path\n+    return Path(os.path.relpath(path, start=Path(f\"{root}/../\")))",
      "comment": "The pathlib version is much cleaner to read as well, so maybe we should use it instead.",
      "comment_id": 766580769,
      "user": "felix-hilden",
      "created_at": "2021-12-10T10:49:41Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r766580769"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/__init__.py",
      "line": 536,
      "side": "RIGHT",
      "diff_hunk": "@@ -515,8 +520,21 @@ def get_sources(\n     stdin_filename: Optional[str],\n ) -> Set[Path]:\n     \"\"\"Compute the set of files to be formatted.\"\"\"\n+    root, method = find_project_root(src)\n+\n+    if verbose:\n+        if method:\n+            out(\n+                f\"Identified `{root}` as project root containing a {method}.\",\n+                fg=\"blue\",\n+            )\n+        else:\n+            out(f\"Identified `{root}` as project root.\", fg=\"blue\")\n+        paths = '\", \"'.join(\n+            str(Path(source).resolve().relative_to(root)) for source in src\n+        )\n+        out(f'Sources to be formatted: \"{paths}\"', fg=\"blue\")",
      "comment": "```suggestion\r\n        normalized_paths = [Path(source).resolve().relative_to(root) for source in src]\r\n        srcs_string = '\", \"'.join(normalized_paths)\r\n        out(f'Sources to be formatted: \"{srcs_string}\"', fg=\"blue\")\r\n```\r\nThis also makes it harder for future developers to mistake `paths` for `src`.",
      "comment_id": 770989813,
      "user": "ichard26",
      "created_at": "2021-12-16T23:26:36Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r770989813"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/files.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,14 +31,19 @@\n \n \n @lru_cache()\n-def find_project_root(srcs: Sequence[str]) -> Path:\n+def find_project_root(srcs: Sequence[str]) -> Tuple[Path, Optional[str]]:\n     \"\"\"Return a directory containing .git, .hg, or pyproject.toml.\n \n     That directory will be a common parent of all files and directories\n     passed in `srcs`.\n \n     If no directory in the tree contains a marker that would specify it's the\n     project root, the root of the file system is returned.\n+\n+    Returns a tuple with the first element as the project root path and the\n+    second element as a string which describes the method by which black\n+    found out the project root (None, if `None` of the registered method\n+    was used).",
      "comment": "```suggestion\r\n    Returns a two-tuple with the first element as the project root path and\r\n    the second element as a string describing the method by which the\r\n    project root was discovered (it will be None the fallback root was used).\r\n```",
      "comment_id": 770991843,
      "user": "ichard26",
      "created_at": "2021-12-16T23:31:33Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r770991843"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/__init__.py",
      "line": 535,
      "side": "RIGHT",
      "diff_hunk": "@@ -515,8 +520,21 @@ def get_sources(\n     stdin_filename: Optional[str],\n ) -> Set[Path]:\n     \"\"\"Compute the set of files to be formatted.\"\"\"\n+    root, method = find_project_root(src)\n+\n+    if verbose:\n+        if method:\n+            out(\n+                f\"Identified `{root}` as project root containing a {method}.\",\n+                fg=\"blue\",\n+            )\n+        else:\n+            out(f\"Identified `{root}` as project root.\", fg=\"blue\")\n+        paths = '\", \"'.join(\n+            str(Path(source).resolve().relative_to(root)) for source in src\n+        )",
      "comment": "Would it be worth it to guard this with a try... except? When we normalize path before applying the file discovery regexes (using `normalize_path_maybe_ignore`) we have be able to handle permission or out of tree exceptions gracefully and this code does none of that. Not sure how this would look but I'd prefer a defensive approach to our filepath handing code.",
      "comment_id": 770994800,
      "user": "ichard26",
      "created_at": "2021-12-16T23:39:24Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r770994800"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/__init__.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -410,8 +411,40 @@ def main(\n     config: Optional[str],\n ) -> None:\n     \"\"\"The uncompromising code formatter.\"\"\"\n-    if config and verbose:\n-        out(f\"Using configuration from {config}.\", bold=False, fg=\"blue\")\n+    ctx.ensure_object(dict)\n+    root, method = (None, None) if code is not None else find_project_root(src)",
      "comment": "```suggestion\r\n    root, method = find_project_root(src) if code is None else (None, None)\r\n```\r\nCould be clearer to go primary functionality first, but this is a minor thing.",
      "comment_id": 775399817,
      "user": "felix-hilden",
      "created_at": "2021-12-27T08:52:00Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r775399817"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/__init__.py",
      "line": 426,
      "side": "RIGHT",
      "diff_hunk": "@@ -410,8 +411,40 @@ def main(\n     config: Optional[str],\n ) -> None:\n     \"\"\"The uncompromising code formatter.\"\"\"\n-    if config and verbose:\n-        out(f\"Using configuration from {config}.\", bold=False, fg=\"blue\")\n+    ctx.ensure_object(dict)\n+    root, method = (None, None) if code is not None else find_project_root(src)\n+    ctx.obj[\"root\"] = root\n+\n+    if verbose:\n+        if root:\n+            if method:\n+                out(\n+                    f\"Identified `{root}` as project root containing a {method}.\",\n+                    fg=\"blue\",\n+                )\n+            else:\n+                out(f\"Identified `{root}` as project root.\", fg=\"blue\")",
      "comment": "Maybe we should always provide a method description to be clearer, see below.",
      "comment_id": 775400432,
      "user": "felix-hilden",
      "created_at": "2021-12-27T08:53:41Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r775400432"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/files.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,20 +62,20 @@ def find_project_root(srcs: Sequence[str]) -> Path:\n \n     for directory in (common_base, *common_base.parents):\n         if (directory / \".git\").exists():\n-            return directory\n+            return directory, \".git directory\"\n \n         if (directory / \".hg\").is_dir():\n-            return directory\n+            return directory, \".hg directory\"\n \n         if (directory / \"pyproject.toml\").is_file():\n-            return directory\n+            return directory, \"pyproject.toml\"\n \n-    return directory\n+    return directory, None",
      "comment": "```suggestion\r\n    return directory, \"file system root\"\r\n```\r\nIf this is the meaning and method, we should be clear about it.",
      "comment_id": 775400892,
      "user": "felix-hilden",
      "created_at": "2021-12-27T08:54:53Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r775400892"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/files.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,14 +31,18 @@\n \n \n @lru_cache()\n-def find_project_root(srcs: Sequence[str]) -> Path:\n+def find_project_root(srcs: Sequence[str]) -> Tuple[Path, Optional[str]]:",
      "comment": "```suggestion\r\ndef find_project_root(srcs: Sequence[str]) -> Tuple[Path, str]:\r\n```",
      "comment_id": 775402168,
      "user": "felix-hilden",
      "created_at": "2021-12-27T08:58:04Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r775402168"
    },
    {
      "repo": "psf/black",
      "pr_number": 2526,
      "file_path": "src/black/files.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,14 +31,18 @@\n \n \n @lru_cache()\n-def find_project_root(srcs: Sequence[str]) -> Path:\n+def find_project_root(srcs: Sequence[str]) -> Tuple[Path, Optional[str]]:\n     \"\"\"Return a directory containing .git, .hg, or pyproject.toml.\n \n     That directory will be a common parent of all files and directories\n     passed in `srcs`.\n \n     If no directory in the tree contains a marker that would specify it's the\n     project root, the root of the file system is returned.\n+\n+    Returns a two-tuple with the first element as the project root path and\n+    the second element as a string describing the method by which the\n+    project root was discovered (if it will be None the fallback root was used).",
      "comment": "```suggestion\r\n    project root was discovered.\r\n```",
      "comment_id": 775402312,
      "user": "felix-hilden",
      "created_at": "2021-12-27T08:58:24Z",
      "url": "https://github.com/psf/black/pull/2526#discussion_r775402312"
    },
    {
      "repo": "psf/black",
      "pr_number": 2712,
      "file_path": "src/black/__init__.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -494,6 +494,7 @@ def main(\n                 workers=workers,\n             )\n \n+    out()\n     if verbose or not quiet:\n         out(error_msg if report.return_code else \"All done! \u2728 \ud83c\udf70 \u2728\")",
      "comment": "```suggestion\r\n    if verbose or not quiet:\r\n        out()\r\n        out(error_msg if report.return_code else \"All done! \u2728 \ud83c\udf70 \u2728\")\r\n```\r\nSorry for being unclear, but we should only add the newline if we're gonna be emitting the summary anyway.",
      "comment_id": 773378719,
      "user": "ichard26",
      "created_at": "2021-12-21T19:06:05Z",
      "url": "https://github.com/psf/black/pull/2712#discussion_r773378719"
    },
    {
      "repo": "psf/black",
      "pr_number": 2712,
      "file_path": "src/black/__init__.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -494,6 +494,7 @@ def main(\n                 workers=workers,\n             )\n \n+    out()\n     if verbose or not quiet:\n         out(error_msg if report.return_code else \"All done! \u2728 \ud83c\udf70 \u2728\")",
      "comment": "Oh I apologize! That would be an oversight from me",
      "comment_id": 773379842,
      "user": "rahulgarg2002",
      "created_at": "2021-12-21T19:08:12Z",
      "url": "https://github.com/psf/black/pull/2712#discussion_r773379842"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,7 +136,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", s, re.DOTALL)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n+\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+    if len(new_prefix) == 2 and \"r\" != new_prefix[0].lower():",
      "comment": "Just double checking - There is never a chance of > 2 here right?\r\n\r\n- Also, lets set a const for 2 to explain it's value\r\n\r\nFeel free to pick a better name etc.\r\n```suggestion\r\n    TWO_CHAR_PREFIX_LEN = 2\r\n    if len(new_prefix) == TWO_CHAR_PREFIX_LEN and \"r\" != new_prefix[0].lower():\r\n```",
      "comment_id": 643218972,
      "user": "cooperlees",
      "created_at": "2021-06-01T15:35:19Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643218972"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,7 +136,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", s, re.DOTALL)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n+\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+    if len(new_prefix) == 2 and \"r\" != new_prefix[0].lower():",
      "comment": "Yeah about that, at least with Python 3 it's max 2. Never used Python 2 tho, but trying on an online interpreter, \"rb\" is invalid and \"f\" doesn't exist. \"ru\" and \"ub\" are also invalid. So we should be ok.\r\n\r\nI'll fight you a bit with adding the constant, if I may. Having \"two char prefix len\" be 2 is both a bit too obvious and not explaining enough in my opinion. Would `len(pf) > 1` or maybe a comment saying max 2 is guaranteed be better? I won't die on this hill though \ud83d\ude04 so feel free to just put your foot down.",
      "comment_id": 643229022,
      "user": "felix-hilden",
      "created_at": "2021-06-01T15:46:56Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643229022"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,7 +136,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", s, re.DOTALL)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n+\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+    if len(new_prefix) == 2 and \"r\" != new_prefix[0].lower():",
      "comment": "I also don't care enough to fight this. I've just always found it easier to come back to code with consts explaining a naked integer years / even weeks later. Happy with this if other maintainers are.",
      "comment_id": 643235138,
      "user": "cooperlees",
      "created_at": "2021-06-01T15:54:15Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643235138"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,7 +136,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", s, re.DOTALL)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n+\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+    if len(new_prefix) == 2 and \"r\" != new_prefix[0].lower():",
      "comment": "Added a comment there explaining it a bit more, that is definitely appropriate and enables a more verbose explanation. Will add the const if others also agree!",
      "comment_id": 643237805,
      "user": "felix-hilden",
      "created_at": "2021-06-01T15:57:21Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643237805"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,7 +136,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", s, re.DOTALL)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n+\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+    if len(new_prefix) == 2 and \"r\" != new_prefix[0].lower():",
      "comment": "2 Seems to be the max according to the lexical analysis page on both versions.\r\nI think a comment would be best here, as a var name won't imo explain why it's two without being overly verbose.\r\n\r\nWhile not directly related, is there any reason for the yoda condition? `... new_prefix[0].lower() != \"r\"` reads better to me",
      "comment_id": 643239335,
      "user": "Numerlor",
      "created_at": "2021-06-01T15:59:09Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643239335"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,7 +136,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", s, re.DOTALL)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n+\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+    if len(new_prefix) == 2 and \"r\" != new_prefix[0].lower():",
      "comment": "I guess \"r is not the first prefix char\" seemed more intuitive for me when writing it, but it could be \"the first char is not r\" just as well! Also, getting to the point faster by \"r != something\" than \"a bunch of stuff != r\".",
      "comment_id": 643241206,
      "user": "felix-hilden",
      "created_at": "2021-06-01T16:01:40Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643241206"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "tests/data/python2.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,10 +5,11 @@\n print >> sys.stderr , \"Warning:\" ,\n print >> sys.stderr , \"this is a blast from the past.\"\n print >> sys.stderr , \"Look, a repr:\", `sys`\n+print >> sys.stderr , U\"Even these prefixes are normalized!\"\n \n \n def function((_globals, _locals)):\n-    exec ur\"print 'hi from exec!'\" in _globals, _locals\n+    exec \"print 'hi from exec!'\" in _globals, _locals",
      "comment": "Oh wow. \"ru\" is invalid but \"ur\" isn't? \ud83d\ude05 Good catch. Let me go through the others once more.",
      "comment_id": 643252907,
      "user": "felix-hilden",
      "created_at": "2021-06-01T16:16:39Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643252907"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "tests/data/python2.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,10 +5,11 @@\n print >> sys.stderr , \"Warning:\" ,\n print >> sys.stderr , \"this is a blast from the past.\"\n print >> sys.stderr , \"Look, a repr:\", `sys`\n+print >> sys.stderr , U\"Even these prefixes are normalized!\"\n \n \n def function((_globals, _locals)):\n-    exec ur\"print 'hi from exec!'\" in _globals, _locals\n+    exec \"print 'hi from exec!'\" in _globals, _locals",
      "comment": "\"br\" is valid and \"rb\" invalid. Well. This is a bummer. They go exactly against the rule. Should we go with \"r last\" after all?",
      "comment_id": 643255402,
      "user": "felix-hilden",
      "created_at": "2021-06-01T16:20:11Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643255402"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "tests/data/python2.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,10 +5,11 @@\n print >> sys.stderr , \"Warning:\" ,\n print >> sys.stderr , \"this is a blast from the past.\"\n print >> sys.stderr , \"Look, a repr:\", `sys`\n+print >> sys.stderr , U\"Even these prefixes are normalized!\"\n \n \n def function((_globals, _locals)):\n-    exec ur\"print 'hi from exec!'\" in _globals, _locals\n+    exec \"print 'hi from exec!'\" in _globals, _locals",
      "comment": "Oh you're right. And in Python 3 they're both invalid. ",
      "comment_id": 643255825,
      "user": "JelleZijlstra",
      "created_at": "2021-06-01T16:20:43Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643255825"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "tests/data/python2.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,10 +5,11 @@\n print >> sys.stderr , \"Warning:\" ,\n print >> sys.stderr , \"this is a blast from the past.\"\n print >> sys.stderr , \"Look, a repr:\", `sys`\n+print >> sys.stderr , U\"Even these prefixes are normalized!\"\n \n \n def function((_globals, _locals)):\n-    exec ur\"print 'hi from exec!'\" in _globals, _locals\n+    exec \"print 'hi from exec!'\" in _globals, _locals",
      "comment": "Yeah \"u\" with anything else seems to be invalid, but \"br\" naturally works.",
      "comment_id": 643257397,
      "user": "felix-hilden",
      "created_at": "2021-06-01T16:22:42Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643257397"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "tests/data/python2.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,10 +5,11 @@\n print >> sys.stderr , \"Warning:\" ,\n print >> sys.stderr , \"this is a blast from the past.\"\n print >> sys.stderr , \"Look, a repr:\", `sys`\n+print >> sys.stderr , U\"Even these prefixes are normalized!\"\n \n \n def function((_globals, _locals)):\n-    exec ur\"print 'hi from exec!'\" in _globals, _locals\n+    exec \"print 'hi from exec!'\" in _globals, _locals",
      "comment": "Sorry that comment was in reference to `ru` not `rb`.\r\n\r\nIn summary:\r\n- Python 3 allows `rb`, `br`, but not `ur` or `ru`\r\n- Python 2 allows `br` and `ur` but not `rb` or `ru`",
      "comment_id": 643258684,
      "user": "JelleZijlstra",
      "created_at": "2021-06-01T16:24:32Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643258684"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "tests/data/python2.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,10 +5,11 @@\n print >> sys.stderr , \"Warning:\" ,\n print >> sys.stderr , \"this is a blast from the past.\"\n print >> sys.stderr , \"Look, a repr:\", `sys`\n+print >> sys.stderr , U\"Even these prefixes are normalized!\"\n \n \n def function((_globals, _locals)):\n-    exec ur\"print 'hi from exec!'\" in _globals, _locals\n+    exec \"print 'hi from exec!'\" in _globals, _locals",
      "comment": "I commented on the original issue and marked this PR as a draft. We ought to discuss it through before merging anything.",
      "comment_id": 643261178,
      "user": "felix-hilden",
      "created_at": "2021-06-01T16:26:45Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643261178"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,7 +136,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", s, re.DOTALL)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n+\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+    if len(new_prefix) == 2 and \"r\" != new_prefix[0].lower():",
      "comment": "What about some logic along the lines of \"if there's an r in the prefix, then move it to the front\" which will also work for future multi-character prefixes? You could also put the rest of the prefix in alphabetical order at the same time for future consistency. Might be gold-plating though.",
      "comment_id": 643467154,
      "user": "jamesmyatt",
      "created_at": "2021-06-01T20:46:13Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643467154"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,7 +136,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     match = re.match(r\"^([\" + STRING_PREFIX_CHARS + r\"]*)(.*)$\", s, re.DOTALL)\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n+\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+    if len(new_prefix) == 2 and \"r\" != new_prefix[0].lower():",
      "comment": "Yeah, reversing is essentially a shorthand in that case. I don't expect many more prefixes to be added so I just left it at that. Are there any on the horizon? If not, I'd say it's just making it too fancy, although strictly correct \ud83d\ude04",
      "comment_id": 643867736,
      "user": "felix-hilden",
      "created_at": "2021-06-02T11:27:32Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r643867736"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +137,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+\n+    # Python syntax guarantees max 2 prefixes and that one of them is \"r\"\n+    if len(new_prefix) == 2 and \"r\" == new_prefix[0].lower():\n+        new_prefix = new_prefix[::-1]",
      "comment": "Sadly `sorted` isn't quite enough here because of `ur` and capital Rs :/",
      "comment_id": 645116953,
      "user": "felix-hilden",
      "created_at": "2021-06-03T20:50:50Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r645116953"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +137,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+\n+    # Python syntax guarantees max 2 prefixes and that one of them is \"r\"\n+    if len(new_prefix) == 2 and \"r\" == new_prefix[0].lower():",
      "comment": "And technically the first condition is redundant, but I like it because it clarifies the meaning.",
      "comment_id": 645129717,
      "user": "felix-hilden",
      "created_at": "2021-06-03T21:14:24Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r645129717"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "tests/data/string_prefixes.py",
      "line": 3,
      "side": "LEFT",
      "diff_hunk": "@@ -1,18 +1,24 @@\n-#!/usr/bin/env python3.6\n+#!/usr/bin/env python3\n \n-name = R\"\u0141ukasz\"",
      "comment": "Just for reducing a redundant test, since all the prefixes are tested below! I thought about removing it altogether, but seems fine to test f-string substitution there at least. Would you like to keep it?",
      "comment_id": 646625180,
      "user": "felix-hilden",
      "created_at": "2021-06-07T14:11:25Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r646625180"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +137,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+\n+    # Python syntax guarantees max 2 prefixes and that one of them is \"r\"\n+    if len(new_prefix) == 2 and \"r\" == new_prefix[0].lower():\n+        new_prefix = new_prefix[::-1]",
      "comment": "Could use a key like this with `sorted`, I think it's nicer than the reverse but I'm not sure if it reads better overall.\r\n```py\r\nnew_prefix = \"\".join(sorted(new_prefix, key=\"fubrR\".index))\r\n```\r\n`STRING_PREFIX_CHARS` could also be reordered to be used as the index string",
      "comment_id": 647388771,
      "user": "Numerlor",
      "created_at": "2021-06-08T12:26:22Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r647388771"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +137,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+\n+    # Python syntax guarantees max 2 prefixes and that one of them is \"r\"\n+    if len(new_prefix) == 2 and \"r\" == new_prefix[0].lower():\n+        new_prefix = new_prefix[::-1]",
      "comment": "That could actually be quite fun \ud83d\ude04 but with #2251 we are still second guessing the decisions, so this is a bit blocked.",
      "comment_id": 647410439,
      "user": "felix-hilden",
      "created_at": "2021-06-08T12:53:49Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r647410439"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +137,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+\n+    # Python syntax guarantees max 2 prefixes and that one of them is \"r\"\n+    if len(new_prefix) == 2 and \"r\" == new_prefix[0].lower():\n+        new_prefix = new_prefix[::-1]",
      "comment": "https://github.com/psf/black/pull/2740 has been merged now",
      "comment_id": 783812539,
      "user": "jamesmyatt",
      "created_at": "2022-01-13T10:11:07Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r783812539"
    },
    {
      "repo": "psf/black",
      "pr_number": 2297,
      "file_path": "src/black/strings.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +137,10 @@ def normalize_string_prefix(s: str, remove_u_prefix: bool = False) -> str:\n     assert match is not None, f\"failed to match string {s!r}\"\n     orig_prefix = match.group(1)\n     new_prefix = orig_prefix.replace(\"F\", \"f\").replace(\"B\", \"b\").replace(\"U\", \"u\")\n+\n+    # Python syntax guarantees max 2 prefixes and that one of them is \"r\"\n+    if len(new_prefix) == 2 and \"r\" == new_prefix[0].lower():",
      "comment": "Also it short circuits the (likely) more complex subscript and `.lower`.",
      "comment_id": 784075595,
      "user": "felix-hilden",
      "created_at": "2022-01-13T15:37:11Z",
      "url": "https://github.com/psf/black/pull/2297#discussion_r784075595"
    },
    {
      "repo": "psf/black",
      "pr_number": 2760,
      "file_path": "tests/data/pattern_matching_style.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +10,60 @@\n     ): print(2)\n     case a: pass\n \n+match(\n+    arg # comment\n+)\n+\n+match(\n+)\n+\n+match(\n+\n+\n+)\n+\n+case(\n+    arg # comment\n+)\n+\n+case(\n+)\n+\n+case(\n+\n+\n+)\n+\n+\n+match something:\n+    case b(): print(1+1)\n+    case c(\n+        very_complex=True,\n+        perhaps_even_loooooooooooooooooooooooooooooooooooooong=-   1\n+    ): print(1)\n+    case c(\n+        very_complex=True,\n+        perhaps_even_loooooooooooooooooooooooooooooooooooooong=-1",
      "comment": "Maybe add a trailing comma here just to see that it interacts correctly with the magic trailing comma\r\n```suggestion\r\n        perhaps_even_loooooooooooooooooooooooooooooooooooooong=-1,\r\n```",
      "comment_id": 781503157,
      "user": "JelleZijlstra",
      "created_at": "2022-01-10T19:52:32Z",
      "url": "https://github.com/psf/black/pull/2760#discussion_r781503157"
    },
    {
      "repo": "psf/black",
      "pr_number": 2760,
      "file_path": "tests/data/pattern_matching_style.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +10,60 @@\n     ): print(2)\n     case a: pass\n \n+match(\n+    arg # comment\n+)\n+\n+match(\n+)\n+\n+match(\n+\n+\n+)\n+\n+case(\n+    arg # comment\n+)\n+\n+case(\n+)\n+\n+case(\n+\n+\n+)\n+\n+\n+match something:\n+    case b(): print(1+1)\n+    case c(\n+        very_complex=True,\n+        perhaps_even_loooooooooooooooooooooooooooooooooooooong=-   1\n+    ): print(1)\n+    case c(\n+        very_complex=True,\n+        perhaps_even_loooooooooooooooooooooooooooooooooooooong=-1",
      "comment": "That'll probably need a change in the output as well, will commit separately. Thanks!\r\n",
      "comment_id": 781504014,
      "user": "isidentical",
      "created_at": "2022-01-10T19:53:51Z",
      "url": "https://github.com/psf/black/pull/2760#discussion_r781504014"
    },
    {
      "repo": "psf/black",
      "pr_number": 2728,
      "file_path": "src/blib2to3/pgen2/parse.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,21 +65,45 @@ def __init__(self, parser: \"Parser\", ilabels: List[int], context: Context) -> No\n \n         self._dead_ilabels: Set[int] = set()\n         self._start_point = self.parser.stack\n-        self._points = {ilabel: copy.deepcopy(self._start_point) for ilabel in ilabels}\n+        self._points = {ilabel: stack_copy(self._start_point) for ilabel in ilabels}\n \n     @property\n     def ilabels(self) -> Set[int]:\n         return self._dead_ilabels.symmetric_difference(self._ilabels)\n \n     @contextmanager\n     def switch_to(self, ilabel: int) -> Iterator[None]:\n-        self.parser.stack = self._points[ilabel]\n+        with self.patch():\n+            self.parser.stack = self._points[ilabel]\n+            try:\n+                yield\n+            except ParseError:\n+                self._dead_ilabels.add(ilabel)\n+            finally:\n+                self.parser.stack = self._start_point\n+\n+    @contextmanager\n+    def patch(self) -> Iterator[None]:\n+        \"\"\"\n+        Patch basic state operations (push/pop/shift) with node-level\n+        immutable variants. These still will operate on the stack; but\n+        they won't create any new nodes, or modify the contents of any\n+        other existing nodes.\n+\n+        This saves us a ton of time when we are backtracking, since we\n+        want to restore to the initial state as quick as possible, which\n+        can only be done by having as little mutatations as possible.\n+        \"\"\"\n+        original_functions = {}\n+        for name in self.parser.STATE_OPERATIONS:\n+            original_functions[name] = getattr(self.parser, name)\n+            safe_variant = getattr(self.parser, name + \"_safe\")\n+            setattr(self.parser, name, safe_variant)",
      "comment": "I was unsure about this one, but at worst we can simply merge the implementations of the safe/unsafe and guard the safe one with a flag like `parser.is_safe = True`. CC: @ichard26 ",
      "comment_id": 780388739,
      "user": "isidentical",
      "created_at": "2022-01-07T16:45:37Z",
      "url": "https://github.com/psf/black/pull/2728#discussion_r780388739"
    },
    {
      "repo": "psf/black",
      "pr_number": 2728,
      "file_path": "src/blib2to3/pgen2/parse.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,21 +65,41 @@ def __init__(self, parser: \"Parser\", ilabels: List[int], context: Context) -> No\n \n         self._dead_ilabels: Set[int] = set()\n         self._start_point = self.parser.stack\n-        self._points = {ilabel: copy.deepcopy(self._start_point) for ilabel in ilabels}\n+        self._points = {ilabel: stack_copy(self._start_point) for ilabel in ilabels}\n \n     @property\n     def ilabels(self) -> Set[int]:\n         return self._dead_ilabels.symmetric_difference(self._ilabels)\n \n     @contextmanager\n     def switch_to(self, ilabel: int) -> Iterator[None]:\n-        self.parser.stack = self._points[ilabel]\n+        with self.patch():\n+            self.parser.stack = self._points[ilabel]\n+            try:\n+                yield\n+            except ParseError:\n+                self._dead_ilabels.add(ilabel)\n+            finally:\n+                self.parser.stack = self._start_point\n+\n+    @contextmanager\n+    def patch(self) -> Iterator[None]:",
      "comment": "Can you rename this to something like `with self.backtrack():`?",
      "comment_id": 781419640,
      "user": "JelleZijlstra",
      "created_at": "2022-01-10T17:55:26Z",
      "url": "https://github.com/psf/black/pull/2728#discussion_r781419640"
    },
    {
      "repo": "psf/black",
      "pr_number": 2728,
      "file_path": "src/blib2to3/pgen2/parse.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,21 +65,41 @@ def __init__(self, parser: \"Parser\", ilabels: List[int], context: Context) -> No\n \n         self._dead_ilabels: Set[int] = set()\n         self._start_point = self.parser.stack\n-        self._points = {ilabel: copy.deepcopy(self._start_point) for ilabel in ilabels}\n+        self._points = {ilabel: stack_copy(self._start_point) for ilabel in ilabels}\n \n     @property\n     def ilabels(self) -> Set[int]:\n         return self._dead_ilabels.symmetric_difference(self._ilabels)\n \n     @contextmanager\n     def switch_to(self, ilabel: int) -> Iterator[None]:\n-        self.parser.stack = self._points[ilabel]\n+        with self.patch():\n+            self.parser.stack = self._points[ilabel]\n+            try:\n+                yield\n+            except ParseError:\n+                self._dead_ilabels.add(ilabel)\n+            finally:\n+                self.parser.stack = self._start_point\n+\n+    @contextmanager\n+    def patch(self) -> Iterator[None]:\n+        \"\"\"\n+        Patch basic state operations (push/pop/shift) with node-level",
      "comment": "Should be reworded to remove mention of \"patching\"",
      "comment_id": 781419887,
      "user": "JelleZijlstra",
      "created_at": "2022-01-10T17:55:44Z",
      "url": "https://github.com/psf/black/pull/2728#discussion_r781419887"
    },
    {
      "repo": "psf/black",
      "pr_number": 2705,
      "file_path": "tests/test_no_ipynb.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,14 +22,14 @@ def test_ipynb_diff_with_no_change_single() -> None:\n     assert expected_output in result.output\n \n \n-def test_ipynb_diff_with_no_change_dir(tmpdir: tmpdir) -> None:\n+def test_ipynb_diff_with_no_change_dir(tmp_path: tmp_path) -> None:",
      "comment": "The `tmp_path` value is a `pathlib.Path`, so this should be\r\n\r\n```suggestion\r\ndef test_ipynb_diff_with_no_change_dir(tmp_path: pathlib.Path) -> None:\r\n```",
      "comment_id": 771329345,
      "user": "bluetech",
      "created_at": "2021-12-17T11:37:45Z",
      "url": "https://github.com/psf/black/pull/2705#discussion_r771329345"
    },
    {
      "repo": "psf/black",
      "pr_number": 2705,
      "file_path": "tests/test_ipynb.py",
      "line": 417,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,52 +371,52 @@ def test_ipynb_diff_with_no_change() -> None:\n \n \n def test_cache_isnt_written_if_no_jupyter_deps_single(\n-    monkeypatch: MonkeyPatch, tmpdir: local\n+    monkeypatch: MonkeyPatch, tmp_path: local\n ) -> None:\n     # Check that the cache isn't written to if Jupyter dependencies aren't installed.\n     jupyter_dependencies_are_installed.cache_clear()\n     nb = DATA_DIR / \"notebook_trailing_newline.ipynb\"\n-    tmp_nb = tmpdir / \"notebook.ipynb\"\n+    tmp_nb = tmp_path / \"notebook.ipynb\"\n     with open(nb) as src, open(tmp_nb, \"w\") as dst:\n         dst.write(src.read())\n     monkeypatch.setattr(\n         \"black.jupyter_dependencies_are_installed\", lambda verbose, quiet: False\n     )\n-    result = runner.invoke(main, [str(tmpdir / \"notebook.ipynb\")])\n+    result = runner.invoke(main, [str(tmp_path / \"notebook.ipynb\")])\n     assert \"No Python files are present to be formatted. Nothing to do\" in result.output\n     jupyter_dependencies_are_installed.cache_clear()\n     monkeypatch.setattr(\n         \"black.jupyter_dependencies_are_installed\", lambda verbose, quiet: True\n     )\n-    result = runner.invoke(main, [str(tmpdir / \"notebook.ipynb\")])\n+    result = runner.invoke(main, [str(tmp_path / \"notebook.ipynb\")])\n     assert \"reformatted\" in result.output\n \n \n def test_cache_isnt_written_if_no_jupyter_deps_dir(\n-    monkeypatch: MonkeyPatch, tmpdir: local\n+    monkeypatch: MonkeyPatch, tmp_path: local\n ) -> None:\n     # Check that the cache isn't written to if Jupyter dependencies aren't installed.\n     jupyter_dependencies_are_installed.cache_clear()\n     nb = DATA_DIR / \"notebook_trailing_newline.ipynb\"\n-    tmp_nb = tmpdir / \"notebook.ipynb\"\n+    tmp_nb = tmp_path / \"notebook.ipynb\"\n     with open(nb) as src, open(tmp_nb, \"w\") as dst:\n         dst.write(src.read())\n     monkeypatch.setattr(\n         \"black.files.jupyter_dependencies_are_installed\", lambda verbose, quiet: False\n     )\n-    result = runner.invoke(main, [str(tmpdir)])\n+    result = runner.invoke(main, [str(tmp_path)])\n     assert \"No Python files are present to be formatted. Nothing to do\" in result.output\n     jupyter_dependencies_are_installed.cache_clear()\n     monkeypatch.setattr(\n         \"black.files.jupyter_dependencies_are_installed\", lambda verbose, quiet: True\n     )\n-    result = runner.invoke(main, [str(tmpdir)])\n+    result = runner.invoke(main, [str(tmp_path)])\n     assert \"reformatted\" in result.output\n \n \n-def test_ipynb_flag(tmpdir: local) -> None:\n+def test_ipynb_flag(tmp_path: local) -> None:",
      "comment": "```suggestion\r\ndef test_ipynb_flag(tmp_path: pathlib.Path) -> None:\r\n```",
      "comment_id": 771330574,
      "user": "bluetech",
      "created_at": "2021-12-17T11:39:46Z",
      "url": "https://github.com/psf/black/pull/2705#discussion_r771330574"
    },
    {
      "repo": "psf/black",
      "pr_number": 2705,
      "file_path": "tests/optional.py",
      "line": 24,
      "side": "LEFT",
      "diff_hunk": "@@ -21,7 +21,12 @@\n from typing import FrozenSet, List, Set, TYPE_CHECKING\n \n import pytest\n-from _pytest.store import StoreKey",
      "comment": "Additionally it would be good to replace uses of `_store` with `stash`. The former still works but will probably be removed at some point.",
      "comment_id": 771331050,
      "user": "bluetech",
      "created_at": "2021-12-17T11:40:37Z",
      "url": "https://github.com/psf/black/pull/2705#discussion_r771331050"
    },
    {
      "repo": "psf/black",
      "pr_number": 2678,
      "file_path": "src/black/__init__.py",
      "line": 181,
      "side": "RIGHT",
      "diff_hunk": "@@ -177,8 +177,8 @@ def validate_regex(\n ) -> Optional[Pattern[str]]:\n     try:\n         return re_compile_maybe_verbose(value) if value is not None else None\n-    except re.error:\n-        raise click.BadParameter(\"Not a valid regular expression\") from None\n+    except re.error as e:\n+        raise click.BadParameter(f\"Not a valid regular expression: {e}\") from None",
      "comment": "Example output:\r\n```\r\nError: Invalid value for '--exclude': Not a valid regular expression: bad escape \\e at position 71 (line 7, column 5)\r\n```",
      "comment_id": 764112833,
      "user": "JelleZijlstra",
      "created_at": "2021-12-07T15:33:19Z",
      "url": "https://github.com/psf/black/pull/2678#discussion_r764112833"
    },
    {
      "repo": "psf/black",
      "pr_number": 2343,
      "file_path": "src/black/parsing.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +93,16 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n             except IndexError:\n                 faulty_line = \"<line number missing in source>\"\n             exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+\n+        except TokenError as te:\n+            lineno, column = te.args[1]\n+            lines = src_txt.splitlines()\n+            try:\n+                faulty_line = lines[lineno - 1]\n+            except IndexError:\n+                faulty_line = \"<line number missing in source>\"\n+            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+",
      "comment": "I have tried to keep the format consistent with ParseError above but still need to correct the values for lineno,column and faulty_line (which are currently wrong)",
      "comment_id": 654947777,
      "user": "tanvimoharir",
      "created_at": "2021-06-20T14:58:56Z",
      "url": "https://github.com/psf/black/pull/2343#discussion_r654947777"
    },
    {
      "repo": "psf/black",
      "pr_number": 2343,
      "file_path": "src/black/parsing.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +93,16 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n             except IndexError:\n                 faulty_line = \"<line number missing in source>\"\n             exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+\n+        except TokenError as te:\n+            lineno, column = te.args[1]\n+            lines = src_txt.splitlines()\n+            try:\n+                faulty_line = lines[lineno - 1]\n+            except IndexError:\n+                faulty_line = \"<line number missing in source>\"\n+            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+",
      "comment": "I think we can do without the duplication of code by conditionalizing (made that up right now :p) the lineno. and col. information extraction code. So in the end it would look something like this (warning: untested):\r\n\r\n```python\r\n        try:\r\n            result = drv.parse_string(src_txt, True)\r\n            break\r\n\r\n        except (ParseError, TokenError) as err:\r\n            if isinstance(err, ParseError):\r\n                lineno, column = err.context[1]\r\n            else:\r\n                lineno, column = err.args[1]\r\n\r\n            lines = src_txt.splitlines()\r\n            try:\r\n                faulty_line = lines[lineno - 1]\r\n            except IndexError:\r\n                faulty_line = \"<line number missing in source>\"\r\n            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\r\n```\r\n",
      "comment_id": 655740470,
      "user": "ichard26",
      "created_at": "2021-06-21T22:19:12Z",
      "url": "https://github.com/psf/black/pull/2343#discussion_r655740470"
    },
    {
      "repo": "psf/black",
      "pr_number": 2343,
      "file_path": "src/black/parsing.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +93,16 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n             except IndexError:\n                 faulty_line = \"<line number missing in source>\"\n             exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+\n+        except TokenError as te:\n+            lineno, column = te.args[1]\n+            lines = src_txt.splitlines()\n+            try:\n+                faulty_line = lines[lineno - 1]\n+            except IndexError:\n+                faulty_line = \"<line number missing in source>\"\n+            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+",
      "comment": "Thanks I will try this. I had initially thought of making changes here https://github.com/psf/black/blob/main/src/blib2to3/pgen2/tokenize.py#L177",
      "comment_id": 656393962,
      "user": "tanvimoharir",
      "created_at": "2021-06-22T16:32:47Z",
      "url": "https://github.com/psf/black/pull/2343#discussion_r656393962"
    },
    {
      "repo": "psf/black",
      "pr_number": 2343,
      "file_path": "src/black/parsing.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -84,14 +85,18 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n             result = drv.parse_string(src_txt, True)\n             break\n \n-        except ParseError as pe:\n-            lineno, column = pe.context[1]\n+        except (TokenError, ParseError) as err:\n+            if isinstance(err, ParseError):\n+                lineno, column = err.context[1]\n+            else:\n+                lineno, column = err.args[1]",
      "comment": "I'm trying to understand why i'm getting linenumber value as 2 for token error:\r\n```\r\n(black) bash-3.2$ python -m src.black --check --code \"print(\"\r\nerror: cannot format <string>: Cannot parse: 2:0: <line number missing in source>\r\n(black) bash-3.2$ python -m src.black --check --code \"print([)\" \r\nerror: cannot format <string>: Cannot parse: 1:7: print([)\r\n```",
      "comment_id": 658632079,
      "user": "tanvimoharir",
      "created_at": "2021-06-25T09:36:20Z",
      "url": "https://github.com/psf/black/pull/2343#discussion_r658632079"
    },
    {
      "repo": "psf/black",
      "pr_number": 2343,
      "file_path": "src/black/parsing.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -84,14 +85,18 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n             result = drv.parse_string(src_txt, True)\n             break\n \n-        except ParseError as pe:\n-            lineno, column = pe.context[1]\n+        except (TokenError, ParseError) as err:\n+            if isinstance(err, ParseError):\n+                lineno, column = err.context[1]\n+            else:\n+                lineno, column = err.args[1]",
      "comment": "Yeahhh that seems to be a bug with the blib2to3 library. We can just ignore that for this PR, it's better if we can just get this landed so while the error message won't be perfect, it should be better than `error: cannot format <string>: ('EOF in multi-line statement', (2, 0))` :)\r\n\r\nAlthough a problem is that the source isn't printed at all which is unfortunate since it would be quite useful. Perhaps it would be good to also include that it was an \"unexpected EOF\" error in the message?\r\n\r\nGood catch tho!",
      "comment_id": 669817450,
      "user": "ichard26",
      "created_at": "2021-07-14T17:33:26Z",
      "url": "https://github.com/psf/black/pull/2343#discussion_r669817450"
    },
    {
      "repo": "psf/black",
      "pr_number": 2343,
      "file_path": "src/black/parsing.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +93,12 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n             except IndexError:\n                 faulty_line = \"<line number missing in source>\"\n             exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+\n+        except TokenError as te:\n+            lineno, column = te.args[1]\n+            lines = src_txt.splitlines()\n+            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: Unexpected EOF\")\n+",
      "comment": "I included it as a separate block since that seemed more readable to me instead of adding multiple if (isintance,TokenError) in the above block where we're handling ParseError",
      "comment_id": 674107096,
      "user": "tanvimoharir",
      "created_at": "2021-07-21T15:49:22Z",
      "url": "https://github.com/psf/black/pull/2343#discussion_r674107096"
    },
    {
      "repo": "psf/black",
      "pr_number": 2343,
      "file_path": "src/black/parsing.py",
      "line": 100,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +93,12 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n             except IndexError:\n                 faulty_line = \"<line number missing in source>\"\n             exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+\n+        except TokenError as te:\n+            lineno, column = te.args[1]\n+            lines = src_txt.splitlines()\n+            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: Unexpected EOF\")",
      "comment": "The `lines = src_txt.splitlines()` line is unnecessary now.",
      "comment_id": 687318097,
      "user": "ichard26",
      "created_at": "2021-08-12T02:18:32Z",
      "url": "https://github.com/psf/black/pull/2343#discussion_r687318097"
    },
    {
      "repo": "psf/black",
      "pr_number": 2343,
      "file_path": "src/black/parsing.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +93,12 @@ def lib2to3_parse(src_txt: str, target_versions: Iterable[TargetVersion] = ()) -\n             except IndexError:\n                 faulty_line = \"<line number missing in source>\"\n             exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n+\n+        except TokenError as te:\n+            lineno, column = te.args[1]\n+            lines = src_txt.splitlines()\n+            exc = InvalidInput(f\"Cannot parse: {lineno}:{column}: Unexpected EOF\")\n+",
      "comment": "Fair enough, I agree the duplication isn't a problem here.",
      "comment_id": 687318386,
      "user": "ichard26",
      "created_at": "2021-08-12T02:19:32Z",
      "url": "https://github.com/psf/black/pull/2343#discussion_r687318386"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,37 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n+    if (3, 8) <= version < (4, 0):\n+        return ast.parse(src, filename, feature_version=version)\n+    elif version >= (3, 6):",
      "comment": "Also, target versions include Pythons all the way from 3.3. Should they be here (and in the version list below) too?",
      "comment_id": 645104182,
      "user": "felix-hilden",
      "created_at": "2021-06-03T20:28:11Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r645104182"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,37 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n+    if (3, 8) <= version < (4, 0):\n+        return ast.parse(src, filename, feature_version=version)\n+    elif version >= (3, 6):",
      "comment": "Looks like the previous behavior was mistakenly parsing 3.3-3.5 with ast27. And if it was somehow deliberate the logic fails to explain it so let's remove that special case and try to parse 3.3-3.5 like you're suggesting. Good find!",
      "comment_id": 648697472,
      "user": "ambv",
      "created_at": "2021-06-09T21:28:53Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r648697472"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,37 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n+    if (3, 8) <= version < (4, 0):\n+        return ast.parse(src, filename, feature_version=version)\n+    elif version >= (3, 6):",
      "comment": "I had to go and verify myself how the versions were parsed again. Here's a summary and new versions we'd like to have:\r\n```\r\ntyped | sysver | parsed                              | new parsed\r\n-----------------------------------------------------------------------\r\n yes  | >= 3.8 | ast: sysver down to 3.5, typed: 2.7 | ast: sysver down to 3.3, typed: 2.7\r\n yes  |  < 3.8 | typed: 3.7, 3.6, 2.7                | typed: 3.7 down to 3.3, 2.7\r\n  no  | >= 3.8 | ast: sysver down to 3.5             | ast: sysver down to 3.3\r\n  no  |  < 3.8 | error on import\r\n```\r\nSo what I've understood is that the builtin ast is good for all versions except 2.7 if we're above 3.8, but below it we need `typed_ast`. I think I understood it differently when I first refactored, so I'll change it if I get a nod of approval that this time around it's solid \ud83d\ude04 Thanks for the patience!",
      "comment_id": 648924096,
      "user": "felix-hilden",
      "created_at": "2021-06-10T07:32:05Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r648924096"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,37 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n+    if (3, 8) <= version < (4, 0):\n+        return ast.parse(src, filename, feature_version=version)\n+    elif version >= (3, 6):",
      "comment": "Also: would we like to tie the parsed version to target versions? I.e. when we add or remove something from the enumeration, we won't have to change this part of the code.",
      "comment_id": 648927276,
      "user": "felix-hilden",
      "created_at": "2021-06-10T07:36:40Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r648927276"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,37 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n+    if (3, 8) <= version < (4, 0):\n+        return ast.parse(src, filename, feature_version=version)\n+    elif version >= (3, 6):",
      "comment": "IIRC we need typed_ast for <3.8 because the built-in `ast` module has limited feature_version support. In other words, using `ast` <3.8 would force Black to be able to only parse using the grammar of the runtime version. I'm not entirely sure though, I would strongly encourage either putting this information in a comment or the dev documentation because it's been like a year of me being here and I still don't 100% understand this area (for more info see [this bpo issue](https://bugs.python.org/issue35766)).",
      "comment_id": 650330405,
      "user": "ichard26",
      "created_at": "2021-06-12T01:55:59Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r650330405"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,37 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n+    if (3, 8) <= version < (4, 0):\n+        return ast.parse(src, filename, feature_version=version)\n+    elif version >= (3, 6):",
      "comment": "Also, apparently `ast` and `typed_ast` have feature_version minimums of (3, 4): \r\n\r\n> The lowest supported version is (3, 4); the highest is sys.version_info[0:2].\r\n\r\nhttps://docs.python.org/3/library/ast.html#ast.parse\r\n\r\n> Currently only fully supported for Python 3.5+ with partial support for Python 3.4. So, feature_version=3 or less are all equivalent to feature_version=4.\r\n\r\nhttps://github.com/python/typed_ast/blob/8eed936014f81a55a3e17310629c40c0203327c3/typed_ast/ast3.py#L50-L54\r\n\r\nThe good news is that it really doesn't matter since 3.3 and 3.4 seem to be practically the same syntax / grammar wise:\r\nhttps://github.com/psf/black/blob/aa31a117b16ed849710cf13cea5c064839beb29e/src/black/mode.py#L47-L48",
      "comment_id": 650330908,
      "user": "ichard26",
      "created_at": "2021-06-12T02:01:46Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r650330908"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,37 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n+    if (3, 8) <= version < (4, 0):\n+        return ast.parse(src, filename, feature_version=version)\n+    elif version >= (3, 6):",
      "comment": "That makes sense, thank you! I'll shoot changes later today and hopefully we can get this forward!",
      "comment_id": 650487234,
      "user": "felix-hilden",
      "created_at": "2021-06-13T08:03:06Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r650487234"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,37 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n+    if (3, 8) <= version < (4, 0):\n+        return ast.parse(src, filename, feature_version=version)\n+    elif version >= (3, 6):",
      "comment": "Seems like the builting `ast` also accepts feature versions below 3.4 as long as they are above 3. Also, I didn't link the code to `TargetVersion`, because assuming the correct enumeration values for minors or parsing the names felt hacky \ud83d\ude05",
      "comment_id": 650563465,
      "user": "felix-hilden",
      "created_at": "2021-06-13T18:51:25Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r650563465"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,36 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n-    if sys.version_info >= (3, 8):\n-        # TODO: support Python 4+ ;)\n-        for minor_version in range(sys.version_info[1], 4, -1):\n-            try:\n-                return ast.parse(src, filename, feature_version=(3, minor_version))\n-            except SyntaxError:\n-                continue\n-    else:\n-        for feature_version in (7, 6):\n-            try:\n-                return ast3.parse(src, filename, feature_version=feature_version)\n-            except SyntaxError:\n-                continue\n-    if ast27.__name__ == \"ast\":\n-        raise SyntaxError(\n-            \"The requested source code has invalid Python 3 syntax.\\n\"\n-            \"If you are trying to format Python 2 files please reinstall Black\"\n-            \" with the 'python2' extra: `python3 -m pip install black[python2]`.\"\n-        )\n-    return ast27.parse(src)\n+    # typed_ast is needed because of feature version limitations in the builtin ast",
      "comment": "I was more thinking adding the whole table as a comment but this works too (and wouldn't become outdated) :D",
      "comment_id": 655757383,
      "user": "ichard26",
      "created_at": "2021-06-21T23:00:44Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r655757383"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,36 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n-    if sys.version_info >= (3, 8):\n-        # TODO: support Python 4+ ;)\n-        for minor_version in range(sys.version_info[1], 4, -1):\n-            try:\n-                return ast.parse(src, filename, feature_version=(3, minor_version))\n-            except SyntaxError:\n-                continue\n-    else:\n-        for feature_version in (7, 6):\n-            try:\n-                return ast3.parse(src, filename, feature_version=feature_version)\n-            except SyntaxError:\n-                continue\n-    if ast27.__name__ == \"ast\":\n-        raise SyntaxError(\n-            \"The requested source code has invalid Python 3 syntax.\\n\"\n-            \"If you are trying to format Python 2 files please reinstall Black\"\n-            \" with the 'python2' extra: `python3 -m pip install black[python2]`.\"\n-        )\n-    return ast27.parse(src)\n+    # typed_ast is needed because of feature version limitations in the builtin ast\n+    if sys.version_info >= (3, 8) and version >= (3,):\n+        return ast.parse(src, filename, feature_version=version)\n+    elif version >= (3,):\n+        return ast3.parse(src, filename, feature_version=version[1])\n+    elif version == (2, 7):\n+        return ast27.parse(src)\n+    raise AssertionError(\"INTERNAL ERROR: Tried parsing unsupported Python version!\")\n+\n+\n+def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+    # TODO: support Python 4+ ;)",
      "comment": "Technically a bigger concern is the fact 3.10 syntax is not supported but oh well ;)",
      "comment_id": 663298632,
      "user": "ichard26",
      "created_at": "2021-07-03T01:23:38Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r663298632"
    },
    {
      "repo": "psf/black",
      "pr_number": 2304,
      "file_path": "src/black/parsing.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,28 +106,36 @@ def lib2to3_unparse(node: Node) -> str:\n     return code\n \n \n-def parse_ast(src: str) -> Union[ast.AST, ast3.AST, ast27.AST]:\n+def parse_single_version(\n+    src: str, version: Tuple[int, int]\n+) -> Union[ast.AST, ast3.AST, ast27.AST]:\n     filename = \"<unknown>\"\n-    if sys.version_info >= (3, 8):\n-        # TODO: support Python 4+ ;)\n-        for minor_version in range(sys.version_info[1], 4, -1):\n-            try:\n-                return ast.parse(src, filename, feature_version=(3, minor_version))\n-            except SyntaxError:\n-                continue\n-    else:\n-        for feature_version in (7, 6):\n-            try:\n-                return ast3.parse(src, filename, feature_version=feature_version)\n-            except SyntaxError:\n-                continue\n-    if ast27.__name__ == \"ast\":\n-        raise SyntaxError(\n-            \"The requested source code has invalid Python 3 syntax.\\n\"\n-            \"If you are trying to format Python 2 files please reinstall Black\"\n-            \" with the 'python2' extra: `python3 -m pip install black[python2]`.\"\n-        )\n-    return ast27.parse(src)\n+    # typed_ast is needed because of feature version limitations in the builtin ast",
      "comment": "Yeah, I think I like this a bit more so let's stick with it unless someone really wants more detail. Once again we should definitely continue the discussion on #2165 or even make a dedicated issue diving into exactly why `typed_ast` is needed. But I think this will do for the current PR.",
      "comment_id": 663544869,
      "user": "felix-hilden",
      "created_at": "2021-07-04T19:11:40Z",
      "url": "https://github.com/psf/black/pull/2304#discussion_r663544869"
    },
    {
      "repo": "psf/black",
      "pr_number": 2667,
      "file_path": "tests/data/pattern_matching_extras.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -77,3 +77,8 @@ def func(match: case, case: match) -> case:\n match match:\n     case case:\n         pass\n+\n+\n+match a, *b(), c:",
      "comment": "That is not a valid syntax.\r\n```py\r\n>>> match *a:\r\n  File \"<stdin>\", line 1\r\n    match *a:\r\n            ^\r\nSyntaxError: invalid syntax\r\n```\r\nFor one regular starred and one normal mixed, see the same file. We have an example for that.",
      "comment_id": 761985486,
      "user": "isidentical",
      "created_at": "2021-12-03T14:32:16Z",
      "url": "https://github.com/psf/black/pull/2667#discussion_r761985486"
    },
    {
      "repo": "psf/black",
      "pr_number": 2667,
      "file_path": "tests/data/pattern_matching_extras.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -77,3 +77,8 @@ def func(match: case, case: match) -> case:\n match match:\n     case case:\n         pass\n+\n+\n+match a, *b(), c:",
      "comment": "Ah my bad, I should perhaps play with pattern matching for once haha.",
      "comment_id": 761987532,
      "user": "ichard26",
      "created_at": "2021-12-03T14:34:11Z",
      "url": "https://github.com/psf/black/pull/2667#discussion_r761987532"
    },
    {
      "repo": "psf/black",
      "pr_number": 2667,
      "file_path": "tests/data/pattern_matching_extras.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -77,3 +77,8 @@ def func(match: case, case: match) -> case:\n match match:\n     case case:\n         pass\n+\n+\n+match a, *b(), c:",
      "comment": "Well then, I need to play with pattern matching too.",
      "comment_id": 761999611,
      "user": "onerandomusername",
      "created_at": "2021-12-03T14:49:10Z",
      "url": "https://github.com/psf/black/pull/2667#discussion_r761999611"
    },
    {
      "repo": "psf/black",
      "pr_number": 2663,
      "file_path": "src/black/trans.py",
      "line": 456,
      "side": "RIGHT",
      "diff_hunk": "@@ -453,7 +453,7 @@ def make_naked(string: str, string_prefix: str) -> str:\n             # with 'f'...\n             if \"f\" in prefix and \"f\" not in next_prefix:\n                 # Then we must escape any braces contained in this substring.\n-                SS = re.subf(r\"(\\{|\\})\", \"{1}{1}\", SS)\n+                SS = re.sub(r\"(\\{|\\})\", r\"\\1\\1\", SS)",
      "comment": "This will never have unicode to match right so we should be safe ... :D",
      "comment_id": 760771521,
      "user": "cooperlees",
      "created_at": "2021-12-02T05:24:13Z",
      "url": "https://github.com/psf/black/pull/2663#discussion_r760771521"
    },
    {
      "repo": "psf/black",
      "pr_number": 2663,
      "file_path": "src/black/trans.py",
      "line": 456,
      "side": "RIGHT",
      "diff_hunk": "@@ -453,7 +453,7 @@ def make_naked(string: str, string_prefix: str) -> str:\n             # with 'f'...\n             if \"f\" in prefix and \"f\" not in next_prefix:\n                 # Then we must escape any braces contained in this substring.\n-                SS = re.subf(r\"(\\{|\\})\", \"{1}{1}\", SS)\n+                SS = re.sub(r\"(\\{|\\})\", r\"\\1\\1\", SS)",
      "comment": "As far as I can tell the missing unicode support is just about character classes, so some \"word\" characters don't match `\\w` in re but do in regex. That doesn't apply here.",
      "comment_id": 761162325,
      "user": "JelleZijlstra",
      "created_at": "2021-12-02T14:45:49Z",
      "url": "https://github.com/psf/black/pull/2663#discussion_r761162325"
    },
    {
      "repo": "psf/black",
      "pr_number": 2472,
      "file_path": "src/black/lines.py",
      "line": 465,
      "side": "RIGHT",
      "diff_hunk": "@@ -447,11 +447,30 @@ def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n             before = 0\n         depth = current_line.depth\n         while self.previous_defs and self.previous_defs[-1] >= depth:\n-            self.previous_defs.pop()\n             if self.is_pyi:\n                 before = 0 if depth else 1\n             else:\n-                before = 1 if depth else 2\n+                if depth:\n+                    before = 1\n+                elif (\n+                    not depth\n+                    and self.previous_defs[-1]\n+                    and current_line.leaves[-1].type == token.COLON\n+                    and (\n+                        current_line.leaves[0].value\n+                        not in (\"with\", \"try\", \"for\", \"while\", \"if\")\n+                    )\n+                ):\n+                    # We shouldn't add two newlines between an indented function and\n+                    # and a dependent non-indented clause. This is to avoid issues with",
      "comment": "```suggestion\r\n                    # a dependent non-indented clause. This is to avoid issues with\r\n```",
      "comment_id": 711675477,
      "user": "JelleZijlstra",
      "created_at": "2021-09-19T03:24:40Z",
      "url": "https://github.com/psf/black/pull/2472#discussion_r711675477"
    },
    {
      "repo": "psf/black",
      "pr_number": 2472,
      "file_path": "src/black/lines.py",
      "line": 469,
      "side": "RIGHT",
      "diff_hunk": "@@ -447,11 +447,30 @@ def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:\n             before = 0\n         depth = current_line.depth\n         while self.previous_defs and self.previous_defs[-1] >= depth:\n-            self.previous_defs.pop()\n             if self.is_pyi:\n                 before = 0 if depth else 1\n             else:\n-                before = 1 if depth else 2\n+                if depth:\n+                    before = 1\n+                elif (\n+                    not depth\n+                    and self.previous_defs[-1]\n+                    and current_line.leaves[-1].type == token.COLON\n+                    and (\n+                        current_line.leaves[0].value\n+                        not in (\"with\", \"try\", \"for\", \"while\", \"if\")\n+                    )\n+                ):\n+                    # We shouldn't add two newlines between an indented function and\n+                    # and a dependent non-indented clause. This is to avoid issues with\n+                    # conditional function definitions that are technically top-level\n+                    # and therefore get two trailing newlines, but look weird and\n+                    # inconsistent when they're followed by elif, else, etc. This is\n+                    # worsen by that these functions only get *one* preceding already.",
      "comment": "```suggestion\r\n                    # worse because these functions only get *one* preceding newline already.\r\n```",
      "comment_id": 711675510,
      "user": "JelleZijlstra",
      "created_at": "2021-09-19T03:25:17Z",
      "url": "https://github.com/psf/black/pull/2472#discussion_r711675510"
    },
    {
      "repo": "psf/black",
      "pr_number": 2654,
      "file_path": "src/black/trans.py",
      "line": 948,
      "side": "RIGHT",
      "diff_hunk": "@@ -942,6 +942,53 @@ def _get_max_string_length(self, line: Line, string_idx: int) -> int:\n         return max_string_length\n \n \n+def iter_fexpr_spans(s: str) -> Iterator[Tuple[int, int]]:\n+    \"\"\"\n+    Yields spans corresponding to expressions in a given f-string.\n+    Assumes the input string is a valid f-string.",
      "comment": "Document that the yielded values are half-open ranges",
      "comment_id": 758574955,
      "user": "JelleZijlstra",
      "created_at": "2021-11-29T17:17:39Z",
      "url": "https://github.com/psf/black/pull/2654#discussion_r758574955"
    },
    {
      "repo": "psf/black",
      "pr_number": 2654,
      "file_path": "src/black/trans.py",
      "line": 982,
      "side": "RIGHT",
      "diff_hunk": "@@ -942,6 +942,53 @@ def _get_max_string_length(self, line: Line, string_idx: int) -> int:\n         return max_string_length\n \n \n+def iter_fexpr_spans(s: str) -> Iterator[Tuple[int, int]]:\n+    \"\"\"\n+    Yields spans corresponding to expressions in a given f-string.\n+    Assumes the input string is a valid f-string.\n+    \"\"\"\n+    stack: List[int] = []  # our curly paren stack\n+    i = 0\n+    while i < len(s):\n+        if s[i] == \"{\":\n+            # if we're in a string part of the f-string, ignore escaped curly braces\n+            if not stack and i + 1 < len(s) and s[i + 1] == \"{\":\n+                i += 2\n+                continue\n+            stack.append(i)\n+            i += 1\n+            continue\n+\n+        if s[i] == \"}\":\n+            if not stack:\n+                i += 1\n+                continue\n+            j = stack.pop()\n+            # we've made it back out of the expression! yield the span\n+            if not stack:\n+                yield (j, i + 1)\n+            i += 1\n+            continue\n+\n+        # if we're in an expression part of the f-string, fast forward through strings\n+        # note that backslashes are not legal in the expression portion of f-strings\n+        if stack:\n+            delim = None\n+            if s[i : i + 3] in (\"'''\", '\"\"\"'):\n+                delim = s[i : i + 3]\n+            elif s[i] in (\"'\", '\"'):\n+                delim = s[i]\n+            if delim:\n+                i += len(delim)",
      "comment": "This seems wrong; triple-quoted string will only work if their length is a multiple of 3. I believe just `i += 1` is right.",
      "comment_id": 758575818,
      "user": "JelleZijlstra",
      "created_at": "2021-11-29T17:18:43Z",
      "url": "https://github.com/psf/black/pull/2654#discussion_r758575818"
    },
    {
      "repo": "psf/black",
      "pr_number": 2654,
      "file_path": "src/black/trans.py",
      "line": 989,
      "side": "RIGHT",
      "diff_hunk": "@@ -942,6 +942,53 @@ def _get_max_string_length(self, line: Line, string_idx: int) -> int:\n         return max_string_length\n \n \n+def iter_fexpr_spans(s: str) -> Iterator[Tuple[int, int]]:\n+    \"\"\"\n+    Yields spans corresponding to expressions in a given f-string.\n+    Assumes the input string is a valid f-string.\n+    \"\"\"\n+    stack: List[int] = []  # our curly paren stack\n+    i = 0\n+    while i < len(s):\n+        if s[i] == \"{\":\n+            # if we're in a string part of the f-string, ignore escaped curly braces\n+            if not stack and i + 1 < len(s) and s[i + 1] == \"{\":\n+                i += 2\n+                continue\n+            stack.append(i)\n+            i += 1\n+            continue\n+\n+        if s[i] == \"}\":\n+            if not stack:\n+                i += 1\n+                continue\n+            j = stack.pop()\n+            # we've made it back out of the expression! yield the span\n+            if not stack:\n+                yield (j, i + 1)\n+            i += 1\n+            continue\n+\n+        # if we're in an expression part of the f-string, fast forward through strings\n+        # note that backslashes are not legal in the expression portion of f-strings\n+        if stack:\n+            delim = None\n+            if s[i : i + 3] in (\"'''\", '\"\"\"'):\n+                delim = s[i : i + 3]\n+            elif s[i] in (\"'\", '\"'):\n+                delim = s[i]\n+            if delim:\n+                i += len(delim)\n+                while i < len(s) and s[i : i + len(delim)] != delim:\n+                    i += 1\n+        i += 1\n+\n+\n+def fstring_contains_expr(s: str) -> bool:\n+    return any(True for _ in iter_fexpr_spans(s))",
      "comment": "```suggestion\r\n    return any(iter_fexpr_spans(s))\r\n```",
      "comment_id": 758576357,
      "user": "JelleZijlstra",
      "created_at": "2021-11-29T17:19:22Z",
      "url": "https://github.com/psf/black/pull/2654#discussion_r758576357"
    },
    {
      "repo": "psf/black",
      "pr_number": 2654,
      "file_path": "src/black/trans.py",
      "line": 982,
      "side": "RIGHT",
      "diff_hunk": "@@ -942,6 +942,53 @@ def _get_max_string_length(self, line: Line, string_idx: int) -> int:\n         return max_string_length\n \n \n+def iter_fexpr_spans(s: str) -> Iterator[Tuple[int, int]]:\n+    \"\"\"\n+    Yields spans corresponding to expressions in a given f-string.\n+    Assumes the input string is a valid f-string.\n+    \"\"\"\n+    stack: List[int] = []  # our curly paren stack\n+    i = 0\n+    while i < len(s):\n+        if s[i] == \"{\":\n+            # if we're in a string part of the f-string, ignore escaped curly braces\n+            if not stack and i + 1 < len(s) and s[i + 1] == \"{\":\n+                i += 2\n+                continue\n+            stack.append(i)\n+            i += 1\n+            continue\n+\n+        if s[i] == \"}\":\n+            if not stack:\n+                i += 1\n+                continue\n+            j = stack.pop()\n+            # we've made it back out of the expression! yield the span\n+            if not stack:\n+                yield (j, i + 1)\n+            i += 1\n+            continue\n+\n+        # if we're in an expression part of the f-string, fast forward through strings\n+        # note that backslashes are not legal in the expression portion of f-strings\n+        if stack:\n+            delim = None\n+            if s[i : i + 3] in (\"'''\", '\"\"\"'):\n+                delim = s[i : i + 3]\n+            elif s[i] in (\"'\", '\"'):\n+                delim = s[i]\n+            if delim:\n+                i += len(delim)",
      "comment": "I'm not sure I understand :-( , do you have an example that fails? This is just skipping past the opening (triple) quote, we do `i += 1` in the loop.",
      "comment_id": 758673938,
      "user": "hauntsaninja",
      "created_at": "2021-11-29T19:32:19Z",
      "url": "https://github.com/psf/black/pull/2654#discussion_r758673938"
    },
    {
      "repo": "psf/black",
      "pr_number": 2654,
      "file_path": "src/black/trans.py",
      "line": 989,
      "side": "RIGHT",
      "diff_hunk": "@@ -942,6 +942,53 @@ def _get_max_string_length(self, line: Line, string_idx: int) -> int:\n         return max_string_length\n \n \n+def iter_fexpr_spans(s: str) -> Iterator[Tuple[int, int]]:\n+    \"\"\"\n+    Yields spans corresponding to expressions in a given f-string.\n+    Assumes the input string is a valid f-string.\n+    \"\"\"\n+    stack: List[int] = []  # our curly paren stack\n+    i = 0\n+    while i < len(s):\n+        if s[i] == \"{\":\n+            # if we're in a string part of the f-string, ignore escaped curly braces\n+            if not stack and i + 1 < len(s) and s[i + 1] == \"{\":\n+                i += 2\n+                continue\n+            stack.append(i)\n+            i += 1\n+            continue\n+\n+        if s[i] == \"}\":\n+            if not stack:\n+                i += 1\n+                continue\n+            j = stack.pop()\n+            # we've made it back out of the expression! yield the span\n+            if not stack:\n+                yield (j, i + 1)\n+            i += 1\n+            continue\n+\n+        # if we're in an expression part of the f-string, fast forward through strings\n+        # note that backslashes are not legal in the expression portion of f-strings\n+        if stack:\n+            delim = None\n+            if s[i : i + 3] in (\"'''\", '\"\"\"'):\n+                delim = s[i : i + 3]\n+            elif s[i] in (\"'\", '\"'):\n+                delim = s[i]\n+            if delim:\n+                i += len(delim)\n+                while i < len(s) and s[i : i + len(delim)] != delim:\n+                    i += 1\n+        i += 1\n+\n+\n+def fstring_contains_expr(s: str) -> bool:\n+    return any(True for _ in iter_fexpr_spans(s))",
      "comment": "Sure, I guess `iter_fexpr_spans` only yields truthy things and that's unlikely to change :-)",
      "comment_id": 758674421,
      "user": "hauntsaninja",
      "created_at": "2021-11-29T19:32:57Z",
      "url": "https://github.com/psf/black/pull/2654#discussion_r758674421"
    },
    {
      "repo": "psf/black",
      "pr_number": 2630,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,20 +37,13 @@\n         \"ESCAPED_NL\",\n     )\n )\n-NON_PYTHON_CELL_MAGICS = frozenset(\n+PYTHON_CELL_MAGICS = frozenset(\n     (\n-        \"bash\",\n-        \"html\",\n-        \"javascript\",\n-        \"js\",\n-        \"latex\",\n-        \"markdown\",\n-        \"perl\",\n-        \"ruby\",\n-        \"script\",\n-        \"sh\",\n-        \"svg\",\n-        \"writefile\",\n+        \"capture\",\n+        \"prun\",\n+        \"pypy\",\n+        \"time\",\n+        \"timeit\",",
      "comment": "I think `python` and `python3` should also be added?",
      "comment_id": 753329363,
      "user": "MarcoGorelli",
      "created_at": "2021-11-19T16:08:42Z",
      "url": "https://github.com/psf/black/pull/2630#discussion_r753329363"
    },
    {
      "repo": "psf/black",
      "pr_number": 2630,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,20 +37,16 @@\n         \"ESCAPED_NL\",\n     )\n )\n-NON_PYTHON_CELL_MAGICS = frozenset(\n+PYTHON_CELL_MAGICS = frozenset(\n     (\n-        \"bash\",\n-        \"html\",\n-        \"javascript\",\n-        \"js\",\n-        \"latex\",\n-        \"markdown\",\n-        \"perl\",\n-        \"ruby\",\n-        \"script\",\n-        \"sh\",\n-        \"svg\",\n-        \"writefile\",\n+        \"capture\",\n+        \"prun\",\n+        \"pypy\",\n+        \"python\",\n+        \"python2\",",
      "comment": "Python2 support has been deprecated from `black`, I think this can be removed",
      "comment_id": 753343632,
      "user": "MarcoGorelli",
      "created_at": "2021-11-19T16:27:14Z",
      "url": "https://github.com/psf/black/pull/2630#discussion_r753343632"
    },
    {
      "repo": "psf/black",
      "pr_number": 2630,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,20 +37,16 @@\n         \"ESCAPED_NL\",\n     )\n )\n-NON_PYTHON_CELL_MAGICS = frozenset(\n+PYTHON_CELL_MAGICS = frozenset(\n     (\n-        \"bash\",\n-        \"html\",\n-        \"javascript\",\n-        \"js\",\n-        \"latex\",\n-        \"markdown\",\n-        \"perl\",\n-        \"ruby\",\n-        \"script\",\n-        \"sh\",\n-        \"svg\",\n-        \"writefile\",\n+        \"capture\",\n+        \"prun\",\n+        \"pypy\",\n+        \"python\",\n+        \"python2\",",
      "comment": "Thanks, removed in https://github.com/psf/black/pull/2630/commits/744820647cc1728d0c4e82e20fcfbeaeb0fd6cad",
      "comment_id": 753361883,
      "user": "danielsparing",
      "created_at": "2021-11-19T16:50:40Z",
      "url": "https://github.com/psf/black/pull/2630#discussion_r753361883"
    },
    {
      "repo": "psf/black",
      "pr_number": 2630,
      "file_path": "src/black/__init__.py",
      "line": 967,
      "side": "RIGHT",
      "diff_hunk": "@@ -959,6 +962,10 @@ def validate_cell(src: str) -> None:\n     \"\"\"\n     if any(transformed_magic in src for transformed_magic in TRANSFORMED_MAGICS):\n         raise NothingChanged\n+    if src[:2] == \"%%\" and src.split()[0] not in (\n+        \"%%\" + magic for magic in PYTHON_CELL_MAGICS\n+    ):",
      "comment": "really minor, but perhaps\r\n```suggestion\r\n    if src[:2] == \"%%\" and src.split()[0][2:] not in PYTHON_CELL_MAGICS:\r\n```\r\nis simpler / marginally more efficient?\r\n\r\n(feel free to disregard this comment of course \ud83d\ude06 )",
      "comment_id": 758348346,
      "user": "MarcoGorelli",
      "created_at": "2021-11-29T13:13:19Z",
      "url": "https://github.com/psf/black/pull/2630#discussion_r758348346"
    },
    {
      "repo": "psf/black",
      "pr_number": 2644,
      "file_path": "src/blib2to3/pgen2/tokenize.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -86,7 +86,7 @@ def _combinations(*l):\n Comment = r\"#[^\\r\\n]*\"\n Ignore = Whitespace + any(r\"\\\\\\r?\\n\" + Whitespace) + maybe(Comment)\n Name = (  # this is invalid but it's fine because Name comes after Number in all groups\n-    r\"\\w+\"\n+    r\"[^\\s#\\(\\)\\[\\]\\{\\}+\\-*/!@$%^&=|;:'\\\",\\.<>/?`~\\\\]+\"",
      "comment": "At this point we might need to add a FAQ entry describing why Black is incredibly inconsistent detecting invalid syntax. We don't promise that Black will fail on all invalid code but people do reasonably assume consistency. We don't need to get into the nitty gritty but simply explaining how it requires less work while achieving a high degree compatibility. ",
      "comment_id": 757175541,
      "user": "ichard26",
      "created_at": "2021-11-26T01:12:50Z",
      "url": "https://github.com/psf/black/pull/2644#discussion_r757175541"
    },
    {
      "repo": "psf/black",
      "pr_number": 2661,
      "file_path": "src/black/linegen.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,6 +142,14 @@ def visit_stmt(\n \n             yield from self.visit(child)\n \n+    def visit_match_case(self, node: Node) -> Iterator[Line]:\n+        \"\"\"Visit either a match or case statement.\"\"\"\n+        normalize_invisible_parens(node, parens_after=set())\n+\n+        yield from self.line()",
      "comment": "I am not sure if this is the correct solution; it originates from the assumptions that for each `match_statement`/`case_statement` node, there will be only one valid `match`/`case` keyword for the context. So we simply yield a line; and for all following encounters of child nodes, we process them as usual.",
      "comment_id": 759593202,
      "user": "isidentical",
      "created_at": "2021-11-30T19:26:11Z",
      "url": "https://github.com/psf/black/pull/2661#discussion_r759593202"
    },
    {
      "repo": "psf/black",
      "pr_number": 2661,
      "file_path": "tests/data/pattern_matching_extras.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,10 +23,10 @@\n \n def func(match: case, case: match) -> case:\n     match Something():\n-        case another:\n-            ...\n         case func(match, case):\n             ...\n+        case another:",
      "comment": "I've fixed some syntax errors in this file (e.g a name pattern can't be followed by anything else) to ensure everything is also parsable by the python parser.",
      "comment_id": 759593631,
      "user": "isidentical",
      "created_at": "2021-11-30T19:26:48Z",
      "url": "https://github.com/psf/black/pull/2661#discussion_r759593631"
    },
    {
      "repo": "psf/black",
      "pr_number": 2642,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 422,
      "side": "RIGHT",
      "diff_hunk": "@@ -403,20 +403,29 @@ def visit_Assign(self, node: ast.Assign) -> None:\n         For example,\n \n             black_version = !black --version\n+            env = %env var\n \n-        would have been transformed to\n+        would have been (respectively) transformed to\n \n             black_version = get_ipython().getoutput('black --version')\n+            env = get_ipython().run_line_magic('env', 'var')\n \n-        and we look for instances of the latter.\n+        and we look for instances of any of the latter.\n         \"\"\"\n-        if (\n-            isinstance(node.value, ast.Call)\n-            and _is_ipython_magic(node.value.func)\n-            and node.value.func.attr == \"getoutput\"\n-        ):\n-            (arg,) = _get_str_args(node.value.args)\n-            src = f\"!{arg}\"\n+        if isinstance(node.value, ast.Call) and _is_ipython_magic(node.value.func):\n+            args = _get_str_args(node.value.args)\n+            if node.value.func.attr == \"getoutput\":\n+                src = f\"!{args[0]}\"\n+            elif node.value.func.attr == \"run_line_magic\":\n+                src = f\"%{args[0]}\"\n+                if args[1]:\n+                    assert src is not None",
      "comment": "Does mypy need this? It's assigned to a str just above.",
      "comment_id": 757179851,
      "user": "JelleZijlstra",
      "created_at": "2021-11-26T01:32:13Z",
      "url": "https://github.com/psf/black/pull/2642#discussion_r757179851"
    },
    {
      "repo": "psf/black",
      "pr_number": 2642,
      "file_path": "src/black/handle_ipynb_magics.py",
      "line": 425,
      "side": "RIGHT",
      "diff_hunk": "@@ -403,20 +403,28 @@ def visit_Assign(self, node: ast.Assign) -> None:\n         For example,\n \n             black_version = !black --version\n+            env = %env var\n \n-        would have been transformed to\n+        would have been (respectively) transformed to\n \n             black_version = get_ipython().getoutput('black --version')\n+            env = get_ipython().run_line_magic('env', 'var')\n \n-        and we look for instances of the latter.\n+        and we look for instances of any of the latter.\n         \"\"\"\n-        if (\n-            isinstance(node.value, ast.Call)\n-            and _is_ipython_magic(node.value.func)\n-            and node.value.func.attr == \"getoutput\"\n-        ):\n-            (arg,) = _get_str_args(node.value.args)\n-            src = f\"!{arg}\"\n+        if isinstance(node.value, ast.Call) and _is_ipython_magic(node.value.func):\n+            args = _get_str_args(node.value.args)\n+            if node.value.func.attr == \"getoutput\":\n+                src = f\"!{args[0]}\"\n+            elif node.value.func.attr == \"run_line_magic\":\n+                src = f\"%{args[0]}\"\n+                if args[1]:\n+                    src += f\" {args[1]}\"\n+            else:\n+                raise AssertionError(\n+                    \"Unexpected IPython magic found. \"",
      "comment": "```suggestion\r\n                    \"Unexpected IPython magic {node.value.func.attr!r} found. \"\r\n```\r\nGoing to save us some work if we ever do run into this.",
      "comment_id": 757581648,
      "user": "JelleZijlstra",
      "created_at": "2021-11-26T15:25:31Z",
      "url": "https://github.com/psf/black/pull/2642#discussion_r757581648"
    },
    {
      "repo": "psf/black",
      "pr_number": 2559,
      "file_path": "src/black/parsing.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,10 +15,13 @@\n from black.mode import TargetVersion, Feature, supports_feature\n from black.nodes import syms\n \n+_IS_PYPY = \"__pypy__\" in sys.modules",
      "comment": "[`_IS_PYPY = platform.python_implementation() == \"PyPy\"`](https://docs.python.org/3/library/platform.html#platform.python_implementation)",
      "comment_id": 736164457,
      "user": "Zac-HD",
      "created_at": "2021-10-26T05:30:36Z",
      "url": "https://github.com/psf/black/pull/2559#discussion_r736164457"
    },
    {
      "repo": "psf/black",
      "pr_number": 2562,
      "file_path": "setup.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,6 +104,7 @@ def get_long_description() -> str:\n         \"Programming Language :: Python :: 3.7\",\n         \"Programming Language :: Python :: 3.8\",\n         \"Programming Language :: Python :: 3.9\",\n+        \"Programming Language :: Python :: 3.10\",",
      "comment": "Do we wish to do this before we support all the syntax?",
      "comment_id": 734650622,
      "user": "cooperlees",
      "created_at": "2021-10-22T15:37:30Z",
      "url": "https://github.com/psf/black/pull/2562#discussion_r734650622"
    },
    {
      "repo": "psf/black",
      "pr_number": 2562,
      "file_path": "setup.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,6 +104,7 @@ def get_long_description() -> str:\n         \"Programming Language :: Python :: 3.7\",\n         \"Programming Language :: Python :: 3.8\",\n         \"Programming Language :: Python :: 3.9\",\n+        \"Programming Language :: Python :: 3.10\",",
      "comment": "We already declare Python 3.9 support without formatting all such syntax (e.g. parenthesised context managers), so I'd support adding this classifier - `black` does run on 3.10 after all!",
      "comment_id": 736164887,
      "user": "Zac-HD",
      "created_at": "2021-10-26T05:31:51Z",
      "url": "https://github.com/psf/black/pull/2562#discussion_r736164887"
    },
    {
      "repo": "psf/black",
      "pr_number": 2562,
      "file_path": "setup.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,6 +104,7 @@ def get_long_description() -> str:\n         \"Programming Language :: Python :: 3.7\",\n         \"Programming Language :: Python :: 3.8\",\n         \"Programming Language :: Python :: 3.9\",\n+        \"Programming Language :: Python :: 3.10\",",
      "comment": "But it crashes if you have the new syntax elements. We don\u2019t crash on context managers. Or has that been fixed? If so, sure. Let\u2019s add away.",
      "comment_id": 736581908,
      "user": "cooperlees",
      "created_at": "2021-10-26T14:07:01Z",
      "url": "https://github.com/psf/black/pull/2562#discussion_r736581908"
    },
    {
      "repo": "psf/black",
      "pr_number": 2562,
      "file_path": "setup.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,6 +104,7 @@ def get_long_description() -> str:\n         \"Programming Language :: Python :: 3.7\",\n         \"Programming Language :: Python :: 3.8\",\n         \"Programming Language :: Python :: 3.9\",\n+        \"Programming Language :: Python :: 3.10\",",
      "comment": "```console\r\n$ cat 1.py\r\ndef http_error(status):\r\n    match status:\r\n        case 400:\r\n            return \"Bad request\"\r\n        case 404:\r\n            return \"Not found\"\r\n        case 418:\r\n            return \"I'm a teapot\"\r\n        case _:\r\n            return \"Something's wrong with the internet\"\r\n$ black 1.py\r\nerror: cannot format 1.py: Cannot parse: 2:10:     match status:\r\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\r\n1 file failed to reformat.\r\n```",
      "comment_id": 736589731,
      "user": "hugovk",
      "created_at": "2021-10-26T14:14:18Z",
      "url": "https://github.com/psf/black/pull/2562#discussion_r736589731"
    },
    {
      "repo": "psf/black",
      "pr_number": 2562,
      "file_path": "setup.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,6 +104,7 @@ def get_long_description() -> str:\n         \"Programming Language :: Python :: 3.7\",\n         \"Programming Language :: Python :: 3.8\",\n         \"Programming Language :: Python :: 3.9\",\n+        \"Programming Language :: Python :: 3.10\",",
      "comment": "No, we do crash on context managers: see #1948, #2318 and \r\n\r\n```\r\n$ cat 2.py\r\nfrom contextlib import nullcontext\r\nwith (\r\n    nullcontext() as a,\r\n    nullcontext() as b,\r\n):\r\n    pass\r\n\r\n$ python3.9 2.py\r\n$ black 2.py\r\nerror: cannot format 2.py: Cannot parse: 4:18:     nullcontext() as a,\r\nOh no! \ud83d\udca5 \ud83d\udc94 \ud83d\udca5\r\n1 file failed to reformat.\r\n```",
      "comment_id": 737321808,
      "user": "Zac-HD",
      "created_at": "2021-10-27T10:19:40Z",
      "url": "https://github.com/psf/black/pull/2562#discussion_r737321808"
    },
    {
      "repo": "psf/black",
      "pr_number": 2562,
      "file_path": "setup.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,6 +104,7 @@ def get_long_description() -> str:\n         \"Programming Language :: Python :: 3.7\",\n         \"Programming Language :: Python :: 3.8\",\n         \"Programming Language :: Python :: 3.9\",\n+        \"Programming Language :: Python :: 3.10\",",
      "comment": "But parenthesized CMs are an undocumented feature in 3.9, not a flagship new feature like pattern matching in 3.10.",
      "comment_id": 737540309,
      "user": "JelleZijlstra",
      "created_at": "2021-10-27T14:39:26Z",
      "url": "https://github.com/psf/black/pull/2562#discussion_r737540309"
    },
    {
      "repo": "psf/black",
      "pr_number": 2562,
      "file_path": "setup.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,6 +104,7 @@ def get_long_description() -> str:\n         \"Programming Language :: Python :: 3.7\",\n         \"Programming Language :: Python :: 3.8\",\n         \"Programming Language :: Python :: 3.9\",\n+        \"Programming Language :: Python :: 3.10\",",
      "comment": "PEP-614 \"relaxed grammar restrictions on decorators\" *is* documented in the what's new page, and also crashes. ",
      "comment_id": 737825970,
      "user": "Zac-HD",
      "created_at": "2021-10-27T20:35:52Z",
      "url": "https://github.com/psf/black/pull/2562#discussion_r737825970"
    }
  ]
}