{
  "repo": "encode/httpx",
  "scraped_at": "2026-02-03T12:34:36.824196",
  "stats": {
    "total_comments": 1200,
    "filtered": {
      "not_python": 314,
      "too_short": 243,
      "no_diff_hunk": 2,
      "too_long": 5,
      "skip_pattern:awesome": 1,
      "skip_pattern:looks good": 1,
      "skip_pattern:nit:": 2,
      "skip_pattern:thanks!": 1
    },
    "kept": 631
  },
  "examples": [
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/utils.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +107,14 @@ def get_netrc_login(host: str) -> typing.Optional[typing.Tuple[str, str, str]]:\n     return netrc_info.authenticators(host)  # type: ignore\n \n \n+def get_ssl_cert_file() -> typing.Optional[str]:\n+    for env_name in (\"REQUESTS_CA_BUNDLE\", \"SSL_CERT_FILE\", \"CURL_CA_BUNDLE\"):",
      "comment": "> We should check the three environment variables in the order above\r\n> `(SSL_CERT_FILE, REQUESTS_CA_BUNDLE, CURL_CA_BUNDLE)`,\r\n> as SSL_CERT_FILE is a PEP and a standard whereas the other are products of other projects.\r\n- @sethmlarson \thttps://github.com/encode/httpx/issues/306#issue-488260040\r\n\r\nThis also affects [the](https://github.com/encode/httpx/pull/307/files#diff-c73723c2d8a7c6dfecc80f229ebcef55R83) [docs](https://github.com/encode/httpx/pull/307/files#diff-c73723c2d8a7c6dfecc80f229ebcef55R88)",
      "comment_id": 320042951,
      "user": "StephenBrown2",
      "created_at": "2019-09-02T20:32:01Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r320042951"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_utils.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -111,3 +116,19 @@ def test_parse_header_links(value, expected):\n \n     # Reset the logger so we don't have verbose output in all unit tests\n     logging.getLogger(\"httpx\").handlers = []\n+\n+\n+def test_get_ssl_cert_file():",
      "comment": "This should also test if all three are set and if none are valid files, and verify the order tested.",
      "comment_id": 320043132,
      "user": "StephenBrown2",
      "created_at": "2019-09-02T20:33:59Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r320043132"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/config.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,6 +62,10 @@ def __init__(\n             verify = True\n             self._load_client_certs(ssl_context)\n \n+        if trust_env:\n+            if verify is True or verify is None:\n+                verify = get_ssl_cert_file()  # type: ignore",
      "comment": "This doesn't look quite right to me, but perhaps I've got myself in a muddle.\r\n\r\nIf verify is True, but `SSL_CERT_FILE` is not set, then `get_ssl_cert_file` will return `None`, which looks like a behavioral change from what we've got right now.",
      "comment_id": 320250534,
      "user": "lovelydinosaur",
      "created_at": "2019-09-03T12:43:53Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r320250534"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/config.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,6 +62,10 @@ def __init__(\n             verify = True\n             self._load_client_certs(ssl_context)\n \n+        if trust_env:\n+            if verify is True or verify is None:\n+                verify = get_ssl_cert_file()  # type: ignore",
      "comment": "I also think we should *probably* inspect the environment at the point of calling `load_ssl_context`, rather than on `__init__`.",
      "comment_id": 320250946,
      "user": "lovelydinosaur",
      "created_at": "2019-09-03T12:44:49Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r320250946"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/utils.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +107,14 @@ def get_netrc_login(host: str) -> typing.Optional[typing.Tuple[str, str, str]]:\n     return netrc_info.authenticators(host)  # type: ignore\n \n \n+def get_ssl_cert_file() -> typing.Optional[str]:\n+    for env_name in (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"):\n+        ssl_file = Path(os.getenv(env_name, \"\"))\n+        if ssl_file and ssl_file.is_file():",
      "comment": "This won't work for `SSL_CERT_DIR`, for hopefully obvious reasons.",
      "comment_id": 320416523,
      "user": "StephenBrown2",
      "created_at": "2019-09-03T18:30:00Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r320416523"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/utils.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +107,16 @@ def get_netrc_login(host: str) -> typing.Optional[typing.Tuple[str, str, str]]:\n     return netrc_info.authenticators(host)  # type: ignore\n \n \n+def get_ssl_cert_file() -> typing.Optional[str]:",
      "comment": "Let's change the title of this since \"cert\" is what we use for client cert. Really this should be `get_ca_bundle_from_env()` or something like it?",
      "comment_id": 321404735,
      "user": "sethmlarson",
      "created_at": "2019-09-05T18:02:10Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321404735"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +27,19 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(config):\n+    default_path = httpx.config.DEFAULT_CA_BUNDLE_PATH",
      "comment": "We should use a non-default and verify that it's loaded. I think there's a way to see how many certificates are loaded in an SSLContext?",
      "comment_id": 321405215,
      "user": "sethmlarson",
      "created_at": "2019-09-05T18:03:16Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321405215"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +27,19 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(config):\n+    default_path = httpx.config.DEFAULT_CA_BUNDLE_PATH",
      "comment": "I couldn't understand this part. Could you give an example roughly?",
      "comment_id": 321487564,
      "user": "cansarigol",
      "created_at": "2019-09-05T21:18:25Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321487564"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +27,19 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(config):\n+    default_path = httpx.config.DEFAULT_CA_BUNDLE_PATH",
      "comment": "Basically if we don't set any `SSL_CERT_...` environment variable we choose `httpx.config.DEFAULT_CA_BUNDLE_PATH` so we can't test the behavior of `SSL_CERT_...` using that path as our expected value because there's no way to tell if the environment variable worked or we just picked the default anyways.\r\n\r\nI suggest you use one of the auto-generated cert fixtures to test this functionality. :)",
      "comment_id": 321546711,
      "user": "sethmlarson",
      "created_at": "2019-09-06T01:34:35Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321546711"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +27,19 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(config):\n+    default_path = httpx.config.DEFAULT_CA_BUNDLE_PATH",
      "comment": "thanks. in addition, added ssl_config.verify validation to the end of the test to make sure.",
      "comment_id": 321593551,
      "user": "cansarigol",
      "created_at": "2019-09-06T06:36:45Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321593551"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/config.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +91,12 @@ def load_ssl_context(\n     ) -> ssl.SSLContext:\n         http_versions = HTTPVersionConfig() if http_versions is None else http_versions\n \n+        if self.trust_env:",
      "comment": "Can we move this section into the `load_ssl_context_verify()`? Since we're only doing the loading if we've got verify active anyways.\r\n\r\nAlso is there any harm in having `SSLConfig.verify` default to `True` in the constructor? It defaults to `True` on the client anyways.",
      "comment_id": 321714538,
      "user": "sethmlarson",
      "created_at": "2019-09-06T12:39:56Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321714538"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "Verify that certs are loaded via `assert len(context.get_ca_certs) > 0`",
      "comment_id": 321715100,
      "user": "sethmlarson",
      "created_at": "2019-09-06T12:41:32Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321715100"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "`get_ca_certs` returns empty if use `context.load_verify_locations(capath=str(ca_bundle_path))`. \r\nTo get a result, we should create an `SSLSocket` and call [getpeercert](https://docs.python.org/3/library/ssl.html#ssl.SSLSocket.getpeercert) like below\r\n\r\n```\r\nif config == \"SSL_CERT_DIR\":\r\n        HOST = \"example.org\"\r\n        PORT = 443\r\n        conn: ssl.SSLSocket = ssl_config.ssl_context.wrap_socket(\r\n            socket.socket(socket.AF_INET, socket.SOCK_STREAM), server_hostname=HOST\r\n        )\r\n        conn.connect((HOST, PORT))\r\n        conn.getpeercert()\r\n```\r\n",
      "comment_id": 321744962,
      "user": "cansarigol",
      "created_at": "2019-09-06T13:52:03Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321744962"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/config.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +91,12 @@ def load_ssl_context(\n     ) -> ssl.SSLContext:\n         http_versions = HTTPVersionConfig() if http_versions is None else http_versions\n \n+        if self.trust_env:",
      "comment": "Did you mean `load_ssl_context_verify`? when `verify` active, `load_ssl_context_verify` is called.",
      "comment_id": 321748486,
      "user": "cansarigol",
      "created_at": "2019-09-06T13:59:49Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321748486"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "Maybe we can use https_server.url.host and https_server.url.port to accomplish that. Then our certificate will verify as well :)",
      "comment_id": 321753686,
      "user": "sethmlarson",
      "created_at": "2019-09-06T14:11:41Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321753686"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "I couldn't verify with `cert_pem_file` for `https_server.url`. Please help :)",
      "comment_id": 321870931,
      "user": "cansarigol",
      "created_at": "2019-09-06T19:04:19Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r321870931"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_utils.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -111,3 +116,19 @@ def test_parse_header_links(value, expected):\n \n     # Reset the logger so we don't have verbose output in all unit tests\n     logging.getLogger(\"httpx\").handlers = []\n+\n+\n+def test_get_ssl_cert_file():",
      "comment": "I'd probably tend to be okay either way on this sort of thing.\r\nWe can't ever test every possible permutation, and test code does have it's own maintenance cost, too.",
      "comment_id": 322308585,
      "user": "lovelydinosaur",
      "created_at": "2019-09-09T15:30:03Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r322308585"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/utils.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +107,16 @@ def get_netrc_login(host: str) -> typing.Optional[typing.Tuple[str, str, str]]:\n     return netrc_info.authenticators(host)  # type: ignore\n \n \n+def get_ca_bundle_from_env() -> typing.Optional[str]:\n+    ssl_path = Path(os.getenv(\"SSL_CERT_FILE\", \"\"))\n+    if ssl_path and ssl_path.is_file():\n+        return str(ssl_path)\n+    ssl_path = Path(os.getenv(\"SSL_CERT_DIR\", \"\"))\n+    if ssl_path and ssl_path.is_dir():",
      "comment": "I don't think this is doing what we want: `bool(ssl_path)` is always going to be `True` because it refers to a `Path` object.\r\n\r\nAs a result, we'll probably end up using the current directory as the `SSL_CERT_DIR` in all cases. \ud83d\ude15 \r\n\r\nWe should probably instead write something like\u2026\r\n\r\n```python\r\nif \"SSL_CERT_DIR\" in os.environ:\r\n    ssl_path = Path(os.environ[\"SSL_CERT_DIR\"])\r\n    if ssl_path.is_dir():\r\n        return str(ssl_path)\r\n```\r\n\r\nand do the same kind of procesing for `SSL_CERT_FILE` above (although the bug wouldn't happen because the current directory is never a file).\r\n",
      "comment_id": 323458263,
      "user": "florimondmanca",
      "created_at": "2019-09-11T21:03:18Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r323458263"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/utils.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +107,16 @@ def get_netrc_login(host: str) -> typing.Optional[typing.Tuple[str, str, str]]:\n     return netrc_info.authenticators(host)  # type: ignore\n \n \n+def get_ca_bundle_from_env() -> typing.Optional[str]:\n+    ssl_path = Path(os.getenv(\"SSL_CERT_FILE\", \"\"))\n+    if ssl_path and ssl_path.is_file():\n+        return str(ssl_path)\n+    ssl_path = Path(os.getenv(\"SSL_CERT_DIR\", \"\"))\n+    if ssl_path and ssl_path.is_dir():",
      "comment": "(Trivia: I think this is typically a case where the Python 3.8 walrus operator would shine \ud83d\ude04)\r\n\r\n```python\r\nif (\r\n    ssl_cert_dir := os.getenv(\"SSL_CERT_DIR\") is not None\r\n    and (ssl_path := Path(ssl_cert_dir)).is_dir()\r\n):\r\n    return str(ssl_path)\r\n```",
      "comment_id": 323459451,
      "user": "florimondmanca",
      "created_at": "2019-09-11T21:06:27Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r323459451"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_utils.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -111,3 +116,15 @@ def test_parse_header_links(value, expected):\n \n     # Reset the logger so we don't have verbose output in all unit tests\n     logging.getLogger(\"httpx\").handlers = []\n+\n+\n+def test_get_ssl_cert_file():",
      "comment": "I'd say let\u2019s add tests at the top here for the cases when `SSL_CERT_FILE` and `SSL_CERT_DIR` are not set. Ideally we should be able to catch the potential bugs I mention in my other comment. :)",
      "comment_id": 323460444,
      "user": "florimondmanca",
      "created_at": "2019-09-11T21:09:01Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r323460444"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/utils.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +107,16 @@ def get_netrc_login(host: str) -> typing.Optional[typing.Tuple[str, str, str]]:\n     return netrc_info.authenticators(host)  # type: ignore\n \n \n+def get_ca_bundle_from_env() -> typing.Optional[str]:\n+    ssl_path = Path(os.getenv(\"SSL_CERT_FILE\", \"\"))\n+    if ssl_path and ssl_path.is_file():\n+        return str(ssl_path)\n+    ssl_path = Path(os.getenv(\"SSL_CERT_DIR\", \"\"))\n+    if ssl_path and ssl_path.is_dir():",
      "comment": "I got it. `Path` always returns a `PosixPath` and never be `None`. I'm fixing thanks.",
      "comment_id": 323605716,
      "user": "cansarigol",
      "created_at": "2019-09-12T08:02:24Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r323605716"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "httpx/utils.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +107,16 @@ def get_netrc_login(host: str) -> typing.Optional[typing.Tuple[str, str, str]]:\n     return netrc_info.authenticators(host)  # type: ignore\n \n \n+def get_ca_bundle_from_env() -> typing.Optional[str]:\n+    ssl_path = Path(os.getenv(\"SSL_CERT_FILE\", \"\"))\n+    if ssl_path and ssl_path.is_file():\n+        return str(ssl_path)\n+    ssl_path = Path(os.getenv(\"SSL_CERT_DIR\", \"\"))\n+    if ssl_path and ssl_path.is_dir():",
      "comment": "> (Trivia: I think this is typically a case where the Python 3.8 walrus operator would shine \ud83d\ude04)\r\n> \r\n> ```python\r\n> if (\r\n>     ssl_cert_dir := os.getenv(\"SSL_CERT_DIR\") is not None\r\n>     and (ssl_path := Path(ssl_cert_dir)).is_dir()\r\n> ):\r\n>     return str(ssl_path)\r\n> ```\r\n\r\ndefinitely, this syntax is great \ud83d\ude80 ",
      "comment_id": 323620515,
      "user": "cansarigol",
      "created_at": "2019-09-12T08:37:50Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r323620515"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "Not yet, would be good to resolve this and maybe add a case for the default of certifi getting loaded. :)",
      "comment_id": 324024303,
      "user": "sethmlarson",
      "created_at": "2019-09-13T03:25:18Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r324024303"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "I'm trying to fix this like [cpython test_ssl](https://github.com/python/cpython/blob/7cad53e6b084435a220e6604010f1fa5778bd0b1/Lib/test/test_ssl.py#L1931). However, I haven't been able to verify the certificate yet.",
      "comment_id": 324054753,
      "user": "cansarigol",
      "created_at": "2019-09-13T06:47:35Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r324054753"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "@cansarigol Is there anything we can do to help unblock this?",
      "comment_id": 324460274,
      "user": "florimondmanca",
      "created_at": "2019-09-15T12:25:42Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r324460274"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "Would be great. Thanks.  I'm stuck about create a sslsocket because of ssl validation error. I don't know if it is related trustme scope",
      "comment_id": 324462839,
      "user": "cansarigol",
      "created_at": "2019-09-15T13:24:53Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r324462839"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "@cansarigol Can you share a traceback so we know what part is failing exactly? :) Thanks",
      "comment_id": 324465172,
      "user": "florimondmanca",
      "created_at": "2019-09-15T14:18:24Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r324465172"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "I'm very sorry that I didn't do anything but i will asap",
      "comment_id": 324579390,
      "user": "cansarigol",
      "created_at": "2019-09-16T09:28:17Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r324579390"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "This is blocked by #354, just gave it a spin myself. I think we should maybe merge this now?",
      "comment_id": 325815705,
      "user": "sethmlarson",
      "created_at": "2019-09-18T18:00:45Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r325815705"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "#354 is closed now, I tried changing the test to look like this right now:\r\n\r\n```python\r\n    os.environ[config] = (\r\n        ca_cert_pem_file\r\n        if config.endswith(\"_FILE\")\r\n        else str(Path(ca_cert_pem_file).parent)\r\n    )\r\n    ssl_config = httpx.SSLConfig(trust_env=True)\r\n    context = ssl_config.load_ssl_context()\r\n    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\r\n    assert context.check_hostname is True\r\n    assert ssl_config.verify == os.environ[config]\r\n\r\n    host = https_server.url.host\r\n    port = https_server.url.port\r\n    conn = socket.create_connection((host, port))\r\n    context.wrap_socket(conn, server_hostname=host)\r\n    assert len(context.get_ca_certs()) == 1\r\n```\r\n\r\nBut I'm still failing on the `SSL_CERT_DIR` test case and I don't know why, pretty annoying!",
      "comment_id": 325958024,
      "user": "sethmlarson",
      "created_at": "2019-09-19T01:35:30Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r325958024"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "I added a test to be able to compare with below traceback.\r\n\r\n```\r\ntests/test_config.py ...FSSL error in data received\r\nprotocol: <asyncio.sslproto.SSLProtocol object at 0x103c044a8>\r\ntransport: <_SelectorSocketTransport closing fd=19 read=idle write=<idle, bufsize=0>>\r\nTraceback (most recent call last):\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/asyncio/sslproto.py\", line 526, in data_received\r\n    ssldata, appdata = self._sslpipe.feed_ssldata(data)\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/asyncio/sslproto.py\", line 189, in feed_ssldata\r\n    self._sslobj.do_handshake()\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/ssl.py\", line 763, in do_handshake\r\n    self._sslobj.do_handshake()\r\nssl.SSLError: [SSL: TLSV1_ALERT_UNKNOWN_CA] tlsv1 alert unknown ca (_ssl.c:1045)\r\n```",
      "comment_id": 326024810,
      "user": "cansarigol",
      "created_at": "2019-09-19T07:26:53Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r326024810"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 307,
      "file_path": "tests/test_config.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +28,18 @@ def test_load_ssl_config_verify_existing_file():\n     assert context.check_hostname is True\n \n \n+@pytest.mark.parametrize(\"config\", (\"SSL_CERT_FILE\", \"SSL_CERT_DIR\"))\n+def test_load_ssl_config_verify_env_file(cert_pem_file, config):\n+    os.environ[config] = (\n+        cert_pem_file if config.endswith(\"_FILE\") else str(Path(cert_pem_file).parent)\n+    )\n+    ssl_config = httpx.SSLConfig(trust_env=True)\n+    context = ssl_config.load_ssl_context()\n+    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n+    assert context.check_hostname is True\n+    assert ssl_config.verify == os.environ[config]",
      "comment": "Spoke with @florimondmanca and I think we're just going to skip the `SSL_CERT_DIR` case here and if we run into issues with it we'll fix them then. Until then this PR is good to go. Thank you so much @cansarigol for following this one all the way through. :)",
      "comment_id": 327178731,
      "user": "sethmlarson",
      "created_at": "2019-09-23T15:23:46Z",
      "url": "https://github.com/encode/httpx/pull/307#discussion_r327178731"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "tests/models/test_url.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,49 +312,13 @@ def test_url_copywith_security():\n     \"\"\"\n     Prevent unexpected changes on URL after calling copy_with (CVE-2021-41945)\n     \"\"\"\n-    url = httpx.URL(\"https://u:p@[invalid!]//evilHost/path?t=w#tw\")\n-    original_scheme = url.scheme\n-    original_userinfo = url.userinfo\n-    original_netloc = url.netloc\n-    original_raw_path = url.raw_path\n-    original_query = url.query\n-    original_fragment = url.fragment\n-    url = url.copy_with()\n-    assert url.scheme == original_scheme\n-    assert url.userinfo == original_userinfo\n-    assert url.netloc == original_netloc\n-    assert url.raw_path == original_raw_path\n-    assert url.query == original_query\n-    assert url.fragment == original_fragment\n-\n-    url = httpx.URL(\"https://u:p@[invalid!]//evilHost/path?t=w#tw\")\n-    original_scheme = url.scheme\n-    original_netloc = url.netloc\n-    original_raw_path = url.raw_path\n-    original_query = url.query\n-    original_fragment = url.fragment\n-    url = url.copy_with(userinfo=b\"\")\n-    assert url.scheme == original_scheme\n-    assert url.userinfo == b\"\"\n-    assert url.netloc == original_netloc\n-    assert url.raw_path == original_raw_path\n-    assert url.query == original_query\n-    assert url.fragment == original_fragment\n+    with pytest.raises(httpx.InvalidURL):\n+        httpx.URL(\"https://u:p@[invalid!]//evilHost/path?t=w#tw\")",
      "comment": "Our test here is much simpler, since this URL no longer passes validation. \ud83d\udc4d",
      "comment_id": 885618832,
      "user": "lovelydinosaur",
      "created_at": "2022-05-31T13:11:00Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r885618832"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "tests/models/test_url.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,49 +312,13 @@ def test_url_copywith_security():\n     \"\"\"\n     Prevent unexpected changes on URL after calling copy_with (CVE-2021-41945)\n     \"\"\"\n-    url = httpx.URL(\"https://u:p@[invalid!]//evilHost/path?t=w#tw\")\n-    original_scheme = url.scheme\n-    original_userinfo = url.userinfo\n-    original_netloc = url.netloc\n-    original_raw_path = url.raw_path\n-    original_query = url.query\n-    original_fragment = url.fragment\n-    url = url.copy_with()\n-    assert url.scheme == original_scheme\n-    assert url.userinfo == original_userinfo\n-    assert url.netloc == original_netloc\n-    assert url.raw_path == original_raw_path\n-    assert url.query == original_query\n-    assert url.fragment == original_fragment\n-\n-    url = httpx.URL(\"https://u:p@[invalid!]//evilHost/path?t=w#tw\")\n-    original_scheme = url.scheme\n-    original_netloc = url.netloc\n-    original_raw_path = url.raw_path\n-    original_query = url.query\n-    original_fragment = url.fragment\n-    url = url.copy_with(userinfo=b\"\")\n-    assert url.scheme == original_scheme\n-    assert url.userinfo == b\"\"\n-    assert url.netloc == original_netloc\n-    assert url.raw_path == original_raw_path\n-    assert url.query == original_query\n-    assert url.fragment == original_fragment\n+    with pytest.raises(httpx.InvalidURL):\n+        httpx.URL(\"https://u:p@[invalid!]//evilHost/path?t=w#tw\")\n \n     url = httpx.URL(\"https://example.com/path?t=w#tw\")\n-    original_userinfo = url.userinfo\n-    original_netloc = url.netloc\n-    original_raw_path = url.raw_path\n-    original_query = url.query\n-    original_fragment = url.fragment\n     bad = \"https://xxxx:xxxx@xxxxxxx/xxxxx/xxx?x=x#xxxxx\"\n-    url = url.copy_with(scheme=bad)\n-    assert url.scheme == bad\n-    assert url.userinfo == original_userinfo\n-    assert url.netloc == original_netloc\n-    assert url.raw_path == original_raw_path\n-    assert url.query == original_query\n-    assert url.fragment == original_fragment\n+    with pytest.raises(httpx.InvalidURL):\n+        url.copy_with(scheme=bad)",
      "comment": "Similarly, this scheme no longer validates, which is an improved behaviour.",
      "comment_id": 885619451,
      "user": "lovelydinosaur",
      "created_at": "2022-05-31T13:11:34Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r885619451"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "tests/test_asgi.py",
      "line": 119,
      "side": "RIGHT",
      "diff_hunk": "@@ -116,7 +116,7 @@ async def test_asgi_raw_path():\n         response = await client.get(url)\n \n     assert response.status_code == 200\n-    assert response.json() == {\"raw_path\": \"/user%40example.org\"}\n+    assert response.json() == {\"raw_path\": \"/user@example.org\"}",
      "comment": "This test changes, because of some improved behaviour. \"@\" should not be an auto-escaping character in the path.\r\n\r\nTry `https://www.example.com/some@path` in a browser, or see RFC sec 3.3...\r\n\r\nFrom https://datatracker.ietf.org/doc/html/rfc3986.html#section-3.3...\r\n\r\n> `pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"`",
      "comment_id": 885623387,
      "user": "lovelydinosaur",
      "created_at": "2022-05-31T13:14:58Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r885623387"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urls.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,76 +71,87 @@ class URL:\n     def __init__(\n         self, url: typing.Union[\"URL\", str] = \"\", **kwargs: typing.Any\n     ) -> None:\n+        if kwargs:\n+            allowed = {\n+                \"scheme\": str,\n+                \"username\": str,\n+                \"password\": str,\n+                \"userinfo\": bytes,\n+                \"host\": str,\n+                \"port\": int,\n+                \"netloc\": bytes,\n+                \"path\": str,\n+                \"query\": bytes,\n+                \"raw_path\": bytes,\n+                \"fragment\": str,\n+                \"params\": object,\n+            }\n+\n+            # Perform type checking for all supported keyword arguments.\n+            for key, value in kwargs.items():\n+                if key not in allowed:\n+                    message = f\"{key!r} is an invalid keyword argument for URL()\"\n+                    raise TypeError(message)\n+                if value is not None and not isinstance(value, allowed[key]):\n+                    expected = allowed[key].__name__\n+                    seen = type(value).__name__\n+                    message = f\"Argument {key!r} must be {expected} but got {seen}\"\n+                    raise TypeError(message)\n+                if isinstance(value, bytes):\n+                    kwargs[key] = value.decode(\"ascii\")\n+\n+            if \"raw_path\" in kwargs:\n+                kwargs[\"full_path\"] = kwargs.pop(\"raw_path\")\n+\n+            if \"params\" in kwargs:\n+                # Replace any \"params\" keyword with the raw \"query\" instead.\n+                #\n+                # Ensure that empty params use `kwargs[\"query\"] = None` rather\n+                # than `kwargs[\"query\"] = \"\"`, so that generated URLs do not\n+                # include an empty trailing \"?\".\n+                params = kwargs.pop(\"params\")\n+                kwargs[\"query\"] = None if not params else str(QueryParams(params))\n+\n         if isinstance(url, str):\n-            try:\n-                self._uri_reference = rfc3986.iri_reference(url).encode()\n-            except rfc3986.exceptions.InvalidAuthority as exc:\n-                raise InvalidURL(message=str(exc)) from None\n-\n-            if self.is_absolute_url:\n-                # We don't want to normalize relative URLs, since doing so\n-                # removes any leading `../` portion.\n-                self._uri_reference = self._uri_reference.normalize()\n+            self._uri_reference = urlparse(url, **kwargs)\n         elif isinstance(url, URL):\n-            self._uri_reference = url._uri_reference\n+            self._uri_reference = url._uri_reference.copy_with(**kwargs)\n         else:\n             raise TypeError(\n                 f\"Invalid type for url.  Expected str or httpx.URL, got {type(url)}: {url!r}\"\n             )\n \n-        # Perform port normalization, following the WHATWG spec for default ports.\n-        #\n-        # See:\n-        # * https://tools.ietf.org/html/rfc3986#section-3.2.3\n-        # * https://url.spec.whatwg.org/#url-miscellaneous\n-        # * https://url.spec.whatwg.org/#scheme-state\n-        default_port = {\n-            \"ftp\": \":21\",\n-            \"http\": \":80\",\n-            \"https\": \":443\",\n-            \"ws\": \":80\",\n-            \"wss\": \":443\",\n-        }.get(self._uri_reference.scheme, \"\")\n-        authority = self._uri_reference.authority or \"\"\n-        if default_port and authority.endswith(default_port):\n-            authority = authority[: -len(default_port)]\n-            self._uri_reference = self._uri_reference.copy_with(authority=authority)\n-\n-        if kwargs:\n-            self._uri_reference = self.copy_with(**kwargs)._uri_reference\n-\n     @property\n     def scheme(self) -> str:\n         \"\"\"\n         The URL scheme, such as \"http\", \"https\".\n         Always normalised to lowercase.\n         \"\"\"\n-        return self._uri_reference.scheme or \"\"\n+        return self._uri_reference.scheme",
      "comment": "Unlike with `rfc3986`, this value can no longer be `None`.\r\nIt's not needed, since an empty string is sufficient.\r\n\r\nSee also other cases below.",
      "comment_id": 886778198,
      "user": "lovelydinosaur",
      "created_at": "2022-06-01T13:01:22Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r886778198"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urls.py",
      "line": 336,
      "side": "RIGHT",
      "diff_hunk": "@@ -340,127 +333,7 @@ def copy_with(self, **kwargs: typing.Any) -> \"URL\":\n         url = httpx.URL(\"https://www.example.com\").copy_with(username=\"jo@gmail.com\", password=\"a secret\")\n         assert url == \"https://jo%40email.com:a%20secret@www.example.com\"\n         \"\"\"\n-        allowed = {\n-            \"scheme\": str,\n-            \"username\": str,\n-            \"password\": str,\n-            \"userinfo\": bytes,\n-            \"host\": str,\n-            \"port\": int,\n-            \"netloc\": bytes,\n-            \"path\": str,\n-            \"query\": bytes,\n-            \"raw_path\": bytes,\n-            \"fragment\": str,\n-            \"params\": object,\n-        }\n-\n-        # Step 1\n-        # ======\n-        #\n-        # Perform type checking for all supported keyword arguments.\n-        for key, value in kwargs.items():\n-            if key not in allowed:\n-                message = f\"{key!r} is an invalid keyword argument for copy_with()\"\n-                raise TypeError(message)\n-            if value is not None and not isinstance(value, allowed[key]):\n-                expected = allowed[key].__name__\n-                seen = type(value).__name__\n-                message = f\"Argument {key!r} must be {expected} but got {seen}\"\n-                raise TypeError(message)\n-\n-        # Step 2\n-        # ======\n-        #\n-        # Consolidate \"username\", \"password\", \"userinfo\", \"host\", \"port\" and \"netloc\"\n-        # into a single \"authority\" keyword, for `rfc3986`.\n-        if \"username\" in kwargs or \"password\" in kwargs:\n-            # Consolidate \"username\" and \"password\" into \"userinfo\".\n-            username = quote(kwargs.pop(\"username\", self.username) or \"\")\n-            password = quote(kwargs.pop(\"password\", self.password) or \"\")\n-            userinfo = f\"{username}:{password}\" if password else username\n-            kwargs[\"userinfo\"] = userinfo.encode(\"ascii\")\n-\n-        if \"host\" in kwargs or \"port\" in kwargs:\n-            # Consolidate \"host\" and \"port\" into \"netloc\".\n-            host = kwargs.pop(\"host\", self.host) or \"\"\n-            port = kwargs.pop(\"port\", self.port)\n-\n-            if host and \":\" in host and host[0] != \"[\":\n-                # IPv6 addresses need to be escaped within square brackets.\n-                host = f\"[{host}]\"\n-\n-            kwargs[\"netloc\"] = (\n-                f\"{host}:{port}\".encode(\"ascii\")\n-                if port is not None\n-                else host.encode(\"ascii\")\n-            )\n-\n-        if \"userinfo\" in kwargs or \"netloc\" in kwargs:\n-            # Consolidate \"userinfo\" and \"netloc\" into authority.\n-            userinfo = (kwargs.pop(\"userinfo\", self.userinfo) or b\"\").decode(\"ascii\")\n-            netloc = (kwargs.pop(\"netloc\", self.netloc) or b\"\").decode(\"ascii\")\n-            authority = f\"{userinfo}@{netloc}\" if userinfo else netloc\n-            kwargs[\"authority\"] = authority\n-\n-        # Step 3\n-        # ======\n-        #\n-        # Wrangle any \"path\", \"query\", \"raw_path\" and \"params\" keywords into\n-        # \"query\" and \"path\" keywords for `rfc3986`.\n-        if \"raw_path\" in kwargs:\n-            # If \"raw_path\" is included, then split it into \"path\" and \"query\" components.\n-            raw_path = kwargs.pop(\"raw_path\") or b\"\"\n-            path, has_query, query = raw_path.decode(\"ascii\").partition(\"?\")\n-            kwargs[\"path\"] = path\n-            kwargs[\"query\"] = query if has_query else None\n-\n-        else:\n-            if kwargs.get(\"path\") is not None:\n-                # Ensure `kwargs[\"path\"] = <url quoted str>` for `rfc3986`.\n-                kwargs[\"path\"] = quote(kwargs[\"path\"])\n-\n-            if kwargs.get(\"query\") is not None:\n-                # Ensure `kwargs[\"query\"] = <str>` for `rfc3986`.\n-                #\n-                # Note that `.copy_with(query=None)` and `.copy_with(query=b\"\")`\n-                # are subtly different. The `None` style will not include an empty\n-                # trailing \"?\" character.\n-                kwargs[\"query\"] = kwargs[\"query\"].decode(\"ascii\")\n-\n-            if \"params\" in kwargs:\n-                # Replace any \"params\" keyword with the raw \"query\" instead.\n-                #\n-                # Ensure that empty params use `kwargs[\"query\"] = None` rather\n-                # than `kwargs[\"query\"] = \"\"`, so that generated URLs do not\n-                # include an empty trailing \"?\".\n-                params = kwargs.pop(\"params\")\n-                kwargs[\"query\"] = None if not params else str(QueryParams(params))\n-\n-        # Step 4\n-        # ======\n-        #\n-        # Ensure any fragment component is quoted.\n-        if kwargs.get(\"fragment\") is not None:\n-            kwargs[\"fragment\"] = quote(kwargs[\"fragment\"])\n-\n-        # Step 5\n-        # ======\n-        #\n-        # At this point kwargs may include keys for \"scheme\", \"authority\", \"path\",\n-        # \"query\" and \"fragment\". Together these constitute the entire URL.\n-        #\n-        # See https://tools.ietf.org/html/rfc3986#section-3\n-        #\n-        #  foo://example.com:8042/over/there?name=ferret#nose\n-        #  \\_/   \\______________/\\_________/ \\_________/ \\__/\n-        #   |           |            |            |        |\n-        # scheme     authority       path        query   fragment\n-        new_url = URL(self)\n-        new_url._uri_reference = self._uri_reference.copy_with(**kwargs)\n-        if new_url.is_absolute_url:\n-            new_url._uri_reference = new_url._uri_reference.normalize()\n-        return URL(new_url)\n+        return URL(self, **kwargs)",
      "comment": "Note that our parameter checking moves into `__init__(...)` instead.",
      "comment_id": 886792776,
      "user": "lovelydinosaur",
      "created_at": "2022-06-01T13:15:17Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r886792776"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urls.py",
      "line": 362,
      "side": "RIGHT",
      "diff_hunk": "@@ -484,21 +357,9 @@ def join(self, url: URLTypes) -> \"URL\":\n         url = url.join(\"/new/path\")\n         assert url == \"https://www.example.com/new/path\"\n         \"\"\"\n-        if self.is_relative_url:\n-            # Workaround to handle relative URLs, which otherwise raise\n-            # rfc3986.exceptions.ResolutionError when used as an argument\n-            # in `.resolve_with`.\n-            return (\n-                self.copy_with(scheme=\"http\", host=\"example.com\")\n-                .join(url)\n-                .copy_with(scheme=None, host=None)\n-            )\n+        from urllib.parse import urljoin\n \n-        # We drop any fragment portion, because RFC 3986 strictly\n-        # treats URLs with a fragment portion as not being absolute URLs.\n-        base_uri = self._uri_reference.copy_with(fragment=None)\n-        relative_url = URL(url)\n-        return URL(relative_url._uri_reference.resolve_with(base_uri).unsplit())\n+        return URL(urljoin(str(self), str(URL(url))))",
      "comment": "We're just leaning on the stdlib's built-in implementation of `urljoin` now, but making sure to use our URL validation and normalisation first.",
      "comment_id": 886793608,
      "user": "lovelydinosaur",
      "created_at": "2022-06-01T13:16:04Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r886793608"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urls.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,76 +71,87 @@ class URL:\n     def __init__(\n         self, url: typing.Union[\"URL\", str] = \"\", **kwargs: typing.Any\n     ) -> None:\n+        if kwargs:\n+            allowed = {\n+                \"scheme\": str,\n+                \"username\": str,\n+                \"password\": str,\n+                \"userinfo\": bytes,\n+                \"host\": str,\n+                \"port\": int,\n+                \"netloc\": bytes,\n+                \"path\": str,\n+                \"query\": bytes,\n+                \"raw_path\": bytes,\n+                \"fragment\": str,\n+                \"params\": object,\n+            }\n+\n+            # Perform type checking for all supported keyword arguments.\n+            for key, value in kwargs.items():\n+                if key not in allowed:\n+                    message = f\"{key!r} is an invalid keyword argument for URL()\"\n+                    raise TypeError(message)\n+                if value is not None and not isinstance(value, allowed[key]):\n+                    expected = allowed[key].__name__\n+                    seen = type(value).__name__\n+                    message = f\"Argument {key!r} must be {expected} but got {seen}\"\n+                    raise TypeError(message)\n+                if isinstance(value, bytes):\n+                    kwargs[key] = value.decode(\"ascii\")",
      "comment": "Our `urlparse` implementation uses strings everywhere. If `bytes` are provided, then coerce to an ascii string.\r\n\r\nThis is internal detail, but there are some interesting public API considerations that this work has prompted, tho going to leave those as follow-up.",
      "comment_id": 886796756,
      "user": "lovelydinosaur",
      "created_at": "2022-06-01T13:18:49Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r886796756"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urls.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,76 +71,87 @@ class URL:\n     def __init__(\n         self, url: typing.Union[\"URL\", str] = \"\", **kwargs: typing.Any\n     ) -> None:\n+        if kwargs:\n+            allowed = {\n+                \"scheme\": str,\n+                \"username\": str,\n+                \"password\": str,\n+                \"userinfo\": bytes,\n+                \"host\": str,\n+                \"port\": int,\n+                \"netloc\": bytes,\n+                \"path\": str,\n+                \"query\": bytes,\n+                \"raw_path\": bytes,\n+                \"fragment\": str,\n+                \"params\": object,\n+            }\n+\n+            # Perform type checking for all supported keyword arguments.\n+            for key, value in kwargs.items():\n+                if key not in allowed:\n+                    message = f\"{key!r} is an invalid keyword argument for URL()\"\n+                    raise TypeError(message)\n+                if value is not None and not isinstance(value, allowed[key]):\n+                    expected = allowed[key].__name__\n+                    seen = type(value).__name__\n+                    message = f\"Argument {key!r} must be {expected} but got {seen}\"\n+                    raise TypeError(message)\n+                if isinstance(value, bytes):\n+                    kwargs[key] = value.decode(\"ascii\")\n+\n+            if \"raw_path\" in kwargs:\n+                kwargs[\"full_path\"] = kwargs.pop(\"raw_path\")\n+\n+            if \"params\" in kwargs:\n+                # Replace any \"params\" keyword with the raw \"query\" instead.\n+                #\n+                # Ensure that empty params use `kwargs[\"query\"] = None` rather\n+                # than `kwargs[\"query\"] = \"\"`, so that generated URLs do not\n+                # include an empty trailing \"?\".\n+                params = kwargs.pop(\"params\")\n+                kwargs[\"query\"] = None if not params else str(QueryParams(params))",
      "comment": "The \"params\" argument isn't used but the `urlparse` implementation, because the `QueryParams` model doesn't exist at that level of abstraction.",
      "comment_id": 886797472,
      "user": "lovelydinosaur",
      "created_at": "2022-06-01T13:19:32Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r886797472"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urlparse.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,435 @@\n+\"\"\"\n+An implementation of `urlparse` that provides URL validation and normalization\n+as described by RFC3986.\n+\n+We rely on this implementation rather than the one in Python's stdlib, because:\n+\n+* It provides more complete URL validation.\n+* It properly differentiates between an empty querystring and an absent querystring,\n+  to distinguish URLs with a trailing '?'.\n+* It handles scheme, hostname, port, and path normalization.\n+* It supports IDNA hostnames, normalizing them to their encoded form.\n+* The API supports passing individual components, as well as the complete URL string.\n+\n+Previously we relied on the excellent `rfc3986` package to handle URL parsing and\n+validation, but this module provides a simpler alternative, with less indirection\n+required.\n+\"\"\"\n+import ipaddress\n+import re\n+import typing\n+\n+import idna\n+\n+from ._exceptions import InvalidURL\n+\n+MAX_URL_LENGTH = 65536\n+\n+# https://datatracker.ietf.org/doc/html/rfc3986.html#section-2.3\n+UNRESERVED_CHARACTERS = (\n+    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\"\n+)\n+SUB_DELIMS = \"!$&'()*+,;=\"\n+\n+PERCENT_ENCODED_REGEX = re.compile(\"%[A-Fa-f0-9]{2}\")\n+\n+\n+# {scheme}:      (optional)\n+# //{authority}  (optional)\n+# {path}\n+# ?{query}       (optional)\n+# #{fragment}    (optional)\n+URL_REGEX = re.compile(\n+    (\n+        r\"(?:(?P<scheme>{scheme}):)?\"\n+        r\"(?://(?P<authority>{authority}))?\"\n+        r\"(?P<path>{path})\"\n+        r\"(?:\\?(?P<query>{query}))?\"\n+        r\"(?:#(?P<fragment>{fragment}))?\"\n+    ).format(\n+        scheme=\"([a-zA-Z][a-zA-Z0-9+.-]*)?\",\n+        authority=\"[^/?#]*\",\n+        path=\"[^?#]*\",\n+        query=\"[^#]*\",\n+        fragment=\".*\",\n+    )\n+)\n+",
      "comment": "I just want to point out, I love love LOVE using format strings to improve readability and maintainability of regex.",
      "comment_id": 906862566,
      "user": "xkortex",
      "created_at": "2022-06-26T19:39:48Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r906862566"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urls.py",
      "line": 384,
      "side": "RIGHT",
      "diff_hunk": "@@ -507,21 +365,33 @@ def __eq__(self, other: typing.Any) -> bool:\n         return isinstance(other, (URL, str)) and str(self) == str(URL(other))\n \n     def __str__(self) -> str:\n-        return self._uri_reference.unsplit()\n+        return str(self._uri_reference)\n \n     def __repr__(self) -> str:\n-        class_name = self.__class__.__name__\n-        url_str = str(self)\n-        if self._uri_reference.userinfo:\n-            # Mask any password component in the URL representation, to lower the\n-            # risk of unintended leakage, such as in debug information and logging.\n-            username = quote(self.username)\n-            url_str = (\n-                rfc3986.urlparse(url_str)\n-                .copy_with(userinfo=f\"{username}:[secure]\")\n-                .unsplit()\n-            )\n-        return f\"{class_name}({url_str!r})\"\n+        scheme, userinfo, host, port, path, query, fragment = self._uri_reference\n+\n+        if \":\" in userinfo:\n+            # Mask any password component.\n+            userinfo = f'{userinfo.split(\":\")[0]}:[secure]'\n+\n+        authority = \"\".join(\n+            [\n+                f\"{userinfo}@\" if userinfo else \"\",\n+                f\"[{host}]\" if \":\" in host else host,\n+                f\":{port}\" if port is not None else \"\",\n+            ]\n+        )\n+        url = \"\".join(",
      "comment": "Question: could this just be str(self._url_reference)? Just curious what the implications are of the different rendering methods are. I think it'd be more parsimonious to have a single URL->str but I could see this being a backwards-compat thing.",
      "comment_id": 906863406,
      "user": "xkortex",
      "created_at": "2022-06-26T19:48:46Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r906863406"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urls.py",
      "line": 384,
      "side": "RIGHT",
      "diff_hunk": "@@ -507,21 +365,33 @@ def __eq__(self, other: typing.Any) -> bool:\n         return isinstance(other, (URL, str)) and str(self) == str(URL(other))\n \n     def __str__(self) -> str:\n-        return self._uri_reference.unsplit()\n+        return str(self._uri_reference)\n \n     def __repr__(self) -> str:\n-        class_name = self.__class__.__name__\n-        url_str = str(self)\n-        if self._uri_reference.userinfo:\n-            # Mask any password component in the URL representation, to lower the\n-            # risk of unintended leakage, such as in debug information and logging.\n-            username = quote(self.username)\n-            url_str = (\n-                rfc3986.urlparse(url_str)\n-                .copy_with(userinfo=f\"{username}:[secure]\")\n-                .unsplit()\n-            )\n-        return f\"{class_name}({url_str!r})\"\n+        scheme, userinfo, host, port, path, query, fragment = self._uri_reference\n+\n+        if \":\" in userinfo:\n+            # Mask any password component.\n+            userinfo = f'{userinfo.split(\":\")[0]}:[secure]'\n+\n+        authority = \"\".join(\n+            [\n+                f\"{userinfo}@\" if userinfo else \"\",\n+                f\"[{host}]\" if \":\" in host else host,\n+                f\":{port}\" if port is not None else \"\",\n+            ]\n+        )\n+        url = \"\".join(",
      "comment": "Right now we're doing this here because we need to mask the password for `__repr__`, but not for the `__str__`.\r\n\r\nWe could perhaps simplify a little by having a `to_string(mask_password: bool)` method on the `ParseResult` class.\r\n",
      "comment_id": 907152909,
      "user": "lovelydinosaur",
      "created_at": "2022-06-27T09:06:03Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r907152909"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urls.py",
      "line": 384,
      "side": "RIGHT",
      "diff_hunk": "@@ -507,21 +365,33 @@ def __eq__(self, other: typing.Any) -> bool:\n         return isinstance(other, (URL, str)) and str(self) == str(URL(other))\n \n     def __str__(self) -> str:\n-        return self._uri_reference.unsplit()\n+        return str(self._uri_reference)\n \n     def __repr__(self) -> str:\n-        class_name = self.__class__.__name__\n-        url_str = str(self)\n-        if self._uri_reference.userinfo:\n-            # Mask any password component in the URL representation, to lower the\n-            # risk of unintended leakage, such as in debug information and logging.\n-            username = quote(self.username)\n-            url_str = (\n-                rfc3986.urlparse(url_str)\n-                .copy_with(userinfo=f\"{username}:[secure]\")\n-                .unsplit()\n-            )\n-        return f\"{class_name}({url_str!r})\"\n+        scheme, userinfo, host, port, path, query, fragment = self._uri_reference\n+\n+        if \":\" in userinfo:\n+            # Mask any password component.\n+            userinfo = f'{userinfo.split(\":\")[0]}:[secure]'\n+\n+        authority = \"\".join(\n+            [\n+                f\"{userinfo}@\" if userinfo else \"\",\n+                f\"[{host}]\" if \":\" in host else host,\n+                f\":{port}\" if port is not None else \"\",\n+            ]\n+        )\n+        url = \"\".join(",
      "comment": "Ohhhh right, because of this, right? https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.1\r\n\r\n> We could perhaps simplify a little by having a to_string(mask_password: bool) method on the ParseResult class.\r\n\r\nThat also sounds reasonable, if it were my codebase, I'd prefer that. Not a big deal either way (obviously not my call here :) ). \r\n\r\n>  we need to mask the password for __repr__, but not for the __str__\r\n\r\nThis is indeed the current behavior of httpx, but boy does that bug me, that the `repr` of a user info string doesn't convert back to even a correct URL, let alone the equivalent URL.  \r\n```\r\nu = httpx.URL('http://user:hunter2@example.com')\r\nu\r\nOut[10]: URL('http://user:[secure]@example.com')\r\nstr(u)\r\nOut[11]: 'http://user:hunter2@example.com'\r\nhttpx.URL('http://user:[secure]@example.com')\r\nOut[12]: URL('http:')\r\n```\r\n\r\nI think it would be better if it didn't use square braces to elide the password, since that screws up later parses, but that's beyond the purview of this PR, so... `\u00af\\_(\u30c4)_/\u00af`  ",
      "comment_id": 907469214,
      "user": "xkortex",
      "created_at": "2022-06-27T14:41:37Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r907469214"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2252,
      "file_path": "httpx/_urls.py",
      "line": 384,
      "side": "RIGHT",
      "diff_hunk": "@@ -507,21 +365,33 @@ def __eq__(self, other: typing.Any) -> bool:\n         return isinstance(other, (URL, str)) and str(self) == str(URL(other))\n \n     def __str__(self) -> str:\n-        return self._uri_reference.unsplit()\n+        return str(self._uri_reference)\n \n     def __repr__(self) -> str:\n-        class_name = self.__class__.__name__\n-        url_str = str(self)\n-        if self._uri_reference.userinfo:\n-            # Mask any password component in the URL representation, to lower the\n-            # risk of unintended leakage, such as in debug information and logging.\n-            username = quote(self.username)\n-            url_str = (\n-                rfc3986.urlparse(url_str)\n-                .copy_with(userinfo=f\"{username}:[secure]\")\n-                .unsplit()\n-            )\n-        return f\"{class_name}({url_str!r})\"\n+        scheme, userinfo, host, port, path, query, fragment = self._uri_reference\n+\n+        if \":\" in userinfo:\n+            # Mask any password component.\n+            userinfo = f'{userinfo.split(\":\")[0]}:[secure]'\n+\n+        authority = \"\".join(\n+            [\n+                f\"{userinfo}@\" if userinfo else \"\",\n+                f\"[{host}]\" if \":\" in host else host,\n+                f\":{port}\" if port is not None else \"\",\n+            ]\n+        )\n+        url = \"\".join(",
      "comment": "> I think it would be better if it didn't use square braces to elide the password, since that screws up later parses, but that's beyond the purview of this PR\r\n\r\nHrm, yes, we could certainly reconsider that. As you say tho, we'd do so independently of this pull request.",
      "comment_id": 933312779,
      "user": "lovelydinosaur",
      "created_at": "2022-07-29T14:09:27Z",
      "url": "https://github.com/encode/httpx/pull/2252#discussion_r933312779"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "tests/test_multipart.py",
      "line": 100,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,6 +42,64 @@ def test_multipart(value, output):\n     assert multipart[\"file\"] == [b\"<file content>\"]\n \n \n+@pytest.mark.parametrize(\n+    \"header\",\n+    [\n+        \"multipart/form-data; boundary=+++; charset=utf-8\",\n+        \"multipart/form-data; charset=utf-8; boundary=+++\",\n+        \"multipart/form-data; boundary=+++\",\n+        \"multipart/form-data; boundary=+++ ;\",\n+    ],\n+)\n+def test_multipart_explicit_boundary(header: str) -> None:\n+    client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n+\n+    files = {\"file\": io.BytesIO(b\"<file content>\")}\n+    headers = {\"content-type\": header}\n+    response = client.post(\"http://127.0.0.1:8000/\", files=files, headers=headers)\n+    assert response.status_code == 200\n+\n+    # We're using the cgi module to verify the behavior here, which is a\n+    # bit grungy, but sufficient just for our testing purposes.\n+    assert response.request.headers[\"Content-Type\"] == header\n+    content_length = response.request.headers[\"Content-Length\"]\n+    pdict: dict = {\n+        \"boundary\": b\"+++\",\n+        \"CONTENT-LENGTH\": content_length,\n+    }\n+    multipart = cgi.parse_multipart(io.BytesIO(response.content), pdict)\n+\n+    assert multipart[\"file\"] == [b\"<file content>\"]\n+\n+\n+@pytest.mark.parametrize(\n+    \"header\",\n+    [\n+        \"multipart/form-data; charset=utf-8\",\n+        \"multipart/form-data; charset=utf-8; \",\n+    ],\n+)\n+def test_multipart_header_without_boundary(header: str) -> None:\n+    client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n+\n+    files = {\"file\": io.BytesIO(b\"<file content>\")}\n+    headers = {\"content-type\": header}\n+    response = client.post(\"http://127.0.0.1:8000/\", files=files, headers=headers)\n+    assert response.status_code == 200\n+\n+    # We're using the cgi module to verify the behavior here, which is a\n+    # bit grungy, but sufficient just for our testing purposes.\n+    boundary = response.request.headers[\"Content-Type\"].split(\"boundary=\")[-1]\n+    content_length = response.request.headers[\"Content-Length\"]\n+    pdict: dict = {\n+        \"boundary\": boundary.encode(\"ascii\"),\n+        \"CONTENT-LENGTH\": content_length,\n+    }\n+    multipart = cgi.parse_multipart(io.BytesIO(response.content), pdict)\n+\n+    assert multipart[\"file\"] == [b\"<file content>\"]",
      "comment": "This test is fails on main/master as well, but I think it would be important to fix in this PR. What needs to happen is we need to create the random boundary and then insert that into the existing header. The issue is that there is currently no machinery / precedent for `encode_request()` modifying headers, so it would take a bit more refactoring to get working. Alternatively, we can raise an error if a user gives us a `content-type: multipart/form-data` without an explicit header?",
      "comment_id": 905240480,
      "user": "adriangb",
      "created_at": "2022-06-23T16:33:10Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r905240480"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_content.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,6 +198,7 @@ def encode_request(\n     files: Optional[RequestFiles] = None,\n     json: Optional[Any] = None,\n     boundary: Optional[bytes] = None,\n+    headers: Optional[Mapping[str, str]] = None,",
      "comment": "How about we keep things a little tighter here by passing `content_type: str = None` instead? That restricts the information we're passing around to the one thing we're actually interested in.",
      "comment_id": 905940496,
      "user": "lovelydinosaur",
      "created_at": "2022-06-24T10:35:58Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r905940496"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,16 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: str,\n+) -> bytes:\n+    if \";\" in content_type:\n+        for section in content_type.split(\";\"):\n+            if section.strip().startswith(\"boundary=\"):\n+                return section.strip().split(\"boundary=\")[-1].encode(\"latin-1\")\n+    raise ValueError(\"Missing boundary in multipart/form-data content-type header\")",
      "comment": "Instead of raising `ValueError` we could just return `None` if the content type doesn't start with \"multipart/form-data\", or doesn't include a valid boundary.\r\n\r\n(Users can currently submit requests with `Content-Type` headers that don't properly match up to the data they include, so just being lax here seems okay to me.)",
      "comment_id": 905947972,
      "user": "lovelydinosaur",
      "created_at": "2022-06-24T10:47:18Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r905947972"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_content.py",
      "line": 161,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,11 +151,21 @@ def encode_urlencoded_data(\n \n \n def encode_multipart_data(\n-    data: dict, files: RequestFiles, boundary: Optional[bytes] = None\n+    data: dict,\n+    files: RequestFiles,\n+    boundary: Optional[bytes] = None,\n+    headers: Optional[Mapping[str, str]] = None,\n ) -> Tuple[Dict[str, str], MultipartStream]:\n+    if headers and boundary is None and \"content-type\" in headers:\n+        content_type = headers[\"content-type\"]\n+        if not content_type.startswith(\"multipart/form-data\"):",
      "comment": "I think we could drop this case, as with [this comment](https://github.com/encode/httpx/pull/2278/files#r905947972).",
      "comment_id": 905948476,
      "user": "lovelydinosaur",
      "created_at": "2022-06-24T10:48:07Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r905948476"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,16 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: str,\n+) -> bytes:\n+    if \";\" in content_type:\n+        for section in content_type.split(\";\"):\n+            if section.strip().startswith(\"boundary=\"):\n+                return section.strip().split(\"boundary=\")[-1].encode(\"latin-1\")\n+    raise ValueError(\"Missing boundary in multipart/form-data content-type header\")",
      "comment": "Note that since `content-type` gets set [via `setdefault`](https://github.com/encode/httpx/blob/aad60a4f123801e7ce0e02bc49138e7f0f9ca0a5/httpx/_models.py#L362). If it already exists, it won't be overwritten. So in the case where the user provided the `content-type` header but did not provide the multipart boundary we'd be sending out a request with no multipart boundary, which completely violates the spec and no server will be able to parse.",
      "comment_id": 906733887,
      "user": "adriangb",
      "created_at": "2022-06-25T23:17:15Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r906733887"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,16 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: str,\n+) -> bytes:\n+    if \";\" in content_type:\n+        for section in content_type.split(\";\"):\n+            if section.strip().startswith(\"boundary=\"):\n+                return section.strip().split(\"boundary=\")[-1].encode(\"latin-1\")\n+    raise ValueError(\"Missing boundary in multipart/form-data content-type header\")",
      "comment": "> So in the case where the user provided the content-type header but did not provide the multipart boundary we'd be sending out a request with no multipart boundary, which completely violates the spec and no server will be able to parse.\r\n\r\nTrue. We could either hard-error in that case, or just ignore it and allow users to do that.\r\n\r\nThere is also a whole class of cases here where a user can set a `Content-Type` that doesn't match the encoding type they're using with `data=`/`files=`/`json=`. (Eg. they can set `Content-Type: application/json` on either form or multipart requests.) But that's probably okay.\r\n\r\n\r\n\r\n",
      "comment_id": 907177499,
      "user": "lovelydinosaur",
      "created_at": "2022-06-27T09:30:20Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r907177499"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_content.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,11 +150,16 @@ def encode_urlencoded_data(\n \n \n def encode_multipart_data(\n-    data: dict, files: RequestFiles, boundary: Optional[bytes] = None\n+    data: dict,\n+    files: RequestFiles,\n+    boundary: Optional[bytes] = None,\n+    content_type: Optional[str] = None,\n ) -> Tuple[Dict[str, str], MultipartStream]:\n+    if content_type:\n+        boundary = get_multipart_boundary_from_content_type(content_type)",
      "comment": "Shouldn't we check that `boundary is None` before computing `boundary`? (In other words, what happens when `content_type` and `boundary` do not agree on the value to use for `boundary`?)",
      "comment_id": 945183299,
      "user": "jhominal",
      "created_at": "2022-08-13T19:44:33Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945183299"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_content.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,11 +150,16 @@ def encode_urlencoded_data(\n \n \n def encode_multipart_data(\n-    data: dict, files: RequestFiles, boundary: Optional[bytes] = None\n+    data: dict,\n+    files: RequestFiles,\n+    boundary: Optional[bytes] = None,\n+    content_type: Optional[str] = None,\n ) -> Tuple[Dict[str, str], MultipartStream]:\n+    if content_type:\n+        boundary = get_multipart_boundary_from_content_type(content_type)",
      "comment": "We're the only ones ever making the call into this function and we never call it with a mismatch. If I add the error I would either have to (1) add a test just to check the error or (2) pragma: no cover it. I'll add a comment instead.",
      "comment_id": 945184522,
      "user": "adriangb",
      "created_at": "2022-08-13T20:00:32Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945184522"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_content.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,11 +150,16 @@ def encode_urlencoded_data(\n \n \n def encode_multipart_data(\n-    data: dict, files: RequestFiles, boundary: Optional[bytes] = None\n+    data: dict,\n+    files: RequestFiles,\n+    boundary: Optional[bytes] = None,\n+    content_type: Optional[str] = None,\n ) -> Tuple[Dict[str, str], MultipartStream]:\n+    if content_type:\n+        boundary = get_multipart_boundary_from_content_type(content_type)",
      "comment": "Shouldn't the `get_multipart_boundary_from_content_type` call be made upstream? e.g. in httpx/_models.py?",
      "comment_id": 945184797,
      "user": "jhominal",
      "created_at": "2022-08-13T20:03:24Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945184797"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_models.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -332,7 +332,13 @@ def __init__(\n             Cookies(cookies).set_cookie_header(self)\n \n         if stream is None:\n-            headers, stream = encode_request(content, data, files, json)\n+            headers, stream = encode_request(\n+                content=content,\n+                data=data,\n+                files=files,\n+                json=json,\n+                content_type=self.headers.get(\"content-type\"),\n+            )",
      "comment": "By the comment on the other thread, I mean, why not write:\r\n```suggestion\r\n            headers, stream = encode_request(\r\n                content=content,\r\n                data=data,\r\n                files=files,\r\n                json=json,\r\n                boundary= get_multipart_boundary_from_content_type(self.headers.get(\"content-type\")),\r\n            )\r\n```\r\n\r\nThat way, we do not have function signatures that have both a `boundary` and a `content_type` that could possibly have contradictory data?",
      "comment_id": 945184961,
      "user": "jhominal",
      "created_at": "2022-08-13T20:06:12Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945184961"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_models.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -332,7 +332,13 @@ def __init__(\n             Cookies(cookies).set_cookie_header(self)\n \n         if stream is None:\n-            headers, stream = encode_request(content, data, files, json)\n+            headers, stream = encode_request(\n+                content=content,\n+                data=data,\n+                files=files,\n+                json=json,\n+                content_type=self.headers.get(\"content-type\"),\n+            )",
      "comment": "By which I mean, the `content_type` argument could be removed from `encode_request` and `encode_multipart_data`?",
      "comment_id": 945185034,
      "user": "jhominal",
      "created_at": "2022-08-13T20:07:03Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945185034"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_content.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,11 +150,16 @@ def encode_urlencoded_data(\n \n \n def encode_multipart_data(\n-    data: dict, files: RequestFiles, boundary: Optional[bytes] = None\n+    data: dict,\n+    files: RequestFiles,\n+    boundary: Optional[bytes] = None,\n+    content_type: Optional[str] = None,\n ) -> Tuple[Dict[str, str], MultipartStream]:\n+    if content_type:\n+        boundary = get_multipart_boundary_from_content_type(content_type)",
      "comment": "I think _should_ would be a bit strong of a word, we certainly _could_ do that. I think the main reason for having it here is that `_models.py` doesn't know about multipart request or other encoding stuff, so it would be a bit of a violation of the layering that is currently set up to put something like `if content_type.startswith(\"multipart/form-data\")`: <do multipart specific stuff>`.",
      "comment_id": 945185173,
      "user": "adriangb",
      "created_at": "2022-08-13T20:08:37Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945185173"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_content.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,11 +150,16 @@ def encode_urlencoded_data(\n \n \n def encode_multipart_data(\n-    data: dict, files: RequestFiles, boundary: Optional[bytes] = None\n+    data: dict,\n+    files: RequestFiles,\n+    boundary: Optional[bytes] = None,\n+    content_type: Optional[str] = None,\n ) -> Tuple[Dict[str, str], MultipartStream]:\n+    if content_type:\n+        boundary = get_multipart_boundary_from_content_type(content_type)",
      "comment": "No need to apologize for a good suggestion \ud83d\ude04 \r\nLike I said I'm open to it, but I do feel that it breaks a bit with the way abstractions are currently set up in the codebase",
      "comment_id": 945185588,
      "user": "adriangb",
      "created_at": "2022-08-13T20:13:18Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945185588"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_models.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -332,7 +332,13 @@ def __init__(\n             Cookies(cookies).set_cookie_header(self)\n \n         if stream is None:\n-            headers, stream = encode_request(content, data, files, json)\n+            headers, stream = encode_request(\n+                content=content,\n+                data=data,\n+                files=files,\n+                json=json,\n+                content_type=self.headers.get(\"content-type\"),\n+            )",
      "comment": "Okay I liked it once I wrote it, I think given that `encode_request` already takes a `boundary` parameter (which only makes sense in the context of multipart requests) moving the call to where you are suggesting is not a big deal",
      "comment_id": 945185780,
      "user": "adriangb",
      "created_at": "2022-08-13T20:15:59Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945185780"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_models.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -332,7 +332,13 @@ def __init__(\n             Cookies(cookies).set_cookie_header(self)\n \n         if stream is None:\n-            headers, stream = encode_request(content, data, files, json)\n+            headers, stream = encode_request(\n+                content=content,\n+                data=data,\n+                files=files,\n+                json=json,\n+                content_type=self.headers.get(\"content-type\"),\n+            )",
      "comment": "Yes, that kind of was my thought (if `encode_request` did not have `boundary` I would not have suggested that). Thank you for accepting my suggestion.\r\n\r\nI just wonder if you would also go also look at potentially reviewing the remaining changes in `httpx/_content.py`? I mean, these changes seem mostly vestigial to me (e.g. the `content_type` in `encode_request`, and the changes in `encode_multipart_data` are now purely of variable and formatting (and `boundary` is now a required argument)",
      "comment_id": 945186211,
      "user": "jhominal",
      "created_at": "2022-08-13T20:20:56Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945186211"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,18 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: typing.Optional[str],\n+) -> typing.Optional[bytes]:\n+    if not content_type or not content_type.startswith(\"multipart/form-data\"):\n+        return None\n+    if \";\" in content_type:\n+        for section in content_type.split(\";\"):\n+            if section.strip().startswith(\"boundary=\"):\n+                return section.strip().split(\"boundary=\")[-1].encode(\"latin-1\")",
      "comment": "Is there any possibility that `boundary` could be quoted, with either simple or double quotes?",
      "comment_id": 945186645,
      "user": "jhominal",
      "created_at": "2022-08-13T20:26:29Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945186645"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,18 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: typing.Optional[str],\n+) -> typing.Optional[bytes]:\n+    if not content_type or not content_type.startswith(\"multipart/form-data\"):\n+        return None\n+    if \";\" in content_type:\n+        for section in content_type.split(\";\"):\n+            if section.strip().startswith(\"boundary=\"):\n+                return section.strip().split(\"boundary=\")[-1].encode(\"latin-1\")",
      "comment": "[RFC 2046](https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1) has examples where boundary is contained in quotes. Do we want to support that?",
      "comment_id": 945186942,
      "user": "jhominal",
      "created_at": "2022-08-13T20:30:19Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945186942"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,18 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: typing.Optional[str],\n+) -> typing.Optional[bytes]:\n+    if not content_type or not content_type.startswith(\"multipart/form-data\"):\n+        return None\n+    if \";\" in content_type:\n+        for section in content_type.split(\";\"):\n+            if section.strip().startswith(\"boundary=\"):\n+                return section.strip().split(\"boundary=\")[-1].encode(\"latin-1\")",
      "comment": "Great catch! Not sure how you find these things but thank you",
      "comment_id": 945209881,
      "user": "adriangb",
      "created_at": "2022-08-13T23:56:04Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945209881"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,18 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: typing.Optional[str],\n+) -> typing.Optional[bytes]:\n+    if not content_type or not content_type.startswith(\"multipart/form-data\"):\n+        return None\n+    if \";\" in content_type:\n+        for section in content_type.split(\";\"):\n+            if section.strip().startswith(\"boundary=\"):\n+                return section.strip().split(\"boundary=\")[-1].encode(\"latin-1\")",
      "comment": "After reviewing the grammar for boundary ([RFC 2046 Appendix A](https://www.rfc-editor.org/rfc/rfc2046#page-43), referencing [RFC 2045 \u00a75.1](https://www.rfc-editor.org/rfc/rfc2045#section-5.1), referencing [RFC 822 \u00a73.3](https://www.rfc-editor.org/rfc/rfc822#section-3.3) which has been replaced by [RFC 5322 \u00a73.2.4](https://www.rfc-editor.org/rfc/rfc5322#section-3.2.4)):\r\n\r\n1. The only quoting character that seems to be valid is the double quote `\"` (`'` is not valid for that usage);\r\n2. However, when the double quote is in use, any backslash `\\` will be part of a \"quoted pair\", meaning that it is semantically equivalent to the next character (`\\\\` => `\\`, `\\\"` => `\"`);\r\n3. However, there is a limitation on allowed characters in a boundary - none of the characters that would require a quoted pair escape are allowed in a boundary;\r\n\r\nIn other words:\r\n * We need to handle only `\"` for quoting;\r\n * We also need to decide what to do about quoted pairs:\r\n   * Either we write a simpler implementation that does not handle them, as all legal boundaries can be written without using quoted pairs;\r\n   * Or we go the extra mile of supporting quoted pairs;\r\n * What do we want to do about the fact that not all ascii characters are allowed as part of a boundary?",
      "comment_id": 945285489,
      "user": "jhominal",
      "created_at": "2022-08-14T12:50:56Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945285489"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,18 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: typing.Optional[str],\n+) -> typing.Optional[bytes]:\n+    if not content_type or not content_type.startswith(\"multipart/form-data\"):\n+        return None\n+    if \";\" in content_type:\n+        for section in content_type.split(\";\"):\n+            if section.strip().startswith(\"boundary=\"):\n+                return section.strip().split(\"boundary=\")[-1].encode(\"latin-1\")",
      "comment": "I think we can go with the simpler implementation. I also don't think we need to handle non-valid characters, that'd be too much introspection ",
      "comment_id": 945291083,
      "user": "adriangb",
      "created_at": "2022-08-14T13:32:51Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945291083"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,18 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: typing.Optional[str],\n+) -> typing.Optional[bytes]:\n+    if not content_type or not content_type.startswith(\"multipart/form-data\"):\n+        return None\n+    if \";\" in content_type:\n+        for section in content_type.split(\";\"):\n+            if section.strip().startswith(\"boundary=\"):\n+                return section.strip().split(\"boundary=\")[-1].encode(\"latin-1\")",
      "comment": "I just removed the `'` stripping, which I think now makes this able to parse any boundary except the ones with quoted pairs (valid but never necessary).",
      "comment_id": 945728832,
      "user": "adriangb",
      "created_at": "2022-08-15T13:22:20Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945728832"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "httpx/_multipart.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,20 @@\n )\n \n \n+def get_multipart_boundary_from_content_type(\n+    content_type: typing.Optional[bytes],\n+) -> typing.Optional[bytes]:\n+    if not content_type or not content_type.startswith(b\"multipart/form-data\"):\n+        return None\n+    # parse boundary according to\n+    # https://www.rfc-editor.org/rfc/rfc2046#section-5.1.1\n+    if b\";\" in content_type:\n+        for section in content_type.split(b\";\"):\n+            if section.strip().startswith(b\"boundary=\"):\n+                return section.strip().split(b\"boundary=\")[-1].strip(b'\"')",
      "comment": "```suggestion\r\n            if section.strip().lower().startswith(b\"boundary=\"):\r\n                return section.strip()[len(b\"boundary=\"):].strip(b'\"')\r\n```\r\n\r\nI am making this suggestion to solve two things I see as issues (you can argue that these are niche edge cases, but I think that the changes I suggest are reasonable) with the current implementation:\r\n\r\n 1. As indicated in [RFC 2045](https://www.rfc-editor.org/rfc/rfc2045#section-5.1), matching of attributes (of which `boundary` is one) is always case insensitive (thus `BOUNDARY=\"abcd\"` would also work) - so I have added a call to `lower()` on line 32;\r\n 2. The implementation with `split` will fail on a boundary that contains the `boundary=` substring. I think the intent is clearer if we write code that simply removes the prefix, and also reduces the number of potential edge cases;",
      "comment_id": 945822783,
      "user": "jhominal",
      "created_at": "2022-08-15T14:44:39Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r945822783"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2278,
      "file_path": "tests/test_multipart.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,6 +42,58 @@ def test_multipart(value, output):\n     assert multipart[\"file\"] == [b\"<file content>\"]\n \n \n+@pytest.mark.parametrize(\n+    \"header\",\n+    [\n+        \"multipart/form-data; boundary=+++; charset=utf-8\",\n+        \"multipart/form-data; charset=utf-8; boundary=+++\",\n+        \"multipart/form-data; boundary=+++\",\n+        \"multipart/form-data; boundary=+++ ;\",\n+        'multipart/form-data; boundary=\"+++\"; charset=utf-8',\n+        'multipart/form-data; charset=utf-8; boundary=\"+++\"',\n+        'multipart/form-data; boundary=\"+++\"',\n+        'multipart/form-data; boundary=\"+++\" ;',\n+    ],\n+)\n+def test_multipart_explicit_boundary(header: str) -> None:\n+    client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n+\n+    files = {\"file\": io.BytesIO(b\"<file content>\")}\n+    headers = {\"content-type\": header}\n+    response = client.post(\"http://127.0.0.1:8000/\", files=files, headers=headers)\n+    assert response.status_code == 200\n+\n+    # We're using the cgi module to verify the behavior here, which is a\n+    # bit grungy, but sufficient just for our testing purposes.\n+    assert response.request.headers[\"Content-Type\"] == header\n+    content_length = response.request.headers[\"Content-Length\"]\n+    pdict: dict = {\n+        \"boundary\": b\"+++\",\n+        \"CONTENT-LENGTH\": content_length,\n+    }\n+    multipart = cgi.parse_multipart(io.BytesIO(response.content), pdict)\n+\n+    assert multipart[\"file\"] == [b\"<file content>\"]\n+\n+\n+@pytest.mark.parametrize(\n+    \"header\",\n+    [\n+        \"multipart/form-data; charset=utf-8\",\n+        \"multipart/form-data; charset=utf-8; \",\n+    ],\n+)\n+def test_multipart_header_without_boundary(header: str) -> None:\n+    client = httpx.Client(transport=httpx.MockTransport(echo_request_content))\n+\n+    files = {\"file\": io.BytesIO(b\"<file content>\")}\n+    headers = {\"content-type\": header}\n+    response = client.post(\"http://127.0.0.1:8000/\", files=files, headers=headers)\n+\n+    assert response.status_code == 200\n+    assert response.request.headers[\"Content-Type\"] == header",
      "comment": "@adriangb Shouldn't it provide autogenerated boundary in the header ? Seems like it causes this [issue](https://github.com/encode/httpx/issues/3522) ?",
      "comment_id": 1977589495,
      "user": "Anton-Shutik",
      "created_at": "2025-03-03T14:15:18Z",
      "url": "https://github.com/encode/httpx/pull/2278#discussion_r1977589495"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3371,
      "file_path": "tests/models/test_url.py",
      "line": 620,
      "side": "RIGHT",
      "diff_hunk": "@@ -614,10 +614,10 @@ def test_url_copywith_userinfo_subcomponents():\n     }\n     url = httpx.URL(\"https://example.org\")\n     new = url.copy_with(**copy_with_kwargs)\n-    assert str(new) == \"https://tom%40example.org:abc123%40%20%25@example.org\"\n+    assert str(new) == \"https://tom%40example.org:abc123%40%20%@example.org\"\n     assert new.username == \"tom@example.org\"\n     assert new.password == \"abc123@ %\"\n-    assert new.userinfo == b\"tom%40example.org:abc123%40%20%25\"\n+    assert new.userinfo == b\"tom%40example.org:abc123%40%20%\"",
      "comment": "This looks weird. I could be wrong. But should the userinfo field contain partial escapes? The trialing % sign change here seem odd. \r\n\r\n",
      "comment_id": 1895670033,
      "user": "elupus",
      "created_at": "2024-12-23T11:57:19Z",
      "url": "https://github.com/encode/httpx/pull/3371#discussion_r1895670033"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2911,
      "file_path": "httpx/_models.py",
      "line": 766,
      "side": "LEFT",
      "diff_hunk": "@@ -759,11 +758,7 @@ def raise_for_status(self) -> \"Response\":\n         raise HTTPStatusError(message, request=request, response=self)\n \n     def json(self, **kwargs: typing.Any) -> typing.Any:\n-        if self.charset_encoding is None and self.content and len(self.content) > 3:\n-            encoding = guess_json_utf(self.content)\n-            if encoding is not None:\n-                return jsonlib.loads(self.content.decode(encoding), **kwargs)\n-        return jsonlib.loads(self.text, **kwargs)",
      "comment": "Just a random thing I noticed looking through the code, not a problem I've seen in the wild: isn't using `self.text` like this this better than the new version when there's a non-utf charset?",
      "comment_id": 1890475281,
      "user": "alexmojaki",
      "created_at": "2024-12-18T15:56:52Z",
      "url": "https://github.com/encode/httpx/pull/2911#discussion_r1890475281"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3367,
      "file_path": "tests/test_content.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,6 +4,7 @@\n import pytest\n \n import httpx\n+from httpx._content import encode_json",
      "comment": "I've just noticed this accidentally snuck in a private import.\r\n\r\n@BERRADA-Omar would you be up for refactoring these tests?\r\n\r\nWe can test this against public API using `httpx.Request()`. Eg...\r\n\r\n```python\r\ndata = {...}\r\nreq = httpx.Request(\"POST\", \"https://www.example.com/\", json=data)\r\nassert req.content == ...\r\nassert req.headers = ...\r\n```",
      "comment_id": 1829240738,
      "user": "lovelydinosaur",
      "created_at": "2024-11-05T12:08:10Z",
      "url": "https://github.com/encode/httpx/pull/3367#discussion_r1829240738"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3418,
      "file_path": "httpx/_config.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,6 +31,14 @@ def create_ssl_context(verify: ssl.SSLContext | bool = True) -> ssl.SSLContext:\n         ssl_context.check_hostname = False\n         ssl_context.verify_mode = ssl.CERT_NONE\n         return ssl_context\n+    elif isinstance(verify, str):  # pagma: nocover",
      "comment": "```suggestion\r\n    elif isinstance(verify, str):  # pragma: nocover\r\n```",
      "comment_id": 1862031777,
      "user": "lovelydinosaur",
      "created_at": "2024-11-28T11:42:48Z",
      "url": "https://github.com/encode/httpx/pull/3418#discussion_r1862031777"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3387,
      "file_path": "httpx/_models.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,6 +82,60 @@ def _normalize_header_value(value: str | bytes, encoding: str | None = None) ->\n     return value.encode(encoding or \"ascii\")\n \n \n+def _parse_content_type_charset(content_type: str) -> str | None:\n+    # We used to use `cgi.parse_header()` here, but `cgi` became a dead battery.\n+    # See: https://peps.python.org/pep-0594/#cgi\n+    msg = email.message.Message()\n+    msg[\"content-type\"] = content_type\n+    return msg.get_content_charset(failobj=None)\n+\n+\n+def _parse_header_links(value: str) -> list[dict[str, str]]:\n+    \"\"\"\n+    Returns a list of parsed link headers, for more info see:\n+    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link\n+    The generic syntax of those is:\n+    Link: < uri-reference >; param1=value1; param2=\"value2\"\n+    So for instance:\n+    Link; '<http:/.../front.jpeg>; type=\"image/jpeg\",<http://.../back.jpeg>;'\n+    would return\n+        [\n+            {\"url\": \"http:/.../front.jpeg\", \"type\": \"image/jpeg\"},\n+            {\"url\": \"http://.../back.jpeg\"},\n+        ]\n+    :param value: HTTP Link entity-header field\n+    :return: list of parsed link headers\n+    \"\"\"\n+    links: list[dict[str, str]] = []\n+    replace_chars = \" '\\\"\"\n+    value = value.strip(replace_chars)\n+    if not value:\n+        return links\n+    for val in re.split(\", *<\", value):\n+        try:\n+            url, params = val.split(\";\", 1)\n+        except ValueError:\n+            url, params = val, \"\"\n+        link = {\"url\": url.strip(\"<> '\\\"\")}\n+        for param in params.split(\";\"):\n+            try:\n+                key, value = param.split(\"=\")\n+            except ValueError:\n+                break\n+            link[key.strip(replace_chars)] = value.strip(replace_chars)\n+        links.append(link)\n+    return links\n+\n+\n+def _obfuscate_sensitive_headers(",
      "comment": "Is now a good time to review this? Eg does flask provide similar behaviour onto its headers data structures? Does Django?\n\n(Possibly too off topic??)",
      "comment_id": 1826205536,
      "user": "lovelydinosaur",
      "created_at": "2024-11-01T19:15:43Z",
      "url": "https://github.com/encode/httpx/pull/3387#discussion_r1826205536"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3387,
      "file_path": "httpx/_models.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,6 +82,60 @@ def _normalize_header_value(value: str | bytes, encoding: str | None = None) ->\n     return value.encode(encoding or \"ascii\")\n \n \n+def _parse_content_type_charset(content_type: str) -> str | None:\n+    # We used to use `cgi.parse_header()` here, but `cgi` became a dead battery.\n+    # See: https://peps.python.org/pep-0594/#cgi\n+    msg = email.message.Message()\n+    msg[\"content-type\"] = content_type\n+    return msg.get_content_charset(failobj=None)\n+\n+\n+def _parse_header_links(value: str) -> list[dict[str, str]]:\n+    \"\"\"\n+    Returns a list of parsed link headers, for more info see:\n+    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link\n+    The generic syntax of those is:\n+    Link: < uri-reference >; param1=value1; param2=\"value2\"\n+    So for instance:\n+    Link; '<http:/.../front.jpeg>; type=\"image/jpeg\",<http://.../back.jpeg>;'\n+    would return\n+        [\n+            {\"url\": \"http:/.../front.jpeg\", \"type\": \"image/jpeg\"},\n+            {\"url\": \"http://.../back.jpeg\"},\n+        ]\n+    :param value: HTTP Link entity-header field\n+    :return: list of parsed link headers\n+    \"\"\"\n+    links: list[dict[str, str]] = []\n+    replace_chars = \" '\\\"\"\n+    value = value.strip(replace_chars)\n+    if not value:\n+        return links\n+    for val in re.split(\", *<\", value):\n+        try:\n+            url, params = val.split(\";\", 1)\n+        except ValueError:\n+            url, params = val, \"\"\n+        link = {\"url\": url.strip(\"<> '\\\"\")}\n+        for param in params.split(\";\"):\n+            try:\n+                key, value = param.split(\"=\")\n+            except ValueError:\n+                break\n+            link[key.strip(replace_chars)] = value.strip(replace_chars)\n+        links.append(link)\n+    return links\n+\n+\n+def _obfuscate_sensitive_headers(",
      "comment": "It seems that flask does not obfuscate header values for `repr` (see [werkzeug](https://github.com/pallets/werkzeug/blob/357681fc26dd46ec5b7c3c067732873f57db0bc8/src/werkzeug/datastructures/headers.py#L20))\r\n\r\n```python\r\n>>> from werkzeug.datastructures import Headers\r\n>>>\r\n>>> head = Headers({\"authorization\": \"s3kr3t\"})\r\n>>> head\r\nHeaders([('authorization', 's3kr3t')])\r\n>>> repr(head)\r\n\"Headers([('authorization', 's3kr3t')])\"\r\n```\r\n\r\nSame for Django (see [HttpHeaders ](https://github.com/django/django/blob/611bf6c2e2a1b4ab93273980c45150c099ab146d/django/http/request.py#L468) or [ResponseHeaders](https://github.com/django/django/blob/611bf6c2e2a1b4ab93273980c45150c099ab146d/django/http/response.py#L33))\r\n\r\n```python\r\n>>> from django.http.response import ResponseHeaders\r\n>>> head = ResponseHeaders({\"Authorization\": \"s3kr3t\"})\r\n>>> repr(head)\r\n\"{'Authorization': 's3kr3t'}\"\r\n```",
      "comment_id": 1826536279,
      "user": "RafaelWO",
      "created_at": "2024-11-02T09:45:25Z",
      "url": "https://github.com/encode/httpx/pull/3387#discussion_r1826536279"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3370,
      "file_path": "httpx/_api.py",
      "line": 94,
      "side": "LEFT",
      "diff_hunk": "@@ -80,18 +79,11 @@ def request(\n     * **auth** - *(optional)* An authentication class to use when sending the\n     request.\n     * **proxy** - *(optional)* A proxy URL where all the traffic should be routed.\n-    * **proxies** - *(optional)* A dictionary mapping proxy keys to proxy URLs.\n     * **timeout** - *(optional)* The timeout configuration to use when sending\n     the request.\n     * **follow_redirects** - *(optional)* Enables or disables HTTP redirects.\n-    * **verify** - *(optional)* SSL certificates (a.k.a CA bundle) used to\n-    verify the identity of requested hosts. Either `True` (default CA bundle),\n-    a path to an SSL certificate file, an `ssl.SSLContext`, or `False`\n-    (which will disable verification).\n-    * **cert** - *(optional)* An SSL certificate used by the requested host\n-    to authenticate the client. Either a path to an SSL certificate file, or\n-    two-tuple of (certificate file, key file), or a three-tuple of (certificate\n-    file, key file, password).",
      "comment": "Perhaps it's better to keep these with `*(deprecated)*` tag?",
      "comment_id": 1819083352,
      "user": "T-256",
      "created_at": "2024-10-28T13:43:33Z",
      "url": "https://github.com/encode/httpx/pull/3370#discussion_r1819083352"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3370,
      "file_path": "httpx/_transports/default.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,20 +125,25 @@ def close(self) -> None:\n class HTTPTransport(BaseTransport):\n     def __init__(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        ssl_context: ssl.SSLContext | None = None,\n         http1: bool = True,\n         http2: bool = False,\n         limits: Limits = DEFAULT_LIMITS,\n-        trust_env: bool = True,\n         proxy: ProxyTypes | None = None,\n         uds: str | None = None,\n         local_address: str | None = None,\n         retries: int = 0,\n         socket_options: typing.Iterable[SOCKET_OPTION] | None = None,\n+        # Deprecated...\n+        verify: typing.Any = None,\n+        cert: typing.Any = None,\n     ) -> None:\n-        ssl_context = create_ssl_context(verify=verify, cert=cert, trust_env=trust_env)\n         proxy = Proxy(url=proxy) if isinstance(proxy, (str, URL)) else proxy\n+        if verify is not None or cert is not None:  # pragma: nocover\n+            # Deprecated...\n+            ssl_context = create_ssl_context(verify, cert)\n+        else:\n+            ssl_context = ssl_context or SSLContext()",
      "comment": "perhaps, raising error when used together?\r\n```python\r\nhttpx.get(\"https://example.com/\", verify=False, ssl_context=httpx..SSLContext())\r\n```",
      "comment_id": 1819097875,
      "user": "T-256",
      "created_at": "2024-10-28T13:52:11Z",
      "url": "https://github.com/encode/httpx/pull/3370#discussion_r1819097875"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3370,
      "file_path": "httpx/_transports/default.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,20 +125,25 @@ def close(self) -> None:\n class HTTPTransport(BaseTransport):\n     def __init__(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        ssl_context: ssl.SSLContext | None = None,\n         http1: bool = True,\n         http2: bool = False,\n         limits: Limits = DEFAULT_LIMITS,\n-        trust_env: bool = True,\n         proxy: ProxyTypes | None = None,\n         uds: str | None = None,\n         local_address: str | None = None,\n         retries: int = 0,\n         socket_options: typing.Iterable[SOCKET_OPTION] | None = None,\n+        # Deprecated...\n+        verify: typing.Any = None,\n+        cert: typing.Any = None,\n     ) -> None:\n-        ssl_context = create_ssl_context(verify=verify, cert=cert, trust_env=trust_env)\n         proxy = Proxy(url=proxy) if isinstance(proxy, (str, URL)) else proxy\n+        if verify is not None or cert is not None:  # pragma: nocover\n+            # Deprecated...\n+            ssl_context = create_ssl_context(verify, cert)\n+        else:\n+            ssl_context = ssl_context or SSLContext()",
      "comment": "Okay yep... I'm going to retitle our `version-1.0` branch and will resolve there.",
      "comment_id": 1819146801,
      "user": "lovelydinosaur",
      "created_at": "2024-10-28T14:13:07Z",
      "url": "https://github.com/encode/httpx/pull/3370#discussion_r1819146801"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,150 +40,102 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: typing.Optional[CertTypes] = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n-    def __init__(\n-        self,\n-        *,\n-        cert: typing.Optional[CertTypes] = None,\n+    def __new__(\n+        cls,\n+        protocol: ssl._SSLMethod = ssl.PROTOCOL_TLS_CLIENT,\n         verify: VerifyTypes = True,\n-        trust_env: bool = True,\n-        http2: bool = False,\n-    ) -> None:\n-        self.cert = cert\n-        self.verify = verify\n-        self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n+        cert: typing.Optional[CertTypes] = None,\n+    ) -> \"SSLContext\":",
      "comment": "I'm curious why we're overriding `__new__` instead of `__init__` here?",
      "comment_id": 1437601093,
      "user": "lovelydinosaur",
      "created_at": "2023-12-28T12:16:24Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1437601093"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,150 +40,102 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: typing.Optional[CertTypes] = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n-    def __init__(\n-        self,\n-        *,\n-        cert: typing.Optional[CertTypes] = None,\n+    def __new__(\n+        cls,\n+        protocol: ssl._SSLMethod = ssl.PROTOCOL_TLS_CLIENT,\n         verify: VerifyTypes = True,\n-        trust_env: bool = True,\n-        http2: bool = False,\n-    ) -> None:\n-        self.cert = cert\n-        self.verify = verify\n-        self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n+        cert: typing.Optional[CertTypes] = None,\n+    ) -> \"SSLContext\":\n+        self = super().__new__(cls, protocol)\n+\n+        set_minimum_tls_version_1_2(self)\n+        self.options |= ssl.OP_NO_COMPRESSION\n+        self.set_ciphers(DEFAULT_CIPHERS)\n \n-    def load_ssl_context(self) -> ssl.SSLContext:\n         logger.debug(\n-            \"load_ssl_context verify=%r cert=%r trust_env=%r http2=%r\",\n-            self.verify,\n-            self.cert,\n-            self.trust_env,\n-            self.http2,\n+            \"load_ssl_context verify=%r cert=%r\",\n+            verify,\n+            cert,\n         )\n \n-        if self.verify:\n-            return self.load_ssl_context_verify()\n-        return self.load_ssl_context_no_verify()\n+        if verify:\n+            self.load_ssl_context_verify(cert, verify)\n+        else:\n+            self.load_ssl_context_no_verify(cert)\n+        return self\n \n-    def load_ssl_context_no_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_no_verify(\n+        self, cert: typing.Optional[CertTypes]\n+    ) -> ssl.SSLContext:\n         \"\"\"\n         Return an SSL context for unverified connections.\n         \"\"\"\n-        context = self._create_default_ssl_context()\n-        context.check_hostname = False\n-        context.verify_mode = ssl.CERT_NONE\n-        self._load_client_certs(context)\n-        return context\n+        self.check_hostname = False\n+        self.verify_mode = ssl.CERT_NONE\n+        self._load_client_certs(cert)\n+        return self\n \n-    def load_ssl_context_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_verify(\n+        self, cert: typing.Optional[CertTypes], verify: VerifyTypes\n+    ) -> None:\n         \"\"\"\n         Return an SSL context for verified connections.\n         \"\"\"\n-        if self.trust_env and self.verify is True:\n-            ca_bundle = get_ca_bundle_from_env()\n-            if ca_bundle is not None:\n-                self.verify = ca_bundle\n-\n-        if isinstance(self.verify, ssl.SSLContext):\n-            # Allow passing in our own SSLContext object that's pre-configured.\n-            context = self.verify\n-            self._load_client_certs(context)\n-            return context\n-        elif isinstance(self.verify, bool):\n+        if isinstance(verify, bool):\n             ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\n-        elif Path(self.verify).exists():\n-            ca_bundle_path = Path(self.verify)\n+        elif Path(verify).exists():\n+            ca_bundle_path = Path(verify)\n         else:\n             raise IOError(\n                 \"Could not find a suitable TLS CA certificate bundle, \"\n-                \"invalid path: {}\".format(self.verify)\n+                \"invalid path: {}\".format(verify)\n             )",
      "comment": "We confuse the flow here by having this section of code separated from where `ca_bundle_path` is actually used. It'd be more clear if we pushed this block down to just before `if ca_bundle_path.is_file():`. ",
      "comment_id": 1437606317,
      "user": "lovelydinosaur",
      "created_at": "2023-12-28T12:25:23Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1437606317"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,150 +40,102 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: typing.Optional[CertTypes] = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n-    def __init__(\n-        self,\n-        *,\n-        cert: typing.Optional[CertTypes] = None,\n+    def __new__(\n+        cls,\n+        protocol: ssl._SSLMethod = ssl.PROTOCOL_TLS_CLIENT,\n         verify: VerifyTypes = True,\n-        trust_env: bool = True,\n-        http2: bool = False,\n-    ) -> None:\n-        self.cert = cert\n-        self.verify = verify\n-        self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n+        cert: typing.Optional[CertTypes] = None,\n+    ) -> \"SSLContext\":\n+        self = super().__new__(cls, protocol)\n+\n+        set_minimum_tls_version_1_2(self)\n+        self.options |= ssl.OP_NO_COMPRESSION\n+        self.set_ciphers(DEFAULT_CIPHERS)\n \n-    def load_ssl_context(self) -> ssl.SSLContext:\n         logger.debug(\n-            \"load_ssl_context verify=%r cert=%r trust_env=%r http2=%r\",\n-            self.verify,\n-            self.cert,\n-            self.trust_env,\n-            self.http2,\n+            \"load_ssl_context verify=%r cert=%r\",\n+            verify,\n+            cert,\n         )\n \n-        if self.verify:\n-            return self.load_ssl_context_verify()\n-        return self.load_ssl_context_no_verify()\n+        if verify:\n+            self.load_ssl_context_verify(cert, verify)\n+        else:\n+            self.load_ssl_context_no_verify(cert)\n+        return self\n \n-    def load_ssl_context_no_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_no_verify(\n+        self, cert: typing.Optional[CertTypes]\n+    ) -> ssl.SSLContext:\n         \"\"\"\n         Return an SSL context for unverified connections.\n         \"\"\"\n-        context = self._create_default_ssl_context()\n-        context.check_hostname = False\n-        context.verify_mode = ssl.CERT_NONE\n-        self._load_client_certs(context)\n-        return context\n+        self.check_hostname = False\n+        self.verify_mode = ssl.CERT_NONE\n+        self._load_client_certs(cert)\n+        return self\n \n-    def load_ssl_context_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_verify(\n+        self, cert: typing.Optional[CertTypes], verify: VerifyTypes\n+    ) -> None:\n         \"\"\"\n         Return an SSL context for verified connections.\n         \"\"\"\n-        if self.trust_env and self.verify is True:\n-            ca_bundle = get_ca_bundle_from_env()\n-            if ca_bundle is not None:\n-                self.verify = ca_bundle\n-\n-        if isinstance(self.verify, ssl.SSLContext):\n-            # Allow passing in our own SSLContext object that's pre-configured.\n-            context = self.verify\n-            self._load_client_certs(context)\n-            return context\n-        elif isinstance(self.verify, bool):\n+        if isinstance(verify, bool):\n             ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\n-        elif Path(self.verify).exists():\n-            ca_bundle_path = Path(self.verify)\n+        elif Path(verify).exists():\n+            ca_bundle_path = Path(verify)\n         else:\n             raise IOError(\n                 \"Could not find a suitable TLS CA certificate bundle, \"\n-                \"invalid path: {}\".format(self.verify)\n+                \"invalid path: {}\".format(verify)\n             )",
      "comment": "(Tho perhaps we address clean-ups separately to the main API behavioral changes here?)",
      "comment_id": 1437607038,
      "user": "lovelydinosaur",
      "created_at": "2023-12-28T12:26:46Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1437607038"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,150 +40,102 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: typing.Optional[CertTypes] = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n-    def __init__(\n-        self,\n-        *,\n-        cert: typing.Optional[CertTypes] = None,\n+    def __new__(\n+        cls,\n+        protocol: ssl._SSLMethod = ssl.PROTOCOL_TLS_CLIENT,\n         verify: VerifyTypes = True,\n-        trust_env: bool = True,\n-        http2: bool = False,\n-    ) -> None:\n-        self.cert = cert\n-        self.verify = verify\n-        self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n+        cert: typing.Optional[CertTypes] = None,\n+    ) -> \"SSLContext\":",
      "comment": "Yes, it should definitely be in __init__. I believe I encountered some issues and have temporarily moved it to __new__ to see how it looks in general.",
      "comment_id": 1437608213,
      "user": "karpetrosyan",
      "created_at": "2023-12-28T12:28:59Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1437608213"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,150 +40,102 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: typing.Optional[CertTypes] = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n-    def __init__(\n-        self,\n-        *,\n-        cert: typing.Optional[CertTypes] = None,\n+    def __new__(\n+        cls,\n+        protocol: ssl._SSLMethod = ssl.PROTOCOL_TLS_CLIENT,\n         verify: VerifyTypes = True,\n-        trust_env: bool = True,\n-        http2: bool = False,\n-    ) -> None:\n-        self.cert = cert\n-        self.verify = verify\n-        self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n+        cert: typing.Optional[CertTypes] = None,\n+    ) -> \"SSLContext\":\n+        self = super().__new__(cls, protocol)\n+\n+        set_minimum_tls_version_1_2(self)\n+        self.options |= ssl.OP_NO_COMPRESSION\n+        self.set_ciphers(DEFAULT_CIPHERS)\n \n-    def load_ssl_context(self) -> ssl.SSLContext:\n         logger.debug(\n-            \"load_ssl_context verify=%r cert=%r trust_env=%r http2=%r\",\n-            self.verify,\n-            self.cert,\n-            self.trust_env,\n-            self.http2,\n+            \"load_ssl_context verify=%r cert=%r\",\n+            verify,\n+            cert,\n         )\n \n-        if self.verify:\n-            return self.load_ssl_context_verify()\n-        return self.load_ssl_context_no_verify()\n+        if verify:\n+            self.load_ssl_context_verify(cert, verify)\n+        else:\n+            self.load_ssl_context_no_verify(cert)\n+        return self\n \n-    def load_ssl_context_no_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_no_verify(\n+        self, cert: typing.Optional[CertTypes]\n+    ) -> ssl.SSLContext:\n         \"\"\"\n         Return an SSL context for unverified connections.\n         \"\"\"\n-        context = self._create_default_ssl_context()\n-        context.check_hostname = False\n-        context.verify_mode = ssl.CERT_NONE\n-        self._load_client_certs(context)\n-        return context\n+        self.check_hostname = False\n+        self.verify_mode = ssl.CERT_NONE\n+        self._load_client_certs(cert)\n+        return self\n \n-    def load_ssl_context_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_verify(\n+        self, cert: typing.Optional[CertTypes], verify: VerifyTypes\n+    ) -> None:\n         \"\"\"\n         Return an SSL context for verified connections.\n         \"\"\"\n-        if self.trust_env and self.verify is True:\n-            ca_bundle = get_ca_bundle_from_env()\n-            if ca_bundle is not None:\n-                self.verify = ca_bundle\n-\n-        if isinstance(self.verify, ssl.SSLContext):\n-            # Allow passing in our own SSLContext object that's pre-configured.\n-            context = self.verify\n-            self._load_client_certs(context)\n-            return context\n-        elif isinstance(self.verify, bool):\n+        if isinstance(verify, bool):\n             ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\n-        elif Path(self.verify).exists():\n-            ca_bundle_path = Path(self.verify)\n+        elif Path(verify).exists():\n+            ca_bundle_path = Path(verify)\n         else:\n             raise IOError(\n                 \"Could not find a suitable TLS CA certificate bundle, \"\n-                \"invalid path: {}\".format(self.verify)\n+                \"invalid path: {}\".format(verify)\n             )",
      "comment": "Separating them will make it easier to review this PR, which contains an important API change.\r\n",
      "comment_id": 1437611108,
      "user": "karpetrosyan",
      "created_at": "2023-12-28T12:34:38Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1437611108"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,150 +40,102 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: typing.Optional[CertTypes] = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n-    def __init__(\n-        self,\n-        *,\n-        cert: typing.Optional[CertTypes] = None,\n+    def __new__(\n+        cls,\n+        protocol: ssl._SSLMethod = ssl.PROTOCOL_TLS_CLIENT,\n         verify: VerifyTypes = True,\n-        trust_env: bool = True,\n-        http2: bool = False,\n-    ) -> None:\n-        self.cert = cert\n-        self.verify = verify\n-        self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n+        cert: typing.Optional[CertTypes] = None,\n+    ) -> \"SSLContext\":\n+        self = super().__new__(cls, protocol)\n+\n+        set_minimum_tls_version_1_2(self)\n+        self.options |= ssl.OP_NO_COMPRESSION\n+        self.set_ciphers(DEFAULT_CIPHERS)\n \n-    def load_ssl_context(self) -> ssl.SSLContext:\n         logger.debug(\n-            \"load_ssl_context verify=%r cert=%r trust_env=%r http2=%r\",\n-            self.verify,\n-            self.cert,\n-            self.trust_env,\n-            self.http2,\n+            \"load_ssl_context verify=%r cert=%r\",\n+            verify,\n+            cert,\n         )\n \n-        if self.verify:\n-            return self.load_ssl_context_verify()\n-        return self.load_ssl_context_no_verify()\n+        if verify:\n+            self.load_ssl_context_verify(cert, verify)\n+        else:\n+            self.load_ssl_context_no_verify(cert)\n+        return self\n \n-    def load_ssl_context_no_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_no_verify(\n+        self, cert: typing.Optional[CertTypes]\n+    ) -> ssl.SSLContext:\n         \"\"\"\n         Return an SSL context for unverified connections.\n         \"\"\"\n-        context = self._create_default_ssl_context()\n-        context.check_hostname = False\n-        context.verify_mode = ssl.CERT_NONE\n-        self._load_client_certs(context)\n-        return context\n+        self.check_hostname = False\n+        self.verify_mode = ssl.CERT_NONE\n+        self._load_client_certs(cert)\n+        return self\n \n-    def load_ssl_context_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_verify(\n+        self, cert: typing.Optional[CertTypes], verify: VerifyTypes\n+    ) -> None:\n         \"\"\"\n         Return an SSL context for verified connections.\n         \"\"\"\n-        if self.trust_env and self.verify is True:\n-            ca_bundle = get_ca_bundle_from_env()\n-            if ca_bundle is not None:\n-                self.verify = ca_bundle\n-\n-        if isinstance(self.verify, ssl.SSLContext):\n-            # Allow passing in our own SSLContext object that's pre-configured.\n-            context = self.verify\n-            self._load_client_certs(context)\n-            return context\n-        elif isinstance(self.verify, bool):\n+        if isinstance(verify, bool):\n             ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\n-        elif Path(self.verify).exists():\n-            ca_bundle_path = Path(self.verify)\n+        elif Path(verify).exists():\n+            ca_bundle_path = Path(verify)\n         else:\n             raise IOError(\n                 \"Could not find a suitable TLS CA certificate bundle, \"\n-                \"invalid path: {}\".format(self.verify)\n+                \"invalid path: {}\".format(verify)\n             )",
      "comment": "Another important question is whether we need to deprecate previous arguments or simply delete them.",
      "comment_id": 1437621343,
      "user": "karpetrosyan",
      "created_at": "2023-12-28T12:54:22Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1437621343"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,150 +40,102 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: typing.Optional[CertTypes] = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n-    def __init__(\n-        self,\n-        *,\n-        cert: typing.Optional[CertTypes] = None,\n+    def __new__(\n+        cls,\n+        protocol: ssl._SSLMethod = ssl.PROTOCOL_TLS_CLIENT,\n         verify: VerifyTypes = True,\n-        trust_env: bool = True,\n-        http2: bool = False,\n-    ) -> None:\n-        self.cert = cert\n-        self.verify = verify\n-        self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n+        cert: typing.Optional[CertTypes] = None,\n+    ) -> \"SSLContext\":\n+        self = super().__new__(cls, protocol)\n+\n+        set_minimum_tls_version_1_2(self)\n+        self.options |= ssl.OP_NO_COMPRESSION\n+        self.set_ciphers(DEFAULT_CIPHERS)\n \n-    def load_ssl_context(self) -> ssl.SSLContext:\n         logger.debug(\n-            \"load_ssl_context verify=%r cert=%r trust_env=%r http2=%r\",\n-            self.verify,\n-            self.cert,\n-            self.trust_env,\n-            self.http2,\n+            \"load_ssl_context verify=%r cert=%r\",\n+            verify,\n+            cert,\n         )\n \n-        if self.verify:\n-            return self.load_ssl_context_verify()\n-        return self.load_ssl_context_no_verify()\n+        if verify:\n+            self.load_ssl_context_verify(cert, verify)\n+        else:\n+            self.load_ssl_context_no_verify(cert)\n+        return self\n \n-    def load_ssl_context_no_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_no_verify(\n+        self, cert: typing.Optional[CertTypes]\n+    ) -> ssl.SSLContext:\n         \"\"\"\n         Return an SSL context for unverified connections.\n         \"\"\"\n-        context = self._create_default_ssl_context()\n-        context.check_hostname = False\n-        context.verify_mode = ssl.CERT_NONE\n-        self._load_client_certs(context)\n-        return context\n+        self.check_hostname = False\n+        self.verify_mode = ssl.CERT_NONE\n+        self._load_client_certs(cert)\n+        return self\n \n-    def load_ssl_context_verify(self) -> ssl.SSLContext:\n+    def load_ssl_context_verify(\n+        self, cert: typing.Optional[CertTypes], verify: VerifyTypes\n+    ) -> None:\n         \"\"\"\n         Return an SSL context for verified connections.\n         \"\"\"\n-        if self.trust_env and self.verify is True:\n-            ca_bundle = get_ca_bundle_from_env()\n-            if ca_bundle is not None:\n-                self.verify = ca_bundle\n-\n-        if isinstance(self.verify, ssl.SSLContext):\n-            # Allow passing in our own SSLContext object that's pre-configured.\n-            context = self.verify\n-            self._load_client_certs(context)\n-            return context\n-        elif isinstance(self.verify, bool):\n+        if isinstance(verify, bool):\n             ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\n-        elif Path(self.verify).exists():\n-            ca_bundle_path = Path(self.verify)\n+        elif Path(verify).exists():\n+            ca_bundle_path = Path(verify)\n         else:\n             raise IOError(\n                 \"Could not find a suitable TLS CA certificate bundle, \"\n-                \"invalid path: {}\".format(self.verify)\n+                \"invalid path: {}\".format(verify)\n             )",
      "comment": "> (Tho perhaps we address clean-ups separately to the main API behavioral changes here?)\r\n\r\nAgree with tom, you could add `ssl_context=` and `httpx.SSLContext` in current PR and decide to deprecate/remove in separated PR.",
      "comment_id": 1437656569,
      "user": "T-256",
      "created_at": "2023-12-28T13:10:24Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1437656569"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -138,6 +134,14 @@ def _load_client_certs(self, cert: typing.Optional[CertTypes] = None) -> None:\n                     password=cert[2],  # type: ignore\n                 )\n \n+    def __new__(\n+        cls,\n+        protocol: ssl._SSLMethod = ssl.PROTOCOL_TLS_CLIENT,\n+        *args: typing.Any,\n+        **kwargs: typing.Any,\n+    ) -> \"SSLContext\":\n+        return super().__new__(cls, protocol, *args, **kwargs)",
      "comment": "We need this to avoid \"DeprecationWarning: ssl.SSLContext() without protocol argument is deprecated.\"",
      "comment_id": 1438067431,
      "user": "karpetrosyan",
      "created_at": "2023-12-29T07:24:28Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1438067431"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,151 +44,113 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n     def __init__(\n         self,\n-        *,\n-        cert: CertTypes | None = None,\n         verify: VerifyTypes = True,\n-        trust_env: bool = True,\n-        http2: bool = False,\n+        cert: CertTypes | None = None,\n     ) -> None:\n-        self.cert = cert\n         self.verify = verify\n-        self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n+        set_minimum_tls_version_1_2(self)\n+        self.options |= ssl.OP_NO_COMPRESSION\n+        self.set_ciphers(DEFAULT_CIPHERS)\n \n-    def load_ssl_context(self) -> ssl.SSLContext:\n         logger.debug(\n-            \"load_ssl_context verify=%r cert=%r trust_env=%r http2=%r\",\n-            self.verify,\n-            self.cert,\n-            self.trust_env,\n-            self.http2,\n+            \"load_ssl_context verify=%r cert=%r\",\n+            verify,\n+            cert,\n         )\n \n-        if self.verify:\n-            return self.load_ssl_context_verify()\n-        return self.load_ssl_context_no_verify()\n+        if verify:\n+            self.load_ssl_context_verify(cert, verify)\n+        else:\n+            self.load_ssl_context_no_verify(cert)",
      "comment": "since `verify` attribute is set to instance, I think we could mix these in one method:\r\n```py\r\ndef load_ssl_context(self, cert: typing.Optional[CertTypes]) -> None:\r\n    if not self.verify:\r\n        self.check_hostname = False\r\n        self.verify_mode = ssl.CERT_NONE\r\n        self._load_client_certs(cert)\r\n        return\r\n    if isinstance(self.verify, bool):\r\n        ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\r\n    ...\r\n    ...\r\n\r\n```",
      "comment_id": 1771142229,
      "user": "T-256",
      "created_at": "2024-09-23T10:24:55Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1771142229"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,151 +44,113 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):",
      "comment": "If possible I'd like this not to subclass ssl.SSLContext, so we can use pyopenssl with http3",
      "comment_id": 1771217918,
      "user": "graingert",
      "created_at": "2024-09-23T11:16:07Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1771217918"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,151 +44,113 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):",
      "comment": "Ah, so...\r\n\r\nThe *type* required by the client methods should be `ssl.SSLContext`.\r\nFor example in correctly typecheck against this documented usage...\r\n\r\nhttps://github.com/encode/httpx/blob/998f445c83efb140b7e9ae05c993e8f36663cba2/docs/advanced/ssl.md?plain=1#L148-L149\r\n\r\nI think it's okay for us to have an `httpx.SSLContext()` subclass.",
      "comment_id": 1771332015,
      "user": "lovelydinosaur",
      "created_at": "2024-09-23T12:43:02Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1771332015"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,151 +44,113 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):",
      "comment": "I'd like to change the type required by the Client methods to a custom httpcore class that can wrap either an ssl.SSLContext or a pyopenssl SSLContext ",
      "comment_id": 1771393713,
      "user": "graingert",
      "created_at": "2024-09-23T13:12:01Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1771393713"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,151 +44,113 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):",
      "comment": "@graingert Interesting...\r\n\r\nCan we progress that separately by opening a design discussion in `httpcore` for adding `pyopenssl` support?\r\nI'd like to understand that individual part better without risking this PR getting sidetracked.",
      "comment_id": 1771466178,
      "user": "lovelydinosaur",
      "created_at": "2024-09-23T13:40:01Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1771466178"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,8 +47,7 @@ def request(\n     proxy: ProxyTypes | None = None,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n     follow_redirects: bool = False,\n-    verify: VerifyTypes = True,\n-    cert: CertTypes | None = None,\n+    ssl_context: typing.Optional[SSLContext] = None,",
      "comment": "We should be using `typing.Optional[ssl.SSLContext]` here. (Yes it's a bit subtle)",
      "comment_id": 1777467423,
      "user": "lovelydinosaur",
      "created_at": "2024-09-26T17:11:39Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1777467423"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "tests/test_config.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,48 +9,46 @@\n \n \n def test_load_ssl_config():\n-    context = httpx.create_ssl_context()\n+    context = httpx.SSLContext()\n     assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n     assert context.check_hostname is True\n \n \n def test_load_ssl_config_verify_non_existing_path():\n     with pytest.raises(IOError):\n-        httpx.create_ssl_context(verify=\"/path/to/nowhere\")\n+        httpx.SSLContext(verify=\"/path/to/nowhere\")\n \n \n-def test_load_ssl_config_verify_existing_file():\n-    context = httpx.create_ssl_context(verify=certifi.where())\n-    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n-    assert context.check_hostname is True\n-\n+@pytest.mark.parametrize(\n+    \"trust_env, expected_keylog_filename\",\n+    [\n+        pytest.param(True, \"test\", id=\"With trasting env\"),\n+        pytest.param(False, None, id=\"Without trasting env\"),",
      "comment": "```suggestion\r\n        pytest.param(True, \"test\", id=\"With trusting env\"),\r\n        pytest.param(False, None, id=\"Without trusting env\"),\r\n```\r\n\r\n\ud83d\ude0e",
      "comment_id": 1787439662,
      "user": "lovelydinosaur",
      "created_at": "2024-10-04T09:29:07Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1787439662"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,8 +48,7 @@ def request(\n     proxy: ProxyTypes | None = None,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n     follow_redirects: bool = False,\n-    verify: VerifyTypes = True,\n-    cert: CertTypes | None = None,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "Do we need DEFAULT_SSL_CONTEXT instead of None?\r\nI can remember there are memory leak issues for high count instantiate of Client. Personally, I fixed this by using global ssl context varible used for all httpx.Client instances.\r\nref: https://github.com/encode/httpx/discussions/2785#discussioncomment-6539886",
      "comment_id": 1787817691,
      "user": "T-256",
      "created_at": "2024-10-04T14:34:58Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1787817691"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,8 +48,7 @@ def request(\n     proxy: ProxyTypes | None = None,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n     follow_redirects: bool = False,\n-    verify: VerifyTypes = True,\n-    cert: CertTypes | None = None,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "Let's add things incrementally, maybe it should be resolved in another PR?",
      "comment_id": 1787935057,
      "user": "karpetrosyan",
      "created_at": "2024-10-04T16:08:40Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1787935057"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,8 +48,7 @@ def request(\n     proxy: ProxyTypes | None = None,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n     follow_redirects: bool = False,\n-    verify: VerifyTypes = True,\n-    cert: CertTypes | None = None,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "(btw it's not blocking concern, we can do it by follow-up PR.)",
      "comment_id": 1787941707,
      "user": "T-256",
      "created_at": "2024-10-04T16:14:52Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1787941707"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,8 +48,7 @@ def request(\n     proxy: ProxyTypes | None = None,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n     follow_redirects: bool = False,\n-    verify: VerifyTypes = True,\n-    cert: CertTypes | None = None,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "Yes, please. I don't even remember a lot of things from this PR \ud83d\ude04\r\nOne year old PR is a bad practice... always!",
      "comment_id": 1787951248,
      "user": "karpetrosyan",
      "created_at": "2024-10-04T16:23:50Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1787951248"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,8 +48,7 @@ def request(\n     proxy: ProxyTypes | None = None,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n     follow_redirects: bool = False,\n-    verify: VerifyTypes = True,\n-    cert: CertTypes | None = None,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "We should use `None` here.\r\nWe should use with instantiating a singleton default when `None` is passed to the transport.\r\nTho we can deal with that as a follow-up.",
      "comment_id": 1787956942,
      "user": "lovelydinosaur",
      "created_at": "2024-10-04T16:29:05Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1787956942"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_client.py",
      "line": 691,
      "side": "RIGHT",
      "diff_hunk": "@@ -695,20 +683,18 @@ def __init__(\n \n     def _init_transport(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        ssl_context: typing.Optional[ssl.SSLContext],\n         http1: bool = True,\n         http2: bool = False,\n         limits: Limits = DEFAULT_LIMITS,\n-        transport: BaseTransport | None = None,\n         trust_env: bool = True,\n+        transport: typing.Optional[BaseTransport] = None,",
      "comment": "why this change? lets keep it consistent with others.",
      "comment_id": 1789284375,
      "user": "T-256",
      "created_at": "2024-10-06T22:47:39Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1789284375"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,151 +45,103 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n     def __init__(\n         self,\n-        *,\n-        cert: CertTypes | None = None,\n         verify: VerifyTypes = True,\n+        cert: CertTypes | None = None,\n         trust_env: bool = True,\n-        http2: bool = False,\n     ) -> None:\n-        self.cert = cert\n         self.verify = verify\n+        set_minimum_tls_version_1_2(self)\n+        self.options |= ssl.OP_NO_COMPRESSION\n+        self.set_ciphers(DEFAULT_CIPHERS)\n         self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n \n-    def load_ssl_context(self) -> ssl.SSLContext:\n+        keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n+        if keylogfile and self.trust_env:\n+            self.keylog_filename = keylogfile\n+\n         logger.debug(\n-            \"load_ssl_context verify=%r cert=%r trust_env=%r http2=%r\",\n-            self.verify,\n-            self.cert,\n-            self.trust_env,\n-            self.http2,\n+            \"load_ssl_context verify=%r cert=%r\",\n+            verify,\n+            cert,",
      "comment": "```suggestion\r\n            \"load_ssl_context verify=%r cert=%r trust_env=%r\",\r\n            verify,\r\n            cert,\r\n            trust_env,\r\n```",
      "comment_id": 1789288418,
      "user": "T-256",
      "created_at": "2024-10-06T23:00:08Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1789288418"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,151 +45,103 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n     def __init__(\n         self,\n-        *,\n-        cert: CertTypes | None = None,\n         verify: VerifyTypes = True,\n+        cert: CertTypes | None = None,\n         trust_env: bool = True,\n-        http2: bool = False,\n     ) -> None:\n-        self.cert = cert\n         self.verify = verify",
      "comment": "Since httpx.SSLContext is now subclass of ssl.SSLContext, let's make these fields private.",
      "comment_id": 1789289649,
      "user": "T-256",
      "created_at": "2024-10-06T23:04:29Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1789289649"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 136,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,151 +45,103 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n     def __init__(\n         self,\n-        *,\n-        cert: CertTypes | None = None,\n         verify: VerifyTypes = True,\n+        cert: CertTypes | None = None,\n         trust_env: bool = True,\n-        http2: bool = False,\n     ) -> None:\n-        self.cert = cert\n         self.verify = verify\n+        set_minimum_tls_version_1_2(self)\n+        self.options |= ssl.OP_NO_COMPRESSION\n+        self.set_ciphers(DEFAULT_CIPHERS)\n         self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n \n-    def load_ssl_context(self) -> ssl.SSLContext:\n+        keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n+        if keylogfile and self.trust_env:\n+            self.keylog_filename = keylogfile\n+\n         logger.debug(\n-            \"load_ssl_context verify=%r cert=%r trust_env=%r http2=%r\",\n-            self.verify,\n-            self.cert,\n-            self.trust_env,\n-            self.http2,\n+            \"load_ssl_context verify=%r cert=%r\",\n+            verify,\n+            cert,\n         )\n \n-        if self.verify:\n-            return self.load_ssl_context_verify()\n-        return self.load_ssl_context_no_verify()\n-\n-    def load_ssl_context_no_verify(self) -> ssl.SSLContext:\n-        \"\"\"\n-        Return an SSL context for unverified connections.\n-        \"\"\"\n-        context = self._create_default_ssl_context()\n-        context.check_hostname = False\n-        context.verify_mode = ssl.CERT_NONE\n-        self._load_client_certs(context)\n-        return context\n+        if not verify:\n+            self.check_hostname = False\n+            self.verify_mode = ssl.CERT_NONE\n+            self._load_client_certs(cert)\n+            return\n \n-    def load_ssl_context_verify(self) -> ssl.SSLContext:\n-        \"\"\"\n-        Return an SSL context for verified connections.\n-        \"\"\"\n-        if self.trust_env and self.verify is True:\n-            ca_bundle = get_ca_bundle_from_env()\n-            if ca_bundle is not None:\n-                self.verify = ca_bundle\n-\n-        if isinstance(self.verify, ssl.SSLContext):\n-            # Allow passing in our own SSLContext object that's pre-configured.\n-            context = self.verify\n-            self._load_client_certs(context)\n-            return context\n-        elif isinstance(self.verify, bool):\n+        if isinstance(verify, bool):\n             ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\n-        elif Path(self.verify).exists():\n-            ca_bundle_path = Path(self.verify)\n+        elif Path(verify).exists():\n+            ca_bundle_path = Path(verify)\n         else:\n             raise IOError(\n                 \"Could not find a suitable TLS CA certificate bundle, \"\n-                \"invalid path: {}\".format(self.verify)\n+                \"invalid path: {}\".format(verify)\n             )\n \n-        context = self._create_default_ssl_context()\n-        context.verify_mode = ssl.CERT_REQUIRED\n-        context.check_hostname = True\n+        self.verify_mode = ssl.CERT_REQUIRED\n+        self.check_hostname = True\n \n         # Signal to server support for PHA in TLS 1.3. Raises an\n         # AttributeError if only read-only access is implemented.\n         try:\n-            context.post_handshake_auth = True\n+            self.post_handshake_auth = True\n         except AttributeError:  # pragma: no cover\n             pass\n \n         # Disable using 'commonName' for SSLContext.check_hostname\n         # when the 'subjectAltName' extension isn't available.\n         try:\n-            context.hostname_checks_common_name = False\n+            self.hostname_checks_common_name = False\n         except AttributeError:  # pragma: no cover\n             pass\n \n         if ca_bundle_path.is_file():\n             cafile = str(ca_bundle_path)\n             logger.debug(\"load_verify_locations cafile=%r\", cafile)\n-            context.load_verify_locations(cafile=cafile)\n+            self.load_verify_locations(cafile=cafile)\n         elif ca_bundle_path.is_dir():\n             capath = str(ca_bundle_path)\n             logger.debug(\"load_verify_locations capath=%r\", capath)\n-            context.load_verify_locations(capath=capath)\n+            self.load_verify_locations(capath=capath)\n \n-        self._load_client_certs(context)\n+        self._load_client_certs(cert)\n \n-        return context\n-\n-    def _create_default_ssl_context(self) -> ssl.SSLContext:\n+    def _load_client_certs(self, cert: typing.Optional[CertTypes] = None) -> None:\n         \"\"\"\n-        Creates the default SSLContext object that's used for both verified\n-        and unverified connections.\n+        Loads client certificates into our SSLContext object\n         \"\"\"\n-        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)\n-        set_minimum_tls_version_1_2(context)\n-        context.options |= ssl.OP_NO_COMPRESSION\n-        context.set_ciphers(DEFAULT_CIPHERS)\n-\n-        if ssl.HAS_ALPN:\n-            alpn_idents = [\"http/1.1\", \"h2\"] if self.http2 else [\"http/1.1\"]\n-            context.set_alpn_protocols(alpn_idents)\n+        if cert is not None:\n+            if isinstance(cert, str):\n+                self.load_cert_chain(certfile=cert)\n+            elif isinstance(cert, tuple) and len(cert) == 2:\n+                self.load_cert_chain(certfile=cert[0], keyfile=cert[1])\n+            elif isinstance(cert, tuple) and len(cert) == 3:\n+                self.load_cert_chain(\n+                    certfile=cert[0],\n+                    keyfile=cert[1],\n+                    password=cert[2],\n+                )\n \n-        keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n-        if keylogfile and self.trust_env:\n-            context.keylog_filename = keylogfile\n+    def __repr__(self) -> str:\n+        class_name = self.__class__.__name__\n \n-        return context\n+        return f\"{class_name}(verify={self.verify!r})\"",
      "comment": "```suggestion\r\n        return f\"{class_name}(verify={self.verify!r}, trust_env={self.trust_env!r})\"\r\n```",
      "comment_id": 1789290923,
      "user": "T-256",
      "created_at": "2024-10-06T23:08:18Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1789290923"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_transports/default.py",
      "line": 140,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,8 +136,8 @@ def __init__(\n         retries: int = 0,\n         socket_options: typing.Iterable[SOCKET_OPTION] | None = None,\n     ) -> None:\n-        ssl_context = create_ssl_context(verify=verify, cert=cert, trust_env=trust_env)\n         proxy = Proxy(url=proxy) if isinstance(proxy, (str, URL)) else proxy\n+        ssl_context = ssl_context or SSLContext()",
      "comment": "```suggestion\r\n        ssl_context = ssl_context or SSLContext(trust_env=trust_env)\r\n```",
      "comment_id": 1789295895,
      "user": "T-256",
      "created_at": "2024-10-06T23:23:27Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1789295895"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_transports/default.py",
      "line": 279,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,20 +265,18 @@ async def aclose(self) -> None:\n class AsyncHTTPTransport(AsyncBaseTransport):\n     def __init__(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        ssl_context: ssl.SSLContext | None = None,\n         http1: bool = True,\n         http2: bool = False,\n         limits: Limits = DEFAULT_LIMITS,\n-        trust_env: bool = True,\n         proxy: ProxyTypes | None = None,\n         uds: str | None = None,\n         local_address: str | None = None,\n         retries: int = 0,\n         socket_options: typing.Iterable[SOCKET_OPTION] | None = None,\n     ) -> None:\n-        ssl_context = create_ssl_context(verify=verify, cert=cert, trust_env=trust_env)\n         proxy = Proxy(url=proxy) if isinstance(proxy, (str, URL)) else proxy\n+        ssl_context = ssl_context or SSLContext()",
      "comment": "```suggestion\r\n        ssl_context = ssl_context or SSLContext(trust_env=trust_env)\r\n```",
      "comment_id": 1789296103,
      "user": "T-256",
      "created_at": "2024-10-06T23:24:09Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1789296103"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_client.py",
      "line": 686,
      "side": "RIGHT",
      "diff_hunk": "@@ -695,20 +683,18 @@ def __init__(\n \n     def _init_transport(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        ssl_context: typing.Optional[ssl.SSLContext],",
      "comment": "```suggestion\r\n        ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790216656,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:21:22Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790216656"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_client.py",
      "line": 707,
      "side": "RIGHT",
      "diff_hunk": "@@ -718,16 +704,14 @@ def _init_transport(\n     def _init_proxy_transport(\n         self,\n         proxy: Proxy,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n        ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790218211,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:22:18Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790218211"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "tests/test_config.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,48 +9,46 @@\n \n \n def test_load_ssl_config():\n-    context = httpx.create_ssl_context()\n+    context = httpx.SSLContext()\n     assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n     assert context.check_hostname is True\n \n \n def test_load_ssl_config_verify_non_existing_path():\n     with pytest.raises(IOError):\n-        httpx.create_ssl_context(verify=\"/path/to/nowhere\")\n+        httpx.SSLContext(verify=\"/path/to/nowhere\")\n \n \n-def test_load_ssl_config_verify_existing_file():\n-    context = httpx.create_ssl_context(verify=certifi.where())\n-    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n-    assert context.check_hostname is True\n-\n+@pytest.mark.parametrize(\n+    \"trust_env, expected_keylog_filename\",\n+    [\n+        pytest.param(True, \"test\", id=\"With trusting env\"),\n+        pytest.param(False, None, id=\"Without trusting env\"),\n+    ],\n+)\n+def test_load_ssl_with_keylog(\n+    monkeypatch: t.Any, trust_env: bool, expected_keylog_filename: t.Union[str, None]\n+) -> None:",
      "comment": "```suggestion\r\ndef test_load_ssl_with_keylog(\r\n    monkeypatch: typing.Any,\r\n    trust_env: bool,\r\n    expected_keylog_filename: typing.Union[str, None]\r\n) -> None:\r\n```",
      "comment_id": 1790224400,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:25:48Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790224400"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,8 +48,7 @@ def request(\n     proxy: ProxyTypes | None = None,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n     follow_redirects: bool = False,\n-    verify: VerifyTypes = True,\n-    cert: CertTypes | None = None,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n    ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790225935,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:26:40Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790225935"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 135,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,8 +132,7 @@ def stream(\n     proxy: ProxyTypes | None = None,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n     follow_redirects: bool = False,\n-    verify: VerifyTypes = True,\n-    cert: CertTypes | None = None,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n    ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790226408,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:26:57Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790226408"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 179,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,8 +176,7 @@ def get(\n     auth: AuthTypes | None = None,\n     proxy: ProxyTypes | None = None,\n     follow_redirects: bool = False,\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n    ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790226941,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:27:14Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790226941"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -225,8 +212,7 @@ def options(\n     auth: AuthTypes | None = None,\n     proxy: ProxyTypes | None = None,\n     follow_redirects: bool = False,\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n    ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790227449,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:27:31Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790227449"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,8 +248,7 @@ def head(\n     auth: AuthTypes | None = None,\n     proxy: ProxyTypes | None = None,\n     follow_redirects: bool = False,\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n    ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790227923,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:27:47Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790227923"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 291,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,8 +288,7 @@ def post(\n     auth: AuthTypes | None = None,\n     proxy: ProxyTypes | None = None,\n     follow_redirects: bool = False,\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n    ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790228710,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:28:10Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790228710"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 332,
      "side": "RIGHT",
      "diff_hunk": "@@ -348,8 +329,7 @@ def put(\n     auth: AuthTypes | None = None,\n     proxy: ProxyTypes | None = None,\n     follow_redirects: bool = False,\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n    ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790229202,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:28:25Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790229202"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 373,
      "side": "RIGHT",
      "diff_hunk": "@@ -391,8 +370,7 @@ def patch(\n     auth: AuthTypes | None = None,\n     proxy: ProxyTypes | None = None,\n     follow_redirects: bool = False,\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n    ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790229610,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:28:41Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790229610"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_api.py",
      "line": 411,
      "side": "RIGHT",
      "diff_hunk": "@@ -430,9 +407,8 @@ def delete(\n     auth: AuthTypes | None = None,\n     proxy: ProxyTypes | None = None,\n     follow_redirects: bool = False,\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n+    ssl_context: typing.Optional[ssl.SSLContext] = None,",
      "comment": "```suggestion\r\n    ssl_context: ssl.SSLContext | None = None,\r\n```",
      "comment_id": 1790230064,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:28:57Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790230064"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_client.py",
      "line": 691,
      "side": "RIGHT",
      "diff_hunk": "@@ -695,20 +683,18 @@ def __init__(\n \n     def _init_transport(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        ssl_context: typing.Optional[ssl.SSLContext],\n         http1: bool = True,\n         http2: bool = False,\n         limits: Limits = DEFAULT_LIMITS,\n-        transport: BaseTransport | None = None,\n         trust_env: bool = True,\n+        transport: typing.Optional[BaseTransport] = None,",
      "comment": "```suggestion\r\n        transport: BaseTransport | None = None,\r\n        trust_env: bool = True,\r\n```",
      "comment_id": 1790231357,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:29:40Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790231357"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_client.py",
      "line": 691,
      "side": "RIGHT",
      "diff_hunk": "@@ -695,20 +683,18 @@ def __init__(\n \n     def _init_transport(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        ssl_context: typing.Optional[ssl.SSLContext],\n         http1: bool = True,\n         http2: bool = False,\n         limits: Limits = DEFAULT_LIMITS,\n-        transport: BaseTransport | None = None,\n         trust_env: bool = True,\n+        transport: typing.Optional[BaseTransport] = None,",
      "comment": "```suggestion\r\n        transport: BaseTransport | None = None,\r\n        trust_env: bool = True,\r\n```",
      "comment_id": 1790234890,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:31:40Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790234890"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "tests/test_config.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,48 +9,46 @@\n \n \n def test_load_ssl_config():\n-    context = httpx.create_ssl_context()\n+    context = httpx.SSLContext()\n     assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n     assert context.check_hostname is True\n \n \n def test_load_ssl_config_verify_non_existing_path():\n     with pytest.raises(IOError):\n-        httpx.create_ssl_context(verify=\"/path/to/nowhere\")\n+        httpx.SSLContext(verify=\"/path/to/nowhere\")\n \n \n-def test_load_ssl_config_verify_existing_file():\n-    context = httpx.create_ssl_context(verify=certifi.where())\n-    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n-    assert context.check_hostname is True\n-\n+@pytest.mark.parametrize(\n+    \"trust_env, expected_keylog_filename\",\n+    [\n+        pytest.param(True, \"test\", id=\"With trusting env\"),\n+        pytest.param(False, None, id=\"Without trusting env\"),\n+    ],\n+)\n+def test_load_ssl_with_keylog(\n+    monkeypatch: t.Any, trust_env: bool, expected_keylog_filename: t.Union[str, None]\n+) -> None:",
      "comment": "`typing.Union[str, None]` -> `str | None`\r\n\r\nIMO, we could also use add these type annotations in separated PR which includes annotating other tests?",
      "comment_id": 1790238999,
      "user": "T-256",
      "created_at": "2024-10-07T13:34:02Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790238999"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "tests/test_config.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,48 +9,48 @@\n \n \n def test_load_ssl_config():\n-    context = httpx.create_ssl_context()\n+    context = httpx.SSLContext()\n     assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n     assert context.check_hostname is True\n \n \n def test_load_ssl_config_verify_non_existing_path():\n     with pytest.raises(IOError):\n-        httpx.create_ssl_context(verify=\"/path/to/nowhere\")\n+        httpx.SSLContext(verify=\"/path/to/nowhere\")\n \n \n-def test_load_ssl_config_verify_existing_file():\n-    context = httpx.create_ssl_context(verify=certifi.where())\n-    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n-    assert context.check_hostname is True\n-\n+@pytest.mark.parametrize(\n+    \"trust_env, expected_keylog_filename\",\n+    [\n+        pytest.param(True, \"test\", id=\"With trusting env\"),\n+        pytest.param(False, None, id=\"Without trusting env\"),\n+    ],\n+)\n+def test_load_ssl_with_keylog(\n+    monkeypatch: typing.Any,\n+    trust_env: bool,\n+    expected_keylog_filename: typing.Union[str, None]",
      "comment": "```suggestion\r\n    expected_keylog_filename: typing.Union[str, None],\r\n```",
      "comment_id": 1790250479,
      "user": "lovelydinosaur",
      "created_at": "2024-10-07T13:40:33Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1790250479"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "tests/test_config.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,48 +9,48 @@\n \n \n def test_load_ssl_config():\n-    context = httpx.create_ssl_context()\n+    context = httpx.SSLContext()\n     assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n     assert context.check_hostname is True\n \n \n def test_load_ssl_config_verify_non_existing_path():\n     with pytest.raises(IOError):\n-        httpx.create_ssl_context(verify=\"/path/to/nowhere\")\n+        httpx.SSLContext(verify=\"/path/to/nowhere\")\n \n \n-def test_load_ssl_config_verify_existing_file():\n-    context = httpx.create_ssl_context(verify=certifi.where())\n-    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n-    assert context.check_hostname is True\n-\n+@pytest.mark.parametrize(\n+    \"trust_env, expected_keylog_filename\",\n+    [\n+        pytest.param(True, \"test\", id=\"With trusting env\"),\n+        pytest.param(False, None, id=\"Without trusting env\"),\n+    ],\n+)\n+def test_load_ssl_with_keylog(\n+    monkeypatch: typing.Any,\n+    trust_env: bool,\n+    expected_keylog_filename: typing.Union[str, None],\n+) -> None:\n+    monkeypatch.setenv(\"SSLKEYLOGFILE\", \"test\")\n+    context = httpx.SSLContext(trust_env=trust_env)\n+    assert context.keylog_filename == expected_keylog_filename",
      "comment": "```suggestion\r\ndef test_load_ssl_with_keylog(\r\n    monkeypatch: typing.Any,\r\n    expected_keylog_filename: typing.Union[str, None],\r\n) -> None:\r\n    monkeypatch.setenv(\"SSLKEYLOGFILE\", \"test\")\r\n    context = httpx.SSLContext()\r\n    assert context.keylog_filename == expected_keylog_filename\r\n```",
      "comment_id": 1791561015,
      "user": "lovelydinosaur",
      "created_at": "2024-10-08T09:45:45Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1791561015"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_client.py",
      "line": 673,
      "side": "LEFT",
      "diff_hunk": "@@ -664,25 +656,21 @@ def __init__(\n         proxy_map = self._get_proxy_map(proxy, allow_env_proxies)\n \n         self._transport = self._init_transport(\n-            verify=verify,\n-            cert=cert,\n+            ssl_context=ssl_context,\n             http1=http1,\n             http2=http2,\n             limits=limits,\n             transport=transport,\n-            trust_env=trust_env,",
      "comment": "This is in the right direction... dropping `trust_env` out of the `httpx.SSLContext()` API.",
      "comment_id": 1791568594,
      "user": "lovelydinosaur",
      "created_at": "2024-10-08T09:50:46Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1791568594"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "httpx/_config.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,151 +45,103 @@ class UnsetType:\n UNSET = UnsetType()\n \n \n-def create_ssl_context(\n-    cert: CertTypes | None = None,\n-    verify: VerifyTypes = True,\n-    trust_env: bool = True,\n-    http2: bool = False,\n-) -> ssl.SSLContext:\n-    return SSLConfig(\n-        cert=cert, verify=verify, trust_env=trust_env, http2=http2\n-    ).ssl_context\n-\n-\n-class SSLConfig:\n-    \"\"\"\n-    SSL Configuration.\n-    \"\"\"\n-\n+class SSLContext(ssl.SSLContext):\n     DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n \n     def __init__(\n         self,\n-        *,\n-        cert: CertTypes | None = None,\n         verify: VerifyTypes = True,\n+        cert: CertTypes | None = None,\n         trust_env: bool = True,\n-        http2: bool = False,\n     ) -> None:\n-        self.cert = cert\n         self.verify = verify\n+        set_minimum_tls_version_1_2(self)\n+        self.options |= ssl.OP_NO_COMPRESSION\n+        self.set_ciphers(DEFAULT_CIPHERS)\n         self.trust_env = trust_env\n-        self.http2 = http2\n-        self.ssl_context = self.load_ssl_context()\n \n-    def load_ssl_context(self) -> ssl.SSLContext:\n+        keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n+        if keylogfile and self.trust_env:",
      "comment": "Yes we're applying this unilaterally. (In line with `ssl.create_default_context()`, `urllib3`, and `requests`)",
      "comment_id": 1791571187,
      "user": "lovelydinosaur",
      "created_at": "2024-10-08T09:52:28Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1791571187"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3022,
      "file_path": "tests/test_config.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,48 +9,40 @@\n \n \n def test_load_ssl_config():\n-    context = httpx.create_ssl_context()\n+    context = httpx.SSLContext()\n     assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n     assert context.check_hostname is True\n \n \n def test_load_ssl_config_verify_non_existing_path():\n     with pytest.raises(IOError):\n-        httpx.create_ssl_context(verify=\"/path/to/nowhere\")\n+        httpx.SSLContext(verify=\"/path/to/nowhere\")\n \n \n-def test_load_ssl_config_verify_existing_file():\n-    context = httpx.create_ssl_context(verify=certifi.where())\n-    assert context.verify_mode == ssl.VerifyMode.CERT_REQUIRED\n-    assert context.check_hostname is True\n+def test_load_ssl_with_keylog(\n+    monkeypatch: typing.Any,\n+    expected_keylog_filename: typing.Union[str, None],\n+) -> None:\n+    monkeypatch.setenv(\"SSLKEYLOGFILE\", \"test\")\n+    context = httpx.SSLContext()\n+    assert context.keylog_filename == expected_keylog_filename",
      "comment": "```suggestion\r\ndef test_load_ssl_with_keylog(monkeypatch: typing.Any) -> None:\r\n    monkeypatch.setenv(\"SSLKEYLOGFILE\", \"test\")\r\n    context = httpx.SSLContext()\r\n    assert context.keylog_filename == \"test\"\r\n```",
      "comment_id": 1791576267,
      "user": "lovelydinosaur",
      "created_at": "2024-10-08T09:55:50Z",
      "url": "https://github.com/encode/httpx/pull/3022#discussion_r1791576267"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3335,
      "file_path": "httpx/_config.py",
      "line": 49,
      "side": "LEFT",
      "diff_hunk": "@@ -46,92 +45,41 @@ class UnsetType:\n \n \n class SSLContext(ssl.SSLContext):\n-    DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())",
      "comment": "Let's keep it, avoid new `certifi.where()` call per instantization.",
      "comment_id": 1791986336,
      "user": "T-256",
      "created_at": "2024-10-08T14:25:39Z",
      "url": "https://github.com/encode/httpx/pull/3335#discussion_r1791986336"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3335,
      "file_path": "httpx/_config.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,92 +45,41 @@ class UnsetType:\n \n \n class SSLContext(ssl.SSLContext):\n-    DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n-\n     def __init__(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        verify: bool = True,\n     ) -> None:\n-        self.verify = verify\n-        set_minimum_tls_version_1_2(self)\n-        self.options |= ssl.OP_NO_COMPRESSION\n-        self.set_ciphers(DEFAULT_CIPHERS)\n-\n-        keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n-        if keylogfile:\n-            self.keylog_filename = keylogfile\n-\n-        logger.debug(\n-            \"load_ssl_context verify=%r cert=%r\",\n-            verify,\n-            cert,\n-        )\n+        super().__init__()\n+        self._verify = verify\n \n+        # Our SSL setup here is similar to the stdlib `ssl.create_default_context()`\n+        # implementation, except with `certifi` used for certificate verification.",
      "comment": "when `verify=False`, we actually don't load certifi. let's move this comment to down.",
      "comment_id": 1791997641,
      "user": "T-256",
      "created_at": "2024-10-08T14:31:02Z",
      "url": "https://github.com/encode/httpx/pull/3335#discussion_r1791997641"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3335,
      "file_path": "httpx/_config.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,92 +45,41 @@ class UnsetType:\n \n \n class SSLContext(ssl.SSLContext):\n-    DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n-\n     def __init__(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        verify: bool = True,\n     ) -> None:\n-        self.verify = verify\n-        set_minimum_tls_version_1_2(self)\n-        self.options |= ssl.OP_NO_COMPRESSION\n-        self.set_ciphers(DEFAULT_CIPHERS)\n-\n-        keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n-        if keylogfile:\n-            self.keylog_filename = keylogfile\n-\n-        logger.debug(\n-            \"load_ssl_context verify=%r cert=%r\",\n-            verify,\n-            cert,\n-        )\n+        super().__init__()\n+        self._verify = verify\n \n+        # Our SSL setup here is similar to the stdlib `ssl.create_default_context()`\n+        # implementation, except with `certifi` used for certificate verification.\n         if not verify:\n             self.check_hostname = False\n             self.verify_mode = ssl.CERT_NONE\n-            self._load_client_certs(cert)\n             return\n \n-        if isinstance(verify, bool):\n-            ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\n-        elif Path(verify).exists():\n-            ca_bundle_path = Path(verify)\n-        else:\n-            raise IOError(\n-                \"Could not find a suitable TLS CA certificate bundle, \"\n-                \"invalid path: {}\".format(verify)\n-            )\n-\n         self.verify_mode = ssl.CERT_REQUIRED\n         self.check_hostname = True\n \n-        # Signal to server support for PHA in TLS 1.3. Raises an\n-        # AttributeError if only read-only access is implemented.\n-        try:\n-            self.post_handshake_auth = True\n-        except AttributeError:  # pragma: no cover\n-            pass\n-\n-        # Disable using 'commonName' for SSLContext.check_hostname\n-        # when the 'subjectAltName' extension isn't available.\n-        try:\n-            self.hostname_checks_common_name = False\n-        except AttributeError:  # pragma: no cover\n-            pass\n-\n-        if ca_bundle_path.is_file():\n-            cafile = str(ca_bundle_path)\n-            logger.debug(\"load_verify_locations cafile=%r\", cafile)\n-            self.load_verify_locations(cafile=cafile)\n-        elif ca_bundle_path.is_dir():\n-            capath = str(ca_bundle_path)\n-            logger.debug(\"load_verify_locations capath=%r\", capath)\n-            self.load_verify_locations(capath=capath)\n-\n-        self._load_client_certs(cert)\n-\n-    def _load_client_certs(self, cert: typing.Optional[CertTypes] = None) -> None:\n-        \"\"\"\n-        Loads client certificates into our SSLContext object\n-        \"\"\"\n-        if cert is not None:\n-            if isinstance(cert, str):\n-                self.load_cert_chain(certfile=cert)\n-            elif isinstance(cert, tuple) and len(cert) == 2:\n-                self.load_cert_chain(certfile=cert[0], keyfile=cert[1])\n-            elif isinstance(cert, tuple) and len(cert) == 3:\n-                self.load_cert_chain(\n-                    certfile=cert[0],\n-                    keyfile=cert[1],\n-                    password=cert[2],\n-                )\n+        # Use stricter verify flags where possible.\n+        if hasattr(ssl, \"VERIFY_X509_PARTIAL_CHAIN\"):  # pragma: nocover\n+            self.verify_flags |= ssl.VERIFY_X509_PARTIAL_CHAIN\n+        if hasattr(ssl, \"VERIFY_X509_STRICT\"):  # pragma: nocover\n+            self.verify_flags |= ssl.VERIFY_X509_STRICT\n+\n+        # Default to `certifi` for certificiate verification.\n+        self.load_verify_locations(cafile=certifi.where())\n+\n+        # OpenSSL keylog file support.\n+        if hasattr(self, \"keylog_filename\"):\n+            keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n+            if keylogfile and not sys.flags.ignore_environment:",
      "comment": "Do we need to document `sys.flags.ignore_environment` behavior at here?",
      "comment_id": 1792003687,
      "user": "T-256",
      "created_at": "2024-10-08T14:34:25Z",
      "url": "https://github.com/encode/httpx/pull/3335#discussion_r1792003687"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3335,
      "file_path": "httpx/_config.py",
      "line": 60,
      "side": "LEFT",
      "diff_hunk": "@@ -46,92 +45,41 @@ class UnsetType:\n \n \n class SSLContext(ssl.SSLContext):\n-    DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n-\n     def __init__(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        verify: bool = True,\n     ) -> None:\n-        self.verify = verify\n-        set_minimum_tls_version_1_2(self)\n-        self.options |= ssl.OP_NO_COMPRESSION\n-        self.set_ciphers(DEFAULT_CIPHERS)\n-",
      "comment": "We've been following `urllib3`'s lead on SSL, and have [some out of date defaults here](https://github.com/urllib3/urllib3/pull/2705).",
      "comment_id": 1794964425,
      "user": "lovelydinosaur",
      "created_at": "2024-10-10T08:29:07Z",
      "url": "https://github.com/encode/httpx/pull/3335#discussion_r1794964425"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3335,
      "file_path": "httpx/_config.py",
      "line": 49,
      "side": "LEFT",
      "diff_hunk": "@@ -46,92 +45,41 @@ class UnsetType:\n \n \n class SSLContext(ssl.SSLContext):\n-    DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())",
      "comment": "Calling `certifi.where()` at the point the certifi certificates are loaded seems reasonable to me.",
      "comment_id": 1795109143,
      "user": "lovelydinosaur",
      "created_at": "2024-10-10T10:05:43Z",
      "url": "https://github.com/encode/httpx/pull/3335#discussion_r1795109143"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3335,
      "file_path": "httpx/_config.py",
      "line": 102,
      "side": "LEFT",
      "diff_hunk": "@@ -46,92 +45,41 @@ class UnsetType:\n \n \n class SSLContext(ssl.SSLContext):\n-    DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n-\n     def __init__(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        verify: bool = True,\n     ) -> None:\n-        self.verify = verify\n-        set_minimum_tls_version_1_2(self)\n-        self.options |= ssl.OP_NO_COMPRESSION\n-        self.set_ciphers(DEFAULT_CIPHERS)\n-\n-        keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n-        if keylogfile:\n-            self.keylog_filename = keylogfile\n-\n-        logger.debug(\n-            \"load_ssl_context verify=%r cert=%r\",\n-            verify,\n-            cert,\n-        )\n+        super().__init__()\n+        self._verify = verify\n \n+        # Our SSL setup here is similar to the stdlib `ssl.create_default_context()`\n+        # implementation, except with `certifi` used for certificate verification.\n         if not verify:\n             self.check_hostname = False\n             self.verify_mode = ssl.CERT_NONE\n-            self._load_client_certs(cert)\n             return\n \n-        if isinstance(verify, bool):\n-            ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\n-        elif Path(verify).exists():\n-            ca_bundle_path = Path(verify)\n-        else:\n-            raise IOError(\n-                \"Could not find a suitable TLS CA certificate bundle, \"\n-                \"invalid path: {}\".format(verify)\n-            )\n-\n         self.verify_mode = ssl.CERT_REQUIRED\n         self.check_hostname = True\n \n-        # Signal to server support for PHA in TLS 1.3. Raises an\n-        # AttributeError if only read-only access is implemented.\n-        try:\n-            self.post_handshake_auth = True\n-        except AttributeError:  # pragma: no cover\n-            pass\n-\n-        # Disable using 'commonName' for SSLContext.check_hostname\n-        # when the 'subjectAltName' extension isn't available.\n-        try:\n-            self.hostname_checks_common_name = False\n-        except AttributeError:  # pragma: no cover\n-            pass",
      "comment": "Ah... there's possibly useful context to talk through for both `post_handshake_auth`, and for `hostname_checks_common_name`. I'm going to suggest that we start by matching the `stdlib` behaviour, and have a design discussion review on the SSL settings prior to 1.0.\r\n\r\nUsing commonName fallback has been deprecated for some time...\r\n\r\n* https://stackoverflow.com/questions/43665243/invalid-self-signed-ssl-cert-subject-alternative-name-missing\r\n* https://github.com/encode/httpx/discussions/2978\r\n* https://github.com/encode/httpx/discussions/3125\r\n\r\nThis is not enforced in `ssl.create_default_context()`, and perhaps we don't need to either if the user is working with self-signed certs may be their responsibility.\r\n\r\nWrt. PHA, this was introduced in `urllib3` based on this ticket...\r\n\r\nhttps://github.com/urllib3/urllib3/issues/1634\r\n\r\nIt's not obvious to me that \"client cert authentication based on HTTP request parameters like method or path\" is desirable.",
      "comment_id": 1795147435,
      "user": "lovelydinosaur",
      "created_at": "2024-10-10T10:21:25Z",
      "url": "https://github.com/encode/httpx/pull/3335#discussion_r1795147435"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3335,
      "file_path": "httpx/_config.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,92 +45,41 @@ class UnsetType:\n \n \n class SSLContext(ssl.SSLContext):\n-    DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n-\n     def __init__(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        verify: bool = True,\n     ) -> None:\n-        self.verify = verify\n-        set_minimum_tls_version_1_2(self)\n-        self.options |= ssl.OP_NO_COMPRESSION\n-        self.set_ciphers(DEFAULT_CIPHERS)\n-\n-        keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n-        if keylogfile:\n-            self.keylog_filename = keylogfile\n-\n-        logger.debug(\n-            \"load_ssl_context verify=%r cert=%r\",\n-            verify,\n-            cert,\n-        )\n+        super().__init__()\n+        self._verify = verify\n \n+        # Our SSL setup here is similar to the stdlib `ssl.create_default_context()`\n+        # implementation, except with `certifi` used for certificate verification.\n         if not verify:\n             self.check_hostname = False\n             self.verify_mode = ssl.CERT_NONE\n-            self._load_client_certs(cert)\n             return\n \n-        if isinstance(verify, bool):\n-            ca_bundle_path = self.DEFAULT_CA_BUNDLE_PATH\n-        elif Path(verify).exists():\n-            ca_bundle_path = Path(verify)\n-        else:\n-            raise IOError(\n-                \"Could not find a suitable TLS CA certificate bundle, \"\n-                \"invalid path: {}\".format(verify)\n-            )\n-\n         self.verify_mode = ssl.CERT_REQUIRED\n         self.check_hostname = True\n \n-        # Signal to server support for PHA in TLS 1.3. Raises an\n-        # AttributeError if only read-only access is implemented.\n-        try:\n-            self.post_handshake_auth = True\n-        except AttributeError:  # pragma: no cover\n-            pass\n-\n-        # Disable using 'commonName' for SSLContext.check_hostname\n-        # when the 'subjectAltName' extension isn't available.\n-        try:\n-            self.hostname_checks_common_name = False\n-        except AttributeError:  # pragma: no cover\n-            pass\n-\n-        if ca_bundle_path.is_file():\n-            cafile = str(ca_bundle_path)\n-            logger.debug(\"load_verify_locations cafile=%r\", cafile)\n-            self.load_verify_locations(cafile=cafile)\n-        elif ca_bundle_path.is_dir():\n-            capath = str(ca_bundle_path)\n-            logger.debug(\"load_verify_locations capath=%r\", capath)\n-            self.load_verify_locations(capath=capath)\n-\n-        self._load_client_certs(cert)\n-\n-    def _load_client_certs(self, cert: typing.Optional[CertTypes] = None) -> None:\n-        \"\"\"\n-        Loads client certificates into our SSLContext object\n-        \"\"\"\n-        if cert is not None:\n-            if isinstance(cert, str):\n-                self.load_cert_chain(certfile=cert)\n-            elif isinstance(cert, tuple) and len(cert) == 2:\n-                self.load_cert_chain(certfile=cert[0], keyfile=cert[1])\n-            elif isinstance(cert, tuple) and len(cert) == 3:\n-                self.load_cert_chain(\n-                    certfile=cert[0],\n-                    keyfile=cert[1],\n-                    password=cert[2],\n-                )\n+        # Use stricter verify flags where possible.\n+        if hasattr(ssl, \"VERIFY_X509_PARTIAL_CHAIN\"):  # pragma: nocover\n+            self.verify_flags |= ssl.VERIFY_X509_PARTIAL_CHAIN\n+        if hasattr(ssl, \"VERIFY_X509_STRICT\"):  # pragma: nocover\n+            self.verify_flags |= ssl.VERIFY_X509_STRICT\n+\n+        # Default to `certifi` for certificiate verification.\n+        self.load_verify_locations(cafile=certifi.where())\n+\n+        # OpenSSL keylog file support.\n+        if hasattr(self, \"keylog_filename\"):\n+            keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n+            if keylogfile and not sys.flags.ignore_environment:",
      "comment": "Maybe. We're just following `stdlib` behavior here. Can take a final review on that once we've dealt with getting the API clean-up in.",
      "comment_id": 1795162041,
      "user": "lovelydinosaur",
      "created_at": "2024-10-10T10:30:10Z",
      "url": "https://github.com/encode/httpx/pull/3335#discussion_r1795162041"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3335,
      "file_path": "httpx/_config.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,92 +22,41 @@ class UnsetType:\n \n \n class SSLContext(ssl.SSLContext):\n-    DEFAULT_CA_BUNDLE_PATH = Path(certifi.where())\n-\n     def __init__(\n         self,\n-        verify: VerifyTypes = True,\n-        cert: CertTypes | None = None,\n+        verify: bool = True,\n     ) -> None:\n-        self.verify = verify\n-        set_minimum_tls_version_1_2(self)\n-        self.options |= ssl.OP_NO_COMPRESSION\n-        self.set_ciphers(DEFAULT_CIPHERS)\n-\n-        keylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n-        if keylogfile:\n-            self.keylog_filename = keylogfile\n-\n-        logger.debug(\n-            \"load_ssl_context verify=%r cert=%r\",\n-            verify,\n-            cert,\n-        )\n+        super().__init__()",
      "comment": "```suggestion\r\n        # ssl.SSLContext sets OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION,\r\n        # OP_CIPHER_SERVER_PREFERENCE, OP_SINGLE_DH_USE and OP_SINGLE_ECDH_USE\r\n        # by default. (from `ssl.create_default_context`)\r\n        super().__init__()\r\n```",
      "comment_id": 1795338325,
      "user": "T-256",
      "created_at": "2024-10-10T12:34:23Z",
      "url": "https://github.com/encode/httpx/pull/3335#discussion_r1795338325"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3050,
      "file_path": "httpx/_client.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -682,7 +679,13 @@ def __init__(\n             if proxy:\n                 raise RuntimeError(\"Use either `proxy` or 'proxies', not both.\")\n \n-        allow_env_proxies = trust_env and app is None and transport is None\n+        if app:\n+            raise RuntimeError(",
      "comment": "I don't know what's deprecation policy but are you sure raise error here? isn't it breaking change for those using `app`?\r\n\r\nI'd recommend keep docs, type-hints and use warning instead. then we can schedule the removal version and mention it in warning message (?)",
      "comment_id": 1451676418,
      "user": "T-256",
      "created_at": "2024-01-14T07:53:50Z",
      "url": "https://github.com/encode/httpx/pull/3050#discussion_r1451676418"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3050,
      "file_path": "httpx/_client.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -682,7 +679,13 @@ def __init__(\n             if proxy:\n                 raise RuntimeError(\"Use either `proxy` or 'proxies', not both.\")\n \n-        allow_env_proxies = trust_env and app is None and transport is None\n+        if app:\n+            raise RuntimeError(",
      "comment": "> I don't know what's deprecation policy but are you sure raise error here? isn't it breaking change for those using `app`?\r\n\r\nIt looks good to me if this breaking change is for 1.0. But do we want to keep these additional errors in 1.0?",
      "comment_id": 1451678340,
      "user": "T-256",
      "created_at": "2024-01-14T08:06:37Z",
      "url": "https://github.com/encode/httpx/pull/3050#discussion_r1451678340"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3050,
      "file_path": "httpx/_client.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -682,7 +679,13 @@ def __init__(\n             if proxy:\n                 raise RuntimeError(\"Use either `proxy` or 'proxies', not both.\")\n \n-        allow_env_proxies = trust_env and app is None and transport is None\n+        if app:\n+            raise RuntimeError(",
      "comment": "> It looks good to me if this breaking change is for 1.0. But do we want to keep these additional errors in 1.0?\r\n\r\nSo...  we'll need to have consistency around this.\r\n\r\nOptions might be...\r\n\r\n* Include old argument styles for 1.0 with explicit errors, to aid migrations. Clean up later and drop the errors in a 1.1 release.\r\n* Don't include old argument styles.",
      "comment_id": 1452183188,
      "user": "lovelydinosaur",
      "created_at": "2024-01-15T10:20:51Z",
      "url": "https://github.com/encode/httpx/pull/3050#discussion_r1452183188"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3050,
      "file_path": "httpx/_client.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -682,7 +679,13 @@ def __init__(\n             if proxy:\n                 raise RuntimeError(\"Use either `proxy` or 'proxies', not both.\")\n \n-        allow_env_proxies = trust_env and app is None and transport is None\n+        if app:\n+            raise RuntimeError(",
      "comment": "At there, I'm more fan of what done for `proxies`:\r\nhttps://github.com/encode/httpx/blob/419d3a9d80d0c4072f6cb58eeb306148ae89e2e9/httpx/_client.py#L676-L681\r\n\r\nSo, what I can suggest at here is:\r\n1. deprecate and mention scheduled removal if any (e.g. \"The 'proxies' argument is now deprecated and it will remove in v1.0.0\")\r\n2. minor/patch release\r\n3. clear all deprecations in major release",
      "comment_id": 1452230760,
      "user": "T-256",
      "created_at": "2024-01-15T10:58:47Z",
      "url": "https://github.com/encode/httpx/pull/3050#discussion_r1452230760"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3050,
      "file_path": "httpx/_client.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -682,7 +679,13 @@ def __init__(\n             if proxy:\n                 raise RuntimeError(\"Use either `proxy` or 'proxies', not both.\")\n \n-        allow_env_proxies = trust_env and app is None and transport is None\n+        if app:\n+            raise RuntimeError(",
      "comment": "I think now is good time to discuss about deprecation policy, since there are few `1.0 proposal` PRs those trying to directly remove APIs without any deprecation.",
      "comment_id": 1452235919,
      "user": "T-256",
      "created_at": "2024-01-15T11:03:24Z",
      "url": "https://github.com/encode/httpx/pull/3050#discussion_r1452235919"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3050,
      "file_path": "httpx/_client.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -682,7 +679,13 @@ def __init__(\n             if proxy:\n                 raise RuntimeError(\"Use either `proxy` or 'proxies', not both.\")\n \n-        allow_env_proxies = trust_env and app is None and transport is None\n+        if app:\n+            raise RuntimeError(",
      "comment": "https://github.com/encode/httpx/pull/3069 would be a good place for us to discuss how we'd like to approach this.",
      "comment_id": 1466121446,
      "user": "lovelydinosaur",
      "created_at": "2024-01-25T09:58:45Z",
      "url": "https://github.com/encode/httpx/pull/3050#discussion_r1466121446"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3050,
      "file_path": "httpx/_client.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -682,7 +679,13 @@ def __init__(\n             if proxy:\n                 raise RuntimeError(\"Use either `proxy` or 'proxies', not both.\")\n \n-        allow_env_proxies = trust_env and app is None and transport is None\n+        if app:\n+            raise RuntimeError(",
      "comment": "Via #3071 and since v1.0 is major upgrade, I'm now more interested to directly drop instead of deprecation.\r\n",
      "comment_id": 1466369932,
      "user": "T-256",
      "created_at": "2024-01-25T13:19:15Z",
      "url": "https://github.com/encode/httpx/pull/3050#discussion_r1466369932"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3312,
      "file_path": "tests/test_utils.py",
      "line": 319,
      "side": "RIGHT",
      "diff_hunk": "@@ -300,6 +301,24 @@ def test_url_matches(pattern, url, expected):\n     assert pattern.matches(httpx.URL(url)) == expected\n \n \n+@pytest.mark.parametrize(\n+    [\"value\", \"expected\"],\n+    [\n+        (b\"value\", b\"value\"),\n+        (b\"success\", b\"success\"),\n+    ],\n+)\n+def test_normalize_header_value(value, expected):\n+    assert normalize_header_value(value) == expected\n+\n+\n+def test_normalize_header_incorrect_value():\n+    with pytest.raises(\n+        TypeError, match=f\"Header value must be str or bytes, not {type(None)}\"\n+    ):\n+        normalize_header_value(None)  # type: ignore",
      "comment": "Could we have these tests in `tests/client/test_headers.py` with the testing against `httpx.Header(...)` instead of against the internal API?",
      "comment_id": 1777193345,
      "user": "lovelydinosaur",
      "created_at": "2024-09-26T14:31:17Z",
      "url": "https://github.com/encode/httpx/pull/3312#discussion_r1777193345"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3250,
      "file_path": "httpx/_urlparse.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,7 +160,12 @@ def urlparse(url: str = \"\", **kwargs: str | None) -> ParseResult:\n     # If a URL includes any ASCII control characters including \\t, \\r, \\n,\n     # then treat it as invalid.\n     if any(char.isascii() and not char.isprintable() for char in url):\n-        raise InvalidURL(\"Invalid non-printable ASCII character in URL\")\n+        char = [char for char in url if char.isascii() and not char.isprintable()][0]",
      "comment": "Could this be done lazily without materializing the list?",
      "comment_id": 1692499301,
      "user": "adriangb",
      "created_at": "2024-07-26T04:31:08Z",
      "url": "https://github.com/encode/httpx/pull/3250#discussion_r1692499301"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3250,
      "file_path": "httpx/_urlparse.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,9 +210,15 @@ def urlparse(url: str = \"\", **kwargs: str | None) -> ParseResult:\n             # If a component includes any ASCII control characters including \\t, \\r, \\n,\n             # then treat it as invalid.\n             if any(char.isascii() and not char.isprintable() for char in value):\n-                raise InvalidURL(\n-                    f\"Invalid non-printable ASCII character in URL component '{key}'\"\n+                char = [\n+                    char for char in value if char.isascii() and not char.isprintable()\n+                ][0]",
      "comment": "Same here. This could be a small utility function as well (it's duplicated in 2 places, I'm okay keeping it duplicated).",
      "comment_id": 1692499591,
      "user": "adriangb",
      "created_at": "2024-07-26T04:31:43Z",
      "url": "https://github.com/encode/httpx/pull/3250#discussion_r1692499591"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3250,
      "file_path": "httpx/_urlparse.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,7 +160,12 @@ def urlparse(url: str = \"\", **kwargs: str | None) -> ParseResult:\n     # If a URL includes any ASCII control characters including \\t, \\r, \\n,\n     # then treat it as invalid.\n     if any(char.isascii() and not char.isprintable() for char in url):\n-        raise InvalidURL(\"Invalid non-printable ASCII character in URL\")\n+        char = [char for char in url if char.isascii() and not char.isprintable()][0]",
      "comment": "It can be done lazily by materializing a generator yes. \u270c\ufe0f",
      "comment_id": 1692707828,
      "user": "lovelydinosaur",
      "created_at": "2024-07-26T08:35:24Z",
      "url": "https://github.com/encode/httpx/pull/3250#discussion_r1692707828"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3139,
      "file_path": "httpx/_decoders.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,6 +140,41 @@ def flush(self) -> bytes:\n             raise DecodingError(str(exc)) from exc\n \n \n+class ZStandardDecoder(ContentDecoder):\n+    \"\"\"\n+    Handle 'zstd' RFC 8878 decoding.\n+\n+    Requires `pip install zstandard`.\n+    Can be installed as a dependency of httpx using `pip install httpx[zstd]`.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        if zstd is False:  # pragma: no cover\n+            raise ImportError(\n+                \"Using 'ZStandardDecoder', ...\"\n+                \"Make sure to install httpx using `pip install httpx[zstd]`.\"\n+            ) from None\n+\n+        self.decompressor = zstd.ZstdDecompressor().decompressobj()\n+\n+    def decode(self, data: bytes) -> bytes:\n+        try:\n+            data_parts = [self.decompressor.decompress(data)]\n+            while self.decompressor.eof and self.decompressor.unused_data:\n+                unused_data = self.decompressor.unused_data\n+                self.decompressor = zstd.ZstdDecompressor().decompressobj()\n+                data_parts.append(self.decompressor.decompress(unused_data))",
      "comment": "I may be wrong about this one. But wouldn't read_across_frames=True simplify this logic (since it will allow to read multiple frames)?",
      "comment_id": 1518812853,
      "user": "Zaczero",
      "created_at": "2024-03-10T10:19:09Z",
      "url": "https://github.com/encode/httpx/pull/3139#discussion_r1518812853"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3139,
      "file_path": "httpx/_compat.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,6 +18,23 @@\n     except ImportError:\n         brotli = None\n \n+# Zstandard support is optional\n+try:\n+    import zstandard as zstd\n+except (AttributeError, ImportError, ValueError):  # Defensive:\n+    zstd = False\n+else:\n+    # The package 'zstandard' added the 'eof' property starting\n+    # in v0.18.0 which we require to ensure a complete and\n+    # valid zstd stream was fed into the ZstdDecoder.\n+    # See: https://github.com/urllib3/urllib3/pull/2624\n+    _zstd_version = tuple(\n+        map(int, re.search(r\"^([0-9]+)\\.([0-9]+)\", zstd.__version__).groups())  # type: ignore[union-attr]\n+    )\n+    if _zstd_version < (0, 18):  # Defensive:\n+        zstd = False",
      "comment": "This is just out of my curiosity, feel free to not answer it.\r\nWhy do we need this code if we already specify zstandard>=0.18.0, wouldn't package manager guarantee it already?",
      "comment_id": 1518813076,
      "user": "Zaczero",
      "created_at": "2024-03-10T10:20:32Z",
      "url": "https://github.com/encode/httpx/pull/3139#discussion_r1518813076"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3139,
      "file_path": "httpx/_compat.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,6 +18,23 @@\n     except ImportError:\n         brotli = None\n \n+# Zstandard support is optional\n+try:\n+    import zstandard as zstd\n+except (AttributeError, ImportError, ValueError):  # Defensive:\n+    zstd = False\n+else:\n+    # The package 'zstandard' added the 'eof' property starting\n+    # in v0.18.0 which we require to ensure a complete and\n+    # valid zstd stream was fed into the ZstdDecoder.\n+    # See: https://github.com/urllib3/urllib3/pull/2624\n+    _zstd_version = tuple(\n+        map(int, re.search(r\"^([0-9]+)\\.([0-9]+)\", zstd.__version__).groups())  # type: ignore[union-attr]\n+    )\n+    if _zstd_version < (0, 18):  # Defensive:\n+        zstd = False",
      "comment": " zstandard is an optional install. So if your `requirements.txt` just has `httpx` and not `httpx[zstd]`, and you have `zstandard==[old version]` somehow, this would prevent breakage.",
      "comment_id": 1518815892,
      "user": "mbeijen",
      "created_at": "2024-03-10T10:30:56Z",
      "url": "https://github.com/encode/httpx/pull/3139#discussion_r1518815892"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3139,
      "file_path": "httpx/_decoders.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,6 +140,43 @@ def flush(self) -> bytes:\n             raise DecodingError(str(exc)) from exc\n \n \n+class ZStandardDecoder(ContentDecoder):\n+    \"\"\"\n+    Handle 'zstd' RFC 8878 decoding.\n+\n+    Requires `pip install zstandard`.\n+    Can be installed as a dependency of httpx using `pip install httpx[zstd]`.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        if zstd is None:  # pragma: no cover\n+            raise ImportError(\n+                \"Using 'ZStandardDecoder', ...\"\n+                \"Make sure to install httpx using `pip install httpx[zstd]`.\"\n+            ) from None\n+\n+        self.decompressor = zstd.ZstdDecompressor().decompressobj()\n+\n+    def decode(self, data: bytes) -> bytes:\n+        assert zstd is not None\n+        output = io.BytesIO()\n+        try:\n+            output.write(self.decompressor.decompress(data))",
      "comment": "One less function call :slightly_smiling_face:\r\n\r\n```suggestion\r\n        try:\r\n            output = io.BytesIO(self.decompressor.decompress(data))\r\n```",
      "comment_id": 1518817642,
      "user": "Zaczero",
      "created_at": "2024-03-10T10:40:54Z",
      "url": "https://github.com/encode/httpx/pull/3139#discussion_r1518817642"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3139,
      "file_path": "httpx/_decoders.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,6 +140,41 @@ def flush(self) -> bytes:\n             raise DecodingError(str(exc)) from exc\n \n \n+class ZStandardDecoder(ContentDecoder):\n+    \"\"\"\n+    Handle 'zstd' RFC 8878 decoding.\n+\n+    Requires `pip install zstandard`.\n+    Can be installed as a dependency of httpx using `pip install httpx[zstd]`.\n+    \"\"\"\n+\n+    def __init__(self) -> None:\n+        if zstd is False:  # pragma: no cover\n+            raise ImportError(\n+                \"Using 'ZStandardDecoder', ...\"\n+                \"Make sure to install httpx using `pip install httpx[zstd]`.\"\n+            ) from None\n+\n+        self.decompressor = zstd.ZstdDecompressor().decompressobj()\n+\n+    def decode(self, data: bytes) -> bytes:\n+        try:\n+            data_parts = [self.decompressor.decompress(data)]\n+            while self.decompressor.eof and self.decompressor.unused_data:\n+                unused_data = self.decompressor.unused_data\n+                self.decompressor = zstd.ZstdDecompressor().decompressobj()\n+                data_parts.append(self.decompressor.decompress(unused_data))",
      "comment": "I'm not exactly sure what happens, but if I try to use `read_across_frames` I get decoding errors. Also, please note I've copied this logic from urllib3 so it is \"Best Practice\" :-) or at least proven to be working.\r\n\r\nI would be open for suggestions of course!",
      "comment_id": 1518821040,
      "user": "mbeijen",
      "created_at": "2024-03-10T10:59:41Z",
      "url": "https://github.com/encode/httpx/pull/3139#discussion_r1518821040"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3139,
      "file_path": "httpx/_compat.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,6 +20,24 @@\n     except ImportError:\n         brotli = None\n \n+# Zstandard support is optional\n+zstd: Optional[ModuleType] = None\n+try:\n+    import zstandard as zstd\n+except (AttributeError, ImportError, ValueError):  # Defensive:\n+    zstd = None\n+else:\n+    # The package 'zstandard' added the 'eof' property starting\n+    # in v0.18.0 which we require to ensure a complete and\n+    # valid zstd stream was fed into the ZstdDecoder.\n+    # See: https://github.com/urllib3/urllib3/pull/2624\n+    _zstd_version = tuple(\n+        map(int, re.search(r\"^([0-9]+)\\.([0-9]+)\", zstd.__version__).groups())  # type: ignore[union-attr]\n+    )\n+    if _zstd_version < (0, 18):  # Defensive:\n+        zstd = None",
      "comment": "This might be overly defensive? Can we pin >= 0.18 in the requirements instead?",
      "comment_id": 1524997549,
      "user": "lovelydinosaur",
      "created_at": "2024-03-14T14:38:46Z",
      "url": "https://github.com/encode/httpx/pull/3139#discussion_r1524997549"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3139,
      "file_path": "httpx/_compat.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,6 +20,24 @@\n     except ImportError:\n         brotli = None\n \n+# Zstandard support is optional\n+zstd: Optional[ModuleType] = None\n+try:\n+    import zstandard as zstd\n+except (AttributeError, ImportError, ValueError):  # Defensive:\n+    zstd = None\n+else:\n+    # The package 'zstandard' added the 'eof' property starting\n+    # in v0.18.0 which we require to ensure a complete and\n+    # valid zstd stream was fed into the ZstdDecoder.\n+    # See: https://github.com/urllib3/urllib3/pull/2624\n+    _zstd_version = tuple(\n+        map(int, re.search(r\"^([0-9]+)\\.([0-9]+)\", zstd.__version__).groups())  # type: ignore[union-attr]\n+    )\n+    if _zstd_version < (0, 18):  # Defensive:\n+        zstd = None",
      "comment": "I've asked a similar question already and got this answer:\r\n\r\nhttps://github.com/encode/httpx/pull/3139#discussion_r1518815892\r\n\r\n> zstandard is an optional install. So if your `requirements.txt` just has `httpx` and not `httpx[zstd]`, and you have `zstandard==[old version]` somehow, this would prevent breakage.\r\n\r\nBasically the idea is that the optional dependency pin is optional and does not guarantee that the given dependency version will be installed. This check would only be redundant if we made zstandard a hard dependency (one not requiring httpx[zstandard]).\r\n\r\nThe same check [exists](https://github.com/urllib3/urllib3/blob/733f638a2faa02b4ff8a9f3b5668949d39396b8b/src/urllib3/response.py#L28-L43) in urllib3.\r\n\r\nPersonally, I +1 the extra safety at the cost of minimal startup delay. :slightly_smiling_face: ",
      "comment_id": 1525232707,
      "user": "Zaczero",
      "created_at": "2024-03-14T17:07:51Z",
      "url": "https://github.com/encode/httpx/pull/3139#discussion_r1525232707"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3139,
      "file_path": "httpx/_compat.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,6 +20,24 @@\n     except ImportError:\n         brotli = None\n \n+# Zstandard support is optional\n+zstd: Optional[ModuleType] = None\n+try:\n+    import zstandard as zstd\n+except (AttributeError, ImportError, ValueError):  # Defensive:\n+    zstd = None\n+else:\n+    # The package 'zstandard' added the 'eof' property starting\n+    # in v0.18.0 which we require to ensure a complete and\n+    # valid zstd stream was fed into the ZstdDecoder.\n+    # See: https://github.com/urllib3/urllib3/pull/2624\n+    _zstd_version = tuple(\n+        map(int, re.search(r\"^([0-9]+)\\.([0-9]+)\", zstd.__version__).groups())  # type: ignore[union-attr]\n+    )\n+    if _zstd_version < (0, 18):  # Defensive:\n+        zstd = None",
      "comment": "Okay yep. Main thing is coverage needs addressing.",
      "comment_id": 1525274642,
      "user": "lovelydinosaur",
      "created_at": "2024-03-14T17:39:31Z",
      "url": "https://github.com/encode/httpx/pull/3139#discussion_r1525274642"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3245,
      "file_path": "httpx/_api.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,9 +18,9 @@\n     RequestData,\n     RequestFiles,\n     TimeoutTypes,\n-    URLTypes,\n     VerifyTypes,\n )\n+from ._urls import URL",
      "comment": "I'd only use that if it was required to avoid a cyclical dependency.",
      "comment_id": 1688184272,
      "user": "lovelydinosaur",
      "created_at": "2024-07-23T14:36:53Z",
      "url": "https://github.com/encode/httpx/pull/3245#discussion_r1688184272"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3064,
      "file_path": "tests/test_utils.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,21 +233,39 @@ def test_not_same_origin():\n \n \n def test_is_https_redirect():\n-    url = httpx.URL(\"http://example.com\")\n-    location = httpx.URL(\"https://example.com\")\n-    assert is_https_redirect(url, location)\n+    url = httpx.URL(\"https://example.com\")\n+    request = httpx.Request(\n+        \"GET\", \"http://example.com\", headers={\"Authorization\": \"empty\"}\n+    )\n+\n+    client = httpx.Client()\n+    headers = client._redirect_headers(request, url, \"GET\")",
      "comment": "Hrm. Is there a way around that allows us to test this against public API?",
      "comment_id": 1453218472,
      "user": "lovelydinosaur",
      "created_at": "2024-01-16T10:19:53Z",
      "url": "https://github.com/encode/httpx/pull/3064#discussion_r1453218472"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3064,
      "file_path": "tests/test_utils.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,21 +233,39 @@ def test_not_same_origin():\n \n \n def test_is_https_redirect():\n-    url = httpx.URL(\"http://example.com\")\n-    location = httpx.URL(\"https://example.com\")\n-    assert is_https_redirect(url, location)\n+    url = httpx.URL(\"https://example.com\")\n+    request = httpx.Request(\n+        \"GET\", \"http://example.com\", headers={\"Authorization\": \"empty\"}\n+    )\n+\n+    client = httpx.Client()\n+    headers = client._redirect_headers(request, url, \"GET\")",
      "comment": "Might be that we're okay with leaning on implementation details a little bit, certainly not a terrible trade-off to make. (I think we already have some instances of this in our test cases right?)",
      "comment_id": 1453220170,
      "user": "lovelydinosaur",
      "created_at": "2024-01-16T10:21:13Z",
      "url": "https://github.com/encode/httpx/pull/3064#discussion_r1453220170"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3064,
      "file_path": "tests/test_utils.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,21 +233,39 @@ def test_not_same_origin():\n \n \n def test_is_https_redirect():\n-    url = httpx.URL(\"http://example.com\")\n-    location = httpx.URL(\"https://example.com\")\n-    assert is_https_redirect(url, location)\n+    url = httpx.URL(\"https://example.com\")\n+    request = httpx.Request(\n+        \"GET\", \"http://example.com\", headers={\"Authorization\": \"empty\"}\n+    )\n+\n+    client = httpx.Client()\n+    headers = client._redirect_headers(request, url, \"GET\")",
      "comment": "Also, we already use private-accessors in another test:\r\nhttps://github.com/encode/httpx/blob/4f6edf36e93fd9f83ff95b065718fd6bd0c4d3c5/tests/client/test_proxies.py#L333-L338",
      "comment_id": 1453483159,
      "user": "T-256",
      "created_at": "2024-01-16T14:11:05Z",
      "url": "https://github.com/encode/httpx/pull/3064#discussion_r1453483159"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1574,
      "file_path": "httpx/_client.py",
      "line": 736,
      "side": "RIGHT",
      "diff_hunk": "@@ -731,6 +731,14 @@ def request(\n \n         [0]: /advanced/#merging-of-configuration\n         \"\"\"\n+        if cookies is not None:\n+            message = (\n+                \"Setting per-request cookies=... is being deprecated, because \"",
      "comment": "This would be better as\r\n```suggestion\r\n                \"Setting per-request cookies=<...> is being deprecated, because \"\r\n```\r\nfor better language flow, I think (and similar to the `content=<...>` message in https://github.com/encode/httpx/pull/1573/files#diff-361c5daf6e5401b987414c619d003a20ea88f74fe9da50cbb2da72c337aeb290R152)",
      "comment_id": 613343499,
      "user": "StephenBrown2",
      "created_at": "2021-04-14T15:18:40Z",
      "url": "https://github.com/encode/httpx/pull/1574#discussion_r613343499"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3045,
      "file_path": "httpx/_auth.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,7 +280,7 @@ def digest(data: bytes) -> bytes:\n \n         qop = self._resolve_qop(challenge.qop, request=request)\n         if qop is None:\n-            digest_data = [HA1, challenge.nonce, HA2]\n+            digest_data = [challenge.nonce, HA2]\n         else:\n             digest_data = [challenge.nonce, nc_value, cnonce, qop, HA2]",
      "comment": "Looking at the curl code, seems like this change should be the other way around(?)...\r\n\r\n```python\r\n        if qop is None:\r\n            digest_data = [HA1, challenge.nonce, HA2]\r\n        else:\r\n            digest_data = [HA1, challenge.nonce, nc_value, cnonce, qop, HA2]\r\n```\r\n\r\nAnd then...\r\n\r\n```python\r\n        format_args = {\r\n            \"username\": self._username,\r\n            \"realm\": challenge.realm,\r\n            \"nonce\": challenge.nonce,\r\n            \"uri\": path,\r\n            \"response\": digest(key_digest),\r\n            \"algorithm\": challenge.algorithm.encode(),\r\n        }\r\n```",
      "comment_id": 1444454071,
      "user": "lovelydinosaur",
      "created_at": "2024-01-08T11:01:34Z",
      "url": "https://github.com/encode/httpx/pull/3045#discussion_r1444454071"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3045,
      "file_path": "httpx/_auth.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,7 +280,7 @@ def digest(data: bytes) -> bytes:\n \n         qop = self._resolve_qop(challenge.qop, request=request)\n         if qop is None:\n-            digest_data = [HA1, challenge.nonce, HA2]\n+            digest_data = [challenge.nonce, HA2]\n         else:\n             digest_data = [challenge.nonce, nc_value, cnonce, qop, HA2]",
      "comment": "Yeah, initially I wanted to avoid touching the other branch (so I don't break it accidentally), but I agree the curl way is more readable. I also add the comments.",
      "comment_id": 1444577834,
      "user": "the-ress",
      "created_at": "2024-01-08T12:50:09Z",
      "url": "https://github.com/encode/httpx/pull/3045#discussion_r1444577834"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3045,
      "file_path": "tests/test_auth.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,3 +140,168 @@ def test_digest_auth_setting_cookie_in_request():\n     )\n     with pytest.raises(StopIteration):\n         flow.send(response)\n+\n+\n+def test_digest_auth_rfc_2069():\n+    # Example from https://datatracker.ietf.org/doc/html/rfc2069#section-2.4\n+    # with corrected response from https://www.rfc-editor.org/errata/eid749\n+\n+    auth = httpx.DigestAuth(username=\"Mufasa\", password=\"CircleOfLife\")\n+    request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n+\n+    # The initial request should not include an auth header.\n+    flow = auth.sync_auth_flow(request)\n+    request = next(flow)\n+    assert \"Authorization\" not in request.headers\n+\n+    # If a 401 response is returned, then a digest auth request is made.\n+    headers = {\n+        \"WWW-Authenticate\": (\n+            'Digest realm=\"testrealm@host.com\", '\n+            'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", '\n+            'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"'\n+        )\n+    }\n+    response = httpx.Response(\n+        content=b\"Auth required\", status_code=401, headers=headers, request=request\n+    )\n+    request = flow.send(response)\n+    assert request.headers[\"Authorization\"].startswith(\"Digest\")\n+    assert 'username=\"Mufasa\"' in request.headers[\"Authorization\"]\n+    assert 'realm=\"testrealm@host.com\"' in request.headers[\"Authorization\"]\n+    assert (\n+        'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\"' in request.headers[\"Authorization\"]\n+    )\n+    assert 'uri=\"/dir/index.html\"' in request.headers[\"Authorization\"]\n+    assert (\n+        'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"' in request.headers[\"Authorization\"]\n+    )\n+    assert (\n+        'response=\"1949323746fe6a43ef61f9606e7febea\"'\n+        in request.headers[\"Authorization\"]\n+    )\n+\n+    # No other requests are made.\n+    response = httpx.Response(content=b\"Hello, world!\", status_code=200)\n+    with pytest.raises(StopIteration):\n+        flow.send(response)\n+\n+\n+def test_digest_auth_rfc_7616_md5(monkeypatch):\n+    # Example from https://datatracker.ietf.org/doc/html/rfc7616#section-3.9.1\n+\n+    def mock_get_client_nonce(nonce_count: int, nonce: bytes) -> bytes:\n+        return \"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\".encode()\n+\n+    auth = httpx.DigestAuth(username=\"Mufasa\", password=\"Circle of Life\")\n+    monkeypatch.setattr(auth, \"_get_client_nonce\", mock_get_client_nonce)\n+\n+    request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n+\n+    # The initial request should not include an auth header.\n+    flow = auth.sync_auth_flow(request)\n+    request = next(flow)\n+    assert \"Authorization\" not in request.headers\n+\n+    # If a 401 response is returned, then a digest auth request is made.\n+    headers = {\n+        \"WWW-Authenticate\": (\n+            'Digest realm=\"http-auth@example.org\", '\n+            'qop=\"auth, auth-int\", '\n+            \"algorithm=MD5, \"\n+            'nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", '\n+            'opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"'\n+        )\n+    }\n+    response = httpx.Response(\n+        content=b\"Auth required\", status_code=401, headers=headers, request=request\n+    )\n+    request = flow.send(response)\n+    assert request.headers[\"Authorization\"].startswith(\"Digest\")\n+    assert 'username=\"Mufasa\"' in request.headers[\"Authorization\"]\n+    assert 'realm=\"http-auth@example.org\"' in request.headers[\"Authorization\"]\n+    assert 'uri=\"/dir/index.html\"' in request.headers[\"Authorization\"]\n+    assert \"algorithm=MD5\" in request.headers[\"Authorization\"]\n+    assert (\n+        'nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\"'\n+        in request.headers[\"Authorization\"]\n+    )\n+    assert \"nc=00000001\" in request.headers[\"Authorization\"]\n+    assert (\n+        'cnonce=\"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\"'\n+        in request.headers[\"Authorization\"]\n+    )\n+    assert \"qop=auth\" in request.headers[\"Authorization\"]\n+    assert (\n+        'opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"'\n+        in request.headers[\"Authorization\"]\n+    )\n+    assert (\n+        'response=\"8ca523f5e9506fed4657c9700eebdbec\"'\n+        in request.headers[\"Authorization\"]\n+    )",
      "comment": "These tests are fantastic, thanks!\r\n\r\nAre we able to do a literal `assert request.headers[\"Authorization\"] == ...` test here or is the ordering that we're returning different to the example in the RFC?",
      "comment_id": 1445998305,
      "user": "lovelydinosaur",
      "created_at": "2024-01-09T11:56:24Z",
      "url": "https://github.com/encode/httpx/pull/3045#discussion_r1445998305"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3045,
      "file_path": "tests/test_auth.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,3 +140,168 @@ def test_digest_auth_setting_cookie_in_request():\n     )\n     with pytest.raises(StopIteration):\n         flow.send(response)\n+\n+\n+def test_digest_auth_rfc_2069():\n+    # Example from https://datatracker.ietf.org/doc/html/rfc2069#section-2.4\n+    # with corrected response from https://www.rfc-editor.org/errata/eid749\n+\n+    auth = httpx.DigestAuth(username=\"Mufasa\", password=\"CircleOfLife\")\n+    request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n+\n+    # The initial request should not include an auth header.\n+    flow = auth.sync_auth_flow(request)\n+    request = next(flow)\n+    assert \"Authorization\" not in request.headers\n+\n+    # If a 401 response is returned, then a digest auth request is made.\n+    headers = {\n+        \"WWW-Authenticate\": (\n+            'Digest realm=\"testrealm@host.com\", '\n+            'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", '\n+            'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"'\n+        )\n+    }\n+    response = httpx.Response(\n+        content=b\"Auth required\", status_code=401, headers=headers, request=request\n+    )\n+    request = flow.send(response)\n+    assert request.headers[\"Authorization\"].startswith(\"Digest\")\n+    assert 'username=\"Mufasa\"' in request.headers[\"Authorization\"]\n+    assert 'realm=\"testrealm@host.com\"' in request.headers[\"Authorization\"]\n+    assert (\n+        'nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\"' in request.headers[\"Authorization\"]\n+    )\n+    assert 'uri=\"/dir/index.html\"' in request.headers[\"Authorization\"]\n+    assert (\n+        'opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"' in request.headers[\"Authorization\"]\n+    )\n+    assert (\n+        'response=\"1949323746fe6a43ef61f9606e7febea\"'\n+        in request.headers[\"Authorization\"]\n+    )\n+\n+    # No other requests are made.\n+    response = httpx.Response(content=b\"Hello, world!\", status_code=200)\n+    with pytest.raises(StopIteration):\n+        flow.send(response)\n+\n+\n+def test_digest_auth_rfc_7616_md5(monkeypatch):\n+    # Example from https://datatracker.ietf.org/doc/html/rfc7616#section-3.9.1\n+\n+    def mock_get_client_nonce(nonce_count: int, nonce: bytes) -> bytes:\n+        return \"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\".encode()\n+\n+    auth = httpx.DigestAuth(username=\"Mufasa\", password=\"Circle of Life\")\n+    monkeypatch.setattr(auth, \"_get_client_nonce\", mock_get_client_nonce)\n+\n+    request = httpx.Request(\"GET\", \"https://www.example.com/dir/index.html\")\n+\n+    # The initial request should not include an auth header.\n+    flow = auth.sync_auth_flow(request)\n+    request = next(flow)\n+    assert \"Authorization\" not in request.headers\n+\n+    # If a 401 response is returned, then a digest auth request is made.\n+    headers = {\n+        \"WWW-Authenticate\": (\n+            'Digest realm=\"http-auth@example.org\", '\n+            'qop=\"auth, auth-int\", '\n+            \"algorithm=MD5, \"\n+            'nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", '\n+            'opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"'\n+        )\n+    }\n+    response = httpx.Response(\n+        content=b\"Auth required\", status_code=401, headers=headers, request=request\n+    )\n+    request = flow.send(response)\n+    assert request.headers[\"Authorization\"].startswith(\"Digest\")\n+    assert 'username=\"Mufasa\"' in request.headers[\"Authorization\"]\n+    assert 'realm=\"http-auth@example.org\"' in request.headers[\"Authorization\"]\n+    assert 'uri=\"/dir/index.html\"' in request.headers[\"Authorization\"]\n+    assert \"algorithm=MD5\" in request.headers[\"Authorization\"]\n+    assert (\n+        'nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\"'\n+        in request.headers[\"Authorization\"]\n+    )\n+    assert \"nc=00000001\" in request.headers[\"Authorization\"]\n+    assert (\n+        'cnonce=\"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\"'\n+        in request.headers[\"Authorization\"]\n+    )\n+    assert \"qop=auth\" in request.headers[\"Authorization\"]\n+    assert (\n+        'opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"'\n+        in request.headers[\"Authorization\"]\n+    )\n+    assert (\n+        'response=\"8ca523f5e9506fed4657c9700eebdbec\"'\n+        in request.headers[\"Authorization\"]\n+    )",
      "comment": "I wouldn't want to depend on the exact order since it'd make the test more fragile with little benefit.",
      "comment_id": 1446681951,
      "user": "the-ress",
      "created_at": "2024-01-09T22:21:31Z",
      "url": "https://github.com/encode/httpx/pull/3045#discussion_r1446681951"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3042,
      "file_path": "httpx/_client.py",
      "line": 1316,
      "side": "RIGHT",
      "diff_hunk": "@@ -1311,6 +1313,8 @@ class AsyncClient(BaseClient):\n     An asynchronous HTTP client, with connection pooling, HTTP/2, redirects,\n     cookie persistence, etc.\n \n+    It can be shared between threads.",
      "comment": "```suggestion\r\n    It can be shared between tasks.\r\n```",
      "comment_id": 1442512639,
      "user": "karpetrosyan",
      "created_at": "2024-01-05T05:41:11Z",
      "url": "https://github.com/encode/httpx/pull/3042#discussion_r1442512639"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 3042,
      "file_path": "httpx/_client.py",
      "line": 1552,
      "side": "RIGHT",
      "diff_hunk": "@@ -1544,6 +1548,15 @@ async def request(\n \n         [0]: /advanced/#merging-of-configuration\n         \"\"\"\n+\n+        if cookies is not None:",
      "comment": "```suggestion\r\n        if cookies is not None:  # pragma: no cover\r\n```",
      "comment_id": 1442513863,
      "user": "karpetrosyan",
      "created_at": "2024-01-05T05:44:18Z",
      "url": "https://github.com/encode/httpx/pull/3042#discussion_r1442513863"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 454,
      "side": "RIGHT",
      "diff_hunk": "@@ -449,6 +448,32 @@ def quote(string: str, safe: str = \"/\") -> str:\n     )\n \n \n+def quote(string: str, safe: str = \"/\") -> str:\n+    \"\"\"\n+    Use percent-encoding to quote a string, omitting existing '%xx' escape sequences.\n+    \"\"\"",
      "comment": "@tomchristie - perhaps this could do with some code comments?\r\n\r\nAn example of what we're ending up with here is...\r\n\r\n```python\r\ninput = \"abc%20de f\"\r\noutput = \"\".join([percent_encoded(\"abc\"), \"%20\", percent_encoded(\"de f\")])\r\nassert quote(input) == output",
      "comment_id": 1420326415,
      "user": "lovelydinosaur",
      "created_at": "2023-12-08T11:44:52Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1420326415"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 497,
      "side": "RIGHT",
      "diff_hunk": "@@ -464,4 +489,9 @@ def urlencode(items: typing.List[typing.Tuple[str, str]]) -> str:\n     - https://github.com/encode/httpx/issues/2721\n     - https://docs.python.org/3/library/urllib.parse.html#urllib.parse.urlencode\n     \"\"\"\n-    return \"&\".join([quote(k, safe=\"\") + \"=\" + quote(v, safe=\"\") for k, v in items])\n+    return \"&\".join(\n+        [\n+            percent_encoded(k, safe=\"\") + \"=\" + percent_encoded(v, safe=\"\")\n+            for k, v in items\n+        ]\n+    )",
      "comment": "Comment to the gallery...\r\n\r\nWe've switch from `quote` to `percent_encoded` here, because we *always* want to percent encode items that are being provided as form inputs, with `params = {}`.\r\n",
      "comment_id": 1420329649,
      "user": "lovelydinosaur",
      "created_at": "2023-12-08T11:48:11Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1420329649"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 454,
      "side": "RIGHT",
      "diff_hunk": "@@ -449,6 +448,32 @@ def quote(string: str, safe: str = \"/\") -> str:\n     )\n \n \n+def quote(string: str, safe: str = \"/\") -> str:\n+    \"\"\"\n+    Use percent-encoding to quote a string, omitting existing '%xx' escape sequences.\n+    \"\"\"",
      "comment": "I see code comments more difficult to read than that simple straightforward description.\r\nPerhaps `safe` parameter needs more info here(?)",
      "comment_id": 1421693032,
      "user": "T-256",
      "created_at": "2023-12-10T06:35:15Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1421693032"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 443,
      "side": "RIGHT",
      "diff_hunk": "@@ -432,13 +432,12 @@ def is_safe(string: str, safe: str = \"/\") -> bool:\n         if char not in NON_ESCAPED_CHARS:\n             return False\n \n-    # Any '%' characters must be valid '%xx' escape sequences.\n-    return string.count(\"%\") == len(PERCENT_ENCODED_REGEX.findall(string))\n+    return True\n \n \n-def quote(string: str, safe: str = \"/\") -> str:\n+def percent_encoded(string: str, safe: str = \"/\") -> str:\n     \"\"\"\n-    Use percent-encoding to quote a string if required.\n+    Use percent-encoding to quote a string.\n     \"\"\"\n     if is_safe(string, safe=safe):\n         return string",
      "comment": "I suggest use minimal filtering instead of separated one-time function.\r\n```py\r\n    if all(char in NON_ESCAPED_CHARS for char in string):\r\n        return string\r\n```\r\n\r\nI also noticed `NON_ESCAPED_CHARS` name in `is_safe` function has different value than it is in `percent_encoded`.",
      "comment_id": 1421693601,
      "user": "T-256",
      "created_at": "2023-12-10T06:41:37Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1421693601"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 474,
      "side": "RIGHT",
      "diff_hunk": "@@ -449,6 +448,32 @@ def quote(string: str, safe: str = \"/\") -> str:\n     )\n \n \n+def quote(string: str, safe: str = \"/\") -> str:\n+    \"\"\"\n+    Use percent-encoding to quote a string, omitting existing '%xx' escape sequences.\n+    \"\"\"\n+    parts = []\n+    current_position = 0\n+    for match in re.finditer(PERCENT_ENCODED_REGEX, string):\n+        start_position, end_position = match.start(), match.end()\n+        matched_text = match.group(0)\n+        # Add any text up to the '%xx' escape sequence.\n+        if start_position != current_position:\n+            leading_text = string[current_position:start_position]\n+            parts.append(percent_encoded(leading_text, safe=safe))\n+\n+        # Add the '%xx' escape sequence.\n+        parts.append(matched_text)\n+        current_position = end_position\n+\n+    # Add any text after the final '%xx' escape sequence.\n+    if current_position != len(string):\n+        trailing_text = string[current_position:]\n+        parts.append(percent_encoded(trailing_text, safe=safe))\n+\n+    return \"\".join(parts)",
      "comment": "`parts` could be string. `parts +=` instead of `parts.append`",
      "comment_id": 1421694231,
      "user": "T-256",
      "created_at": "2023-12-10T06:48:27Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1421694231"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 443,
      "side": "RIGHT",
      "diff_hunk": "@@ -432,13 +432,12 @@ def is_safe(string: str, safe: str = \"/\") -> bool:\n         if char not in NON_ESCAPED_CHARS:\n             return False\n \n-    # Any '%' characters must be valid '%xx' escape sequences.\n-    return string.count(\"%\") == len(PERCENT_ENCODED_REGEX.findall(string))\n+    return True\n \n \n-def quote(string: str, safe: str = \"/\") -> str:\n+def percent_encoded(string: str, safe: str = \"/\") -> str:\n     \"\"\"\n-    Use percent-encoding to quote a string if required.\n+    Use percent-encoding to quote a string.\n     \"\"\"\n     if is_safe(string, safe=safe):\n         return string",
      "comment": "Sure. I'd like to treat performance improvements separately to this.\r\nI'll followup with some further work once we've got the behavioural changes in.",
      "comment_id": 1422158955,
      "user": "lovelydinosaur",
      "created_at": "2023-12-11T09:21:54Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1422158955"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 474,
      "side": "RIGHT",
      "diff_hunk": "@@ -449,6 +448,32 @@ def quote(string: str, safe: str = \"/\") -> str:\n     )\n \n \n+def quote(string: str, safe: str = \"/\") -> str:\n+    \"\"\"\n+    Use percent-encoding to quote a string, omitting existing '%xx' escape sequences.\n+    \"\"\"\n+    parts = []\n+    current_position = 0\n+    for match in re.finditer(PERCENT_ENCODED_REGEX, string):\n+        start_position, end_position = match.start(), match.end()\n+        matched_text = match.group(0)\n+        # Add any text up to the '%xx' escape sequence.\n+        if start_position != current_position:\n+            leading_text = string[current_position:start_position]\n+            parts.append(percent_encoded(leading_text, safe=safe))\n+\n+        # Add the '%xx' escape sequence.\n+        parts.append(matched_text)\n+        current_position = end_position\n+\n+    # Add any text after the final '%xx' escape sequence.\n+    if current_position != len(string):\n+        trailing_text = string[current_position:]\n+        parts.append(percent_encoded(trailing_text, safe=safe))\n+\n+    return \"\".join(parts)",
      "comment": "It could, yes. I've gone with this pattern because in the past we've seen performance issues with the `+=` pattern, that a `.append() ... \"\".join()` pattern resolves. Might not be the case in this context, since we've got strict limits on the allowable string lengths in URLs. But... let's handle any performance related considerations separately to the behavioural fixes.",
      "comment_id": 1422164211,
      "user": "lovelydinosaur",
      "created_at": "2023-12-11T09:25:09Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1422164211"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_transports/asgi.py",
      "line": 3,
      "side": "LEFT",
      "diff_hunk": "@@ -1,7 +1,5 @@\n import typing\n \n-import sniffio",
      "comment": "`_utils.py` also imports sniffio as top-level.\r\nCould we consider add httpcore's [`current_async_library`](https://github.com/encode/httpcore/blob/2fcd062df71555cc7de55774c6dc137551eb8692/httpcore/_synchronization.py#L21) in httpx?",
      "comment_id": 1423025866,
      "user": "T-256",
      "created_at": "2023-12-11T19:27:01Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1423025866"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,7 +263,7 @@ def urlparse(url: str = \"\", **kwargs: typing.Optional[str]) -> ParseResult:\n     # We also exclude '/' because it is more robust to replace it with a percent\n     # encoding despite it not being a requirement of the spec.",
      "comment": "Doesn't this comment become incorrect with this change?",
      "comment_id": 1424884213,
      "user": "jkseppan",
      "created_at": "2023-12-13T06:01:36Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1424884213"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -449,6 +446,39 @@ def quote(string: str, safe: str = \"/\") -> str:\n     )\n \n \n+def quote(string: str, safe: str = \"/\") -> str:",
      "comment": "I believe we should also add unit tests for these functions, rather than simply testing them with `httpx.URL`. \r\nThis would be a more robust approach, in my opinion.\r\n",
      "comment_id": 1425186493,
      "user": "karpetrosyan",
      "created_at": "2023-12-13T10:55:47Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1425186493"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -449,6 +446,39 @@ def quote(string: str, safe: str = \"/\") -> str:\n     )\n \n \n+def quote(string: str, safe: str = \"/\") -> str:",
      "comment": "IMO current approach is fine.\r\n\r\n> This is clearly a code-smell, because our test cases ought to be tests against our public API, rather than testing implementation details. Perhaps there's some cases where it's a necessary hack, but... perhaps not?\r\n\r\n\r\nfrom https://github.com/encode/httpx/issues/2492#issue-1478857204",
      "comment_id": 1425847949,
      "user": "T-256",
      "created_at": "2023-12-13T20:23:49Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1425847949"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -449,6 +446,39 @@ def quote(string: str, safe: str = \"/\") -> str:\n     )\n \n \n+def quote(string: str, safe: str = \"/\") -> str:",
      "comment": "I agree testing the public API should be sufficient unless something private is particularly expensive to test via the public API.",
      "comment_id": 1426015469,
      "user": "zanieb",
      "created_at": "2023-12-14T00:20:26Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1426015469"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2990,
      "file_path": "httpx/_urlparse.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -449,6 +446,39 @@ def quote(string: str, safe: str = \"/\") -> str:\n     )\n \n \n+def quote(string: str, safe: str = \"/\") -> str:",
      "comment": "It's a matter of preference, but if we encounter regression in our `httpx.URL` tests, we will go through these functions and find the method that isn't working properly, which is why unit tests are useful.",
      "comment_id": 1426181241,
      "user": "karpetrosyan",
      "created_at": "2023-12-14T05:14:41Z",
      "url": "https://github.com/encode/httpx/pull/2990#discussion_r1426181241"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2998,
      "file_path": "tests/test_decoders.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -262,6 +273,11 @@ def test_line_decoder_crnl():\n     assert list(response.iter_lines()) == [\"12345\", \"foo bar baz\"]\n \n \n+@pytest.mark.parametrize([\"text\", \"expected\"], [(\"\", [])])\n+def test_line_decoding_edge_cases(text: str, expected: typing.List[str]) -> None:\n+    assert httpx._decoders.LineDecoder().decode(text) == expected",
      "comment": "This was the only way I could figure out how to cover an empty input to `LineDecoder.decode`.",
      "comment_id": 1422619715,
      "user": "jamesbraza",
      "created_at": "2023-12-11T15:08:15Z",
      "url": "https://github.com/encode/httpx/pull/2998#discussion_r1422619715"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2879,
      "file_path": "httpx/_transports/default.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -47,7 +49,7 @@\n     WriteTimeout,\n )\n from .._models import Request, Response\n-from .._types import AsyncByteStream, CertTypes, SyncByteStream, VerifyTypes\n+from .._types import AsyncByteStream, CertTypes, ProxyTypes, SyncByteStream, VerifyTypes",
      "comment": "```suggestion\r\nfrom .._types import AsyncByteStream, CertTypes, ProxyTypes, SyncByteStream, VerifyTypes\r\nfrom .._urls import URL\r\n```",
      "comment_id": 1353991206,
      "user": "T-256",
      "created_at": "2023-10-11T04:16:34Z",
      "url": "https://github.com/encode/httpx/pull/2879#discussion_r1353991206"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2879,
      "file_path": "httpx/_types.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,7 +78,8 @@\n     Tuple[Optional[float], Optional[float], Optional[float], Optional[float]],\n     \"Timeout\",\n ]\n-ProxiesTypes = Union[URLTypes, \"Proxy\", Dict[URLTypes, Union[None, URLTypes, \"Proxy\"]]]\n+ProxyTypes = Union[URLTypes, \"Proxy\"]\n+ProxiesTypes = Union[URLTypes, ProxyTypes, Dict[URLTypes, Union[None, ProxyTypes]]]",
      "comment": "```suggestion\r\nProxiesTypes = Union[ProxyTypes, Dict[URLTypes, Union[None, ProxyTypes]]]\r\n```",
      "comment_id": 1356443220,
      "user": "karpetrosyan",
      "created_at": "2023-10-12T08:03:28Z",
      "url": "https://github.com/encode/httpx/pull/2879#discussion_r1356443220"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2723,
      "file_path": "httpx/_urlparse.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -260,8 +260,11 @@ def urlparse(url: str = \"\", **kwargs: typing.Optional[str]) -> ParseResult:\n     # For 'path' we need to drop ? and # from the GEN_DELIMS set.\n     parsed_path: str = quote(path, safe=SUB_DELIMS + \":/[]@\")\n     # For 'query' we need to drop '#' from the GEN_DELIMS set.\n+    # We also exclude '/' because it is more robust to replace it with a percent\n+    # encoding despite it not being a requirement of the spec and include '%' to\n+    # prevent duplicate encoding of previously quoted items.\n     parsed_query: typing.Optional[str] = (\n-        None if query is None else quote(query, safe=SUB_DELIMS + \":/?[]@\")\n+        None if query is None else quote(query, safe=SUB_DELIMS + \":?[]@%\")",
      "comment": "I was surprised that I needed to include `%` but it was needed to to prevent spaces converted to `%20` from being changed to `%2520` in tests.",
      "comment_id": 1207129278,
      "user": "zanieb",
      "created_at": "2023-05-26T17:39:17Z",
      "url": "https://github.com/encode/httpx/pull/2723#discussion_r1207129278"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2723,
      "file_path": "httpx/_urlparse.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -260,8 +260,11 @@ def urlparse(url: str = \"\", **kwargs: typing.Optional[str]) -> ParseResult:\n     # For 'path' we need to drop ? and # from the GEN_DELIMS set.\n     parsed_path: str = quote(path, safe=SUB_DELIMS + \":/[]@\")\n     # For 'query' we need to drop '#' from the GEN_DELIMS set.\n+    # We also exclude '/' because it is more robust to replace it with a percent\n+    # encoding despite it not being a requirement of the spec and include '%' to\n+    # prevent duplicate encoding of previously quoted items.\n     parsed_query: typing.Optional[str] = (\n-        None if query is None else quote(query, safe=SUB_DELIMS + \":/?[]@\")\n+        None if query is None else quote(query, safe=SUB_DELIMS + \":?[]@%\")",
      "comment": "Let me know if there's additional test coverage that would make sense for this or if we've revealed another issue.",
      "comment_id": 1207129907,
      "user": "zanieb",
      "created_at": "2023-05-26T17:39:50Z",
      "url": "https://github.com/encode/httpx/pull/2723#discussion_r1207129907"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2723,
      "file_path": "httpx/_urlparse.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -260,8 +260,11 @@ def urlparse(url: str = \"\", **kwargs: typing.Optional[str]) -> ParseResult:\n     # For 'path' we need to drop ? and # from the GEN_DELIMS set.\n     parsed_path: str = quote(path, safe=SUB_DELIMS + \":/[]@\")\n     # For 'query' we need to drop '#' from the GEN_DELIMS set.\n+    # We also exclude '/' because it is more robust to replace it with a percent\n+    # encoding despite it not being a requirement of the spec and include '%' to\n+    # prevent duplicate encoding of previously quoted items.\n     parsed_query: typing.Optional[str] = (\n-        None if query is None else quote(query, safe=SUB_DELIMS + \":/?[]@\")\n+        None if query is None else quote(query, safe=SUB_DELIMS + \":?[]@%\")",
      "comment": "I'll rephrase: Can you drop that bit from this pull request? It seems unrelated so it'd make sense to consider it separately.",
      "comment_id": 1207742623,
      "user": "lovelydinosaur",
      "created_at": "2023-05-27T07:09:05Z",
      "url": "https://github.com/encode/httpx/pull/2723#discussion_r1207742623"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2723,
      "file_path": "httpx/_urlparse.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -260,8 +260,11 @@ def urlparse(url: str = \"\", **kwargs: typing.Optional[str]) -> ParseResult:\n     # For 'path' we need to drop ? and # from the GEN_DELIMS set.\n     parsed_path: str = quote(path, safe=SUB_DELIMS + \":/[]@\")\n     # For 'query' we need to drop '#' from the GEN_DELIMS set.\n+    # We also exclude '/' because it is more robust to replace it with a percent\n+    # encoding despite it not being a requirement of the spec and include '%' to\n+    # prevent duplicate encoding of previously quoted items.\n     parsed_query: typing.Optional[str] = (\n-        None if query is None else quote(query, safe=SUB_DELIMS + \":/?[]@\")\n+        None if query is None else quote(query, safe=SUB_DELIMS + \":?[]@%\")",
      "comment": "Yeah I can but then the _other_ change will make the tests fail i.e. this pull request will introduce a incorrect behavior. I don't understand why yet. I'll adjust my commit so you can see it in CI.",
      "comment_id": 1209579869,
      "user": "zanieb",
      "created_at": "2023-05-29T22:40:17Z",
      "url": "https://github.com/encode/httpx/pull/2723#discussion_r1209579869"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2723,
      "file_path": "httpx/_urlparse.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -260,8 +260,11 @@ def urlparse(url: str = \"\", **kwargs: typing.Optional[str]) -> ParseResult:\n     # For 'path' we need to drop ? and # from the GEN_DELIMS set.\n     parsed_path: str = quote(path, safe=SUB_DELIMS + \":/[]@\")\n     # For 'query' we need to drop '#' from the GEN_DELIMS set.\n+    # We also exclude '/' because it is more robust to replace it with a percent\n+    # encoding despite it not being a requirement of the spec and include '%' to\n+    # prevent duplicate encoding of previously quoted items.\n     parsed_query: typing.Optional[str] = (\n-        None if query is None else quote(query, safe=SUB_DELIMS + \":/?[]@\")\n+        None if query is None else quote(query, safe=SUB_DELIMS + \":?[]@%\")",
      "comment": "> I can but then the other change will make the tests fail i.e. this pull request will introduce a incorrect behavior.\r\n\r\nOkay. That would be worthwhile, we can review from there.",
      "comment_id": 1219265789,
      "user": "lovelydinosaur",
      "created_at": "2023-06-06T09:21:42Z",
      "url": "https://github.com/encode/httpx/pull/2723#discussion_r1219265789"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2723,
      "file_path": "httpx/_urlparse.py",
      "line": 266,
      "side": "RIGHT",
      "diff_hunk": "@@ -260,8 +260,10 @@ def urlparse(url: str = \"\", **kwargs: typing.Optional[str]) -> ParseResult:\n     # For 'path' we need to drop ? and # from the GEN_DELIMS set.\n     parsed_path: str = quote(path, safe=SUB_DELIMS + \":/[]@\")\n     # For 'query' we need to drop '#' from the GEN_DELIMS set.\n+    # We also exclude '/' because it is more robust to replace it with a percent\n+    # encoding despite it not being a requirement of the spec.\n     parsed_query: typing.Optional[str] = (\n-        None if query is None else quote(query, safe=SUB_DELIMS + \":/?[]@\")\n+        None if query is None else quote(query, safe=SUB_DELIMS + \":?[]@\")",
      "comment": "This change was unnecessary. The fix was the changes below. We dont need to change an already encoded query to encode slashes. We do need to handle it when passed in as separate parameter.",
      "comment_id": 1414362854,
      "user": "elupus",
      "created_at": "2023-12-04T19:10:14Z",
      "url": "https://github.com/encode/httpx/pull/2723#discussion_r1414362854"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2909,
      "file_path": "httpx/_multipart.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -200,7 +199,7 @@ def __init__(\n         boundary: typing.Optional[bytes] = None,\n     ) -> None:\n         if boundary is None:\n-            boundary = binascii.hexlify(os.urandom(16))\n+            boundary = ''.join([f'{byte:02x}' for byte in(os.urandom(16)])",
      "comment": "Oh, I see python 2 user \ud83d\ude04 \r\n```suggestion\r\n            boundary = os.urandom(16).hex()\r\n```",
      "comment_id": 1376184439,
      "user": "T-256",
      "created_at": "2023-10-30T13:03:24Z",
      "url": "https://github.com/encode/httpx/pull/2909#discussion_r1376184439"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2854,
      "file_path": "httpx/_config.py",
      "line": 135,
      "side": "LEFT",
      "diff_hunk": "@@ -128,11 +127,10 @@ def load_ssl_context_verify(self) -> ssl.SSLContext:\n \n         # Signal to server support for PHA in TLS 1.3. Raises an\n         # AttributeError if only read-only access is implemented.\n-        if sys.version_info >= (3, 8):  # pragma: no cover\n-            try:\n-                context.post_handshake_auth = True\n-            except AttributeError:  # pragma: no cover\n-                pass",
      "comment": "Python 3.7 no longer supported https://github.com/encode/httpx/pull/2813",
      "comment_id": 1330177340,
      "user": "T-256",
      "created_at": "2023-09-19T13:58:04Z",
      "url": "https://github.com/encode/httpx/pull/2854#discussion_r1330177340"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2854,
      "file_path": "httpx/_config.py",
      "line": 135,
      "side": "LEFT",
      "diff_hunk": "@@ -128,11 +127,10 @@ def load_ssl_context_verify(self) -> ssl.SSLContext:\n \n         # Signal to server support for PHA in TLS 1.3. Raises an\n         # AttributeError if only read-only access is implemented.\n-        if sys.version_info >= (3, 8):  # pragma: no cover\n-            try:\n-                context.post_handshake_auth = True\n-            except AttributeError:  # pragma: no cover\n-                pass",
      "comment": "Yep, with 3.8+, the condition `sys.version_info >= (3, 8)` is always true.",
      "comment_id": 1330191242,
      "user": "hugovk",
      "created_at": "2023-09-19T14:05:37Z",
      "url": "https://github.com/encode/httpx/pull/2854#discussion_r1330191242"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2852,
      "file_path": "tests/models/test_responses.py",
      "line": 311,
      "side": "RIGHT",
      "diff_hunk": "@@ -298,6 +298,22 @@ def test_response_force_encoding():\n     assert response.encoding == \"iso-8859-1\"\n \n \n+def test_response_force_encoding_after_text_accessed():\n+    response = httpx.Response(\n+        200,\n+        content=b\"Hello, world!\",\n+    )\n+    assert response.status_code == 200\n+    assert response.reason_phrase == \"OK\"\n+    assert response.text == \"Hello, world!\"\n+    assert response.encoding == \"utf-8\"\n+\n+    response.encoding = \"UTF8\"",
      "comment": "I'd expect the `ValueError` to be raised here. I don't think we need the conditional \"don't raise if the encoding is being set but the resulting codec won't change\".\n\nSimplicity over complexity where possible.",
      "comment_id": 1328064919,
      "user": "lovelydinosaur",
      "created_at": "2023-09-17T08:52:20Z",
      "url": "https://github.com/encode/httpx/pull/2852#discussion_r1328064919"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2716,
      "file_path": "httpx/_transports/default.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,6 +28,7 @@\n from types import TracebackType\n \n import httpcore\n+from httpcore.backends.base import SOCKET_OPTION",
      "comment": "Let's not import that type definition, it's not documented public API.\r\n\r\nIt's be okay to instead define the socket option types here.\r\n\r\n```python\r\nSOCKET_OPTION = typing.Union[\r\n    typing.Tuple[int, int, int],\r\n    typing.Tuple[int, int, typing.Union[bytes, bytearray]],\r\n    typing.Tuple[int, int, None, int],\r\n]\r\n```",
      "comment_id": 1203667142,
      "user": "lovelydinosaur",
      "created_at": "2023-05-24T08:14:28Z",
      "url": "https://github.com/encode/httpx/pull/2716#discussion_r1203667142"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2669,
      "file_path": "tests/test_asgi.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,6 +3,7 @@\n import pytest\n \n import httpx\n+from httpx._transports.asgi import ASGITransport",
      "comment": "We don't need the import from private API space here.\r\nWe can use `httpx.ASGITransport`, same as the other tests.",
      "comment_id": 1172572391,
      "user": "lovelydinosaur",
      "created_at": "2023-04-20T13:14:57Z",
      "url": "https://github.com/encode/httpx/pull/2669#discussion_r1172572391"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2669,
      "file_path": "tests/test_asgi.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,3 +192,12 @@ async def read_body(scope, receive, send):\n \n     assert response.status_code == 200\n     assert disconnect\n+\n+\n+@pytest.mark.anyio\n+async def test_asgi_exc_no_raise():\n+    transport = ASGITransport(app=raise_exc, raise_app_exceptions=False)\n+    async with httpx.AsyncClient(app=raise_exc, transport=transport) as client:\n+        response = await client.get(\"http://www.example.org/\")\n+\n+        assert response.status_code == 500",
      "comment": "What's the behaviour of this test before the code change?",
      "comment_id": 1172573305,
      "user": "lovelydinosaur",
      "created_at": "2023-04-20T13:15:40Z",
      "url": "https://github.com/encode/httpx/pull/2669#discussion_r1172573305"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2669,
      "file_path": "tests/test_asgi.py",
      "line": 200,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,3 +192,12 @@ async def read_body(scope, receive, send):\n \n     assert response.status_code == 200\n     assert disconnect\n+\n+\n+@pytest.mark.anyio\n+async def test_asgi_exc_no_raise():\n+    transport = ASGITransport(app=raise_exc, raise_app_exceptions=False)\n+    async with httpx.AsyncClient(app=raise_exc, transport=transport) as client:",
      "comment": "Since we're specifying `transport=...` the `app=...` parameter is redundant.\r\n\r\n```suggestion\r\n    async with httpx.AsyncClient(transport=transport) as client:\r\n```",
      "comment_id": 1172575027,
      "user": "lovelydinosaur",
      "created_at": "2023-04-20T13:16:42Z",
      "url": "https://github.com/encode/httpx/pull/2669#discussion_r1172575027"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2669,
      "file_path": "tests/test_asgi.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,3 +192,12 @@ async def read_body(scope, receive, send):\n \n     assert response.status_code == 200\n     assert disconnect\n+\n+\n+@pytest.mark.anyio\n+async def test_asgi_exc_no_raise():\n+    transport = ASGITransport(app=raise_exc, raise_app_exceptions=False)\n+    async with httpx.AsyncClient(app=raise_exc, transport=transport) as client:\n+        response = await client.get(\"http://www.example.org/\")\n+\n+        assert response.status_code == 500",
      "comment": "Test failed with `RuntimeError` being raised from `raise_exc`",
      "comment_id": 1172689472,
      "user": "Nnonexistent",
      "created_at": "2023-04-20T14:32:59Z",
      "url": "https://github.com/encode/httpx/pull/2669#discussion_r1172689472"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2680,
      "file_path": "httpx/_utils.py",
      "line": 467,
      "side": "RIGHT",
      "diff_hunk": "@@ -464,14 +464,14 @@ def __eq__(self, other: typing.Any) -> bool:\n def is_ipv4_hostname(hostname: str) -> bool:\n     try:\n         ipaddress.IPv4Address(hostname.split(\"/\")[0])\n-    except:\n+    except ValueError:",
      "comment": "Not sure if an IndexError is required too.\r\nMaybe we can replace it with `except Exception`.",
      "comment_id": 1176504865,
      "user": "aminalaee",
      "created_at": "2023-04-25T13:16:56Z",
      "url": "https://github.com/encode/httpx/pull/2680#discussion_r1176504865"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2680,
      "file_path": "httpx/_utils.py",
      "line": 467,
      "side": "RIGHT",
      "diff_hunk": "@@ -464,14 +464,14 @@ def __eq__(self, other: typing.Any) -> bool:\n def is_ipv4_hostname(hostname: str) -> bool:\n     try:\n         ipaddress.IPv4Address(hostname.split(\"/\")[0])\n-    except:\n+    except ValueError:",
      "comment": "Technically speaking `except Exception` would guarantee the same behaviour?",
      "comment_id": 1176696378,
      "user": "michaeloliverx",
      "created_at": "2023-04-25T15:32:49Z",
      "url": "https://github.com/encode/httpx/pull/2680#discussion_r1176696378"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2680,
      "file_path": "httpx/_utils.py",
      "line": 467,
      "side": "RIGHT",
      "diff_hunk": "@@ -464,14 +464,14 @@ def __eq__(self, other: typing.Any) -> bool:\n def is_ipv4_hostname(hostname: str) -> bool:\n     try:\n         ipaddress.IPv4Address(hostname.split(\"/\")[0])\n-    except:\n+    except ValueError:",
      "comment": "Yeah, and the only reason we allowed this was because of the ruff issue. Flake8 would have caught this too.",
      "comment_id": 1176767295,
      "user": "aminalaee",
      "created_at": "2023-04-25T16:29:46Z",
      "url": "https://github.com/encode/httpx/pull/2680#discussion_r1176767295"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2570,
      "file_path": "tests/test_decoders.py",
      "line": 335,
      "side": "LEFT",
      "diff_hunk": "@@ -214,125 +213,55 @@ async def iterator() -> typing.AsyncIterator[bytes]:\n \n \n def test_text_decoder_empty_cases():\n-    decoder = TextDecoder()\n-    assert decoder.flush() == \"\"\n+    response = httpx.Response(200, content=b\"\")\n+    assert response.text == \"\"\n \n-    decoder = TextDecoder()\n-    assert decoder.decode(b\"\") == \"\"\n-    assert decoder.flush() == \"\"\n+    response = httpx.Response(200, content=[b\"\"])\n+    response.read()\n+    assert response.text == \"\"\n \n \n def test_line_decoder_nl():\n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"a\\n\\nb\\nc\") == [\"a\\n\", \"\\n\", \"b\\n\"]\n-    assert decoder.flush() == [\"c\"]\n+    response = httpx.Response(200, content=[b\"\"])\n+    assert list(response.iter_lines()) == []\n \n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"a\\n\\nb\\nc\\n\") == [\"a\\n\", \"\\n\", \"b\\n\", \"c\\n\"]\n-    assert decoder.flush() == []\n+    response = httpx.Response(200, content=[b\"\", b\"a\\n\\nb\\nc\"])\n+    assert list(response.iter_lines()) == [\"a\\n\", \"\\n\", \"b\\n\", \"c\"]\n \n     # Issue #1033\n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"12345\\n\") == [\"12345\\n\"]\n-    assert decoder.decode(\"foo \") == []\n-    assert decoder.decode(\"bar \") == []\n-    assert decoder.decode(\"baz\\n\") == [\"foo bar baz\\n\"]\n-    assert decoder.flush() == []\n+    response = httpx.Response(\n+        200, content=[b\"\", b\"12345\\n\", b\"foo \", b\"bar \", b\"baz\\n\"]\n+    )\n+    assert list(response.iter_lines()) == [\"12345\\n\", \"foo bar baz\\n\"]\n \n \n def test_line_decoder_cr():\n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"a\\r\\rb\\rc\") == [\"a\\n\", \"\\n\", \"b\\n\"]\n-    assert decoder.flush() == [\"c\"]\n+    response = httpx.Response(200, content=[b\"\", b\"a\\r\\rb\\rc\"])\n+    assert list(response.iter_lines()) == [\"a\\n\", \"\\n\", \"b\\n\", \"c\"]\n \n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"a\\r\\rb\\rc\\r\") == [\"a\\n\", \"\\n\", \"b\\n\"]\n-    assert decoder.flush() == [\"c\\n\"]\n+    response = httpx.Response(200, content=[b\"\", b\"a\\r\\rb\\rc\\r\"])\n+    assert list(response.iter_lines()) == [\"a\\n\", \"\\n\", \"b\\n\", \"c\\n\"]\n \n     # Issue #1033\n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"12345\\r\") == []\n-    assert decoder.decode(\"foo \") == [\"12345\\n\"]\n-    assert decoder.decode(\"bar \") == []\n-    assert decoder.decode(\"baz\\r\") == []\n-    assert decoder.flush() == [\"foo bar baz\\n\"]\n+    response = httpx.Response(\n+        200, content=[b\"\", b\"12345\\r\", b\"foo \", b\"bar \", b\"baz\\r\"]\n+    )\n+    assert list(response.iter_lines()) == [\"12345\\n\", \"foo bar baz\\n\"]\n \n \n def test_line_decoder_crnl():\n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"a\\r\\n\\r\\nb\\r\\nc\") == [\"a\\n\", \"\\n\", \"b\\n\"]\n-    assert decoder.flush() == [\"c\"]\n-\n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"a\\r\\n\\r\\nb\\r\\nc\\r\\n\") == [\"a\\n\", \"\\n\", \"b\\n\", \"c\\n\"]\n-    assert decoder.flush() == []\n-\n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"a\\r\") == []\n-    assert decoder.decode(\"\\n\\r\\nb\\r\\nc\") == [\"a\\n\", \"\\n\", \"b\\n\"]\n-    assert decoder.flush() == [\"c\"]\n+    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\"])\n+    assert list(response.iter_lines()) == [\"a\\n\", \"\\n\", \"b\\n\", \"c\"]\n+\n+    response = httpx.Response(200, content=[b\"\", b\"a\\r\\n\\r\\nb\\r\\nc\\r\\n\"])\n+    assert list(response.iter_lines()) == [\"a\\n\", \"\\n\", \"b\\n\", \"c\\n\"]\n+\n+    response = httpx.Response(200, content=[b\"\", b\"a\\r\", b\"\\n\\r\\nb\\r\\nc\"])\n+    assert list(response.iter_lines()) == [\"a\\n\", \"\\n\", \"b\\n\", \"c\"]\n \n     # Issue #1033\n-    decoder = LineDecoder()\n-    assert decoder.decode(\"\") == []\n-    assert decoder.decode(\"12345\\r\\n\") == [\"12345\\n\"]\n-    assert decoder.decode(\"foo \") == []\n-    assert decoder.decode(\"bar \") == []\n-    assert decoder.decode(\"baz\\r\\n\") == [\"foo bar baz\\n\"]\n-    assert decoder.flush() == []\n-\n-\n-def test_byte_chunker():\n-    decoder = ByteChunker()\n-    assert decoder.decode(b\"1234567\") == [b\"1234567\"]\n-    assert decoder.decode(b\"89\") == [b\"89\"]\n-    assert decoder.flush() == []\n-\n-    decoder = ByteChunker(chunk_size=3)\n-    assert decoder.decode(b\"1234567\") == [b\"123\", b\"456\"]\n-    assert decoder.decode(b\"89\") == [b\"789\"]\n-    assert decoder.flush() == []\n-\n-    decoder = ByteChunker(chunk_size=3)\n-    assert decoder.decode(b\"123456\") == [b\"123\", b\"456\"]\n-    assert decoder.decode(b\"789\") == [b\"789\"]\n-    assert decoder.flush() == []\n-\n-    decoder = ByteChunker(chunk_size=3)\n-    assert decoder.decode(b\"123456\") == [b\"123\", b\"456\"]\n-    assert decoder.decode(b\"78\") == []\n-    assert decoder.flush() == [b\"78\"]\n-\n-\n-def test_text_chunker():\n-    decoder = TextChunker()\n-    assert decoder.decode(\"1234567\") == [\"1234567\"]\n-    assert decoder.decode(\"89\") == [\"89\"]\n-    assert decoder.flush() == []\n-\n-    decoder = TextChunker(chunk_size=3)\n-    assert decoder.decode(\"1234567\") == [\"123\", \"456\"]\n-    assert decoder.decode(\"89\") == [\"789\"]\n-    assert decoder.flush() == []\n-\n-    decoder = TextChunker(chunk_size=3)\n-    assert decoder.decode(\"123456\") == [\"123\", \"456\"]\n-    assert decoder.decode(\"789\") == [\"789\"]\n-    assert decoder.flush() == []\n-\n-    decoder = TextChunker(chunk_size=3)\n-    assert decoder.decode(\"123456\") == [\"123\", \"456\"]\n-    assert decoder.decode(\"78\") == []\n-    assert decoder.flush() == [\"78\"]",
      "comment": "Most of these cases we actually already well covered in `test_responses.py`, so I figured I'd expand those a bit to match coverage, and drop these.",
      "comment_id": 1096597170,
      "user": "florimondmanca",
      "created_at": "2023-02-04T23:07:37Z",
      "url": "https://github.com/encode/httpx/pull/2570#discussion_r1096597170"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2648,
      "file_path": "tests/client/test_async_client.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -84,7 +84,7 @@ async def test_access_content_stream_response(server):\n \n     assert response.status_code == 200\n     with pytest.raises(httpx.ResponseNotRead):\n-        response.content\n+        response.content  # noqa: B018",
      "comment": "It's on the rules page: https://beta.ruff.rs/docs/rules/#flake8-bugbear-b\r\n\r\nShould I add a comment here or ignore it globally?",
      "comment_id": 1158258821,
      "user": "Kludex",
      "created_at": "2023-04-05T09:22:34Z",
      "url": "https://github.com/encode/httpx/pull/2648#discussion_r1158258821"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2547,
      "file_path": "httpx/_client.py",
      "line": 1013,
      "side": "RIGHT",
      "diff_hunk": "@@ -1010,10 +1010,13 @@ def _send_single_request(self, request: Request) -> Response:\n         self.cookies.extract_cookies(response)\n         response.default_encoding = self._default_encoding\n \n-        status = f\"{response.status_code} {response.reason_phrase}\"\n-        response_line = f\"{response.http_version} {status}\"\n-        logger.debug(\n-            'HTTP Request: %s %s \"%s\"', request.method, request.url, response_line\n+        logger.info(",
      "comment": "Based on the other python packages, I don't recall any other python client having an INFO log message level. :thinking: ",
      "comment_id": 1141706645,
      "user": "Kludex",
      "created_at": "2023-03-20T07:17:57Z",
      "url": "https://github.com/encode/httpx/pull/2547#discussion_r1141706645"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2547,
      "file_path": "httpx/_client.py",
      "line": 1013,
      "side": "RIGHT",
      "diff_hunk": "@@ -1010,10 +1010,13 @@ def _send_single_request(self, request: Request) -> Response:\n         self.cookies.extract_cookies(response)\n         response.default_encoding = self._default_encoding\n \n-        status = f\"{response.status_code} {response.reason_phrase}\"\n-        response_line = f\"{response.http_version} {status}\"\n-        logger.debug(\n-            'HTTP Request: %s %s \"%s\"', request.method, request.url, response_line\n+        logger.info(",
      "comment": "It could yes, though it's less useful to have logging if everything is at the same level.\r\nI like the different \"show me nothing\", \"show me the requests\", \"show me the debug\" lighting levels.\r\n\r\n(Similar: gunicorn, uvicorn using INFO for requests, and DEBUG for other stuffs)",
      "comment_id": 1141930995,
      "user": "lovelydinosaur",
      "created_at": "2023-03-20T10:45:16Z",
      "url": "https://github.com/encode/httpx/pull/2547#discussion_r1141930995"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "tests/models/test_responses.py",
      "line": 642,
      "side": "RIGHT",
      "diff_hunk": "@@ -639,7 +639,7 @@ def test_iter_lines():\n         content=b\"Hello,\\nworld!\",\n     )\n     content = [line for line in response.iter_lines()]\n-    assert content == [\"Hello,\\n\", \"world!\"]\n+    assert content == [\"Hello,\", \"world!\"]",
      "comment": "These test changes show that currently this PR introduces a behavior change. I assume we don't want behavior to change, i.e. for `\\n` to stay in the yielded lines? Does that mean relying on `splitlines(keep_ends=True)`... ?",
      "comment_id": 1014794251,
      "user": "florimondmanca",
      "created_at": "2022-11-06T09:13:57Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1014794251"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "tests/models/test_responses.py",
      "line": 642,
      "side": "RIGHT",
      "diff_hunk": "@@ -639,7 +639,7 @@ def test_iter_lines():\n         content=b\"Hello,\\nworld!\",\n     )\n     content = [line for line in response.iter_lines()]\n-    assert content == [\"Hello,\\n\", \"world!\"]\n+    assert content == [\"Hello,\", \"world!\"]",
      "comment": "Oh, I didn't realise there was a `keepends` flag, let me rework the patch with that. ",
      "comment_id": 1027299829,
      "user": "giannitedesco",
      "created_at": "2022-11-20T14:30:48Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1027299829"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "tests/models/test_responses.py",
      "line": 642,
      "side": "RIGHT",
      "diff_hunk": "@@ -639,7 +639,7 @@ def test_iter_lines():\n         content=b\"Hello,\\nworld!\",\n     )\n     content = [line for line in response.iter_lines()]\n-    assert content == [\"Hello,\\n\", \"world!\"]\n+    assert content == [\"Hello,\", \"world!\"]",
      "comment": "Right, the issue is that `keepends` ~converts~ doesn't convert them all to `\\n`",
      "comment_id": 1027510876,
      "user": "giannitedesco",
      "created_at": "2022-11-21T03:23:35Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1027510876"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 286,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if not text:\n+            return []\n+\n+        lines = text.splitlines(True)\n+        if text.endswith(\"\\n\"):\n+            self.buffer = \"\"\n+        else:\n+            remainder = lines.pop()\n+            self.buffer = remainder\n \n         return lines\n \n     def flush(self) -> typing.List[str]:\n-        if self.buffer.endswith(\"\\r\"):\n-            # Handle the case where we had a trailing '\\r', which could have\n-            # been a '\\r\\n' pair.\n-            lines = [self.buffer[:-1] + \"\\n\"]\n-        elif self.buffer:\n-            lines = [self.buffer]\n-        else:\n-            lines = []\n+        lines = self.buffer.splitlines(True)",
      "comment": "I guess we'll want to drop the `True` here, given review comments.",
      "comment_id": 1044351555,
      "user": "lovelydinosaur",
      "created_at": "2022-12-09T11:18:54Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1044351555"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 276,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if not text:\n+            return []\n+\n+        lines = text.splitlines(True)",
      "comment": "I guess we'll want to drop the `True` here, given review comments.",
      "comment_id": 1044351913,
      "user": "lovelydinosaur",
      "created_at": "2022-12-09T11:19:22Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1044351913"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 277,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if not text:\n+            return []\n+\n+        lines = text.splitlines(True)\n+        if text.endswith(\"\\n\"):",
      "comment": "I *think* this would then be something like...\r\n\r\n```python\r\nlastline = lines[-1]\r\nif lastline and text and lastline[-1] != text[-1]:\r\n    # The final line ends with a different character to the input\r\n    # text, so it must have ended in a newline.\r\n    ...\r\nelse:\r\n    #\u00a0The final line *didn't* end with a newline, so push it back\r\n    # into the buffer.\r\n    ...\r\n```",
      "comment_id": 1044355428,
      "user": "lovelydinosaur",
      "created_at": "2022-12-09T11:24:02Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1044355428"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 272,
      "side": "RIGHT",
      "diff_hunk": "@@ -266,57 +266,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if text.endswith(\"\\r\"):",
      "comment": "`splitlines()` will teat a trailing `\"\\r\"` as a newline because it is designed around the assumption that that input is the whole string.. in the case of the line decoder, when a trailing `\"\\r\"` is received, we need to buffer it up in case the next character in the input stream is an `\"\\n\"` (ie. it was part of an interrupted `\"\\r\\n\"` sequence)",
      "comment_id": 1045052360,
      "user": "giannitedesco",
      "created_at": "2022-12-10T10:10:21Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1045052360"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 272,
      "side": "RIGHT",
      "diff_hunk": "@@ -266,57 +266,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if text.endswith(\"\\r\"):",
      "comment": "well, if we go with this version then it needs a comment :)",
      "comment_id": 1045052847,
      "user": "giannitedesco",
      "created_at": "2022-12-10T10:11:49Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1045052847"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if text.endswith(\"\\r\"):\n+            self.buffer = text\n+            return []\n+\n+        lines = text.splitlines()\n+        if text.endswith(\"\\n\") or not lines:",
      "comment": "The `if text.endswith(\"\\n\")` doesn't seems sufficient to me.\r\n\r\nOther newline endings [are also available](https://docs.python.org/3/library/stdtypes.html#str.splitlines).\r\n\r\nI'd assume that our test cases aren't covering this sufficiently.",
      "comment_id": 1045653671,
      "user": "lovelydinosaur",
      "created_at": "2022-12-12T10:32:26Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1045653671"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 272,
      "side": "RIGHT",
      "diff_hunk": "@@ -266,57 +266,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if text.endswith(\"\\r\"):",
      "comment": "Gotcha. Yes a comment would be good. I assume that `\"\\r\\n\"` is the *only* two-character newline sequence, right?",
      "comment_id": 1045679676,
      "user": "lovelydinosaur",
      "created_at": "2022-12-12T10:57:22Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1045679676"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if text.endswith(\"\\r\"):\n+            self.buffer = text\n+            return []\n+\n+        lines = text.splitlines()\n+        if text.endswith(\"\\n\") or not lines:",
      "comment": "The behaviour when using any of the other \"funny money\" line-endings is not really incorrect output, but that trailing lines will be delayed until the subsequent call or until finalization when one or two lines will be returned.",
      "comment_id": 1045694536,
      "user": "giannitedesco",
      "created_at": "2022-12-12T11:13:20Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1045694536"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if text.endswith(\"\\r\"):\n+            self.buffer = text\n+            return []\n+\n+        lines = text.splitlines()\n+        if text.endswith(\"\\n\") or not lines:",
      "comment": "Well, unless you consider splitting on those other line endings is, itself, as a bug/unintended. (I had no idea, fwiw)",
      "comment_id": 1045695695,
      "user": "giannitedesco",
      "created_at": "2022-12-12T11:14:38Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1045695695"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 283,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,23 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        if self.buffer:\n+            text = self.buffer + text\n+\n+        if text.endswith(\"\\r\"):\n+            self.buffer = text\n+            return []\n+\n+        lines = text.splitlines()\n+        if text.endswith(\"\\n\") or not lines:\n+            self.buffer = \"\"\n+        else:\n+            self.buffer = lines.pop()\n \n         return lines",
      "comment": "```suggestion\r\n        # See https://docs.python.org/3/library/stdtypes.html#str.splitlines\r\n        NEWLINE_CHARS = \"\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029\"\r\n\r\n        if self.buffer:\r\n            # If we have some buffered text from the previous pass,\r\n            # then we include it before handling the input.\r\n            text = self.buffer + text\r\n            self.buffer = \"\"\r\n\r\n        if not text:\r\n            return []\r\n        elif text[-1] == \"\\r\":\r\n            # If the last character is \"\\r\", then we might be about to see \"\\r\\n\"\r\n            # newline seperator. We buffer the text input and return.\r\n            self.buffer = text\r\n            return []\r\n        elif text[-1] in NEWLINE_CHARS:\r\n            # If the last character is a newline separator then we can simply split\r\n            # the text into lines and return them. There is no remaining portion\r\n            # to be dealt with on the next pass.\r\n            return text.splitlines()\r\n        else:\r\n            # If the last character is not a newline seperator, then the final portion\r\n            # from `splitlines()` is incomplete and needs to be buffered for the next\r\n            # pass.\r\n            lines = text.splitlines()\r\n            self.buffer = lines.pop()\r\n            return lines\r\n```",
      "comment_id": 1050940196,
      "user": "lovelydinosaur",
      "created_at": "2022-12-16T16:30:16Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1050940196"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 276,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,34 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        # See https://docs.python.org/3/library/stdtypes.html#str.splitlines\n+        NEWLINE_CHARS = \"\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029\"\n+\n+        if self.buffer:\n+            # If we have some buffered text from the previous pass,\n+            # then we include it before handling the input.\n+            text = self.buffer + text",
      "comment": "Please correct me if I'm wrong, but it seems like if we do the following:\r\n\r\n```python\r\nfor i in range(N):\r\n    decoder.decode(\"a\")\r\n```\r\n\r\nthen we will have N string concatenations here (e.g. N string concatenations gives us O(N**2)). I'm curious if there any way to avoid it?\r\n\r\nE.g. may be we can use a `list` as a buffer, and do `''.join(buffer)` (it's O(N)) when newline is coming?",
      "comment_id": 1066603902,
      "user": "cdeler",
      "created_at": "2023-01-11T06:07:22Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1066603902"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 276,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,34 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        # See https://docs.python.org/3/library/stdtypes.html#str.splitlines\n+        NEWLINE_CHARS = \"\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029\"\n+\n+        if self.buffer:\n+            # If we have some buffered text from the previous pass,\n+            # then we include it before handling the input.\n+            text = self.buffer + text",
      "comment": "Well observed.\r\n\r\nThis will run slowly...\r\n\r\n```python\r\nclass LineDecoder:\r\n    \"\"\"\r\n    Handles incrementally reading lines from text.\r\n    Uses universal line decoding, supporting any of `\\n`, `\\r`, or `\\r\\n`\r\n    as line endings, normalizing to `\\n`.\r\n    \"\"\"\r\n\r\n    def __init__(self):\r\n        self.buffer = \"\"\r\n\r\n    def decode(self, text):\r\n        # See https://docs.python.org/3/library/stdtypes.html#str.splitlines\r\n        NEWLINE_CHARS = \"\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029\"\r\n\r\n        if self.buffer:\r\n            # If we have some buffered text from the previous pass,\r\n            # then we include it before handling the input.\r\n            text = self.buffer + text\r\n            self.buffer = \"\"\r\n\r\n        if not text:\r\n            return []\r\n\r\n        lines = text.splitlines()\r\n\r\n        if text[-1] == \"\\r\":\r\n            # If the last character is \"\\r\", then we might be on the boundary of\r\n            # a \"\\r\\n\" sequence. We reassemble and buffer the final portion of the input.\r\n            self.buffer = lines.pop() + \"\\r\"\r\n        elif text[-1] not in NEWLINE_CHARS:\r\n            # If the last character is not a newline seperator, then the final portion\r\n            # from `splitlines()` is incomplete and needs to be buffered for the next\r\n            # pass.\r\n            self.buffer = lines.pop()\r\n\r\n        return lines\r\n\r\n    def flush(self):\r\n        lines = self.buffer.splitlines()\r\n        self.buffer = \"\"\r\n        return lines\r\n\r\n\r\nl = LineDecoder()\r\nfor i in range(100_000):\r\n    l.decode(\"a\")\r\nl.flush()\r\n```",
      "comment_id": 1066796498,
      "user": "lovelydinosaur",
      "created_at": "2023-01-11T10:00:50Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1066796498"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 276,
      "side": "RIGHT",
      "diff_hunk": "@@ -267,57 +267,34 @@ def __init__(self) -> None:\n         self.buffer = \"\"\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        # See https://docs.python.org/3/library/stdtypes.html#str.splitlines\n+        NEWLINE_CHARS = \"\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029\"\n+\n+        if self.buffer:\n+            # If we have some buffered text from the previous pass,\n+            # then we include it before handling the input.\n+            text = self.buffer + text",
      "comment": "I feel we should re-write the `flush(...)`\r\n\r\n```diff\r\n    def flush(self) -> typing.List[str]:\r\n        if self.buffer or self.trailing_cr:\r\n-            return [\"\".join(self.buffer)]\r\n+            result = [\"\".join(self.buffer)]\r\n+            self.buffer = []\r\n+            return result\r\n        return []\r\n```",
      "comment_id": 1067360513,
      "user": "cdeler",
      "created_at": "2023-01-11T19:04:30Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1067360513"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2423,
      "file_path": "httpx/_decoders.py",
      "line": 311,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,67 +259,56 @@ class LineDecoder:\n     \"\"\"\n     Handles incrementally reading lines from text.\n \n-    Uses universal line decoding, supporting any of `\\n`, `\\r`, or `\\r\\n`\n-    as line endings, normalizing to `\\n`.\n+    Has the same behaviour as the stdllib splitlines, but handling the input iteratively.\n     \"\"\"\n \n     def __init__(self) -> None:\n-        self.buffer = \"\"\n+        self.buffer: typing.List[str] = []\n+        self.trailing_cr: bool = False\n \n     def decode(self, text: str) -> typing.List[str]:\n-        lines = []\n-\n-        if text and self.buffer and self.buffer[-1] == \"\\r\":\n-            if text.startswith(\"\\n\"):\n-                # Handle the case where we have an \"\\r\\n\" split across\n-                # our previous input, and our new chunk.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-                text = text[1:]\n-            else:\n-                # Handle the case where we have \"\\r\" at the end of our\n-                # previous input.\n-                lines.append(self.buffer[:-1] + \"\\n\")\n-                self.buffer = \"\"\n-\n-        while text:\n-            num_chars = len(text)\n-            for idx in range(num_chars):\n-                char = text[idx]\n-                next_char = None if idx + 1 == num_chars else text[idx + 1]\n-                if char == \"\\n\":\n-                    lines.append(self.buffer + text[: idx + 1])\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif char == \"\\r\" and next_char == \"\\n\":\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 2 :]\n-                    break\n-                elif char == \"\\r\" and next_char is not None:\n-                    lines.append(self.buffer + text[:idx] + \"\\n\")\n-                    self.buffer = \"\"\n-                    text = text[idx + 1 :]\n-                    break\n-                elif next_char is None:\n-                    self.buffer += text\n-                    text = \"\"\n-                    break\n+        # See https://docs.python.org/3/library/stdtypes.html#str.splitlines\n+        NEWLINE_CHARS = \"\\n\\r\\x0b\\x0c\\x1c\\x1d\\x1e\\x85\\u2028\\u2029\"\n+\n+        # We always push a trailing `\\r` into the next decode iteration.\n+        if self.trailing_cr:\n+            text = \"\\r\" + text\n+            self.trailing_cr = False\n+        if text.endswith(\"\\r\"):\n+            self.trailing_cr = True\n+            text = text[:-1]\n+\n+        if not text:\n+            return []\n+\n+        trailing_newline = text[-1] in NEWLINE_CHARS\n+        lines = text.splitlines()\n+\n+        if len(lines) == 1 and not trailing_newline:\n+            # No new lines, buffer the input and continue.\n+            self.buffer.append(lines[0])\n+            return []\n+\n+        if self.buffer:\n+            # Include any existing buffer in the first portion of the\n+            # splitlines result.\n+            lines = [\"\".join(self.buffer) + lines[0]] + lines[1:]\n+            self.buffer = []\n+\n+        if not trailing_newline:\n+            # If the last segment of splitlines is not newline terminated,\n+            # then drop it from our output and start a new buffer.\n+            self.buffer = [lines.pop()]\n \n         return lines\n \n     def flush(self) -> typing.List[str]:\n-        if self.buffer.endswith(\"\\r\"):\n-            # Handle the case where we had a trailing '\\r', which could have\n-            # been a '\\r\\n' pair.\n-            lines = [self.buffer[:-1] + \"\\n\"]\n-        elif self.buffer:\n-            lines = [self.buffer]\n-        else:\n-            lines = []\n-        self.buffer = \"\"\n-        return lines\n+        if self.buffer or self.trailing_cr:\n+            lines = [\"\".join(self.buffer)]\n+            self.buffer = []\n+            self.trailing_cr = False\n+            return lines\n+        return []",
      "comment": "```suggestion\r\n        if not self.buffer and not self.trailing_cr:\r\n            return []\r\n            \r\n        lines = [\"\".join(self.buffer)]\r\n        self.buffer = []\r\n        self.trailing_cr = False\r\n        return lines\r\n```",
      "comment_id": 1068912857,
      "user": "cdeler",
      "created_at": "2023-01-13T04:24:11Z",
      "url": "https://github.com/encode/httpx/pull/2423#discussion_r1068912857"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2572,
      "file_path": "httpx/_urlparse.py",
      "line": 208,
      "side": "LEFT",
      "diff_hunk": "@@ -195,18 +195,6 @@ def urlparse(url: str = \"\", **kwargs: typing.Optional[str]) -> ParseResult:\n     # -------------------------------------------------------------\n \n     for key, value in kwargs.items():\n-        if key not in (\n-            \"scheme\",\n-            \"authority\",\n-            \"path\",\n-            \"query\",\n-            \"fragment\",\n-            \"userinfo\",\n-            \"host\",\n-            \"port\",\n-        ):\n-            raise TypeError(f\"'{key}' is an invalid keyword argument for urlparse()\")",
      "comment": "We were already doing this check in `URL.__init__()`, so in the wild it would indeed be redundant as we use `httpx.URL()`, so I dropped this check.",
      "comment_id": 1096670353,
      "user": "florimondmanca",
      "created_at": "2023-02-05T11:44:24Z",
      "url": "https://github.com/encode/httpx/pull/2572#discussion_r1096670353"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2571,
      "file_path": "tests/test_exceptions.py",
      "line": 63,
      "side": "LEFT",
      "diff_hunk": "@@ -16,66 +14,39 @@ def test_httpcore_all_exceptions_mapped() -> None:\n     All exception classes exposed by HTTPCore are properly mapped to an HTTPX-specific\n     exception class.\n     \"\"\"\n-    not_mapped = [\n-        value\n-        for name, value in vars(httpcore).items()\n+    expected_mapped_httpcore_exceptions = {\n+        value.__name__\n+        for _, value in vars(httpcore).items()\n         if isinstance(value, type)\n         and issubclass(value, Exception)\n-        and value not in HTTPCORE_EXC_MAP\n         and value is not httpcore.ConnectionNotAvailable\n-    ]\n+    }\n \n-    if not_mapped:  # pragma: no cover\n-        pytest.fail(f\"Unmapped httpcore exceptions: {not_mapped}\")\n+    httpx_exceptions = {\n+        value.__name__\n+        for _, value in vars(httpx).items()\n+        if isinstance(value, type) and issubclass(value, Exception)\n+    }\n \n+    unmapped_exceptions = expected_mapped_httpcore_exceptions - httpx_exceptions\n \n-def test_httpcore_exception_mapping(server: \"TestServer\") -> None:\n-    \"\"\"\n-    HTTPCore exception mapping works as expected.\n-    \"\"\"\n-\n-    def connect_failed(*args, **kwargs):\n-        raise httpcore.ConnectError()\n-\n-    class TimeoutStream:\n-        def __iter__(self):\n-            raise httpcore.ReadTimeout()\n-\n-        def close(self):\n-            pass\n-\n-    with mock.patch(\n-        \"httpcore.ConnectionPool.handle_request\", side_effect=connect_failed\n-    ):\n-        with pytest.raises(httpx.ConnectError):\n-            httpx.get(server.url)\n+    if unmapped_exceptions:  # pragma: no cover\n+        pytest.fail(f\"Unmapped httpcore exceptions: {unmapped_exceptions}\")\n \n-    with mock.patch(\n-        \"httpcore.ConnectionPool.handle_request\",\n-        return_value=httpcore.Response(\n-            200, headers=[], content=TimeoutStream(), extensions={}\n-        ),\n-    ):\n-        with pytest.raises(httpx.ReadTimeout):\n-            httpx.get(server.url)\n \n-\n-def test_httpx_exceptions_exposed() -> None:",
      "comment": "The purpose of this test was to verify that we don't leave any exception class defined in `httpx/_exceptions.py` out of `httpx/__init__.py`.\r\n\r\nAs such, it's impossible to perform without reaching to `httpx._exceptions`.\r\n\r\nBut I also thought it wasn't very useful after all, so I am dropping it in this PR.",
      "comment_id": 1096665736,
      "user": "florimondmanca",
      "created_at": "2023-02-05T11:12:07Z",
      "url": "https://github.com/encode/httpx/pull/2571#discussion_r1096665736"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2535,
      "file_path": "httpx/_auth.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +142,34 @@ def _build_auth_header(\n         return f\"Basic {token}\"\n \n \n+class NetRCAuth(Auth):\n+    \"\"\"\n+    Use a 'netrc' file to lookup basic auth credentials based on the url host.\n+    \"\"\"\n+\n+    def __init__(self, file: typing.Optional[str]):\n+        self._netrc_info = netrc.netrc(file)\n+\n+    def auth_flow(self, request: Request) -> typing.Generator[Request, Response, None]:\n+        auth_info = self._netrc_info.authenticators(request.url.host)\n+        if auth_info is None or auth_info[2] is None:",
      "comment": "I'm sorry, may I ask you why you are checking the password for `None`?",
      "comment_id": 1066615132,
      "user": "cdeler",
      "created_at": "2023-01-11T06:26:56Z",
      "url": "https://github.com/encode/httpx/pull/2535#discussion_r1066615132"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2535,
      "file_path": "httpx/_auth.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +142,34 @@ def _build_auth_header(\n         return f\"Basic {token}\"\n \n \n+class NetRCAuth(Auth):\n+    \"\"\"\n+    Use a 'netrc' file to lookup basic auth credentials based on the url host.\n+    \"\"\"\n+\n+    def __init__(self, file: typing.Optional[str]):\n+        self._netrc_info = netrc.netrc(file)\n+\n+    def auth_flow(self, request: Request) -> typing.Generator[Request, Response, None]:\n+        auth_info = self._netrc_info.authenticators(request.url.host)\n+        if auth_info is None or auth_info[2] is None:",
      "comment": "I'm asking since previously you were checking \r\n```python\r\nif credentials is not None:\r\n    ...\r\n```\r\n\r\nand python documentation says ([link](https://docs.python.org/3/library/netrc.html#netrc.netrc.authenticators)) that \r\n> If the netrc file did not contain an entry for the given host, return the tuple associated with the \u2018default\u2019 entry. If neither matching host nor default entry is available, return None.\r\n\r\n",
      "comment_id": 1066617055,
      "user": "cdeler",
      "created_at": "2023-01-11T06:28:42Z",
      "url": "https://github.com/encode/httpx/pull/2535#discussion_r1066617055"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2535,
      "file_path": "httpx/_auth.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +142,34 @@ def _build_auth_header(\n         return f\"Basic {token}\"\n \n \n+class NetRCAuth(Auth):\n+    \"\"\"\n+    Use a 'netrc' file to lookup basic auth credentials based on the url host.\n+    \"\"\"\n+\n+    def __init__(self, file: typing.Optional[str]):\n+        self._netrc_info = netrc.netrc(file)\n+\n+    def auth_flow(self, request: Request) -> typing.Generator[Request, Response, None]:\n+        auth_info = self._netrc_info.authenticators(request.url.host)\n+        if auth_info is None or auth_info[2] is None:",
      "comment": "Thanks @cdeler.\r\n\r\nThe simple version of \"why\" is because I was blindly following our previous implementation details here.\r\n\r\nI've had a look into it, and I don't think the password can be `None` here, but I think it can be the empty string. It looks to me like Python 3.11+ will allow the empty string for a missing password field in the `netrc` file, and the previous versions will raise a parse error for missing passwords.\r\n\r\nI think the robust thing to do here would be...\r\n\r\n```python\r\nif auth_info is None or not auth_info[2]:\r\n```",
      "comment_id": 1066942807,
      "user": "lovelydinosaur",
      "created_at": "2023-01-11T12:38:35Z",
      "url": "https://github.com/encode/httpx/pull/2535#discussion_r1066942807"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2535,
      "file_path": "httpx/_auth.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +142,34 @@ def _build_auth_header(\n         return f\"Basic {token}\"\n \n \n+class NetRCAuth(Auth):\n+    \"\"\"\n+    Use a 'netrc' file to lookup basic auth credentials based on the url host.\n+    \"\"\"\n+\n+    def __init__(self, file: typing.Optional[str]):\n+        self._netrc_info = netrc.netrc(file)\n+\n+    def auth_flow(self, request: Request) -> typing.Generator[Request, Response, None]:\n+        auth_info = self._netrc_info.authenticators(request.url.host)\n+        if auth_info is None or auth_info[2] is None:",
      "comment": "```suggestion\r\n        if auth_info is None or not auth_info[2]:\r\n```",
      "comment_id": 1066943032,
      "user": "lovelydinosaur",
      "created_at": "2023-01-11T12:38:49Z",
      "url": "https://github.com/encode/httpx/pull/2535#discussion_r1066943032"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2535,
      "file_path": "httpx/_auth.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +142,34 @@ def _build_auth_header(\n         return f\"Basic {token}\"\n \n \n+class NetRCAuth(Auth):\n+    \"\"\"\n+    Use a 'netrc' file to lookup basic auth credentials based on the url host.\n+    \"\"\"\n+\n+    def __init__(self, file: typing.Optional[str]):\n+        self._netrc_info = netrc.netrc(file)\n+\n+    def auth_flow(self, request: Request) -> typing.Generator[Request, Response, None]:\n+        auth_info = self._netrc_info.authenticators(request.url.host)\n+        if auth_info is None or auth_info[2] is None:",
      "comment": "Demo'ing the behaviour of Python `netrc` with an empty password entry...\r\n\r\n```python\r\nimport netrc\r\nimport tempfile\r\n\r\n\r\nwith tempfile.NamedTemporaryFile(delete=False) as t:\r\n    t.write(b\"machine example.com\\nlogin user\\n\")\r\n    t.close()\r\n    n = netrc.netrc(t.name)\r\n    print(n.authenticators(\"example.com\"))\r\n```\r\n\r\nPython 3.11:\r\n\r\n```shell\r\n$ python3.11 ./example.py \r\n('user', '', '')\r\n```\r\n\r\nPython 3.10:\r\n\r\n```shell\r\n$ python3.10 ./example.py \r\nTraceback (most recent call last):\r\n  File \"/Users/tomchristie/Temp/./example.py\", line 8, in <module>\r\n    n = netrc.netrc(t.name)\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/netrc.py\", line 31, in __init__\r\n    self._parse(file, fp, default_netrc)\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/netrc.py\", line 82, in _parse\r\n    raise NetrcParseError(\r\nnetrc.NetrcParseError: malformed machine entry example.com terminated by '' (/var/folders/8s/dk9369g11yzdnsfkvbtljcjm0000gn/T/tmpipnocc0x, line 3)\r\n```",
      "comment_id": 1066955362,
      "user": "lovelydinosaur",
      "created_at": "2023-01-11T12:52:11Z",
      "url": "https://github.com/encode/httpx/pull/2535#discussion_r1066955362"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2523,
      "file_path": "tests/models/test_queryparams.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -87,6 +87,11 @@ def test_empty_query_params():\n     assert str(q) == \"a=\"\n \n \n+def test_invalid_query_params():\n+    with pytest.raises(TypeError):",
      "comment": "Seems nice to ensure that the formatted message is correct\r\n```suggestion\r\n    with pytest.raises(TypeError, match=r\"Expected str, int, float, bool, or None\\. Got 'bytes'\\.\"):\r\n```",
      "comment_id": 1059507467,
      "user": "zanieb",
      "created_at": "2022-12-30T20:01:02Z",
      "url": "https://github.com/encode/httpx/pull/2523#discussion_r1059507467"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2523,
      "file_path": "tests/models/test_queryparams.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,7 +89,7 @@ def test_empty_query_params():\n \n def test_invalid_query_params():\n     with pytest.raises(\n-        TypeError, match=r\"Expected str, int, float, bool, or None\\. Got 'bytes'\\.\"\n+        TypeError, match=r\"Expected str, int, float, bool, or None. Got 'bytes'.\"",
      "comment": "You don't need the `r` if you aren't escaping the periods \u2014 this is doing a `re.search` so technically the `.` will be a wildcard but \ud83e\udd37\u200d\u2640\ufe0f it's not likely to cause you any problems. You could use `re.escape` if you really wanted to be correct.",
      "comment_id": 1059518254,
      "user": "zanieb",
      "created_at": "2022-12-30T20:58:04Z",
      "url": "https://github.com/encode/httpx/pull/2523#discussion_r1059518254"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2512,
      "file_path": "tests/client/test_auth.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -152,7 +152,7 @@ async def async_auth_flow(\n         yield request\n \n \n-@pytest.mark.asyncio\n+@pytest.mark.anyio",
      "comment": "is there a reason these were not marked `@pytest.mark.usefixtures(\"async_environment\")` ?",
      "comment_id": 1053443351,
      "user": "graingert",
      "created_at": "2022-12-20T15:27:14Z",
      "url": "https://github.com/encode/httpx/pull/2512#discussion_r1053443351"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2512,
      "file_path": "tests/client/test_auth.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -152,7 +152,7 @@ async def async_auth_flow(\n         yield request\n \n \n-@pytest.mark.asyncio\n+@pytest.mark.anyio",
      "comment": "ah some of these tests used `asyncio.Lock` so only worked on asyncio. I changed it to `anyio.Lock` and they pass on trio or asyncio now",
      "comment_id": 1055414437,
      "user": "graingert",
      "created_at": "2022-12-22T12:35:16Z",
      "url": "https://github.com/encode/httpx/pull/2512#discussion_r1055414437"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2479,
      "file_path": "tests/test_main.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,29 +1,31 @@\n import os\n+import typing\n \n from click.testing import CliRunner\n \n import httpx\n+from httpx._main import main",
      "comment": "What's prompted this change?\r\n\r\nCan we continue to use `import httpx` and `httpx.main(...)` so that we're not importing private namespaces?",
      "comment_id": 1035955830,
      "user": "lovelydinosaur",
      "created_at": "2022-11-30T13:15:50Z",
      "url": "https://github.com/encode/httpx/pull/2479#discussion_r1035955830"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2479,
      "file_path": "tests/test_main.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,29 +1,31 @@\n import os\n+import typing\n \n from click.testing import CliRunner\n \n import httpx\n+from httpx._main import main",
      "comment": "Without this, mypy sees the `def main()` fallback defined in `httpx/__init__.py`, which is decidedly not a `click.BaseCommand` or subclass, so all the calls to `httpx.main()` then need a `typing.cast(click.BaseCommand, httpx.main)`. Which is unfortunate.\r\n\r\nI can see if we can't trick mypy by using a `TYPE_CHECKING` block that does the private import and leave the test using the normal, public import.",
      "comment_id": 1035964401,
      "user": "mjpieters",
      "created_at": "2022-11-30T13:23:57Z",
      "url": "https://github.com/encode/httpx/pull/2479#discussion_r1035964401"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2479,
      "file_path": "tests/test_main.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,29 +1,31 @@\n import os\n+import typing\n \n from click.testing import CliRunner\n \n import httpx\n+from httpx._main import main",
      "comment": "> Without this, mypy sees the def main() fallback defined in httpx/__init__.py, which is decidedly not a click.BaseCommand or subclass, so all the calls to httpx.main() then need a typing.cast(click.BaseCommand, httpx.main). Which is unfortunate.\r\n\r\nAh, gotcha. You're referring to this...\r\n\r\nhttps://github.com/encode/httpx/blob/57aa5b08a48c82a6e1a1500e131d94a31128b6f9/httpx/__init__.py#L47-L59\r\n\r\nIt looks to me like we should type the arguments on that.\r\n\r\n```python\r\ndef main(*args: str) -> None:\r\n    ...\r\n```\r\n\r\nWould that resolve the issue?",
      "comment_id": 1035970727,
      "user": "lovelydinosaur",
      "created_at": "2022-11-30T13:29:32Z",
      "url": "https://github.com/encode/httpx/pull/2479#discussion_r1035970727"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2479,
      "file_path": "tests/test_main.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,29 +1,31 @@\n import os\n+import typing\n \n from click.testing import CliRunner\n \n import httpx\n+from httpx._main import main",
      "comment": "Oh right, no it wouldn't.\r\n\r\nHrm. Perhaps we can put it inside a conditional `if not TYPE_CHECKING` block?",
      "comment_id": 1035976094,
      "user": "lovelydinosaur",
      "created_at": "2022-11-30T13:34:29Z",
      "url": "https://github.com/encode/httpx/pull/2479#discussion_r1035976094"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2479,
      "file_path": "tests/test_main.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,29 +1,31 @@\n import os\n+import typing\n \n from click.testing import CliRunner\n \n import httpx\n+from httpx._main import main",
      "comment": "Or else we just suck up the gnarly private import for now.\r\n\r\nPerhaps that's okay.",
      "comment_id": 1035977544,
      "user": "lovelydinosaur",
      "created_at": "2022-11-30T13:35:51Z",
      "url": "https://github.com/encode/httpx/pull/2479#discussion_r1035977544"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2479,
      "file_path": "tests/test_main.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,29 +1,31 @@\n import os\n+import typing\n \n from click.testing import CliRunner\n \n import httpx\n+from httpx._main import main",
      "comment": "I've put the import into a TYPE_CHECKING guard with a comment. The test is against the public import. This feels marginally better. Whadayathink?",
      "comment_id": 1036013153,
      "user": "mjpieters",
      "created_at": "2022-11-30T14:07:12Z",
      "url": "https://github.com/encode/httpx/pull/2479#discussion_r1036013153"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2479,
      "file_path": "tests/test_main.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,29 +1,35 @@\n import os\n+import typing\n \n from click.testing import CliRunner\n \n import httpx\n+from httpx import main\n \n+if typing.TYPE_CHECKING:  # pragma: no cover\n+    # don't let mypy be misled by the fallback defined in httpx/__init__.py\n+    from httpx._main import main  # noqa: F811",
      "comment": "I like what you've done here - we've got other cases where the `TYPE_CHECKING` imports from private namespaces, so I think this is okay.",
      "comment_id": 1036041371,
      "user": "lovelydinosaur",
      "created_at": "2022-11-30T14:29:58Z",
      "url": "https://github.com/encode/httpx/pull/2479#discussion_r1036041371"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2475,
      "file_path": "httpx/_models.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,7 +41,7 @@\n     ResponseExtensions,\n     SyncByteStream,\n )\n-from ._urls import URL\n+from ._urls import URL as URL",
      "comment": "I'm curious why `mypy` requires us to do this weird dance here.\r\nMaybe we don't care why, and we just do it anyway?\r\nOr?",
      "comment_id": 1035688365,
      "user": "lovelydinosaur",
      "created_at": "2022-11-30T08:52:35Z",
      "url": "https://github.com/encode/httpx/pull/2475#discussion_r1035688365"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2475,
      "file_path": "httpx/_models.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,7 +41,7 @@\n     ResponseExtensions,\n     SyncByteStream,\n )\n-from ._urls import URL\n+from ._urls import URL as URL",
      "comment": "Ah gotcha.\r\n\r\nWe're importing `URL` from the wrong place, once in `_config.py` and twice in `_utils.py`. Let's fix those instead of making this change here...\r\n\r\n```diff\r\n--- a/httpx/_config.py\r\n+++ b/httpx/_config.py\r\n@@ -6,8 +6,9 @@ from pathlib import Path\r\n import certifi\r\n \r\n from ._compat import set_minimum_tls_version_1_2\r\n-from ._models import URL, Headers\r\n+from ._models import Headers\r\n from ._types import CertTypes, HeaderTypes, TimeoutTypes, URLTypes, VerifyTypes\r\n+from ._urls import URL\r\n from ._utils import get_ca_bundle_from_env, get_logger\r\n \r\n DEFAULT_CIPHERS = \":\".join(\r\n```\r\n\r\nAnd...\r\n\r\n```diff\r\n--- a/httpx/_utils.py\r\n+++ b/httpx/_utils.py\r\n@@ -16,7 +16,7 @@ import sniffio\r\n from ._types import PrimitiveData\r\n \r\n if typing.TYPE_CHECKING:  # pragma: no cover\r\n-    from ._models import URL\r\n+    from ._urls import URL\r\n \r\n \r\n _HTML5_FORM_ENCODING_REPLACEMENTS = {'\"': \"%22\", \"\\\\\": \"\\\\\\\\\"}\r\n@@ -465,7 +465,7 @@ class URLPattern:\r\n     \"\"\"\r\n \r\n     def __init__(self, pattern: str) -> None:\r\n-        from ._models import URL\r\n+        from ._urls import URL\r\n \r\n         if pattern and \":\" not in pattern:\r\n             raise ValueError(\r\n```",
      "comment_id": 1035698791,
      "user": "lovelydinosaur",
      "created_at": "2022-11-30T09:02:26Z",
      "url": "https://github.com/encode/httpx/pull/2475#discussion_r1035698791"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2467,
      "file_path": "httpx/_transports/wsgi.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,14 +1,38 @@\n import io\n import itertools\n import sys\n+import types\n import typing\n \n+import typing_extensions as te",
      "comment": "I can't see where this is coming from in the `requirements.txt`... is this built-in or a package?\r\n\r\nAlso, can we just `import typing_extensions` rather than `import typing_extensions as te`?\r\n",
      "comment_id": 1035060751,
      "user": "lovelydinosaur",
      "created_at": "2022-11-29T17:34:39Z",
      "url": "https://github.com/encode/httpx/pull/2467#discussion_r1035060751"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2467,
      "file_path": "httpx/_transports/wsgi.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,14 +1,38 @@\n import io\n import itertools\n import sys\n+import types\n import typing\n \n+import typing_extensions as te",
      "comment": "I changed the Protocol to `Callable` and removed the import. The protocol _is_ more correct, it seems like `exc_info` must have a default value which you can't describe with `Callable.` That said, I don't know if this will cause real world issues with WSGI frameworks or not, I think it would depend on how strict their typing is, I'm going to check and report back.",
      "comment_id": 1035086504,
      "user": "adriangb",
      "created_at": "2022-11-29T17:57:49Z",
      "url": "https://github.com/encode/httpx/pull/2467#discussion_r1035086504"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2467,
      "file_path": "httpx/_transports/wsgi.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,14 +1,31 @@\n import io\n import itertools\n import sys\n+import types\n import typing\n \n from .._models import Request, Response\n from .._types import SyncByteStream\n from .base import BaseTransport\n \n+_T = typing.TypeVar(\"_T\")\n+_ExcInfo = typing.Tuple[typing.Type[BaseException], BaseException, types.TracebackType]\n+_OptExcInfo = typing.Union[_ExcInfo, typing.Tuple[None, None, None]]\n \n-def _skip_leading_empty_chunks(body: typing.Iterable[bytes]) -> typing.Iterable[bytes]:\n+\n+# backported wsgiref.types definitions from Python 3.11\n+StartResponse = typing.Callable[\n+    [str, typing.List[typing.Tuple[str, str]], typing.Optional[_OptExcInfo]],\n+    typing.Callable[[bytes], object],\n+]\n+\n+\n+WSGIApplication = typing.Callable[\n+    [typing.Dict[str, typing.Any], StartResponse], typing.Iterable[bytes]\n+]",
      "comment": "Hmm shouldn't we just import these directly from typeshed instead?\r\nE.g.\r\n```python\r\nif typing.TYPE_CHECKING:\r\n    from _typeshed import OptExcInfo\r\n    from _typeshed.wsgi import WSGIApplication\r\n```",
      "comment_id": 1035198510,
      "user": "michaeloliverx",
      "created_at": "2022-11-29T19:34:34Z",
      "url": "https://github.com/encode/httpx/pull/2467#discussion_r1035198510"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2467,
      "file_path": "httpx/_transports/wsgi.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,14 +1,31 @@\n import io\n import itertools\n import sys\n+import types\n import typing\n \n from .._models import Request, Response\n from .._types import SyncByteStream\n from .base import BaseTransport\n \n+_T = typing.TypeVar(\"_T\")\n+_ExcInfo = typing.Tuple[typing.Type[BaseException], BaseException, types.TracebackType]\n+_OptExcInfo = typing.Union[_ExcInfo, typing.Tuple[None, None, None]]\n \n-def _skip_leading_empty_chunks(body: typing.Iterable[bytes]) -> typing.Iterable[bytes]:\n+\n+# backported wsgiref.types definitions from Python 3.11\n+StartResponse = typing.Callable[\n+    [str, typing.List[typing.Tuple[str, str]], typing.Optional[_OptExcInfo]],\n+    typing.Callable[[bytes], object],\n+]\n+\n+\n+WSGIApplication = typing.Callable[\n+    [typing.Dict[str, typing.Any], StartResponse], typing.Iterable[bytes]\n+]",
      "comment": "Probably. With an `else: WSGIApplication = Any` or something. Maybe make a PR?",
      "comment_id": 1035214197,
      "user": "adriangb",
      "created_at": "2022-11-29T19:52:07Z",
      "url": "https://github.com/encode/httpx/pull/2467#discussion_r1035214197"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2463,
      "file_path": "tests/client/test_auth.py",
      "line": 533,
      "side": "RIGHT",
      "diff_hunk": "@@ -527,6 +527,47 @@ async def test_digest_auth_incorrect_credentials() -> None:\n     assert len(response.history) == 1\n \n \n+@pytest.mark.asyncio\n+async def test_digest_auth_reuses_challenge() -> None:\n+    url = \"https://example.org/\"\n+    auth = DigestAuth(username=\"tomchristie\", password=\"password123\")",
      "comment": "```suggestion\r\n    auth = DigestAuth(username=\"user\", password=\"password123\")\r\n```",
      "comment_id": 1032516837,
      "user": "lovelydinosaur",
      "created_at": "2022-11-25T14:41:50Z",
      "url": "https://github.com/encode/httpx/pull/2463#discussion_r1032516837"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2463,
      "file_path": "tests/client/test_auth.py",
      "line": 550,
      "side": "RIGHT",
      "diff_hunk": "@@ -527,6 +527,47 @@ async def test_digest_auth_incorrect_credentials() -> None:\n     assert len(response.history) == 1\n \n \n+@pytest.mark.asyncio\n+async def test_digest_auth_reuses_challenge() -> None:\n+    url = \"https://example.org/\"\n+    auth = DigestAuth(username=\"tomchristie\", password=\"password123\")\n+    app = DigestApp()\n+\n+    async with httpx.AsyncClient(transport=httpx.MockTransport(app)) as client:\n+        response_1 = await client.get(url, auth=auth)\n+        response_2 = await client.get(url, auth=auth)\n+\n+        assert response_1.status_code == 200\n+        assert response_2.status_code == 200\n+\n+        assert len(response_1.history) == 1\n+        assert len(response_2.history) == 0\n+\n+\n+@pytest.mark.asyncio\n+async def test_digest_auth_resets_nonce_count_after_401() -> None:\n+    url = \"https://example.org/\"\n+    auth = DigestAuth(username=\"tomchristie\", password=\"password123\")",
      "comment": "```suggestion\r\n    auth = DigestAuth(username=\"user\", password=\"password123\")\r\n```",
      "comment_id": 1032517268,
      "user": "lovelydinosaur",
      "created_at": "2022-11-25T14:42:25Z",
      "url": "https://github.com/encode/httpx/pull/2463#discussion_r1032517268"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2463,
      "file_path": "tests/client/test_auth.py",
      "line": 560,
      "side": "RIGHT",
      "diff_hunk": "@@ -527,6 +527,47 @@ async def test_digest_auth_incorrect_credentials() -> None:\n     assert len(response.history) == 1\n \n \n+@pytest.mark.asyncio\n+async def test_digest_auth_reuses_challenge() -> None:\n+    url = \"https://example.org/\"\n+    auth = DigestAuth(username=\"tomchristie\", password=\"password123\")\n+    app = DigestApp()\n+\n+    async with httpx.AsyncClient(transport=httpx.MockTransport(app)) as client:\n+        response_1 = await client.get(url, auth=auth)\n+        response_2 = await client.get(url, auth=auth)\n+\n+        assert response_1.status_code == 200\n+        assert response_2.status_code == 200\n+\n+        assert len(response_1.history) == 1\n+        assert len(response_2.history) == 0\n+\n+\n+@pytest.mark.asyncio\n+async def test_digest_auth_resets_nonce_count_after_401() -> None:\n+    url = \"https://example.org/\"\n+    auth = DigestAuth(username=\"tomchristie\", password=\"password123\")\n+    app = DigestApp()\n+\n+    async with httpx.AsyncClient(transport=httpx.MockTransport(app)) as client:\n+        response_1 = await client.get(url, auth=auth)\n+        assert response_1.status_code == 200\n+        assert len(response_1.history) == 1\n+        first_nonce = response_1.json()[\"auth\"].split(\"nonce=\")[1].split(\",\")[0]\n+        first_nc = response_1.json()[\"auth\"].split(\"nc=\")[1].split(\",\")[0]\n+\n+        app.send_response_after_attempt = 2",
      "comment": "This is a bit obscure to me, I think this line deserves a comment.\r\n",
      "comment_id": 1032528869,
      "user": "lovelydinosaur",
      "created_at": "2022-11-25T14:56:55Z",
      "url": "https://github.com/encode/httpx/pull/2463#discussion_r1032528869"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2463,
      "file_path": "tests/client/test_auth.py",
      "line": 560,
      "side": "RIGHT",
      "diff_hunk": "@@ -527,6 +527,47 @@ async def test_digest_auth_incorrect_credentials() -> None:\n     assert len(response.history) == 1\n \n \n+@pytest.mark.asyncio\n+async def test_digest_auth_reuses_challenge() -> None:\n+    url = \"https://example.org/\"\n+    auth = DigestAuth(username=\"tomchristie\", password=\"password123\")\n+    app = DigestApp()\n+\n+    async with httpx.AsyncClient(transport=httpx.MockTransport(app)) as client:\n+        response_1 = await client.get(url, auth=auth)\n+        response_2 = await client.get(url, auth=auth)\n+\n+        assert response_1.status_code == 200\n+        assert response_2.status_code == 200\n+\n+        assert len(response_1.history) == 1\n+        assert len(response_2.history) == 0\n+\n+\n+@pytest.mark.asyncio\n+async def test_digest_auth_resets_nonce_count_after_401() -> None:\n+    url = \"https://example.org/\"\n+    auth = DigestAuth(username=\"tomchristie\", password=\"password123\")\n+    app = DigestApp()\n+\n+    async with httpx.AsyncClient(transport=httpx.MockTransport(app)) as client:\n+        response_1 = await client.get(url, auth=auth)\n+        assert response_1.status_code == 200\n+        assert len(response_1.history) == 1\n+        first_nonce = response_1.json()[\"auth\"].split(\"nonce=\")[1].split(\",\")[0]\n+        first_nc = response_1.json()[\"auth\"].split(\"nc=\")[1].split(\",\")[0]\n+\n+        app.send_response_after_attempt = 2",
      "comment": "added some explanation for the assertions / send_response_after",
      "comment_id": 1032997333,
      "user": "rettier",
      "created_at": "2022-11-27T19:24:31Z",
      "url": "https://github.com/encode/httpx/pull/2463#discussion_r1032997333"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2309,
      "file_path": "httpx/_utils.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,6 +210,17 @@ def parse_header_links(value: str) -> typing.List[typing.Dict[str, str]]:\n     return links\n \n \n+def parse_content_type_charset(content_type: str) -> typing.Optional[str]:\n+    # We used to use `cgi.parse_header()` here, but `cgi` became a dead battery.\n+    # See: https://peps.python.org/pep-0594/#cgi\n+    msg = email.message.Message()\n+    msg[\"content-type\"] = content_type\n+    charset = msg.get_param(\"charset\")\n+    if charset is None:\n+        return None\n+    return str(charset).strip(\"'\\\"\")",
      "comment": "does `str` call not seem redundant? given failobj (default to None) is returned in the absence of a param. If param is present, either a string or a 3-tuple. Is the latter a possibility?",
      "comment_id": 950720909,
      "user": "oyeyipo",
      "created_at": "2022-08-20T17:33:21Z",
      "url": "https://github.com/encode/httpx/pull/2309#discussion_r950720909"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2309,
      "file_path": "httpx/_utils.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,6 +210,17 @@ def parse_header_links(value: str) -> typing.List[typing.Dict[str, str]]:\n     return links\n \n \n+def parse_content_type_charset(content_type: str) -> typing.Optional[str]:\n+    # We used to use `cgi.parse_header()` here, but `cgi` became a dead battery.\n+    # See: https://peps.python.org/pep-0594/#cgi\n+    msg = email.message.Message()\n+    msg[\"content-type\"] = content_type\n+    charset = msg.get_param(\"charset\")\n+    if charset is None:\n+        return None\n+    return str(charset).strip(\"'\\\"\")",
      "comment": "True, not sure why I used `str()` here. Also, I think we want `get_content_charset()`, which does an equivalent of `email.utils.collapse_rfc2231_value(msg.get_param(\"charset\"))`, which is what the [get_param() docs](https://docs.python.org/3/library/email.compat32-message.html#email.message.Message.get_param) recommend to deal with this \"string or 3-tuple\" oddity.",
      "comment_id": 954774357,
      "user": "florimondmanca",
      "created_at": "2022-08-25T10:06:10Z",
      "url": "https://github.com/encode/httpx/pull/2309#discussion_r954774357"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2309,
      "file_path": "httpx/_utils.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,6 +210,17 @@ def parse_header_links(value: str) -> typing.List[typing.Dict[str, str]]:\n     return links\n \n \n+def parse_content_type_charset(content_type: str) -> typing.Optional[str]:\n+    # We used to use `cgi.parse_header()` here, but `cgi` became a dead battery.\n+    # See: https://peps.python.org/pep-0594/#cgi\n+    msg = email.message.Message()\n+    msg[\"content-type\"] = content_type\n+    charset = msg.get_param(\"charset\")\n+    if charset is None:\n+        return None\n+    return str(charset).strip(\"'\\\"\")",
      "comment": "```suggestion\r\n    return msg.get_content_charset(failobj=None)\r\n```",
      "comment_id": 954775637,
      "user": "florimondmanca",
      "created_at": "2022-08-25T10:07:33Z",
      "url": "https://github.com/encode/httpx/pull/2309#discussion_r954775637"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2407,
      "file_path": "tests/test_content.py",
      "line": 17,
      "side": "LEFT",
      "diff_hunk": "@@ -13,8 +13,8 @@ async def test_empty_content():\n     assert isinstance(stream, httpx.SyncByteStream)\n     assert isinstance(stream, httpx.AsyncByteStream)\n \n-    sync_content = stream.read()\n-    async_content = await stream.aread()",
      "comment": "We're matching the style of the other test cases now.\r\nThese `.read()`/`.aread()` operations were only added to this test case so that we'd have coverage of those code lines.",
      "comment_id": 994626502,
      "user": "lovelydinosaur",
      "created_at": "2022-10-13T13:12:06Z",
      "url": "https://github.com/encode/httpx/pull/2407#discussion_r994626502"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2407,
      "file_path": "httpx/_content.py",
      "line": 57,
      "side": "LEFT",
      "diff_hunk": "@@ -52,9 +52,7 @@ def __iter__(self) -> Iterator[bytes]:\n             raise StreamConsumed()\n \n         self._is_stream_consumed = True\n-        if hasattr(self._stream, \"read\") and not isinstance(\n-            self._stream, SyncByteStream\n-        ):",
      "comment": "The `and not isinstance(self._stream, SyncByteStream)` is what prompted me to clean these up.\r\n\r\nIt's such an oddly confusing branch - I couldn't figure out why it existed.\r\n\r\n*\"Treat file-like objects as file-like objects, except for this one specific case\"*.\r\n\r\nNo thanks.",
      "comment_id": 994631467,
      "user": "lovelydinosaur",
      "created_at": "2022-10-13T13:16:09Z",
      "url": "https://github.com/encode/httpx/pull/2407#discussion_r994631467"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2407,
      "file_path": "httpx/_types.py",
      "line": 120,
      "side": "LEFT",
      "diff_hunk": "@@ -107,33 +107,7 @@ def close(self) -> None:\n         \"\"\"\n         Subclasses can override this method to release any network resources\n         after a request/response cycle is complete.\n-\n-        Streaming cases should use a `try...finally` block to ensure that\n-        the stream `close()` method is always called.\n-\n-        Example:\n-\n-            status_code, headers, stream, extensions = transport.handle_request(...)\n-            try:\n-                ...\n-            finally:\n-                stream.close()",
      "comment": "This is an example from the old-style Transport API.\r\n\r\nWe had `.read()` so that users could eg. `stream.read()` here.\r\n\r\nThe Transport API now just returns fully fledged responses, so this is redundant.",
      "comment_id": 994633162,
      "user": "lovelydinosaur",
      "created_at": "2022-10-13T13:17:36Z",
      "url": "https://github.com/encode/httpx/pull/2407#discussion_r994633162"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2266,
      "file_path": "httpx/_client.py",
      "line": 1366,
      "side": "RIGHT",
      "diff_hunk": "@@ -1360,11 +1363,11 @@ def __init__(\n         limits: Limits = DEFAULT_LIMITS,\n         max_redirects: int = DEFAULT_MAX_REDIRECTS,\n         event_hooks: typing.Optional[\n-            typing.Mapping[str, typing.List[typing.Callable]]\n+            typing.Mapping[str, typing.List[typing.Callable[..., typing.Any]]]",
      "comment": "```suggestion\r\n            typing.Mapping[str, typing.List[EventHook]]\r\n```",
      "comment_id": 992859839,
      "user": "adriangb",
      "created_at": "2022-10-11T23:40:31Z",
      "url": "https://github.com/encode/httpx/pull/2266#discussion_r992859839"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2351,
      "file_path": "setup.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import sys\n+\n+from setuptools import setup",
      "comment": "I guess technically this import isn't required since it can never be used.",
      "comment_id": 958385038,
      "user": "samuelcolvin",
      "created_at": "2022-08-30T11:56:19Z",
      "url": "https://github.com/encode/httpx/pull/2351#discussion_r958385038"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2351,
      "file_path": "setup.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,29 @@\n+import sys",
      "comment": "```suggestion\r\nimport sys\r\n\r\nfrom setuptools import setup\r\n```",
      "comment_id": 959183720,
      "user": "Kludex",
      "created_at": "2022-08-31T05:51:38Z",
      "url": "https://github.com/encode/httpx/pull/2351#discussion_r959183720"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1943,
      "file_path": "httpx/_utils.py",
      "line": 471,
      "side": "RIGHT",
      "diff_hunk": "@@ -457,19 +457,18 @@ def __init__(self, pattern: str) -> None:\n         self.port = url.port\n         if not url.host or url.host == \"*\":\n             self.host_regex: typing.Optional[typing.Pattern[str]] = None\n+        elif url.host.startswith(\"*.\"):\n+            # *.example.com should match \"www.example.com\", but not \"example.com\"\n+            domain = re.escape(url.host[2:])\n+            self.host_regex = re.compile(f\"^.+\\\\.{domain}$\")\n+        elif url.host.startswith(\"*\"):\n+            # *example.com should match \"www.example.com\" and \"example.com\"\n+            domain = re.escape(url.host[1:])\n+            self.host_regex = re.compile(f\"^(.+\\\\.)?{domain}$\")\n         else:\n-            if url.host.startswith(\"*.\"):\n-                # *.example.com should match \"www.example.com\", but not \"example.com\"\n-                domain = re.escape(url.host[2:])\n-                self.host_regex = re.compile(f\"^.+\\\\.{domain}$\")\n-            elif url.host.startswith(\"*\"):\n-                # *example.com should match \"www.example.com\" and \"example.com\"\n-                domain = re.escape(url.host[1:])\n-                self.host_regex = re.compile(f\"^(.+\\\\.)?{domain}$\")\n-            else:\n-                # example.com should match \"example.com\" but not \"www.example.com\"\n-                domain = re.escape(url.host)\n-                self.host_regex = re.compile(f\"^{domain}$\")\n+            # example.com should match \"example.com\" but not \"www.example.com\"\n+            domain = re.escape(url.host)\n+            self.host_regex = re.compile(f\"^{domain}$\")",
      "comment": "I like the refactoring you've done on this block, yup. I think it makes enough of a readability difference that it's worth having in.",
      "comment_id": 754255175,
      "user": "lovelydinosaur",
      "created_at": "2021-11-22T13:03:01Z",
      "url": "https://github.com/encode/httpx/pull/1943#discussion_r754255175"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1943,
      "file_path": "httpx/_utils.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -120,7 +120,7 @@ def guess_json_utf(data: bytes) -> typing.Optional[str]:\n         if sample[1::2] == _null2:  # 2nd and 4th are null\n             return \"utf-16-le\"\n         # Did not detect 2 valid UTF-16 ascii-range characters\n-    if nullcount == 3:\n+    elif nullcount == 3:",
      "comment": "Either we should update all the cases here that could be `elif`, or none of them.\r\nWe're not really getting any value from the change, so I'd suggest we just leave it.\r\n\r\n```suggestion\r\n    if nullcount == 3:\r\n```",
      "comment_id": 754257899,
      "user": "lovelydinosaur",
      "created_at": "2021-11-22T13:06:07Z",
      "url": "https://github.com/encode/httpx/pull/1943#discussion_r754257899"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1943,
      "file_path": "httpx/_utils.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,7 +23,7 @@\n     {chr(c): \"%{:02X}\".format(c) for c in range(0x1F + 1) if c != 0x1B}\n )\n _HTML5_FORM_ENCODING_RE = re.compile(\n-    r\"|\".join([re.escape(c) for c in _HTML5_FORM_ENCODING_REPLACEMENTS.keys()])\n+    r\"|\".join([re.escape(c) for c in _HTML5_FORM_ENCODING_REPLACEMENTS])",
      "comment": "I could go either way on this one. Possibly it's more obvious with `.keys()` what the effect is. Possibly not. But, okay, sure.",
      "comment_id": 754259285,
      "user": "lovelydinosaur",
      "created_at": "2021-11-22T13:07:37Z",
      "url": "https://github.com/encode/httpx/pull/1943#discussion_r754259285"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1943,
      "file_path": "httpx/_utils.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,7 +23,7 @@\n     {chr(c): \"%{:02X}\".format(c) for c in range(0x1F + 1) if c != 0x1B}\n )\n _HTML5_FORM_ENCODING_RE = re.compile(\n-    r\"|\".join([re.escape(c) for c in _HTML5_FORM_ENCODING_REPLACEMENTS.keys()])\n+    r\"|\".join([re.escape(c) for c in _HTML5_FORM_ENCODING_REPLACEMENTS])",
      "comment": "```suggestion\r\n    r\"|\".join([re.escape(c) for c in _HTML5_FORM_ENCODING_REPLACEMENTS.keys()])\r\n```",
      "comment_id": 802583896,
      "user": "lovelydinosaur",
      "created_at": "2022-02-09T11:55:24Z",
      "url": "https://github.com/encode/httpx/pull/1943#discussion_r802583896"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2074,
      "file_path": "httpx/_client.py",
      "line": 539,
      "side": "RIGHT",
      "diff_hunk": "@@ -532,9 +533,11 @@ def _redirect_headers(self, request: Request, url: URL, method: str) -> Headers:\n         headers = Headers(request.headers)\n \n         if not same_origin(url, request.url):\n-            # Strip Authorization headers when responses are redirected away from\n-            # the origin.\n-            headers.pop(\"Authorization\", None)\n+            if not is_https_redirect(request.url, url):\n+                # Strip Authorization headers when responses are redirected\n+                # away from the origin, but keep them if it is a HTTPS\n+                # redirect.",
      "comment": "```suggestion\r\n                # Strip Authorization headers when responses are redirected\r\n                # away from the origin. (Except for direct HTTP to HTTPS redirects.)\r\n```",
      "comment_id": 802548304,
      "user": "lovelydinosaur",
      "created_at": "2022-02-09T11:10:43Z",
      "url": "https://github.com/encode/httpx/pull/2074#discussion_r802548304"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2070,
      "file_path": "httpx/_transports/base.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,63 +23,32 @@ def handle_request(self, request: Request) -> Response:\n         \"\"\"\n         Send a single HTTP request and return a response.\n \n-        At this layer of API we're simply using plain primitives. No `Request` or\n-        `Response` models, no fancy `URL` or `Header` handling. This strict point\n-        of cut-off provides a clear design separation between the HTTPX API,\n-        and the low-level network handling.\n-\n         Developers shouldn't typically ever need to call into this API directly,\n         since the Client class provides all the higher level user-facing API\n         niceties.\n \n-        In order to properly release any network resources, the response stream\n-        should *either* be consumed immediately, with a call to `stream.read()`,\n-        or else the `handle_request` call should be followed with a try/finally\n-        block to ensuring the stream is always closed.\n+        In order to properly release any network resources, the response\n+        stream should *either* be consumed immediately, with a call to \n+        `response.stream.read()`, or else the `handle_request` call should \n+        be followed with a try/finally block to ensuring the stream is \n+        always closed.",
      "comment": "```suggestion\r\n        In order to properly release any network resources, the response\r\n        stream should *either* be consumed immediately, with a call to\r\n        `response.stream.read()`, or else the `handle_request` call should\r\n        be followed with a try/finally block to ensuring the stream is\r\n        always closed.\r\n```",
      "comment_id": 800506029,
      "user": "lovelydinosaur",
      "created_at": "2022-02-07T10:19:25Z",
      "url": "https://github.com/encode/httpx/pull/2070#discussion_r800506029"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 2065,
      "file_path": "httpx/_multipart.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,9 +157,8 @@ def render_data(self) -> typing.Iterator[bytes]:\n             yield self._data\n             return\n \n-        if self._consumed:  # pragma: nocover\n+        if hasattr(self.file, \"seek\"):",
      "comment": "This is more of a question, so we do `seek` for the first file upload too, right?",
      "comment_id": 799455735,
      "user": "aminalaee",
      "created_at": "2022-02-04T13:16:55Z",
      "url": "https://github.com/encode/httpx/pull/2065#discussion_r799455735"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1866,
      "file_path": "httpx/_main.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -173,20 +175,21 @@ def print_response(response: Response) -> None:\n \n def download_response(response: Response, download: typing.BinaryIO) -> None:\n     console = rich.console.Console()\n-    syntax = rich.syntax.Syntax(\"\", \"http\", theme=\"ansi_dark\", word_wrap=True)\n-    console.print(syntax)\n-\n+    console.print()\n     content_length = response.headers.get(\"Content-Length\")\n-    kwargs = {\"total\": int(content_length)} if content_length else {}\n     with rich.progress.Progress(\n         \"[progress.description]{task.description}\",\n         \"[progress.percentage]{task.percentage:>3.0f}%\",\n         rich.progress.BarColumn(bar_width=None),\n         rich.progress.DownloadColumn(),\n         rich.progress.TransferSpeedColumn(),\n     ) as progress:\n-        description = f\"Downloading [bold]{download.name}\"\n-        download_task = progress.add_task(description, **kwargs)  # type: ignore\n+        description = f\"Downloading [bold]{rich.markup.escape(download.name)}\"",
      "comment": "Hi, thanks for this :)\r\n\r\nI _think_ this is the only _relevant_ change in this PR wrt the \"markup leak\" issue, right? By only adding that `rich.markup.escape()` call I was able to prevent eg `--download \"[blink red]file.out\"` from rendering.\r\n\r\nI'm not sure what the effect of the `syntax` and `kwargs` bits are, but they seem non-related, so they should be kept out, sounds legit?",
      "comment_id": 730824506,
      "user": "florimondmanca",
      "created_at": "2021-10-18T11:26:27Z",
      "url": "https://github.com/encode/httpx/pull/1866#discussion_r730824506"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1866,
      "file_path": "httpx/_main.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -173,20 +175,21 @@ def print_response(response: Response) -> None:\n \n def download_response(response: Response, download: typing.BinaryIO) -> None:\n     console = rich.console.Console()\n-    syntax = rich.syntax.Syntax(\"\", \"http\", theme=\"ansi_dark\", word_wrap=True)\n-    console.print(syntax)\n-\n+    console.print()\n     content_length = response.headers.get(\"Content-Length\")\n-    kwargs = {\"total\": int(content_length)} if content_length else {}\n     with rich.progress.Progress(\n         \"[progress.description]{task.description}\",\n         \"[progress.percentage]{task.percentage:>3.0f}%\",\n         rich.progress.BarColumn(bar_width=None),\n         rich.progress.DownloadColumn(),\n         rich.progress.TransferSpeedColumn(),\n     ) as progress:\n-        description = f\"Downloading [bold]{download.name}\"\n-        download_task = progress.add_task(description, **kwargs)  # type: ignore\n+        description = f\"Downloading [bold]{rich.markup.escape(download.name)}\"",
      "comment": "Mainly the markup leak.\r\n\r\nReplacing the kwargs was partly a simplification, but also covers the situation where there is no content length in the header. Consequently Rich will show a \"in progress animation\" rather than remain stuck at 0% until the download was finished.",
      "comment_id": 730858576,
      "user": "willmcgugan",
      "created_at": "2021-10-18T12:13:55Z",
      "url": "https://github.com/encode/httpx/pull/1866#discussion_r730858576"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,39 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n         if isinstance(value, tuple):\n             try:\n-                filename, fileobj, content_type = value  # type: ignore\n+                filename, fileobj, content_type, headers = value  # type: ignore\n             except ValueError:\n-                filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+                try:\n+                    filename, fileobj, content_type = value  # type: ignore\n+                except ValueError:\n+                    filename, fileobj = value  # type: ignore\n+            else:\n+                headers = {k.title(): v for k, v in headers.items()}\n+                if \"Content-Type\" in headers:\n+                    raise ValueError(\n+                        \"Content-Type cannot be included in multipart headers\"\n+                    )",
      "comment": "Perhaps we don't need to do this check.\r\n\r\nIt's *odd* behaviour for the developer to set the `content_type` and then override it with the *actual* value provided in the custom headers. But it's not *broken*.\r\n\r\nMy preference would be that we don't do the explicit check here. In the case of conflicts I'd probably have `header` values take precedence.\r\n\r\nI'm not absolute on this one, but slight preference.",
      "comment_id": 780155315,
      "user": "lovelydinosaur",
      "created_at": "2022-01-07T10:02:11Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r780155315"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,39 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n         if isinstance(value, tuple):\n             try:\n-                filename, fileobj, content_type = value  # type: ignore\n+                filename, fileobj, content_type, headers = value  # type: ignore\n             except ValueError:\n-                filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+                try:\n+                    filename, fileobj, content_type = value  # type: ignore\n+                except ValueError:\n+                    filename, fileobj = value  # type: ignore\n+            else:\n+                headers = {k.title(): v for k, v in headers.items()}\n+                if \"Content-Type\" in headers:\n+                    raise ValueError(\n+                        \"Content-Type cannot be included in multipart headers\"\n+                    )",
      "comment": "Makes sense. I thought it'd be a good idea to check what requests does here. It looks like it silently ignores the header in the `header`. That is:\r\n\r\n```python\r\nrequests.post(\"http://example.com\", files=[(\"test\", (\"test_filename\", b\"data\", \"text/plain\", {\"Content-Type\": \"text/csv\"}))])\r\n```\r\n\r\nGets sent as `text/plain`.\r\n\r\nDigging into _why_ this is the case, it seems like it's just an implementation detail in urllib3. It happens [here](https://github.com/urllib3/urllib3/blob/c58dbbb35a19877a8f367c1eaa99ca43c2148f59/src/urllib3/fields.py#L351).\r\n\r\nI'm not sure what the right thing to do here is, but if you feel like it's best to go with no error and making `header` values take precedence, I'm happy to implement that.\r\n\r\nAnother alternative would be to have the 3rd parameter be either a string representing the content type _or_ a headers dict. We can't really make the 3rd parameter always be a headers dict because that would be a breaking change for httpx.\r\nThis would eliminate the edge case, but deviates from requests' API. It seems pretty reasonable that if I'm specifying headers I'm doing advanced stuff and so specifying the content type in the headers directly would not be an issue.",
      "comment_id": 780401103,
      "user": "adriangb",
      "created_at": "2022-01-07T17:04:26Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r780401103"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,39 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n         if isinstance(value, tuple):\n             try:\n-                filename, fileobj, content_type = value  # type: ignore\n+                filename, fileobj, content_type, headers = value  # type: ignore\n             except ValueError:\n-                filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+                try:\n+                    filename, fileobj, content_type = value  # type: ignore\n+                except ValueError:\n+                    filename, fileobj = value  # type: ignore\n+            else:\n+                headers = {k.title(): v for k, v in headers.items()}\n+                if \"Content-Type\" in headers:\n+                    raise ValueError(\n+                        \"Content-Type cannot be included in multipart headers\"\n+                    )",
      "comment": "> I'm not sure what the right thing to do here is, but if you feel like it's best to go with no error and making header values take precedence, I'm happy to implement that.\r\n\r\nI reckon let's do that, yeah.\r\n\r\n> Another alternative would be to have the 3rd parameter be either a string representing the content type or a headers dict. We can't really make the 3rd parameter always be a headers dict because that would be a breaking change for httpx.\r\n\r\nI actually quite like that yes, neat idea. The big-tuples API is... not helpful really. But let's probably just go with the path of least resistance here. Perhaps one day we'll want an `httpx` 2.0, where we gradually start deprecating the various big-tuples bits of API in favour of a neater style.",
      "comment_id": 781051219,
      "user": "lovelydinosaur",
      "created_at": "2022-01-10T10:17:35Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r781051219"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,39 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n         if isinstance(value, tuple):\n             try:\n-                filename, fileobj, content_type = value  # type: ignore\n+                filename, fileobj, content_type, headers = value  # type: ignore\n             except ValueError:\n-                filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+                try:\n+                    filename, fileobj, content_type = value  # type: ignore\n+                except ValueError:\n+                    filename, fileobj = value  # type: ignore\n+            else:\n+                headers = {k.title(): v for k, v in headers.items()}\n+                if \"Content-Type\" in headers:\n+                    raise ValueError(\n+                        \"Content-Type cannot be included in multipart headers\"\n+                    )",
      "comment": "> I reckon let's do that, yeah.\r\n\r\n\ud83d\udc4d donzo\r\n\r\n> > Another alternative would be to have the 3rd parameter be either a string representing the content type or a headers dict. We can't really make the 3rd parameter always be a headers dict because that would be a breaking change for httpx.\r\n> \r\n> I actually quite like that yes, neat idea. The big-tuples API is... not helpful really. But let's probably just go with the path of least resistance here. Perhaps one day we'll want an `httpx` 2.0, where we gradually start deprecating the various big-tuples bits of API in favour of a neater style.\r\n\r\nAgreed! I added a comment in the code explaining the reasoning behind the big tuple API (inherited from requests) and how we might want to change it in the future.\r\n",
      "comment_id": 781355791,
      "user": "adriangb",
      "created_at": "2022-01-10T16:35:23Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r781355791"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,44 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n+        # This large tuple based API largely mirror's requests' API\n+        # It would be good to think of better APIs for this that we could include in httpx 2.0\n+        # since variable length tuples (especially of 4 elements) are quite unwieldly\n         if isinstance(value, tuple):\n             try:\n-                filename, fileobj, content_type = value  # type: ignore\n+                filename, fileobj, content_type, headers = value  # type: ignore\n             except ValueError:\n-                filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+                # 4th parameter (headers) not included\n+                try:\n+                    filename, fileobj, content_type = value  # type: ignore\n+                except ValueError:\n+                    # neither the 3rd parameter (content_type) nor the 4th (headers) was included\n+                    filename, fileobj = value  # type: ignore",
      "comment": "An alternative would be...\r\n\r\n```python\r\n# Unpack filename, fileobj, and optionally content_type and headers.\r\nfilename, fileobj, content_type, headers, *_ = value + (None, None)\r\n```\r\n\r\nNot sure if the more concise version is better or worse here.\r\n\r\nOr we could do explicitly length-based...\r\n\r\n```python\r\nif len(value) == 2:\r\n    filename, fileobj = value\r\nelif len(value) == 3:\r\n    filename, fileobj, content_type = value\r\nelse:\r\n    filename, fileobj, content_type, headers = value\r\n```\r\n\r\nLooking at it now, I think the length based version is probably neatest, since it's just very clear and obvious. Marginally nicer than the various indents that try..catch requires.",
      "comment_id": 782019673,
      "user": "lovelydinosaur",
      "created_at": "2022-01-11T10:39:28Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r782019673"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,44 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n+        # This large tuple based API largely mirror's requests' API\n+        # It would be good to think of better APIs for this that we could include in httpx 2.0\n+        # since variable length tuples (especially of 4 elements) are quite unwieldly\n         if isinstance(value, tuple):\n             try:\n-                filename, fileobj, content_type = value  # type: ignore\n+                filename, fileobj, content_type, headers = value  # type: ignore\n             except ValueError:\n-                filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+                # 4th parameter (headers) not included\n+                try:\n+                    filename, fileobj, content_type = value  # type: ignore\n+                except ValueError:\n+                    # neither the 3rd parameter (content_type) nor the 4th (headers) was included\n+                    filename, fileobj = value  # type: ignore\n+            else:\n+                # corresponds to (filename, fileobj, content_type, headers)\n+                headers = {k.title(): v for k, v in headers.items()}\n         else:\n             filename = Path(str(getattr(value, \"name\", \"upload\"))).name\n             fileobj = value\n+\n+        if content_type is None:\n             content_type = guess_content_type(filename)\n \n+        if content_type is not None and \"Content-Type\" not in headers:\n+            # note that unlike requests, we ignore the content_type\n+            # provided in the 3rd tuple element if it is also included in the headers\n+            # requests does the opposite",
      "comment": "Okay maybe we should instead do it the other way. If the 4-tuple is used, just ignore the `content_type` variable. That'd be okay enough, matches `requests` more closely, and we can forget about fiddly case-based header checking.",
      "comment_id": 782024045,
      "user": "lovelydinosaur",
      "created_at": "2022-01-11T10:44:56Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r782024045"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,44 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n+        # This large tuple based API largely mirror's requests' API\n+        # It would be good to think of better APIs for this that we could include in httpx 2.0\n+        # since variable length tuples (especially of 4 elements) are quite unwieldly\n         if isinstance(value, tuple):\n             try:\n-                filename, fileobj, content_type = value  # type: ignore\n+                filename, fileobj, content_type, headers = value  # type: ignore\n             except ValueError:\n-                filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+                # 4th parameter (headers) not included\n+                try:\n+                    filename, fileobj, content_type = value  # type: ignore\n+                except ValueError:\n+                    # neither the 3rd parameter (content_type) nor the 4th (headers) was included\n+                    filename, fileobj = value  # type: ignore",
      "comment": "Yep yep. I guess I just took what was there and extended it. Obviously it doesn't scale, I like matching on the length more.",
      "comment_id": 782405660,
      "user": "adriangb",
      "created_at": "2022-01-11T18:05:11Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r782405660"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,44 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n+        # This large tuple based API largely mirror's requests' API\n+        # It would be good to think of better APIs for this that we could include in httpx 2.0\n+        # since variable length tuples (especially of 4 elements) are quite unwieldly\n         if isinstance(value, tuple):\n             try:\n-                filename, fileobj, content_type = value  # type: ignore\n+                filename, fileobj, content_type, headers = value  # type: ignore\n             except ValueError:\n-                filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+                # 4th parameter (headers) not included\n+                try:\n+                    filename, fileobj, content_type = value  # type: ignore\n+                except ValueError:\n+                    # neither the 3rd parameter (content_type) nor the 4th (headers) was included\n+                    filename, fileobj = value  # type: ignore\n+            else:\n+                # corresponds to (filename, fileobj, content_type, headers)\n+                headers = {k.title(): v for k, v in headers.items()}\n         else:\n             filename = Path(str(getattr(value, \"name\", \"upload\"))).name\n             fileobj = value\n+\n+        if content_type is None:\n             content_type = guess_content_type(filename)\n \n+        if content_type is not None and \"Content-Type\" not in headers:\n+            # note that unlike requests, we ignore the content_type\n+            # provided in the 3rd tuple element if it is also included in the headers\n+            # requests does the opposite",
      "comment": "requests does the opposite: it ignores the header in the 4th tuple element. so we'll still need the case-based header checking if we want to do exactly what requests does. either way, we need to know if the content type header exists in the 4th element tuple so we can either ignore the 3rd element or overwrite it with the 3rd element.",
      "comment_id": 782406811,
      "user": "adriangb",
      "created_at": "2022-01-11T18:06:56Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r782406811"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,41 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n+        # This large tuple based API largely mirror's requests' API\n+        # It would be good to think of better APIs for this that we could include in httpx 2.0\n+        # since variable length tuples (especially of 4 elements) are quite unwieldly\n         if isinstance(value, tuple):\n-            try:\n-                filename, fileobj, content_type = value  # type: ignore\n-            except ValueError:\n+            if len(value) == 2:\n+                # neither the 3rd parameter (content_type) nor the 4th (headers) was included\n                 filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+            elif len(value) == 3:\n+                filename, fileobj, content_type = value  # type: ignore\n+            else:\n+                # all 4 parameters included\n+                filename, fileobj, content_type, headers = value  # type: ignore\n+                headers = {k.title(): v for k, v in headers.items()}\n         else:\n             filename = Path(str(getattr(value, \"name\", \"upload\"))).name\n             fileobj = value\n+\n+        if content_type is None:\n             content_type = guess_content_type(filename)\n \n+        if content_type is not None and \"Content-Type\" not in headers:",
      "comment": "Perhaps...\r\n\r\n```python\r\nhas_content_type_header = any([\"content-type\" in key.lower() for key in headers])\r\nif content_type is not None and not has_content_type_header:\r\n    ...\r\n```\r\n\r\n?",
      "comment_id": 782946496,
      "user": "lovelydinosaur",
      "created_at": "2022-01-12T10:49:52Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r782946496"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1936,
      "file_path": "httpx/_multipart.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +78,41 @@ def __init__(self, name: str, value: FileTypes) -> None:\n \n         fileobj: FileContent\n \n+        headers: typing.Dict[str, str] = {}\n+        content_type: typing.Optional[str] = None\n+\n+        # This large tuple based API largely mirror's requests' API\n+        # It would be good to think of better APIs for this that we could include in httpx 2.0\n+        # since variable length tuples (especially of 4 elements) are quite unwieldly\n         if isinstance(value, tuple):\n-            try:\n-                filename, fileobj, content_type = value  # type: ignore\n-            except ValueError:\n+            if len(value) == 2:\n+                # neither the 3rd parameter (content_type) nor the 4th (headers) was included\n                 filename, fileobj = value  # type: ignore\n-                content_type = guess_content_type(filename)\n+            elif len(value) == 3:\n+                filename, fileobj, content_type = value  # type: ignore\n+            else:\n+                # all 4 parameters included\n+                filename, fileobj, content_type, headers = value  # type: ignore\n+                headers = {k.title(): v for k, v in headers.items()}\n         else:\n             filename = Path(str(getattr(value, \"name\", \"upload\"))).name\n             fileobj = value\n+\n+        if content_type is None:\n             content_type = guess_content_type(filename)\n \n+        if content_type is not None and \"Content-Type\" not in headers:",
      "comment": "I adapted it to `any(\"content-type\" in key.lower() for key in headers)` (so it'll stop early).\r\nAlso removed the `{header.title() ...}` line.",
      "comment_id": 783258394,
      "user": "adriangb",
      "created_at": "2022-01-12T16:47:19Z",
      "url": "https://github.com/encode/httpx/pull/1936#discussion_r783258394"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1808,
      "file_path": "httpx/_api.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,7 +34,7 @@ def request(\n     auth: AuthTypes = None,\n     proxies: ProxiesTypes = None,\n     timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n-    allow_redirects: bool = True,\n+    follow_redirects: bool = False,",
      "comment": "I assume we don't consider a soft deprecation (with a warning) to be worth it here, given the amount of code that would require?",
      "comment_id": 691534140,
      "user": "florimondmanca",
      "created_at": "2021-08-18T19:13:51Z",
      "url": "https://github.com/encode/httpx/pull/1808#discussion_r691534140"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1853,
      "file_path": "httpx/__init__.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -43,6 +43,21 @@\n from ._transports.wsgi import WSGITransport\n from ._types import AsyncByteStream, SyncByteStream\n \n+try:\n+    from ._main import main\n+except ImportError:  # pragma: nocover\n+\n+    def main() -> None:  # type: ignore\n+        import sys\n+\n+        print(\n+            \"The httpx command line client could not run because the required \"\n+            \"dependancies were not installed.\\nMake sure you've installed \"",
      "comment": "Think this is a typo \ud83d\ude42 \r\n```suggestion\r\n            \"dependencies were not installed.\\nMake sure you've installed \"\r\n```",
      "comment_id": 707146041,
      "user": "sondrelg",
      "created_at": "2021-09-13T09:08:46Z",
      "url": "https://github.com/encode/httpx/pull/1853#discussion_r707146041"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1828,
      "file_path": "httpx/_transports/wsgi.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,11 +63,13 @@ def __init__(\n         raise_app_exceptions: bool = True,\n         script_name: str = \"\",\n         remote_addr: str = \"127.0.0.1\",\n+        log_file: typing.Optional[typing.TextIO] = None,\n     ) -> None:\n         self.app = app\n         self.raise_app_exceptions = raise_app_exceptions\n         self.script_name = script_name\n         self.remote_addr = remote_addr\n+        self.log_file = log_file",
      "comment": "I think `wsgi_errors` would be more consistent here, right?\r\nLoosely matching `script_name` and `remote_addr`.",
      "comment_id": 700323791,
      "user": "lovelydinosaur",
      "created_at": "2021-09-01T15:25:54Z",
      "url": "https://github.com/encode/httpx/pull/1828#discussion_r700323791"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1618,
      "file_path": "httpx/_decoders.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,37 +95,44 @@ class BrotliDecoder(ContentDecoder):\n     \"\"\"\n \n     def __init__(self) -> None:\n-        if brotlicffi is None:  # pragma: nocover\n+        if brotli is None:  # pragma: nocover\n             raise ImportError(\n-                \"Using 'BrotliDecoder', but the 'brotlicffi' library \"\n-                \"is not installed.\"\n+                \"Using 'BrotliDecoder', but neither of the 'brotlicffi' or 'brotli' \"\n+                \"packages have been installed. \"\n                 \"Make sure to install httpx using `pip install httpx[brotli]`.\"\n             ) from None\n \n-        self.decompressor = brotlicffi.Decompressor()\n+        self.decompressor = brotli.Decompressor()\n         self.seen_data = False\n         if hasattr(self.decompressor, \"decompress\"):\n-            self._decompress = self.decompressor.decompress\n+            # The 'brotlicffi' package.\n+            self._decompress = self.decompressor.decompress  # pragma: nocover\n         else:\n+            # The 'brotli' package.\n             self._decompress = self.decompressor.process  # pragma: nocover",
      "comment": "I think`brotlicffi`  also has a `process` alias for `decompress`:\r\n\r\nhttps://github.com/python-hyper/brotlicffi/blob/68c0431673e6c59549079e6588b043a707262c80/src/brotlicffi/_api.py#L423\r\n\r\nHow about just use `self.decompressor.process`?",
      "comment_id": 623738358,
      "user": "j178",
      "created_at": "2021-04-30T09:21:12Z",
      "url": "https://github.com/encode/httpx/pull/1618#discussion_r623738358"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1618,
      "file_path": "httpx/_decoders.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,37 +95,44 @@ class BrotliDecoder(ContentDecoder):\n     \"\"\"\n \n     def __init__(self) -> None:\n-        if brotlicffi is None:  # pragma: nocover\n+        if brotli is None:  # pragma: nocover\n             raise ImportError(\n-                \"Using 'BrotliDecoder', but the 'brotlicffi' library \"\n-                \"is not installed.\"\n+                \"Using 'BrotliDecoder', but neither of the 'brotlicffi' or 'brotli' \"\n+                \"packages have been installed. \"\n                 \"Make sure to install httpx using `pip install httpx[brotli]`.\"\n             ) from None\n \n-        self.decompressor = brotlicffi.Decompressor()\n+        self.decompressor = brotli.Decompressor()\n         self.seen_data = False\n         if hasattr(self.decompressor, \"decompress\"):\n-            self._decompress = self.decompressor.decompress\n+            # The 'brotlicffi' package.\n+            self._decompress = self.decompressor.decompress  # pragma: nocover\n         else:\n+            # The 'brotli' package.\n             self._decompress = self.decompressor.process  # pragma: nocover",
      "comment": "True. Tho I double checked and the `brotlipy` package doesn't, so what we want to do here depends on if we want to take care around the possibility that on some systems the older `brotlipy` package might have been installed. (Or not.)\r\n\r\n* If we do care about that awkward case, then we should just update the comment strings here.\r\n* If we don't case about that case, then we should just always use `Decompressor().process()`.\r\n\r\nPerhaps we could check which of `brotli` vs `brotlipy` is installed the `_compat.py` module, and raise an error if `brotlipy` is installed and is shadowing the `brotli` namespace.\r\n\r\nFor example:\r\n\r\n```python\r\n    if hasattr(brotli.Decompressor, 'decompress'):\r\n        raise RuntimeError(\r\n            \"The brotlipy library appears to be installed, and is shadowing the 'brotli' namespace. \"\r\n            \"Uninstall brotlipy and use brotlicffi instead.\"\r\n        )\r\n```",
      "comment_id": 623766741,
      "user": "lovelydinosaur",
      "created_at": "2021-04-30T10:09:52Z",
      "url": "https://github.com/encode/httpx/pull/1618#discussion_r623766741"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1791,
      "file_path": "httpx/_models.py",
      "line": 1365,
      "side": "RIGHT",
      "diff_hunk": "@@ -1351,6 +1356,19 @@ def charset_encoding(self) -> typing.Optional[str]:\n \n         return params[\"charset\"].strip(\"'\\\"\")\n \n+    @property\n+    def apparent_encoding(self) -> typing.Optional[str]:\n+        \"\"\"\n+        Return the encoding, as detemined by `charset_normalizer`.\n+        \"\"\"\n+        content = getattr(self, \"_content\", b\"\")\n+        if len(content) < 32:",
      "comment": "There are cases where the detection works just fine with small content. I would suggest silent the warning instead.\r\n\r\n```\r\n(target: x.encode(\"utf_8\"))\r\n* Using the following `Qu'est ce que une \u00e9toile?`\r\nchardet detect ISO-8859-1\r\ncchardet detect IBM852\r\ncharset-normalizer detect utf-8\r\n\r\n  * Using the following `Qu\u2019est ce que une \u00e9toile?`\r\nchardet detect utf-8\r\ncchardet detect UTF-8\r\ncharset-normalizer detect utf-8\r\n\r\n  * Using the following `<?xml ?><c>Financi\u00ebn</c>`\r\nchardet detect ISO-8859-1\r\ncchardet detect ISO-8859-13\r\ncharset-normalizer detect utf-8\r\n\r\n  * Using the following `(\u00b0 \u035c\u0296 \u00b0), creepy face, smiley \ud83d\ude00`\r\nchardet detect Windows-1254\r\ncchardet detect UTF-8\r\ncharset-normalizer detect utf-8\r\n\r\n  * Using the following `[\"Financi\u00ebn\", \"La France\"]`\r\nchardet detect utf-8\r\ncchardet detect ISO-8859-13\r\ncharset-normalizer detect utf-8\r\n```\r\n\r\nWDYT?",
      "comment_id": 686648010,
      "user": "Ousret",
      "created_at": "2021-08-11T09:12:07Z",
      "url": "https://github.com/encode/httpx/pull/1791#discussion_r686648010"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1791,
      "file_path": "httpx/_models.py",
      "line": 1365,
      "side": "RIGHT",
      "diff_hunk": "@@ -1351,6 +1356,19 @@ def charset_encoding(self) -> typing.Optional[str]:\n \n         return params[\"charset\"].strip(\"'\\\"\")\n \n+    @property\n+    def apparent_encoding(self) -> typing.Optional[str]:\n+        \"\"\"\n+        Return the encoding, as detemined by `charset_normalizer`.\n+        \"\"\"\n+        content = getattr(self, \"_content\", b\"\")\n+        if len(content) < 32:",
      "comment": "I went with that originally, and a couple of the tests with small amounts of content returned results I wasn't expecting. If `apparent_encoding` is `None`, then we'll end up decoding it with `'utf-8', errors='replace'`, whichI figure  is a pretty reasonable default for the corner case.",
      "comment_id": 686699898,
      "user": "lovelydinosaur",
      "created_at": "2021-08-11T10:23:43Z",
      "url": "https://github.com/encode/httpx/pull/1791#discussion_r686699898"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1791,
      "file_path": "httpx/_models.py",
      "line": 1365,
      "side": "RIGHT",
      "diff_hunk": "@@ -1351,6 +1356,19 @@ def charset_encoding(self) -> typing.Optional[str]:\n \n         return params[\"charset\"].strip(\"'\\\"\")\n \n+    @property\n+    def apparent_encoding(self) -> typing.Optional[str]:\n+        \"\"\"\n+        Return the encoding, as detemined by `charset_normalizer`.\n+        \"\"\"\n+        content = getattr(self, \"_content\", b\"\")\n+        if len(content) < 32:",
      "comment": "Alrighty, that is reasonable. :+1: \r\nIn another matter, you may run the detection anyway and check if the result has a SIG/BOM, that could be reasonable too. And discard it if len(content) < 32 and best_guess.bom is False.\r\n\r\n```python\r\nresults = from_bytes(content)\r\nbest_guess = results.best()\r\n\r\nif best_guess.bom:\r\n    ...\r\n```\r\n\r\n",
      "comment_id": 686770501,
      "user": "Ousret",
      "created_at": "2021-08-11T12:13:46Z",
      "url": "https://github.com/encode/httpx/pull/1791#discussion_r686770501"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1765,
      "file_path": "httpx/_core/base.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,15 +50,25 @@ def __str__(self) -> str:\n \n \n class RawURL:\n-    def __init__(self, scheme: bytes, host: bytes, port: int, target: bytes) -> None:\n+    def __init__(\n+        self, scheme: bytes, host: bytes, port: Optional[int], target: bytes\n+    ) -> None:\n         self.scheme = scheme\n         self.host = host\n         self.port = port\n         self.target = target\n \n     @property\n     def origin(self) -> Origin:\n-        return Origin(self.scheme, self.host, self.port)\n+        default_port = {b\"http\": 80, b\"https\": 443}[self.scheme]\n+        return Origin(self.scheme, self.host, self.port or default_port)\n+\n+    def __str__(self) -> str:\n+        scheme = self.scheme.decode(\"ascii\")\n+        host = self.host.decode(\"ascii\")\n+        port_str = \"f:{self.port}\" if self.port else \"\"",
      "comment": "```suggestion\r\n        port_str = f\":{self.port}\" if self.port else \"\"\r\n```",
      "comment_id": 676015127,
      "user": "tsotnikov",
      "created_at": "2021-07-24T15:56:05Z",
      "url": "https://github.com/encode/httpx/pull/1765#discussion_r676015127"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1759,
      "file_path": "tests/models/test_responses.py",
      "line": 575,
      "side": "RIGHT",
      "diff_hunk": "@@ -572,10 +572,7 @@ def test_iter_lines():\n         200,\n         content=b\"Hello,\\nworld!\",\n     )\n-\n-    content = []\n-    for line in response.iter_lines():\n-        content.append(line)\n+    content = [line for line in response.iter_lines()]",
      "comment": "We could also use `content = list(response.iter_lines())` here.",
      "comment_id": 673974528,
      "user": "lovelydinosaur",
      "created_at": "2021-07-21T13:31:25Z",
      "url": "https://github.com/encode/httpx/pull/1759#discussion_r673974528"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1714,
      "file_path": "httpx/_compat.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,13 +13,20 @@\n     from async_generator import asynccontextmanager  # type: ignore # noqa\n \n \n-def set_minimum_tls_version_1_2(context: ssl.SSLContext) -> None:\n-    if sys.version_info >= (3, 10):\n+if sys.version_info >= (3, 10) or (\n+    sys.version_info >= (3, 7) and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0, 7)\n+):\n+    # The OP_NO_SSL* and OP_NO_TLS* become deprecated in favor of\n+    # 'SSLContext.minimum_version' from Python 3.7 onwards, however\n+    # this attribute is not available unless the ssl module is compiled\n+    # with OpenSSL 1.1.0g or newer.\n+    def set_minimum_tls_version_1_2(context: ssl.SSLContext) -> None:\n         context.minimum_version = ssl.TLSVersion.TLSv1_2\n-    else:\n-        # These become deprecated in favor of 'context.minimum_version'\n-        # from Python 3.10 onwards.\n-        context.options |= ssl.OP_NO_SSLv2\n-        context.options |= ssl.OP_NO_SSLv3\n-        context.options |= ssl.OP_NO_TLSv1\n-        context.options |= ssl.OP_NO_TLSv1_1\n+\n+\n+else:\n+\n+    def set_minimum_tls_version_1_2(context: ssl.SSLContext) -> None:\n+        context.options |= (\n+            ssl.OP_NO_SSLv2 | ssl.OP_NO_SSLv3 | ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n+        )",
      "comment": "Okay. I'd suggest we aim to keep the change footprint on pull requests as low as possible. Not reformatting the `context.options |= ...` style here would help with that.\r\n\r\n```python\r\ndef set_minimum_tls_version_1_2(context: ssl.SSLContext) -> None:\r\n     if (\r\n        sys.version_info >= (3, 10) or\r\n        sys.version_info >= (3, 7) and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0, 7)\r\n     ):\r\n         # The 'minimum_version' attribute is available from Python 3.10 onwards,\r\n         # or Python 3.7 onwards if the ssl module is compiled with OpenSSL 1.1.0g\r\n         # or newer.\r\n         # https://docs.python.org/3.10/library/ssl.html#ssl.SSLContext.minimum_version\r\n         # https://docs.python.org/3.7/library/ssl.html#ssl.SSLContext.minimum_version\r\n         context.minimum_version = ssl.TLSVersion.TLSv1_2\r\n     else:\r\n         # If 'minimum_version' isn't available, we configure these options with\r\n         # the older deprecated variants.\r\n         context.options |= ssl.OP_NO_SSLv2\r\n         context.options |= ssl.OP_NO_SSLv3\r\n         context.options |= ssl.OP_NO_TLSv1\r\n         context.options |= ssl.OP_NO_TLSv1_1\r\n```",
      "comment_id": 658624321,
      "user": "lovelydinosaur",
      "created_at": "2021-06-25T09:24:14Z",
      "url": "https://github.com/encode/httpx/pull/1714#discussion_r658624321"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1714,
      "file_path": "httpx/_compat.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,12 +13,20 @@\n     from async_generator import asynccontextmanager  # type: ignore # noqa\n \n \n-def set_minimum_tls_version_1_2(context: ssl.SSLContext) -> None:\n-    if sys.version_info >= (3, 10):\n+if sys.version_info >= (3, 10) or (\n+    sys.version_info >= (3, 7) and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0, 7)\n+):\n+    # The OP_NO_SSL* and OP_NO_TLS* become deprecated in favor of\n+    # 'SSLContext.minimum_version' from Python 3.7 onwards, however\n+    # this attribute is not available unless the ssl module is compiled\n+    # with OpenSSL 1.1.0g or newer.",
      "comment": "```suggestion\r\n    # with OpenSSL 1.1.0g or newer.\r\n    # https://docs.python.org/3.10/library/ssl.html#ssl.SSLContext.minimum_version\r\n    # https://docs.python.org/3.7/library/ssl.html#ssl.SSLContext.minimum_version\r\n```",
      "comment_id": 658659482,
      "user": "graingert",
      "created_at": "2021-06-25T10:21:13Z",
      "url": "https://github.com/encode/httpx/pull/1714#discussion_r658659482"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1714,
      "file_path": "httpx/_compat.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,12 +13,22 @@\n     from async_generator import asynccontextmanager  # type: ignore # noqa\n \n \n-def set_minimum_tls_version_1_2(context: ssl.SSLContext) -> None:\n-    if sys.version_info >= (3, 10):\n+if sys.version_info >= (3, 10) or (",
      "comment": "So there's still a little too much unnecessary change footprint here. We don't really need to switch the structure around here. Let's keep `set_minimum_tls_version_1_2` as the top level function, with the switch *inside* it.\r\n\r\nWe really just want to:\r\n\r\n* Update the `sys.version_info >= (3, 10)` branch condition.\r\n* Possibly neaten up the commenting.\r\n\r\nAnd absolutely nothing else.",
      "comment_id": 658664093,
      "user": "lovelydinosaur",
      "created_at": "2021-06-25T10:29:40Z",
      "url": "https://github.com/encode/httpx/pull/1714#discussion_r658664093"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1714,
      "file_path": "httpx/_compat.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,11 +14,17 @@\n \n \n def set_minimum_tls_version_1_2(context: ssl.SSLContext) -> None:\n-    if sys.version_info >= (3, 10):\n+    if sys.version_info >= (3, 10) or (\n+        sys.version_info >= (3, 7) and ssl.OPENSSL_VERSION_INFO >= (1, 1, 0, 7)\n+    ):\n+        # The OP_NO_SSL* and OP_NO_TLS* become deprecated in favor of\n+        # 'SSLContext.minimum_version' from Python 3.7 onwards, however\n+        # this attribute is not available unless the ssl module is compiled\n+        # with OpenSSL 1.1.0g or newer.\n+        # https://docs.python.org/3.10/library/ssl.html#ssl.SSLContext.minimum_version\n+        # https://docs.python.org/3.7/library/ssl.html#ssl.SSLContext.minimum_version\n         context.minimum_version = ssl.TLSVersion.TLSv1_2\n     else:\n-        # These become deprecated in favor of 'context.minimum_version'\n-        # from Python 3.10 onwards.\n         context.options |= ssl.OP_NO_SSLv2",
      "comment": "```suggestion\r\n        # If 'minimum_version' isn't available, we configure these options with\r\n        # the older deprecated variants.\r\n        context.options |= ssl.OP_NO_SSLv2\r\n```",
      "comment_id": 658669795,
      "user": "graingert",
      "created_at": "2021-06-25T10:40:45Z",
      "url": "https://github.com/encode/httpx/pull/1714#discussion_r658669795"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1682,
      "file_path": "tests/conftest.py",
      "line": 168,
      "side": "RIGHT",
      "diff_hunk": "@@ -164,7 +165,7 @@ async def redirect_301(scope, receive, send):\n     await send({\"type\": \"http.response.body\"})\n \n \n-SERVER_SCOPE = \"session\"\n+SERVER_SCOPE: Literal[\"session\"] = \"session\"",
      "comment": "Few questions, for thoroughness. \ud83d\ude01\r\n\r\n* What's prompting this change?\r\n* Is it strictly necessary for us to type this variable, here?\r\n* Do we have a build failure without it?\r\n* Can it simply be `str`?",
      "comment_id": 651007415,
      "user": "lovelydinosaur",
      "created_at": "2021-06-14T14:37:47Z",
      "url": "https://github.com/encode/httpx/pull/1682#discussion_r651007415"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1682,
      "file_path": "tests/conftest.py",
      "line": 168,
      "side": "RIGHT",
      "diff_hunk": "@@ -164,7 +165,7 @@ async def redirect_301(scope, receive, send):\n     await send({\"type\": \"http.response.body\"})\n \n \n-SERVER_SCOPE = \"session\"\n+SERVER_SCOPE: Literal[\"session\"] = \"session\"",
      "comment": "> Do you have an alternative suggestion?\r\n\r\nNope. Just making sure I understand e'rything going in, and we've got a super clear history in place throughout. \ud83d\ude00",
      "comment_id": 651076716,
      "user": "lovelydinosaur",
      "created_at": "2021-06-14T15:57:49Z",
      "url": "https://github.com/encode/httpx/pull/1682#discussion_r651076716"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1522,
      "file_path": "httpx/_transports/base.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+import typing\n+from types import TracebackType\n+\n+T = typing.TypeVar(\"T\", bound=\"BaseTransport\")\n+A = typing.TypeVar(\"A\", bound=\"AsyncBaseTransport\")\n+\n+\n+class BaseTransport:\n+    def __enter__(self: T) -> T:\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: typing.Type[BaseException] = None,\n+        exc_value: BaseException = None,\n+        traceback: TracebackType = None,\n+    ) -> None:\n+        self.close()\n+\n+    def handle_request(\n+        self,\n+        method: bytes,\n+        url: typing.Tuple[bytes, bytes, typing.Optional[int], bytes],\n+        headers: typing.List[typing.Tuple[bytes, bytes]],\n+        stream: typing.Iterator[bytes],",
      "comment": "I understand this used to be an `httpcore.SyncByteStream` type, and we're now switching to standard \"can be used in a `for` loop\" type.\r\n\r\nWondering if we should be using `Iterable[bytes]` instead?\r\n\r\nMostly because of this\u2026\r\n\r\n```python\r\ndef f(stream: Iterator[bytes]) -> None:\r\n    pass\r\n\r\nstream = [b\"hello, world\"]\r\n\r\nf(stream)  # error: Argument 1 to \"f\" has incompatible type \"List[bytes]\"; expected \"Iterator[bytes]\"\r\n```\r\n\r\nAnd\u2026\r\n\r\n```python\r\ndef f() -> typing.Iterator[bytes]:\r\n    return [b\"content\"]  # error: Incompatible return value type (got \"List[bytes]\", expected \"Iterator[bytes]\"\r\n```\r\n\r\nSo:\r\n\r\n```suggestion\r\n        stream: typing.Iterable[bytes],\r\n```",
      "comment_id": 599876834,
      "user": "florimondmanca",
      "created_at": "2021-03-23T19:38:45Z",
      "url": "https://github.com/encode/httpx/pull/1522#discussion_r599876834"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1522,
      "file_path": "httpx/_transports/base.py",
      "line": 119,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+import typing\n+from types import TracebackType\n+\n+T = typing.TypeVar(\"T\", bound=\"BaseTransport\")\n+A = typing.TypeVar(\"A\", bound=\"AsyncBaseTransport\")\n+\n+\n+class BaseTransport:\n+    def __enter__(self: T) -> T:\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: typing.Type[BaseException] = None,\n+        exc_value: BaseException = None,\n+        traceback: TracebackType = None,\n+    ) -> None:\n+        self.close()\n+\n+    def handle_request(\n+        self,\n+        method: bytes,\n+        url: typing.Tuple[bytes, bytes, typing.Optional[int], bytes],\n+        headers: typing.List[typing.Tuple[bytes, bytes]],\n+        stream: typing.Iterator[bytes],\n+        extensions: dict,\n+    ) -> typing.Tuple[\n+        int, typing.List[typing.Tuple[bytes, bytes]], typing.Iterator[bytes], dict\n+    ]:\n+        \"\"\"\n+        Send a single HTTP request and return a response.\n+\n+        At this layer of API we're simply using plain primitives. No `Request` or\n+        `Response` models, no fancy `URL` or `Header` handling. This strict point\n+        of cut-off provides a clear design seperation between the HTTPX API,\n+        and the low-level network handling.\n+\n+        Developers shouldn't typically ever need to call into this API directly,\n+        since the Client class provides all the higher level user-facing API\n+        niceties.\n+\n+        Example usage:\n+\n+            with httpx.HTTPTransport() as transport:\n+                status_code, headers, stream, extensions = transport.handle_request(\n+                    method=b'GET',\n+                    url=(b'https', b'www.example.com', 443, b'/'),\n+                    headers=[(b'Host', b'www.example.com')],\n+                    stream=[],\n+                    extensions={}\n+                )\n+                try:\n+                    body = b''.join([part for part in stream])\n+                finally:\n+                    if 'close' in extensions:\n+                        extensions['close']()\n+                print(status_code, headers, body)\n+\n+        Arguments:\n+\n+        method: The request method as bytes. Eg. b'GET'.\n+        url: The components of the request URL, as a tuple of `(scheme, host, port, target)`.\n+             The target will usually be the URL path, but also allows for alternative\n+             formulations, such as proxy requests which include the complete URL in\n+             the target portion of the HTTP request, or for \"OPTIONS *\" requests, which\n+             cannot be expressed in a URL string.\n+        headers: The request headers as a list of byte pairs.\n+        stream: The request body as a bytes iterator.\n+        extensions: An open ended dictionary, including optional extensions to the\n+                    core request/response API. Keys may include:\n+            timeout: A dictionary of str:Optional[float] timeout values.\n+                     May include values for 'connect', 'read', 'write', or 'pool'.\n+\n+        Returns a tuple of:\n+\n+        status_code: The response status code as an integer. Should be in the range 1xx-5xx.\n+        headers: The response headers as a list of byte pairs.\n+        stream: The response body as a bytes iterator.\n+        extensions: An open ended dictionary, including optional extensions to the\n+                    core request/response API. Keys are plain strings, and may include:\n+            reason_phrase: The reason-phrase of the HTTP response, as bytes. Eg b'OK'.\n+                    HTTP/2 onwards does not include a reason phrase on the wire.\n+                    When no key is included, a default based on the status code may\n+                    be used. An empty-string reason phrase should not be substituted\n+                    for a default, as it indicates the server left the portion blank\n+                    eg. the leading response bytes were b\"HTTP/1.1 200 <CRLF>\".\n+            http_version: The HTTP version, as bytes. Eg. b\"HTTP/1.1\".\n+                    When no http_version key is included, HTTP/1.1 may be assumed.\n+            close:  A callback which should be invoked to release any network\n+                    resources.\n+            aclose: An async callback which should be invoked to release any\n+                    network resources.\n+        \"\"\"\n+        raise NotImplementedError(\n+            \"The 'handle_request' method must be implemented.\"\n+        )  # pragma: nocover\n+\n+    def close(self) -> None:\n+        pass\n+\n+\n+class AsyncBaseTransport:\n+    async def __aenter__(self: A) -> A:\n+        return self\n+\n+    async def __aexit__(\n+        self,\n+        exc_type: typing.Type[BaseException] = None,\n+        exc_value: BaseException = None,\n+        traceback: TracebackType = None,\n+    ) -> None:\n+        await self.aclose()\n+\n+    async def handle_async_request(\n+        self,\n+        method: bytes,\n+        url: typing.Tuple[bytes, bytes, typing.Optional[int], bytes],\n+        headers: typing.List[typing.Tuple[bytes, bytes]],\n+        stream: typing.AsyncIterator[bytes],",
      "comment": "```suggestion\r\n        stream: typing.AsyncIterable[bytes],\r\n```",
      "comment_id": 599878475,
      "user": "florimondmanca",
      "created_at": "2021-03-23T19:41:34Z",
      "url": "https://github.com/encode/httpx/pull/1522#discussion_r599878475"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1522,
      "file_path": "httpx/_transports/base.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+import typing\n+from types import TracebackType\n+\n+T = typing.TypeVar(\"T\", bound=\"BaseTransport\")\n+A = typing.TypeVar(\"A\", bound=\"AsyncBaseTransport\")\n+\n+\n+class BaseTransport:\n+    def __enter__(self: T) -> T:\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: typing.Type[BaseException] = None,\n+        exc_value: BaseException = None,\n+        traceback: TracebackType = None,\n+    ) -> None:\n+        self.close()\n+\n+    def handle_request(\n+        self,\n+        method: bytes,\n+        url: typing.Tuple[bytes, bytes, typing.Optional[int], bytes],\n+        headers: typing.List[typing.Tuple[bytes, bytes]],\n+        stream: typing.Iterator[bytes],\n+        extensions: dict,\n+    ) -> typing.Tuple[\n+        int, typing.List[typing.Tuple[bytes, bytes]], typing.Iterator[bytes], dict",
      "comment": "```suggestion\r\n        int, typing.List[typing.Tuple[bytes, bytes]], typing.Iterable[bytes], dict\r\n```",
      "comment_id": 599878626,
      "user": "florimondmanca",
      "created_at": "2021-03-23T19:41:50Z",
      "url": "https://github.com/encode/httpx/pull/1522#discussion_r599878626"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1522,
      "file_path": "httpx/_transports/base.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,129 @@\n+import typing\n+from types import TracebackType\n+\n+T = typing.TypeVar(\"T\", bound=\"BaseTransport\")\n+A = typing.TypeVar(\"A\", bound=\"AsyncBaseTransport\")\n+\n+\n+class BaseTransport:\n+    def __enter__(self: T) -> T:\n+        return self\n+\n+    def __exit__(\n+        self,\n+        exc_type: typing.Type[BaseException] = None,\n+        exc_value: BaseException = None,\n+        traceback: TracebackType = None,\n+    ) -> None:\n+        self.close()\n+\n+    def handle_request(\n+        self,\n+        method: bytes,\n+        url: typing.Tuple[bytes, bytes, typing.Optional[int], bytes],\n+        headers: typing.List[typing.Tuple[bytes, bytes]],\n+        stream: typing.Iterator[bytes],\n+        extensions: dict,\n+    ) -> typing.Tuple[\n+        int, typing.List[typing.Tuple[bytes, bytes]], typing.Iterator[bytes], dict",
      "comment": "(There are more of these in mock/asgi/wsgi transports.)",
      "comment_id": 599882259,
      "user": "florimondmanca",
      "created_at": "2021-03-23T19:46:45Z",
      "url": "https://github.com/encode/httpx/pull/1522#discussion_r599882259"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1522,
      "file_path": "httpx/_transports/default.py",
      "line": 181,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,21 +163,44 @@ def __exit__(\n     ) -> None:\n         self._pool.__exit__(exc_type, exc_value, traceback)\n \n-    def request(\n+    def handle_request(\n         self,\n         method: bytes,\n-        url: URL,\n-        headers: Headers = None,\n-        stream: httpcore.SyncByteStream = None,\n-        ext: dict = None,\n-    ) -> typing.Tuple[int, Headers, httpcore.SyncByteStream, dict]:\n-        return self._pool.request(method, url, headers=headers, stream=stream, ext=ext)\n+        url: typing.Tuple[bytes, bytes, typing.Optional[int], bytes],\n+        headers: typing.List[typing.Tuple[bytes, bytes]],\n+        stream: typing.Iterator[bytes],\n+        extensions: dict,\n+    ) -> typing.Tuple[\n+        int, typing.List[typing.Tuple[bytes, bytes]], typing.Iterator[bytes], dict\n+    ]:\n+        with map_httpcore_exceptions():\n+            status_code, headers, byte_stream, extensions = self._pool.request(\n+                method=method,\n+                url=url,\n+                headers=headers,\n+                stream=stream,  # type: ignore",
      "comment": "Do we / how do we plan to deal with this `type: ignore`? Shall we wrap in `httpcore.SyncIteratorStream` in the interim?",
      "comment_id": 599883018,
      "user": "florimondmanca",
      "created_at": "2021-03-23T19:48:02Z",
      "url": "https://github.com/encode/httpx/pull/1522#discussion_r599883018"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1522,
      "file_path": "httpx/_transports/default.py",
      "line": 181,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,21 +163,44 @@ def __exit__(\n     ) -> None:\n         self._pool.__exit__(exc_type, exc_value, traceback)\n \n-    def request(\n+    def handle_request(\n         self,\n         method: bytes,\n-        url: URL,\n-        headers: Headers = None,\n-        stream: httpcore.SyncByteStream = None,\n-        ext: dict = None,\n-    ) -> typing.Tuple[int, Headers, httpcore.SyncByteStream, dict]:\n-        return self._pool.request(method, url, headers=headers, stream=stream, ext=ext)\n+        url: typing.Tuple[bytes, bytes, typing.Optional[int], bytes],\n+        headers: typing.List[typing.Tuple[bytes, bytes]],\n+        stream: typing.Iterator[bytes],\n+        extensions: dict,\n+    ) -> typing.Tuple[\n+        int, typing.List[typing.Tuple[bytes, bytes]], typing.Iterator[bytes], dict\n+    ]:\n+        with map_httpcore_exceptions():\n+            status_code, headers, byte_stream, extensions = self._pool.request(\n+                method=method,\n+                url=url,\n+                headers=headers,\n+                stream=stream,  # type: ignore",
      "comment": "Good call. Using the concrete `httpcore.IteratorByteStream()` and `httpcore.AsyncIteratorByteStream()` classes to wrap this in the correct interface.",
      "comment_id": 600316829,
      "user": "lovelydinosaur",
      "created_at": "2021-03-24T09:42:40Z",
      "url": "https://github.com/encode/httpx/pull/1522#discussion_r600316829"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1522,
      "file_path": "httpx/_transports/asgi.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,17 +70,14 @@ def __init__(\n         self.root_path = root_path\n         self.client = client\n \n-    async def arequest(\n+    async def handle_async_request(\n         self,\n         method: bytes,\n         url: Tuple[bytes, bytes, Optional[int], bytes],\n-        headers: List[Tuple[bytes, bytes]] = None,\n-        stream: httpcore.AsyncByteStream = None,\n-        ext: dict = None,\n-    ) -> Tuple[int, List[Tuple[bytes, bytes]], httpcore.AsyncByteStream, dict]:\n-        headers = [] if headers is None else headers\n-        stream = httpcore.PlainByteStream(content=b\"\") if stream is None else stream\n-\n+        headers: List[Tuple[bytes, bytes]],\n+        stream: typing.AsyncIterable[bytes],",
      "comment": "(Nit) Preferring adding `AsyncIterable` to the `from typing import ...` line?\r\n\r\n```suggestion\r\n        stream: AsyncIterable[bytes],\r\n```",
      "comment_id": 600373075,
      "user": "florimondmanca",
      "created_at": "2021-03-24T10:58:56Z",
      "url": "https://github.com/encode/httpx/pull/1522#discussion_r600373075"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1522,
      "file_path": "httpx/_transports/asgi.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,17 +70,14 @@ def __init__(\n         self.root_path = root_path\n         self.client = client\n \n-    async def arequest(\n+    async def handle_async_request(\n         self,\n         method: bytes,\n         url: Tuple[bytes, bytes, Optional[int], bytes],\n-        headers: List[Tuple[bytes, bytes]] = None,\n-        stream: httpcore.AsyncByteStream = None,\n-        ext: dict = None,\n-    ) -> Tuple[int, List[Tuple[bytes, bytes]], httpcore.AsyncByteStream, dict]:\n-        headers = [] if headers is None else headers\n-        stream = httpcore.PlainByteStream(content=b\"\") if stream is None else stream\n-\n+        headers: List[Tuple[bytes, bytes]],\n+        stream: typing.AsyncIterable[bytes],",
      "comment": "Good catch. I've gone with consistency across the transport modules, switching `asgi.py` and `mock.py` to use `import typing`, in line with `base.py`, `default.py`, and `wsgi.py`.\r\n\r\nThis is the style we use in all our top level modules too, except for `_content.py` (Which we probably may as well switch for consistency), and `_types.py` (Which might be a bit unneccessarily grungy if we switched, so might want to leave as an exception.)",
      "comment_id": 600404043,
      "user": "lovelydinosaur",
      "created_at": "2021-03-24T11:46:44Z",
      "url": "https://github.com/encode/httpx/pull/1522#discussion_r600404043"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1590,
      "file_path": "httpx/_models.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -60,33 +61,45 @@\n \n class URL:\n     \"\"\"\n-    url = httpx.URL(\"HTTPS://jo%40email.com:a%20secret@example.com:1234/pa%20th?search=ab#anchorlink\")\n+    url = httpx.URL(\"HTTPS://jo%40email.com:a%20secret@m\u00fcller.de:1234/pa%20th?search=ab#anchorlink\")\n \n     assert url.scheme == \"https\"\n     assert url.username == \"jo@email.com\"\n     assert url.password == \"a secret\"\n     assert url.userinfo == b\"jo%40email.com:a%20secret\"\n-    assert url.host == \"example.com\"\n+    assert url.host == \"m\u00fcller.de\"\n+    assert url.raw_host == b\"xn--mller-kva.dem\"",
      "comment": "I think this is a typo, based on [the test below](https://github.com/encode/httpx/pull/1590/files#diff-e22e5624ca4e994155aa44e1b25f7812b286a8bbbeabdcd6490073ad2f3927dcR26-R27)\r\n```suggestion\r\n    assert url.raw_host == b\"xn--mller-kva.de\"\r\n```",
      "comment_id": 618620007,
      "user": "StephenBrown2",
      "created_at": "2021-04-22T17:51:55Z",
      "url": "https://github.com/encode/httpx/pull/1590#discussion_r618620007"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1590,
      "file_path": "httpx/_models.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -60,33 +61,45 @@\n \n class URL:\n     \"\"\"\n-    url = httpx.URL(\"HTTPS://jo%40email.com:a%20secret@example.com:1234/pa%20th?search=ab#anchorlink\")\n+    url = httpx.URL(\"HTTPS://jo%40email.com:a%20secret@m\u00fcller.de:1234/pa%20th?search=ab#anchorlink\")\n \n     assert url.scheme == \"https\"\n     assert url.username == \"jo@email.com\"\n     assert url.password == \"a secret\"\n     assert url.userinfo == b\"jo%40email.com:a%20secret\"\n-    assert url.host == \"example.com\"\n+    assert url.host == \"m\u00fcller.de\"\n+    assert url.raw_host == b\"xn--mller-kva.dem\"\n     assert url.port == 1234\n-    assert url.netloc == \"example.com:1234\"\n+    assert url.netloc == b\"xn--mller-kva.dem:1234\"",
      "comment": "I think this is a typo, based on [the test below](https://github.com/encode/httpx/pull/1590/files#diff-e22e5624ca4e994155aa44e1b25f7812b286a8bbbeabdcd6490073ad2f3927dcR26-R27)\r\n```suggestion\r\n    assert url.netloc == b\"xn--mller-kva.de:1234\"\r\n```",
      "comment_id": 618620175,
      "user": "StephenBrown2",
      "created_at": "2021-04-22T17:52:11Z",
      "url": "https://github.com/encode/httpx/pull/1590#discussion_r618620175"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1590,
      "file_path": "httpx/_models.py",
      "line": 205,
      "side": "RIGHT",
      "diff_hunk": "@@ -181,26 +202,60 @@ def password(self) -> str:\n     def host(self) -> str:\n         \"\"\"\n         The URL host as a string.\n-        Always normlized to lowercase, and IDNA encoded.\n+        Always normlized to lowercase, with IDNA hosts decoded into unicode.",
      "comment": "Old typo\r\n```suggestion\r\n        Always normalized to lowercase, with IDNA hosts decoded into unicode.\r\n```",
      "comment_id": 618621946,
      "user": "StephenBrown2",
      "created_at": "2021-04-22T17:54:56Z",
      "url": "https://github.com/encode/httpx/pull/1590#discussion_r618621946"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1590,
      "file_path": "httpx/_models.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -181,26 +202,60 @@ def password(self) -> str:\n     def host(self) -> str:\n         \"\"\"\n         The URL host as a string.\n-        Always normlized to lowercase, and IDNA encoded.\n+        Always normlized to lowercase, with IDNA hosts decoded into unicode.\n \n         Examples:\n \n         url = httpx.URL(\"http://www.EXAMPLE.org\")\n         assert url.host == \"www.example.org\"\n \n         url = httpx.URL(\"http://\u4e2d\u56fd.icom.museum\")\n-        assert url.host == \"xn--fiqs8s.icom.museum\"\n+        assert url.host == \"\u4e2d\u56fd.icom.museum\"\n+\n+        url = httpx.URL(\"http://xn--fiqs8s.icom.museum\")\n+        assert url.host == \"\u4e2d\u56fd.icom.museum\"\n \n         url = httpx.URL(\"https://[::ffff:192.168.0.1]\")\n         assert url.host == \"::ffff:192.168.0.1\"\n         \"\"\"\n-        host: str = self._uri_reference.host\n+        host: str = self._uri_reference.host or \"\"\n+\n+        if host and \":\" in host and host[0] == \"[\":\n+            # it's an IPv6 address\n+            host = host.lstrip(\"[\").rstrip(\"]\")\n+\n+        if host.startswith(\"xn--\"):\n+            host = idna.decode(host)\n+\n+        return host\n+\n+    @property\n+    def raw_host(self) -> bytes:\n+        \"\"\"\n+        The raw bytes representation of the URL host.\n+        Always normlized to lowercase, and IDNA encoded.",
      "comment": "New typo, copy-paste of the old. ;-)\r\n```suggestion\r\n        Always normalized to lowercase, and IDNA encoded.\r\n```",
      "comment_id": 618622556,
      "user": "StephenBrown2",
      "created_at": "2021-04-22T17:55:45Z",
      "url": "https://github.com/encode/httpx/pull/1590#discussion_r618622556"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1590,
      "file_path": "httpx/_models.py",
      "line": 272,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,14 +266,17 @@ def port(self) -> typing.Optional[int]:\n         return int(port) if port else None\n \n     @property\n-    def netloc(self) -> str:\n+    def netloc(self) -> bytes:\n         \"\"\"\n-        Either `<host>` or `<host>:<port>` as a string.\n+        Either `<host>` or `<host>:<port>` as bytes.\n         Always normlized to lowercase, and IDNA encoded.",
      "comment": "```suggestion\r\n        Always normalized to lowercase, and IDNA encoded.\r\n```",
      "comment_id": 618623513,
      "user": "StephenBrown2",
      "created_at": "2021-04-22T17:57:04Z",
      "url": "https://github.com/encode/httpx/pull/1590#discussion_r618623513"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1579,
      "file_path": "httpx/_content.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,6 +61,21 @@ async def __aiter__(self) -> AsyncIterator[bytes]:\n             yield part\n \n \n+class UnattachedStream(AsyncByteStream, SyncByteStream):\n+    \"\"\"\n+    If a request or response is serialized using pickle, then it is no longer\n+    attached to a stream for I/O purposes. Any stream operations should result\n+    in `httpx.StreamClosed`.\n+    \"\"\"\n+\n+    def __iter__(self) -> Iterator[bytes]:\n+        raise ResponseClosed()  # TODO: StreamClosed\n+\n+    async def __aiter__(self) -> AsyncIterator[bytes]:\n+        raise ResponseClosed()  # TODO: StreamClosed\n+        yield b\"\"  # pragma: nocover",
      "comment": "We need the `yield` here to avoid `TypeError`:\r\n\r\n```\r\n    async def aread(self) -> bytes:\r\n        \"\"\"\r\n        Read and return the request content.\r\n        \"\"\"\r\n        if not hasattr(self, \"_content\"):\r\n            assert isinstance(self.stream, typing.AsyncIterable)\r\n>           self._content = b\"\".join([part async for part in self.stream])\r\nE           TypeError: 'async for' received an object from __aiter__ that does not implement __anext__: coroutine\r\n```",
      "comment_id": 616036989,
      "user": "hannseman",
      "created_at": "2021-04-19T17:22:26Z",
      "url": "https://github.com/encode/httpx/pull/1579#discussion_r616036989"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1579,
      "file_path": "tests/models/test_responses.py",
      "line": 885,
      "side": "RIGHT",
      "diff_hunk": "@@ -853,3 +854,40 @@ def content():\n     headers = {\"Content-Length\": \"8\"}\n     response = httpx.Response(200, content=content(), headers=headers)\n     assert response.headers == {\"Content-Length\": \"8\"}\n+\n+\n+def test_response_picklable():\n+    response = httpx.Response(\n+        200,\n+        content=b\"Hello, world!\",\n+        request=httpx.Request(\"GET\", \"https://example.org\"),\n+    )\n+    pickle_response = pickle.loads(pickle.dumps(response))\n+    assert pickle_response.is_closed is True\n+    assert pickle_response.is_stream_consumed is True\n+    assert pickle_response.next_request is None\n+    assert pickle_response.stream is not None\n+    assert pickle_response.content == b\"Hello, world!\"\n+    assert pickle_response.status_code == 200\n+    assert pickle_response.request.url == response.request.url\n+    assert pickle_response.extensions == {}\n+    assert pickle_response.history == []\n+\n+\n+@pytest.mark.asyncio\n+async def test_response_async_streaming_picklable():\n+    response = httpx.Response(200, content=async_streaming_body())\n+    pickle_response = pickle.loads(pickle.dumps(response))\n+    assert hasattr(pickle_response, \"_content\") is False\n+    with pytest.raises(httpx.ResponseClosed):  # TODO: StreamClosed\n+        await pickle_response.aread()\n+    assert pickle_response.is_stream_consumed is False\n+    assert pickle_response._num_bytes_downloaded == 0",
      "comment": "Let's aim to test against public API wherever possible.\r\n\r\nEg. in this case let's access the property instead, so... `assert pickle_response.num_bytes_downloaded == 0`",
      "comment_id": 616496859,
      "user": "lovelydinosaur",
      "created_at": "2021-04-20T09:11:03Z",
      "url": "https://github.com/encode/httpx/pull/1579#discussion_r616496859"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1579,
      "file_path": "tests/models/test_responses.py",
      "line": 881,
      "side": "RIGHT",
      "diff_hunk": "@@ -853,3 +854,40 @@ def content():\n     headers = {\"Content-Length\": \"8\"}\n     response = httpx.Response(200, content=content(), headers=headers)\n     assert response.headers == {\"Content-Length\": \"8\"}\n+\n+\n+def test_response_picklable():\n+    response = httpx.Response(\n+        200,\n+        content=b\"Hello, world!\",\n+        request=httpx.Request(\"GET\", \"https://example.org\"),\n+    )\n+    pickle_response = pickle.loads(pickle.dumps(response))\n+    assert pickle_response.is_closed is True\n+    assert pickle_response.is_stream_consumed is True\n+    assert pickle_response.next_request is None\n+    assert pickle_response.stream is not None\n+    assert pickle_response.content == b\"Hello, world!\"\n+    assert pickle_response.status_code == 200\n+    assert pickle_response.request.url == response.request.url\n+    assert pickle_response.extensions == {}\n+    assert pickle_response.history == []\n+\n+\n+@pytest.mark.asyncio\n+async def test_response_async_streaming_picklable():\n+    response = httpx.Response(200, content=async_streaming_body())\n+    pickle_response = pickle.loads(pickle.dumps(response))\n+    assert hasattr(pickle_response, \"_content\") is False",
      "comment": "I guess testing against public API we probably want something like this instead...\r\n\r\n```python\r\nwith pytest.raises(httpx.ResponseNotRead):\r\n    response.content\r\n```",
      "comment_id": 616497491,
      "user": "lovelydinosaur",
      "created_at": "2021-04-20T09:11:59Z",
      "url": "https://github.com/encode/httpx/pull/1579#discussion_r616497491"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1579,
      "file_path": "httpx/_content.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,7 +13,7 @@\n )\n from urllib.parse import urlencode\n \n-from ._exceptions import StreamConsumed\n+from ._exceptions import ResponseClosed, StreamConsumed",
      "comment": "```suggestion\r\nfrom ._exceptions import StreamClosed, StreamConsumed\r\n```",
      "comment_id": 617379102,
      "user": "lovelydinosaur",
      "created_at": "2021-04-21T09:55:41Z",
      "url": "https://github.com/encode/httpx/pull/1579#discussion_r617379102"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1579,
      "file_path": "tests/models/test_responses.py",
      "line": 883,
      "side": "RIGHT",
      "diff_hunk": "@@ -853,3 +854,41 @@ def content():\n     headers = {\"Content-Length\": \"8\"}\n     response = httpx.Response(200, content=content(), headers=headers)\n     assert response.headers == {\"Content-Length\": \"8\"}\n+\n+\n+def test_response_picklable():\n+    response = httpx.Response(\n+        200,\n+        content=b\"Hello, world!\",\n+        request=httpx.Request(\"GET\", \"https://example.org\"),\n+    )\n+    pickle_response = pickle.loads(pickle.dumps(response))\n+    assert pickle_response.is_closed is True\n+    assert pickle_response.is_stream_consumed is True\n+    assert pickle_response.next_request is None\n+    assert pickle_response.stream is not None\n+    assert pickle_response.content == b\"Hello, world!\"\n+    assert pickle_response.status_code == 200\n+    assert pickle_response.request.url == response.request.url\n+    assert pickle_response.extensions == {}\n+    assert pickle_response.history == []\n+\n+\n+@pytest.mark.asyncio\n+async def test_response_async_streaming_picklable():\n+    response = httpx.Response(200, content=async_streaming_body())\n+    pickle_response = pickle.loads(pickle.dumps(response))\n+    with pytest.raises(httpx.ResponseNotRead):\n+        pickle_response.content\n+    with pytest.raises(httpx.ResponseClosed):  # TODO: StreamClosed",
      "comment": "```suggestion\r\n    with pytest.raises(httpx.StreamClosed):\r\n```",
      "comment_id": 617387570,
      "user": "lovelydinosaur",
      "created_at": "2021-04-21T10:04:06Z",
      "url": "https://github.com/encode/httpx/pull/1579#discussion_r617387570"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1579,
      "file_path": "tests/models/test_requests.py",
      "line": 222,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,3 +175,54 @@ def test_url():\n     assert request.url.port is None\n     assert request.url.path == \"/abc\"\n     assert request.url.raw_path == b\"/abc?foo=bar\"\n+\n+\n+def test_request_picklable():\n+    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    assert pickle_request.method == \"POST\"\n+    assert pickle_request.url.path == \"/\"\n+    assert pickle_request.headers[\"Content-Type\"] == \"application/json\"\n+    assert pickle_request.content == b'{\"test\": 123}'\n+    assert pickle_request.stream is not None\n+    assert request.headers == {\n+        \"Host\": \"example.org\",\n+        \"Content-Type\": \"application/json\",\n+        \"content-length\": \"13\",\n+    }\n+\n+\n+@pytest.mark.asyncio\n+async def test_request_async_streaming_content_picklable():\n+    async def streaming_body(data):\n+        yield data\n+\n+    data = streaming_body(b\"test 123\")\n+    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    with pytest.raises(httpx.RequestNotRead):\n+        pickle_request.content\n+    with pytest.raises(httpx.ResponseClosed):  # TODO: StreamClosed\n+        await pickle_request.aread()\n+\n+    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n+    await request.aread()\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    assert pickle_request.content == b\"test 123\"\n+\n+\n+def test_request_generator_content_picklable():\n+    def content():\n+        yield b\"test 123\"  # pragma: nocover\n+\n+    request = httpx.Request(\"POST\", \"http://example.org\", content=content())\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    with pytest.raises(httpx.RequestNotRead):\n+        pickle_request.content\n+    with pytest.raises(httpx.ResponseClosed):  # TODO: StreamClosed",
      "comment": "```suggestion\r\n    with pytest.raises(https.StreamClosed):\r\n```",
      "comment_id": 617388000,
      "user": "lovelydinosaur",
      "created_at": "2021-04-21T10:04:31Z",
      "url": "https://github.com/encode/httpx/pull/1579#discussion_r617388000"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1579,
      "file_path": "tests/models/test_requests.py",
      "line": 205,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,3 +175,54 @@ def test_url():\n     assert request.url.port is None\n     assert request.url.path == \"/abc\"\n     assert request.url.raw_path == b\"/abc?foo=bar\"\n+\n+\n+def test_request_picklable():\n+    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    assert pickle_request.method == \"POST\"\n+    assert pickle_request.url.path == \"/\"\n+    assert pickle_request.headers[\"Content-Type\"] == \"application/json\"\n+    assert pickle_request.content == b'{\"test\": 123}'\n+    assert pickle_request.stream is not None\n+    assert request.headers == {\n+        \"Host\": \"example.org\",\n+        \"Content-Type\": \"application/json\",\n+        \"content-length\": \"13\",\n+    }\n+\n+\n+@pytest.mark.asyncio\n+async def test_request_async_streaming_content_picklable():\n+    async def streaming_body(data):\n+        yield data\n+\n+    data = streaming_body(b\"test 123\")\n+    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    with pytest.raises(httpx.RequestNotRead):\n+        pickle_request.content\n+    with pytest.raises(httpx.ResponseClosed):  # TODO: StreamClosed",
      "comment": "```suggestion\r\n    with pytest.raises(httpx.StreamClosed):\r\n```",
      "comment_id": 617388301,
      "user": "lovelydinosaur",
      "created_at": "2021-04-21T10:04:47Z",
      "url": "https://github.com/encode/httpx/pull/1579#discussion_r617388301"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1579,
      "file_path": "tests/models/test_requests.py",
      "line": 222,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,3 +175,54 @@ def test_url():\n     assert request.url.port is None\n     assert request.url.path == \"/abc\"\n     assert request.url.raw_path == b\"/abc?foo=bar\"\n+\n+\n+def test_request_picklable():\n+    request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    assert pickle_request.method == \"POST\"\n+    assert pickle_request.url.path == \"/\"\n+    assert pickle_request.headers[\"Content-Type\"] == \"application/json\"\n+    assert pickle_request.content == b'{\"test\": 123}'\n+    assert pickle_request.stream is not None\n+    assert request.headers == {\n+        \"Host\": \"example.org\",\n+        \"Content-Type\": \"application/json\",\n+        \"content-length\": \"13\",\n+    }\n+\n+\n+@pytest.mark.asyncio\n+async def test_request_async_streaming_content_picklable():\n+    async def streaming_body(data):\n+        yield data\n+\n+    data = streaming_body(b\"test 123\")\n+    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    with pytest.raises(httpx.RequestNotRead):\n+        pickle_request.content\n+    with pytest.raises(httpx.StreamClosed):\n+        await pickle_request.aread()\n+\n+    request = httpx.Request(\"POST\", \"http://example.org\", content=data)\n+    await request.aread()\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    assert pickle_request.content == b\"test 123\"\n+\n+\n+def test_request_generator_content_picklable():\n+    def content():\n+        yield b\"test 123\"  # pragma: nocover\n+\n+    request = httpx.Request(\"POST\", \"http://example.org\", content=content())\n+    pickle_request = pickle.loads(pickle.dumps(request))\n+    with pytest.raises(httpx.RequestNotRead):\n+        pickle_request.content\n+    with pytest.raises(https.StreamClosed):",
      "comment": "```suggestion\r\n    with pytest.raises(httpx.StreamClosed):\r\n```",
      "comment_id": 617390913,
      "user": "lovelydinosaur",
      "created_at": "2021-04-21T10:07:15Z",
      "url": "https://github.com/encode/httpx/pull/1579#discussion_r617390913"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1550,
      "file_path": "httpx/_transports/asgi.py",
      "line": 158,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,9 +155,14 @@ async def send(message: dict) -> None:\n         assert status_code is not None\n         assert response_headers is not None\n \n-        async def response_stream() -> typing.AsyncIterator[bytes]:\n-            yield b\"\".join(body_parts)\n+        class ASGIResponseStream(AsyncByteStream):",
      "comment": "Thoughts on moving this class definition at the module level? Doesn't seem like it encloses any data from this function call (that wouldn't be ideal anyway).",
      "comment_id": 611080353,
      "user": "florimondmanca",
      "created_at": "2021-04-10T18:52:31Z",
      "url": "https://github.com/encode/httpx/pull/1550#discussion_r611080353"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1550,
      "file_path": "httpx/_transports/base.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,6 +5,63 @@\n A = typing.TypeVar(\"A\", bound=\"AsyncBaseTransport\")\n \n \n+class SyncByteStream:\n+    def __iter__(self) -> typing.Iterator[bytes]:\n+        raise NotImplementedError(\n+            \"The '__iter__' method must be implemented.\"\n+        )  # pragma: nocover\n+        yield b\"\"  # pragma: nocover\n+\n+    def close(self) -> None:\n+        \"\"\"\n+        Subclasses can override this method to release any network resources\n+        after a request/response cycle is complete.\n+\n+        Streaming cases should call use a `try...finally` block to ensure that",
      "comment": "```suggestion\r\n        Streaming cases should use a `try...finally` block to ensure that\r\n```",
      "comment_id": 611080393,
      "user": "florimondmanca",
      "created_at": "2021-04-10T18:53:05Z",
      "url": "https://github.com/encode/httpx/pull/1550#discussion_r611080393"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1550,
      "file_path": "httpx/_transports/default.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -182,19 +182,23 @@ def handle_request(\n                 ext=extensions,\n             )\n \n-        def response_stream() -> typing.Iterator[bytes]:\n-            with map_httpcore_exceptions():\n-                for part in byte_stream:\n-                    yield part\n+        class ResponseStream(SyncByteStream):",
      "comment": "Same here, how about moving this to the module level?",
      "comment_id": 611080531,
      "user": "florimondmanca",
      "created_at": "2021-04-10T18:54:31Z",
      "url": "https://github.com/encode/httpx/pull/1550#discussion_r611080531"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1550,
      "file_path": "httpx/_transports/default.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,19 +276,23 @@ async def handle_async_request(\n                 ext=extensions,\n             )\n \n-        async def response_stream() -> typing.AsyncIterator[bytes]:\n-            with map_httpcore_exceptions():\n-                async for part in byte_stream:\n-                    yield part\n+        class ResponseStream(AsyncByteStream):\n+            def __init__(self, httpcore_stream: httpcore.AsyncByteStream):\n+                self._httpcore_stream = httpcore_stream\n+\n+            async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+                with map_httpcore_exceptions():\n+                    async for part in self._httpcore_stream:\n+                        yield part\n \n-        async def aclose() -> None:\n-            with map_httpcore_exceptions():\n-                await byte_stream.aclose()\n+            async def aclose(self) -> None:\n+                with map_httpcore_exceptions():\n+                    await byte_stream.aclose()",
      "comment": "```suggestion\r\n                    await self._httpcore_stream.aclose()\r\n```",
      "comment_id": 611080559,
      "user": "florimondmanca",
      "created_at": "2021-04-10T18:55:04Z",
      "url": "https://github.com/encode/httpx/pull/1550#discussion_r611080559"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1539,
      "file_path": "httpx/_utils.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,7 +56,7 @@ def normalize_header_value(\n     return value.encode(encoding or \"ascii\")\n \n \n-def str_query_param(value: \"PrimitiveData\") -> str:\n+def primitive_value_to_str(value: \"PrimitiveData\") -> str:\n     \"\"\"\n     Coerce a primitive data type into a string value for query params.",
      "comment": "(Nit)\r\n\r\n```suggestion\r\n    Coerce a primitive data type into a string value.\r\n```",
      "comment_id": 601826129,
      "user": "florimondmanca",
      "created_at": "2021-03-25T20:43:46Z",
      "url": "https://github.com/encode/httpx/pull/1539#discussion_r601826129"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1503,
      "file_path": "httpx/_types.py",
      "line": 60,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,7 +51,11 @@\n \n CookieTypes = Union[\"Cookies\", CookieJar, Dict[str, str], List[Tuple[str, str]]]\n \n-CertTypes = Union[str, Tuple[str, str], Tuple[str, str, str]]\n+CertTypes = Union[\n+    str,\n+    Tuple[str, Optional[str]],\n+    Tuple[str, Optional[str], Optional[str]],",
      "comment": "We can add some comments to help readers, eg:\n\n```suggestion\n    # (cert, key, password)\n    Tuple[str, Optional[str], Optional[str]],\n```\n",
      "comment_id": 590725412,
      "user": "florimondmanca",
      "created_at": "2021-03-09T21:16:46Z",
      "url": "https://github.com/encode/httpx/pull/1503#discussion_r590725412"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1503,
      "file_path": "httpx/_types.py",
      "line": 60,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,7 +51,11 @@\n \n CookieTypes = Union[\"Cookies\", CookieJar, Dict[str, str], List[Tuple[str, str]]]\n \n-CertTypes = Union[str, Tuple[str, str], Tuple[str, str, str]]\n+CertTypes = Union[\n+    str,\n+    Tuple[str, Optional[str]],\n+    Tuple[str, Optional[str], Optional[str]],",
      "comment": "Ok, named them the same as arguments named in documentation.",
      "comment_id": 590732096,
      "user": "decaz",
      "created_at": "2021-03-09T21:27:42Z",
      "url": "https://github.com/encode/httpx/pull/1503#discussion_r590732096"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1465,
      "file_path": "tests/client/test_async_client.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,3 +301,22 @@ async def test_mounted_transport():\n         response = await client.get(\"custom://www.example.com\")\n         assert response.status_code == 200\n         assert response.json() == {\"app\": \"mounted\"}\n+\n+\n+@pytest.mark.usefixtures(\"async_environment\")\n+async def test_response_aclose_map_exceptions():\n+    class BrokenStream:\n+        async def __aiter__(self):\n+            # so we're an AsyncIterator\n+            pass  # pragma: nocover\n+\n+        async def aclose(self):\n+            raise httpcore.CloseError(OSError(104, \"Connection reset by peer\"))\n+\n+    def handle(request: httpx.Request) -> httpx.Response:\n+        return httpx.Response(200, stream=BrokenStream())\n+\n+    async with httpx.AsyncClient(transport=httpx.MockTransport(handle)) as client:\n+        async with client.stream(\"GET\", \"http://example.com\") as response:\n+            with pytest.raises(httpx.CloseError):\n+                await response.aclose()",
      "comment": "Am I correct saying this would also reproduce for a regular `client.request()`? If so, should we update this to\u2026?\r\n\r\n```suggestion\r\n        with pytest.raises(httpx.CloseError):\r\n            await client.request(\"GET\", \"http://example.com\")\r\n    \r\n        with pytest.raises(httpx.CloseError):\r\n            async with client.stream(\"GET\", \"http://example.com\"):\r\n                pass  # Close on exit.\r\n```\r\n\r\n(Also dropped the explicit `response.aclose()` since the expected behavior is that exiting the `stream()` async context manager would do that for us, and fail with the proper exception.)",
      "comment_id": 575128734,
      "user": "florimondmanca",
      "created_at": "2021-02-12T10:34:53Z",
      "url": "https://github.com/encode/httpx/pull/1465#discussion_r575128734"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1465,
      "file_path": "tests/client/test_async_client.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,3 +301,22 @@ async def test_mounted_transport():\n         response = await client.get(\"custom://www.example.com\")\n         assert response.status_code == 200\n         assert response.json() == {\"app\": \"mounted\"}\n+\n+\n+@pytest.mark.usefixtures(\"async_environment\")\n+async def test_response_aclose_map_exceptions():\n+    class BrokenStream:\n+        async def __aiter__(self):\n+            # so we're an AsyncIterator\n+            pass  # pragma: nocover\n+\n+        async def aclose(self):\n+            raise httpcore.CloseError(OSError(104, \"Connection reset by peer\"))\n+\n+    def handle(request: httpx.Request) -> httpx.Response:\n+        return httpx.Response(200, stream=BrokenStream())\n+\n+    async with httpx.AsyncClient(transport=httpx.MockTransport(handle)) as client:\n+        async with client.stream(\"GET\", \"http://example.com\") as response:\n+            with pytest.raises(httpx.CloseError):\n+                await response.aclose()",
      "comment": "You are correct. And the `await client.request()` test is a worthy addition.\r\n\r\nYou're the maintainer, so you are welcome to change to nix the `aclose()` in the test ... but first, I'll explain my motivation.\r\n\r\nDuring debugging, I was surprised by #1464 -- a broken stream raises the \"wrong\" error on shutdown.\r\n\r\nI imagine a reasonable `__aexit__()` might _handle_ an errno=104 error -- by doing nothing and raising nothing. So I aimed for an explicit test that avoids `__aexit__()`.\r\n\r\nThe change would be _correct_. But as a user, I find `__axit__()` behavior confusing; so I wrote a more-explicit test.",
      "comment_id": 575204954,
      "user": "adamhooper",
      "created_at": "2021-02-12T12:58:01Z",
      "url": "https://github.com/encode/httpx/pull/1465#discussion_r575204954"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1465,
      "file_path": "tests/client/test_async_client.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,3 +301,22 @@ async def test_mounted_transport():\n         response = await client.get(\"custom://www.example.com\")\n         assert response.status_code == 200\n         assert response.json() == {\"app\": \"mounted\"}\n+\n+\n+@pytest.mark.usefixtures(\"async_environment\")\n+async def test_response_aclose_map_exceptions():\n+    class BrokenStream:\n+        async def __aiter__(self):\n+            # so we're an AsyncIterator\n+            pass  # pragma: nocover\n+\n+        async def aclose(self):\n+            raise httpcore.CloseError(OSError(104, \"Connection reset by peer\"))\n+\n+    def handle(request: httpx.Request) -> httpx.Response:\n+        return httpx.Response(200, stream=BrokenStream())\n+\n+    async with httpx.AsyncClient(transport=httpx.MockTransport(handle)) as client:\n+        async with client.stream(\"GET\", \"http://example.com\") as response:\n+            with pytest.raises(httpx.CloseError):\n+                await response.aclose()",
      "comment": "Yup, I like the way @adamhooper has approached the test case here, too.",
      "comment_id": 577537371,
      "user": "lovelydinosaur",
      "created_at": "2021-02-17T11:31:45Z",
      "url": "https://github.com/encode/httpx/pull/1465#discussion_r577537371"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1469,
      "file_path": "httpx/_transports/wsgi.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -87,7 +87,7 @@ def request(\n             \"PATH_INFO\": unquote(path.decode(\"ascii\")),\n             \"QUERY_STRING\": query.decode(\"ascii\"),\n             \"SERVER_NAME\": host.decode(\"ascii\"),\n-            \"SERVER_PORT\": str(port),\n+            \"SERVER_PORT\": str(port or 80),",
      "comment": "I believe we need to handle HTTP (80) vs HTTPS (443). So let's properly compute the default port separately higher up this method\u2026?\r\n\r\n```python\r\nif port is None:\r\n    port = {b\"http\": 80, b\"https\": 443}[scheme]\r\n```",
      "comment_id": 576778013,
      "user": "florimondmanca",
      "created_at": "2021-02-16T12:14:41Z",
      "url": "https://github.com/encode/httpx/pull/1469#discussion_r576778013"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1399,
      "file_path": "httpx/_transports/default.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,131 @@\n+\"\"\"\n+Custom transports, with nicely configured defaults.\n+\n+The following additional keyword arguments are currently supported by httpcore...\n+\n+* uds: str\n+* local_address: str\n+* retries: int\n+* backend: str (\"auto\", \"asyncio\", \"trio\", \"curio\", \"anyio\", \"sync\")\n+\n+Example usages...\n+\n+# Disable HTTP/2 on a single specfic domain.",
      "comment": "This kind of super granular usage enabled by mounts is _really_ cool. :-)",
      "comment_id": 530566910,
      "user": "florimondmanca",
      "created_at": "2020-11-25T18:20:05Z",
      "url": "https://github.com/encode/httpx/pull/1399#discussion_r530566910"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1399,
      "file_path": "httpx/_transports/default.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,131 @@\n+\"\"\"\n+Custom transports, with nicely configured defaults.\n+\n+The following additional keyword arguments are currently supported by httpcore...\n+\n+* uds: str\n+* local_address: str\n+* retries: int\n+* backend: str (\"auto\", \"asyncio\", \"trio\", \"curio\", \"anyio\", \"sync\")\n+\n+Example usages...\n+\n+# Disable HTTP/2 on a single specfic domain.\n+mounts = {\n+    \"all://\": httpx.HTTPTransport(http2=True),\n+    \"all://*example.org\": httpx.HTTPTransport()\n+}\n+\n+# Using advanced httpcore configuration, with connection retries.\n+transport = httpx.HTTPTransport(retries=1)\n+client = httpx.Client(transport=transport)\n+\n+# Using advanced httpcore configuration, with unix domain sockets.\n+transport = httpx.HTTPTransport(uds=\"socket.uds\")\n+client = httpx.Client(transport=transport)\n+\"\"\"\n+import typing\n+from types import TracebackType\n+\n+import httpcore\n+\n+from .._config import DEFAULT_LIMITS, Limits, create_ssl_context\n+from .._types import CertTypes, VerifyTypes\n+\n+T = typing.TypeVar(\"T\")\n+Headers = typing.List[typing.Tuple[bytes, bytes]]\n+URL = typing.Tuple[bytes, bytes, typing.Optional[int], bytes]\n+\n+\n+class HTTPTransport(httpcore.SyncHTTPTransport):\n+    def __init__(\n+        self,\n+        verify: VerifyTypes = True,\n+        cert: CertTypes = None,\n+        http2: bool = False,\n+        limits: Limits = DEFAULT_LIMITS,\n+        trust_env: bool = True,\n+        **kwargs: typing.Any,\n+    ):",
      "comment": "(Nit) I think we need `-> None` in these constructors for mypy to take them into account when type checking... ?",
      "comment_id": 530567722,
      "user": "florimondmanca",
      "created_at": "2020-11-25T18:21:42Z",
      "url": "https://github.com/encode/httpx/pull/1399#discussion_r530567722"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1399,
      "file_path": "httpx/_transports/default.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,131 @@\n+\"\"\"\n+Custom transports, with nicely configured defaults.\n+\n+The following additional keyword arguments are currently supported by httpcore...\n+\n+* uds: str\n+* local_address: str\n+* retries: int\n+* backend: str (\"auto\", \"asyncio\", \"trio\", \"curio\", \"anyio\", \"sync\")\n+\n+Example usages...\n+\n+# Disable HTTP/2 on a single specfic domain.",
      "comment": "Indeed!\r\nI've added this one to the docs too, now.",
      "comment_id": 531551955,
      "user": "lovelydinosaur",
      "created_at": "2020-11-27T11:42:15Z",
      "url": "https://github.com/encode/httpx/pull/1399#discussion_r531551955"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1399,
      "file_path": "httpx/_transports/default.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,134 @@\n+\"\"\"\n+Custom transports, with nicely configured defaults.\n+\n+The following additional keyword arguments are currently supported by httpcore...\n+\n+* uds: str\n+* local_address: str\n+* retries: int\n+* backend: str (\"auto\", \"asyncio\", \"trio\", \"curio\", \"anyio\", \"sync\")\n+\n+Example usages...\n+\n+# Disable HTTP/2 on a single specfic domain.\n+mounts = {\n+    \"all://\": httpx.HTTPTransport(http2=True),\n+    \"all://*example.org\": httpx.HTTPTransport()\n+}\n+\n+# Using advanced httpcore configuration, with connection retries.\n+transport = httpx.HTTPTransport(retries=1)\n+client = httpx.Client(transport=transport)\n+\n+# Using advanced httpcore configuration, with unix domain sockets.\n+transport = httpx.HTTPTransport(uds=\"socket.uds\")\n+client = httpx.Client(transport=transport)\n+\"\"\"\n+import typing\n+from types import TracebackType\n+\n+import httpcore\n+\n+from .._config import DEFAULT_LIMITS, Limits, create_ssl_context\n+from .._types import CertTypes, VerifyTypes\n+\n+T = typing.TypeVar(\"T\", bound=\"HTTPTransport\")\n+A = typing.TypeVar(\"A\", bound=\"AsyncHTTPTransport\")\n+Headers = typing.List[typing.Tuple[bytes, bytes]]\n+URL = typing.Tuple[bytes, bytes, typing.Optional[int], bytes]\n+\n+\n+class HTTPTransport(httpcore.SyncHTTPTransport):\n+    def __init__(\n+        self,\n+        verify: VerifyTypes = True,\n+        cert: CertTypes = None,\n+        http2: bool = False,\n+        limits: Limits = DEFAULT_LIMITS,\n+        trust_env: bool = True,\n+        **kwargs: typing.Any,",
      "comment": "Final thoughts on `**kwargs` vs explicit params? I had switched to explicit params in #1431. My idea there was avoiding the [kwargs problem](http://ivory.idyll.org/blog/on-kwargs.html). I can see the benefit of `**kwargs` for maintainability (additions in HTTPCore are directly available in HTTPX without a code change), but at the same time there's a case to be made for readability & user experience. Was curious about your opinion. :-)",
      "comment_id": 552568019,
      "user": "florimondmanca",
      "created_at": "2021-01-06T12:38:54Z",
      "url": "https://github.com/encode/httpx/pull/1399#discussion_r552568019"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1426,
      "file_path": "httpx/_models.py",
      "line": 444,
      "side": "RIGHT",
      "diff_hunk": "@@ -441,7 +441,7 @@ def __init__(self, *args: QueryParamTypes, **kwargs: typing.Any) -> None:\n             items = parse_qsl(value)\n         elif isinstance(value, QueryParams):\n             items = value.multi_items()\n-        elif isinstance(value, list):\n+        elif type(value) in [list, tuple]:",
      "comment": "From the [docs for `type()`](https://docs.python.org/3.8/library/functions.html#type):\r\n> The `isinstance()` built-in function is recommended for testing the type of an object, because it takes subclasses into account.\r\n\r\nThis would be better written as:\r\n```suggestion\r\n        elif any(isinstance(value, t) for t in [list, tuple]):\r\n```",
      "comment_id": 541113627,
      "user": "StephenBrown2",
      "created_at": "2020-12-11T17:36:45Z",
      "url": "https://github.com/encode/httpx/pull/1426#discussion_r541113627"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1426,
      "file_path": "httpx/_models.py",
      "line": 444,
      "side": "RIGHT",
      "diff_hunk": "@@ -441,7 +441,7 @@ def __init__(self, *args: QueryParamTypes, **kwargs: typing.Any) -> None:\n             items = parse_qsl(value)\n         elif isinstance(value, QueryParams):\n             items = value.multi_items()\n-        elif isinstance(value, list):\n+        elif type(value) in [list, tuple]:",
      "comment": "In theory any `Sequence` of 2-tuples would do. We _could_ consider switching to `isinstance(value, typing.Sequence)`. But hmm, I don't think there's much of a case for anything else than lists and tuples, so this sounds good enough.",
      "comment_id": 541150439,
      "user": "florimondmanca",
      "created_at": "2020-12-11T18:39:54Z",
      "url": "https://github.com/encode/httpx/pull/1426#discussion_r541150439"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1426,
      "file_path": "httpx/_models.py",
      "line": 444,
      "side": "RIGHT",
      "diff_hunk": "@@ -441,7 +441,7 @@ def __init__(self, *args: QueryParamTypes, **kwargs: typing.Any) -> None:\n             items = parse_qsl(value)\n         elif isinstance(value, QueryParams):\n             items = value.multi_items()\n-        elif isinstance(value, list):\n+        elif type(value) in [list, tuple]:",
      "comment": "I'm also in favor of using the more generic `Sequence`, makes the docs easier to change as well.",
      "comment_id": 541186266,
      "user": "StephenBrown2",
      "created_at": "2020-12-11T19:18:08Z",
      "url": "https://github.com/encode/httpx/pull/1426#discussion_r541186266"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1426,
      "file_path": "httpx/_models.py",
      "line": 444,
      "side": "RIGHT",
      "diff_hunk": "@@ -441,7 +441,7 @@ def __init__(self, *args: QueryParamTypes, **kwargs: typing.Any) -> None:\n             items = parse_qsl(value)\n         elif isinstance(value, QueryParams):\n             items = value.multi_items()\n-        elif isinstance(value, list):\n+        elif type(value) in [list, tuple]:",
      "comment": "Even better is this... :)\n\n```python\nif isinstance(value, (tuple, list)): ...\n```",
      "comment_id": 541551432,
      "user": "florimondmanca",
      "created_at": "2020-12-12T10:41:07Z",
      "url": "https://github.com/encode/httpx/pull/1426#discussion_r541551432"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1426,
      "file_path": "httpx/_models.py",
      "line": 444,
      "side": "RIGHT",
      "diff_hunk": "@@ -441,7 +441,7 @@ def __init__(self, *args: QueryParamTypes, **kwargs: typing.Any) -> None:\n             items = parse_qsl(value)\n         elif isinstance(value, QueryParams):\n             items = value.multi_items()\n-        elif isinstance(value, list):\n+        elif type(value) in [list, tuple]:",
      "comment": "Hey, sorry for the ignorance of mypy, but this error message seems to make no sense to me:\r\n\r\nhttpx/_models.py:445: error: Incompatible types in assignment (expression has type \"Union[**Sequence[Tuple[str, Union[str, int, float, bool, None]]]**, str, bytes]\", variable has type \"**Sequence[Tuple[str, Union[str, int, float, bool, None]]]**\")\r\n\r\nDoes anyone have an idea what I am doing wrong here?\r\n\r\n",
      "comment_id": 541597256,
      "user": "SarunasAzna",
      "created_at": "2020-12-12T14:51:58Z",
      "url": "https://github.com/encode/httpx/pull/1426#discussion_r541597256"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1426,
      "file_path": "httpx/_models.py",
      "line": 444,
      "side": "RIGHT",
      "diff_hunk": "@@ -441,7 +441,7 @@ def __init__(self, *args: QueryParamTypes, **kwargs: typing.Any) -> None:\n             items = parse_qsl(value)\n         elif isinstance(value, QueryParams):\n             items = value.multi_items()\n-        elif isinstance(value, list):\n+        elif type(value) in [list, tuple]:",
      "comment": "As per `isinstance(value, Sequence)` - it is a bit too broad. For example - String is also isinstance of Sequence:\r\n```\r\n>>> isinstance('asfd', Sequence)\r\nTrue\r\n```",
      "comment_id": 541634440,
      "user": "SarunasAzna",
      "created_at": "2020-12-12T15:55:22Z",
      "url": "https://github.com/encode/httpx/pull/1426#discussion_r541634440"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1411,
      "file_path": "httpx/_models.py",
      "line": 1504,
      "side": "RIGHT",
      "diff_hunk": "@@ -1491,6 +1491,20 @@ def __bool__(self) -> bool:\n             return True\n         return False\n \n+    def __repr__(self) -> str:\n+        template = \"<Cookie {name}={value} for {domain} />\"\n+\n+        cookies_repr = \", \".join(\n+            [\n+                template.format(\n+                    name=cookie.name, value=cookie.value, domain=cookie.domain\n+                )\n+                for cookie in self.jar\n+            ]\n+        )",
      "comment": "(Nit) Possible simplification using f-strings:\r\n\r\n```suggestion\r\n        cookies_repr = \", \".join(\r\n            f\"<Cookie {cookie.name}={cookie.value} for {cookie.domain} />\"\r\n            for cookie in self.jar\r\n        )\r\n```",
      "comment_id": 534447007,
      "user": "florimondmanca",
      "created_at": "2020-12-02T20:04:25Z",
      "url": "https://github.com/encode/httpx/pull/1411#discussion_r534447007"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1277,
      "file_path": "httpx/_models.py",
      "line": 916,
      "side": "RIGHT",
      "diff_hunk": "@@ -912,19 +913,28 @@ def read(self) -> bytes:\n             self._content = b\"\".join(self.iter_bytes())\n         return self._content\n \n-    def iter_bytes(self) -> typing.Iterator[bytes]:\n+    def iter_bytes(self, chunk_size: int = None) -> typing.Iterator[bytes]:",
      "comment": "Are you sure about chunk_size with default `None`?\r\n\r\n I do agree that it looks more suitable, but `requests` provides us with defaults [chunk_size=1](https://2.python-requests.org/en/master/_modules/requests/models/#Response.iter_content) or [512](https://2.python-requests.org/en/master/_modules/requests/models/#Response.iter_lines)",
      "comment_id": 486452226,
      "user": "cdeler",
      "created_at": "2020-09-10T15:52:22Z",
      "url": "https://github.com/encode/httpx/pull/1277#discussion_r486452226"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1277,
      "file_path": "httpx/_models.py",
      "line": 976,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,10 +968,17 @@ def iter_raw(self) -> typing.Iterator[bytes]:\n \n         self.is_stream_consumed = True\n         self._num_bytes_downloaded = 0\n+        chunker = ByteChunker(chunk_size=chunk_size)\n+\n         with map_exceptions(HTTPCORE_EXC_MAP, request=self._request):\n-            for part in self._raw_stream:\n-                self._num_bytes_downloaded += len(part)\n-                yield part\n+            for raw_stream_bytes in self._raw_stream:\n+                self._num_bytes_downloaded += len(raw_stream_bytes)\n+                for chunk in chunker.decode(raw_stream_bytes):",
      "comment": "~What do you think about~\r\n\r\n```python3\r\nyield from chunker.decode(raw_stream_bytes)\r\n# ...\r\nyield from chunker.flush()\r\n```\r\n~(I know this approach is not applicable for `async` copy of this function, but may be we can use it  there?)~\r\n\r\nMy bad,`decode` is not a generator function",
      "comment_id": 486455366,
      "user": "cdeler",
      "created_at": "2020-09-10T15:56:52Z",
      "url": "https://github.com/encode/httpx/pull/1277#discussion_r486455366"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1277,
      "file_path": "httpx/_models.py",
      "line": 916,
      "side": "RIGHT",
      "diff_hunk": "@@ -912,19 +913,28 @@ def read(self) -> bytes:\n             self._content = b\"\".join(self.iter_bytes())\n         return self._content\n \n-    def iter_bytes(self) -> typing.Iterator[bytes]:\n+    def iter_bytes(self, chunk_size: int = None) -> typing.Iterator[bytes]:",
      "comment": "In this PR, when `chunk_size=None` we just return the input `content` unchanged, as one single big chunk.\r\n\r\nYes, this would deviate from what Requests seems to do, but:\r\n\r\n- Setting a non-`None` default would break backward compatibility on our side.\r\n- Defaulting to \"transparently pass the chunk sent by the server\" is probably the most reasonable approach _anyway_.\r\n\r\nThat said, we'd need to add this deviation from Requests to the compatibility guide. :+1:",
      "comment_id": 502757453,
      "user": "florimondmanca",
      "created_at": "2020-10-10T07:11:36Z",
      "url": "https://github.com/encode/httpx/pull/1277#discussion_r502757453"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1362,
      "file_path": "httpx/_client.py",
      "line": 630,
      "side": "RIGHT",
      "diff_hunk": "@@ -626,7 +627,12 @@ def __init__(\n             )\n             for key, proxy in proxy_map.items()\n         }\n-        self._proxies = dict(sorted(self._proxies.items()))\n+        if mounts is not None:",
      "comment": "Do I understand correctly that the mounts overrides proxies? Like:\r\n```python\r\nclient = Client(..., proxies={\"http://\": SomeTransport()}, ..., mounts={\"http://\": SomeOtherTransport())\r\nassert isinstance(client._mounts[\"http://\"], SomeOtherTransport)\r\n```\r\nDo we need to outline it somewhere?",
      "comment_id": 506405555,
      "user": "cdeler",
      "created_at": "2020-10-16T13:17:00Z",
      "url": "https://github.com/encode/httpx/pull/1362#discussion_r506405555"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1362,
      "file_path": "httpx/_client.py",
      "line": 690,
      "side": "RIGHT",
      "diff_hunk": "@@ -681,7 +687,7 @@ def _transport_for_url(self, url: URL) -> httpcore.SyncHTTPTransport:\n         Returns the transport instance that should be used for a given URL.\n         This will either be the standard connection pool, or a proxy.\n         \"\"\"\n-        for pattern, transport in self._proxies.items():\n+        for pattern, transport in self._mounts.items():",
      "comment": "So only the thing, why we introduce `self._mounts` is a lookup over the dict items.\r\n\r\nThen why it's a dictionary? May we have a list with tuples there?\r\n\r\n_Update_: the only benefit we get from `self._mounts` presented by dict is the keys uniques.",
      "comment_id": 506410229,
      "user": "cdeler",
      "created_at": "2020-10-16T13:20:38Z",
      "url": "https://github.com/encode/httpx/pull/1362#discussion_r506410229"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1362,
      "file_path": "httpx/_models.py",
      "line": 1476,
      "side": "RIGHT",
      "diff_hunk": "@@ -1473,7 +1473,7 @@ def __init__(self, response: Response):\n         def info(self) -> email.message.Message:\n             info = email.message.Message()\n             for key, value in self.response.headers.multi_items():\n-                # \u00a0Note that setting `info[key]` here is an \"append\" operation,\n+                # Note that setting `info[key]` here is an \"append\" operation,",
      "comment": "there is one extra non-breakable space in this comment\r\nhttps://github.com/encode/httpx/blob/07229b8dff61d3e9d819244d4835f547cae67b4d/httpx/_status_codes.py#L142\r\n\r\n(I found it using `grep -r httpx -e \"$(printf '\\302\\240')\"` snippet)",
      "comment_id": 507587122,
      "user": "cdeler",
      "created_at": "2020-10-19T09:03:17Z",
      "url": "https://github.com/encode/httpx/pull/1362#discussion_r507587122"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1368,
      "file_path": "httpx/_multipart.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,9 +19,11 @@ class DataField:\n \n     def __init__(self, name: str, value: typing.Union[str, bytes]) -> None:\n         if not isinstance(name, str):\n-            raise TypeError(\"Invalid type for name. Expected str.\")\n+            raise TypeError(f\"Invalid type for name. Expected str, \"\n+                            f\"got {type(name).__name__}: {name!r}\")",
      "comment": "```suggestion\r\n            raise TypeError(\r\n                f\"Invalid type for name. Expected str, got {type(name)}: {name!r}\"\r\n            )\r\n```",
      "comment_id": 511991636,
      "user": "florimondmanca",
      "created_at": "2020-10-26T14:14:33Z",
      "url": "https://github.com/encode/httpx/pull/1368#discussion_r511991636"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1368,
      "file_path": "httpx/_multipart.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,9 +19,11 @@ class DataField:\n \n     def __init__(self, name: str, value: typing.Union[str, bytes]) -> None:\n         if not isinstance(name, str):\n-            raise TypeError(\"Invalid type for name. Expected str.\")\n+            raise TypeError(f\"Invalid type for name. Expected str, \"\n+                            f\"got {type(name).__name__}: {name!r}\")\n         if not isinstance(value, (str, bytes)):\n-            raise TypeError(\"Invalid type for value. Expected str or bytes.\")\n+            raise TypeError(f\"Invalid type for value. Expected str or bytes, \"\n+                            f\"got {type(value).__name__}: {value!r}\")",
      "comment": "```suggestion\r\n            raise TypeError(\r\n                f\"Invalid type for value. Expected str or bytes, got {type(value)}: {value!r}\"\r\n            )\r\n```",
      "comment_id": 511991985,
      "user": "florimondmanca",
      "created_at": "2020-10-26T14:15:00Z",
      "url": "https://github.com/encode/httpx/pull/1368#discussion_r511991985"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1357,
      "file_path": "tests/test_asgi.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,6 +23,15 @@ async def echo_path(scope, receive, send):\n     await send({\"type\": \"http.response.body\", \"body\": output})\n \n \n+async def echo_raw_path(scope, receive, send):\n+    status = 200\n+    output = json.dumps({\"raw_path\": repr(scope[\"raw_path\"])}).encode(\"utf-8\")",
      "comment": "I'm using `repr(scope[\"raw_path\"])` here as an easy way to confirm that the value is indeed a Python bytestring - it ends up being returned as `\"b'/user%40example.org'\"` in the JSON.",
      "comment_id": 502169081,
      "user": "simonw",
      "created_at": "2020-10-09T03:44:33Z",
      "url": "https://github.com/encode/httpx/pull/1357#discussion_r502169081"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1357,
      "file_path": "tests/test_asgi.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,6 +23,15 @@ async def echo_path(scope, receive, send):\n     await send({\"type\": \"http.response.body\", \"body\": output})\n \n \n+async def echo_raw_path(scope, receive, send):\n+    status = 200\n+    output = json.dumps({\"raw_path\": repr(scope[\"raw_path\"])}).encode(\"utf-8\")",
      "comment": "Yup that make sense.\r\n\r\nI guess it might look a bit confusing to future readers, so we could either:\r\n\r\n1. Comment it.\r\n2. Switch it around to `{\"raw_path\": scope[\"raw_path\"].decode(\"ascii\")}`\r\n\r\nI'd marginally prefer (2), since it's actually perfectly sufficient here, but I'm okay enough with either.",
      "comment_id": 502312785,
      "user": "lovelydinosaur",
      "created_at": "2020-10-09T09:43:18Z",
      "url": "https://github.com/encode/httpx/pull/1357#discussion_r502312785"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1349,
      "file_path": "tests/models/test_url.py",
      "line": 302,
      "side": "RIGHT",
      "diff_hunk": "@@ -287,3 +287,37 @@ def test_url_with_url_encoded_path():\n     assert url.path == \"/path to somewhere\"\n     assert url.query == b\"\"\n     assert url.raw_path == b\"/path%20to%20somewhere\"\n+\n+\n+def test_ipv6_url():\n+    url = httpx.URL(\"http://[::ffff:192.168.0.1]:5678/\")\n+\n+    assert url.host == \"::ffff:192.168.0.1\"\n+    assert url.netloc == \"[::ffff:192.168.0.1]:5678\"\n+\n+\n+@pytest.mark.parametrize(\n+    \"url_str\",\n+    [\n+        \"http://192.168.0.1:1234\",",
      "comment": "The test with this parameter doesn't make sense.\r\n```suggestion\r\n        \"http://127.0.0.1:1234\",\r\n```",
      "comment_id": 501269107,
      "user": "cdeler",
      "created_at": "2020-10-07T19:49:42Z",
      "url": "https://github.com/encode/httpx/pull/1349#discussion_r501269107"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1349,
      "file_path": "tests/models/test_url.py",
      "line": 304,
      "side": "RIGHT",
      "diff_hunk": "@@ -287,3 +287,37 @@ def test_url_with_url_encoded_path():\n     assert url.path == \"/path to somewhere\"\n     assert url.query == b\"\"\n     assert url.raw_path == b\"/path%20to%20somewhere\"\n+\n+\n+def test_ipv6_url():\n+    url = httpx.URL(\"http://[::ffff:192.168.0.1]:5678/\")\n+\n+    assert url.host == \"::ffff:192.168.0.1\"\n+    assert url.netloc == \"[::ffff:192.168.0.1]:5678\"\n+\n+\n+@pytest.mark.parametrize(\n+    \"url_str\",\n+    [\n+        \"http://127.0.0.1:1234\",\n+        \"http://example.com:1234\",\n+        \"http://[::ffff:192.168.0.2]:1234\",",
      "comment": "Change this host as the above\r\n```suggestion\r\n        \"http://[::ffff:127.0.0.1]:1234\",\r\n```",
      "comment_id": 501269781,
      "user": "cdeler",
      "created_at": "2020-10-07T19:50:59Z",
      "url": "https://github.com/encode/httpx/pull/1349#discussion_r501269781"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 1803,
      "side": "LEFT",
      "diff_hunk": "@@ -1800,7 +1811,7 @@ def __init__(\n         self.timeout = timeout\n         self.close_client = close_client\n \n-    def __enter__(self) -> \"Response\":",
      "comment": "I don't think there's any reason to change this line.",
      "comment_id": 498258787,
      "user": "lovelydinosaur",
      "created_at": "2020-10-01T13:49:26Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498258787"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 1803,
      "side": "LEFT",
      "diff_hunk": "@@ -1800,7 +1811,7 @@ def __init__(\n         self.timeout = timeout\n         self.close_client = close_client\n \n-    def __enter__(self) -> \"Response\":",
      "comment": "Yeah, if nobody is going to subclass StreamContextManager",
      "comment_id": 498284498,
      "user": "Congee",
      "created_at": "2020-10-01T14:23:34Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498284498"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "Wondering if we should have a comment here linking to https://www.python.org/dev/peps/pep-0484/#annotating-instance-and-class-methods (?)",
      "comment_id": 498301492,
      "user": "lovelydinosaur",
      "created_at": "2020-10-01T14:45:33Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498301492"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "Did, and added some reasons behind the change here \ud83d\ude09 ",
      "comment_id": 498316180,
      "user": "Congee",
      "created_at": "2020-10-01T15:04:44Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498316180"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "I'm ok with it. @tomchristie I can make a change if you agree",
      "comment_id": 498321994,
      "user": "Congee",
      "created_at": "2020-10-01T15:12:39Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498321994"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "May just be bikeshedding, if so ignore me. I'm not sure if there is actually a name that neatly encapsulates the concept of an upper bounded type variable. Maybe not worth trying :)",
      "comment_id": 498335011,
      "user": "johtso",
      "created_at": "2020-10-01T15:30:29Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498335011"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "Possible colors to paint the shed: `TClient` `AnyClient` `ClientSubtype`",
      "comment_id": 498340434,
      "user": "johtso",
      "created_at": "2020-10-01T15:38:07Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498340434"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "I guess(?) I'd probably prefer that we follow the PEP and stick with `T`.",
      "comment_id": 498351213,
      "user": "lovelydinosaur",
      "created_at": "2020-10-01T15:53:32Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498351213"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "So, what's the conclusion here? I can make a change",
      "comment_id": 498367771,
      "user": "Congee",
      "created_at": "2020-10-01T16:20:09Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498367771"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "I'd also personally go for `T` (or `C`, or whatevs), as `_Client` feels more like a \"private base class\" than a \"generic bounded type variable\".",
      "comment_id": 498399659,
      "user": "florimondmanca",
      "created_at": "2020-10-01T17:16:57Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498399659"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "Will make a change. Keep in mind that switching to `T = TypeVar('T', covariant=True)` loses the ability to use `TypeVar(.., bound=...)`. After all, `T` is a generic name used everywhere and python's typing system does not support namespace.",
      "comment_id": 498402246,
      "user": "Congee",
      "created_at": "2020-10-01T17:21:51Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498402246"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1336,
      "file_path": "httpx/_client.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +493,9 @@ def _redirect_stream(\n         return request.stream\n \n \n+_Client = typing.TypeVar(\"_Client\", bound=\"Client\")",
      "comment": "As I anticipated, lacking of namespace causes trouble. The following works:\r\n```python\r\nT = typing.TypeVar(\"T\", bound=\"Client\")\r\nU = typing.TypeVar(\"U\", bound=\"AsyncClient\")\r\n```\r\nWhat do you think?",
      "comment_id": 498407924,
      "user": "Congee",
      "created_at": "2020-10-01T17:31:59Z",
      "url": "https://github.com/encode/httpx/pull/1336#discussion_r498407924"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1326,
      "file_path": "tests/models/test_headers.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,7 +23,8 @@ def test_headers():\n     assert dict(h) == {\"a\": \"123, 456\", \"b\": \"789\"}\n     assert repr(h) == \"Headers([('a', '123'), ('a', '456'), ('b', '789')])\"\n     assert h == httpx.Headers([(\"a\", \"123\"), (\"b\", \"789\"), (\"a\", \"456\")])\n-    assert h != [(\"a\", \"123\"), (\"A\", \"456\"), (\"b\", \"789\")]\n+    assert h == [(\"a\", \"123\"), (\"A\", \"456\"), (\"b\", \"789\")]\n+    assert h == {\"a\": \"123\", \"A\": \"456\", \"b\": \"789\"}",
      "comment": "To keep coverage at 100% we'll also need a test against a no-headers-like item.\r\n\r\nEg...\r\n\r\n```python\r\nassert h != \"a: 123\\nA: 456\\nb: 789\"\r\n```",
      "comment_id": 494853446,
      "user": "lovelydinosaur",
      "created_at": "2020-09-25T09:08:27Z",
      "url": "https://github.com/encode/httpx/pull/1326#discussion_r494853446"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1246,
      "file_path": "httpx/_client.py",
      "line": 799,
      "side": "RIGHT",
      "diff_hunk": "@@ -765,6 +794,10 @@ def _send_handling_auth(\n \n         auth_flow = auth.auth_flow(request)\n         request = next(auth_flow)\n+\n+        for hook in self._event_hooks[\"request\"]:\n+            hook(request)",
      "comment": "Getting my thoughts down here \u2014 are we sure this is the correct/best place to call `request` hooks? AFAICS Requests does not provide a `request` hook so we're in green field here.\r\n\r\nThere are a few options that I can see\u2026\r\n\r\n1. In `.send()` or at the beginning of `_send_handling_redirects()` - Hide redirect requests, auth requests, retries requests.\r\n1. At the beginning of `._send_handling_auth()` - Hide auth requests, retries requests.\r\n1. At the beginning of `._send_single_request()` - Hide retries requests.\r\n\r\nAs I understand it, currently this PR suggests option 2/.\r\n\r\nBut interestingly the `response` hook is located at level 1/. So in case of a redirect, we'd have `request` hooks called twice or more, but `response` hooks called once.\r\n\r\nIs this appropriate, or do we want `request` being called only once (for the initial request) (which corresponds to option 1/)?\r\n\r\nAnother data point from the monitoring use case perspective \u2014 I can see that the Datadog/Requests tracer integration [wraps `requests.Session.send()`](https://github.com/DataDog/dd-trace-py/blob/master/ddtrace/contrib/requests/connection.py), which _I think_ corresponds to case 1/ above.\r\n\r\nPerhaps there's a case to be made about having `request`, `redirect_request`, `auth_request`, and `single_request` hooks, or perhaps just `request` and `single_request`, or\u2026? And then, should we match them up with corresponding `response_*` hooks?\r\n\r\nI guess for simplicity we'd really want option 1/, i.e. call `request` hooks before calling `._send_handling_redirects()`, and call `response` hooks on the received resolved response?",
      "comment_id": 481971442,
      "user": "florimondmanca",
      "created_at": "2020-09-02T10:39:07Z",
      "url": "https://github.com/encode/httpx/pull/1246#discussion_r481971442"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1246,
      "file_path": "tests/client/test_event_hooks.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,113 @@\n+import pytest\n+\n+import httpx\n+\n+\n+def test_event_hooks(server):",
      "comment": "It seems we're not testing for \"request hooks are called on redirect requests\", which makes me think the decision to put request hooks at the top of `._send_handling_auth()` was not entirely deliberate? :-)\r\n\r\nAny case, whichever we decide I guess we'd need to add explicit tests for what we expect to happen as requests and responses go through the send-redirects-auth-(retries soon) stack?",
      "comment_id": 481978992,
      "user": "florimondmanca",
      "created_at": "2020-09-02T10:52:20Z",
      "url": "https://github.com/encode/httpx/pull/1246#discussion_r481978992"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1269,
      "file_path": "httpx/_decoders.py",
      "line": 176,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,12 +167,13 @@ def __init__(self, encoding: typing.Optional[str] = None):\n \n     def decode(self, data: bytes) -> str:\n         if self.decoder is None:\n-            self.decoder = codecs.getincrementaldecoder(\"utf-8\")(errors=\"strict\")\n+            attempt_utf_8 = codecs.getincrementaldecoder(\"utf-8\")(errors=\"strict\")\n             try:\n-                return self.decoder.decode(data)\n+                attempt_utf_8.decode(data)\n             except UnicodeDecodeError:\n-                self.decoder = codecs.getincrementaldecoder(\"cp1251\")(errors=\"ignore\")\n-                return self.decoder.decode(data)\n+                self.decoder = codecs.getincrementaldecoder(\"cp1252\")(errors=\"replace\")\n+            else:\n+                self.decoder = codecs.getincrementaldecoder(\"utf-8\")(errors=\"replace\")",
      "comment": "Why `(\"utf-8\")(errors=\"replace\")` here if it passed with `(\"utf-8\")(errors=\"strict\")` to get here?",
      "comment_id": 485695550,
      "user": "StephenBrown2",
      "created_at": "2020-09-09T15:18:15Z",
      "url": "https://github.com/encode/httpx/pull/1269#discussion_r485695550"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1269,
      "file_path": "httpx/_decoders.py",
      "line": 176,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,12 +167,13 @@ def __init__(self, encoding: typing.Optional[str] = None):\n \n     def decode(self, data: bytes) -> str:\n         if self.decoder is None:\n-            self.decoder = codecs.getincrementaldecoder(\"utf-8\")(errors=\"strict\")\n+            attempt_utf_8 = codecs.getincrementaldecoder(\"utf-8\")(errors=\"strict\")\n             try:\n-                return self.decoder.decode(data)\n+                attempt_utf_8.decode(data)\n             except UnicodeDecodeError:\n-                self.decoder = codecs.getincrementaldecoder(\"cp1251\")(errors=\"ignore\")\n-                return self.decoder.decode(data)\n+                self.decoder = codecs.getincrementaldecoder(\"cp1252\")(errors=\"replace\")\n+            else:\n+                self.decoder = codecs.getincrementaldecoder(\"utf-8\")(errors=\"replace\")",
      "comment": "We need `strict` to raise an error if it doesn't appear to decode as UTF-8, but once we've made the decision we use `errors=\"replace\"` for the most robust behaviour possible. So eg. if we've got a streaming response that initially appears to be UTF-8, but later has some non-UTF-8 bytes, then we're not raising a hard error on accessing `.text`.\r\n\r\n(We'd like it to have a failure mode that is as graceful as possible.)",
      "comment_id": 485716138,
      "user": "lovelydinosaur",
      "created_at": "2020-09-09T15:46:37Z",
      "url": "https://github.com/encode/httpx/pull/1269#discussion_r485716138"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1281,
      "file_path": "tests/utils.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,3 +22,90 @@ def override_log_level(log_level: str):\n     finally:\n         # Reset the logger so we don't have verbose output in all unit tests\n         logging.getLogger(\"httpx\").handlers = []\n+\n+\n+class MockTransport(httpcore.SyncHTTPTransport):\n+    def __init__(self, handler: Callable) -> None:\n+        self.handler = handler\n+\n+    def request(\n+        self,\n+        method: bytes,\n+        url: Tuple[bytes, bytes, Optional[int], bytes],\n+        headers: List[Tuple[bytes, bytes]] = None,\n+        stream: httpcore.SyncByteStream = None,\n+        timeout: Mapping[str, Optional[float]] = None,\n+    ) -> Tuple[bytes, int, bytes, List[Tuple[bytes, bytes]], httpcore.SyncByteStream]:\n+        raw_scheme, raw_host, port, raw_path = url\n+        scheme = raw_scheme.decode(\"ascii\")\n+        host = raw_host.decode(\"ascii\")\n+        port_str = \"\" if port is None else f\":{port}\"\n+        path = raw_path.decode(\"ascii\")\n+\n+        request_headers = httpx.Headers(headers)\n+        data = (\n+            (item for item in stream)\n+            if stream\n+            and (\n+                \"Content-Length\" in request_headers\n+                or \"Transfer-Encoding\" in request_headers\n+            )",
      "comment": "It's a bit fiddly to explain why we're having to do this at the moment, but it's related to some of the grungy bits that need ironing out in #1253.\r\n\r\nI'll resolve it as part of a follow-up.",
      "comment_id": 487003977,
      "user": "lovelydinosaur",
      "created_at": "2020-09-11T12:13:41Z",
      "url": "https://github.com/encode/httpx/pull/1281#discussion_r487003977"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1265,
      "file_path": "httpx/_content_streams.py",
      "line": 400,
      "side": "RIGHT",
      "diff_hunk": "@@ -402,3 +388,18 @@ def encode(\n         return IteratorStream(iterator=data)\n \n     raise TypeError(f\"Unexpected type for 'data', {type(data)!r}\")\n+\n+\n+def encode_response(content: ResponseContent = None) -> ContentStream:\n+    if content is None:\n+        return ByteStream(b\"\")\n+    elif isinstance(content, bytes):\n+        return ByteStream(body=content)\n+    elif hasattr(content, \"__aiter__\"):\n+        content = typing.cast(typing.AsyncIterator[bytes], content)\n+        return AsyncIteratorStream(aiterator=content)",
      "comment": "Maybe you were already aware, but a thing I just learned from reviewing encode/starlette#1041: `collections.abc.AsyncIterator`/`collections.abc.Iterator` (which the `typing` equivalents derive from) have [a subclasshook](https://github.com/python/cpython/blob/v3.8.5/Lib/_collections_abc.py#L185-L189) which I think means you could just do:\r\n```python\r\n    elif isinstance(content, typing.AsyncIterator):\r\n          return AsyncIteratorStream(aiterator=content)\r\n```\r\n\r\nAlso _technically_ you may be casting Iterables to _Iterators_ here by just checking for the presence of `__aiter__`, though it seems unlikely to cause problems.",
      "comment_id": 486924364,
      "user": "JayH5",
      "created_at": "2020-09-11T09:45:48Z",
      "url": "https://github.com/encode/httpx/pull/1265#discussion_r486924364"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1127,
      "file_path": "tests/client/test_proxies.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,3 +247,21 @@ def test_proxies_environ(monkeypatch, client_class, url, env, expected):\n         assert transport == client._transport\n     else:\n         assert transport.proxy_origin == url_to_origin(expected)\n+\n+\n+@pytest.mark.parametrize(\n+    [\"proxies\", \"expected_scheme\"],\n+    [\n+        ({\"http\": \"http://127.0.0.1\"}, [\"http://\"]),\n+        ({\"https\": \"http://127.0.0.1\"}, [\"https://\"]),\n+        ({\"all\": \"http://127.0.0.1\"}, [\"all://\"]),\n+    ],\n+)\n+def test_for_deprecated_proxy_params(proxies, expected_scheme):\n+    with pytest.deprecated_call() as block:\n+        httpx.AsyncClient(proxies=proxies)\n+\n+    warning_message = str(block.pop(DeprecationWarning))\n+\n+    for scheme in expected_scheme:\n+        assert scheme in warning_message",
      "comment": "Could this be simplified to this by converting `expected_scheme` to a plain string?\r\n\r\n```suggestion\r\n    assert expected_scheme in warning_message\r\n```",
      "comment_id": 465885359,
      "user": "florimondmanca",
      "created_at": "2020-08-05T17:23:27Z",
      "url": "https://github.com/encode/httpx/pull/1127#discussion_r465885359"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1127,
      "file_path": "tests/client/test_proxies.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,3 +247,21 @@ def test_proxies_environ(monkeypatch, client_class, url, env, expected):\n         assert transport == client._transport\n     else:\n         assert transport.proxy_origin == url_to_origin(expected)\n+\n+\n+@pytest.mark.parametrize(\n+    [\"proxies\", \"expected_scheme\"],\n+    [\n+        ({\"http\": \"http://127.0.0.1\"}, [\"http://\"]),\n+        ({\"https\": \"http://127.0.0.1\"}, [\"https://\"]),\n+        ({\"all\": \"http://127.0.0.1\"}, [\"all://\"]),\n+    ],\n+)\n+def test_for_deprecated_proxy_params(proxies, expected_scheme):\n+    with pytest.deprecated_call() as block:\n+        httpx.AsyncClient(proxies=proxies)\n+\n+    warning_message = str(block.pop(DeprecationWarning))\n+\n+    for scheme in expected_scheme:\n+        assert scheme in warning_message",
      "comment": "Yeah I think that was walking through the *characters* in the string. :)",
      "comment_id": 465890018,
      "user": "lovelydinosaur",
      "created_at": "2020-08-05T17:31:34Z",
      "url": "https://github.com/encode/httpx/pull/1127#discussion_r465890018"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1127,
      "file_path": "tests/client/test_proxies.py",
      "line": 257,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,3 +247,20 @@ def test_proxies_environ(monkeypatch, client_class, url, env, expected):\n         assert transport == client._transport\n     else:\n         assert transport.proxy_origin == url_to_origin(expected)\n+\n+\n+@pytest.mark.parametrize(\n+    [\"proxies\", \"expected_scheme\"],\n+    [\n+        ({\"http\": \"http://127.0.0.1\"}, [\"http://\"]),\n+        ({\"https\": \"http://127.0.0.1\"}, [\"https://\"]),\n+        ({\"all\": \"http://127.0.0.1\"}, [\"all://\"]),",
      "comment": "```suggestion\r\n        ({\"http\": \"http://127.0.0.1\"}, \"http://\"),\r\n        ({\"https\": \"http://127.0.0.1\"}, \"https://\"),\r\n        ({\"all\": \"http://127.0.0.1\"}, \"all://\"),\r\n```",
      "comment_id": 465890681,
      "user": "florimondmanca",
      "created_at": "2020-08-05T17:32:44Z",
      "url": "https://github.com/encode/httpx/pull/1127#discussion_r465890681"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1127,
      "file_path": "tests/client/test_proxies.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,3 +247,21 @@ def test_proxies_environ(monkeypatch, client_class, url, env, expected):\n         assert transport == client._transport\n     else:\n         assert transport.proxy_origin == url_to_origin(expected)\n+\n+\n+@pytest.mark.parametrize(\n+    [\"proxies\", \"expected_scheme\"],\n+    [\n+        ({\"http\": \"http://127.0.0.1\"}, [\"http://\"]),\n+        ({\"https\": \"http://127.0.0.1\"}, [\"https://\"]),\n+        ({\"all\": \"http://127.0.0.1\"}, [\"all://\"]),\n+    ],\n+)\n+def test_for_deprecated_proxy_params(proxies, expected_scheme):\n+    with pytest.deprecated_call() as block:\n+        httpx.AsyncClient(proxies=proxies)\n+\n+    warning_message = str(block.pop(DeprecationWarning))\n+\n+    for scheme in expected_scheme:\n+        assert scheme in warning_message",
      "comment": "No, it was correct (I expect CI to fail now! ;-)), but `expected_scheme` was unecessarily a 1-item list. Sent a patch\u2026",
      "comment_id": 465891189,
      "user": "florimondmanca",
      "created_at": "2020-08-05T17:33:39Z",
      "url": "https://github.com/encode/httpx/pull/1127#discussion_r465891189"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1217,
      "file_path": "tests/client/test_auth.py",
      "line": 681,
      "side": "RIGHT",
      "diff_hunk": "@@ -641,3 +666,23 @@ def test_sync_auth_reads_response_body() -> None:\n     response = client.get(url, auth=auth)\n     assert response.status_code == 200\n     assert response.json() == {\"auth\": '{\"auth\": \"xyz\"}'}\n+\n+\n+@pytest.mark.asyncio\n+async def test_sync_async_auth() -> None:\n+    \"\"\"\n+    Test that we can use a different auth flow implementation in the async case, to\n+    support cases that require performing I/O or using concurrency primitives (such\n+    as checking a disk-based cache or fetching a token from a remote auth server).\n+    \"\"\"\n+    url = \"https://example.org/\"\n+    auth = SyncOrAsyncAuth()\n+\n+    client = AsyncClient(transport=AsyncMockTransport())",
      "comment": "Let's use `async with AsyncClient(...) as client` here, since we're starting to get strict about that now.\n\nMay as well also use the same for the sync case too, just for consistency within the test case.",
      "comment_id": 478466315,
      "user": "lovelydinosaur",
      "created_at": "2020-08-27T14:34:14Z",
      "url": "https://github.com/encode/httpx/pull/1217#discussion_r478466315"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1217,
      "file_path": "httpx/_client.py",
      "line": 764,
      "side": "RIGHT",
      "diff_hunk": "@@ -760,15 +760,12 @@ def _send_handling_auth(\n         auth: Auth,\n         timeout: Timeout,\n     ) -> Response:\n-        if auth.requires_request_body:\n-            request.read()\n+        auth_flow = auth.sync_auth_flow(request)\n+        request = auth_flow.send(None)  # type: ignore",
      "comment": "Wondering which of `auth_flow.send(None)` vs `next(auth_flow)` we should prefer for this? I don't really mind either way, but I guess whichever we stick with we should use consistently across:\n\n* The docs.\n* The client implementation.\n* The auth implementation.",
      "comment_id": 478469471,
      "user": "lovelydinosaur",
      "created_at": "2020-08-27T14:38:26Z",
      "url": "https://github.com/encode/httpx/pull/1217#discussion_r478469471"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1217,
      "file_path": "httpx/_client.py",
      "line": 764,
      "side": "RIGHT",
      "diff_hunk": "@@ -760,15 +760,12 @@ def _send_handling_auth(\n         auth: Auth,\n         timeout: Timeout,\n     ) -> Response:\n-        if auth.requires_request_body:\n-            request.read()\n+        auth_flow = auth.sync_auth_flow(request)\n+        request = auth_flow.send(None)  # type: ignore",
      "comment": "I'll stick to our current usage of `next()` / `.__anext__()` for the purpose of this PR. Given that this works more nicely with type checking it's a pretty okay approach.",
      "comment_id": 479677095,
      "user": "florimondmanca",
      "created_at": "2020-08-29T18:31:14Z",
      "url": "https://github.com/encode/httpx/pull/1217#discussion_r479677095"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1217,
      "file_path": "httpx/_auth.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,6 +51,56 @@ def auth_flow(self, request: Request) -> typing.Generator[Request, Response, Non\n         \"\"\"",
      "comment": "Should we raise a `NotImplementedError()` here by default?",
      "comment_id": 484334303,
      "user": "lovelydinosaur",
      "created_at": "2020-09-07T10:10:45Z",
      "url": "https://github.com/encode/httpx/pull/1217#discussion_r484334303"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1217,
      "file_path": "httpx/_auth.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,6 +51,56 @@ def auth_flow(self, request: Request) -> typing.Generator[Request, Response, Non\n         \"\"\"",
      "comment": "Okay, I can see we're using `Auth()` in no-auth cases at the moment, so no that wouldn't work trivially.\r\nMight be something to think about there, but let's treat it separately if we do.",
      "comment_id": 485615914,
      "user": "lovelydinosaur",
      "created_at": "2020-09-09T13:35:24Z",
      "url": "https://github.com/encode/httpx/pull/1217#discussion_r485615914"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1249,
      "file_path": "tests/models/test_responses.py",
      "line": 34,
      "side": "LEFT",
      "diff_hunk": "@@ -31,7 +30,6 @@ def test_response():\n     assert response.text == \"Hello, world!\"\n     assert response.request.method == \"GET\"\n     assert response.request.url == \"https://example.org\"\n-    assert response.elapsed >= datetime.timedelta(0)",
      "comment": "Haven't checked, do we still have some tests for the `response.elapsed` property?",
      "comment_id": 482256717,
      "user": "florimondmanca",
      "created_at": "2020-09-02T17:50:41Z",
      "url": "https://github.com/encode/httpx/pull/1249#discussion_r482256717"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1249,
      "file_path": "tests/models/test_responses.py",
      "line": 34,
      "side": "LEFT",
      "diff_hunk": "@@ -31,7 +30,6 @@ def test_response():\n     assert response.text == \"Hello, world!\"\n     assert response.request.method == \"GET\"\n     assert response.request.url == \"https://example.org\"\n-    assert response.elapsed >= datetime.timedelta(0)",
      "comment": "Yup `test_client.py` and `test_async_client.py` check the property, and `test_responses.py` has a test to ensure that it's not accessible until the response has been closed.",
      "comment_id": 482802379,
      "user": "lovelydinosaur",
      "created_at": "2020-09-03T08:30:22Z",
      "url": "https://github.com/encode/httpx/pull/1249#discussion_r482802379"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1259,
      "file_path": "httpx/_models.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,8 +71,10 @@ def __init__(self, url: URLTypes = \"\", params: QueryParamTypes = None) -> None:\n                 # We don't want to normalize relative URLs, since doing so\n                 # removes any leading `../` portion.\n                 self._uri_reference = self._uri_reference.normalize()\n-        else:\n+        elif isinstance(url, URL):\n             self._uri_reference = url._uri_reference\n+        else:\n+            raise TypeError(\"Invalid type for url.  Expected str or httpx.URL\")",
      "comment": "(Nit) Consider showing the received type of `url`\r\n\r\n```suggestion\r\n            raise TypeError(f\"Expected url to be an str or httpx.URL, got {type(url)}\")\r\n```",
      "comment_id": 483835011,
      "user": "florimondmanca",
      "created_at": "2020-09-04T20:39:38Z",
      "url": "https://github.com/encode/httpx/pull/1259#discussion_r483835011"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,6 +56,18 @@\n KEEPALIVE_EXPIRY = 5.0\n \n \n+def check_not_closed(method: typing.Callable) -> typing.Callable:",
      "comment": "I'd prefer for us *not* to use a decorator style.\r\nI'll use inline comments below to walk through the alternative...\r\n",
      "comment_id": 472950631,
      "user": "lovelydinosaur",
      "created_at": "2020-08-19T11:14:03Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r472950631"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 642,
      "side": "RIGHT",
      "diff_hunk": "@@ -619,6 +639,7 @@ def _transport_for_url(self, url: URL) -> httpcore.SyncHTTPTransport:\n \n         return self._transport\n \n+    @check_not_closed",
      "comment": "I guess we should instead put the check around `def send()` rather than `def request()`.",
      "comment_id": 472951243,
      "user": "lovelydinosaur",
      "created_at": "2020-08-19T11:15:13Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r472951243"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 642,
      "side": "RIGHT",
      "diff_hunk": "@@ -619,6 +639,7 @@ def _transport_for_url(self, url: URL) -> httpcore.SyncHTTPTransport:\n \n         return self._transport\n \n+    @check_not_closed",
      "comment": "Rather than the decorator, I'd prefer the plainer style of starting the method with...\r\n\r\n```python\r\nif self._is_closed:\r\n   raise RuntimeError(\"Cannot send requests on a closed client instance.\")\r\n```",
      "comment_id": 472951806,
      "user": "lovelydinosaur",
      "created_at": "2020-08-19T11:16:18Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r472951806"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 1039,
      "side": "RIGHT",
      "diff_hunk": "@@ -1015,6 +1036,7 @@ def delete(\n             timeout=timeout,\n         )\n \n+    @check_not_closed",
      "comment": "Could we instead just let things pass silently if the client is already closed, and `.close()` is called again?\r\nSo...\r\n\r\n```python\r\nif not self._is_closed:\r\n    self._transport.close()\r\n    for proxy in self._proxies.values():\r\n        if proxy is not None:\r\n            proxy.close()",
      "comment_id": 472952614,
      "user": "lovelydinosaur",
      "created_at": "2020-08-19T11:17:56Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r472952614"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 1657,
      "side": "RIGHT",
      "diff_hunk": "@@ -1628,6 +1654,8 @@ async def aclose(self) -> None:\n             if proxy is not None:\n                 await proxy.aclose()\n \n+        self._is_closed = True",
      "comment": "We should put `self._is_closed = True` as the very first line, rather than the very last line, since that'd handle potential race conditions more cleanly.",
      "comment_id": 472953172,
      "user": "lovelydinosaur",
      "created_at": "2020-08-19T11:19:04Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r472953172"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,6 +56,18 @@\n KEEPALIVE_EXPIRY = 5.0\n \n \n+def check_not_closed(method: typing.Callable) -> typing.Callable:",
      "comment": "I've removed the decorator. Simple is better than complex.",
      "comment_id": 472963455,
      "user": "cdeler",
      "created_at": "2020-08-19T11:38:36Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r472963455"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 642,
      "side": "RIGHT",
      "diff_hunk": "@@ -619,6 +639,7 @@ def _transport_for_url(self, url: URL) -> httpcore.SyncHTTPTransport:\n \n         return self._transport\n \n+    @check_not_closed",
      "comment": "> I guess we should instead put the check around def send() rather than def request().\r\n\r\nDone\r\n\r\n> Rather than the decorator, I'd prefer the plainer style of starting the method with...\r\n\r\nDone, but I used `self.is_closed` in the condition\r\n",
      "comment_id": 472963913,
      "user": "cdeler",
      "created_at": "2020-08-19T11:39:26Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r472963913"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 1657,
      "side": "RIGHT",
      "diff_hunk": "@@ -1628,6 +1654,8 @@ async def aclose(self) -> None:\n             if proxy is not None:\n                 await proxy.aclose()\n \n+        self._is_closed = True",
      "comment": "@tomchristie It a bit confuses me, since there should be another ways to avoid race conditions, e.g. locks. ",
      "comment_id": 472964894,
      "user": "cdeler",
      "created_at": "2020-08-19T11:40:56Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r472964894"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 1657,
      "side": "RIGHT",
      "diff_hunk": "@@ -1628,6 +1654,8 @@ async def aclose(self) -> None:\n             if proxy is not None:\n                 await proxy.aclose()\n \n+        self._is_closed = True",
      "comment": "I saw several same places where race condition _is possible_ \r\n\r\nI can try to write a test, which strictly cause a race condition here (if it's possible)",
      "comment_id": 472965687,
      "user": "cdeler",
      "created_at": "2020-08-19T11:42:23Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r472965687"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 1701,
      "side": "RIGHT",
      "diff_hunk": "@@ -1649,6 +1673,18 @@ async def __aexit__(\n     ) -> None:\n         await self.aclose()\n \n+    def __del__(self) -> None:\n+        if not self.is_closed:\n+            warnings.warn(\n+                f\"Unclosed {self!r}. \"\n+                \"Please call\\n\"\n+                \"\\t>>> await async_client.aclose()\\n\"\n+                \"or use it as a context manager\\n\"\n+                \"\\t>>> async with httpx.AsyncClient() as client:\\n\"\n+                \"\\t>>>     ...\",\n+                ResourceWarning,\n+            )",
      "comment": "Right, I'm going to suggest that we use `UserWarning` for this case, for better visibility.\r\n\r\nWe'll eventually end up tracking individual connections with proper a `ResourceWarning` against each of those, but this is a good case for a higher-level warning I think.\r\n\r\nAlso, let's make sure to use a more concise warning format.\r\n\r\nPerhaps...\r\n\r\n```python\r\nwarnings.warn(\"Unclosed {self!r}. See https://www.python-httpx.org/async/#opening-and-closing-clients for details.\")\r\n```\r\n\r\nThen we can add a little more context in the documentation.\r\n\r\nWhat do we think?",
      "comment_id": 474644263,
      "user": "lovelydinosaur",
      "created_at": "2020-08-21T11:41:17Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r474644263"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 1701,
      "side": "RIGHT",
      "diff_hunk": "@@ -1649,6 +1673,18 @@ async def __aexit__(\n     ) -> None:\n         await self.aclose()\n \n+    def __del__(self) -> None:\n+        if not self.is_closed:\n+            warnings.warn(\n+                f\"Unclosed {self!r}. \"\n+                \"Please call\\n\"\n+                \"\\t>>> await async_client.aclose()\\n\"\n+                \"or use it as a context manager\\n\"\n+                \"\\t>>> async with httpx.AsyncClient() as client:\\n\"\n+                \"\\t>>>     ...\",\n+                ResourceWarning,\n+            )",
      "comment": "Developing libraries/SDKs, I try to avoid to use such warnings as `UserWarning`. This warning is for users' applications, not for a middle layer, presented by the SDK. Users should be able to separate their warning and `httpx` warnings.\r\n\r\nBut I definitely agree with you, that `ResourceWarning` (unfortunately) is too silent for this case.\r\n",
      "comment_id": 474660321,
      "user": "cdeler",
      "created_at": "2020-08-21T12:18:07Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r474660321"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1197,
      "file_path": "httpx/_client.py",
      "line": 1701,
      "side": "RIGHT",
      "diff_hunk": "@@ -1649,6 +1673,18 @@ async def __aexit__(\n     ) -> None:\n         await self.aclose()\n \n+    def __del__(self) -> None:\n+        if not self.is_closed:\n+            warnings.warn(\n+                f\"Unclosed {self!r}. \"\n+                \"Please call\\n\"\n+                \"\\t>>> await async_client.aclose()\\n\"\n+                \"or use it as a context manager\\n\"\n+                \"\\t>>> async with httpx.AsyncClient() as client:\\n\"\n+                \"\\t>>>     ...\",\n+                ResourceWarning,\n+            )",
      "comment": "@tomchristie \r\nI changed the warning type to `UserWarning`, then I have to fix a lot of warning in the project tests (it's a separated commit)",
      "comment_id": 474684818,
      "user": "cdeler",
      "created_at": "2020-08-21T13:07:46Z",
      "url": "https://github.com/encode/httpx/pull/1197#discussion_r474684818"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1243,
      "file_path": "tests/models/test_responses.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,17 +20,24 @@ async def async_streaming_body():\n \n \n def test_response():\n-    response = httpx.Response(200, content=b\"Hello, world!\", request=REQUEST)\n+    response = httpx.Response(\n+        200,\n+        content=b\"Hello, world!\",\n+        request=httpx.Request(\"GET\", \"https://example.org\"),\n+    )\n \n     assert response.status_code == 200\n     assert response.reason_phrase == \"OK\"\n     assert response.text == \"Hello, world!\"\n-    assert response.request is REQUEST\n+    assert response.request.method == \"GET\"\n+    assert response.request.url == \"https://example.org\"\n     assert response.elapsed >= datetime.timedelta(0)\n     assert not response.is_error\n \n \n def test_raise_for_status():\n+    REQUEST = httpx.Request(\"GET\", \"https://example.org\")",
      "comment": "I guess let's use the same \"use lowercase if not using globals\" convention here, even if it results in a slightly larger diff since we have to change the rest of this test case?\r\n```suggestion\r\n    request = httpx.Request(\"GET\", \"https://example.org\")\r\n```",
      "comment_id": 481419825,
      "user": "florimondmanca",
      "created_at": "2020-09-01T20:44:17Z",
      "url": "https://github.com/encode/httpx/pull/1243#discussion_r481419825"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1238,
      "file_path": "httpx/_models.py",
      "line": 863,
      "side": "RIGHT",
      "diff_hunk": "@@ -843,10 +858,14 @@ def raise_for_status(self) -> None:\n \n         if codes.is_client_error(self.status_code):\n             message = message.format(self, error_type=\"Client Error\")\n-            raise HTTPStatusError(message, request=self.request, response=self)\n+            if self._request is None:\n+                raise ValueError(message)\n+            raise HTTPStatusError(message, request=self._request, response=self)",
      "comment": "Raising a ValueError inside raise_for_status seems a bit off ?",
      "comment_id": 480428337,
      "user": "tbascoul",
      "created_at": "2020-08-31T22:13:42Z",
      "url": "https://github.com/encode/httpx/pull/1238#discussion_r480428337"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1238,
      "file_path": "httpx/_models.py",
      "line": 737,
      "side": "RIGHT",
      "diff_hunk": "@@ -726,6 +728,19 @@ def elapsed(self) -> datetime.timedelta:\n             )\n         return self._elapsed\n \n+    @property\n+    def request(self) -> Request:\n+        \"\"\"\n+        Returns the request instance associated to the current response.\n+        \"\"\"\n+        if self._request is None:\n+            raise RuntimeError(\"'.request' may only be accessed if initialized\")",
      "comment": "```suggestion\r\n            raise RuntimeError(\"The request instance has not been set on this response.\")\r\n```",
      "comment_id": 481136139,
      "user": "lovelydinosaur",
      "created_at": "2020-09-01T13:27:04Z",
      "url": "https://github.com/encode/httpx/pull/1238#discussion_r481136139"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1238,
      "file_path": "httpx/_models.py",
      "line": 863,
      "side": "RIGHT",
      "diff_hunk": "@@ -843,10 +858,14 @@ def raise_for_status(self) -> None:\n \n         if codes.is_client_error(self.status_code):\n             message = message.format(self, error_type=\"Client Error\")\n-            raise HTTPStatusError(message, request=self.request, response=self)\n+            if self._request is None:\n+                raise ValueError(message)\n+            raise HTTPStatusError(message, request=self._request, response=self)",
      "comment": "I'd suggest we start the method with something like...\r\n\r\n```python\r\nif self._request is None:\r\n    raise RuntimeError(\"Cannot call `raise_for_status` as the request instance has not been set on this response.\")\r\n```",
      "comment_id": 481137254,
      "user": "lovelydinosaur",
      "created_at": "2020-09-01T13:28:51Z",
      "url": "https://github.com/encode/httpx/pull/1238#discussion_r481137254"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1240,
      "file_path": "tests/client/test_auth.py",
      "line": 362,
      "side": "RIGHT",
      "diff_hunk": "@@ -354,6 +354,21 @@ async def test_digest_auth_returns_no_auth_if_no_digest_header_in_response() ->\n     assert len(response.history) == 0\n \n \n+def test_digest_auth_returns_no_auth_if_alternate_auth_scheme() -> None:\n+    url = \"https://example.org/\"\n+    auth = DigestAuth(username=\"tomchristie\", password=\"password123\")\n+    auth_header = b\"Token ...\"\n+\n+    client = Client(",
      "comment": "CI is failing, I guess this should be `httpx.Client`?",
      "comment_id": 480955747,
      "user": "florimondmanca",
      "created_at": "2020-09-01T08:15:00Z",
      "url": "https://github.com/encode/httpx/pull/1240#discussion_r480955747"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1218,
      "file_path": "httpx/_client.py",
      "line": 1053,
      "side": "RIGHT",
      "diff_hunk": "@@ -1043,7 +1047,10 @@ def __exit__(\n         exc_value: BaseException = None,\n         traceback: TracebackType = None,\n     ) -> None:\n-        self.close()\n+        self._transport.__exit__()\n+        for proxy in self._proxies.values():\n+            if proxy is not None:\n+                proxy.__exit__()",
      "comment": "I believe we need to send the exception information down, like this:\r\n\r\n```suggestion\r\n        self._transport.__exit__(exc_type, exc_value, traceback)\r\n        for proxy in self._proxies.values():\r\n            if proxy is not None:\r\n                proxy.__exit__(exc_type, exc_value, traceback)\r\n```\r\n\r\n(I'm actually surprised the code works without passing these - HTTPCore transports allow `= None` but I'm not _sure_ this is part of the context manager protocol strictly?)",
      "comment_id": 477206076,
      "user": "florimondmanca",
      "created_at": "2020-08-26T10:42:43Z",
      "url": "https://github.com/encode/httpx/pull/1218#discussion_r477206076"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1218,
      "file_path": "httpx/_client.py",
      "line": 1664,
      "side": "RIGHT",
      "diff_hunk": "@@ -1647,7 +1658,10 @@ async def __aexit__(\n         exc_value: BaseException = None,\n         traceback: TracebackType = None,\n     ) -> None:\n-        await self.aclose()\n+        await self._transport.__aexit__()\n+        for proxy in self._proxies.values():\n+            if proxy is not None:\n+                await proxy.__aexit__()",
      "comment": "```suggestion\r\n        await self._transport.__aexit__(exc_type, exc_value, traceback)\r\n        for proxy in self._proxies.values():\r\n            if proxy is not None:\r\n                await proxy.__aexit__(exc_type, exc_value, traceback)\r\n```",
      "comment_id": 477206186,
      "user": "florimondmanca",
      "created_at": "2020-08-26T10:42:57Z",
      "url": "https://github.com/encode/httpx/pull/1218#discussion_r477206186"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1218,
      "file_path": "tests/client/test_async_client.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,3 +167,38 @@ async def test_100_continue(server):\n \n     assert response.status_code == 200\n     assert response.content == data\n+\n+\n+@pytest.mark.usefixtures(\"async_environment\")\n+async def test_context_managed_transport():\n+    class Transport(httpcore.AsyncHTTPTransport):\n+        def __init__(self):\n+            self.events = []\n+\n+        async def aclose(self):\n+            self.events.append(\"transport.aclose\")\n+\n+        async def __aenter__(self):\n+            await super().__aenter__()\n+            self.events.append(\"transport.__aenter__\")\n+\n+        async def __aexit__(self):\n+            await super().__aexit__()",
      "comment": "```suggestion\r\n        async def __aexit__(self, *args):\r\n            await super().__aexit__(*args)\r\n```",
      "comment_id": 477206534,
      "user": "florimondmanca",
      "created_at": "2020-08-26T10:43:41Z",
      "url": "https://github.com/encode/httpx/pull/1218#discussion_r477206534"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1218,
      "file_path": "tests/client/test_client.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -208,3 +209,37 @@ def test_pool_limits_deprecated():\n \n     with pytest.warns(DeprecationWarning):\n         httpx.AsyncClient(pool_limits=limits)\n+\n+\n+def test_context_managed_transport():\n+    class Transport(httpcore.SyncHTTPTransport):\n+        def __init__(self):\n+            self.events = []\n+\n+        def close(self):\n+            self.events.append(\"transport.close\")\n+\n+        def __enter__(self):\n+            super().__enter__()\n+            self.events.append(\"transport.__enter__\")\n+\n+        def __exit__(self):\n+            super().__exit__()",
      "comment": "```suggestion\r\n        def __exit__(self, *args):\r\n            super().__exit__(*args)\r\n```",
      "comment_id": 477206895,
      "user": "florimondmanca",
      "created_at": "2020-08-26T10:44:27Z",
      "url": "https://github.com/encode/httpx/pull/1218#discussion_r477206895"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1218,
      "file_path": "tests/client/test_async_client.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,3 +167,38 @@ async def test_100_continue(server):\n \n     assert response.status_code == 200\n     assert response.content == data\n+\n+\n+@pytest.mark.usefixtures(\"async_environment\")\n+async def test_context_managed_transport():\n+    class Transport(httpcore.AsyncHTTPTransport):\n+        def __init__(self):\n+            self.events = []\n+\n+        async def aclose(self):\n+            self.events.append(\"transport.aclose\")\n+\n+        async def __aenter__(self):\n+            await super().__aenter__()\n+            self.events.append(\"transport.__aenter__\")\n+\n+        async def __aexit__(self):\n+            await super().__aexit__()\n+            self.events.append(\"transport.__aexit__\")\n+\n+    # Note that we're including 'proxies' here to *also* run through the\n+    # proxy context management, although we can't easily test that at the\n+    # moment, since we can't add proxies as transport instances.\n+    #\n+    # Once we have a more generalised Mount API we'll be able to remove this\n+    # in favour of ensuring all mounts are context managed, which will\n+    # also neccessarily include proxies.\n+    transport = Transport()\n+    async with httpx.AsyncClient(transport=transport, proxies=\"http://www.example.com\"):\n+        pass\n+\n+    assert transport.events == [\n+        \"transport.__aenter__\",\n+        \"transport.aclose\",\n+        \"transport.__aexit__\",\n+    ]",
      "comment": "I'm curious why `transport.aclose` is included at all here? Do we call `.aclose()` anywhere before `Client.__aexit__()`?\r\n\r\nEdit: hmm, probably because the base `.__aexit__()` implementation calls into `.aclose()`?",
      "comment_id": 477207333,
      "user": "florimondmanca",
      "created_at": "2020-08-26T10:45:18Z",
      "url": "https://github.com/encode/httpx/pull/1218#discussion_r477207333"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1218,
      "file_path": "tests/client/test_async_client.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,3 +167,38 @@ async def test_100_continue(server):\n \n     assert response.status_code == 200\n     assert response.content == data\n+\n+\n+@pytest.mark.usefixtures(\"async_environment\")\n+async def test_context_managed_transport():\n+    class Transport(httpcore.AsyncHTTPTransport):\n+        def __init__(self):\n+            self.events = []\n+\n+        async def aclose(self):\n+            self.events.append(\"transport.aclose\")\n+\n+        async def __aenter__(self):\n+            await super().__aenter__()\n+            self.events.append(\"transport.__aenter__\")\n+\n+        async def __aexit__(self):\n+            await super().__aexit__()\n+            self.events.append(\"transport.__aexit__\")\n+\n+    # Note that we're including 'proxies' here to *also* run through the\n+    # proxy context management, although we can't easily test that at the\n+    # moment, since we can't add proxies as transport instances.\n+    #\n+    # Once we have a more generalised Mount API we'll be able to remove this\n+    # in favour of ensuring all mounts are context managed, which will\n+    # also neccessarily include proxies.\n+    transport = Transport()\n+    async with httpx.AsyncClient(transport=transport, proxies=\"http://www.example.com\"):\n+        pass\n+\n+    assert transport.events == [\n+        \"transport.__aenter__\",\n+        \"transport.aclose\",\n+        \"transport.__aexit__\",\n+    ]",
      "comment": "Yes.\r\n\r\nThe base implementation is \"Just call `.close()`/`.aclose()`\".\r\n\r\nOne of the allowable things for a concrete transport to do is \"Just implement `close`/`aclose`\", which is in fact what our existing implementations do.\r\n\r\nThat gives us both the simple case, while still allowing *some* implementations to do more complex stuff with `__aenter__`, `__aexit__`.",
      "comment_id": 477213626,
      "user": "lovelydinosaur",
      "created_at": "2020-08-26T10:58:08Z",
      "url": "https://github.com/encode/httpx/pull/1218#discussion_r477213626"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1218,
      "file_path": "tests/client/test_async_client.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,3 +167,38 @@ async def test_100_continue(server):\n \n     assert response.status_code == 200\n     assert response.content == data\n+\n+\n+@pytest.mark.usefixtures(\"async_environment\")\n+async def test_context_managed_transport():\n+    class Transport(httpcore.AsyncHTTPTransport):\n+        def __init__(self):\n+            self.events = []\n+\n+        async def aclose(self):\n+            self.events.append(\"transport.aclose\")\n+\n+        async def __aenter__(self):\n+            await super().__aenter__()\n+            self.events.append(\"transport.__aenter__\")\n+\n+        async def __aexit__(self):\n+            await super().__aexit__()\n+            self.events.append(\"transport.__aexit__\")\n+\n+    # Note that we're including 'proxies' here to *also* run through the\n+    # proxy context management, although we can't easily test that at the\n+    # moment, since we can't add proxies as transport instances.\n+    #\n+    # Once we have a more generalised Mount API we'll be able to remove this\n+    # in favour of ensuring all mounts are context managed, which will\n+    # also neccessarily include proxies.\n+    transport = Transport()\n+    async with httpx.AsyncClient(transport=transport, proxies=\"http://www.example.com\"):\n+        pass\n+\n+    assert transport.events == [\n+        \"transport.__aenter__\",\n+        \"transport.aclose\",\n+        \"transport.__aexit__\",\n+    ]",
      "comment": "Actually maybe worth a comment there against the test case.",
      "comment_id": 477214707,
      "user": "lovelydinosaur",
      "created_at": "2020-08-26T11:00:19Z",
      "url": "https://github.com/encode/httpx/pull/1218#discussion_r477214707"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1200,
      "file_path": "httpx/_api.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,6 +114,11 @@ def stream(\n     cert: CertTypes = None,\n     trust_env: bool = True,\n ) -> StreamContextManager:\n+    \"\"\"\n+    Streaming response content.",
      "comment": "What do we think of some more elaborate copy like this...?\n\n```\nAlternative to `httpx.request()` that streams the response body instead of loading it into memory at once.\n\n**Parameters**: See `httpx.request`.\n\nSee also: [Streaming Responses][0]\n\n[0]: /quickstart#streaming-responses\n```\n\nAlso I think we could add this docstring onto `Client.stream` and `AsyncClient.stream` as well. :-)",
      "comment_id": 473659797,
      "user": "florimondmanca",
      "created_at": "2020-08-20T06:47:20Z",
      "url": "https://github.com/encode/httpx/pull/1200#discussion_r473659797"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1200,
      "file_path": "httpx/_api.py",
      "line": 248,
      "side": "RIGHT",
      "diff_hunk": "@@ -226,9 +231,7 @@ def head(\n     **Parameters**: See `httpx.request`.\n \n     Note that the `data`, `files`, and `json` parameters are not available on\n-    this function, as `HEAD` requests should not include a request body. The\n-    `HEAD` method also differs from the other cases in that `allow_redirects`\n-    defaults to `False`.\n+    this function, as `HEAD` requests should not include a request body.",
      "comment": "Should this be submitted as a separate cleanup PR?",
      "comment_id": 473660604,
      "user": "florimondmanca",
      "created_at": "2020-08-20T06:48:23Z",
      "url": "https://github.com/encode/httpx/pull/1200#discussion_r473660604"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1198,
      "file_path": "httpx/_api.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,6 +58,8 @@ def request(\n     request.\n     * **auth** - *(optional)* An authentication class to use when sending the\n     request.\n+    * **proxies** - *(optional)* A dictionary mapping HTTP protocols to proxy",
      "comment": "Perhaps \"mapping proxy keys to proxy URLs\"? Proxy routing supports more than just routing by HTTP protocol.",
      "comment_id": 473056600,
      "user": "florimondmanca",
      "created_at": "2020-08-19T14:06:54Z",
      "url": "https://github.com/encode/httpx/pull/1198#discussion_r473056600"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1190,
      "file_path": "tests/test_exceptions.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,6 +33,13 @@ def test_httpcore_exception_mapping() -> None:\n     with pytest.raises(httpx.ConnectError):\n         httpx.get(\"http://doesnotexist\")\n \n+    # Make sure Response.iter_raw() exceptinos are mapped",
      "comment": "```suggestion\r\n    # Make sure streaming methods also map exceptions.\r\n```",
      "comment_id": 472808359,
      "user": "florimondmanca",
      "created_at": "2020-08-19T07:34:02Z",
      "url": "https://github.com/encode/httpx/pull/1190#discussion_r472808359"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1170,
      "file_path": "tests/models/test_requests.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,6 +73,18 @@ async def streaming_body(data):\n     assert request.headers[\"Transfer-Encoding\"] == \"chunked\"\n \n \n+def test_ignore_transfer_encoding_header():",
      "comment": "Let's go for `test_ignore_transfer_encoding_if_content_length_exists`, and include a docstring linking to the issue that this resolves.",
      "comment_id": 468633320,
      "user": "lovelydinosaur",
      "created_at": "2020-08-11T14:39:31Z",
      "url": "https://github.com/encode/httpx/pull/1170#discussion_r468633320"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1155,
      "file_path": "httpx/__init__.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -109,3 +109,9 @@\n     \"DigestAuth\",\n     \"WSGITransport\",\n ]\n+\n+\n+_locals = locals()\n+for name in __all__:\n+    if not name.startswith(\"__\"):\n+        setattr(_locals[name], \"__module__\", \"httpx\")",
      "comment": "```suggestion\r\n        setattr(_locals[name], \"__module__\", \"httpx\"). # noqa\r\n```",
      "comment_id": 467904788,
      "user": "florimondmanca",
      "created_at": "2020-08-10T13:31:24Z",
      "url": "https://github.com/encode/httpx/pull/1155#discussion_r467904788"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1155,
      "file_path": "httpx/__init__.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -109,3 +109,9 @@\n     \"DigestAuth\",\n     \"WSGITransport\",\n ]\n+\n+\n+_locals = locals()\n+for name in __all__:\n+    if not name.startswith(\"__\"):\n+        setattr(_locals[name], \"__module__\", \"httpx\"). # noqa",
      "comment": "Oops, sorry!\r\n\r\n```suggestion\r\n        setattr(_locals[name], \"__module__\", \"httpx\")  # noqa\r\n```",
      "comment_id": 467905073,
      "user": "florimondmanca",
      "created_at": "2020-08-10T13:31:49Z",
      "url": "https://github.com/encode/httpx/pull/1155#discussion_r467905073"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1095,
      "file_path": "httpx/_decoders.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +50,8 @@ class DeflateDecoder(Decoder):\n     See: https://stackoverflow.com/questions/1838699\n     \"\"\"\n \n-    def __init__(self) -> None:\n+    def __init__(self, request: \"Request\") -> None:\n+        self.request = request",
      "comment": "? (Applicable to all other decoders here)\r\n\r\n```suggestion\r\n        super().__init__(request)\r\n```",
      "comment_id": 463129186,
      "user": "florimondmanca",
      "created_at": "2020-07-30T16:41:19Z",
      "url": "https://github.com/encode/httpx/pull/1095#discussion_r463129186"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1095,
      "file_path": "httpx/_exceptions.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,30 +37,26 @@\n     from ._models import Request, Response  # pragma: nocover\n \n \n-class HTTPError(Exception):\n+class RequestError(Exception):\n     \"\"\"\n-    Base class for all HTTPX exceptions.\n+    Base class for all exceptions that may occur when issuing a `.request()`.\n     \"\"\"\n \n-    def __init__(\n-        self, *args: typing.Any, request: \"Request\" = None, response: \"Response\" = None\n-    ) -> None:\n-        super().__init__(*args)\n-        self._request = request or (response.request if response is not None else None)\n-        self.response = response\n+    def __init__(self, message: str, *, request: \"Request\",) -> None:",
      "comment": "```suggestion\r\n    def __init__(self, message: str, *, request: \"Request\") -> None:\r\n```",
      "comment_id": 463130202,
      "user": "florimondmanca",
      "created_at": "2020-07-30T16:42:58Z",
      "url": "https://github.com/encode/httpx/pull/1095#discussion_r463130202"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1095,
      "file_path": "httpx/_exceptions.py",
      "line": 213,
      "side": "RIGHT",
      "diff_hunk": "@@ -100,76 +126,103 @@ class CloseError(NetworkError):\n # Other transport exceptions...\n \n \n-class ProxyError(HTTPError):\n+class ProxyError(TransportError):\n     \"\"\"\n     An error occurred while proxying a request.\n     \"\"\"\n \n \n-class ProtocolError(HTTPError):\n+class ProtocolError(TransportError):\n     \"\"\"\n     A protocol was violated by the server.\n     \"\"\"\n \n \n-# HTTP exceptions...\n+# Other request exceptions...\n \n \n-class DecodingError(HTTPError):\n+class DecodingError(RequestError):\n     \"\"\"\n     Decoding of the response failed.\n     \"\"\"\n \n \n-class HTTPStatusError(HTTPError):\n+class TooManyRedirects(RequestError):\n     \"\"\"\n-    Response sent an error HTTP status.\n+    Too many redirects.\n     \"\"\"\n \n-    def __init__(self, *args: typing.Any, response: \"Response\") -> None:\n-        super().__init__(*args)\n-        self._request = response.request\n-        self.response = response\n-\n \n-# Redirect exceptions...\n+class RequestBodyUnavailable(RequestError):\n+    \"\"\"\n+    Had to send the request again, but the request body was streaming, and is\n+    no longer available.\n+    \"\"\"\n \n \n-class RedirectError(HTTPError):\n+class InvalidURL(RequestError):\n     \"\"\"\n-    Base class for HTTP redirect errors.\n+    URL was missing a hostname, or was not one of HTTP/HTTPS.\n     \"\"\"\n \n \n-class TooManyRedirects(RedirectError):\n+# Client errors\n+\n+\n+class HTTPStatusError(Exception):\n     \"\"\"\n-    Too many redirects.\n+    Response sent an error HTTP status.\n+\n+    May be raised when calling `response.raise_for_status()`\n     \"\"\"\n \n+    def __init__(\n+        self, message: str, *, request: \"Request\", response: \"Response\"\n+    ) -> None:\n+        super().__init__(message)\n+        self.request = request\n+        self.response = response\n \n-class NotRedirectResponse(RedirectError):\n+\n+class NotRedirectResponse(Exception):\n     \"\"\"\n     Response was not a redirect response.\n+\n+    May be raised if `response.next()` is called without first\n+    properly checking `response.is_redirect`.\n     \"\"\"\n \n+    def __init__(self, message: str) -> None:\n+        super().__init__(message)\n+\n+\n+class CookieConflict(Exception):\n+    \"\"\"\n+    Attempted to lookup a cookie by name, but multiple cookies existed.\n+\n+    Can occur when calling `response.cookies.get(...)`\n+    \"\"\"\n+\n+    def __init__(self, message: str) -> None:\n+        super().__init__(message)\n+\n \n # Stream exceptions...\n \n+# These may occur as the result of a programming error, by accessing\n+# the request/respose stream in an invalid manner.",
      "comment": "```suggestion\r\n# the request/response stream in an invalid manner.\r\n```",
      "comment_id": 463131050,
      "user": "florimondmanca",
      "created_at": "2020-07-30T16:44:20Z",
      "url": "https://github.com/encode/httpx/pull/1095#discussion_r463131050"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1095,
      "file_path": "httpx/_exceptions.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -100,76 +126,103 @@ class CloseError(NetworkError):\n # Other transport exceptions...\n \n \n-class ProxyError(HTTPError):\n+class ProxyError(TransportError):\n     \"\"\"\n     An error occurred while proxying a request.\n     \"\"\"\n \n \n-class ProtocolError(HTTPError):\n+class ProtocolError(TransportError):\n     \"\"\"\n     A protocol was violated by the server.\n     \"\"\"\n \n \n-# HTTP exceptions...\n+# Other request exceptions...\n \n \n-class DecodingError(HTTPError):\n+class DecodingError(RequestError):\n     \"\"\"\n     Decoding of the response failed.\n     \"\"\"\n \n \n-class HTTPStatusError(HTTPError):\n+class TooManyRedirects(RequestError):\n     \"\"\"\n-    Response sent an error HTTP status.\n+    Too many redirects.\n     \"\"\"\n \n-    def __init__(self, *args: typing.Any, response: \"Response\") -> None:\n-        super().__init__(*args)\n-        self._request = response.request\n-        self.response = response\n-\n \n-# Redirect exceptions...\n+class RequestBodyUnavailable(RequestError):\n+    \"\"\"\n+    Had to send the request again, but the request body was streaming, and is\n+    no longer available.\n+    \"\"\"\n \n \n-class RedirectError(HTTPError):\n+class InvalidURL(RequestError):\n     \"\"\"\n-    Base class for HTTP redirect errors.\n+    URL was missing a hostname, or was not one of HTTP/HTTPS.\n     \"\"\"\n \n \n-class TooManyRedirects(RedirectError):\n+# Client errors\n+\n+\n+class HTTPStatusError(Exception):\n     \"\"\"\n-    Too many redirects.\n+    Response sent an error HTTP status.\n+\n+    May be raised when calling `response.raise_for_status()`\n     \"\"\"\n \n+    def __init__(\n+        self, message: str, *, request: \"Request\", response: \"Response\"\n+    ) -> None:\n+        super().__init__(message)\n+        self.request = request\n+        self.response = response\n \n-class NotRedirectResponse(RedirectError):\n+\n+class NotRedirectResponse(Exception):\n     \"\"\"\n     Response was not a redirect response.\n+\n+    May be raised if `response.next()` is called without first\n+    properly checking `response.is_redirect`.\n     \"\"\"\n \n+    def __init__(self, message: str) -> None:\n+        super().__init__(message)\n+\n+\n+class CookieConflict(Exception):\n+    \"\"\"\n+    Attempted to lookup a cookie by name, but multiple cookies existed.\n+\n+    Can occur when calling `response.cookies.get(...)`",
      "comment": "(I'm reviewing assuming these docstrings will end up in the public Developer Interface sometime in the near future \ud83d\ude09)\r\n\r\n```suggestion\r\n    Can occur when calling `response.cookies.get(...)`.\r\n```",
      "comment_id": 463131192,
      "user": "florimondmanca",
      "created_at": "2020-07-30T16:44:33Z",
      "url": "https://github.com/encode/httpx/pull/1095#discussion_r463131192"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1095,
      "file_path": "httpx/_decoders.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +50,8 @@ class DeflateDecoder(Decoder):\n     See: https://stackoverflow.com/questions/1838699\n     \"\"\"\n \n-    def __init__(self) -> None:\n+    def __init__(self, request: \"Request\") -> None:\n+        self.request = request",
      "comment": "Yeah a guess a lot of other Python developers would *tend* always just rely on \"hey I'm supposed to call `super` right\". Personally, I think explicit is preferable to indirect here. Calling into `super` isn't always necessary or inherently the \"right\" thing to do.",
      "comment_id": 463495154,
      "user": "lovelydinosaur",
      "created_at": "2020-07-31T09:06:51Z",
      "url": "https://github.com/encode/httpx/pull/1095#discussion_r463495154"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1095,
      "file_path": "httpx/_decoders.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +50,8 @@ class DeflateDecoder(Decoder):\n     See: https://stackoverflow.com/questions/1838699\n     \"\"\"\n \n-    def __init__(self) -> None:\n+    def __init__(self, request: \"Request\") -> None:\n+        self.request = request",
      "comment": "I see, well then I guess `Decoder` would really be better served by a `Protocol`, rather than a full-fledged base class\u2026 But we only have them on Py38+, which is unfortunate.\r\n\r\n```python\r\nclass Decoder(Protocol):\r\n    request: Request\r\n\r\n    def decode(self, data: bytes) -> bytes:\r\n        ...\r\n\r\n    def flush(self) -> bytes:\r\n        ...\r\n```\r\n\r\nBut maybe we could then also use the `request: Request` annotation on the `Decoder` interface, remove its constructor, and add an explicit constructor for `IdentityDecoder` (for consistency with other decoder classes)?",
      "comment_id": 463500184,
      "user": "florimondmanca",
      "created_at": "2020-07-31T09:17:14Z",
      "url": "https://github.com/encode/httpx/pull/1095#discussion_r463500184"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1095,
      "file_path": "httpx/_decoders.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +50,8 @@ class DeflateDecoder(Decoder):\n     See: https://stackoverflow.com/questions/1838699\n     \"\"\"\n \n-    def __init__(self) -> None:\n+    def __init__(self, request: \"Request\") -> None:\n+        self.request = request",
      "comment": "`MultiDecoder` inherits the `Decoder` interface, but do not have this property\r\n\r\nFrom my point of view, `MultiDecoder`, `TextDecoder` and `LineDecoder` should be renamed, since they:\r\n1. on one hand these Decoders imitates the real decoders (having `decode` and `flush`)\r\n1. on the other hand these decoders violates Liskov's substitution principle (I don't want to be so nerd, `mypy` pointed it for me), e.g. as they accept different types as args of decode",
      "comment_id": 468574084,
      "user": "cdeler",
      "created_at": "2020-08-11T13:21:50Z",
      "url": "https://github.com/encode/httpx/pull/1095#discussion_r468574084"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1152,
      "file_path": "httpx/_client.py",
      "line": 1260,
      "side": "RIGHT",
      "diff_hunk": "@@ -1154,6 +1209,11 @@ async def send(\n         allow_redirects: bool = True,\n         timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n     ) -> Response:\n+        \"\"\"\n+        Send a pre-built request.\n+\n+        Does not merge parameters with the client.\n+        \"\"\"",
      "comment": "```suggestion\r\n        \"\"\"\r\n        Send a request.\r\n\r\n        The request is sent as-is, unmodified.\r\n\r\n        Typically you'll want to get it from `Client.build_request()` (so that any\r\n        client-level configuration is merged into the request), but passing\r\n        an explicit `httpx.Request()` is supported as well.\r\n\r\n        See also: [Request instances][0]\r\n\r\n        [0]: /advanced/#request-instances\r\n        \"\"\"\r\n```",
      "comment_id": 467609329,
      "user": "florimondmanca",
      "created_at": "2020-08-09T17:38:25Z",
      "url": "https://github.com/encode/httpx/pull/1152#discussion_r467609329"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1152,
      "file_path": "httpx/_client.py",
      "line": 1223,
      "side": "RIGHT",
      "diff_hunk": "@@ -1130,6 +1180,11 @@ async def request(\n         allow_redirects: bool = True,\n         timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n     ) -> Response:\n+        \"\"\"\n+        Build and send a request.\n+\n+        Merges parameters with the client.\n+        \"\"\"",
      "comment": "```suggestion\r\n        \"\"\"\r\n        Build and send a request.\r\n\r\n        Roughly equivalent to:\r\n\r\n        ```python\r\n        request = client.build_request(...)\r\n        response = client.send(request, ...)\r\n        ```\r\n\r\n        See `Client.build_request()`, `Client.send()` and [Merging of configuration][0]\r\n        for how the various parameters are merged with client-level configuration.\r\n\r\n        [0]: /advanced/#merging-of-configuration\r\n        \"\"\"\r\n```",
      "comment_id": 467609590,
      "user": "florimondmanca",
      "created_at": "2020-08-09T17:41:01Z",
      "url": "https://github.com/encode/httpx/pull/1152#discussion_r467609590"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1152,
      "file_path": "httpx/_client.py",
      "line": 1260,
      "side": "RIGHT",
      "diff_hunk": "@@ -1154,6 +1209,11 @@ async def send(\n         allow_redirects: bool = True,\n         timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n     ) -> Response:\n+        \"\"\"\n+        Send a pre-built request.\n+\n+        Does not merge parameters with the client.\n+        \"\"\"",
      "comment": "Added this with a minor rewording to the new version!",
      "comment_id": 467979767,
      "user": "felix-hilden",
      "created_at": "2020-08-10T15:20:38Z",
      "url": "https://github.com/encode/httpx/pull/1152#discussion_r467979767"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1152,
      "file_path": "httpx/_client.py",
      "line": 1211,
      "side": "RIGHT",
      "diff_hunk": "@@ -1130,6 +1205,22 @@ async def request(\n         allow_redirects: bool = True,\n         timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n     ) -> Response:\n+        \"\"\"\n+        Build and send a request.\n+\n+        Roughly equivalent to:",
      "comment": "Fair point, because currently *it is*. But do you want to have some leeway in case it stops being, for some reason?",
      "comment_id": 468007529,
      "user": "felix-hilden",
      "created_at": "2020-08-10T15:52:45Z",
      "url": "https://github.com/encode/httpx/pull/1152#discussion_r468007529"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1163,
      "file_path": "httpx/_client.py",
      "line": 350,
      "side": "RIGHT",
      "diff_hunk": "@@ -340,7 +342,12 @@ def _redirect_url(self, request: Request, response: Response) -> URL:\n         \"\"\"\n         location = response.headers[\"Location\"]\n \n-        url = URL(location)\n+        try:\n+            url = URL(location)\n+        except InvalidURL as exc:\n+            raise RemoteProtocolError(\n+                f\"Invalid URL in location header: {exc}.\", request=request\n+            )",
      "comment": "Let's use `from None` here - we don't need to expose the extra traceback info.",
      "comment_id": 468368877,
      "user": "lovelydinosaur",
      "created_at": "2020-08-11T07:04:45Z",
      "url": "https://github.com/encode/httpx/pull/1163#discussion_r468368877"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1126,
      "file_path": "httpx/_exceptions.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -132,9 +155,35 @@ class ProxyError(TransportError):\n     \"\"\"\n \n \n+class UnsupportedProtocol(TransportError):\n+    \"\"\"\n+    Attempted to make a request to a no-supported protocol.",
      "comment": "```suggestion\r\n    Attempted to make a request to an unsupported protocol.\r\n```",
      "comment_id": 464487607,
      "user": "StephenBrown2",
      "created_at": "2020-08-03T15:27:28Z",
      "url": "https://github.com/encode/httpx/pull/1126#discussion_r464487607"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1128,
      "file_path": "httpx/_models.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,6 +140,8 @@ def raw(self) -> typing.Tuple[bytes, bytes, typing.Optional[int], bytes]:\n \n     @property\n     def is_ssl(self) -> bool:\n+        message = 'URL.is_ssl() is pending deprecation. Use url.scheme == \"https\"'\n+        warnings.warn(message, DeprecationWarning)",
      "comment": "Note: we have a handy util in `_utils.py` so we don't have to remember which warning category should be passed (planning to issue a PR to update all usage to this shortly!).\r\n\r\n```suggestion\r\n        warn_deprecated(message)\r\n```",
      "comment_id": 465879004,
      "user": "florimondmanca",
      "created_at": "2020-08-05T17:12:24Z",
      "url": "https://github.com/encode/httpx/pull/1128#discussion_r465879004"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1130,
      "file_path": "httpx/_client.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +110,17 @@ def _get_proxy_map(\n             proxy = Proxy(url=proxies) if isinstance(proxies, (str, URL)) else proxies\n             return {\"all\": proxy}\n \n+    @property\n+    def base_url(self) -> URL:\n+        \"\"\"\n+        Base URL to use when sending requests with relative URLs.\n+        \"\"\"\n+        return self._base_url",
      "comment": "Where is `self._base_url` set/created? I see `self.base_url` on [Line 72](https://github.com/encode/httpx/pull/1130/files#diff-eff812167840d2389ea5f0d809b30c32R72), perhaps that should be privatized?",
      "comment_id": 465863317,
      "user": "StephenBrown2",
      "created_at": "2020-08-05T16:46:12Z",
      "url": "https://github.com/encode/httpx/pull/1130#discussion_r465863317"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1130,
      "file_path": "httpx/_client.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +110,17 @@ def _get_proxy_map(\n             proxy = Proxy(url=proxies) if isinstance(proxies, (str, URL)) else proxies\n             return {\"all\": proxy}\n \n+    @property\n+    def base_url(self) -> URL:\n+        \"\"\"\n+        Base URL to use when sending requests with relative URLs.\n+        \"\"\"\n+        return self._base_url",
      "comment": "Thanks yup. Should have been `self._base_url` in `__init__`.\r\nIt was still working (because there's a property setter) but it's neater now.",
      "comment_id": 465873534,
      "user": "lovelydinosaur",
      "created_at": "2020-08-05T17:02:52Z",
      "url": "https://github.com/encode/httpx/pull/1130#discussion_r465873534"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1119,
      "file_path": "tests/models/test_headers.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,6 +13,7 @@ def test_headers():\n     assert h[\"a\"] == \"123, 456\"\n     assert h.get(\"a\") == \"123, 456\"\n     assert h.get(\"nope\", default=None) is None\n+    assert h.getlist(\"a\") == [\"123\", \"456\"]",
      "comment": "Do we want a `with pytest.warns(DeprecatedWarning)` here and in `test_params()`, so that these known warnings don't show up in the pytest output?",
      "comment_id": 464055245,
      "user": "florimondmanca",
      "created_at": "2020-08-02T09:30:57Z",
      "url": "https://github.com/encode/httpx/pull/1119#discussion_r464055245"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1119,
      "file_path": "tests/models/test_headers.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,6 +13,7 @@ def test_headers():\n     assert h[\"a\"] == \"123, 456\"\n     assert h.get(\"a\") == \"123, 456\"\n     assert h.get(\"nope\", default=None) is None\n+    assert h.getlist(\"a\") == [\"123\", \"456\"]",
      "comment": "\ud83d\udcaf - Yes, thanks! Which helped catch that they needed to be `DeprecationWarning` in line with everything else (not PendingDeprecationWarning).",
      "comment_id": 464056716,
      "user": "lovelydinosaur",
      "created_at": "2020-08-02T09:46:55Z",
      "url": "https://github.com/encode/httpx/pull/1119#discussion_r464056716"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1103,
      "file_path": "httpx/_client.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,7 +89,7 @@ def _get_proxy_map(\n         if proxies is None:\n             if trust_env:\n                 return {\n-                    key: Proxy(url=url)\n+                    key: None if url is None else Proxy(url=url)",
      "comment": "Previously `get_environment_proxies()` did not return `None` values.\r\nNow it does.",
      "comment_id": 463504287,
      "user": "lovelydinosaur",
      "created_at": "2020-07-31T09:25:42Z",
      "url": "https://github.com/encode/httpx/pull/1103#discussion_r463504287"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1103,
      "file_path": "httpx/_utils.py",
      "line": 515,
      "side": "RIGHT",
      "diff_hunk": "@@ -496,10 +512,13 @@ def matches(self, other: \"URL\") -> bool:\n     def priority(self) -> tuple:\n         \"\"\"\n         The priority allows URLMatcher instances to be sortable, so that\n-        we can match from most specific to least specific.\n+        if we can match from most specific to least specific.",
      "comment": "```suggestion\r\n        we can match from most specific to least specific.\r\n```",
      "comment_id": 463939394,
      "user": "florimondmanca",
      "created_at": "2020-08-01T08:31:38Z",
      "url": "https://github.com/encode/httpx/pull/1103#discussion_r463939394"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1103,
      "file_path": "tests/test_utils.py",
      "line": 295,
      "side": "RIGHT",
      "diff_hunk": "@@ -228,75 +227,85 @@ def test_obfuscate_sensitive_headers(headers, output):\n     [\n         (\n             \"http://127.0.0.1\",\n-            {\"NO_PROXY\": \"\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"\"},\n             False,\n         ),  # everything proxied when no_proxy is empty/unset\n         (\n             \"http://127.0.0.1\",\n-            {\"NO_PROXY\": \"127.0.0.1\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"127.0.0.1\"},\n             True,\n         ),  # no_proxy as ip case is matched\n         (\n             \"http://127.0.0.1\",\n-            {\"NO_PROXY\": \"https://127.0.0.1\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"https://127.0.0.1\"},\n             False,\n         ),  # no_proxy with scheme is ignored\n         (\n             \"http://127.0.0.1\",\n-            {\"NO_PROXY\": \"1.1.1.1\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"1.1.1.1\"},\n             False,\n         ),  # different no_proxy means its proxied\n         (\n             \"http://courses.mit.edu\",\n-            {\"NO_PROXY\": \"mit.edu\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu\"},\n             True,\n         ),  # no_proxy for sub-domain matches\n         (\n             \"https://mit.edu.info\",\n-            {\"NO_PROXY\": \"mit.edu\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu\"},\n             False,\n         ),  # domain is actually edu.info, so should be proxied\n         (\n             \"https://mit.edu.info\",\n-            {\"NO_PROXY\": \"mit.edu,edu.info\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu,edu.info\"},\n             True,\n         ),  # list in no_proxy, matches second domain\n         (\n             \"https://mit.edu.info\",\n-            {\"NO_PROXY\": \"mit.edu, edu.info\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu, edu.info\"},\n             True,\n         ),  # list with spaces in no_proxy\n         (\n             \"https://mit.edu.info\",\n-            {\"NO_PROXY\": \"mit.edu,mit.info\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu,mit.info\"},\n             False,\n         ),  # list in no_proxy, without any domain matching\n         (\n             \"https://foo.example.com\",\n-            {\"NO_PROXY\": \"www.example.com\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"www.example.com\"},\n             False,\n         ),  # different subdomains foo vs www means we still proxy\n         (\n             \"https://www.example1.com\",\n-            {\"NO_PROXY\": \".example1.com\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \".example1.com\"},\n             True,\n         ),  # no_proxy starting with dot\n         (\n             \"https://www.example2.com\",\n-            {\"NO_PROXY\": \"ample2.com\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"ample2.com\"},\n             False,\n         ),  # whole-domain matching\n         (\n             \"https://www.example3.com\",\n-            {\"NO_PROXY\": \"*\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"*\"},\n             True,\n         ),  # wildcard * means nothing proxied\n     ],\n )\n def test_should_not_be_proxied(url, no_proxy, expected):",
      "comment": "Should we move this test to `test_proxies.py` now that the `should_not_be_proxied` util is gone?",
      "comment_id": 463939540,
      "user": "florimondmanca",
      "created_at": "2020-08-01T08:33:25Z",
      "url": "https://github.com/encode/httpx/pull/1103#discussion_r463939540"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1103,
      "file_path": "tests/test_utils.py",
      "line": 295,
      "side": "RIGHT",
      "diff_hunk": "@@ -228,75 +227,85 @@ def test_obfuscate_sensitive_headers(headers, output):\n     [\n         (\n             \"http://127.0.0.1\",\n-            {\"NO_PROXY\": \"\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"\"},\n             False,\n         ),  # everything proxied when no_proxy is empty/unset\n         (\n             \"http://127.0.0.1\",\n-            {\"NO_PROXY\": \"127.0.0.1\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"127.0.0.1\"},\n             True,\n         ),  # no_proxy as ip case is matched\n         (\n             \"http://127.0.0.1\",\n-            {\"NO_PROXY\": \"https://127.0.0.1\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"https://127.0.0.1\"},\n             False,\n         ),  # no_proxy with scheme is ignored\n         (\n             \"http://127.0.0.1\",\n-            {\"NO_PROXY\": \"1.1.1.1\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"1.1.1.1\"},\n             False,\n         ),  # different no_proxy means its proxied\n         (\n             \"http://courses.mit.edu\",\n-            {\"NO_PROXY\": \"mit.edu\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu\"},\n             True,\n         ),  # no_proxy for sub-domain matches\n         (\n             \"https://mit.edu.info\",\n-            {\"NO_PROXY\": \"mit.edu\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu\"},\n             False,\n         ),  # domain is actually edu.info, so should be proxied\n         (\n             \"https://mit.edu.info\",\n-            {\"NO_PROXY\": \"mit.edu,edu.info\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu,edu.info\"},\n             True,\n         ),  # list in no_proxy, matches second domain\n         (\n             \"https://mit.edu.info\",\n-            {\"NO_PROXY\": \"mit.edu, edu.info\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu, edu.info\"},\n             True,\n         ),  # list with spaces in no_proxy\n         (\n             \"https://mit.edu.info\",\n-            {\"NO_PROXY\": \"mit.edu,mit.info\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"mit.edu,mit.info\"},\n             False,\n         ),  # list in no_proxy, without any domain matching\n         (\n             \"https://foo.example.com\",\n-            {\"NO_PROXY\": \"www.example.com\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"www.example.com\"},\n             False,\n         ),  # different subdomains foo vs www means we still proxy\n         (\n             \"https://www.example1.com\",\n-            {\"NO_PROXY\": \".example1.com\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \".example1.com\"},\n             True,\n         ),  # no_proxy starting with dot\n         (\n             \"https://www.example2.com\",\n-            {\"NO_PROXY\": \"ample2.com\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"ample2.com\"},\n             False,\n         ),  # whole-domain matching\n         (\n             \"https://www.example3.com\",\n-            {\"NO_PROXY\": \"*\"},\n+            {\"ALL_PROXY\": \"http://localhost:123\", \"NO_PROXY\": \"*\"},\n             True,\n         ),  # wildcard * means nothing proxied\n     ],\n )\n def test_should_not_be_proxied(url, no_proxy, expected):",
      "comment": "I've merged these tests into the existing `test_proxies_environ` case now.\r\nLooks much nicer!",
      "comment_id": 464050738,
      "user": "lovelydinosaur",
      "created_at": "2020-08-02T08:42:47Z",
      "url": "https://github.com/encode/httpx/pull/1103#discussion_r464050738"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1113,
      "file_path": "httpx/_client.py",
      "line": 422,
      "side": "RIGHT",
      "diff_hunk": "@@ -418,8 +419,7 @@ class Client(BaseClient):\n     URLs.\n     * **timeout** - *(optional)* The timeout configuration to use when sending\n     requests.\n-    * **pool_limits** - *(optional)* The connection pool configuration to use\n-    when determining the maximum number of concurrently open HTTP connections.\n+    * **limits** - *(optional)* The limits configuration to use.",
      "comment": "Haven't found a better description of the parameter that's not redundant with the info in the `Limits` docstring. I don't think it's included in the Developer Interface yet so that could be a nice follow-up, and then cross-link it here?",
      "comment_id": 463946896,
      "user": "florimondmanca",
      "created_at": "2020-08-01T10:08:09Z",
      "url": "https://github.com/encode/httpx/pull/1113#discussion_r463946896"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1113,
      "file_path": "httpx/_client.py",
      "line": 422,
      "side": "RIGHT",
      "diff_hunk": "@@ -418,8 +419,7 @@ class Client(BaseClient):\n     URLs.\n     * **timeout** - *(optional)* The timeout configuration to use when sending\n     requests.\n-    * **pool_limits** - *(optional)* The connection pool configuration to use\n-    when determining the maximum number of concurrently open HTTP connections.\n+    * **limits** - *(optional)* The limits configuration to use.",
      "comment": "I guess we could say something like... \"Allows for configuration options, such as the maximum number of open connections to allow.\" Just to give a bit of an indication what we mean by \"limits\" here(?)",
      "comment_id": 463990298,
      "user": "lovelydinosaur",
      "created_at": "2020-08-01T19:02:36Z",
      "url": "https://github.com/encode/httpx/pull/1113#discussion_r463990298"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1113,
      "file_path": "httpx/_client.py",
      "line": 422,
      "side": "RIGHT",
      "diff_hunk": "@@ -418,8 +419,7 @@ class Client(BaseClient):\n     URLs.\n     * **timeout** - *(optional)* The timeout configuration to use when sending\n     requests.\n-    * **pool_limits** - *(optional)* The connection pool configuration to use\n-    when determining the maximum number of concurrently open HTTP connections.\n+    * **limits** - *(optional)* The limits configuration to use.",
      "comment": "Let's pull this in for now as it is. Welcome to follow up with docstring improvements later.",
      "comment_id": 463993804,
      "user": "lovelydinosaur",
      "created_at": "2020-08-01T19:44:48Z",
      "url": "https://github.com/encode/httpx/pull/1113#discussion_r463993804"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1111,
      "file_path": "httpx/_config.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -251,17 +288,11 @@ def __init__(\n                 )\n                 timeout = None\n             self.connect_timeout = (",
      "comment": "Note that I haven't changed the `Timeout.<xyz>_timeout` attributes yet, since this PR focuses on parameters.\r\n\r\nI _suppose_ the attributes are considered public API too, right @tomchristie? If so I'd like to leave their renaming to a follow-up PR since we'd probably also want smooth `@property`-based deprecation for those too.",
      "comment_id": 463944539,
      "user": "florimondmanca",
      "created_at": "2020-08-01T09:35:52Z",
      "url": "https://github.com/encode/httpx/pull/1111#discussion_r463944539"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1111,
      "file_path": "httpx/_config.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -251,17 +288,11 @@ def __init__(\n                 )\n                 timeout = None\n             self.connect_timeout = (",
      "comment": "I think we'd *potentially?* be okay without a deprecation on those, but happy either way.\n\n(Given that they're very unlikely to be used, aren't documented, and that we have a clear policy on 0.x version changes / pinning expectations and nice, clear versioning notes)",
      "comment_id": 463946781,
      "user": "lovelydinosaur",
      "created_at": "2020-08-01T10:06:27Z",
      "url": "https://github.com/encode/httpx/pull/1111#discussion_r463946781"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1111,
      "file_path": "httpx/_config.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -251,17 +288,11 @@ def __init__(\n                 )\n                 timeout = None\n             self.connect_timeout = (",
      "comment": "That's my feeling as well\u2026 :-) I'll see and probably make the change in this PR then, since it's contained to the `Timeout` class (transports expect a timeout `dict` and those keys don't change), and maybe some tests.",
      "comment_id": 463947142,
      "user": "florimondmanca",
      "created_at": "2020-08-01T10:11:07Z",
      "url": "https://github.com/encode/httpx/pull/1111#discussion_r463947142"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1089,
      "file_path": "httpx/_models.py",
      "line": 427,
      "side": "RIGHT",
      "diff_hunk": "@@ -376,26 +406,47 @@ def raw(self) -> typing.List[typing.Tuple[bytes, bytes]]:\n         return self._list\n \n     def keys(self) -> typing.List[str]:  # type: ignore\n-        return [key.decode(self.encoding) for key, value in self._list]\n+        return [key.decode(self.encoding) for key in self._dict.keys()]\n \n     def values(self) -> typing.List[str]:  # type: ignore\n-        return [value.decode(self.encoding) for key, value in self._list]\n+        return [value.decode(self.encoding) for value in self._dict.values()]\n \n     def items(self) -> typing.List[typing.Tuple[str, str]]:  # type: ignore\n+        \"\"\"\n+        Return a list of `(key, value)` pairs of headers. Concatenate headers\n+        into a single comma seperated value when a key occurs multiple times.\n+        \"\"\"\n+        return [\n+            (key.decode(self.encoding), value.decode(self.encoding))\n+            for key, value in self._dict.items()\n+        ]\n+\n+    def multi_items(self) -> typing.List[typing.Tuple[str, str]]:  # type: ignore\n+        \"\"\"\n+        Return a list of `(key, value)` pairs of headers. Allow multiple\n+        occurances of the same key without concatenating into a single",
      "comment": "```suggestion\r\n        occurences of the same key without concatenating into a single\r\n```",
      "comment_id": 463124266,
      "user": "florimondmanca",
      "created_at": "2020-07-30T16:33:00Z",
      "url": "https://github.com/encode/httpx/pull/1089#discussion_r463124266"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1089,
      "file_path": "httpx/_models.py",
      "line": 437,
      "side": "RIGHT",
      "diff_hunk": "@@ -376,26 +406,47 @@ def raw(self) -> typing.List[typing.Tuple[bytes, bytes]]:\n         return self._list\n \n     def keys(self) -> typing.List[str]:  # type: ignore\n-        return [key.decode(self.encoding) for key, value in self._list]\n+        return [key.decode(self.encoding) for key in self._dict.keys()]\n \n     def values(self) -> typing.List[str]:  # type: ignore\n-        return [value.decode(self.encoding) for key, value in self._list]\n+        return [value.decode(self.encoding) for value in self._dict.values()]\n \n     def items(self) -> typing.List[typing.Tuple[str, str]]:  # type: ignore\n+        \"\"\"\n+        Return a list of `(key, value)` pairs of headers. Concatenate headers\n+        into a single comma seperated value when a key occurs multiple times.\n+        \"\"\"\n+        return [\n+            (key.decode(self.encoding), value.decode(self.encoding))\n+            for key, value in self._dict.items()\n+        ]\n+\n+    def multi_items(self) -> typing.List[typing.Tuple[str, str]]:  # type: ignore\n+        \"\"\"\n+        Return a list of `(key, value)` pairs of headers. Allow multiple\n+        occurances of the same key without concatenating into a single\n+        comma seperated value.\n+        \"\"\"\n         return [\n             (key.decode(self.encoding), value.decode(self.encoding))\n             for key, value in self._list\n         ]\n \n     def get(self, key: str, default: typing.Any = None) -> typing.Any:\n+        \"\"\"\n+        Return a header value. If multiple occurances of the header occur",
      "comment": "```suggestion\r\n        Return a header value. If multiple occurences of the header occur\r\n```",
      "comment_id": 463124702,
      "user": "florimondmanca",
      "created_at": "2020-07-30T16:33:44Z",
      "url": "https://github.com/encode/httpx/pull/1089#discussion_r463124702"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1096,
      "file_path": "httpx/_transports/asgi.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,6 +31,10 @@ def create_event() -> \"Event\":\n         return asyncio.Event()\n \n \n+async def async_byte_iterator(bytestring: bytes) -> AsyncIterator[bytes]:\n+    yield bytestring",
      "comment": "I'd agree that having this built-in supported by HTTPCore would be beneficial. I hit this myself before too and having to write a dedicated async generator function each time is a bit cumbersome as I think you noted. :-) (Same for having to write a generator expression from a 1-list in the sync case.)",
      "comment_id": 463120018,
      "user": "florimondmanca",
      "created_at": "2020-07-30T16:26:08Z",
      "url": "https://github.com/encode/httpx/pull/1096#discussion_r463120018"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1098,
      "file_path": "httpx/_utils.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -429,5 +429,89 @@ def elapsed(self) -> timedelta:\n         return timedelta(seconds=self.end - self.start)\n \n \n+class URLMatcher:\n+    \"\"\"\n+    A utility class currently used for making lookups against proxy keys...\n+\n+    # Wildcard matching...\n+    >>> pattern = URLMatcher(\"all\")\n+    >>> pattern.matches(httpx.URL(\"http://example.com\"))\n+    True\n+\n+    # Witch scheme matching...\n+    >>> pattern = URLMatcher(\"https\")\n+    >>> pattern.matches(httpx.URL(\"https://example.com\"))\n+    True\n+    >>> pattern.matches(httpx.URL(\"http://example.com\"))\n+    False\n+\n+    # With domain matching...\n+    >>> pattern = URLMatcher(\"https://example.com\")\n+    >>> pattern.matches(httpx.URL(\"https://example.com\"))\n+    True\n+    >>> pattern.matches(httpx.URL(\"http://example.com\"))\n+    False\n+    >>> pattern.matches(httpx.URL(\"https://other.com\"))\n+    False\n+\n+    # Wildcard scheme, with domain matching...\n+    >>> pattern = URLMatcher(\"all://example.com\")\n+    >>> pattern.matches(httpx.URL(\"https://example.com\"))\n+    True\n+    >>> pattern.matches(httpx.URL(\"http://example.com\"))\n+    True\n+    >>> pattern.matches(httpx.URL(\"https://other.com\"))\n+    False\n+\n+    # With port matching...\n+    >>> pattern = URLMatcher(\"https://example.com:1234\")\n+    >>> pattern.matches(httpx.URL(\"https://example.com:1234\"))\n+    True\n+    >>> pattern.matches(httpx.URL(\"https://example.com\"))\n+    False\n+    \"\"\"\n+\n+    def __init__(self, pattern: str) -> None:\n+        from ._models import URL\n+\n+        if pattern and \":\" not in pattern:\n+            pattern += \"://\"\n+\n+        url = URL(pattern)\n+        self.pattern = pattern\n+        self.scheme = \"\" if url.scheme == \"all\" else url.scheme\n+        self.host = url.host\n+        self.port = url.port\n+\n+    def matches(self, other: \"URL\") -> bool:\n+        if self.scheme and self.scheme != other.scheme:\n+            return False\n+        if self.host and self.host != other.host:\n+            return False\n+        if self.port is not None and self.port != other.port:\n+            return False\n+        return True\n+\n+    @property\n+    def priority(self) -> tuple:\n+        \"\"\"\n+        The priority allows URLMatcher instances to be sortable, so that\n+        if we can match from most specific to least specific.",
      "comment": "```suggestion\r\n        we can match from most specific to least specific.\r\n```",
      "comment_id": 463112196,
      "user": "florimondmanca",
      "created_at": "2020-07-30T16:13:58Z",
      "url": "https://github.com/encode/httpx/pull/1098#discussion_r463112196"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 996,
      "file_path": "tests/test_config.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -38,10 +36,11 @@ def test_load_ssl_config_verify_env_file(https_server, ca_cert_pem_file, config)\n         else str(Path(ca_cert_pem_file).parent)\n     )\n     ssl_config = SSLConfig(trust_env=True)",
      "comment": "It'd be *great* as part of this change if we dropped using the private `SSLConfig` from the tests completely.\r\nNot *necessarily* a blocker to getting this PR in, but might be worth a go?",
      "comment_id": 429996378,
      "user": "lovelydinosaur",
      "created_at": "2020-05-25T15:44:03Z",
      "url": "https://github.com/encode/httpx/pull/996#discussion_r429996378"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 996,
      "file_path": "tests/test_config.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -94,17 +90,16 @@ def test_load_ssl_config_cert_without_key_raises(cert_pem_file):\n \n \n def test_load_ssl_config_no_verify():\n-    ssl_config = SSLConfig(verify=False)\n-    context = ssl_config.ssl_context\n+    context = httpx.create_ssl_context(verify=False)\n     assert context.verify_mode == ssl.VerifyMode.CERT_NONE\n     assert context.check_hostname is False\n \n \n def test_load_ssl_context():\n     ssl_context = ssl.create_default_context()\n-    ssl_config = SSLConfig(verify=ssl_context)\n+    context = httpx.create_ssl_context(verify=ssl_context)\n \n-    assert ssl_config.ssl_context is ssl_context\n+    assert context is ssl_context\n \n \n def test_ssl_repr():",
      "comment": "We could probably drop the `__repr__` and `__eq__` methods from `SSLConfig`, and then drop these two tests.\r\nGiven that we're not exposing the instance anyplace they're pretty much superfluous.",
      "comment_id": 429996855,
      "user": "lovelydinosaur",
      "created_at": "2020-05-25T15:45:09Z",
      "url": "https://github.com/encode/httpx/pull/996#discussion_r429996855"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1084,
      "file_path": "httpx/_auth.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,10 +54,10 @@ class FunctionAuth(Auth):\n     \"\"\"\n \n     def __init__(self, func: typing.Callable[[Request], Request]) -> None:\n-        self.func = func\n+        self._func = func",
      "comment": "Curious if we'd want to more clearly separate out \"the Auth interface\" from our default \"function-based Auth\" implementation - ie separate Auth from FuncAuth?",
      "comment_id": 460036945,
      "user": "florimondmanca",
      "created_at": "2020-07-24T13:00:25Z",
      "url": "https://github.com/encode/httpx/pull/1084#discussion_r460036945"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1084,
      "file_path": "httpx/_auth.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,10 +54,10 @@ class FunctionAuth(Auth):\n     \"\"\"\n \n     def __init__(self, func: typing.Callable[[Request], Request]) -> None:\n-        self.func = func\n+        self._func = func",
      "comment": "I'm not sure *exactly* what you mean here, but... We don't expose `FunctionAuth` publicly anywhere, but we *might* want to have a property setter on Client, as we do with several of the other attributes on it, so that eg...\r\n\r\n```\r\nThe following are all valid...\r\n\r\nclient.auth = None\r\nclient.auth = ('username', 'password')\r\nclient.auth = httpx.DigestAuthentiction(...)\r\nclient.auth = simple_function_auth\r\nclient.auth = CustomAuthClass()\r\n\r\nprint(client.auth)  # Always returns an instance of `Auth`. Our instances don't expose any additional public API beyond that.\r\n```",
      "comment_id": 460043286,
      "user": "lovelydinosaur",
      "created_at": "2020-07-24T13:13:05Z",
      "url": "https://github.com/encode/httpx/pull/1084#discussion_r460043286"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1084,
      "file_path": "httpx/_auth.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,10 +54,10 @@ class FunctionAuth(Auth):\n     \"\"\"\n \n     def __init__(self, func: typing.Callable[[Request], Request]) -> None:\n-        self.func = func\n+        self._func = func",
      "comment": "Ah okay, nevermind \u2014 the GitHub UI tricked me. I thought this diff was on the `Auth` class, but it's on `FunctionAuth`. So it's all as I was meaning to think it should be. :-)",
      "comment_id": 460433300,
      "user": "florimondmanca",
      "created_at": "2020-07-25T18:53:00Z",
      "url": "https://github.com/encode/httpx/pull/1084#discussion_r460433300"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1080,
      "file_path": "httpx/_client.py",
      "line": 546,
      "side": "RIGHT",
      "diff_hunk": "@@ -543,10 +543,13 @@ def _transport_for_url(self, url: URL) -> httpcore.SyncHTTPTransport:\n         enforce_http_url(url)\n \n         if self._proxies and not should_not_be_proxied(url):\n-            is_default_port = (url.scheme == \"http\" and url.port == 80) or (\n-                url.scheme == \"https\" and url.port == 443\n+            default_port = {\"http\": 80, \"https\": 443}[url.scheme]",
      "comment": "Should this be a `.get()` to avoid `KeyError: 'ftp'`?\r\n```suggestion\r\n            default_port = {\"http\": 80, \"https\": 443}.get(url.scheme)\r\n```",
      "comment_id": 459542182,
      "user": "StephenBrown2",
      "created_at": "2020-07-23T15:36:12Z",
      "url": "https://github.com/encode/httpx/pull/1080#discussion_r459542182"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1080,
      "file_path": "httpx/_client.py",
      "line": 552,
      "side": "RIGHT",
      "diff_hunk": "@@ -543,10 +543,13 @@ def _transport_for_url(self, url: URL) -> httpcore.SyncHTTPTransport:\n         enforce_http_url(url)\n \n         if self._proxies and not should_not_be_proxied(url):\n-            is_default_port = (url.scheme == \"http\" and url.port == 80) or (\n-                url.scheme == \"https\" and url.port == 443\n+            default_port = {\"http\": 80, \"https\": 443}[url.scheme]\n+            is_default_port = url.port is None or url.port == default_port\n+            hostname = (\n+                f\"{url.host}:{default_port}\"\n+                if url.port is None\n+                else f\"{url.host}:{url.port}\"\n             )",
      "comment": "Could this be simplified:\r\n```suggestion\r\n            port = url.port or default_port\r\n            hostname = f\"{url.host}:{port}\"\r\n```",
      "comment_id": 459543877,
      "user": "StephenBrown2",
      "created_at": "2020-07-23T15:38:42Z",
      "url": "https://github.com/encode/httpx/pull/1080#discussion_r459543877"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1080,
      "file_path": "httpx/_client.py",
      "line": 546,
      "side": "RIGHT",
      "diff_hunk": "@@ -543,10 +543,13 @@ def _transport_for_url(self, url: URL) -> httpcore.SyncHTTPTransport:\n         enforce_http_url(url)\n \n         if self._proxies and not should_not_be_proxied(url):\n-            is_default_port = (url.scheme == \"http\" and url.port == 80) or (\n-                url.scheme == \"https\" and url.port == 443\n+            default_port = {\"http\": 80, \"https\": 443}[url.scheme]",
      "comment": "Actually no, because we've called `enforce_http_url(url)` before doing anything else, so `url.scheme` will always be `http|https` here, and `default_port` will be an `int` rather than an `Optional[int]`.\r\n\r\n(Agree that it's a bit futzy, and I think it'd potentially clean up a bit if we rethought the proxy_keys/mount API.)",
      "comment_id": 459960466,
      "user": "lovelydinosaur",
      "created_at": "2020-07-24T09:56:57Z",
      "url": "https://github.com/encode/httpx/pull/1080#discussion_r459960466"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1073,
      "file_path": "httpx/_models.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,12 +54,7 @@\n \n \n class URL:\n-    def __init__(\n-        self,\n-        url: URLTypes,\n-        allow_relative: bool = False,\n-        params: QueryParamTypes = None,\n-    ) -> None:\n+    def __init__(self, url: URLTypes, params: QueryParamTypes = None,) -> None:",
      "comment": "(Nit)\r\n\r\n```suggestion\r\n    def __init__(self, url: URLTypes, params: QueryParamTypes = None) -> None:\r\n```",
      "comment_id": 458338414,
      "user": "florimondmanca",
      "created_at": "2020-07-21T19:31:57Z",
      "url": "https://github.com/encode/httpx/pull/1073#discussion_r458338414"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1073,
      "file_path": "tests/client/test_client.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,16 @@ def test_get(server):\n     assert response.elapsed > timedelta(0)\n \n \n+def test_get_invalid_url(server):\n+    with httpx.Client() as client:\n+        with pytest.raises(httpx.InvalidURL):\n+            client.get(\"invalid://example.org\")\n+        with pytest.raises(httpx.InvalidURL):\n+            client.get(\"://example.org\")\n+        with pytest.raises(httpx.InvalidURL):\n+            client.get(\"http://\")",
      "comment": "(Nit) Considering using a parametrized test style? I enjoy the documentation purpose of `id=...`, and that each case runs as its own test...\r\n\r\nThen should we back-port this to `test_async_client.py` as well?\r\n\r\n```suggestion\r\n@pytest.mark.parametrize(\r\n    \"url\",\r\n    [\r\n        pytest.param(\"invalid://example.org\", id=\"scheme-not-http(s)\"),\r\n        pytest.param(\"://example.org\", id=\"no-scheme\"),\r\n        pytest.param(\"http://\", id=\"no-host\"),\r\n    ],\r\n)\r\ndef test_get_invalid_url(server, url):\r\n    with httpx.Client() as client:\r\n        with pytest.raises(httpx.InvalidURL):\r\n             client.get(url)\r\n```",
      "comment_id": 458340993,
      "user": "florimondmanca",
      "created_at": "2020-07-21T19:37:13Z",
      "url": "https://github.com/encode/httpx/pull/1073#discussion_r458340993"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1073,
      "file_path": "tests/client/test_async_client.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,6 +23,10 @@ async def test_get_invalid_url(server):\n     async with httpx.AsyncClient() as client:\n         with pytest.raises(httpx.InvalidURL):\n             await client.get(\"invalid://example.org\")\n+        with pytest.raises(httpx.InvalidURL):\n+            await client.get(\"://example.org\")\n+        with pytest.raises(httpx.InvalidURL):\n+            await client.get(\"http://\")",
      "comment": "Refs https://github.com/encode/httpx/pull/1073#discussion_r458340993\r\n\r\n```python\r\n@pytest.mark.parametrize(\r\n    \"url\",\r\n    [\r\n        pytest.param(\"invalid://example.org\", id=\"scheme-not-http(s)\"),\r\n        pytest.param(\"://example.org\", id=\"no-scheme\"),\r\n        pytest.param(\"http://\", id=\"no-host\"),\r\n    ],\r\n)\r\n@pytest.mark.usefixtures(\"async_environment\")\r\nasync def test_get_invalid_url(server, url):\r\n    async with httpx.AsyncClient() as client:\r\n        with pytest.raises(httpx.InvalidURL):\r\n             await client.get(url)\r\n```",
      "comment_id": 458341502,
      "user": "florimondmanca",
      "created_at": "2020-07-21T19:38:14Z",
      "url": "https://github.com/encode/httpx/pull/1073#discussion_r458341502"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1076,
      "file_path": "httpx/_exceptions.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -235,7 +236,8 @@ def map_exceptions(\n         if mapped_exc is None:\n             raise\n \n-        raise mapped_exc(exc) from None\n+        message = str(exc)\n+        raise mapped_exc(message, **kwargs) from None  # type: ignore",
      "comment": "We have to `type: ignore` here, because `**kwargs` isn't *generally* appropriate to any exception class, so it's up to us to ensure that calling code uses it appropriately with whichever exceptions are being mapped too.",
      "comment_id": 457999545,
      "user": "lovelydinosaur",
      "created_at": "2020-07-21T10:34:50Z",
      "url": "https://github.com/encode/httpx/pull/1076#discussion_r457999545"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1052,
      "file_path": "tests/common.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,5 @@\n+import pathlib\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+TESTS_DIR = TESTS_DIR.relative_to(TESTS_DIR.parent)  # Ensure relative to project root.",
      "comment": "Is there any benefit of using a relative path? I think all the usages admit a full one.",
      "comment_id": 449892897,
      "user": "jcugat",
      "created_at": "2020-07-05T16:03:13Z",
      "url": "https://github.com/encode/httpx/pull/1052#discussion_r449892897"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1052,
      "file_path": "tests/common.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,5 @@\n+import pathlib\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+TESTS_DIR = TESTS_DIR.relative_to(TESTS_DIR.parent)  # Ensure relative to project root.",
      "comment": "Mostly so that the existing assertions in `tests/test_utils.py` don't have to be changed (eg `assert ... == 'tests'`, see https://github.com/encode/httpx/pull/1052/files#diff-87010571bbeeee0b9a13279c493670f3R144).\r\n\r\nOtherwise we'd be setting env variables to eg `/Users/florimond/.../tests/.netrc` and so we'd have to assert against that, and I realized it's not trivial due to trailing slashes etc.\r\n\r\nSo, went for what seemed to me as keeping things simple here.",
      "comment_id": 449893835,
      "user": "florimondmanca",
      "created_at": "2020-07-05T16:13:47Z",
      "url": "https://github.com/encode/httpx/pull/1052#discussion_r449893835"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1052,
      "file_path": "tests/common.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,5 @@\n+import pathlib\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+TESTS_DIR = TESTS_DIR.relative_to(TESTS_DIR.parent)  # Ensure relative to project root.",
      "comment": "Good point, I missed this part (and learned about `relative_to()` in the way!).",
      "comment_id": 449894246,
      "user": "jcugat",
      "created_at": "2020-07-05T16:18:34Z",
      "url": "https://github.com/encode/httpx/pull/1052#discussion_r449894246"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1052,
      "file_path": "tests/common.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,5 @@\n+import pathlib\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+TESTS_DIR = TESTS_DIR.relative_to(TESTS_DIR.parent)  # Ensure relative to project root.",
      "comment": "After thinking about it again, it seems that using the relative path will still have the same problems that were reported in https://github.com/encode/httpx/pull/1035\r\n\r\nSo running the tests from inside the `httpx/tests/` will fail since it won't find the correct fixtures path.\r\n\r\nAn alternative would be to remove line 4 from `tests/common.py` and update the test to check `assert get_ca_bundle_from_env().endswith(\"tests\")` (or similar) instead.",
      "comment_id": 449897079,
      "user": "jcugat",
      "created_at": "2020-07-05T16:50:39Z",
      "url": "https://github.com/encode/httpx/pull/1052#discussion_r449897079"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1052,
      "file_path": "tests/common.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,5 @@\n+import pathlib\n+\n+TESTS_DIR = pathlib.Path(__file__).parent\n+TESTS_DIR = TESTS_DIR.relative_to(TESTS_DIR.parent)  # Ensure relative to project root.",
      "comment": "Good call @jcugat, updated the PR. Running `pytest` from inside `httpx/tests/` runs tests fine now. :-)",
      "comment_id": 450674376,
      "user": "florimondmanca",
      "created_at": "2020-07-07T07:50:05Z",
      "url": "https://github.com/encode/httpx/pull/1052#discussion_r450674376"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1032,
      "file_path": "httpx/_content_streams.py",
      "line": 332,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,7 +328,8 @@ def _iter_fields(\n             else:\n                 yield self.DataField(name=name, value=value)\n \n-        for name, value in files.items():\n+        file_items = files.items() if isinstance(files, dict) else files\n+        for name, value in file_items:  # type: ignore",
      "comment": "No idea how to fix the mypy error on this line `httpx/_content_streams.py:332: error: Unpacking a string is disallowed\r\n`",
      "comment_id": 444935193,
      "user": "euri10",
      "created_at": "2020-06-24T14:28:02Z",
      "url": "https://github.com/encode/httpx/pull/1032#discussion_r444935193"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1032,
      "file_path": "httpx/_content_streams.py",
      "line": 332,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,7 +328,8 @@ def _iter_fields(\n             else:\n                 yield self.DataField(name=name, value=value)\n \n-        for name, value in files.items():\n+        file_items = files.items() if isinstance(files, dict) else files\n+        for name, value in file_items:  # type: ignore",
      "comment": "I think it\u2019s because the type hints is using Mapping but we\u2019re only matching against dict (a specific type of mapping), so mypy assumes that the other branch could also receive other types of mappings, and iterating over a mapping yields its keys (strings).\n\nIt\u2019s actually possible to `isinstance(obj, typing.Mapping)` (since it\u2019s the same Mapping class than in collections.abc), so I think we can go for that?\n\nAlternatively, switch the `if` to match a tuple (and treat the default case as mapping) - probably a bit less surprising.",
      "comment_id": 444942187,
      "user": "florimondmanca",
      "created_at": "2020-06-24T14:36:53Z",
      "url": "https://github.com/encode/httpx/pull/1032#discussion_r444942187"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1032,
      "file_path": "tests/test_content_streams.py",
      "line": 217,
      "side": "RIGHT",
      "diff_hunk": "@@ -204,3 +204,50 @@ async def test_empty_request():\n def test_invalid_argument():\n     with pytest.raises(TypeError):\n         encode(123)\n+\n+\n+@pytest.mark.asyncio\n+async def test_multipart_multiple_files_single_input_content():\n+    files = [\n+        (\"file\", io.BytesIO(b\"<file content 1>\")),\n+        (\"file\", io.BytesIO(b\"<file content 2>\")),\n+    ]\n+    stream = encode(files=files, boundary=b\"+++\")\n+    sync_content = b\"\".join([part for part in stream])\n+    async_content = b\"\".join([part async for part in stream])",
      "comment": "Is there value in testing for the sync and async content concatenation here? I think we\u2019re using async for in the other test cases.\n\n(If there\u2019s a missing test case for \u201casync for yields the same than for\u201d then we could add it, but separately to this PR imo.)",
      "comment_id": 444943311,
      "user": "florimondmanca",
      "created_at": "2020-06-24T14:38:20Z",
      "url": "https://github.com/encode/httpx/pull/1032#discussion_r444943311"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1032,
      "file_path": "tests/test_content_streams.py",
      "line": 217,
      "side": "RIGHT",
      "diff_hunk": "@@ -204,3 +204,50 @@ async def test_empty_request():\n def test_invalid_argument():\n     with pytest.raises(TypeError):\n         encode(123)\n+\n+\n+@pytest.mark.asyncio\n+async def test_multipart_multiple_files_single_input_content():\n+    files = [\n+        (\"file\", io.BytesIO(b\"<file content 1>\")),\n+        (\"file\", io.BytesIO(b\"<file content 2>\")),\n+    ]\n+    stream = encode(files=files, boundary=b\"+++\")\n+    sync_content = b\"\".join([part for part in stream])\n+    async_content = b\"\".join([part async for part in stream])",
      "comment": "I basically took the previous PR test and didn't think about it but looking all tests inside the module all have the very same joins on both sync and async.",
      "comment_id": 444951244,
      "user": "euri10",
      "created_at": "2020-06-24T14:48:30Z",
      "url": "https://github.com/encode/httpx/pull/1032#discussion_r444951244"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1032,
      "file_path": "tests/test_content_streams.py",
      "line": 217,
      "side": "RIGHT",
      "diff_hunk": "@@ -204,3 +204,50 @@ async def test_empty_request():\n def test_invalid_argument():\n     with pytest.raises(TypeError):\n         encode(123)\n+\n+\n+@pytest.mark.asyncio\n+async def test_multipart_multiple_files_single_input_content():\n+    files = [\n+        (\"file\", io.BytesIO(b\"<file content 1>\")),\n+        (\"file\", io.BytesIO(b\"<file content 2>\")),\n+    ]\n+    stream = encode(files=files, boundary=b\"+++\")\n+    sync_content = b\"\".join([part for part in stream])\n+    async_content = b\"\".join([part async for part in stream])",
      "comment": "Ah, right, sorry then I didn\u2019t actually check the code before writing that up. \ud83d\ude05 Either way works then, and we can clean up the tests later.",
      "comment_id": 445019205,
      "user": "florimondmanca",
      "created_at": "2020-06-24T16:26:04Z",
      "url": "https://github.com/encode/httpx/pull/1032#discussion_r445019205"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1021,
      "file_path": "httpx/_transports/asgi.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -144,7 +148,7 @@ async def send(message: dict) -> None:\n         try:\n             await self.app(scope, receive, send)\n         except Exception:\n-            if self.raise_app_exceptions or not response_complete:\n+            if self.raise_app_exceptions or not response_complete.is_set():",
      "comment": "Think that was my mistake. Missed this when changing `response_complete` from a bool to an event. Also didn't realise the `nonlocal` could be removed \ud83d\ude2c ",
      "comment_id": 439751016,
      "user": "JayH5",
      "created_at": "2020-06-13T16:26:04Z",
      "url": "https://github.com/encode/httpx/pull/1021#discussion_r439751016"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1012,
      "file_path": "tests/client/test_auth.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,6 +51,29 @@ async def request(\n         return b\"HTTP/1.1\", self.status_code, b\"\", response_headers, response_stream\n \n \n+class SyncMockTransport(httpcore.SyncHTTPTransport):",
      "comment": "I didn't manage to reuse the code from `AsyncMockTransport` without copy&pasting it.",
      "comment_id": 432935540,
      "user": "jcugat",
      "created_at": "2020-05-31T11:07:50Z",
      "url": "https://github.com/encode/httpx/pull/1012#discussion_r432935540"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1012,
      "file_path": "tests/concurrency.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +10,6 @@\n \n async def sleep(seconds: float) -> None:\n     if sniffio.current_async_library() == \"trio\":\n-        await trio.sleep(seconds)\n+        await trio.sleep(seconds)  # pragma: nocover",
      "comment": "This `sleep()` method is only used from `conftest.TestServer`, but the server always runs under the `asyncio` loop so the `trio` branch is never executed.",
      "comment_id": 432935648,
      "user": "jcugat",
      "created_at": "2020-05-31T11:09:22Z",
      "url": "https://github.com/encode/httpx/pull/1012#discussion_r432935648"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1012,
      "file_path": "tests/client/test_auth.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,6 +51,29 @@ async def request(\n         return b\"HTTP/1.1\", self.status_code, b\"\", response_headers, response_stream\n \n \n+class SyncMockTransport(httpcore.SyncHTTPTransport):",
      "comment": "I would naively suggest moving the body of `request` to a separate function? Seems like it's all synchronous code, but it's not a big deal anyway.",
      "comment_id": 433100851,
      "user": "yeraydiazdiaz",
      "created_at": "2020-06-01T08:15:50Z",
      "url": "https://github.com/encode/httpx/pull/1012#discussion_r433100851"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1012,
      "file_path": "tests/client/test_redirects.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,9 +156,43 @@ async def body():\n         return b\"HTTP/1.1\", 200, b\"OK\", [], ByteStream(b\"Hello, world!\")\n \n \n+class SyncMockTransport(httpcore.SyncHTTPTransport):",
      "comment": "I would suggest the same as above, this one is a bit longer so it adds a bit more noise, but again no big deal.",
      "comment_id": 433103321,
      "user": "yeraydiazdiaz",
      "created_at": "2020-06-01T08:21:28Z",
      "url": "https://github.com/encode/httpx/pull/1012#discussion_r433103321"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1012,
      "file_path": "tests/client/test_auth.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,6 +51,29 @@ async def request(\n         return b\"HTTP/1.1\", self.status_code, b\"\", response_headers, response_stream\n \n \n+class SyncMockTransport(httpcore.SyncHTTPTransport):",
      "comment": "Personally I'm usually okay with a bit of carefully applied light duplication like this, but happy enough either ways. \ud83d\ude04",
      "comment_id": 433111079,
      "user": "lovelydinosaur",
      "created_at": "2020-06-01T08:39:39Z",
      "url": "https://github.com/encode/httpx/pull/1012#discussion_r433111079"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1012,
      "file_path": "tests/client/test_auth.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,6 +51,29 @@ async def request(\n         return b\"HTTP/1.1\", self.status_code, b\"\", response_headers, response_stream\n \n \n+class SyncMockTransport(httpcore.SyncHTTPTransport):",
      "comment": "I've moved it into a class instead, this way the `__init__` is also reused.",
      "comment_id": 433173927,
      "user": "jcugat",
      "created_at": "2020-06-01T11:08:54Z",
      "url": "https://github.com/encode/httpx/pull/1012#discussion_r433173927"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1012,
      "file_path": "tests/client/test_redirects.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,9 +156,43 @@ async def body():\n         return b\"HTTP/1.1\", 200, b\"OK\", [], ByteStream(b\"Hello, world!\")\n \n \n+class SyncMockTransport(httpcore.SyncHTTPTransport):",
      "comment": "For this one it's a bit harder, since there are a couple of `part async for part in stream` inside. I tried changing those to `part for part in stream` but it fails with `RuntimeError: Attempted to call a sync iterator on an async stream.`.\r\n\r\nIt's only really used in `redirect_body_target` (in the other usages the content is discarded). Is there any way to fetch the stream independently from the context (async/sync) we're in?",
      "comment_id": 433175913,
      "user": "jcugat",
      "created_at": "2020-06-01T11:13:56Z",
      "url": "https://github.com/encode/httpx/pull/1012#discussion_r433175913"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1012,
      "file_path": "tests/client/test_redirects.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,9 +156,43 @@ async def body():\n         return b\"HTTP/1.1\", 200, b\"OK\", [], ByteStream(b\"Hello, world!\")\n \n \n+class SyncMockTransport(httpcore.SyncHTTPTransport):",
      "comment": "Nevermind, I used the example in [custom transports](https://www.python-httpx.org/advanced/#custom-transports) and it's working now :)",
      "comment_id": 433179599,
      "user": "jcugat",
      "created_at": "2020-06-01T11:23:42Z",
      "url": "https://github.com/encode/httpx/pull/1012#discussion_r433179599"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1012,
      "file_path": "tests/client/test_redirects.py",
      "line": 387,
      "side": "RIGHT",
      "diff_hunk": "@@ -348,19 +380,19 @@ async def test_can_stream_if_no_redirect():\n \n @pytest.mark.usefixtures(\"async_environment\")\n async def test_cannot_redirect_streaming_body():\n-    client = AsyncClient(transport=MockTransport())\n+    client = AsyncClient(transport=AsyncMockTransport())\n     url = \"https://example.org/redirect_body\"\n \n     async def streaming_body():\n-        yield b\"Example request body\"\n+        yield b\"Example request body\"  # pragma: nocover",
      "comment": "Had to add this since we need a streaming body for this test, although is never consumed.",
      "comment_id": 433184602,
      "user": "jcugat",
      "created_at": "2020-06-01T11:36:11Z",
      "url": "https://github.com/encode/httpx/pull/1012#discussion_r433184602"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1003,
      "file_path": "httpx/_models.py",
      "line": 483,
      "side": "LEFT",
      "diff_hunk": "@@ -481,9 +481,6 @@ def update(self, headers: HeaderTypes = None) -> None:  # type: ignore\n         for header in headers:\n             self[header] = headers[header]\n \n-    def copy(self) -> \"Headers\":\n-        return Headers(self.items(), encoding=self.encoding)\n-",
      "comment": "Did you mean to remove this? Evidently we're not using it right now, but we *probably* still want it as part of the public API. (Or at least, if we *did* want to remove it, then it's a *small* breaking change, so we'd need to do so in a major version bump, so we can call it out in the CHANGELOG)",
      "comment_id": 431700756,
      "user": "lovelydinosaur",
      "created_at": "2020-05-28T09:24:35Z",
      "url": "https://github.com/encode/httpx/pull/1003#discussion_r431700756"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1003,
      "file_path": "httpx/_models.py",
      "line": 483,
      "side": "LEFT",
      "diff_hunk": "@@ -481,9 +481,6 @@ def update(self, headers: HeaderTypes = None) -> None:  # type: ignore\n         for header in headers:\n             self[header] = headers[header]\n \n-    def copy(self) -> \"Headers\":\n-        return Headers(self.items(), encoding=self.encoding)\n-",
      "comment": "I'd prefer to keep it altogether, I feel a lot of our users to header manipulation and rely on this method.",
      "comment_id": 431708729,
      "user": "yeraydiazdiaz",
      "created_at": "2020-05-28T09:38:19Z",
      "url": "https://github.com/encode/httpx/pull/1003#discussion_r431708729"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1003,
      "file_path": "httpx/_models.py",
      "line": 483,
      "side": "LEFT",
      "diff_hunk": "@@ -481,9 +481,6 @@ def update(self, headers: HeaderTypes = None) -> None:  # type: ignore\n         for header in headers:\n             self[header] = headers[header]\n \n-    def copy(self) -> \"Headers\":\n-        return Headers(self.items(), encoding=self.encoding)\n-",
      "comment": "Hey @tomchristie, yes, I removed it on purpose since it isn't documented and I thought it was just used internally: https://www.python-httpx.org/api/#url\r\n",
      "comment_id": 431710066,
      "user": "jcugat",
      "created_at": "2020-05-28T09:40:40Z",
      "url": "https://github.com/encode/httpx/pull/1003#discussion_r431710066"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1003,
      "file_path": "httpx/_models.py",
      "line": 483,
      "side": "LEFT",
      "diff_hunk": "@@ -481,9 +481,6 @@ def update(self, headers: HeaderTypes = None) -> None:  # type: ignore\n         for header in headers:\n             self[header] = headers[header]\n \n-    def copy(self) -> \"Headers\":\n-        return Headers(self.items(), encoding=self.encoding)\n-",
      "comment": "Also I noticed the same thing can be done already with the class constructor, but happy to roll this change back if you prefer \ud83d\ude42 \r\nhttps://github.com/encode/httpx/blob/21d7e16559d9360ae3a5c5cfd23bab8bb85ee4a8/httpx/_models.py#L391",
      "comment_id": 431711258,
      "user": "jcugat",
      "created_at": "2020-05-28T09:42:45Z",
      "url": "https://github.com/encode/httpx/pull/1003#discussion_r431711258"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1003,
      "file_path": "httpx/_models.py",
      "line": 483,
      "side": "LEFT",
      "diff_hunk": "@@ -481,9 +481,6 @@ def update(self, headers: HeaderTypes = None) -> None:  # type: ignore\n         for header in headers:\n             self[header] = headers[header]\n \n-    def copy(self) -> \"Headers\":\n-        return Headers(self.items(), encoding=self.encoding)\n-",
      "comment": "I've added the method back and documented & tested it.",
      "comment_id": 432041728,
      "user": "jcugat",
      "created_at": "2020-05-28T18:37:11Z",
      "url": "https://github.com/encode/httpx/pull/1003#discussion_r432041728"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1002,
      "file_path": "httpx/_client.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -322,6 +322,10 @@ def redirect_url(self, request: Request, response: Response) -> URL:\n \n         url = URL(location, allow_relative=True)\n \n+        # Check that we can handle the scheme\n+        if url.scheme and url.scheme not in (\"http\", \"https\"):",
      "comment": "This pattern `(\"http\", \"https\")` (or something similar) is repeated in a few places, like:\r\n\r\nhttps://github.com/jcugat/httpx/blob/9160631d7fb957a319ce8985c97a858f8eab49a3/httpx/_client.py#L609\r\nhttps://github.com/jcugat/httpx/blob/9160631d7fb957a319ce8985c97a858f8eab49a3/httpx/_models.py#L105\r\nhttps://github.com/jcugat/httpx/blob/9160631d7fb957a319ce8985c97a858f8eab49a3/httpx/_models.py#L132\r\n\r\nIt would probably make sense to unify it in a single place.",
      "comment_id": 431393847,
      "user": "jcugat",
      "created_at": "2020-05-27T19:31:22Z",
      "url": "https://github.com/encode/httpx/pull/1002#discussion_r431393847"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 1002,
      "file_path": "httpx/_client.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -322,6 +322,10 @@ def redirect_url(self, request: Request, response: Response) -> URL:\n \n         url = URL(location, allow_relative=True)\n \n+        # Check that we can handle the scheme\n+        if url.scheme and url.scheme not in (\"http\", \"https\"):",
      "comment": "In these kinds of cases, if it's a single-liner I'd often prefer *not* to introduce indirection. It's as clear as it can possibly be, and it's not a complicated expression.",
      "comment_id": 431808262,
      "user": "lovelydinosaur",
      "created_at": "2020-05-28T12:48:05Z",
      "url": "https://github.com/encode/httpx/pull/1002#discussion_r431808262"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 985,
      "file_path": "httpx/_types.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,7 +26,7 @@\n     from ._config import Proxy, Timeout  # noqa: F401\n     from ._models import URL, Cookies, Headers, QueryParams, Request  # noqa: F401\n \n-StrOrBytes = Union[str, bytes]\n+StrOrBytes = TypeVar(\"StrOrBytes\", str, bytes)",
      "comment": "Was this change required somehow? We specifically don't want to use type vars/generics for `HeaderTypes` and others \u2014 we initially used that but realized a `Union` better fits what we accept (i.e. \"`str` _or_ `bytes`, I don't care\").\r\n\r\nWe initially used `typing.AnyStr` as our \"str or bytes\" annotation (which this is equivalent to), but changed it because ",
      "comment_id": 429614834,
      "user": "florimondmanca",
      "created_at": "2020-05-24T09:01:40Z",
      "url": "https://github.com/encode/httpx/pull/985#discussion_r429614834"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 985,
      "file_path": "tests/client/test_async_client.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,12 +1,14 @@\n from datetime import timedelta\n+from typing import AsyncGenerator\n \n import pytest\n+from uvicorn.main import Server\n \n import httpx\n \n \n @pytest.mark.usefixtures(\"async_environment\")\n-async def test_get(server):\n+async def test_get(server: Server) -> None:\n     url = server.url",
      "comment": "I'm a bit curious about why this works at all \u2014 Uvicorn's `Server` doesn't have a `.url` property, but our `TestServer` does. \ud83e\udd14 I assume it's because Uvicorn doesn't ship type annotations so mypy really just treats `Server` as `Any`? (A `reveal_type(server)` could help confirm it.)\r\n\r\nI don't think importing from `conftest` is common practice? If not we might need to move the `TestServer` (and some other items) to `utils.py`. And we might as well rename `TestServer` as `Server`? (Any such changes should  probably go into their own PRs too, right?)\r\n\r\n(I realize there are some rough edges to clean up here and there for us to be able to roll out type hints to the tests code more fluently in the future; I think it's okay to do that small bit of work first.)",
      "comment_id": 429614983,
      "user": "florimondmanca",
      "created_at": "2020-05-24T09:03:34Z",
      "url": "https://github.com/encode/httpx/pull/985#discussion_r429614983"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 985,
      "file_path": "httpx/_types.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -38,7 +40,9 @@\n ]\n \n HeaderTypes = Union[\n-    \"Headers\", Dict[StrOrBytes, StrOrBytes], Sequence[Tuple[StrOrBytes, StrOrBytes]],\n+    \"Headers\",\n+    MutableMapping[StrOrBytes, StrOrBytes],",
      "comment": "Should we consider submitting this change as its own \"fix headers type annotations\" PR? Very similar to #976. (We tend to strongly go for \"one PR = one change\", mostly because then it's easier to decide what goes into release changelogs and what don't.)",
      "comment_id": 429615097,
      "user": "florimondmanca",
      "created_at": "2020-05-24T09:05:19Z",
      "url": "https://github.com/encode/httpx/pull/985#discussion_r429615097"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 985,
      "file_path": "httpx/_types.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,7 +26,7 @@\n     from ._config import Proxy, Timeout  # noqa: F401\n     from ._models import URL, Cookies, Headers, QueryParams, Request  # noqa: F401\n \n-StrOrBytes = Union[str, bytes]\n+StrOrBytes = TypeVar(\"StrOrBytes\", str, bytes)",
      "comment": "I tried `MutableMapping[StrOrBytes, StrOrBytes]`, but I had the incompatibility error. that's why I decided to change the `StrOrBytes`.\r\nWhat should we do? split  `Dict[StrOrBytes, StrOrBytes]` in `HeaderTypes` to `MutableMapping[str, str], MutableMapping[bytes, bytes]`?",
      "comment_id": 429624707,
      "user": "hramezani",
      "created_at": "2020-05-24T11:04:46Z",
      "url": "https://github.com/encode/httpx/pull/985#discussion_r429624707"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 985,
      "file_path": "httpx/_types.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -38,7 +40,9 @@\n ]\n \n HeaderTypes = Union[\n-    \"Headers\", Dict[StrOrBytes, StrOrBytes], Sequence[Tuple[StrOrBytes, StrOrBytes]],\n+    \"Headers\",\n+    MutableMapping[StrOrBytes, StrOrBytes],",
      "comment": "FYI I'm in the process of opening a PR for this that also resolves the odd mypy error you mentioned here https://github.com/encode/httpx/pull/985#discussion_r429624707 :-)\r\n\r\nEdit: https://github.com/encode/httpx/pull/993",
      "comment_id": 429624891,
      "user": "florimondmanca",
      "created_at": "2020-05-24T11:07:13Z",
      "url": "https://github.com/encode/httpx/pull/985#discussion_r429624891"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 985,
      "file_path": "tests/client/test_async_client.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,12 +1,14 @@\n from datetime import timedelta\n+from typing import AsyncGenerator\n \n import pytest\n+from uvicorn.main import Server\n \n import httpx\n \n \n @pytest.mark.usefixtures(\"async_environment\")\n-async def test_get(server):\n+async def test_get(server: Server) -> None:\n     url = server.url",
      "comment": "> I'm a bit curious about why this works at all \u2014 Uvicorn's Server doesn't have a .url property, but our TestServer does. thinking I assume it's because Uvicorn doesn't ship type annotations so mypy really just treats Server as Any? (A reveal_type(server) could help confirm it.)\r\n\r\nYes, you are right. its type is `Any`.\r\n\r\n> I don't think importing from conftest is common practice? If not we might need to move the TestServer (and some other items) to utils.py. And we might as well rename TestServer as Server? (Any such changes should probably go into their own PRs too, right?)\r\n\r\nI will do this in separate PR as well",
      "comment_id": 429625454,
      "user": "hramezani",
      "created_at": "2020-05-24T11:15:15Z",
      "url": "https://github.com/encode/httpx/pull/985#discussion_r429625454"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 985,
      "file_path": "tests/client/test_async_client.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,12 +1,14 @@\n from datetime import timedelta\n+from typing import AsyncGenerator\n \n import pytest\n+from uvicorn.main import Server\n \n import httpx\n \n \n @pytest.mark.usefixtures(\"async_environment\")\n-async def test_get(server):\n+async def test_get(server: Server) -> None:\n     url = server.url",
      "comment": "What do you think about #991?\r\n\r\nI'm thinking adding the `server: Server` annotations everywhere is super cumbersome, and doesn't add a lot of value. We can have mypy type check the inside of our test functions anyway, which will save us a big amount of work. If we go for that approach, then we actually don't really need to move `TestServer` anywhere (since we won't really need to import it for type hints purposes).\r\n\r\nBesides, note that I initally submitted #990 but closed it as I think #991 is a better way forward.",
      "comment_id": 429625657,
      "user": "florimondmanca",
      "created_at": "2020-05-24T11:18:05Z",
      "url": "https://github.com/encode/httpx/pull/985#discussion_r429625657"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 985,
      "file_path": "httpx/_types.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,7 +26,7 @@\n     from ._config import Proxy, Timeout  # noqa: F401\n     from ._models import URL, Cookies, Headers, QueryParams, Request  # noqa: F401\n \n-StrOrBytes = Union[str, bytes]\n+StrOrBytes = TypeVar(\"StrOrBytes\", str, bytes)",
      "comment": "Yeah, it's odd. I actually traced that back to a mypy limitation in `Mapping`/`MutableMapping` (the key type is invariant). Opened #993 with a tight fix inspired by yours here. :-)",
      "comment_id": 429625738,
      "user": "florimondmanca",
      "created_at": "2020-05-24T11:19:14Z",
      "url": "https://github.com/encode/httpx/pull/985#discussion_r429625738"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 985,
      "file_path": "tests/client/test_async_client.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,12 +1,14 @@\n from datetime import timedelta\n+from typing import AsyncGenerator\n \n import pytest\n+from uvicorn.main import Server\n \n import httpx\n \n \n @pytest.mark.usefixtures(\"async_environment\")\n-async def test_get(server):\n+async def test_get(server: Server) -> None:\n     url = server.url",
      "comment": "Thanks for the PR :+1:  . Yes, I agree with you. this change will save our time and we can go faster.",
      "comment_id": 429626752,
      "user": "hramezani",
      "created_at": "2020-05-24T11:30:36Z",
      "url": "https://github.com/encode/httpx/pull/985#discussion_r429626752"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 999,
      "file_path": "httpx/_types.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -38,7 +38,7 @@\n ]\n \n HeaderTypes = Union[\n-    \"Headers\", Dict[StrOrBytes, StrOrBytes], Sequence[Tuple[StrOrBytes, StrOrBytes]],\n+    \"Headers\", Dict[AnyStr, AnyStr], Sequence[Tuple[AnyStr, AnyStr]],",
      "comment": "Based off @yeraydiazdiaz's observations it seems this might be closer to what we need:\r\n\r\n```suggestion\r\n    \"Headers\",\r\n    Dict[str, str],\r\n    Dict[bytes, bytes],\r\n    Sequence[Tuple[str, str]],\r\n    Sequence[Tuple[bytes, bytes]],\r\n```\r\n\r\nIt would work (i.e. tell users \"use either str/str or bytes/bytes, but don't mix\") even outside of functions :+1:",
      "comment_id": 430374891,
      "user": "florimondmanca",
      "created_at": "2020-05-26T12:30:14Z",
      "url": "https://github.com/encode/httpx/pull/999#discussion_r430374891"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 995,
      "file_path": "tests/client/test_client.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +37,22 @@ def test_build_request(server):\n     assert response.json()[\"Custom-header\"] == \"value\"\n \n \n+def test_build_port_request(server):",
      "comment": "Tiny typo :-)\r\n\r\n```suggestion\r\ndef test_build_post_request(server):\r\n```",
      "comment_id": 430021388,
      "user": "florimondmanca",
      "created_at": "2020-05-25T17:05:37Z",
      "url": "https://github.com/encode/httpx/pull/995#discussion_r430021388"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 992,
      "file_path": "httpx/_types.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,7 +45,11 @@\n \n CertTypes = Union[str, Tuple[str, str], Tuple[str, str, str]]\n VerifyTypes = Union[str, bool, ssl.SSLContext]\n-TimeoutTypes = Union[None, float, Tuple[float, float, float, float], \"Timeout\"]\n+TimeoutTypes = Union[\n+    Optional[float],\n+    Tuple[Optional[float], Optional[float], Optional[float], Optional[float]],",
      "comment": "`Timeout` seems to require [the first two elements of the tuple to be not `None`](https://github.com/encode/httpx/blob/master/httpx/_config.py#L229-L230), do we want to keep those as not optional?",
      "comment_id": 429625120,
      "user": "yeraydiazdiaz",
      "created_at": "2020-05-24T11:10:31Z",
      "url": "https://github.com/encode/httpx/pull/992#discussion_r429625120"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 992,
      "file_path": "httpx/_types.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,7 +45,11 @@\n \n CertTypes = Union[str, Tuple[str, str], Tuple[str, str, str]]\n VerifyTypes = Union[str, bool, ssl.SSLContext]\n-TimeoutTypes = Union[None, float, Tuple[float, float, float, float], \"Timeout\"]\n+TimeoutTypes = Union[\n+    Optional[float],\n+    Tuple[Optional[float], Optional[float], Optional[float], Optional[float]],",
      "comment": "It seems actually we _do_ allow those to be `None` (which makes sense - don't think there's a reason we'd want to prevent people from disabling connect/read timeouts):\r\n\r\nhttps://github.com/encode/httpx/blob/440b5ab95faf94f56472e08c8c5dbf59b2175fc6/httpx/_config.py#L210-L211\r\n\r\nHowever for some reason we allow any of a 2-, 3- or 4- tuple. \ud83e\udd14 \r\n\r\nAlso we don't document the tuple usage in [Fine-tuning timeouts](https://www.python-httpx.org/advanced/#fine-tuning-the-configuration), instead hinting people to use kwargs, eg `Timeout(read_timeout=...)`. \ud83e\udd14\r\n\r\nSo, is this tuple form actually something we should drop altogether?\r\n\r\nIn any case, I think the annotations here are in line with what `Timeout` accepts, so we can merge this either way and keep that for later discussion.",
      "comment_id": 429635440,
      "user": "florimondmanca",
      "created_at": "2020-05-24T13:14:07Z",
      "url": "https://github.com/encode/httpx/pull/992#discussion_r429635440"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 992,
      "file_path": "httpx/_types.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,7 +45,11 @@\n \n CertTypes = Union[str, Tuple[str, str], Tuple[str, str, str]]\n VerifyTypes = Union[str, bool, ssl.SSLContext]\n-TimeoutTypes = Union[None, float, Tuple[float, float, float, float], \"Timeout\"]\n+TimeoutTypes = Union[\n+    Optional[float],\n+    Tuple[Optional[float], Optional[float], Optional[float], Optional[float]],",
      "comment": "Ah sorry, I misread that \ud83d\udc4d \r\n\r\nI don't think there's a lot of benefit from the tuple form FWIW.",
      "comment_id": 429649266,
      "user": "yeraydiazdiaz",
      "created_at": "2020-05-24T15:43:57Z",
      "url": "https://github.com/encode/httpx/pull/992#discussion_r429649266"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 785,
      "file_path": "tests/test_multipart.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,10 +7,10 @@\n import pytest\n \n import httpx\n-from httpx.config import CertTypes, TimeoutTypes, VerifyTypes\n-from httpx.content_streams import encode\n-from httpx.dispatch.base import AsyncDispatcher\n-from httpx.utils import format_form_param\n+from httpx._config import CertTypes, TimeoutTypes, VerifyTypes",
      "comment": "Incidentally, it looks like we've erronously left the signature as `send(request, verify, cert, timeout)` in a bunch of these and other test cases, rather than switching to `send(request, timeout)` on the dispatch interface.\r\n\r\nWe're missing those because we're not type checking our test cases.\r\n\r\nNot related to this PR, so doesn't neccessarily need to change here, but this helps highlight it, since we're pulling in more private API that we might otherwise expect.",
      "comment_id": 369518991,
      "user": "lovelydinosaur",
      "created_at": "2020-01-22T11:57:11Z",
      "url": "https://github.com/encode/httpx/pull/785#discussion_r369518991"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 968,
      "file_path": "httpx/_config.py",
      "line": 319,
      "side": "RIGHT",
      "diff_hunk": "@@ -288,29 +289,47 @@ class PoolLimits:\n \n     **Parameters:**\n \n-    * **soft_limit** - Allow the connection pool to maintain keep-alive connections\n+    * **max_keepalive** - Allow the connection pool to maintain keep-alive connections\n                        below this point.\n-    * **hard_limit** - The maximum number of concurrent connections that may be\n+    * **max_connections** - The maximum number of concurrent connections that may be\n                        established.\n     \"\"\"\n \n     def __init__(\n-        self, *, soft_limit: int = None, hard_limit: int = None,\n+        self,\n+        *,\n+        max_keepalive: int = None,\n+        max_connections: int = None,\n+        soft_limit: int = None,\n+        hard_limit: int = None,\n     ):\n-        self.soft_limit = soft_limit\n-        self.hard_limit = hard_limit\n+        self.max_keepalive = max_keepalive\n+        self.max_connections = max_connections\n+        if soft_limit is not None:  # pragma: nocover\n+            self.max_keepalive = soft_limit\n+            warnings.warn(\n+                \"'soft_limit' is deprecated. Use 'max_keepalive' instead.\",\n+                DeprecationWarning,\n+            )\n+        if hard_limit is not None:  # pragma: nocover\n+            self.max_connections = hard_limit\n+            warnings.warn(\n+                \"'hard_limit' is deprecated. Use 'max_connections' instead.\",\n+                DeprecationWarning,\n+            )",
      "comment": "You can use the new [`warn_deprecated` util function.](https://github.com/encode/httpx/blob/master/httpx/_utils.py#L406-L407)",
      "comment_id": 428598218,
      "user": "yeraydiazdiaz",
      "created_at": "2020-05-21T11:33:07Z",
      "url": "https://github.com/encode/httpx/pull/968#discussion_r428598218"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 968,
      "file_path": "httpx/_config.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -288,29 +288,43 @@ class PoolLimits:\n \n     **Parameters:**\n \n-    * **soft_limit** - Allow the connection pool to maintain keep-alive connections\n+    * **max_keepalive** - Allow the connection pool to maintain keep-alive connections\n                        below this point.\n-    * **hard_limit** - The maximum number of concurrent connections that may be\n+    * **max_connections** - The maximum number of concurrent connections that may be\n                        established.\n     \"\"\"\n \n     def __init__(\n-        self, *, soft_limit: int = None, hard_limit: int = None,\n+        self,\n+        *,\n+        max_keepalive: int = None,\n+        max_connections: int = None,\n+        soft_limit: int = None,\n+        hard_limit: int = None,\n     ):\n-        self.soft_limit = soft_limit\n-        self.hard_limit = hard_limit\n+        self.max_keepalive = max_keepalive\n+        self.max_connections = max_connections\n+        if soft_limit is not None:  # pragma: nocover\n+            self.max_keepalive = soft_limit\n+            warn_deprecated(\"'soft_limit' is deprecated. Use 'max_keepalive' instead.\",)\n+        if hard_limit is not None:  # pragma: nocover\n+            self.max_connections = hard_limit\n+            warn_deprecated(\n+                \"'hard_limit' is deprecated. Use 'max_connections' instead.\",\n+            )",
      "comment": "I _assume_ eventually one of the linters is going to cough on the extra commas here, so just a heads up:\r\n\r\n```suggestion\r\n        if soft_limit is not None:  # pragma: nocover\r\n            self.max_keepalive = soft_limit\r\n            warn_deprecated(\"'soft_limit' is deprecated. Use 'max_keepalive' instead.\")\r\n        if hard_limit is not None:  # pragma: nocover\r\n            self.max_connections = hard_limit\r\n            warn_deprecated(\r\n                \"'hard_limit' is deprecated. Use 'max_connections' instead.\"\r\n            )\r\n```",
      "comment_id": 428606595,
      "user": "florimondmanca",
      "created_at": "2020-05-21T11:53:38Z",
      "url": "https://github.com/encode/httpx/pull/968#discussion_r428606595"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 963,
      "file_path": "httpx/__init__.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,8 +3,8 @@\n from ._auth import Auth, BasicAuth, DigestAuth\n from ._client import AsyncClient, Client\n from ._config import PoolLimits, Proxy, Timeout\n-from ._dispatch.asgi import ASGIDispatch\n-from ._dispatch.wsgi import WSGIDispatch\n+from ._transports.asgi import ASGIDispatch, ASGITransport\n+from ._transports.wsgi import WSGIDispatch, WSGITransport",
      "comment": "Fantastic yes. We'll want `URLLib3Transport` here, too.",
      "comment_id": 428127686,
      "user": "lovelydinosaur",
      "created_at": "2020-05-20T15:59:45Z",
      "url": "https://github.com/encode/httpx/pull/963#discussion_r428127686"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 963,
      "file_path": "httpx/_client.py",
      "line": 463,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,16 +459,24 @@ def __init__(\n \n         proxy_map = self.get_proxy_map(proxies, trust_env)\n \n-        self.dispatch = self.init_dispatch(\n+        if dispatch is not None:\n+            warnings.warn(",
      "comment": "Do we want to make the `category` of these warnings `DeprecationWarning` (like #908)?",
      "comment_id": 428279889,
      "user": "JayH5",
      "created_at": "2020-05-20T20:11:44Z",
      "url": "https://github.com/encode/httpx/pull/963#discussion_r428279889"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 963,
      "file_path": "httpx/_client.py",
      "line": 463,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,16 +459,25 @@ def __init__(\n \n         proxy_map = self.get_proxy_map(proxies, trust_env)\n \n-        self.dispatch = self.init_dispatch(\n+        if dispatch is not None:\n+            warnings.warn(",
      "comment": "I'm tempted to follow up with a PR that adds a small `warn_deprecated()` util that we can use in cases like this, to not forget the `DeprecationWarning` :)",
      "comment_id": 428502778,
      "user": "florimondmanca",
      "created_at": "2020-05-21T07:56:19Z",
      "url": "https://github.com/encode/httpx/pull/963#discussion_r428502778"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 963,
      "file_path": "httpx/_transports/wsgi.py",
      "line": 145,
      "side": "RIGHT",
      "diff_hunk": "@@ -131,3 +132,20 @@ def start_response(\n         stream = IteratorStream(chunk for chunk in result)\n \n         return (b\"HTTP/1.1\", status_code, b\"\", headers, stream)\n+\n+\n+class WSGIDispatch(WSGITransport):\n+    def __init__(\n+        self,\n+        app: typing.Callable,\n+        raise_app_exceptions: bool = True,\n+        script_name: str = \"\",\n+        remote_addr: str = \"127.0.0.1\",\n+    ) -> None:\n+        warnings.warn(\"WSGIDispatch is deprecated, please use WSGITransport\")",
      "comment": "`DeprecationWarning` is missing here as well - let's review the `warnings.warn` additions to make sure we use it everywhere?",
      "comment_id": 428504703,
      "user": "florimondmanca",
      "created_at": "2020-05-21T08:00:45Z",
      "url": "https://github.com/encode/httpx/pull/963#discussion_r428504703"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 963,
      "file_path": "httpx/_client.py",
      "line": 463,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,16 +459,25 @@ def __init__(\n \n         proxy_map = self.get_proxy_map(proxies, trust_env)\n \n-        self.dispatch = self.init_dispatch(\n+        if dispatch is not None:\n+            warnings.warn(",
      "comment": "Just pushed https://github.com/encode/httpx/pull/964 \ud83d\ude04 ",
      "comment_id": 428507736,
      "user": "florimondmanca",
      "created_at": "2020-05-21T08:07:59Z",
      "url": "https://github.com/encode/httpx/pull/963#discussion_r428507736"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 946,
      "file_path": "tests/conftest.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,12 +102,7 @@ async def hello_world(scope, receive, send):\n \n \n async def slow_response(scope, receive, send):\n-    delay_ms_str: str = scope[\"path\"].replace(\"/slow_response/\", \"\")\n-    try:\n-        delay_ms = float(delay_ms_str)\n-    except ValueError:\n-        delay_ms = 100\n-    await sleep(delay_ms / 1000.0)\n+    await sleep(1.0)",
      "comment": "This feels a bit too long, each test that uses `slow_response` will take a full second to complete.\r\n\r\nMaybe we could keep the above logic and set only the offending test to use a 1 second delay?",
      "comment_id": 423766556,
      "user": "yeraydiazdiaz",
      "created_at": "2020-05-12T14:12:38Z",
      "url": "https://github.com/encode/httpx/pull/946#discussion_r423766556"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 946,
      "file_path": "tests/conftest.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,12 +102,7 @@ async def hello_world(scope, receive, send):\n \n \n async def slow_response(scope, receive, send):\n-    delay_ms_str: str = scope[\"path\"].replace(\"/slow_response/\", \"\")\n-    try:\n-        delay_ms = float(delay_ms_str)\n-    except ValueError:\n-        delay_ms = 100\n-    await sleep(delay_ms / 1000.0)\n+    await sleep(1.0)",
      "comment": "So there's two timeout tests that use this, and I don't think they *do* take a full second to complete, because the client raises a timeout exception in each case.\r\n\r\nThe delay needs to not be ridiculously excessive, or I think the tests will hang at the end of the suite, when the server is shutting down.\r\n",
      "comment_id": 423778411,
      "user": "lovelydinosaur",
      "created_at": "2020-05-12T14:27:05Z",
      "url": "https://github.com/encode/httpx/pull/946#discussion_r423778411"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_concurrency.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import typing",
      "comment": "Let me know if this module and/or type checking stuff is over-the-top \ud83d\ude43. The type checking does allow us to assert that `asyncio.Event` and `trio.Event` expose similar-enough interfaces.",
      "comment_id": 418643366,
      "user": "JayH5",
      "created_at": "2020-05-01T17:22:27Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r418643366"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_concurrency.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import typing",
      "comment": "I\u2019d probably not bother with the Protocol level stuff here yeah.",
      "comment_id": 419086748,
      "user": "lovelydinosaur",
      "created_at": "2020-05-03T11:04:14Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r419086748"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_concurrency.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import typing",
      "comment": "OK I've reduced the type-checking stuff and got rid of this new `_concurrency` module :+1:\r\n",
      "comment_id": 419094829,
      "user": "JayH5",
      "created_at": "2020-05-03T12:12:42Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r419094829"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_dispatch/asgi.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,28 @@\n+import typing\n from typing import Callable, Dict, List, Optional, Tuple\n \n import httpcore\n+import sniffio\n \n from .._content_streams import ByteStream\n \n+if typing.TYPE_CHECKING:  # pragma: no cover\n+    import asyncio\n+    import trio",
      "comment": "Okay, so `trio` might not be installed.\r\n\r\nPerhaps we should be doing something like this?...\r\n\r\n```python\r\ntry:\r\n    import trio\r\n    Event = typing.Union[asyncio.Event, trio.Event]\r\nexcept ImportError:\r\n    Event = asyncio.Event\r\n```\r\n\r\nAlso it's not obvious to me that we need to bother with the `if typing.TYPE_CHECKING:` dance? We *usually* only use that if it's required to avoid otherwise circular imports.",
      "comment_id": 419412496,
      "user": "lovelydinosaur",
      "created_at": "2020-05-04T12:52:48Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r419412496"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_dispatch/asgi.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,28 @@\n+import typing\n from typing import Callable, Dict, List, Optional, Tuple\n \n import httpcore\n+import sniffio\n \n from .._content_streams import ByteStream\n \n+if typing.TYPE_CHECKING:  # pragma: no cover\n+    import asyncio\n+    import trio",
      "comment": "I tried what you're suggesting but unfortunately run into an error like:\r\n```\r\nerror: Cannot assign multiple types to name \"Event\" without an explicit \"Type[...]\" annotation\r\n```\r\n\r\nSeems like type aliases need to be statically resolvable: https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases",
      "comment_id": 419425612,
      "user": "JayH5",
      "created_at": "2020-05-04T13:14:26Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r419425612"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_dispatch/asgi.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,28 @@\n+import typing\n from typing import Callable, Dict, List, Optional, Tuple\n \n import httpcore\n+import sniffio\n \n from .._content_streams import ByteStream\n \n+if typing.TYPE_CHECKING:  # pragma: no cover\n+    import asyncio\n+    import trio",
      "comment": "Okay. We can't rely on the `trio` package necessarily being installed tho.\r\n(Even if we're limiting this to `if typing.TYPE_CHECKING:`)\r\n\r\nOne other option might be to just under-specify the type in this case, as a lazy `typing.Any`. We're not exposing the type info or using that function outside of this scope, so perhaps that's a sensibly practical option?",
      "comment_id": 419445703,
      "user": "lovelydinosaur",
      "created_at": "2020-05-04T13:43:09Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r419445703"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_dispatch/asgi.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,28 @@\n+import typing\n from typing import Callable, Dict, List, Optional, Tuple\n \n import httpcore\n+import sniffio\n \n from .._content_streams import ByteStream\n \n+if typing.TYPE_CHECKING:  # pragma: no cover\n+    import asyncio\n+    import trio",
      "comment": "The `if typing.TYPE_CHECKING` does actually help here. If `trio` (actually, `trio-typing`) is not installed, mypy is still happy because we use `--ignore-missing-imports` so it just ignores `import trio` and `trio.Event()`.",
      "comment_id": 419488860,
      "user": "JayH5",
      "created_at": "2020-05-04T14:42:01Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r419488860"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_dispatch/asgi.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,28 @@\n+import typing\n from typing import Callable, Dict, List, Optional, Tuple\n \n import httpcore\n+import sniffio\n \n from .._content_streams import ByteStream\n \n+if typing.TYPE_CHECKING:  # pragma: no cover\n+    import asyncio\n+    import trio",
      "comment": "@tomchristie still want me to make that a `typing.Any`?",
      "comment_id": 420762136,
      "user": "JayH5",
      "created_at": "2020-05-06T12:47:29Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r420762136"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_dispatch/asgi.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,23 +95,27 @@ async def request(\n         status_code = None\n         response_headers = None\n         body_parts = []\n+        request_complete = False\n         response_started = False\n-        response_complete = False\n+        response_complete = create_event()\n \n         headers = [] if headers is None else headers\n         stream = ByteStream(b\"\") if stream is None else stream\n \n         request_body_chunks = stream.__aiter__()\n \n         async def receive() -> dict:\n-            nonlocal response_complete\n+            nonlocal request_complete, response_complete\n \n-            if response_complete:\n+            if request_complete:\n+                # Simulate blocking until the response is complete and then disconnect",
      "comment": "I'd tweak this comment. We're not \"simulating\" blocking until the response is complete, we *are* blocking until the response is complete. :)",
      "comment_id": 420820086,
      "user": "lovelydinosaur",
      "created_at": "2020-05-06T14:07:39Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r420820086"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 919,
      "file_path": "httpx/_dispatch/asgi.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,23 +95,27 @@ async def request(\n         status_code = None\n         response_headers = None\n         body_parts = []\n+        request_complete = False\n         response_started = False\n-        response_complete = False\n+        response_complete = create_event()\n \n         headers = [] if headers is None else headers\n         stream = ByteStream(b\"\") if stream is None else stream\n \n         request_body_chunks = stream.__aiter__()\n \n         async def receive() -> dict:\n-            nonlocal response_complete\n+            nonlocal request_complete, response_complete\n \n-            if response_complete:\n+            if request_complete:\n+                # Simulate blocking until the response is complete and then disconnect",
      "comment": "Took out \"streaming\" and then found the comment a bit redundant \ud83e\udd14 ",
      "comment_id": 421017956,
      "user": "JayH5",
      "created_at": "2020-05-06T18:53:03Z",
      "url": "https://github.com/encode/httpx/pull/919#discussion_r421017956"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 923,
      "file_path": "httpx/_models.py",
      "line": 841,
      "side": "RIGHT",
      "diff_hunk": "@@ -838,7 +838,7 @@ def raise_for_status(self) -> None:\n             message = message.format(self, error_type=\"Server Error\")\n             raise HTTPError(message, response=self)\n \n-    def json(self, **kwargs: typing.Any) -> typing.Union[dict, list]:\n+    def json(self, **kwargs: typing.Any) -> typing.Any:",
      "comment": "I'm surprised by:\r\n\r\n> note that marking as : dict is not enough\r\n\r\nDo you get the same error?",
      "comment_id": 418949360,
      "user": "yeraydiazdiaz",
      "created_at": "2020-05-02T11:52:26Z",
      "url": "https://github.com/encode/httpx/pull/923#discussion_r418949360"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 923,
      "file_path": "httpx/_models.py",
      "line": 841,
      "side": "RIGHT",
      "diff_hunk": "@@ -838,7 +838,7 @@ def raise_for_status(self) -> None:\n             message = message.format(self, error_type=\"Server Error\")\n             raise HTTPError(message, response=self)\n \n-    def json(self, **kwargs: typing.Any) -> typing.Union[dict, list]:\n+    def json(self, **kwargs: typing.Any) -> typing.Any:",
      "comment": "I get a different (and even more confusing) error:\r\n\r\n```python\r\ndata: dict = httpx.get(\"http://example.com\").json()\r\n```\r\n\r\n```console\r\nerror: Incompatible types in assignment (expression has type \"Union[Dict[Any, Any], List[Any]]\", variable has type \"Dict[Any, Any]\")\r\n```\r\n\r\nI assume it's because mypy doesn't allow just down-sizing a union like that - you'd need to make a proper `assert`, or `cast()`.",
      "comment_id": 418951855,
      "user": "florimondmanca",
      "created_at": "2020-05-02T12:17:33Z",
      "url": "https://github.com/encode/httpx/pull/923#discussion_r418951855"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 923,
      "file_path": "httpx/_models.py",
      "line": 841,
      "side": "RIGHT",
      "diff_hunk": "@@ -838,7 +838,7 @@ def raise_for_status(self) -> None:\n             message = message.format(self, error_type=\"Server Error\")\n             raise HTTPError(message, response=self)\n \n-    def json(self, **kwargs: typing.Any) -> typing.Union[dict, list]:\n+    def json(self, **kwargs: typing.Any) -> typing.Any:",
      "comment": "Ugh, yeah, sounds like `Any` is the way to go here \ud83d\udc4d ",
      "comment_id": 418952709,
      "user": "yeraydiazdiaz",
      "created_at": "2020-05-02T12:26:09Z",
      "url": "https://github.com/encode/httpx/pull/923#discussion_r418952709"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,19 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:",
      "comment": "Would this be a more appropriate name for what this does, i.e. skip any empty chunks in the `body`?\r\n\r\n```suggestion\r\ndef _seek_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\r\n```",
      "comment_id": 399709293,
      "user": "florimondmanca",
      "created_at": "2020-03-28T21:03:34Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399709293"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,19 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"\n+    Get a non-empty chunk from body. This is needed because the status returned\n+    by start_response shouldn't be used until the first non-empty chunk has been\n+    served.",
      "comment": "Nit: can we move this comment to when we actually call this function? (What this function does is quite clear, but it might be better to keep the motivation close to the actual usage.)",
      "comment_id": 399710460,
      "user": "florimondmanca",
      "created_at": "2020-03-28T21:15:51Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399710460"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "tests/client/test_client.py",
      "line": 206,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,3 +153,54 @@ def test_elapsed_delay(server):\n     with httpx.Client() as client:\n         response = client.get(url)\n     assert response.elapsed.total_seconds() > 0.0\n+\n+\n+_wsgi_body = b\"\"\"\n+\n+\n+<!DOCTYPE html>\n+<html>\n+  <head>\n+    <title>This is not a web page</title>\n+  </head>\n+  <body>\n+    <p>This page deliberately left blank</p>\n+  </body>\n+</html>\n+\"\"\"\n+\n+\n+def test_wsgi_app():\n+    def application(env, start_response):\n+        start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+        return [_wsgi_body]\n+\n+    with httpx.Client(app=application) as client:\n+        response = client.get(\"http://example.com/\")\n+        assert response.status_code == 200\n+        assert b\"This page deliberately left blank\" in response.content\n+\n+\n+def test_wsgi_app_generator():\n+    def application(env, start_response):\n+        start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+        for line in _wsgi_body.split(b\"\\n\"):\n+            yield line\n+\n+    with httpx.Client(app=application) as client:\n+        response = client.get(\"http://example.com/\")\n+        assert response.status_code == 200\n+        assert b\"This page deliberately left blank\" in response.content\n+\n+\n+def test_wsgi_app_generator_empty():\n+    def application(env, start_response):\n+        body = [b\"\", b\"\", b\"\"]\n+        start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+        for line in body:\n+            yield line\n+\n+    with httpx.Client(app=application) as client:\n+        response = client.get(\"http://example.com/\")\n+        assert response.status_code == 200\n+        assert response.content == b\"\"",
      "comment": "FYI, we already have a `tests/test_wsgi.py` file. :-)\r\n\r\nIt doesn't seem like we need more tests there \u2014 we'd just need to refactor `echo_body_with_response_stream` to be an actual generator (instead of calling `start_response` synchronously and *then* returning a generator), which would match eg the `test_wsgi_app_generator` case here:\r\n\r\nhttps://github.com/encode/httpx/blob/fc980e779276e46ce2e2aad10a8ced1d50334306/tests/test_wsgi.py#L36-L50",
      "comment_id": 399710687,
      "user": "florimondmanca",
      "created_at": "2020-03-28T21:18:19Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399710687"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,19 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"\n+    Get a non-empty chunk from body. This is needed because the status returned\n+    by start_response shouldn't be used until the first non-empty chunk has been\n+    served.",
      "comment": "Sure.  The style where I work is to avoid comments, so it's just a habit.",
      "comment_id": 399712141,
      "user": "Singletoned",
      "created_at": "2020-03-28T21:33:17Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399712141"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "tests/client/test_client.py",
      "line": 206,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,3 +153,54 @@ def test_elapsed_delay(server):\n     with httpx.Client() as client:\n         response = client.get(url)\n     assert response.elapsed.total_seconds() > 0.0\n+\n+\n+_wsgi_body = b\"\"\"\n+\n+\n+<!DOCTYPE html>\n+<html>\n+  <head>\n+    <title>This is not a web page</title>\n+  </head>\n+  <body>\n+    <p>This page deliberately left blank</p>\n+  </body>\n+</html>\n+\"\"\"\n+\n+\n+def test_wsgi_app():\n+    def application(env, start_response):\n+        start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+        return [_wsgi_body]\n+\n+    with httpx.Client(app=application) as client:\n+        response = client.get(\"http://example.com/\")\n+        assert response.status_code == 200\n+        assert b\"This page deliberately left blank\" in response.content\n+\n+\n+def test_wsgi_app_generator():\n+    def application(env, start_response):\n+        start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+        for line in _wsgi_body.split(b\"\\n\"):\n+            yield line\n+\n+    with httpx.Client(app=application) as client:\n+        response = client.get(\"http://example.com/\")\n+        assert response.status_code == 200\n+        assert b\"This page deliberately left blank\" in response.content\n+\n+\n+def test_wsgi_app_generator_empty():\n+    def application(env, start_response):\n+        body = [b\"\", b\"\", b\"\"]\n+        start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+        for line in body:\n+            yield line\n+\n+    with httpx.Client(app=application) as client:\n+        response = client.get(\"http://example.com/\")\n+        assert response.status_code == 200\n+        assert response.content == b\"\"",
      "comment": "I'll move them.  Though I'm a little surprised the tests aren't in `tests/client/`.  I assumed the test structure would roughly match the code structure.",
      "comment_id": 399712677,
      "user": "Singletoned",
      "created_at": "2020-03-28T21:38:57Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399712677"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "tests/client/test_client.py",
      "line": 206,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,3 +153,54 @@ def test_elapsed_delay(server):\n     with httpx.Client() as client:\n         response = client.get(url)\n     assert response.elapsed.total_seconds() > 0.0\n+\n+\n+_wsgi_body = b\"\"\"\n+\n+\n+<!DOCTYPE html>\n+<html>\n+  <head>\n+    <title>This is not a web page</title>\n+  </head>\n+  <body>\n+    <p>This page deliberately left blank</p>\n+  </body>\n+</html>\n+\"\"\"\n+\n+\n+def test_wsgi_app():\n+    def application(env, start_response):\n+        start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+        return [_wsgi_body]\n+\n+    with httpx.Client(app=application) as client:\n+        response = client.get(\"http://example.com/\")\n+        assert response.status_code == 200\n+        assert b\"This page deliberately left blank\" in response.content\n+\n+\n+def test_wsgi_app_generator():\n+    def application(env, start_response):\n+        start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+        for line in _wsgi_body.split(b\"\\n\"):\n+            yield line\n+\n+    with httpx.Client(app=application) as client:\n+        response = client.get(\"http://example.com/\")\n+        assert response.status_code == 200\n+        assert b\"This page deliberately left blank\" in response.content\n+\n+\n+def test_wsgi_app_generator_empty():\n+    def application(env, start_response):\n+        body = [b\"\", b\"\", b\"\"]\n+        start_response(\"200 OK\", [(\"Content-Type\", \"text/html\")])\n+        for line in body:\n+            yield line\n+\n+    with httpx.Client(app=application) as client:\n+        response = client.get(\"http://example.com/\")\n+        assert response.status_code == 200\n+        assert response.content == b\"\"",
      "comment": "Yeah it's a bit surprising. Personally I'd see them in `tests/dispatch/` since `asgi.py` and `wsgi.py` are in the `_dispatch` sub-package. :-) Happy to review any follow-up PR for this!",
      "comment_id": 399712899,
      "user": "florimondmanca",
      "created_at": "2020-03-28T21:41:11Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399712899"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,15 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"Get a non-empty chunk from body.\"\"\"\n+    body = iter(body)\n+    for chunk in body:\n+        if chunk:\n+            return itertools.chain([chunk], body)\n+    return []",
      "comment": "From the PEP:\r\n\r\n> In other words, response headers must not be sent until there is actual body data available, or until the application's returned iterable is exhausted. *(The only possible exception to this rule is if the response headers explicitly include a Content-Length of zero.)*\r\n\r\nIs it worth explictly checking for the Content-Length to be zero irrespective of the body also being empty?\r\n\r\nI'm not sure if that's something that can ever happen though, not super familiar with WSGI myself.",
      "comment_id": 399773077,
      "user": "yeraydiazdiaz",
      "created_at": "2020-03-29T09:50:49Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399773077"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,15 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"Get a non-empty chunk from body.\"\"\"\n+    body = iter(body)\n+    for chunk in body:\n+        if chunk:\n+            return itertools.chain([chunk], body)\n+    return []",
      "comment": "My reading of this is that if a Content-Length of zero is set, then you CAN skip checking for body data, not that you SHOULD skip checking for body data (eg for performance reasons).  It's not something I've ever bothered to put in a WSGI adapter before, though my use cases are always quite lightweight (I mainly use it for testing web apps, which is what I'm doing with httpx).\r\n\r\nIt would mitigate against a situation where the app returned an infinite empty iterator, as long as it had a Content-Length of zero.  You would still have to take the first value of the iterator though, eg when a generator is being used.\r\n\r\nHappy to add it, as it's a tiny amount of code.  It's really your decision over how you want the library to behave.",
      "comment_id": 399775172,
      "user": "Singletoned",
      "created_at": "2020-03-29T10:10:05Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399775172"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,15 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"Get a non-empty chunk from body.\"\"\"\n+    body = iter(body)\n+    for chunk in body:\n+        if chunk:\n+            return itertools.chain([chunk], body)\n+    return []",
      "comment": "I guess it might be worth it while we're at it but I'd like to hear @tomchristie and @florimondmanca's opinion.\r\n\r\nThanks again @Singletoned ",
      "comment_id": 399776502,
      "user": "yeraydiazdiaz",
      "created_at": "2020-03-29T10:22:43Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399776502"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,15 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"Get a non-empty chunk from body.\"\"\"\n+    body = iter(body)\n+    for chunk in body:\n+        if chunk:\n+            return itertools.chain([chunk], body)\n+    return []",
      "comment": "Feels like a super narrow edge case to me\u2026 I read the paragraph in the PEP as \"in case of `Content-Length: 0` then you *don't have to* check for body data\" too, i.e. it doesn't mean you *can't* skip it.\r\n\r\nSo maybe we can leave things as they are for now, in the name of keeping things simple while covering 99.99% of use cases?",
      "comment_id": 399777583,
      "user": "florimondmanca",
      "created_at": "2020-03-29T10:32:36Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399777583"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,15 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"Get a non-empty chunk from body.\"\"\"",
      "comment": "I notice you reverted the name, but I still think the current \"get chunk\" naming is not conveying correctly what this function does\u2026 A \"get chunk\" function should return a `chunk`, but this returns a modified `body` iterable that skips any leading empty chunks.\r\n\r\nSo, maybe\u2026?\r\n\r\n```suggestion\r\ndef _skip_leading_empty_chunks(body: typing.Iterable) -> typing.Iterable:\r\n```",
      "comment_id": 399778004,
      "user": "florimondmanca",
      "created_at": "2020-03-29T10:36:36Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399778004"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,15 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"Get a non-empty chunk from body.\"\"\"\n+    body = iter(body)\n+    for chunk in body:\n+        if chunk:\n+            return itertools.chain([chunk], body)\n+    return []",
      "comment": "I guess a broader question here is, in general, do you want httpx to be:\r\n\r\n  a) as strict as possible (tightly conforming to specs)\r\n  b) as permissive as possible (eg handle broken responses, etc)\r\n  c) as simple as possible (least code complexity)\r\n\r\nGiven that it will be used to fetch things on the web, I would guess \"b\" is the answer, but any of them are valid.  If you do have a clear answer, I'd suggest putting it in the \"contributing\" docs.\r\n\r\nUnder either \"a\" or \"b\" I'd suggest that this should be added.  It conforms to the spec, and it also allows broken cases to succeed.  Under \"c\" then it's not really needed.\r\n\r\nEDIT: I guess a sensible balance between two of them is also a good answer.  I always forget about sensible balances. (I hadn't seen @florimondmanca 's reply before I wrote this).",
      "comment_id": 399778166,
      "user": "Singletoned",
      "created_at": "2020-03-29T10:38:01Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399778166"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "tests/test_wsgi.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,3 +93,21 @@ def test_wsgi_exc():\n     client = httpx.Client(app=raise_exc)\n     with pytest.raises(ValueError):\n         client.get(\"http://www.example.org/\")\n+\n+\n+def test_wsgi_generator():\n+    output = [b\"\", b\"\", b\"Some content\", b\" and more content\"]\n+    client = httpx.Client(app=application_factory(output))\n+    response = client.get(\"http://www.example.org/\")\n+    assert response.status_code == 200\n+    assert response.text == \"Some content and more content\"\n+    assert response.content == b\"Some content and more content\"",
      "comment": "Do we actually *need* to assert both the `text` and `content`? We're not testing body decoding, so I feel like asserting the `text` (like in other tests here) should be enough, WDYT?\r\n\r\n```suggestion\r\n```",
      "comment_id": 399778282,
      "user": "florimondmanca",
      "created_at": "2020-03-29T10:38:56Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399778282"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,15 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"Get a non-empty chunk from body.\"\"\"\n+    body = iter(body)\n+    for chunk in body:\n+        if chunk:\n+            return itertools.chain([chunk], body)\n+    return []",
      "comment": "I think for areas like these where neither urllib3 nor Requests support the feature, we generally adopt a pragmatic variant of c).\r\n\r\nIf there's something obviously broken we should fix it. But so far we haven't seen any user issues about \"my WSGI server returns an infinite stream of empty chunks and HTTPX can't process it\", which is why I'd be advocating for \"let's fix this only if/when we have actual proof users are encountering it in the wild\". :-)",
      "comment_id": 399779008,
      "user": "florimondmanca",
      "created_at": "2020-03-29T10:44:20Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399779008"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,15 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"Get a non-empty chunk from body.\"\"\"",
      "comment": "That was a regression on my part.  Happy to accept any name whatsoever.",
      "comment_id": 399779300,
      "user": "Singletoned",
      "created_at": "2020-03-29T10:47:02Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399779300"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,15 @@\n from .base import SyncDispatcher\n \n \n+def _get_non_empty_chunk(body: typing.Iterable) -> typing.Iterable:\n+    \"\"\"Get a non-empty chunk from body.\"\"\"",
      "comment": "Sure, sorry if my wording sounded offensive if any way :) I meant to write \"I notice the name was reverted\".",
      "comment_id": 399779530,
      "user": "florimondmanca",
      "created_at": "2020-03-29T10:48:59Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399779530"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 887,
      "file_path": "httpx/_dispatch/wsgi.py",
      "line": 102,
      "side": "RIGHT",
      "diff_hunk": "@@ -88,6 +97,9 @@ def start_response(\n             seen_exc_info = exc_info\n \n         result = self.app(environ, start_response)\n+        # This is needed because the status returned by start_response\n+        # shouldn't be used until the first non-empty chunk has been served.\n+        result = _get_non_empty_chunk(result)",
      "comment": "Woops \ud83d\ude04  (Forgot to add this suggestion to my previous review!)\r\n\r\n```suggestion\r\n        result = _skip_leading_empty_chunks(result)\r\n```",
      "comment_id": 399779698,
      "user": "florimondmanca",
      "created_at": "2020-03-29T10:50:26Z",
      "url": "https://github.com/encode/httpx/pull/887#discussion_r399779698"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "httpx/_utils.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,6 +310,37 @@ def unquote(value: str) -> str:\n     return value[1:-1] if value[0] == value[-1] == '\"' else value\n \n \n+def guess_content_type(filename: typing.Optional[str]) -> typing.Optional[str]:\n+    if filename:\n+        return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n+    return None\n+\n+\n+def get_filelike_length(stream: typing.IO) -> int:\n+    \"\"\"\n+    Given a file-like stream object, efficiently compute and return its length\n+    in number of bytes.\n+    \"\"\"\n+    try:\n+        # Is it an actual file?\n+        fd = stream.fileno()\n+    except OSError:\n+        # No... is it something that supports random access, like `io.BytesIO`?\n+        if not hasattr(stream, \"seekable\") or not stream.seekable():  # pragma: nocover\n+            # Not even that? Sorry, we're doomed...\n+            raise",
      "comment": "We might need to think about how we handle this case a bit more I guess. I don't recall off the top of my head if individual multipart file fields *have* to include a content-length, or if they support framing the data when the content length is unkown up front?",
      "comment_id": 390192686,
      "user": "lovelydinosaur",
      "created_at": "2020-03-10T09:40:29Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r390192686"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "httpx/_utils.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,6 +310,37 @@ def unquote(value: str) -> str:\n     return value[1:-1] if value[0] == value[-1] == '\"' else value\n \n \n+def guess_content_type(filename: typing.Optional[str]) -> typing.Optional[str]:\n+    if filename:\n+        return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n+    return None\n+\n+\n+def get_filelike_length(stream: typing.IO) -> int:\n+    \"\"\"\n+    Given a file-like stream object, efficiently compute and return its length\n+    in number of bytes.\n+    \"\"\"\n+    try:\n+        # Is it an actual file?\n+        fd = stream.fileno()\n+    except OSError:\n+        # No... is it something that supports random access, like `io.BytesIO`?\n+        if not hasattr(stream, \"seekable\") or not stream.seekable():  # pragma: nocover\n+            # Not even that? Sorry, we're doomed...\n+            raise",
      "comment": "Right, so yeah the content is delimited by the `boundary` markers, so files *without* a content-length header are perfectly okay. Eg in the MDN example here https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\r\n\r\n```\r\nPOST /test.html HTTP/1.1\r\nHost: example.org\r\nContent-Type: multipart/form-data;boundary=\"boundary\"\r\n\r\n--boundary\r\nContent-Disposition: form-data; name=\"field1\"\r\n\r\nvalue1\r\n--boundary\r\nContent-Disposition: form-data; name=\"field2\"; filename=\"example.txt\"\r\n\r\nvalue2\r\n--boundary--\r\n```\r\n\r\nI *guess* we ought to include the Content-Length where possible, but it's feasible that our policy could alternately be \"let's *not* include the Content-Length\". Perhaps it'd be good to take a steer on that from some prior art. Eg. what does the streaming multipart implementation in the requests toolbelt do?... https://toolbelt.readthedocs.io/en/latest/uploading-data.html#streaming-multipart-data-encoder",
      "comment_id": 390201831,
      "user": "lovelydinosaur",
      "created_at": "2020-03-10T09:55:55Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r390201831"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "httpx/_utils.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,6 +310,37 @@ def unquote(value: str) -> str:\n     return value[1:-1] if value[0] == value[-1] == '\"' else value\n \n \n+def guess_content_type(filename: typing.Optional[str]) -> typing.Optional[str]:\n+    if filename:\n+        return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n+    return None\n+\n+\n+def get_filelike_length(stream: typing.IO) -> int:\n+    \"\"\"\n+    Given a file-like stream object, efficiently compute and return its length\n+    in number of bytes.\n+    \"\"\"\n+    try:\n+        # Is it an actual file?\n+        fd = stream.fileno()\n+    except OSError:\n+        # No... is it something that supports random access, like `io.BytesIO`?\n+        if not hasattr(stream, \"seekable\") or not stream.seekable():  # pragma: nocover\n+            # Not even that? Sorry, we're doomed...\n+            raise",
      "comment": "For the purposes of *this* function, I guess we'll want to return an `Optional[int]`, and return `None` when we cannot determine the content length.",
      "comment_id": 390202362,
      "user": "lovelydinosaur",
      "created_at": "2020-03-10T09:56:43Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r390202362"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "httpx/_content_streams.py",
      "line": 214,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,17 +206,34 @@ def __init__(self, name: str, value: typing.Union[str, bytes]) -> None:\n             self.name = name\n             self.value = value\n \n+        @functools.lru_cache(1)\n         def render_headers(self) -> bytes:\n             name = format_form_param(\"name\", self.name)\n             return b\"\".join([b\"Content-Disposition: form-data; \", name, b\"\\r\\n\\r\\n\"])\n \n+        @functools.lru_cache(1)",
      "comment": "These functions are simple enough that I'd expect a `@functools.lru_cache(1)` is likely to introduce more overhead than it'll save. We *might* consider either:\r\n\r\n* Dropping the `@functools.lru_cache(1)` on trivial method implementations.\r\n* Dropping the `@functools.lru_cache` cases everywhere for this PR, focusing strictly on correctness, and *potentially* adding them in as an incremental improvement sperately. (It's feasible that there's stateful approaches that we might consider instead of `lru_cache` wrapping.)\r\n\r\nAny thoughts?",
      "comment_id": 390204481,
      "user": "lovelydinosaur",
      "created_at": "2020-03-10T10:00:30Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r390204481"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "httpx/_utils.py",
      "line": 319,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,6 +310,37 @@ def unquote(value: str) -> str:\n     return value[1:-1] if value[0] == value[-1] == '\"' else value\n \n \n+def guess_content_type(filename: typing.Optional[str]) -> typing.Optional[str]:\n+    if filename:\n+        return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n+    return None\n+\n+\n+def get_filelike_length(stream: typing.IO) -> int:",
      "comment": "Thanks! Basically a patchwork of info from here and there :-) eg the [io](https://docs.python.org/3/library/io.html) module docs, and SO for `os.fstat` and \"how to get length of BytesIO/StringIO\".",
      "comment_id": 391436958,
      "user": "florimondmanca",
      "created_at": "2020-03-12T07:17:59Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r391436958"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "httpx/_utils.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,6 +310,37 @@ def unquote(value: str) -> str:\n     return value[1:-1] if value[0] == value[-1] == '\"' else value\n \n \n+def guess_content_type(filename: typing.Optional[str]) -> typing.Optional[str]:\n+    if filename:\n+        return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n+    return None\n+\n+\n+def get_filelike_length(stream: typing.IO) -> int:\n+    \"\"\"\n+    Given a file-like stream object, efficiently compute and return its length\n+    in number of bytes.\n+    \"\"\"\n+    try:\n+        # Is it an actual file?\n+        fd = stream.fileno()\n+    except OSError:\n+        # No... is it something that supports random access, like `io.BytesIO`?\n+        if not hasattr(stream, \"seekable\") or not stream.seekable():  # pragma: nocover\n+            # Not even that? Sorry, we're doomed...\n+            raise",
      "comment": "Ah interesting about `Content-Disposition`\u2026 I actually took heavy inspiration from this blog post: [Streaming Multipart Requests](http://khanlou.com/2018/11/streaming-multipart-requests/), and it also actually doesn't use the `Content-Disposition: form-data; ...` format too.\r\n\r\nSo it's not even clear whether we should _always_ follow that format, or if there are cases when we should _always_ try to pass `Content-Length`\u2026\r\n\r\n~I'll try that out and do some validation against some live servers too. :-)~\r\n\r\nEdit: will first look at what some requests-toolbet/other HTTP clients do in this space.",
      "comment_id": 391439662,
      "user": "florimondmanca",
      "created_at": "2020-03-12T07:26:13Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r391439662"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "httpx/_content_streams.py",
      "line": 214,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,17 +206,34 @@ def __init__(self, name: str, value: typing.Union[str, bytes]) -> None:\n             self.name = name\n             self.value = value\n \n+        @functools.lru_cache(1)\n         def render_headers(self) -> bytes:\n             name = format_form_param(\"name\", self.name)\n             return b\"\".join([b\"Content-Disposition: form-data; \", name, b\"\\r\\n\\r\\n\"])\n \n+        @functools.lru_cache(1)",
      "comment": "I actually initially used private unset attributes + `if not hasattr(self, \"_headers\")`, but decided the `lru_cache` way was a bit cleaner while functionally identical.\r\n\r\nI guess we can revert to that correct-first approach though, sure.",
      "comment_id": 391441049,
      "user": "florimondmanca",
      "created_at": "2020-03-12T07:30:19Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r391441049"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "httpx/_utils.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,6 +310,37 @@ def unquote(value: str) -> str:\n     return value[1:-1] if value[0] == value[-1] == '\"' else value\n \n \n+def guess_content_type(filename: typing.Optional[str]) -> typing.Optional[str]:\n+    if filename:\n+        return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n+    return None\n+\n+\n+def get_filelike_length(stream: typing.IO) -> int:\n+    \"\"\"\n+    Given a file-like stream object, efficiently compute and return its length\n+    in number of bytes.\n+    \"\"\"\n+    try:\n+        # Is it an actual file?\n+        fd = stream.fileno()\n+    except OSError:\n+        # No... is it something that supports random access, like `io.BytesIO`?\n+        if not hasattr(stream, \"seekable\") or not stream.seekable():  # pragma: nocover\n+            # Not even that? Sorry, we're doomed...\n+            raise",
      "comment": "See https://github.com/encode/httpx/pull/857#issuecomment-598063395: looks like in practice `Content-Length` is very much needed.\r\n\r\nSo my intuition here would be to fail loudly in case we can't compute the `Content-Length`.\r\n\r\nWhat kind of exception would we like to throw? Surely bubbling up `OSError` isn't great UX. Would this be a new subclass of `StreamError`?",
      "comment_id": 391462969,
      "user": "florimondmanca",
      "created_at": "2020-03-12T08:26:37Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r391462969"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "httpx/_utils.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,6 +310,37 @@ def unquote(value: str) -> str:\n     return value[1:-1] if value[0] == value[-1] == '\"' else value\n \n \n+def guess_content_type(filename: typing.Optional[str]) -> typing.Optional[str]:\n+    if filename:\n+        return mimetypes.guess_type(filename)[0] or \"application/octet-stream\"\n+    return None\n+\n+\n+def get_filelike_length(stream: typing.IO) -> int:\n+    \"\"\"\n+    Given a file-like stream object, efficiently compute and return its length\n+    in number of bytes.\n+    \"\"\"\n+    try:\n+        # Is it an actual file?\n+        fd = stream.fileno()\n+    except OSError:\n+        # No... is it something that supports random access, like `io.BytesIO`?\n+        if not hasattr(stream, \"seekable\") or not stream.seekable():  # pragma: nocover\n+            # Not even that? Sorry, we're doomed...\n+            raise",
      "comment": "Now stale, as we now handle this special 0.01%-of-cases situation by reading the entire file in memory as a fallback.",
      "comment_id": 392576206,
      "user": "florimondmanca",
      "created_at": "2020-03-14T10:54:47Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r392576206"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "tests/test_multipart.py",
      "line": 279,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,38 +158,125 @@ def test_multipart_encode_files_allows_filenames_as_none():\n     ],\n )\n def test_multipart_encode_files_guesses_correct_content_type(\n-    file_name, expected_content_type\n-):\n+    file_name: str, expected_content_type: str\n+) -> None:\n     files = {\"file\": (file_name, io.BytesIO(b\"<file content>\"))}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        assert b\"\".join(stream) == (\n             f'--{boundary}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             f'filename=\"{file_name}\"\\r\\nContent-Type: '\n             f\"{expected_content_type}\\r\\n\\r\\n<file content>\\r\\n--{boundary}--\\r\\n\"\n             \"\".encode(\"ascii\")\n         )\n \n \n-def test_multipart_encode_files_allows_str_content():\n+def test_multipart_encode_files_allows_str_content() -> None:\n     files = {\"file\": (\"test.txt\", \"<string content>\", \"text/plain\")}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        content = (\n             '--{0}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             'filename=\"test.txt\"\\r\\n'\n             \"Content-Type: text/plain\\r\\n\\r\\n<string content>\\r\\n\"\n             \"--{0}--\\r\\n\"\n             \"\".format(boundary).encode(\"ascii\")\n         )\n+        assert stream.get_headers()[\"Content-Length\"] == str(len(content))\n+        assert b\"\".join(stream) == content\n+\n+\n+def test_multipart_encode_non_seekable_filelike() -> None:\n+    \"\"\"\n+    Test that special readable but non-seekable filelike objects are supported,\n+    at the cost of reading them into memory at most once.\n+    \"\"\"\n+\n+    class IteratorIO(io.IOBase):\n+        def __init__(self, iterator: Iterator[bytes]) -> None:\n+            self._iterator = iterator\n+\n+        def seekable(self) -> bool:\n+            return False\n+\n+        def read(self, *args: Any) -> bytes:\n+            return b\"\".join(self._iterator)\n+\n+    def data() -> Iterator[bytes]:\n+        yield b\"Hello\"\n+        yield b\"World\"\n+\n+    fileobj = IteratorIO(data())\n+    files = {\"file\": fileobj}\n+    stream = encode(files=files, boundary=b\"+++\")\n+    assert not stream.can_replay()\n+\n+    content = (\n+        b\"--+++\\r\\n\"\n+        b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n'\n+        b\"Content-Type: application/octet-stream\\r\\n\"\n+        b\"\\r\\n\"\n+        b\"HelloWorld\\r\\n\"\n+        b\"--+++--\\r\\n\"\n+    )\n+    assert stream.get_headers() == {\n+        \"Content-Type\": \"multipart/form-data; boundary=+++\",\n+        \"Content-Length\": str(len(content)),\n+    }\n+    assert b\"\".join(stream) == content\n+\n+\n+def test_multipart_file_streaming_memory(tmp_path: Any) -> None:\n+    \"\"\"\n+    Test that multipart file uploads are effectively streaming, i.e. they don't\n+    result in loading the entire file into memory.\n+    \"\"\"\n+    path = str(tmp_path / \"name.txt\")\n+\n+    # Flush a relatively large file to disk to read from.\n+    ONE_MB = 1024 * 1024\n+    size_mb = 1\n+    with open(path, \"wb\") as out:\n+        out.write(os.urandom(int(size_mb * ONE_MB)))\n+\n+    def bench() -> None:\n+        files = {\"file\": open(path, \"rb\")}\n+        stream = encode(files=files, boundary=b\"+++\")\n+        # Consume the stream one chunk at a time.\n+        for _ in stream:\n+            pass\n+\n+    # Measure memory usage of `main()` -- one entry per LOC (plus init/teardown).\n+    memory_per_line: List[float] = memory_profiler.memory_usage((bench, (), {}))\n+\n+    # Rationale: if streaming works correctly, all lines should use roughly the\n+    # same amount of memory. In particular, they should use the same amount of memory\n+    # than the first operation in `main()`.\n+    percents = 1\n+    baseline = memory_per_line[0]\n+    max_allowed_memory = (100 + percents) / 100 * baseline\n+\n+    # Make sure initial file was big enough to exceed memory limits\n+    # if it were to be consumed in full.\n+    assert (\n+        size_mb > max_allowed_memory - baseline\n+    ), \"Impact of loading entire file in memory wouldn't be detectable\"\n+\n+    # Now verify memory usage.\n+    assert all(memory < max_allowed_memory for memory in memory_per_line), (\n+        max_allowed_memory,\n+        memory_per_line,\n+    )",
      "comment": "Wow, I haven't seen memory consumption being part of a test before, great job! \ud83d\udcaf ",
      "comment_id": 392653129,
      "user": "yeraydiazdiaz",
      "created_at": "2020-03-15T08:41:05Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r392653129"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "tests/test_multipart.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,38 +158,125 @@ def test_multipart_encode_files_allows_filenames_as_none():\n     ],\n )\n def test_multipart_encode_files_guesses_correct_content_type(\n-    file_name, expected_content_type\n-):\n+    file_name: str, expected_content_type: str\n+) -> None:\n     files = {\"file\": (file_name, io.BytesIO(b\"<file content>\"))}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        assert b\"\".join(stream) == (\n             f'--{boundary}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             f'filename=\"{file_name}\"\\r\\nContent-Type: '\n             f\"{expected_content_type}\\r\\n\\r\\n<file content>\\r\\n--{boundary}--\\r\\n\"\n             \"\".encode(\"ascii\")\n         )\n \n \n-def test_multipart_encode_files_allows_str_content():\n+def test_multipart_encode_files_allows_str_content() -> None:\n     files = {\"file\": (\"test.txt\", \"<string content>\", \"text/plain\")}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        content = (\n             '--{0}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             'filename=\"test.txt\"\\r\\n'\n             \"Content-Type: text/plain\\r\\n\\r\\n<string content>\\r\\n\"\n             \"--{0}--\\r\\n\"\n             \"\".format(boundary).encode(\"ascii\")\n         )\n+        assert stream.get_headers()[\"Content-Length\"] == str(len(content))\n+        assert b\"\".join(stream) == content\n+\n+\n+def test_multipart_encode_non_seekable_filelike() -> None:\n+    \"\"\"\n+    Test that special readable but non-seekable filelike objects are supported,",
      "comment": "Sorry if I missed something in the conversation but could you give an example of such case?",
      "comment_id": 392653901,
      "user": "yeraydiazdiaz",
      "created_at": "2020-03-15T08:53:14Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r392653901"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "tests/test_multipart.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,38 +158,125 @@ def test_multipart_encode_files_allows_filenames_as_none():\n     ],\n )\n def test_multipart_encode_files_guesses_correct_content_type(\n-    file_name, expected_content_type\n-):\n+    file_name: str, expected_content_type: str\n+) -> None:\n     files = {\"file\": (file_name, io.BytesIO(b\"<file content>\"))}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        assert b\"\".join(stream) == (\n             f'--{boundary}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             f'filename=\"{file_name}\"\\r\\nContent-Type: '\n             f\"{expected_content_type}\\r\\n\\r\\n<file content>\\r\\n--{boundary}--\\r\\n\"\n             \"\".encode(\"ascii\")\n         )\n \n \n-def test_multipart_encode_files_allows_str_content():\n+def test_multipart_encode_files_allows_str_content() -> None:\n     files = {\"file\": (\"test.txt\", \"<string content>\", \"text/plain\")}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        content = (\n             '--{0}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             'filename=\"test.txt\"\\r\\n'\n             \"Content-Type: text/plain\\r\\n\\r\\n<string content>\\r\\n\"\n             \"--{0}--\\r\\n\"\n             \"\".format(boundary).encode(\"ascii\")\n         )\n+        assert stream.get_headers()[\"Content-Length\"] == str(len(content))\n+        assert b\"\".join(stream) == content\n+\n+\n+def test_multipart_encode_non_seekable_filelike() -> None:\n+    \"\"\"\n+    Test that special readable but non-seekable filelike objects are supported,",
      "comment": "This araised more as a theoretical aspect (a branch of the code that'd otherwise result in an exception being raised), but I've seen people being in this situation, eg on SO: [Stream a non-seekable file-like object to multiple sinks](https://stackoverflow.com/questions/39324151/stream-a-non-seekable-file-like-object-to-multiple-sinks) (unfortunately OP doesn't clarify what their non-seekable file-like object looks like). Basically this is a special edge case that theoretically we have to handle, so here we are. :-)",
      "comment_id": 392656584,
      "user": "florimondmanca",
      "created_at": "2020-03-15T09:34:43Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r392656584"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "tests/test_multipart.py",
      "line": 260,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,38 +158,125 @@ def test_multipart_encode_files_allows_filenames_as_none():\n     ],\n )\n def test_multipart_encode_files_guesses_correct_content_type(\n-    file_name, expected_content_type\n-):\n+    file_name: str, expected_content_type: str\n+) -> None:\n     files = {\"file\": (file_name, io.BytesIO(b\"<file content>\"))}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        assert b\"\".join(stream) == (\n             f'--{boundary}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             f'filename=\"{file_name}\"\\r\\nContent-Type: '\n             f\"{expected_content_type}\\r\\n\\r\\n<file content>\\r\\n--{boundary}--\\r\\n\"\n             \"\".encode(\"ascii\")\n         )\n \n \n-def test_multipart_encode_files_allows_str_content():\n+def test_multipart_encode_files_allows_str_content() -> None:\n     files = {\"file\": (\"test.txt\", \"<string content>\", \"text/plain\")}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        content = (\n             '--{0}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             'filename=\"test.txt\"\\r\\n'\n             \"Content-Type: text/plain\\r\\n\\r\\n<string content>\\r\\n\"\n             \"--{0}--\\r\\n\"\n             \"\".format(boundary).encode(\"ascii\")\n         )\n+        assert stream.get_headers()[\"Content-Length\"] == str(len(content))\n+        assert b\"\".join(stream) == content\n+\n+\n+def test_multipart_encode_non_seekable_filelike() -> None:\n+    \"\"\"\n+    Test that special readable but non-seekable filelike objects are supported,\n+    at the cost of reading them into memory at most once.\n+    \"\"\"\n+\n+    class IteratorIO(io.IOBase):\n+        def __init__(self, iterator: Iterator[bytes]) -> None:\n+            self._iterator = iterator\n+\n+        def seekable(self) -> bool:\n+            return False\n+\n+        def read(self, *args: Any) -> bytes:\n+            return b\"\".join(self._iterator)\n+\n+    def data() -> Iterator[bytes]:\n+        yield b\"Hello\"\n+        yield b\"World\"\n+\n+    fileobj = IteratorIO(data())\n+    files = {\"file\": fileobj}\n+    stream = encode(files=files, boundary=b\"+++\")\n+    assert not stream.can_replay()\n+\n+    content = (\n+        b\"--+++\\r\\n\"\n+        b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n'\n+        b\"Content-Type: application/octet-stream\\r\\n\"\n+        b\"\\r\\n\"\n+        b\"HelloWorld\\r\\n\"\n+        b\"--+++--\\r\\n\"\n+    )\n+    assert stream.get_headers() == {\n+        \"Content-Type\": \"multipart/form-data; boundary=+++\",\n+        \"Content-Length\": str(len(content)),\n+    }\n+    assert b\"\".join(stream) == content\n+\n+\n+def test_multipart_file_streaming_memory(tmp_path: Any) -> None:\n+    \"\"\"\n+    Test that multipart file uploads are effectively streaming, i.e. they don't\n+    result in loading the entire file into memory.\n+    \"\"\"\n+    path = str(tmp_path / \"name.txt\")\n+\n+    # Flush a relatively large file to disk to read from.\n+    ONE_MB = 1024 * 1024\n+    size_mb = 1\n+    with open(path, \"wb\") as out:\n+        out.write(os.urandom(int(size_mb * ONE_MB)))\n+\n+    def bench() -> None:\n+        files = {\"file\": open(path, \"rb\")}\n+        stream = encode(files=files, boundary=b\"+++\")\n+        # Consume the stream one chunk at a time.\n+        for _ in stream:\n+            pass\n+\n+    # Measure memory usage of `main()` -- one entry per LOC (plus init/teardown).\n+    memory_per_line: List[float] = memory_profiler.memory_usage((bench, (), {}))",
      "comment": "I'd suggest that we might not want to enforce memory profiling in the test case, as it might be a bit brittle, adds a requirement we could possibly do without.",
      "comment_id": 399803093,
      "user": "lovelydinosaur",
      "created_at": "2020-03-29T14:09:25Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r399803093"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 857,
      "file_path": "tests/test_multipart.py",
      "line": 260,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,38 +158,125 @@ def test_multipart_encode_files_allows_filenames_as_none():\n     ],\n )\n def test_multipart_encode_files_guesses_correct_content_type(\n-    file_name, expected_content_type\n-):\n+    file_name: str, expected_content_type: str\n+) -> None:\n     files = {\"file\": (file_name, io.BytesIO(b\"<file content>\"))}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        assert b\"\".join(stream) == (\n             f'--{boundary}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             f'filename=\"{file_name}\"\\r\\nContent-Type: '\n             f\"{expected_content_type}\\r\\n\\r\\n<file content>\\r\\n--{boundary}--\\r\\n\"\n             \"\".encode(\"ascii\")\n         )\n \n \n-def test_multipart_encode_files_allows_str_content():\n+def test_multipart_encode_files_allows_str_content() -> None:\n     files = {\"file\": (\"test.txt\", \"<string content>\", \"text/plain\")}\n     with mock.patch(\"os.urandom\", return_value=os.urandom(16)):\n         boundary = binascii.hexlify(os.urandom(16)).decode(\"ascii\")\n \n-        stream = encode(data={}, files=files)\n+        stream = cast(MultipartStream, encode(data={}, files=files))\n+        assert stream.can_replay()\n \n         assert stream.content_type == f\"multipart/form-data; boundary={boundary}\"\n-        assert stream.body == (\n+        content = (\n             '--{0}\\r\\nContent-Disposition: form-data; name=\"file\"; '\n             'filename=\"test.txt\"\\r\\n'\n             \"Content-Type: text/plain\\r\\n\\r\\n<string content>\\r\\n\"\n             \"--{0}--\\r\\n\"\n             \"\".format(boundary).encode(\"ascii\")\n         )\n+        assert stream.get_headers()[\"Content-Length\"] == str(len(content))\n+        assert b\"\".join(stream) == content\n+\n+\n+def test_multipart_encode_non_seekable_filelike() -> None:\n+    \"\"\"\n+    Test that special readable but non-seekable filelike objects are supported,\n+    at the cost of reading them into memory at most once.\n+    \"\"\"\n+\n+    class IteratorIO(io.IOBase):\n+        def __init__(self, iterator: Iterator[bytes]) -> None:\n+            self._iterator = iterator\n+\n+        def seekable(self) -> bool:\n+            return False\n+\n+        def read(self, *args: Any) -> bytes:\n+            return b\"\".join(self._iterator)\n+\n+    def data() -> Iterator[bytes]:\n+        yield b\"Hello\"\n+        yield b\"World\"\n+\n+    fileobj = IteratorIO(data())\n+    files = {\"file\": fileobj}\n+    stream = encode(files=files, boundary=b\"+++\")\n+    assert not stream.can_replay()\n+\n+    content = (\n+        b\"--+++\\r\\n\"\n+        b'Content-Disposition: form-data; name=\"file\"; filename=\"upload\"\\r\\n'\n+        b\"Content-Type: application/octet-stream\\r\\n\"\n+        b\"\\r\\n\"\n+        b\"HelloWorld\\r\\n\"\n+        b\"--+++--\\r\\n\"\n+    )\n+    assert stream.get_headers() == {\n+        \"Content-Type\": \"multipart/form-data; boundary=+++\",\n+        \"Content-Length\": str(len(content)),\n+    }\n+    assert b\"\".join(stream) == content\n+\n+\n+def test_multipart_file_streaming_memory(tmp_path: Any) -> None:\n+    \"\"\"\n+    Test that multipart file uploads are effectively streaming, i.e. they don't\n+    result in loading the entire file into memory.\n+    \"\"\"\n+    path = str(tmp_path / \"name.txt\")\n+\n+    # Flush a relatively large file to disk to read from.\n+    ONE_MB = 1024 * 1024\n+    size_mb = 1\n+    with open(path, \"wb\") as out:\n+        out.write(os.urandom(int(size_mb * ONE_MB)))\n+\n+    def bench() -> None:\n+        files = {\"file\": open(path, \"rb\")}\n+        stream = encode(files=files, boundary=b\"+++\")\n+        # Consume the stream one chunk at a time.\n+        for _ in stream:\n+            pass\n+\n+    # Measure memory usage of `main()` -- one entry per LOC (plus init/teardown).\n+    memory_per_line: List[float] = memory_profiler.memory_usage((bench, (), {}))",
      "comment": "Yeah looking back at this PR, this test is *fancy* for sure. I still think it's nice to have some kind of proof that streaming works as expected (reduced memory consumption is the main motivation factor in the first place), but not absolute on keeping this either, since once we use generators there's not much risk we buffer everything up.",
      "comment_id": 399807675,
      "user": "florimondmanca",
      "created_at": "2020-03-29T14:45:54Z",
      "url": "https://github.com/encode/httpx/pull/857#discussion_r399807675"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 882,
      "file_path": "httpx/_models.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,8 +68,8 @@\n \n HeaderTypes = typing.Union[\n     \"Headers\",\n-    typing.Dict[typing.AnyStr, typing.AnyStr],\n-    typing.List[typing.Tuple[typing.AnyStr, typing.AnyStr]],\n+    typing.Dict[StrOrBytes, StrOrBytes],\n+    typing.Sequence[typing.Tuple[StrOrBytes, StrOrBytes]],",
      "comment": "Note: this change from `List` to `Sequence` was required, or mypy would raise errors here about `List` being invariant (so not working well with unions of types):\r\n\r\nhttps://github.com/encode/httpx/blob/21f533774f87292c2381376eb40f3216a48eee06/httpx/_models.py#L492",
      "comment_id": 399642653,
      "user": "florimondmanca",
      "created_at": "2020-03-28T09:45:11Z",
      "url": "https://github.com/encode/httpx/pull/882#discussion_r399642653"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 718,
      "file_path": "httpx/client.py",
      "line": 591,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,8 +584,10 @@ def redirect_stream(\n                 await response.aclose()\n                 raise exc from None\n             else:\n+                response.history = list(history)\n+                await response.aread()\n                 request = next_request\n-                await response.aclose()\n+                history.append(response)\n ",
      "comment": "As suggested by @j178, this part closely follows the behavior we have when handling redirection: copy the current history onto the latest response, read the response (instead of closing it), then add the response to the history.\r\n\r\nThe only difference is that here we mutate `history` in-place instead of creating a new list (`history = history + [response]`) so that the change is propagated to `.send_handling_redirects()`.\r\n\r\nIt's possible to change this so that we build and maintain an `auth_history` list instead, and merge it with the initial `history` both here and `.send_handling_redirects()`, but I'm not sure the gained immutability would be worth the extra complexity.\r\n\r\nSeparate note: I don't think we test the case of redirect + auth yet, but that would be a good idea. Definitely out of scope for this PR though?",
      "comment_id": 362957305,
      "user": "florimondmanca",
      "created_at": "2020-01-03T20:52:22Z",
      "url": "https://github.com/encode/httpx/pull/718#discussion_r362957305"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 718,
      "file_path": "httpx/client.py",
      "line": 588,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,8 +584,10 @@ def redirect_stream(\n                 await response.aclose()\n                 raise exc from None\n             else:\n+                response.history = list(history)\n+                await response.aread()",
      "comment": "Yup, good call.\r\n\r\nIt's possible that at a later date we *might* want to ensure that streaming responses *don't* load an intermediate response bodies (in redirect or auth), but that's only a *\"might\"*, and would be a seperate issue if we *did* choose to tackle it.",
      "comment_id": 362962773,
      "user": "lovelydinosaur",
      "created_at": "2020-01-03T21:12:07Z",
      "url": "https://github.com/encode/httpx/pull/718#discussion_r362962773"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 603,
      "file_path": "httpx/concurrency/trio.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -204,17 +202,31 @@ def run(\n             functools.partial(coroutine, **kwargs) if kwargs else coroutine, *args\n         )\n \n+    async def fork(\n+        self,\n+        coroutine1: typing.Callable,\n+        args1: typing.Sequence,\n+        coroutine2: typing.Callable,\n+        args2: typing.Sequence,\n+    ) -> None:\n+        try:\n+            async with trio.open_nursery() as nursery:\n+                nursery.start_soon(coroutine1, *args1)\n+                nursery.start_soon(coroutine2, *args2)\n+        except trio.MultiError as exc:\n+            # NOTE: asyncio doesn't handle multi-errors yet, so we must align on its\n+            # behavior here, and need to arbitrarily decide which exception to raise.\n+            # We may want to add an 'httpx.MultiError', manually add support\n+            # for this situation in the asyncio backend, and re-raise\n+            # an 'httpx.MultiError' from trio's here.",
      "comment": "We can be more direct on our wording here. If `MultiError` occurs then we semantically only want *either* one of those two exceptions raised up to the user.",
      "comment_id": 354757802,
      "user": "lovelydinosaur",
      "created_at": "2019-12-06T10:18:18Z",
      "url": "https://github.com/encode/httpx/pull/603#discussion_r354757802"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 603,
      "file_path": "httpx/concurrency/asyncio.py",
      "line": 338,
      "side": "RIGHT",
      "diff_hunk": "@@ -317,34 +315,30 @@ def run(\n         finally:\n             self._loop = loop\n \n+    async def fork(\n+        self,\n+        coroutine1: typing.Callable,\n+        args1: typing.Sequence,\n+        coroutine2: typing.Callable,\n+        args2: typing.Sequence,\n+    ) -> None:\n+        task1 = self.loop.create_task(coroutine1(*args1))\n+        task2 = self.loop.create_task(coroutine2(*args2))\n+\n+        try:\n+            await asyncio.gather(task1, task2)\n+        finally:\n+            pending: typing.Set[asyncio.Future[typing.Any]]  # Please mypy.\n+            _, pending = await asyncio.wait({task1, task2}, timeout=0)\n+            for task in pending:\n+                task.cancel()\n+                try:\n+                    await task\n+                except asyncio.CancelledError:\n+                    pass",
      "comment": "This'll look a bunch nicer with `anyio`. (Tho we should leave Trio's implementation alone, since they already *have* a sensible nursery primitive.)",
      "comment_id": 354758409,
      "user": "lovelydinosaur",
      "created_at": "2019-12-06T10:19:21Z",
      "url": "https://github.com/encode/httpx/pull/603#discussion_r354758409"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 676,
      "file_path": "httpx/client.py",
      "line": 484,
      "side": "RIGHT",
      "diff_hunk": "@@ -476,7 +476,12 @@ def setup_auth(\n \n             if not allow_redirects:\n                 response.call_next = functools.partial(\n-                    self.send_handling_redirects,\n+                    # NOTE: not using 'self.send_handling_redirects' here, because\n+                    # 'call_next' must reference a function (instead\n+                    # of a method). This ensures that 'inspect.iscoroutinefunction()'\n+                    # checks behave properly.\n+                    Client.send_handling_redirects,\n+                    self,",
      "comment": "Yes, that's surprising, and possibly related to https://github.com/python/cpython/pull/16600 \u2014 details below\u2026\r\n\r\n<details>\r\n<summary>Details (click to expand)</summary>\r\nEssentially boils down to\u2026\r\n\r\n```python\r\nimport inspect\r\n\r\nclass Foo:\r\n    async def bar(self):\r\n        pass\r\n\r\nfoo = Foo()\r\nbar = functools.partial(foo.bar)\r\nprint(inspect.iscoroutinefunction(bar))  # False\r\n```\r\n\r\nStrangely though, the non-partial'd method behaves just fine\u2026\r\n\r\n```python\r\nprint(inspect.iscoroutinefunction(foo.bar))  # True\r\n```\r\n\r\n`functools.partial` is definitely doing something weird here, because\u2026\r\n\r\n```python\r\nprint(functools._unwrap_partial(bar) is foo.bar)  # False\r\n```\r\n\r\nEven though the unwrapping returns the same underlying function for \"non-method\" functions\u2026\r\n\r\n```python\r\nasync def funcbar():\r\n    pass\r\n\r\npfuncbar = functools.partial(funcbar)\r\nprint(functools._unwrap_partial(pfuncbar) is funcbar)  # True\r\n```\r\n\r\nBut then I realized this is a property of bound methods themselves\u2026\r\n\r\n```python\r\nprint(foo.bar is foo.bar)  # False\r\n```\r\n\r\nWtf, Python? \ud83e\udd37\u200d\u2642\ud83e\udd37\u200d\u2642\ud83e\udd37\u200d\u2642\ud83e\udd37\u200d\u2642\ud83e\udd37\u200d\u2642\r\n\r\n</details>",
      "comment_id": 360658726,
      "user": "florimondmanca",
      "created_at": "2019-12-21T17:10:51Z",
      "url": "https://github.com/encode/httpx/pull/676#discussion_r360658726"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 676,
      "file_path": "httpx/models.py",
      "line": 933,
      "side": "RIGHT",
      "diff_hunk": "@@ -922,13 +923,14 @@ def raw(self):  # type: ignore\n                 yield part\n             await self.close()\n \n-    async def next(self) -> \"Response\":\n+    async def anext(self) -> \"Response\":\n         \"\"\"\n         Get the next response from a redirect response.\n         \"\"\"\n         if not self.is_redirect:\n             raise NotRedirectResponse()\n         assert self.call_next is not None\n+        assert inspect.iscoroutinefunction(self.call_next)",
      "comment": "I wouldn\u2019t bother making this functional change, or the associated `partial` change. Let\u2019s just do a straight name change and leave it at that. We can look at any extra type smart when we introduce `.next()`",
      "comment_id": 360660490,
      "user": "lovelydinosaur",
      "created_at": "2019-12-21T17:52:25Z",
      "url": "https://github.com/encode/httpx/pull/676#discussion_r360660490"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 676,
      "file_path": "httpx/client.py",
      "line": 484,
      "side": "RIGHT",
      "diff_hunk": "@@ -476,7 +476,12 @@ def setup_auth(\n \n             if not allow_redirects:\n                 response.call_next = functools.partial(\n-                    self.send_handling_redirects,\n+                    # NOTE: not using 'self.send_handling_redirects' here, because\n+                    # 'call_next' must reference a function (instead\n+                    # of a method). This ensures that 'inspect.iscoroutinefunction()'\n+                    # checks behave properly.\n+                    Client.send_handling_redirects,\n+                    self,",
      "comment": "Strangely, this workaround doesn't work on 3.6 and 3.7 \u2014 CI is failing for those versions. \ud83d\ude15",
      "comment_id": 360660518,
      "user": "florimondmanca",
      "created_at": "2019-12-21T17:53:13Z",
      "url": "https://github.com/encode/httpx/pull/676#discussion_r360660518"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 676,
      "file_path": "httpx/models.py",
      "line": 933,
      "side": "RIGHT",
      "diff_hunk": "@@ -922,13 +923,14 @@ def raw(self):  # type: ignore\n                 yield part\n             await self.close()\n \n-    async def next(self) -> \"Response\":\n+    async def anext(self) -> \"Response\":\n         \"\"\"\n         Get the next response from a redirect response.\n         \"\"\"\n         if not self.is_redirect:\n             raise NotRedirectResponse()\n         assert self.call_next is not None\n+        assert inspect.iscoroutinefunction(self.call_next)",
      "comment": "Yep, that'd fix it *for now* \u2014 but we might bump into this again when looking at `.next()`. Anyway, will remove this check for now so we can move on.",
      "comment_id": 360660547,
      "user": "florimondmanca",
      "created_at": "2019-12-21T17:53:47Z",
      "url": "https://github.com/encode/httpx/pull/676#discussion_r360660547"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 460,
      "file_path": "noxfile.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,14 +41,14 @@ def check(session):\n     )\n \n \n-@nox.session(reuse_venv=True)\n+@nox.session\n def docs(session):\n-    session.install(\"mkdocs\", \"mkdocs-material\")\n+    session.install(\"--upgrade\", \"mkdocs\", \"mkdocs-material\", \"pymdown-extensions\")",
      "comment": "Same here - I don't think we need `pymdown-extensions` at the moment?",
      "comment_id": 333397843,
      "user": "lovelydinosaur",
      "created_at": "2019-10-10T08:45:36Z",
      "url": "https://github.com/encode/httpx/pull/460#discussion_r333397843"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 521,
      "file_path": "httpx/concurrency/asyncio.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,16 +58,49 @@ def __init__(\n         self, hostname: str, ssl_context: ssl.SSLContext, timeout: TimeoutConfig\n     ) -> \"SocketStream\":\n         loop = asyncio.get_event_loop()\n-        if not hasattr(loop, \"start_tls\"):  # pragma: no cover\n-            raise NotImplementedError(\n-                \"asyncio.AbstractEventLoop.start_tls() is only available in Python 3.7+\"\n-            )\n \n         stream_reader = asyncio.StreamReader()\n         protocol = asyncio.StreamReaderProtocol(stream_reader)\n         transport = self.stream_writer.transport\n \n-        loop_start_tls = loop.start_tls  # type: ignore\n+        if hasattr(loop, \"start_tls\"):\n+            loop_start_tls = loop.start_tls  # type: ignore",
      "comment": "Removing the `type: ignore` after changing the if statement to be `if sys.version_info >= (3, 7)` should pass CI with `mypy>=0.730`.",
      "comment_id": 345359669,
      "user": "JayH5",
      "created_at": "2019-11-12T18:03:39Z",
      "url": "https://github.com/encode/httpx/pull/521#discussion_r345359669"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 521,
      "file_path": "httpx/concurrency/asyncio.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,16 +58,49 @@ def __init__(\n         self, hostname: str, ssl_context: ssl.SSLContext, timeout: TimeoutConfig\n     ) -> \"SocketStream\":\n         loop = asyncio.get_event_loop()\n-        if not hasattr(loop, \"start_tls\"):  # pragma: no cover\n-            raise NotImplementedError(\n-                \"asyncio.AbstractEventLoop.start_tls() is only available in Python 3.7+\"\n-            )\n \n         stream_reader = asyncio.StreamReader()\n         protocol = asyncio.StreamReaderProtocol(stream_reader)\n         transport = self.stream_writer.transport\n \n-        loop_start_tls = loop.start_tls  # type: ignore\n+        if hasattr(loop, \"start_tls\"):\n+            loop_start_tls = loop.start_tls  # type: ignore",
      "comment": "Unfortunately we can't assume that loops on Python 3.6 don't have start_tls(). Uvloop supports 3.6 and supports start_tls(). That's interesting that mypy knows about features though! Would an assert work here?",
      "comment_id": 345366444,
      "user": "sethmlarson",
      "created_at": "2019-11-12T18:18:12Z",
      "url": "https://github.com/encode/httpx/pull/521#discussion_r345366444"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 521,
      "file_path": "httpx/concurrency/asyncio.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,16 +58,49 @@ def __init__(\n         self, hostname: str, ssl_context: ssl.SSLContext, timeout: TimeoutConfig\n     ) -> \"SocketStream\":\n         loop = asyncio.get_event_loop()\n-        if not hasattr(loop, \"start_tls\"):  # pragma: no cover\n-            raise NotImplementedError(\n-                \"asyncio.AbstractEventLoop.start_tls() is only available in Python 3.7+\"\n-            )\n \n         stream_reader = asyncio.StreamReader()\n         protocol = asyncio.StreamReaderProtocol(stream_reader)\n         transport = self.stream_writer.transport\n \n-        loop_start_tls = loop.start_tls  # type: ignore\n+        if hasattr(loop, \"start_tls\"):\n+            loop_start_tls = loop.start_tls  # type: ignore",
      "comment": "Ah I didn't know about uvloop \ud83d\ude1e\r\n\r\n> That's interesting that mypy knows about features though!\r\n\r\nIt knows about if/else with sys.version_info comparisons but that's all. It's very limited.\r\n\r\n> Would an assert work here?\r\n\r\nI don't think we can assert much about the function at runtime, unfortunately. Could maybe do something with `typing.cast` but probably not worth the effort.",
      "comment_id": 345404688,
      "user": "JayH5",
      "created_at": "2019-11-12T19:37:02Z",
      "url": "https://github.com/encode/httpx/pull/521#discussion_r345404688"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 804,
      "file_path": "httpx/_dispatch/asgi.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,8 +1,8 @@\n-import typing\n+from typing import Callable, List, Tuple",
      "comment": "Are you now nudged towards switching to that style too? I've been thinking about it lately. :-)",
      "comment_id": 374137478,
      "user": "florimondmanca",
      "created_at": "2020-02-03T14:38:22Z",
      "url": "https://github.com/encode/httpx/pull/804#discussion_r374137478"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 804,
      "file_path": "httpx/_dispatch/asgi.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,8 +1,8 @@\n-import typing\n+from typing import Callable, List, Tuple",
      "comment": "Happy enough either way, but yeah it works nicer in more verbose cases like the httpcore API.\r\n\r\nIe I'd rater we've got this kind of thing...\r\n\r\n```python\r\n    async def request(\r\n        self,\r\n        method: bytes,\r\n        url: Tuple[bytes, bytes, int, bytes],\r\n        headers: List[Tuple[bytes, bytes]] = None,\r\n        stream: ContentStream = None,\r\n        timeout: Dict[Optional[float]] = None,\r\n    ) -> Tuple[bytes, int, bytes, List[Tuple[bytes, bytes]], ContentStream]:\r\n```\r\n\r\nThan this:\r\n\r\n```python\r\n    async def request(\r\n        self,\r\n        method: bytes,\r\n        url: typing.Tuple[bytes, bytes, int, bytes],\r\n        headers: typing.List[typing.Tuple[bytes, bytes]] = None,\r\n        stream: ContentStream = None,\r\n        timeout: typing.Dict[typing.Optional[float]] = None,\r\n    ) -> Tuple[bytes, int, bytes, typing.List[typing.Tuple[bytes, bytes]], ContentStream]:\r\n```",
      "comment_id": 374150974,
      "user": "lovelydinosaur",
      "created_at": "2020-02-03T15:01:04Z",
      "url": "https://github.com/encode/httpx/pull/804#discussion_r374150974"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 804,
      "file_path": "tests/client/test_auth.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,44 +1,56 @@\n import hashlib\n-import json\n import os\n import typing\n \n+import httpcore\n import pytest\n \n from httpx import (\n     URL,\n     AsyncClient,\n     Auth,\n     DigestAuth,\n+    Headers,\n     ProtocolError,\n     Request,\n     RequestBodyUnavailable,\n     Response,\n )\n-from httpx._config import CertTypes, TimeoutTypes, VerifyTypes\n-from httpx._dispatch.base import AsyncDispatcher\n+from httpx._content_streams import ContentStream, JSONStream\n \n \n-class MockDispatch(AsyncDispatcher):\n-    def __init__(self, auth_header: str = \"\", status_code: int = 200) -> None:\n+def get_header_value(headers, key, default=None):\n+    lookup = key.encode(\"ascii\").lower()\n+    for header_key, header_value in headers:\n+        if header_key.lower() == lookup:\n+            return header_value.decode(\"ascii\")\n+    return default\n+\n+\n+class MockDispatch(httpcore.AsyncHTTPProxy):\n+    def __init__(self, auth_header: bytes = b\"\", status_code: int = 200) -> None:\n         self.auth_header = auth_header\n         self.status_code = status_code\n \n-    async def send(\n+    async def request(\n         self,\n-        request: Request,\n-        verify: VerifyTypes = None,\n-        cert: CertTypes = None,\n-        timeout: TimeoutTypes = None,\n-    ) -> Response:\n-        headers = [(\"www-authenticate\", self.auth_header)] if self.auth_header else []\n-        body = json.dumps({\"auth\": request.headers.get(\"Authorization\")}).encode()\n-        return Response(\n-            self.status_code, headers=headers, content=body, request=request\n+        method: bytes,\n+        url: typing.Tuple[bytes, bytes, int, bytes],\n+        headers: typing.List[typing.Tuple[bytes, bytes]],\n+        stream: ContentStream,\n+        timeout: typing.Dict[str, typing.Optional[float]] = None,\n+    ) -> typing.Tuple[\n+        bytes, int, bytes, typing.List[typing.Tuple[bytes, bytes]], ContentStream\n+    ]:\n+        authorization = get_header_value(headers, \"Authorization\")\n+        response_headers = (\n+            [(b\"www-authenticate\", self.auth_header)] if self.auth_header else []\n         )\n+        response_stream = JSONStream({\"auth\": authorization})\n+        return b\"HTTP/1.1\", self.status_code, b\"\", response_headers, response_stream\n \n \n-class MockDigestAuthDispatch(AsyncDispatcher):\n+class MockDigestAuthDispatch(httpcore.AsyncHTTPProxy):",
      "comment": "Why does this have to be an `HTTPProxy` now? (Is it an oversight?)",
      "comment_id": 388512691,
      "user": "florimondmanca",
      "created_at": "2020-03-05T19:26:54Z",
      "url": "https://github.com/encode/httpx/pull/804#discussion_r388512691"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 866,
      "file_path": "tests/models/test_requests.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,7 +10,7 @@ def test_request_repr():\n \n def test_no_content():\n     request = httpx.Request(\"GET\", \"http://example.org\")\n-    assert \"Content-Length\" not in request.headers\n+    assert request.headers[\"Content-Length\"] == \"0\"",
      "comment": "We shouldn't send Content-Length with GET/HEAD requests\r\nReferences:\r\n - https://github.com/encode/httpx/pull/866#issuecomment-605899948\r\n - https://tools.ietf.org/html/rfc7230#section-3.3.2 \"A user agent SHOULD NOT ...\"\r\n - `requests` implementation for non-stream requests https://github.com/psf/requests/blob/fd13816d015c4c90ee65297fa996caea6a094ed1/requests/models.py#L522-L533\r\n - `requests` implementation for stream requests https://github.com/psf/requests/blob/fd13816d015c4c90ee65297fa996caea6a094ed1/requests/models.py#L476-L479",
      "comment_id": 400079171,
      "user": "b0g3r",
      "created_at": "2020-03-30T10:16:11Z",
      "url": "https://github.com/encode/httpx/pull/866#discussion_r400079171"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 861,
      "file_path": "httpx/_content_streams.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,7 +331,7 @@ def encode(\n         else:\n             return ByteStream(body=b\"\")\n     elif isinstance(data, dict):",
      "comment": "Seems like we should also check for empty data here, so as to not send an empty `URLEncodedStream`, but instead an empty `ByteStream`:\r\n\r\n```suggestion\r\n    elif isinstance(data, dict) and data:\r\n```\r\n\r\nThis would put us in line with what requests does:\r\n\r\n```python\r\n>>> import requests\r\n>>> url = 'https://httpbin.org/post'\r\n>>> r = requests.post(url, data={}, files={})\r\n>>> r.request.headers\r\n{'User-Agent': 'python-requests/2.23.0', 'Accept-Encoding': 'gzip, deflate', 'Accept': '*/*', 'Connection': 'keep-alive', 'Content-Length': '0'}\r\n```",
      "comment_id": 392665739,
      "user": "florimondmanca",
      "created_at": "2020-03-15T11:44:09Z",
      "url": "https://github.com/encode/httpx/pull/861#discussion_r392665739"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 861,
      "file_path": "tests/test_content_streams.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,6 +189,21 @@ def hello_world():\n     )\n \n \n+@pytest.mark.asyncio\n+async def test_empty_request():\n+    stream = encode(data={}, files={})\n+    sync_content = b\"\".join([part for part in stream])\n+    async_content = b\"\".join([part async for part in stream])\n+\n+    assert stream.can_replay()\n+    assert stream.get_headers() == {\n+        \"Content-Length\": \"0\",\n+        \"Content-Type\": \"application/x-www-form-urlencoded\",",
      "comment": "(And so to match Requests there shouldn't be any `Content-Type` in the request. :-))",
      "comment_id": 392665817,
      "user": "florimondmanca",
      "created_at": "2020-03-15T11:45:18Z",
      "url": "https://github.com/encode/httpx/pull/861#discussion_r392665817"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 861,
      "file_path": "tests/test_content_streams.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,6 +189,21 @@ def hello_world():\n     )\n \n \n+@pytest.mark.asyncio\n+async def test_empty_request():\n+    stream = encode(data={}, files={})\n+    sync_content = b\"\".join([part for part in stream])\n+    async_content = b\"\".join([part async for part in stream])\n+\n+    assert stream.can_replay()\n+    assert stream.get_headers() == {\n+        \"Content-Length\": \"0\",\n+        \"Content-Type\": \"application/x-www-form-urlencoded\",",
      "comment": "I found that ByteStream.get_headers doesn't return Content-Length header with an empty body. Should I fix it?\r\nhttps://github.com/encode/httpx/blob/43ec09c3cbb089edd2e83ccc717fb95beef0c189/httpx/_content_streams.py#L73-L75",
      "comment_id": 392829966,
      "user": "b0g3r",
      "created_at": "2020-03-16T07:35:32Z",
      "url": "https://github.com/encode/httpx/pull/861#discussion_r392829966"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 861,
      "file_path": "tests/test_content_streams.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,6 +189,21 @@ def hello_world():\n     )\n \n \n+@pytest.mark.asyncio\n+async def test_empty_request():\n+    stream = encode(data={}, files={})\n+    sync_content = b\"\".join([part for part in stream])\n+    async_content = b\"\".join([part async for part in stream])\n+\n+    assert stream.can_replay()\n+    assert stream.get_headers() == {\n+        \"Content-Length\": \"0\",\n+        \"Content-Type\": \"application/x-www-form-urlencoded\",",
      "comment": "Because the body is `bytes` (`Union[str, bytes]` transformed in `__init__` to `bytes`) this check looks redundant \ud83e\udd14 ",
      "comment_id": 392830613,
      "user": "b0g3r",
      "created_at": "2020-03-16T07:37:24Z",
      "url": "https://github.com/encode/httpx/pull/861#discussion_r392830613"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 861,
      "file_path": "tests/test_content_streams.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,6 +189,21 @@ def hello_world():\n     )\n \n \n+@pytest.mark.asyncio\n+async def test_empty_request():\n+    stream = encode(data={}, files={})\n+    sync_content = b\"\".join([part for part in stream])\n+    async_content = b\"\".join([part async for part in stream])\n+\n+    assert stream.can_replay()\n+    assert stream.get_headers() == {\n+        \"Content-Length\": \"0\",\n+        \"Content-Type\": \"application/x-www-form-urlencoded\",",
      "comment": "Looking at [RFC 7320](https://tools.ietf.org/html/rfc7230#section-3.3.2), it looks like for POST requests including a `Content-Length` always is sort of recommended, yes:\r\n\r\n> A user agent SHOULD send a Content-Length in a request message when\r\n   no Transfer-Encoding is sent and the request method defines a meaning\r\n   for an enclosed payload body. **For example, a Content-Length header\r\n   field is normally sent in a POST request even when the value is 0\r\n   (indicating an empty payload body).**\r\n\r\nSo given that we only use `encode()` for multipart POST requests, I think it would make sense for us to do it. But let's treat that as a separate PR maybe? \ud83d\ude04",
      "comment_id": 392840494,
      "user": "florimondmanca",
      "created_at": "2020-03-16T08:03:28Z",
      "url": "https://github.com/encode/httpx/pull/861#discussion_r392840494"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 835,
      "file_path": "tests/client/test_proxies.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -87,3 +88,18 @@ def test_dispatcher_for_request(url, proxies, expected):\n def test_unsupported_proxy_scheme():\n     with pytest.raises(ValueError):\n         httpx.AsyncClient(proxies=\"ftp://127.0.0.1\")\n+\n+\n+def test_no_proxy_returns_correct_dispatcher(monkeypatch):\n+    monkeypatch.setenv(\"HTTP_PROXY\", \"http://example.com\")\n+    monkeypatch.setenv(\"NO_PROXY\", \"google.com\")\n+    client = httpx.AsyncClient()\n+    dispatcher = client.dispatcher_for_url(URL(\"http://google.com\"))\n+    assert dispatcher == client.dispatch\n+\n+\n+def test_no_proxy_not_set_returns_correct_dispatcher(monkeypatch):\n+    monkeypatch.setenv(\"HTTP_PROXY\", \"http://example.com\")\n+    client = httpx.AsyncClient()\n+    dispatcher = client.dispatcher_for_url(URL(\"http://google.com\"))\n+    assert dispatcher == client.proxies[\"http\"]",
      "comment": "I think we can use the style from the other test cases here, and parametrize this test to be able to easily add more test cases if needed (e.g. I added one below for the default \"no env set\" case), so\u2026\r\n\r\n```suggestion\r\n@pytest.mark.parametrize(\r\n    [\"url\", \"env\", \"expected\"],\r\n    [\r\n        (\"http://google.com\", {}, None),\r\n        (\r\n            \"http://google.com\",\r\n            {\"HTTP_PROXY\": \"http://example.com\"},\r\n            \"http://example.com\",\r\n        ),\r\n        (\r\n            \"http://google.com\",\r\n            {\"HTTP_PROXY\": \"http://example.com\", \"NO_PROXY\": \"google.com\"},\r\n            None,\r\n        ),\r\n    ],\r\n)\r\ndef test_proxies_environ(monkeypatch, url, env, expected):\r\n    for name, value in env.items():\r\n        monkeypatch.setenv(name, value)\r\n\r\n    client = httpx.AsyncClient()\r\n    dispatcher = client.dispatcher_for_url(httpx.URL(url))\r\n\r\n    if expected is None:\r\n        assert dispatcher == client.dispatch\r\n    else:\r\n        assert dispatcher.proxy_url == expected\r\n```",
      "comment_id": 386013243,
      "user": "florimondmanca",
      "created_at": "2020-02-29T08:48:09Z",
      "url": "https://github.com/encode/httpx/pull/835#discussion_r386013243"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 835,
      "file_path": "tests/client/test_proxies.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,6 +1,7 @@\n import pytest\n \n import httpx\n+from httpx import URL",
      "comment": "`URL` is a public piece of API; in that case we tend to have tests stick to the `httpx.*` usage we recommend for users. :-)\r\n\r\n```suggestion\r\n```",
      "comment_id": 386013274,
      "user": "florimondmanca",
      "created_at": "2020-02-29T08:48:51Z",
      "url": "https://github.com/encode/httpx/pull/835#discussion_r386013274"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 820,
      "file_path": "httpx/_models.py",
      "line": 524,
      "side": "RIGHT",
      "diff_hunk": "@@ -515,8 +515,13 @@ def __setitem__(self, key: str, value: str) -> None:\n         Set the header `key` to `value`, removing any duplicate entries.\n         Retains insertion order.\n         \"\"\"\n-        set_key = key.lower().encode(self.encoding)\n-        set_value = value.encode(self.encoding)\n+        try:\n+            set_key = key.lower().encode(self.encoding)\n+            set_value = value.encode(self.encoding)\n+        except UnicodeEncodeError:\n+            self.encoding = \"utf8\"\n+            set_key = key.lower().encode(self.encoding)\n+            set_value = value.encode(self.encoding)",
      "comment": "Actually I think we need a slightly different approach on this, since eg. we don't want to just change `self.encoding` if it has been explicitly set.\r\n\r\nHow's something like this?...\r\n\r\n```python\r\nencoding = self._encoding or \"utf-8\"\r\nset_key = key.lower().encode(encoding)\r\nset_value = value.encode(encoding)\r\n```",
      "comment_id": 383197150,
      "user": "lovelydinosaur",
      "created_at": "2020-02-24T10:52:54Z",
      "url": "https://github.com/encode/httpx/pull/820#discussion_r383197150"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 819,
      "file_path": "tests/client/test_redirects.py",
      "line": 249,
      "side": "LEFT",
      "diff_hunk": "@@ -242,23 +241,6 @@ class MockDispatch(AsyncDispatcher):\n             response = await response.anext()\n \n \n-@pytest.mark.usefixtures(\"async_environment\")\n-async def test_redirect_loop():\n-    client = AsyncClient(dispatch=MockDispatch())\n-    with pytest.raises(RedirectLoop):\n-        await client.get(\"https://example.org/redirect_loop\")",
      "comment": "I guess we *could* keep this test in, and just ensure that `TooManyRedirects` is raised?",
      "comment_id": 383145717,
      "user": "lovelydinosaur",
      "created_at": "2020-02-24T09:11:03Z",
      "url": "https://github.com/encode/httpx/pull/819#discussion_r383145717"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 819,
      "file_path": "tests/client/test_redirects.py",
      "line": 249,
      "side": "LEFT",
      "diff_hunk": "@@ -242,23 +241,6 @@ class MockDispatch(AsyncDispatcher):\n             response = await response.anext()\n \n \n-@pytest.mark.usefixtures(\"async_environment\")\n-async def test_redirect_loop():\n-    client = AsyncClient(dispatch=MockDispatch())\n-    with pytest.raises(RedirectLoop):\n-        await client.get(\"https://example.org/redirect_loop\")",
      "comment": "There is already test for TooManyRedirects with 21 redirects so i thought it's gonna be enough but sure more is better.",
      "comment_id": 383164675,
      "user": "oczkers",
      "created_at": "2020-02-24T09:50:22Z",
      "url": "https://github.com/encode/httpx/pull/819#discussion_r383164675"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 803,
      "file_path": "tests/client/test_auth.py",
      "line": 498,
      "side": "RIGHT",
      "diff_hunk": "@@ -467,3 +467,37 @@ def auth_flow(\n \n     with pytest.raises(RequestBodyUnavailable):\n         await client.post(url, data=streaming_body(), auth=auth)\n+\n+\n+@pytest.mark.asyncio\n+async def test_auth_reads_response_body() -> None:\n+    \"\"\"\n+    Test that we can read the response body in an auth flow if `requires_response_body`\n+    is set.\n+    \"\"\"\n+\n+    class ResponseBodyAuth(Auth):\n+        \"\"\"\n+        A mock authentication scheme that requires clients to send an 'Authorization'\n+        header, then send back the contents of the response in the 'Authorization'\n+        header.\n+        \"\"\"\n+\n+        requires_response_body = True\n+\n+        def auth_flow(\n+            self, request: Request\n+        ) -> typing.Generator[Request, Response, None]:\n+            request.headers[\"Authorization\"] = \"xyz\"\n+            response = yield request\n+            data = response.text\n+            request.headers[\"Authorization\"] = data\n+            yield request\n+\n+    url = \"https://example.org/\"\n+    auth = ResponseBodyAuth()",
      "comment": "For clarity, can we make it so that `\"xyz\"` is passed as a parameter here?\r\n\r\n```suggestion\r\n    auth = ResponseBodyAuth(\"xyz\")\r\n```",
      "comment_id": 374150832,
      "user": "florimondmanca",
      "created_at": "2020-02-03T15:00:50Z",
      "url": "https://github.com/encode/httpx/pull/803#discussion_r374150832"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 780,
      "file_path": "httpx/config.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -325,10 +326,25 @@ def __init__(\n         if mode not in (\"DEFAULT\", \"CONNECT_ONLY\", \"TUNNEL_ONLY\"):\n             raise ValueError(f\"Unknown proxy mode {mode!r}\")\n \n+        if url.username or url.password:\n+            headers.setdefault(\n+                \"Proxy-Authorization\",\n+                self.build_auth_header(url.username, url.password),\n+            )\n+            # Remove userinfo from the URL authority, e.g.:\n+            # 'username:password@proxy_host:proxy_port' -> 'proxy_host:proxy_port'\n+            credentials, _, authority = url.authority.rpartition(\"@\")\n+            url = url.copy_with(authority=authority)",
      "comment": "Perhaps replace these two lines with `ul = url.copy_with(username=None, password=None)`?",
      "comment_id": 368442692,
      "user": "lovelydinosaur",
      "created_at": "2020-01-20T09:27:29Z",
      "url": "https://github.com/encode/httpx/pull/780#discussion_r368442692"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 780,
      "file_path": "httpx/config.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -325,10 +326,25 @@ def __init__(\n         if mode not in (\"DEFAULT\", \"CONNECT_ONLY\", \"TUNNEL_ONLY\"):\n             raise ValueError(f\"Unknown proxy mode {mode!r}\")\n \n+        if url.username or url.password:\n+            headers.setdefault(\n+                \"Proxy-Authorization\",\n+                self.build_auth_header(url.username, url.password),\n+            )\n+            # Remove userinfo from the URL authority, e.g.:\n+            # 'username:password@proxy_host:proxy_port' -> 'proxy_host:proxy_port'\n+            credentials, _, authority = url.authority.rpartition(\"@\")\n+            url = url.copy_with(authority=authority)",
      "comment": "That's definitely cleaner, good catch :+1:\r\n\r\nThe `copy_with` seems to add the default port to the URL though which forced me to change the tests a bit, but I think that's fine.",
      "comment_id": 368461225,
      "user": "yeraydiazdiaz",
      "created_at": "2020-01-20T10:04:35Z",
      "url": "https://github.com/encode/httpx/pull/780#discussion_r368461225"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 735,
      "file_path": "httpx/dispatch/wsgi.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+import io\n+import typing\n+\n+from ..config import TimeoutTypes\n+from ..content_streams import IteratorStream\n+from ..models import Request, Response\n+from .base import SyncDispatcher\n+\n+\n+class WSGIDispatch(SyncDispatcher):\n+    \"\"\"\n+    A custom SyncDispatcher that handles sending requests directly to an WSGI app.\n+    The simplest way to use this functionality is to use the `app` argument.\n+\n+    ```\n+    client = httpx.Client(app=app)\n+    ```\n+\n+    Alternatively, you can setup the dispatch instance explicitly.\n+    This allows you to include any additional configuration arguments specific\n+    to the WSGIDispatch class:\n+\n+    ```\n+    dispatch = httpx.WSGIDispatch(\n+        app=app,\n+        script_name=\"/submount\",\n+        remote_addr=\"1.2.3.4\"\n+    )\n+    client = httpx.Client(dispatch=dispatch)\n+    ```\n+\n+    Arguments:\n+\n+    * `app` - The ASGI application.\n+    * `raise_app_exceptions` - Boolean indicating if exceptions in the application\n+       should be raised. Default to `True`. Can be set to `False` for use cases\n+       such as testing the content of a client 500 response.\n+    * `script_name` - The root path on which the ASGI application should be mounted.\n+    * `remote_addr` - A string indicating the client IP of incoming requests.\n+    ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        app: typing.Callable,\n+        raise_app_exceptions: bool = True,\n+        script_name: str = \"\",\n+        remote_addr: str = \"127.0.0.1\",\n+    ) -> None:\n+        self.app = app\n+        self.raise_app_exceptions = raise_app_exceptions\n+        self.script_name = script_name\n+        self.remote_addr = remote_addr\n+\n+    def send(self, request: Request, timeout: TimeoutTypes = None) -> Response:\n+        environ = {\n+            \"wsgi.version\": (1, 0),\n+            \"wsgi.url_scheme\": request.url.scheme,\n+            \"wsgi.input\": BodyStream(request.stream.__iter__()),\n+            \"wsgi.errors\": io.BytesIO(),\n+            \"wsgi.multithread\": True,\n+            \"wsgi.multiprocess\": False,\n+            \"wsgi.run_once\": False,\n+            \"REQUEST_METHOD\": request.method,\n+            \"SCRIPT_NAME\": self.script_name,\n+            \"PATH_INFO\": request.url.path,\n+            \"QUERY_STRING\": request.url.query,\n+            \"SERVER_NAME\": request.url.host,\n+            \"SERVER_PORT\": str(request.url.port),\n+            \"REMOTE_ADDR\": self.remote_addr,\n+        }\n+        for key, value in request.headers.items():\n+            key = key.upper().replace(\"-\", \"_\")\n+            if key not in (\"CONTENT_TYPE\", \"CONTENT_LENGTH\"):\n+                key = \"HTTP_\" + key\n+            environ[key] = value\n+\n+        seen_status = None\n+        seen_response_headers = None\n+        seen_exc_info = None\n+\n+        def start_response(\n+            status: str, response_headers: list, exc_info: typing.Any = None\n+        ) -> None:\n+            nonlocal seen_status, seen_response_headers, seen_exc_info\n+            seen_status = status\n+            seen_response_headers = response_headers\n+            seen_exc_info = exc_info\n+\n+        result = self.app(environ, start_response)\n+\n+        assert seen_status is not None\n+        assert seen_response_headers is not None\n+        if seen_exc_info and self.raise_app_exceptions:\n+            raise seen_exc_info[1]\n+\n+        return Response(\n+            status_code=int(seen_status.split()[0]),\n+            http_version=\"HTTP/1.1\",\n+            headers=seen_response_headers,\n+            stream=IteratorStream(chunk for chunk in result),\n+            request=request,\n+        )\n+\n+\n+class BodyStream(io.RawIOBase):",
      "comment": "Can we call this `WSGIInput`, so that it doesn't clash with our own concept of \"streams\"?\r\n\r\nI'm also a bit surprised by this class. Does WSGI necessarily require such an object to be passed? Can't an `io.BytesIO` do the trick?",
      "comment_id": 363881101,
      "user": "florimondmanca",
      "created_at": "2020-01-07T18:15:10Z",
      "url": "https://github.com/encode/httpx/pull/735#discussion_r363881101"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 735,
      "file_path": "httpx/client.py",
      "line": 888,
      "side": "RIGHT",
      "diff_hunk": "@@ -437,88 +299,743 @@ def build_redirect_request(self, request: Request, response: Response) -> Reques\n             method=method, url=url, headers=headers, cookies=cookies, stream=stream\n         )\n \n-    def redirect_method(self, request: Request, response: Response) -> str:\n-        \"\"\"\n-        When being redirected we may want to change the method of the request\n-        based on certain specs or browser behavior.\n-        \"\"\"\n-        method = request.method\n-\n-        # https://tools.ietf.org/html/rfc7231#section-6.4.4\n-        if response.status_code == codes.SEE_OTHER and method != \"HEAD\":\n-            method = \"GET\"\n+    def redirect_method(self, request: Request, response: Response) -> str:\n+        \"\"\"\n+        When being redirected we may want to change the method of the request\n+        based on certain specs or browser behavior.\n+        \"\"\"\n+        method = request.method\n+\n+        # https://tools.ietf.org/html/rfc7231#section-6.4.4\n+        if response.status_code == codes.SEE_OTHER and method != \"HEAD\":\n+            method = \"GET\"\n+\n+        # Do what the browsers do, despite standards...\n+        # Turn 302s into GETs.\n+        if response.status_code == codes.FOUND and method != \"HEAD\":\n+            method = \"GET\"\n+\n+        # If a POST is responded to with a 301, turn it into a GET.\n+        # This bizarre behaviour is explained in 'requests' issue 1704.\n+        if response.status_code == codes.MOVED_PERMANENTLY and method == \"POST\":\n+            method = \"GET\"\n+\n+        return method\n+\n+    def redirect_url(self, request: Request, response: Response) -> URL:\n+        \"\"\"\n+        Return the URL for the redirect to follow.\n+        \"\"\"\n+        location = response.headers[\"Location\"]\n+\n+        url = URL(location, allow_relative=True)\n+\n+        # Facilitate relative 'Location' headers, as allowed by RFC 7231.\n+        # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n+        if url.is_relative_url:\n+            url = request.url.join(url)\n+\n+        # Attach previous fragment if needed (RFC 7231 7.1.2)\n+        if request.url.fragment and not url.fragment:\n+            url = url.copy_with(fragment=request.url.fragment)\n+\n+        return url\n+\n+    def redirect_headers(self, request: Request, url: URL, method: str) -> Headers:\n+        \"\"\"\n+        Return the headers that should be used for the redirect request.\n+        \"\"\"\n+        headers = Headers(request.headers)\n+\n+        if Origin(url) != Origin(request.url):\n+            # Strip Authorization headers when responses are redirected away from\n+            # the origin.\n+            headers.pop(\"Authorization\", None)\n+            headers[\"Host\"] = url.authority\n+\n+        if method != request.method and method == \"GET\":\n+            # If we've switch to a 'GET' request, then strip any headers which\n+            # are only relevant to the request body.\n+            headers.pop(\"Content-Length\", None)\n+            headers.pop(\"Transfer-Encoding\", None)\n+\n+        # We should use the client cookie store to determine any cookie header,\n+        # rather than whatever was on the original outgoing request.\n+        headers.pop(\"Cookie\", None)\n+\n+        return headers\n+\n+    def redirect_stream(\n+        self, request: Request, method: str\n+    ) -> typing.Optional[ContentStream]:\n+        \"\"\"\n+        Return the body that should be used for the redirect request.\n+        \"\"\"\n+        if method != request.method and method == \"GET\":\n+            return None\n+\n+        if not request.stream.can_replay():\n+            raise RequestBodyUnavailable(\n+                \"Got a redirect response, but the request body was streaming \"\n+                \"and is no longer available.\"\n+            )\n+\n+        return request.stream\n+\n+\n+class Client(BaseClient):\n+    \"\"\"\n+    An HTTP client, with connection pooling, HTTP/2, redirects, cookie persistence, etc.\n+\n+    Usage:\n+\n+    ```python\n+    >>> client = httpx.Client()\n+    >>> response = client.get('https://example.org')\n+    ```\n+\n+    **Parameters:**\n+\n+    * **auth** - *(optional)* An authentication class to use when sending\n+    requests.\n+    * **params** - *(optional)* Query parameters to include in request URLs, as\n+    a string, dictionary, or list of two-tuples.\n+    * **headers** - *(optional)* Dictionary of HTTP headers to include when\n+    sending requests.\n+    * **cookies** - *(optional)* Dictionary of Cookie items to include when\n+    sending requests.\n+    * **verify** - *(optional)* SSL certificates (a.k.a CA bundle) used to\n+    verify the identity of requested hosts. Either `True` (default CA bundle),\n+    a path to an SSL certificate file, or `False` (disable verification).\n+    * **cert** - *(optional)* An SSL certificate used by the requested host\n+    to authenticate the client. Either a path to an SSL certificate file, or\n+    two-tuple of (certificate file, key file), or a three-tuple of (certificate\n+    file, key file, password).\n+    * **proxies** - *(optional)* A dictionary mapping HTTP protocols to proxy\n+    URLs.\n+    * **timeout** - *(optional)* The timeout configuration to use when sending\n+    requests.\n+    * **pool_limits** - *(optional)* The connection pool configuration to use\n+    when determining the maximum number of concurrently open HTTP connections.\n+    * **max_redirects** - *(optional)* The maximum number of redirect responses\n+    that should be followed.\n+    * **base_url** - *(optional)* A URL to use as the base when building\n+    request URLs.\n+    * **dispatch** - *(optional)* A dispatch class to use for sending requests\n+    over the network.\n+    * **app** - *(optional)* An ASGI application to send requests to,\n+    rather than sending actual network requests.\n+    * **trust_env** - *(optional)* Enables or disables usage of environment\n+    variables for configuration.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        *,\n+        auth: AuthTypes = None,\n+        params: QueryParamTypes = None,\n+        headers: HeaderTypes = None,\n+        cookies: CookieTypes = None,\n+        verify: VerifyTypes = True,\n+        cert: CertTypes = None,\n+        proxies: ProxiesTypes = None,\n+        timeout: TimeoutTypes = DEFAULT_TIMEOUT_CONFIG,\n+        pool_limits: PoolLimits = DEFAULT_POOL_LIMITS,\n+        max_redirects: int = DEFAULT_MAX_REDIRECTS,\n+        base_url: URLTypes = None,\n+        dispatch: SyncDispatcher = None,\n+        app: typing.Callable = None,\n+        trust_env: bool = True,\n+    ):\n+        super().__init__(\n+            auth=auth,\n+            params=params,\n+            headers=headers,\n+            cookies=cookies,\n+            timeout=timeout,\n+            max_redirects=max_redirects,\n+            base_url=base_url,\n+            trust_env=trust_env,\n+        )\n+\n+        proxy_map = self.get_proxy_map(proxies, trust_env)\n+\n+        self.dispatch = self.init_dispatch(\n+            verify=verify,\n+            cert=cert,\n+            pool_limits=pool_limits,\n+            dispatch=dispatch,\n+            app=app,\n+            trust_env=trust_env,\n+        )\n+        self.proxies: typing.Dict[str, SyncDispatcher] = {\n+            key: self.init_proxy_dispatch(\n+                proxy,\n+                verify=verify,\n+                cert=cert,\n+                pool_limits=pool_limits,\n+                trust_env=trust_env,\n+            )\n+            for key, proxy in proxy_map.items()\n+        }\n+\n+    def init_dispatch(\n+        self,\n+        verify: VerifyTypes = True,\n+        cert: CertTypes = None,\n+        pool_limits: PoolLimits = DEFAULT_POOL_LIMITS,\n+        dispatch: SyncDispatcher = None,\n+        app: typing.Callable = None,\n+        trust_env: bool = True,\n+    ) -> SyncDispatcher:\n+        if dispatch is not None:\n+            return dispatch\n+\n+        if app is not None:\n+            return WSGIDispatch(app=app)\n+\n+        return URLLib3Dispatcher(\n+            verify=verify, cert=cert, pool_limits=pool_limits, trust_env=trust_env,\n+        )\n+\n+    def init_proxy_dispatch(\n+        self,\n+        proxy: Proxy,\n+        verify: VerifyTypes = True,\n+        cert: CertTypes = None,\n+        pool_limits: PoolLimits = DEFAULT_POOL_LIMITS,\n+        trust_env: bool = True,\n+    ) -> SyncDispatcher:\n+        return URLLib3Dispatcher(\n+            proxy=proxy,\n+            verify=verify,\n+            cert=cert,\n+            pool_limits=pool_limits,\n+            trust_env=trust_env,\n+        )\n+\n+    def dispatcher_for_url(self, url: URL) -> SyncDispatcher:\n+        \"\"\"\n+        Returns the SyncDispatcher instance that should be used for a given URL.\n+        This will either be the standard connection pool, or a proxy.\n+        \"\"\"\n+        if self.proxies:\n+            is_default_port = (url.scheme == \"http\" and url.port == 80) or (\n+                url.scheme == \"https\" and url.port == 443\n+            )\n+            hostname = f\"{url.host}:{url.port}\"\n+            proxy_keys = (\n+                f\"{url.scheme}://{hostname}\",\n+                f\"{url.scheme}://{url.host}\" if is_default_port else None,\n+                f\"all://{hostname}\",\n+                f\"all://{url.host}\" if is_default_port else None,\n+                url.scheme,\n+                \"all\",\n+            )\n+            for proxy_key in proxy_keys:\n+                if proxy_key and proxy_key in self.proxies:\n+                    dispatcher = self.proxies[proxy_key]\n+                    return dispatcher\n+\n+        return self.dispatch\n+\n+    def request(\n+        self,\n+        method: str,\n+        url: URLTypes,\n+        *,\n+        data: RequestData = None,\n+        files: RequestFiles = None,\n+        json: typing.Any = None,\n+        params: QueryParamTypes = None,\n+        headers: HeaderTypes = None,\n+        cookies: CookieTypes = None,\n+        auth: AuthTypes = None,\n+        allow_redirects: bool = True,\n+        timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n+    ) -> Response:\n+        request = self.build_request(\n+            method=method,\n+            url=url,\n+            data=data,\n+            files=files,\n+            json=json,\n+            params=params,\n+            headers=headers,\n+            cookies=cookies,\n+        )\n+        return self.send(\n+            request, auth=auth, allow_redirects=allow_redirects, timeout=timeout,\n+        )\n+\n+    def send(\n+        self,\n+        request: Request,\n+        *,\n+        stream: bool = False,\n+        auth: AuthTypes = None,\n+        allow_redirects: bool = True,\n+        timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n+    ) -> Response:\n+        if request.url.scheme not in (\"http\", \"https\"):\n+            raise InvalidURL('URL scheme must be \"http\" or \"https\".')\n+\n+        timeout = self.timeout if isinstance(timeout, UnsetType) else Timeout(timeout)\n+\n+        auth = self.build_auth(request, auth)\n+\n+        response = self.send_handling_redirects(\n+            request, auth=auth, timeout=timeout, allow_redirects=allow_redirects,\n+        )\n+\n+        if not stream:\n+            try:\n+                response.read()\n+            finally:\n+                response.close()\n+\n+        return response\n+\n+    def send_handling_redirects(\n+        self,\n+        request: Request,\n+        auth: Auth,\n+        timeout: Timeout,\n+        allow_redirects: bool = True,\n+        history: typing.List[Response] = None,\n+    ) -> Response:\n+        if history is None:\n+            history = []\n+\n+        while True:\n+            if len(history) > self.max_redirects:\n+                raise TooManyRedirects()\n+            urls = ((resp.request.method, resp.url) for resp in history)\n+            if (request.method, request.url) in urls:\n+                raise RedirectLoop()\n+\n+            response = self.send_handling_auth(\n+                request, auth=auth, timeout=timeout, history=history\n+            )\n+            response.history = list(history)\n+\n+            if not response.is_redirect:\n+                return response\n+\n+            response.read()\n+            request = self.build_redirect_request(request, response)\n+            history = history + [response]\n+\n+            if not allow_redirects:\n+                response.call_next = functools.partial(\n+                    self.send_handling_redirects,\n+                    request=request,\n+                    auth=auth,\n+                    timeout=timeout,\n+                    allow_redirects=False,\n+                    history=history,\n+                )\n+                return response\n+\n+    def send_handling_auth(\n+        self,\n+        request: Request,\n+        history: typing.List[Response],\n+        auth: Auth,\n+        timeout: Timeout,\n+    ) -> Response:\n+        if auth.requires_request_body:\n+            request.read()\n+\n+        auth_flow = auth.auth_flow(request)\n+        request = next(auth_flow)\n+        while True:\n+            response = self.send_single_request(request, timeout)\n+            try:\n+                next_request = auth_flow.send(response)\n+            except StopIteration:\n+                return response\n+            except BaseException as exc:\n+                response.close()\n+                raise exc from None\n+            else:\n+                response.history = list(history)\n+                response.read()\n+                request = next_request\n+                history.append(response)\n+\n+    def send_single_request(self, request: Request, timeout: Timeout,) -> Response:\n+        \"\"\"\n+        Sends a single request, without handling any redirections.\n+        \"\"\"\n+\n+        dispatcher = self.dispatcher_for_url(request.url)\n+\n+        try:\n+            response = dispatcher.send(request, timeout=timeout)\n+        except HTTPError as exc:\n+            # Add the original request to any HTTPError unless\n+            # there'a already a request attached in the case of\n+            # a ProxyError.\n+            if exc.request is None:\n+                exc.request = request\n+            raise\n+\n+        self.cookies.extract_cookies(response)\n+\n+        status = f\"{response.status_code} {response.reason_phrase}\"\n+        response_line = f\"{response.http_version} {status}\"\n+        logger.debug(f'HTTP Request: {request.method} {request.url} \"{response_line}\"')\n+\n+        return response\n+\n+    def get(\n+        self,\n+        url: URLTypes,\n+        *,\n+        params: QueryParamTypes = None,\n+        headers: HeaderTypes = None,\n+        cookies: CookieTypes = None,\n+        auth: AuthTypes = None,\n+        allow_redirects: bool = True,\n+        timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n+    ) -> Response:\n+        return self.request(\n+            \"GET\",\n+            url,\n+            params=params,\n+            headers=headers,\n+            cookies=cookies,\n+            auth=auth,\n+            allow_redirects=allow_redirects,\n+            timeout=timeout,\n+        )\n+\n+    def options(\n+        self,\n+        url: URLTypes,\n+        *,\n+        params: QueryParamTypes = None,\n+        headers: HeaderTypes = None,\n+        cookies: CookieTypes = None,\n+        auth: AuthTypes = None,\n+        allow_redirects: bool = True,\n+        timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n+    ) -> Response:\n+        return self.request(\n+            \"OPTIONS\",\n+            url,\n+            params=params,\n+            headers=headers,\n+            cookies=cookies,\n+            auth=auth,\n+            allow_redirects=allow_redirects,\n+            timeout=timeout,\n+        )\n+\n+    def head(\n+        self,\n+        url: URLTypes,\n+        *,\n+        params: QueryParamTypes = None,\n+        headers: HeaderTypes = None,\n+        cookies: CookieTypes = None,\n+        auth: AuthTypes = None,\n+        allow_redirects: bool = False,  # NOTE: Differs to usual default.\n+        timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n+    ) -> Response:\n+        return self.request(\n+            \"HEAD\",\n+            url,\n+            params=params,\n+            headers=headers,\n+            cookies=cookies,\n+            auth=auth,\n+            allow_redirects=allow_redirects,\n+            timeout=timeout,\n+        )\n+\n+    def post(\n+        self,\n+        url: URLTypes,\n+        *,\n+        data: RequestData = None,\n+        files: RequestFiles = None,\n+        json: typing.Any = None,\n+        params: QueryParamTypes = None,\n+        headers: HeaderTypes = None,\n+        cookies: CookieTypes = None,\n+        auth: AuthTypes = None,\n+        allow_redirects: bool = True,\n+        timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n+    ) -> Response:\n+        return self.request(\n+            \"POST\",\n+            url,\n+            data=data,\n+            files=files,\n+            json=json,\n+            params=params,\n+            headers=headers,\n+            cookies=cookies,\n+            auth=auth,\n+            allow_redirects=allow_redirects,\n+            timeout=timeout,\n+        )\n+\n+    def put(\n+        self,\n+        url: URLTypes,\n+        *,\n+        data: RequestData = None,\n+        files: RequestFiles = None,\n+        json: typing.Any = None,\n+        params: QueryParamTypes = None,\n+        headers: HeaderTypes = None,\n+        cookies: CookieTypes = None,\n+        auth: AuthTypes = None,\n+        allow_redirects: bool = True,\n+        timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n+    ) -> Response:\n+        return self.request(\n+            \"PUT\",\n+            url,\n+            data=data,\n+            files=files,\n+            json=json,\n+            params=params,\n+            headers=headers,\n+            cookies=cookies,\n+            auth=auth,\n+            allow_redirects=allow_redirects,\n+            timeout=timeout,\n+        )\n+\n+    def patch(\n+        self,\n+        url: URLTypes,\n+        *,\n+        data: RequestData = None,\n+        files: RequestFiles = None,\n+        json: typing.Any = None,\n+        params: QueryParamTypes = None,\n+        headers: HeaderTypes = None,\n+        cookies: CookieTypes = None,\n+        auth: AuthTypes = None,\n+        allow_redirects: bool = True,\n+        timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n+    ) -> Response:\n+        return self.request(\n+            \"PATCH\",\n+            url,\n+            data=data,\n+            files=files,\n+            json=json,\n+            params=params,\n+            headers=headers,\n+            cookies=cookies,\n+            auth=auth,\n+            allow_redirects=allow_redirects,\n+            timeout=timeout,\n+        )\n+\n+    def delete(\n+        self,\n+        url: URLTypes,\n+        *,\n+        params: QueryParamTypes = None,\n+        headers: HeaderTypes = None,\n+        cookies: CookieTypes = None,\n+        auth: AuthTypes = None,\n+        allow_redirects: bool = True,\n+        timeout: typing.Union[TimeoutTypes, UnsetType] = UNSET,\n+    ) -> Response:\n+        return self.request(\n+            \"DELETE\",\n+            url,\n+            params=params,\n+            headers=headers,\n+            cookies=cookies,\n+            auth=auth,\n+            allow_redirects=allow_redirects,\n+            timeout=timeout,\n+        )\n \n-        # Do what the browsers do, despite standards...\n-        # Turn 302s into GETs.\n-        if response.status_code == codes.FOUND and method != \"HEAD\":\n-            method = \"GET\"\n+    def close(self) -> None:\n+        self.dispatch.close()\n \n-        # If a POST is responded to with a 301, turn it into a GET.\n-        # This bizarre behaviour is explained in 'requests' issue 1704.\n-        if response.status_code == codes.MOVED_PERMANENTLY and method == \"POST\":\n-            method = \"GET\"\n+    def __enter__(self) -> \"Client\":\n+        return self\n \n-        return method\n+    def __exit__(\n+        self,\n+        exc_type: typing.Type[BaseException] = None,\n+        exc_value: BaseException = None,\n+        traceback: TracebackType = None,\n+    ) -> None:\n+        self.close()\n \n-    def redirect_url(self, request: Request, response: Response) -> URL:\n-        \"\"\"\n-        Return the URL for the redirect to follow.\n-        \"\"\"\n-        location = response.headers[\"Location\"]\n \n-        url = URL(location, allow_relative=True)\n+class AsyncClient(BaseClient):\n+    \"\"\"\n+    An asynchronous HTTP client, with connection pooling, HTTP/2, redirects,\n+    cookie persistence, etc.\n \n-        # Facilitate relative 'Location' headers, as allowed by RFC 7231.\n-        # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n-        if url.is_relative_url:\n-            url = request.url.join(url)\n+    Usage:\n \n-        # Attach previous fragment if needed (RFC 7231 7.1.2)\n-        if request.url.fragment and not url.fragment:\n-            url = url.copy_with(fragment=request.url.fragment)\n+    ```python\n+    >>> client = httpx.AsyncClient()\n+    >>> response = client.get('https://example.org')",
      "comment": "Encourage block usage? Also the `await` keyword is missing:\r\n\r\n```python\r\n>>> async with httpx.AsyncClient():\r\n...     response = await client.get(\"https://example.org\")\r\n```",
      "comment_id": 363883365,
      "user": "florimondmanca",
      "created_at": "2020-01-07T18:20:36Z",
      "url": "https://github.com/encode/httpx/pull/735#discussion_r363883365"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 735,
      "file_path": "httpx/dispatch/wsgi.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+import io\n+import typing\n+\n+from ..config import TimeoutTypes\n+from ..content_streams import IteratorStream\n+from ..models import Request, Response\n+from .base import SyncDispatcher\n+\n+\n+class WSGIDispatch(SyncDispatcher):\n+    \"\"\"\n+    A custom SyncDispatcher that handles sending requests directly to an WSGI app.\n+    The simplest way to use this functionality is to use the `app` argument.\n+\n+    ```\n+    client = httpx.Client(app=app)\n+    ```\n+\n+    Alternatively, you can setup the dispatch instance explicitly.\n+    This allows you to include any additional configuration arguments specific\n+    to the WSGIDispatch class:\n+\n+    ```\n+    dispatch = httpx.WSGIDispatch(\n+        app=app,\n+        script_name=\"/submount\",\n+        remote_addr=\"1.2.3.4\"\n+    )\n+    client = httpx.Client(dispatch=dispatch)\n+    ```\n+\n+    Arguments:\n+\n+    * `app` - The ASGI application.\n+    * `raise_app_exceptions` - Boolean indicating if exceptions in the application\n+       should be raised. Default to `True`. Can be set to `False` for use cases\n+       such as testing the content of a client 500 response.\n+    * `script_name` - The root path on which the ASGI application should be mounted.\n+    * `remote_addr` - A string indicating the client IP of incoming requests.\n+    ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        app: typing.Callable,\n+        raise_app_exceptions: bool = True,\n+        script_name: str = \"\",\n+        remote_addr: str = \"127.0.0.1\",\n+    ) -> None:\n+        self.app = app\n+        self.raise_app_exceptions = raise_app_exceptions\n+        self.script_name = script_name\n+        self.remote_addr = remote_addr\n+\n+    def send(self, request: Request, timeout: TimeoutTypes = None) -> Response:\n+        environ = {\n+            \"wsgi.version\": (1, 0),\n+            \"wsgi.url_scheme\": request.url.scheme,\n+            \"wsgi.input\": BodyStream(request.stream.__iter__()),\n+            \"wsgi.errors\": io.BytesIO(),\n+            \"wsgi.multithread\": True,\n+            \"wsgi.multiprocess\": False,\n+            \"wsgi.run_once\": False,\n+            \"REQUEST_METHOD\": request.method,\n+            \"SCRIPT_NAME\": self.script_name,\n+            \"PATH_INFO\": request.url.path,\n+            \"QUERY_STRING\": request.url.query,\n+            \"SERVER_NAME\": request.url.host,\n+            \"SERVER_PORT\": str(request.url.port),\n+            \"REMOTE_ADDR\": self.remote_addr,\n+        }\n+        for key, value in request.headers.items():\n+            key = key.upper().replace(\"-\", \"_\")\n+            if key not in (\"CONTENT_TYPE\", \"CONTENT_LENGTH\"):\n+                key = \"HTTP_\" + key\n+            environ[key] = value\n+\n+        seen_status = None\n+        seen_response_headers = None\n+        seen_exc_info = None\n+\n+        def start_response(\n+            status: str, response_headers: list, exc_info: typing.Any = None\n+        ) -> None:\n+            nonlocal seen_status, seen_response_headers, seen_exc_info\n+            seen_status = status\n+            seen_response_headers = response_headers\n+            seen_exc_info = exc_info\n+\n+        result = self.app(environ, start_response)\n+\n+        assert seen_status is not None\n+        assert seen_response_headers is not None\n+        if seen_exc_info and self.raise_app_exceptions:\n+            raise seen_exc_info[1]\n+\n+        return Response(\n+            status_code=int(seen_status.split()[0]),\n+            http_version=\"HTTP/1.1\",\n+            headers=seen_response_headers,\n+            stream=IteratorStream(chunk for chunk in result),\n+            request=request,\n+        )\n+\n+\n+class BodyStream(io.RawIOBase):",
      "comment": "If we read the request body rather than streaming it, then yes, `io.BytesIO` would work.\r\n",
      "comment_id": 364124172,
      "user": "lovelydinosaur",
      "created_at": "2020-01-08T09:02:57Z",
      "url": "https://github.com/encode/httpx/pull/735#discussion_r364124172"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 735,
      "file_path": "httpx/dispatch/wsgi.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,156 @@\n+import io\n+import typing\n+\n+from ..config import TimeoutTypes\n+from ..content_streams import IteratorStream\n+from ..models import Request, Response\n+from .base import SyncDispatcher\n+\n+\n+class WSGIDispatch(SyncDispatcher):\n+    \"\"\"\n+    A custom SyncDispatcher that handles sending requests directly to an WSGI app.\n+    The simplest way to use this functionality is to use the `app` argument.\n+\n+    ```\n+    client = httpx.Client(app=app)\n+    ```\n+\n+    Alternatively, you can setup the dispatch instance explicitly.\n+    This allows you to include any additional configuration arguments specific\n+    to the WSGIDispatch class:\n+\n+    ```\n+    dispatch = httpx.WSGIDispatch(\n+        app=app,\n+        script_name=\"/submount\",\n+        remote_addr=\"1.2.3.4\"\n+    )\n+    client = httpx.Client(dispatch=dispatch)\n+    ```\n+\n+    Arguments:\n+\n+    * `app` - The ASGI application.\n+    * `raise_app_exceptions` - Boolean indicating if exceptions in the application\n+       should be raised. Default to `True`. Can be set to `False` for use cases\n+       such as testing the content of a client 500 response.\n+    * `script_name` - The root path on which the ASGI application should be mounted.\n+    * `remote_addr` - A string indicating the client IP of incoming requests.\n+    ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        app: typing.Callable,\n+        raise_app_exceptions: bool = True,\n+        script_name: str = \"\",\n+        remote_addr: str = \"127.0.0.1\",\n+    ) -> None:\n+        self.app = app\n+        self.raise_app_exceptions = raise_app_exceptions\n+        self.script_name = script_name\n+        self.remote_addr = remote_addr\n+\n+    def send(self, request: Request, timeout: TimeoutTypes = None) -> Response:\n+        environ = {\n+            \"wsgi.version\": (1, 0),\n+            \"wsgi.url_scheme\": request.url.scheme,\n+            \"wsgi.input\": BodyStream(request.stream.__iter__()),\n+            \"wsgi.errors\": io.BytesIO(),\n+            \"wsgi.multithread\": True,\n+            \"wsgi.multiprocess\": False,\n+            \"wsgi.run_once\": False,\n+            \"REQUEST_METHOD\": request.method,\n+            \"SCRIPT_NAME\": self.script_name,\n+            \"PATH_INFO\": request.url.path,\n+            \"QUERY_STRING\": request.url.query,\n+            \"SERVER_NAME\": request.url.host,\n+            \"SERVER_PORT\": str(request.url.port),\n+            \"REMOTE_ADDR\": self.remote_addr,\n+        }\n+        for key, value in request.headers.items():\n+            key = key.upper().replace(\"-\", \"_\")\n+            if key not in (\"CONTENT_TYPE\", \"CONTENT_LENGTH\"):\n+                key = \"HTTP_\" + key\n+            environ[key] = value\n+\n+        seen_status = None\n+        seen_response_headers = None\n+        seen_exc_info = None\n+\n+        def start_response(\n+            status: str, response_headers: list, exc_info: typing.Any = None\n+        ) -> None:\n+            nonlocal seen_status, seen_response_headers, seen_exc_info\n+            seen_status = status\n+            seen_response_headers = response_headers\n+            seen_exc_info = exc_info\n+\n+        result = self.app(environ, start_response)\n+\n+        assert seen_status is not None\n+        assert seen_response_headers is not None\n+        if seen_exc_info and self.raise_app_exceptions:\n+            raise seen_exc_info[1]\n+\n+        return Response(\n+            status_code=int(seen_status.split()[0]),\n+            http_version=\"HTTP/1.1\",\n+            headers=seen_response_headers,\n+            stream=IteratorStream(chunk for chunk in result),\n+            request=request,\n+        )\n+\n+\n+class BodyStream(io.RawIOBase):",
      "comment": "Righty, I've opted for a simpler implementation, with the constraint that the request body is no longer streamed. We can always update that at a later point if we choose, but let's keep it simple if possible.",
      "comment_id": 364125356,
      "user": "lovelydinosaur",
      "created_at": "2020-01-08T09:05:58Z",
      "url": "https://github.com/encode/httpx/pull/735#discussion_r364125356"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 732,
      "file_path": "tests/models/test_requests.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,19 +21,38 @@ def test_content_length_header():\n @pytest.mark.asyncio\n async def test_url_encoded_data():\n     request = httpx.Request(\"POST\", \"http://example.org\", data={\"test\": \"123\"})\n-    content = b\"\".join([part async for part in request.stream])\n+    await request.aread()\n \n     assert request.headers[\"Content-Type\"] == \"application/x-www-form-urlencoded\"\n-    assert content == b\"test=123\"\n+    assert request.content == b\"test=123\"\n \n \n @pytest.mark.asyncio\n async def test_json_encoded_data():\n     request = httpx.Request(\"POST\", \"http://example.org\", json={\"test\": 123})\n-    content = b\"\".join([part async for part in request.stream])\n+    await request.aread()\n \n     assert request.headers[\"Content-Type\"] == \"application/json\"\n-    assert content == b'{\"test\": 123}'\n+    assert request.content == b'{\"test\": 123}'\n+\n+\n+@pytest.mark.asyncio\n+async def test_read_and_stream_data():\n+    # Ensure a request may still be streamed if it has been read.\n+    # \u00a0Needed for cases such as authentication classes that read the request body.",
      "comment": "Nit:\r\n\r\n```suggestion\r\n    # Needed for cases such as authentication classes that read the request body.\r\n```\r\n\r\nSame on the comment in the other test case below.",
      "comment_id": 363726787,
      "user": "florimondmanca",
      "created_at": "2020-01-07T12:32:33Z",
      "url": "https://github.com/encode/httpx/pull/732#discussion_r363726787"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 685,
      "file_path": "httpx/exceptions.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,6 +93,12 @@ class RedirectBodyUnavailable(RedirectError):\n     \"\"\"\n \n \n+class RequestBodyUnavailable(RedirectBodyUnavailable):\n+    \"\"\"\n+    Got a request body, but the request body is no longer available.\n+    \"\"\"",
      "comment": "Hmm\u2026 So maybe we can simply re-purpose the `RedirectBodyUnavailable` exception above, by moving it to the `StreamError` tree\u2026 Something like:\r\n\r\n```python\r\n# Stream exceptions...\r\n\r\n# ...\r\nclass RequestBodyUnavailable(StreamError):\r\n    \"\"\"\r\n    Had to send the request again but the request body was streaming, and is\r\n    no longer available.\r\n    \"\"\"\r\n```\r\n\r\nWe can (should?) address this change separately, and come back to this afterwards. I'll issue a quick PR right away to see what this would look like. :-)",
      "comment_id": 361761039,
      "user": "florimondmanca",
      "created_at": "2019-12-27T23:23:48Z",
      "url": "https://github.com/encode/httpx/pull/685#discussion_r361761039"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 685,
      "file_path": "httpx/exceptions.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,6 +93,12 @@ class RedirectBodyUnavailable(RedirectError):\n     \"\"\"\n \n \n+class RequestBodyUnavailable(RedirectBodyUnavailable):\n+    \"\"\"\n+    Got a request body, but the request body is no longer available.\n+    \"\"\"",
      "comment": "Yeah it looks  better. once the PR gets merged I will make the changes here.",
      "comment_id": 361775918,
      "user": "kousikmitra",
      "created_at": "2019-12-28T04:39:10Z",
      "url": "https://github.com/encode/httpx/pull/685#discussion_r361775918"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 685,
      "file_path": "httpx/exceptions.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,6 +93,12 @@ class RedirectBodyUnavailable(RedirectError):\n     \"\"\"\n \n \n+class RequestBodyUnavailable(RedirectBodyUnavailable):\n+    \"\"\"\n+    Got a request body, but the request body is no longer available.\n+    \"\"\"",
      "comment": "Cool! Should merge soon.\r\n\r\nOn a separate note \u2014 ideally we'd have some testing for this new behavior. Could we look at adding one along with the other `DigestAuth` tests?",
      "comment_id": 361813537,
      "user": "florimondmanca",
      "created_at": "2019-12-28T21:01:31Z",
      "url": "https://github.com/encode/httpx/pull/685#discussion_r361813537"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 685,
      "file_path": "httpx/exceptions.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,6 +93,12 @@ class RedirectBodyUnavailable(RedirectError):\n     \"\"\"\n \n \n+class RequestBodyUnavailable(RedirectBodyUnavailable):\n+    \"\"\"\n+    Got a request body, but the request body is no longer available.\n+    \"\"\"",
      "comment": "@kousikmitra #690 has landed in master \u2014 you can update this PR when ready. \ud83d\ude04 ",
      "comment_id": 362966643,
      "user": "florimondmanca",
      "created_at": "2020-01-03T21:26:51Z",
      "url": "https://github.com/encode/httpx/pull/685#discussion_r362966643"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 685,
      "file_path": "httpx/exceptions.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,6 +93,12 @@ class RedirectBodyUnavailable(RedirectError):\n     \"\"\"\n \n \n+class RequestBodyUnavailable(RedirectBodyUnavailable):\n+    \"\"\"\n+    Got a request body, but the request body is no longer available.\n+    \"\"\"",
      "comment": "@florimondmanca Merged The PR and added a test function to test the behavior. \ud83d\ude03 ",
      "comment_id": 363024216,
      "user": "kousikmitra",
      "created_at": "2020-01-04T08:47:28Z",
      "url": "https://github.com/encode/httpx/pull/685#discussion_r363024216"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 695,
      "file_path": "httpx/models.py",
      "line": 912,
      "side": "LEFT",
      "diff_hunk": "@@ -917,18 +979,15 @@ def raw(self):  # type: ignore\n         \"\"\"\n         A byte-iterator over the raw response content.\n         \"\"\"\n-        if hasattr(self, \"_raw_content\"):",
      "comment": "We can drop `_raw_content` here since we're not special casing that anymore.",
      "comment_id": 361976502,
      "user": "lovelydinosaur",
      "created_at": "2019-12-30T12:40:28Z",
      "url": "https://github.com/encode/httpx/pull/695#discussion_r361976502"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 695,
      "file_path": "httpx/models.py",
      "line": 688,
      "side": "RIGHT",
      "diff_hunk": "@@ -673,15 +679,13 @@ def __init__(\n \n         self.history = [] if history is None else list(history)\n \n-        if stream is None:\n-            self.is_closed = True\n-            self.is_stream_consumed = True\n-            self._raw_content = content or b\"\"\n-            self._elapsed = request.timer.elapsed\n-        else:\n-            self.is_closed = False\n-            self.is_stream_consumed = False\n+        self.is_closed = False\n+        self.is_stream_consumed = False\n+        if stream is not None:\n             self._raw_stream = stream\n+        else:\n+            self._raw_stream = ByteStream(body=content or b\"\")\n+            self.read()",
      "comment": "This is a little nicer now that we can use a sync `.read()` inside `__init__` rather than having to special-case `self._raw_content`.",
      "comment_id": 361976684,
      "user": "lovelydinosaur",
      "created_at": "2019-12-30T12:41:22Z",
      "url": "https://github.com/encode/httpx/pull/695#discussion_r361976684"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 695,
      "file_path": "httpx/content_streams.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,10 +76,48 @@ def get_headers(self) -> typing.Dict[str, str]:\n         content_length = str(len(self.body))\n         return {\"Content-Length\": content_length}\n \n+    def __iter__(self) -> typing.Iterator[bytes]:\n+        yield self.body\n+\n     async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n         yield self.body\n \n \n+class IteratorStream(ContentStream):\n+    \"\"\"\n+    Request content encoded as plain bytes, using an byte iterator.\n+    \"\"\"\n+\n+    def __init__(\n+        self, iterator: typing.Iterator[bytes], close_func: typing.Callable = None\n+    ) -> None:\n+        self.iterator = iterator\n+        self.close_func = close_func\n+        self.is_stream_consumed = False\n+\n+    def can_replay(self) -> bool:\n+        return False\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {\"Transfer-Encoding\": \"chunked\"}\n+\n+    def __iter__(self) -> typing.Iterator[bytes]:\n+        if self.is_stream_consumed:\n+            raise StreamConsumed()\n+        self.is_stream_consumed = True\n+        for part in self.iterator:\n+            yield part\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        raise RuntimeError(\"Attempted to call a async iterator on an sync stream.\")\n+        async for part in ():  # pragma: nocover\n+            yield b\"\"",
      "comment": "Does this have any actual runtime consequence, or is this to please linters?\r\n\r\nTurns out that we can make this work without tricks by dropping the `async` annotation\u2026\r\n\r\n```python\r\ndef __aiter__(self) -> typing.AsyncIterator[bytes]:\r\n    raise RuntimeError(\"Attempted to call a async iterator on an sync stream.\")\r\n```",
      "comment_id": 362326943,
      "user": "florimondmanca",
      "created_at": "2020-01-01T14:46:14Z",
      "url": "https://github.com/encode/httpx/pull/695#discussion_r362326943"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 695,
      "file_path": "tests/test_content_streams.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -130,3 +187,9 @@\n             b\"--+++--\\r\\n\",\n         ]\n     )\n+\n+\n+@pytest.mark.asyncio\n+async def test_invalid_argument():",
      "comment": "We don't *need* the `asyncio` marker here, do we? Possible simplification\u2026\r\n\r\n```python\r\ndef test_invalid_argument():\r\n    with pytest.raises(TypeError):\r\n        encode(123)\r\n```",
      "comment_id": 362327523,
      "user": "florimondmanca",
      "created_at": "2020-01-01T14:57:35Z",
      "url": "https://github.com/encode/httpx/pull/695#discussion_r362327523"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 706,
      "file_path": "tests/client/test_proxies.py",
      "line": 50,
      "side": "LEFT",
      "diff_hunk": "@@ -29,27 +29,6 @@ def test_proxies_parameter(proxies, expected_proxies):\n     assert len(expected_proxies) == len(client.proxies)\n \n \n-def test_proxies_has_same_properties_as_dispatch():\n-    client = httpx.AsyncClient(\n-        proxies=\"http://127.0.0.1\",\n-        verify=\"/path/to/verify\",\n-        cert=\"/path/to/cert\",\n-        trust_env=False,\n-        timeout=30,\n-    )\n-    pool = client.dispatch\n-    proxy = client.proxies[\"all\"]\n-\n-    assert isinstance(proxy, httpx.HTTPProxy)\n-\n-    for prop in [\n-        \"verify\",\n-        \"cert\",\n-        \"pool_limits\",\n-    ]:\n-        assert getattr(pool, prop) == getattr(proxy, prop)",
      "comment": "`verify` and `cert` properties no longer exist.\r\nI don't think this test case is sufficiently meaningful at this point, so dropping it. \ud83d\ude03",
      "comment_id": 362329289,
      "user": "lovelydinosaur",
      "created_at": "2020-01-01T15:31:44Z",
      "url": "https://github.com/encode/httpx/pull/706#discussion_r362329289"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 616,
      "file_path": "httpx/dispatch/connection.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,13 +141,21 @@ def __init__(\n             # HTTP request. Don't try to upgrade to TLS in this case.\n             pass\n \n+        self.set_open_connection(http_version, socket=socket, on_release=on_release)\n+\n+    def set_open_connection(\n+        self,\n+        http_version: str,\n+        socket: BaseSocketStream,\n+        on_release: typing.Optional[typing.Callable],\n+    ) -> None:\n         if http_version == \"HTTP/2\":\n-            self.h2_connection = HTTP2Connection(\n+            self.open_connection = HTTP2Connection(",
      "comment": "This is the only place where we reference `HTTP2Connection` in this file, so we'll be able to lazily-import it here, and fail if `h2` isn't installed. :+1:",
      "comment_id": 355125337,
      "user": "florimondmanca",
      "created_at": "2019-12-07T14:46:10Z",
      "url": "https://github.com/encode/httpx/pull/616#discussion_r355125337"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 616,
      "file_path": "httpx/dispatch/connection.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,13 +88,7 @@ def __init__(\n         http_version = stream.get_http_version()\n         logger.trace(f\"connected http_version={http_version!r}\")\n \n-        if http_version == \"HTTP/2\":\n-            self.h2_connection = HTTP2Connection(\n-                stream, backend=self.backend, on_release=on_release\n-            )\n-        else:\n-            assert http_version == \"HTTP/1.1\"\n-            self.h11_connection = HTTP11Connection(stream, on_release=on_release)\n+        self.set_open_connection(http_version, socket=stream, on_release=on_release)",
      "comment": "Note that we've got an outstanding `stream` vs `socket` instance here (following up #601). Wondering if should push the renaming further with `.open_tcp_socket()` and `.open_uds_socket()` on the `ConcurrencyBackend` interface?",
      "comment_id": 355125412,
      "user": "florimondmanca",
      "created_at": "2019-12-07T14:47:48Z",
      "url": "https://github.com/encode/httpx/pull/616#discussion_r355125412"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 692,
      "file_path": "httpx/models.py",
      "line": 686,
      "side": "RIGHT",
      "diff_hunk": "@@ -683,11 +683,25 @@ def __init__(\n             self.is_closed = True\n             self.is_stream_consumed = True\n             self._raw_content = content or b\"\"\n+            self._elapsed = datetime.timedelta(0)",
      "comment": "Shouldn't this be `request.timer.elapsed`? Otherwise we don't account for the time spent receiving the response headers in the raw-bytes case.",
      "comment_id": 361858002,
      "user": "florimondmanca",
      "created_at": "2019-12-29T15:51:07Z",
      "url": "https://github.com/encode/httpx/pull/692#discussion_r361858002"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 692,
      "file_path": "httpx/models.py",
      "line": 686,
      "side": "RIGHT",
      "diff_hunk": "@@ -683,11 +683,25 @@ def __init__(\n             self.is_closed = True\n             self.is_stream_consumed = True\n             self._raw_content = content or b\"\"\n+            self._elapsed = datetime.timedelta(0)",
      "comment": "Ah that'd be better yup. As it *happens* we'll always use `stream=...` for actual network responses, it's really only the \"mock response instance\" case that we use `content=...` for, but yes it makes sense to account for the time properly in that case too.",
      "comment_id": 361860550,
      "user": "lovelydinosaur",
      "created_at": "2019-12-29T16:35:35Z",
      "url": "https://github.com/encode/httpx/pull/692#discussion_r361860550"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 693,
      "file_path": "httpx/dispatch/http2.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,32 +39,28 @@ def __init__(\n         self.streams = {}  # type: typing.Dict[int, HTTP2Stream]\n         self.events = {}  # type: typing.Dict[int, typing.List[h2.events.Event]]\n \n-        self.init_started = False\n+        self.sent_connection_init = False\n \n     @property\n     def is_http2(self) -> bool:\n         return True\n \n     @property\n-    def init_complete(self) -> BaseEvent:\n+    def init_lock(self) -> BaseLock:\n         # We do this lazily, to make sure backend autodetection always\n         # runs within an async context.\n-        if not hasattr(self, \"_initialization_complete\"):\n-            self._initialization_complete = self.backend.create_event()\n-        return self._initialization_complete\n+        if not hasattr(self, \"_initialization_lock\"):\n+            self._initialization_lock = self.backend.create_lock()\n+        return self._initialization_lock\n \n     async def send(self, request: Request, timeout: Timeout = None) -> Response:\n         timeout = Timeout() if timeout is None else timeout\n \n-        if not self.init_started:\n-            # The very first stream is responsible for initiating the connection.\n-            self.init_started = True\n-            await self.send_connection_init(timeout)\n-            stream_id = self.state.get_next_available_stream_id()\n-            self.init_complete.set()\n-        else:\n-            # All other streams need to wait until the connection is established.\n-            await self.init_complete.wait()\n+        async with self.init_lock:\n+            if not self.sent_connection_init:\n+                # The very first stream is responsible for initiating the connection.\n+                await self.send_connection_init(timeout)\n+                self.sent_connection_init = True\n             stream_id = self.state.get_next_available_stream_id()",
      "comment": "Took me some time to realise this works as expected, but it does seem to!",
      "comment_id": 361858491,
      "user": "florimondmanca",
      "created_at": "2019-12-29T16:00:44Z",
      "url": "https://github.com/encode/httpx/pull/693#discussion_r361858491"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 677,
      "file_path": "tests/client/test_cookies.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,21 +101,21 @@ class MockDispatch(Dispatcher):\n         discard=True,\n         comment=None,\n         comment_url=None,\n-        rest={\"HttpOnly\": None},\n+        rest={\"HttpOnly\": \"\"},\n         rfc2109=False,\n     )\n     cookies.set_cookie(cookie)\n \n     client = Client(dispatch=MockDispatch())\n-    client.cookies = cookies\n+    client.cookies = cookies  # type: ignore",
      "comment": "mypy doesn't yet support setters that accept arguments of a different type than what is returned by the getter. The official recommandation is to `# type: ignore` for now. See: https://github.com/python/mypy/issues/3004",
      "comment_id": 360665078,
      "user": "florimondmanca",
      "created_at": "2019-12-21T19:50:27Z",
      "url": "https://github.com/encode/httpx/pull/677#discussion_r360665078"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 677,
      "file_path": "tests/client/test_cookies.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,21 +101,21 @@ class MockDispatch(Dispatcher):\n         discard=True,\n         comment=None,\n         comment_url=None,\n-        rest={\"HttpOnly\": None},\n+        rest={\"HttpOnly\": \"\"},\n         rfc2109=False,\n     )\n     cookies.set_cookie(cookie)\n \n     client = Client(dispatch=MockDispatch())\n-    client.cookies = cookies\n+    client.cookies = cookies  # type: ignore",
      "comment": "Hrm. Well, it *is* a strange usage. Got me thinking that maybe we just shouldn\u2019t be doing that in the first place...\r\n\r\nInstead, we could enforce this style:\r\n\r\n`client.cookies = httpx.Cookies(...)`\r\n\r\nThat\u2019s possibly less surprising than setting the cookies to a dict, but having it return a Cookies instance.\r\n\r\nWe would probably want to hard check the type.\r\n\r\nObvs same would apply to the other setters too.\r\n\r\nThoughts?",
      "comment_id": 360668301,
      "user": "lovelydinosaur",
      "created_at": "2019-12-21T21:10:32Z",
      "url": "https://github.com/encode/httpx/pull/677#discussion_r360668301"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 665,
      "file_path": "tests/client/test_auth.py",
      "line": 198,
      "side": "RIGHT",
      "diff_hunk": "@@ -179,34 +180,37 @@ def auth(request):\n     }\n \n \n-def test_auth_hidden_url():\n+def test_auth_hidden_url() -> None:\n     url = \"http://example-username:example-password@example.org/\"\n     expected = \"URL('http://example-username:[secure]@example.org/')\"\n     assert url == URL(url)\n     assert expected == repr(URL(url))\n \n \n @pytest.mark.asyncio\n-async def test_auth_hidden_header():\n+async def test_auth_hidden_header() -> None:\n     url = \"https://example.org/\"\n     auth = (\"example-username\", \"example-password\")\n \n     client = Client(dispatch=MockDispatch())\n     response = await client.get(url, auth=auth)\n \n-    assert \"'authorization': '[secure]'\" in str(response.request.headers)\n+    request = typing.cast(Request, response.request)",
      "comment": "This might prove to be bad UX for our users: `response.request` is *almost always* set, *except* for some tests where *we* create a `Response` without a request. May look into those situations and then turn on `request` as non-optional on `Response`.",
      "comment_id": 360601429,
      "user": "florimondmanca",
      "created_at": "2019-12-20T22:55:26Z",
      "url": "https://github.com/encode/httpx/pull/665#discussion_r360601429"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 665,
      "file_path": "tests/client/test_auth.py",
      "line": 198,
      "side": "RIGHT",
      "diff_hunk": "@@ -179,34 +180,37 @@ def auth(request):\n     }\n \n \n-def test_auth_hidden_url():\n+def test_auth_hidden_url() -> None:\n     url = \"http://example-username:example-password@example.org/\"\n     expected = \"URL('http://example-username:[secure]@example.org/')\"\n     assert url == URL(url)\n     assert expected == repr(URL(url))\n \n \n @pytest.mark.asyncio\n-async def test_auth_hidden_header():\n+async def test_auth_hidden_header() -> None:\n     url = \"https://example.org/\"\n     auth = (\"example-username\", \"example-password\")\n \n     client = Client(dispatch=MockDispatch())\n     response = await client.get(url, auth=auth)\n \n-    assert \"'authorization': '[secure]'\" in str(response.request.headers)\n+    request = typing.cast(Request, response.request)",
      "comment": "Good call. Let's defer this until #666 is in, and we can drop the cast.",
      "comment_id": 360651434,
      "user": "lovelydinosaur",
      "created_at": "2019-12-21T14:19:52Z",
      "url": "https://github.com/encode/httpx/pull/665#discussion_r360651434"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 664,
      "file_path": "tests/conftest.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,6 +32,16 @@\n }\n \n \n+@pytest.fixture(\n+    params=[\n+        pytest.param(\"asyncio\", marks=pytest.mark.asyncio),\n+        pytest.param(\"trio\", marks=pytest.mark.trio),\n+    ]\n+)\n+def async_environment(request) -> str:",
      "comment": "Should we have a small docstring here, noting usage, and that this is equivelent to having a pair of tests, wrapped wth `@pytest.mark.asyncio` and `@pytest.mark.trio`. Or perhaps not neccessary?",
      "comment_id": 360651579,
      "user": "lovelydinosaur",
      "created_at": "2019-12-21T14:23:03Z",
      "url": "https://github.com/encode/httpx/pull/664#discussion_r360651579"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/client.py",
      "line": 502,
      "side": "RIGHT",
      "diff_hunk": "@@ -499,10 +499,10 @@ def build_redirect_request(self, request: Request, response: Response) -> Reques\n         method = self.redirect_method(request, response)\n         url = self.redirect_url(request, response)\n         headers = self.redirect_headers(request, url, method)\n-        content = self.redirect_content(request, method)\n+        stream = self.redirect_content(request, method)",
      "comment": "Strange mismatch here between stream/content, isn\u2019t it?",
      "comment_id": 359553985,
      "user": "florimondmanca",
      "created_at": "2019-12-18T20:29:18Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359553985"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/dispatch/asgi.py",
      "line": 80,
      "side": "LEFT",
      "diff_hunk": "@@ -77,13 +77,20 @@ def __init__(\n         status_code = None\n         headers = None\n         body_parts = []\n-        request_stream = request.stream()",
      "comment": "How about just changing this into\u2026?\r\n\r\n```python\r\nrequest_body_chunks = request.stream.__aiter__()\r\n```",
      "comment_id": 359556832,
      "user": "florimondmanca",
      "created_at": "2019-12-18T20:36:34Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359556832"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/dispatch/proxy_http.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,8 +167,9 @@ def build_auth_header(self, username: str, password: str) -> str:\n                 response=proxy_response,\n             )\n         else:\n-            proxy_response.on_close = None\n-            await proxy_response.read()\n+            # Hack to ingest the response, without closing it.\n+            async for chunk in proxy_response._raw_stream:\n+                pass",
      "comment": "It's a hack, yes \ud83d\ude15 But it seems there's no public interface on `Response` that allows us to do this. Why is it important to not close the response in the first place? We don't do anything with it afterwards. Would it close the connection?",
      "comment_id": 359558522,
      "user": "florimondmanca",
      "created_at": "2019-12-18T20:41:02Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359558522"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/dispatch/http2.py",
      "line": 219,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,13 +210,13 @@ def __init__(self, stream_id: int, connection: HTTP2Connection) -> None:\n \n         # Receive the response.\n         status_code, headers = await self.receive_response(timeout)\n-        content = self.body_iter(timeout)\n+        stream = ResponseStream(iterator=self.body_iter(timeout), close=self.close)\n+\n         return Response(\n             status_code=status_code,\n             http_version=\"HTTP/2\",\n             headers=headers,\n-            content=content,\n-            on_close=self.close,\n+            content=stream,",
      "comment": "Wouldn't we want this to be `Response(stream=...)`?",
      "comment_id": 359559254,
      "user": "florimondmanca",
      "created_at": "2019-12-18T20:42:58Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359559254"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/models.py",
      "line": 647,
      "side": "RIGHT",
      "diff_hunk": "@@ -646,11 +644,7 @@ def __repr__(self) -> str:\n         \"\"\"\n         Read and return the request content.\n         \"\"\"\n-        return await self.content.aread()\n-\n-    async def stream(self) -> typing.AsyncIterator[bytes]:\n-        async for part in self.content:\n-            yield part\n+        return await self.stream.aread()",
      "comment": "Not a direct consequence of this PR, but should this method on the request really be called `.aread()`? As in: will we need a sync `def read(self):` for sync support?",
      "comment_id": 359559963,
      "user": "florimondmanca",
      "created_at": "2019-12-18T20:44:54Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359559963"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/models.py",
      "line": 657,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,8 +654,7 @@ def __init__(\n         *,\n         http_version: str = None,\n         headers: HeaderTypes = None,\n-        content: ResponseContent = None,\n-        on_close: typing.Callable = None,\n+        content: typing.Union[bytes, Stream] = None,",
      "comment": "`HTTP11Connection` and `HTTP2Connection` pass a `Stream` instance, but do we every pass raw `bytes` anywhere else in the code base? I'm thinking maybe this can be scoped down to `stream: Stream = None`.",
      "comment_id": 359561208,
      "user": "florimondmanca",
      "created_at": "2019-12-18T20:48:08Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359561208"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/models.py",
      "line": 657,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,8 +654,7 @@ def __init__(\n         *,\n         http_version: str = None,\n         headers: HeaderTypes = None,\n-        content: ResponseContent = None,\n-        on_close: typing.Callable = None,\n+        content: typing.Union[bytes, Stream] = None,",
      "comment": "See also your own comment in the PR description: \"Responses accept a stream argument\".",
      "comment_id": 359562178,
      "user": "florimondmanca",
      "created_at": "2019-12-18T20:50:27Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359562178"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/models.py",
      "line": 657,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,8 +654,7 @@ def __init__(\n         *,\n         http_version: str = None,\n         headers: HeaderTypes = None,\n-        content: ResponseContent = None,\n-        on_close: typing.Callable = None,\n+        content: typing.Union[bytes, Stream] = None,",
      "comment": "So, right now we're only ever passing `content=<bytes>` in the test cases.\r\n\r\nWe may want to have seperate `content: bytes = None` and `stream: Stream = None` arguments. Instantiating `Response` instances isn't something that users will typically do, but we probably do want it to be doable, and we probably *don't* want to force users to pass a stream instance for the simple case.",
      "comment_id": 359818452,
      "user": "lovelydinosaur",
      "created_at": "2019-12-19T11:40:44Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359818452"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/models.py",
      "line": 657,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,8 +654,7 @@ def __init__(\n         *,\n         http_version: str = None,\n         headers: HeaderTypes = None,\n-        content: ResponseContent = None,\n-        on_close: typing.Callable = None,\n+        content: typing.Union[bytes, Stream] = None,",
      "comment": "Once we have a sync interface on the `Response` we can have a more graceful implementation here, too, along these lines...\r\n\r\n```python\r\nif stream is None:\r\n    # When a Response is directly instantiated with `content=<bytes or None>` we can read/close the response immediately.\r\n    self.stream = ByteStream(content)\r\n    self.read()\r\nelse:\r\n    # This is the standard case. Dispatchers pass a `stream=<Stream>` argument to the response.\r\n    self.stream = stream\r\n```\r\n\r\nAnd drop the `_raw_content` special casing that we currently have in a few places.",
      "comment_id": 359819990,
      "user": "lovelydinosaur",
      "created_at": "2019-12-19T11:45:16Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359819990"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/models.py",
      "line": 647,
      "side": "RIGHT",
      "diff_hunk": "@@ -646,11 +644,7 @@ def __repr__(self) -> str:\n         \"\"\"\n         Read and return the request content.\n         \"\"\"\n-        return await self.content.aread()\n-\n-    async def stream(self) -> typing.AsyncIterator[bytes]:\n-        async for part in self.content:\n-            yield part\n+        return await self.stream.aread()",
      "comment": "It should yes. It's also not *actually* clear if we should expose this method at all.",
      "comment_id": 359822154,
      "user": "lovelydinosaur",
      "created_at": "2019-12-19T11:51:38Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359822154"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/dispatch/proxy_http.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,8 +167,9 @@ def build_auth_header(self, username: str, password: str) -> str:\n                 response=proxy_response,\n             )\n         else:\n-            proxy_response.on_close = None\n-            await proxy_response.read()\n+            # Hack to ingest the response, without closing it.\n+            async for chunk in proxy_response._raw_stream:\n+                pass",
      "comment": "Actually this point in the code surprised me too. Yes I think we're making sure that we maintain the connection. However I *actually* think that this is highlighting an issue here. I *think* that we probably actually want an explicit \"proxy being established state\" on the HTTP Connection, that will play into the stuff I was starting to think about on https://github.com/encode/httpx/pull/624. It wouldn't at all surprise me if we have some buggy behavior aroung this, such as later maintaining proxy connections that ought to have become closed.",
      "comment_id": 359823694,
      "user": "lovelydinosaur",
      "created_at": "2019-12-19T11:55:46Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359823694"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/models.py",
      "line": 657,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,8 +654,7 @@ def __init__(\n         *,\n         http_version: str = None,\n         headers: HeaderTypes = None,\n-        content: ResponseContent = None,\n-        on_close: typing.Callable = None,\n+        content: typing.Union[bytes, Stream] = None,",
      "comment": "Actually we happen to be passing `content=...` in the ASGI case at the moment, but only for convience. We could easily change that around to passing a concrete stream instance.",
      "comment_id": 359834092,
      "user": "lovelydinosaur",
      "created_at": "2019-12-19T12:24:37Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359834092"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/models.py",
      "line": 647,
      "side": "RIGHT",
      "diff_hunk": "@@ -646,11 +644,7 @@ def __repr__(self) -> str:\n         \"\"\"\n         Read and return the request content.\n         \"\"\"\n-        return await self.content.aread()\n-\n-    async def stream(self) -> typing.AsyncIterator[bytes]:\n-        async for part in self.content:\n-            yield part\n+        return await self.stream.aread()",
      "comment": "Well, I'm not sure we actually. Do we use it anywhere internally (in the package or in the tests) already?",
      "comment_id": 359853359,
      "user": "florimondmanca",
      "created_at": "2019-12-19T13:16:17Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359853359"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/streams.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,297 @@\n+import binascii\n+import mimetypes\n+import os\n+import typing\n+from io import BytesIO\n+from json import dumps as json_dumps\n+from pathlib import Path\n+from urllib.parse import urlencode\n+\n+from .utils import format_form_param\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class Stream:\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aclose(self) -> None:\n+        pass\n+\n+    async def aread(self) -> bytes:\n+        return b\"\".join([part async for part in self])\n+\n+\n+class ResponseStream(Stream):\n+    def __init__(self, iterator: typing.AsyncIterator[bytes], close: typing.Callable):\n+        self.iterator = iterator\n+        self.close_func = close\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        async for chunk in self.iterator:\n+            yield chunk\n+\n+    async def aclose(self) -> None:\n+        await self.close_func()\n+\n+\n+class RequestStream(Stream):\n+    \"\"\"\n+    Base class for streaming request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        \"\"\"\n+        Return a dictionary of request headers that are implied by the encoding.\n+        \"\"\"\n+        return {}\n+\n+    def can_replay(self) -> bool:\n+        \"\"\"\n+        Return `True` if `__aiter__` can be called multiple times.\n+\n+        We need this in order to determine if we can re-issue a request body\n+        when we receive a redirect response.\n+        \"\"\"\n+        return True\n+\n+\n+class BytesRequestStream(RequestStream):\n+    \"\"\"\n+    Request content encoded as plain bytes.\n+    \"\"\"\n+\n+    def __init__(self, body: typing.Union[str, bytes]) -> None:\n+        self.body = body.encode(\"utf-8\") if isinstance(body, str) else body\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        return {\"Content-Length\": content_length}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class IteratorRequestStream(RequestStream):\n+    \"\"\"\n+    Request content encoded as plain bytes, using an async byte iterator.\n+    \"\"\"\n+\n+    def __init__(self, aiterator: typing.AsyncIterator[bytes]) -> None:\n+        self.aiterator = aiterator\n+\n+    def can_replay(self) -> bool:\n+        return False\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {\"Transfer-Encoding\": \"chunked\"}",
      "comment": "Is `Transfer-Encoding` actually a valid/actionable request header? The [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding) present it as a response-only header. \ud83e\udd14 \r\n\r\nEven then, we're not making sure that the parts in the `aiterator` are separated with `\\r\\n`, are we?\r\n\r\n(Not directly related to this PR, we probably were doing this before.)",
      "comment_id": 359856785,
      "user": "florimondmanca",
      "created_at": "2019-12-19T13:24:50Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359856785"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "tests/models/test_responses.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -190,7 +190,7 @@ def test_response_force_encoding():\n \n @pytest.mark.asyncio\n async def test_streaming_response():\n-    response = httpx.Response(200, content=async_streaming_body())\n+    response = httpx.Response(200, stream=async_streaming_body())",
      "comment": "This *works*, but it isn't actually valid from a type hint point of view, correct? Async generators are missing the `.aread()` method.\r\n\r\n(Albeit tedious, I tend to be in favor of type-hinting/type-checking tests. Helps catch this kind of minor inconsistency as well as see how users will actually interact with our code *including type hints*.)",
      "comment_id": 359862603,
      "user": "florimondmanca",
      "created_at": "2019-12-19T13:38:08Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359862603"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/streams.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,297 @@\n+import binascii\n+import mimetypes\n+import os\n+import typing\n+from io import BytesIO\n+from json import dumps as json_dumps\n+from pathlib import Path\n+from urllib.parse import urlencode\n+\n+from .utils import format_form_param\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class Stream:\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aclose(self) -> None:\n+        pass\n+\n+    async def aread(self) -> bytes:\n+        return b\"\".join([part async for part in self])",
      "comment": "We never actually use this method on responses (we use `async for chunk in raw_stream` there), and it's not public for users anyway.\r\n\r\nSo should this be moved to `RequestStream`?\r\n\r\nThis would mean `Stream` ends up being equivalent to `AsyncIterator[bytes]` \u2014 which sounds good to me \u2014 and would resolve a few type hint issues (we don't currently catch) in our tests.",
      "comment_id": 359864382,
      "user": "florimondmanca",
      "created_at": "2019-12-19T13:42:00Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359864382"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "tests/models/test_responses.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -190,7 +190,7 @@ def test_response_force_encoding():\n \n @pytest.mark.asyncio\n async def test_streaming_response():\n-    response = httpx.Response(200, content=async_streaming_body())\n+    response = httpx.Response(200, stream=async_streaming_body())",
      "comment": "> I tend to be in favor of type-hinting/type-checking tests.\r\n\r\nYeah, I've come to the view that it'd *probably* be a good plan for us, since there's *loads* of stuff that it would help catch.\r\n\r\n(I'd need to see how things look in order to take a more informed view on it, but it *feels* like it'd be a good thing to be doing.)",
      "comment_id": 359879722,
      "user": "lovelydinosaur",
      "created_at": "2019-12-19T14:15:00Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359879722"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/streams.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,297 @@\n+import binascii\n+import mimetypes\n+import os\n+import typing\n+from io import BytesIO\n+from json import dumps as json_dumps\n+from pathlib import Path\n+from urllib.parse import urlencode\n+\n+from .utils import format_form_param\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class Stream:\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aclose(self) -> None:\n+        pass\n+\n+    async def aread(self) -> bytes:\n+        return b\"\".join([part async for part in self])\n+\n+\n+class ResponseStream(Stream):\n+    def __init__(self, iterator: typing.AsyncIterator[bytes], close: typing.Callable):\n+        self.iterator = iterator\n+        self.close_func = close\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        async for chunk in self.iterator:\n+            yield chunk\n+\n+    async def aclose(self) -> None:\n+        await self.close_func()\n+\n+\n+class RequestStream(Stream):\n+    \"\"\"\n+    Base class for streaming request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        \"\"\"\n+        Return a dictionary of request headers that are implied by the encoding.\n+        \"\"\"\n+        return {}\n+\n+    def can_replay(self) -> bool:\n+        \"\"\"\n+        Return `True` if `__aiter__` can be called multiple times.\n+\n+        We need this in order to determine if we can re-issue a request body\n+        when we receive a redirect response.\n+        \"\"\"\n+        return True\n+\n+\n+class BytesRequestStream(RequestStream):\n+    \"\"\"\n+    Request content encoded as plain bytes.\n+    \"\"\"\n+\n+    def __init__(self, body: typing.Union[str, bytes]) -> None:\n+        self.body = body.encode(\"utf-8\") if isinstance(body, str) else body\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        return {\"Content-Length\": content_length}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class IteratorRequestStream(RequestStream):\n+    \"\"\"\n+    Request content encoded as plain bytes, using an async byte iterator.\n+    \"\"\"\n+\n+    def __init__(self, aiterator: typing.AsyncIterator[bytes]) -> None:\n+        self.aiterator = aiterator\n+\n+    def can_replay(self) -> bool:\n+        return False\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {\"Transfer-Encoding\": \"chunked\"}",
      "comment": "Not sure why they list it as response only, since it's required for streaming unknown-length request bodies too. Wrt. the framing, `h11` has us covered... https://h11.readthedocs.io/en/latest/api.html#message-body-framing-content-length-and-all-that",
      "comment_id": 359882869,
      "user": "lovelydinosaur",
      "created_at": "2019-12-19T14:20:58Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r359882869"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "httpx/content_streams.py",
      "line": 263,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,283 @@\n+import binascii\n+import mimetypes\n+import os\n+import typing\n+from io import BytesIO\n+from json import dumps as json_dumps\n+from pathlib import Path\n+from urllib.parse import urlencode\n+\n+from .utils import format_form_param\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class ContentStream:\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        \"\"\"\n+        Return a dictionary of headers that are implied by the encoding.\n+        \"\"\"\n+        return {}\n+\n+    def can_replay(self) -> bool:\n+        \"\"\"\n+        Return `True` if `__aiter__` can be called multiple times.\n+\n+        We need this in cases such determining if we can re-issue a request\n+        body when we receive a redirect response.\n+        \"\"\"\n+        return True\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aclose(self) -> None:\n+        pass\n+\n+\n+class ByteStream(ContentStream):\n+    \"\"\"\n+    Request content encoded as plain bytes.\n+    \"\"\"\n+\n+    def __init__(self, body: typing.Union[str, bytes]) -> None:\n+        self.body = body.encode(\"utf-8\") if isinstance(body, str) else body\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        if not self.body:\n+            return {}\n+        content_length = str(len(self.body))\n+        return {\"Content-Length\": content_length}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class AsyncIteratorStream(ContentStream):\n+    \"\"\"\n+    Request content encoded as plain bytes, using an async byte iterator.\n+    \"\"\"\n+\n+    def __init__(\n+        self, aiterator: typing.AsyncIterator[bytes], close_func: typing.Callable = None\n+    ) -> None:\n+        self.aiterator = aiterator\n+        self.close_func = close_func\n+\n+    def can_replay(self) -> bool:\n+        return False\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {\"Transfer-Encoding\": \"chunked\"}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        async for part in self.aiterator:\n+            yield part\n+\n+    async def aclose(self) -> None:\n+        if self.close_func is not None:\n+            await self.close_func()\n+\n+\n+class JSONStream(ContentStream):\n+    \"\"\"\n+    Request content encoded as JSON.\n+    \"\"\"\n+\n+    def __init__(self, json: typing.Any) -> None:\n+        self.body = json_dumps(json).encode(\"utf-8\")\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = \"application/json\"\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class URLEncodedStream(ContentStream):\n+    \"\"\"\n+    Request content as URL encoded form data.\n+    \"\"\"\n+\n+    def __init__(self, data: dict) -> None:\n+        self.body = urlencode(data, doseq=True).encode(\"utf-8\")\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = \"application/x-www-form-urlencoded\"\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class MultipartStream(ContentStream):\n+    \"\"\"\n+    Request content as multipart encoded form data.\n+    \"\"\"\n+\n+    class DataField:\n+        \"\"\"\n+        A single form field item, within a multipart form field.\n+        \"\"\"\n+\n+        def __init__(self, name: str, value: typing.Union[str, bytes]) -> None:\n+            if not isinstance(name, str):\n+                raise TypeError(\"Invalid type for name. Expected str.\")\n+            if not isinstance(value, (str, bytes)):\n+                raise TypeError(\"Invalid type for value. Expected str or bytes.\")\n+            self.name = name\n+            self.value = value\n+\n+        def render_headers(self) -> bytes:\n+            name = format_form_param(\"name\", self.name)\n+            return b\"\".join([b\"Content-Disposition: form-data; \", name, b\"\\r\\n\\r\\n\"])\n+\n+        def render_data(self) -> bytes:\n+            return (\n+                self.value\n+                if isinstance(self.value, bytes)\n+                else self.value.encode(\"utf-8\")\n+            )\n+\n+    class FileField:\n+        \"\"\"\n+        A single file field item, within a multipart form field.\n+        \"\"\"\n+\n+        def __init__(\n+            self, name: str, value: typing.Union[typing.IO[typing.AnyStr], tuple]\n+        ) -> None:\n+            self.name = name\n+            if not isinstance(value, tuple):\n+                self.filename = Path(str(getattr(value, \"name\", \"upload\"))).name\n+                self.file = (\n+                    value\n+                )  # type: typing.Union[typing.IO[str], typing.IO[bytes]]\n+                self.content_type = self.guess_content_type()\n+            else:\n+                self.filename = value[0]\n+                self.file = value[1]\n+                self.content_type = (\n+                    value[2] if len(value) > 2 else self.guess_content_type()\n+                )\n+\n+        def guess_content_type(self) -> typing.Optional[str]:\n+            if self.filename:\n+                return (\n+                    mimetypes.guess_type(self.filename)[0] or \"application/octet-stream\"\n+                )\n+            else:\n+                return None\n+\n+        def render_headers(self) -> bytes:\n+            parts = [\n+                b\"Content-Disposition: form-data; \",\n+                format_form_param(\"name\", self.name),\n+            ]\n+            if self.filename:\n+                filename = format_form_param(\"filename\", self.filename)\n+                parts.extend([b\"; \", filename])\n+            if self.content_type is not None:\n+                content_type = self.content_type.encode()\n+                parts.extend([b\"\\r\\nContent-Type: \", content_type])\n+            parts.append(b\"\\r\\n\\r\\n\")\n+            return b\"\".join(parts)\n+\n+        def render_data(self) -> bytes:\n+            if isinstance(self.file, str):\n+                content = self.file\n+            else:\n+                content = self.file.read()\n+            return content.encode(\"utf-8\") if isinstance(content, str) else content\n+\n+    def __init__(self, data: dict, files: dict, boundary: bytes = None) -> None:\n+        body = BytesIO()\n+        if boundary is None:\n+            boundary = binascii.hexlify(os.urandom(16))\n+\n+        for field in self.iter_fields(data, files):\n+            body.write(b\"--%s\\r\\n\" % boundary)\n+            body.write(field.render_headers())\n+            body.write(field.render_data())\n+            body.write(b\"\\r\\n\")\n+\n+        body.write(b\"--%s--\\r\\n\" % boundary)\n+\n+        self.content_type = \"multipart/form-data; boundary=%s\" % boundary.decode(\n+            \"ascii\"\n+        )\n+        self.body = body.getvalue()\n+\n+    def iter_fields(\n+        self, data: dict, files: dict\n+    ) -> typing.Iterator[typing.Union[\"FileField\", \"DataField\"]]:\n+        for name, value in data.items():\n+            if isinstance(value, (list, dict)):\n+                for item in value:\n+                    yield self.DataField(name=name, value=item)\n+            else:\n+                yield self.DataField(name=name, value=value)\n+\n+        for name, value in files.items():\n+            yield self.FileField(name=name, value=value)\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = self.content_type\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+def encode(\n+    data: RequestData = None,\n+    files: RequestFiles = None,\n+    json: typing.Any = None,\n+    boundary: bytes = None,\n+) -> ContentStream:\n+    \"\"\"\n+    Handles encoding the given `data`, `files`, and `json`, returning\n+    a `ContentStream` implementation which provides a byte iterator onto\n+    the content, as well as `.is_rewindable()` and `.get_headers()` interfaces.",
      "comment": "Small inconsistency on `.is_rewindable()` here. I think slimming this down to the following is sufficient:\r\n\r\n```\r\n    Handles encoding the given `data`, `files`, and `json`, returning\r\n    a `ContentStream` implementation.\r\n```",
      "comment_id": 360357582,
      "user": "florimondmanca",
      "created_at": "2019-12-20T12:45:19Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r360357582"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "tests/test_decoders.py",
      "line": 140,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,7 +137,7 @@ def test_decoding_errors(header_value):\n         for chunk in data:\n             yield chunk\n \n-    response = httpx.Response(200, content=iterator())\n+    response = httpx.Response(200, stream=iterator())",
      "comment": "Strictly speaking these would need to be `stream=AsyncIteratorStream(iterator())`, correct?\r\n\r\nI'd be in favor of making that change, since we're otherwise setting false expectations that `stream=` accepts async generators when it actually doesn't (it just so happens to work because responses don't call into `.get_headers()` or `.can_replay()`).",
      "comment_id": 360360625,
      "user": "florimondmanca",
      "created_at": "2019-12-20T12:54:23Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r360360625"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 648,
      "file_path": "tests/test_decoders.py",
      "line": 140,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,7 +137,7 @@ def test_decoding_errors(header_value):\n         for chunk in data:\n             yield chunk\n \n-    response = httpx.Response(200, content=iterator())\n+    response = httpx.Response(200, stream=iterator())",
      "comment": "100% yes! I\u2019d missed these - thanks for the catch!",
      "comment_id": 360415974,
      "user": "lovelydinosaur",
      "created_at": "2019-12-20T15:16:36Z",
      "url": "https://github.com/encode/httpx/pull/648#discussion_r360415974"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 628,
      "file_path": "httpx/dispatch/http2.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -172,15 +194,9 @@ def is_connection_dropped(self) -> bool:\n \n \n class HTTP2Stream:\n-    def __init__(\n-        self,\n-        stream_id: int,\n-        connection: HTTP2Connection,\n-        state: h2.connection.H2Connection,\n-    ) -> None:\n+    def __init__(self, stream_id: int, connection: HTTP2Connection,) -> None:",
      "comment": "Formatting nit (I've already had these, not sure why Black doesn't reformat them):\r\n\r\n```suggestion\r\n    def __init__(self, stream_id: int, connection: HTTP2Connection) -> None:\r\n```",
      "comment_id": 357013303,
      "user": "florimondmanca",
      "created_at": "2019-12-12T08:32:42Z",
      "url": "https://github.com/encode/httpx/pull/628#discussion_r357013303"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 628,
      "file_path": "httpx/dispatch/http2.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -172,15 +194,9 @@ def is_connection_dropped(self) -> bool:\n \n \n class HTTP2Stream:\n-    def __init__(\n-        self,\n-        stream_id: int,\n-        connection: HTTP2Connection,\n-        state: h2.connection.H2Connection,\n-    ) -> None:\n+    def __init__(self, stream_id: int, connection: HTTP2Connection,) -> None:",
      "comment": "https://github.com/psf/black#trailing-commas was changed recently, I believe https://github.com/psf/black/pull/826 was the ~culprit~ responsible PR. There appears to be a follow-up PR https://github.com/psf/black/pull/1164 to remedy it.",
      "comment_id": 359999162,
      "user": "StephenBrown2",
      "created_at": "2019-12-19T18:15:57Z",
      "url": "https://github.com/encode/httpx/pull/628#discussion_r359999162"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 636,
      "file_path": "httpx/content.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,162 @@\n+import typing\n+from json import dumps as json_dumps\n+from urllib.parse import urlencode\n+\n+from .multipart import multipart_encode\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class RequestContent:\n+    \"\"\"\n+    Base class for request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {}\n+\n+    def can_rewind(self) -> bool:\n+        return True\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aread(self) -> bytes:\n+        return b\"\".join([part async for part in self])\n+\n+\n+class BytesRequestContent(RequestContent):\n+    \"\"\"\n+    Request content encoded as plain bytes.\n+    \"\"\"\n+\n+    def __init__(self, body: typing.Union[str, bytes]) -> None:\n+        self.body = body.encode(\"utf-8\") if isinstance(body, str) else body\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        return {\"Content-Length\": content_length}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class StreamingRequestContent(RequestContent):\n+    \"\"\"\n+    Request content encoded as plain bytes, using an async byte iterator.\n+    \"\"\"\n+\n+    def __init__(self, aiterator: typing.AsyncIterator[bytes]) -> None:\n+        self.aiterator = aiterator\n+\n+    def can_rewind(self) -> bool:\n+        return False\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {\"Transfer-Encoding\": \"chunked\"}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        async for part in self.aiterator:\n+            yield part\n+\n+\n+class JSONRequestContent(RequestContent):\n+    \"\"\"\n+    Request content encoded as JSON.\n+    \"\"\"\n+\n+    def __init__(self, json: typing.Any) -> None:\n+        self.body = json_dumps(json).encode(\"utf-8\")\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = \"application/json\"\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class URLEncodedRequestContent(RequestContent):\n+    \"\"\"\n+    Request content as URL encoded form data.\n+    \"\"\"\n+\n+    def __init__(self, data: dict) -> None:\n+        self.body = urlencode(data, doseq=True).encode(\"utf-8\")\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = \"application/x-www-form-urlencoded\"\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class MultipartRequestContent(RequestContent):\n+    \"\"\"\n+    Request content as multipart encoded form data.\n+    \"\"\"\n+\n+    def __init__(self, data: dict, files: dict, boundary: bytes = None) -> None:\n+        self.body, self.content_type = multipart_encode(data, files, boundary)\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = self.content_type\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+def encode(\n+    data: RequestData = None,\n+    files: RequestFiles = None,\n+    json: typing.Any = None,\n+    boundary: bytes = None,\n+) -> RequestContent:\n+    \"\"\"\n+    Handles encoding the given `data`, `files`, and `json`, returning\n+    a `RequestContent` implementation which provides a byte iterator onto\n+    the content, as well as `.is_rewindable()` and `.get_headers()` interfaces.\n+\n+    The `boundary` argument is also included for reproducible test cases\n+    when working with multipart data.\n+    \"\"\"\n+    if data is None:\n+        if json is not None:\n+            return JSONRequestContent(json)\n+        elif files:\n+            return MultipartRequestContent({}, files, boundary=boundary)\n+        else:\n+            return RequestContent()\n+    elif isinstance(data, dict):\n+        if files:",
      "comment": "For consistency/explicitness:\r\n\r\n```suggestion\r\n        if files is not None:\r\n```",
      "comment_id": 357912295,
      "user": "florimondmanca",
      "created_at": "2019-12-14T11:24:03Z",
      "url": "https://github.com/encode/httpx/pull/636#discussion_r357912295"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 636,
      "file_path": "httpx/content.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,162 @@\n+import typing\n+from json import dumps as json_dumps\n+from urllib.parse import urlencode\n+\n+from .multipart import multipart_encode\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class RequestContent:\n+    \"\"\"\n+    Base class for request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {}\n+\n+    def can_rewind(self) -> bool:\n+        return True",
      "comment": "What is this property supposed to enable in practice? Does that mean we can `async for chunk in content` again once we've done so at least once? I can't think of better names (`.is_replayable()`? `.can_replay()`? `.can_read_multiple_times`? `.is_isomorphic()`? \ud83e\udd23), but maybe a docstring on this base implementation could help.",
      "comment_id": 357912684,
      "user": "florimondmanca",
      "created_at": "2019-12-14T11:33:18Z",
      "url": "https://github.com/encode/httpx/pull/636#discussion_r357912684"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 636,
      "file_path": "httpx/content.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,162 @@\n+import typing\n+from json import dumps as json_dumps\n+from urllib.parse import urlencode\n+\n+from .multipart import multipart_encode\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class RequestContent:\n+    \"\"\"\n+    Base class for request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {}\n+\n+    def can_rewind(self) -> bool:\n+        return True\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aread(self) -> bytes:",
      "comment": "Also, do we really want `.aread()` as a name here?\r\n\r\nThinking about `unasync`, this means that the sync version of this would be `def aread(self)` by default (unless `unasync` also supports removing any \"a\" prefix, but I don't think it does/should).\r\n\r\nSo maybe this should be `async def read(self) -> bytes` which would map to `def read(self) -> bytes` on the `SyncResponseContent` variant?\r\n\r\nOr is that not the `unasync` use case you're thinking of here?",
      "comment_id": 357912817,
      "user": "florimondmanca",
      "created_at": "2019-12-14T11:36:02Z",
      "url": "https://github.com/encode/httpx/pull/636#discussion_r357912817"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 636,
      "file_path": "httpx/content.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,162 @@\n+import typing\n+from json import dumps as json_dumps\n+from urllib.parse import urlencode\n+\n+from .multipart import multipart_encode\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class RequestContent:\n+    \"\"\"\n+    Base class for request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {}\n+\n+    def can_rewind(self) -> bool:\n+        return True\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aread(self) -> bytes:",
      "comment": "Thinking about it we may not need `unasync` at all to support sync here, right? Kind of the point of this whole thing I suppose. \ud83d\ude04 We'll just implement `def read()` and `__iter__()`, right?",
      "comment_id": 357913083,
      "user": "florimondmanca",
      "created_at": "2019-12-14T11:42:19Z",
      "url": "https://github.com/encode/httpx/pull/636#discussion_r357913083"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 636,
      "file_path": "httpx/content.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,162 @@\n+import typing\n+from json import dumps as json_dumps\n+from urllib.parse import urlencode\n+\n+from .multipart import multipart_encode\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class RequestContent:\n+    \"\"\"\n+    Base class for request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {}\n+\n+    def can_rewind(self) -> bool:\n+        return True",
      "comment": "> Does that mean we can async for chunk in content again\r\n\r\nExactly, yes. It is used when handling redrect responses, that need to generate another request with a body. It happens to be true in all cases except if you pass `data=<async iterator>` in which case we're not able to replay/rewind the request.\r\n\r\nAnd yes, a decent docstring there would make sense.",
      "comment_id": 358214428,
      "user": "lovelydinosaur",
      "created_at": "2019-12-16T12:49:37Z",
      "url": "https://github.com/encode/httpx/pull/636#discussion_r358214428"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 636,
      "file_path": "httpx/content.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,162 @@\n+import typing\n+from json import dumps as json_dumps\n+from urllib.parse import urlencode\n+\n+from .multipart import multipart_encode\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class RequestContent:\n+    \"\"\"\n+    Base class for request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {}\n+\n+    def can_rewind(self) -> bool:\n+        return True\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aread(self) -> bytes:\n+        return b\"\".join([part async for part in self])\n+\n+\n+class BytesRequestContent(RequestContent):\n+    \"\"\"\n+    Request content encoded as plain bytes.\n+    \"\"\"\n+\n+    def __init__(self, body: typing.Union[str, bytes]) -> None:\n+        self.body = body.encode(\"utf-8\") if isinstance(body, str) else body\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        return {\"Content-Length\": content_length}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class StreamingRequestContent(RequestContent):\n+    \"\"\"\n+    Request content encoded as plain bytes, using an async byte iterator.\n+    \"\"\"\n+\n+    def __init__(self, aiterator: typing.AsyncIterator[bytes]) -> None:\n+        self.aiterator = aiterator\n+\n+    def can_rewind(self) -> bool:\n+        return False\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {\"Transfer-Encoding\": \"chunked\"}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        async for part in self.aiterator:\n+            yield part\n+\n+\n+class JSONRequestContent(RequestContent):\n+    \"\"\"\n+    Request content encoded as JSON.\n+    \"\"\"\n+\n+    def __init__(self, json: typing.Any) -> None:\n+        self.body = json_dumps(json).encode(\"utf-8\")\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = \"application/json\"\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class URLEncodedRequestContent(RequestContent):\n+    \"\"\"\n+    Request content as URL encoded form data.\n+    \"\"\"\n+\n+    def __init__(self, data: dict) -> None:\n+        self.body = urlencode(data, doseq=True).encode(\"utf-8\")\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = \"application/x-www-form-urlencoded\"\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class MultipartRequestContent(RequestContent):\n+    \"\"\"\n+    Request content as multipart encoded form data.\n+    \"\"\"\n+\n+    def __init__(self, data: dict, files: dict, boundary: bytes = None) -> None:\n+        self.body, self.content_type = multipart_encode(data, files, boundary)\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = self.content_type\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+def encode(\n+    data: RequestData = None,\n+    files: RequestFiles = None,\n+    json: typing.Any = None,\n+    boundary: bytes = None,\n+) -> RequestContent:\n+    \"\"\"\n+    Handles encoding the given `data`, `files`, and `json`, returning\n+    a `RequestContent` implementation which provides a byte iterator onto\n+    the content, as well as `.is_rewindable()` and `.get_headers()` interfaces.\n+\n+    The `boundary` argument is also included for reproducible test cases\n+    when working with multipart data.\n+    \"\"\"\n+    if data is None:\n+        if json is not None:\n+            return JSONRequestContent(json)\n+        elif files:\n+            return MultipartRequestContent({}, files, boundary=boundary)\n+        else:\n+            return RequestContent()\n+    elif isinstance(data, dict):\n+        if files:",
      "comment": "I've commited the suggestion, yup. It does *somewhat* depend on exactly what behavior we want to expect here... ie should `files={}` result in a multipart encoded request, or a urlencoded request?",
      "comment_id": 358214966,
      "user": "lovelydinosaur",
      "created_at": "2019-12-16T12:50:54Z",
      "url": "https://github.com/encode/httpx/pull/636#discussion_r358214966"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 636,
      "file_path": "httpx/content.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,162 @@\n+import typing\n+from json import dumps as json_dumps\n+from urllib.parse import urlencode\n+\n+from .multipart import multipart_encode\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class RequestContent:\n+    \"\"\"\n+    Base class for request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {}\n+\n+    def can_rewind(self) -> bool:\n+        return True\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aread(self) -> bytes:",
      "comment": "> Thinking about it we may not need unasync at all to support sync here, right? Kind of the point of this whole thing I suppose. \ud83d\ude04 We'll just implement def read() and __iter__(), right?\r\n\r\nExactly, yes. `Request` and `Response` *won't* have two different class variants.",
      "comment_id": 358215401,
      "user": "lovelydinosaur",
      "created_at": "2019-12-16T12:52:02Z",
      "url": "https://github.com/encode/httpx/pull/636#discussion_r358215401"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 636,
      "file_path": "httpx/content.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,162 @@\n+import typing\n+from json import dumps as json_dumps\n+from urllib.parse import urlencode\n+\n+from .multipart import multipart_encode\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class RequestContent:\n+    \"\"\"\n+    Base class for request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {}\n+\n+    def can_rewind(self) -> bool:\n+        return True\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield b\"\"\n+\n+    async def aread(self) -> bytes:\n+        return b\"\".join([part async for part in self])\n+\n+\n+class BytesRequestContent(RequestContent):\n+    \"\"\"\n+    Request content encoded as plain bytes.\n+    \"\"\"\n+\n+    def __init__(self, body: typing.Union[str, bytes]) -> None:\n+        self.body = body.encode(\"utf-8\") if isinstance(body, str) else body\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        return {\"Content-Length\": content_length}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class StreamingRequestContent(RequestContent):\n+    \"\"\"\n+    Request content encoded as plain bytes, using an async byte iterator.\n+    \"\"\"\n+\n+    def __init__(self, aiterator: typing.AsyncIterator[bytes]) -> None:\n+        self.aiterator = aiterator\n+\n+    def can_rewind(self) -> bool:\n+        return False\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {\"Transfer-Encoding\": \"chunked\"}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        async for part in self.aiterator:\n+            yield part\n+\n+\n+class JSONRequestContent(RequestContent):\n+    \"\"\"\n+    Request content encoded as JSON.\n+    \"\"\"\n+\n+    def __init__(self, json: typing.Any) -> None:\n+        self.body = json_dumps(json).encode(\"utf-8\")\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = \"application/json\"\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class URLEncodedRequestContent(RequestContent):\n+    \"\"\"\n+    Request content as URL encoded form data.\n+    \"\"\"\n+\n+    def __init__(self, data: dict) -> None:\n+        self.body = urlencode(data, doseq=True).encode(\"utf-8\")\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = \"application/x-www-form-urlencoded\"\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+class MultipartRequestContent(RequestContent):\n+    \"\"\"\n+    Request content as multipart encoded form data.\n+    \"\"\"\n+\n+    def __init__(self, data: dict, files: dict, boundary: bytes = None) -> None:\n+        self.body, self.content_type = multipart_encode(data, files, boundary)\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        content_length = str(len(self.body))\n+        content_type = self.content_type\n+        return {\"Content-Length\": content_length, \"Content-Type\": content_type}\n+\n+    async def __aiter__(self) -> typing.AsyncIterator[bytes]:\n+        yield self.body\n+\n+\n+def encode(\n+    data: RequestData = None,\n+    files: RequestFiles = None,\n+    json: typing.Any = None,\n+    boundary: bytes = None,\n+) -> RequestContent:\n+    \"\"\"\n+    Handles encoding the given `data`, `files`, and `json`, returning\n+    a `RequestContent` implementation which provides a byte iterator onto\n+    the content, as well as `.is_rewindable()` and `.get_headers()` interfaces.\n+\n+    The `boundary` argument is also included for reproducible test cases\n+    when working with multipart data.\n+    \"\"\"\n+    if data is None:\n+        if json is not None:\n+            return JSONRequestContent(json)\n+        elif files:\n+            return MultipartRequestContent({}, files, boundary=boundary)\n+        else:\n+            return RequestContent()\n+    elif isinstance(data, dict):\n+        if files:",
      "comment": "Well, I'd say if `files` is given then as a user I'd expect HTTPX to use multipart. The previous behavior (which we still have in the `data is None` branch?) would use urlencoded for `data=..., files={}`, which I'd find surprising.\r\n\r\n(But I'm also wondering whether using `files={}` has any practical sense in the first place?)",
      "comment_id": 358218327,
      "user": "florimondmanca",
      "created_at": "2019-12-16T12:59:21Z",
      "url": "https://github.com/encode/httpx/pull/636#discussion_r358218327"
    },
    {
      "repo": "encode/httpx",
      "pr_number": 636,
      "file_path": "httpx/content.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,162 @@\n+import typing\n+from json import dumps as json_dumps\n+from urllib.parse import urlencode\n+\n+from .multipart import multipart_encode\n+\n+RequestData = typing.Union[dict, str, bytes, typing.AsyncIterator[bytes]]\n+\n+RequestFiles = typing.Dict[\n+    str,\n+    typing.Union[\n+        # file (or str)\n+        typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        # (filename, file (or str))\n+        typing.Tuple[\n+            typing.Optional[str], typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+        ],\n+        # (filename, file (or str), content_type)\n+        typing.Tuple[\n+            typing.Optional[str],\n+            typing.Union[typing.IO[typing.AnyStr], typing.AnyStr],\n+            typing.Optional[str],\n+        ],\n+    ],\n+]\n+\n+\n+class RequestContent:\n+    \"\"\"\n+    Base class for request content.\n+    Defaults to a \"no request body\" implementation.\n+    \"\"\"\n+\n+    def get_headers(self) -> typing.Dict[str, str]:\n+        return {}\n+\n+    def can_rewind(self) -> bool:\n+        return True",
      "comment": "I've updated this to `can_replay` and added a proper docstring.",
      "comment_id": 358748570,
      "user": "lovelydinosaur",
      "created_at": "2019-12-17T11:51:26Z",
      "url": "https://github.com/encode/httpx/pull/636#discussion_r358748570"
    }
  ]
}