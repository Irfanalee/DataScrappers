{
  "repo": "ansible/ansible",
  "scraped_at": "2026-02-03T14:18:51.114319",
  "stats": {
    "total_comments": 127,
    "filtered": {
      "not_python": 39,
      "too_short": 25,
      "no_diff_hunk": 3
    },
    "kept": 60
  },
  "examples": [
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/galaxy/collection/__init__.py",
      "line": 866,
      "side": "RIGHT",
      "diff_hunk": "@@ -838,31 +844,36 @@ def verify_collections(\n                         format(coll_type=collection.type)\n                     )\n \n+                search_path_paths: t.Iterator[pathlib.Path] = (\n+                    pathlib.Path(path) / collection.namespace / collection.name\n+                    for path in search_paths\n+                )\n+\n+                # NOTE: using the installed_collections list\n+                # NOTE: guarantees finding the collection if\n+                # NOTE: the folder is improperly named\n+                if installed_collection := installed_collections.get(collection.fqcn, None):\n+                    search_path_paths = chain(\n+                        [pathlib.Path(to_text(installed_collection.src))],\n+                        search_path_paths,\n+                    )\n+\n                 # NOTE: Verify local collection exists before\n                 # NOTE: downloading its source artifact from\n                 # NOTE: a galaxy server.\n-                default_err = 'Collection %s is not installed in any of the collection paths.' % collection.fqcn\n-                for search_path in search_paths:\n-                    b_search_path = to_bytes(\n-                        os.path.join(\n-                            search_path,\n-                            collection.namespace, collection.name,\n-                        ),\n-                        errors='surrogate_or_strict',\n-                    )\n-                    if not os.path.isdir(b_search_path):\n+                err_msg = f\"Collection {collection.fqcn} is not installed in any of the collection paths.\"\n+                for search_path in search_path_paths:\n+                    if not search_path.is_dir():\n                         continue\n-                    if not _is_installed_collection_dir(b_search_path):\n-                        default_err = (\n-                            \"Collection %s does not have a MANIFEST.json. \"\n-                            \"A MANIFEST.json is expected if the collection has been built \"\n-                            \"and installed via ansible-galaxy\" % collection.fqcn\n-                        )\n+                    if not _is_installed_collection_dir(search_path):\n+                        err_msg = (f\"Collection {collection.fqcn} does not have a MANIFEST.json. A MANIFEST.json \"\n+                                   \"is expected if the collection has been built and installed via ansible-galaxy.\")\n                         continue\n \n                     local_collection = Candidate.from_dir_path(\n-                        b_search_path, artifacts_manager,\n+                        to_bytes(search_path), artifacts_manager,\n                     )\n+",
      "comment": "Instead of raising an exception in verify_local_collection, checking the FQCN in the metadata matches the actual FQCN a task will actually use could occur here. This way, if the collection is installed correctly the error won't occur.\r\n\r\n```suggestion\r\n                    actual_fqcn = \".\".join(search_path.as_posix().split(os.path.sep)[-2:])\r\n                    if local_collection.fqcn != actual_fqcn:\r\n                        err_msg = f\"{local_collection.src} path does not match the FQCN {local_collection.fqcn}\"\r\n                        continue\r\n```\r\n\r\nI don't think my suggested change is complete - If I move ns.col improperly to ns.other, I'd only expect an error if I run `ansible-galaxy collection verify ns.other`, not if I run `ansible-galaxy verfiy ns.col` (I'd expect an error that ns.col is not installed in any of the collection paths).",
      "comment_id": 2683581626,
      "user": "s-hertel",
      "created_at": "2026-01-12T19:24:19Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2683581626"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/cli/galaxy.py",
      "line": 1667,
      "side": "RIGHT",
      "diff_hunk": "@@ -1658,7 +1658,13 @@ def execute_list_collection(self, artifacts_manager=None):\n         fqcn_width, version_width = _get_collection_widths(collections)\n         for collection in sorted(collections, key=lambda c: c.src):\n             collection_found = True\n-            collection_path = pathlib.Path(to_text(collection.src)).parent.parent.as_posix()\n+            collection_src_path = pathlib.Path(to_text(collection.src))\n+            collection_path = collection_src_path.parent.parent.as_posix()\n+\n+            if (collection_path_parts := collection_src_path.parts)[-2] != collection.namespace or \\\n+                    collection_path_parts[-1] != collection.name:\n+                warnings.append(f\"Collection {collection.fqcn} is in incorrectly named directory {collection_src_path}. \"\n+                                f\"Expected {collection_src_path.parent.parent / collection.namespace / collection.name}\")",
      "comment": "It's possible that collection is installed correctly too, so I think the warning should lead with the path or actual fqcn and indicate that the metadata doesn't match, for example\r\n\r\n```suggestion\r\n                warnings.append(f\"Collection {collection_src_path} documents FQCN {collection.fqcn}, which is invalid and has no effect.\")\r\n```",
      "comment_id": 2683582135,
      "user": "s-hertel",
      "created_at": "2026-01-12T19:24:29Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2683582135"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/galaxy/collection/__init__.py",
      "line": 866,
      "side": "RIGHT",
      "diff_hunk": "@@ -838,31 +844,36 @@ def verify_collections(\n                         format(coll_type=collection.type)\n                     )\n \n+                search_path_paths: t.Iterator[pathlib.Path] = (\n+                    pathlib.Path(path) / collection.namespace / collection.name\n+                    for path in search_paths\n+                )\n+\n+                # NOTE: using the installed_collections list\n+                # NOTE: guarantees finding the collection if\n+                # NOTE: the folder is improperly named\n+                if installed_collection := installed_collections.get(collection.fqcn, None):\n+                    search_path_paths = chain(\n+                        [pathlib.Path(to_text(installed_collection.src))],\n+                        search_path_paths,\n+                    )\n+\n                 # NOTE: Verify local collection exists before\n                 # NOTE: downloading its source artifact from\n                 # NOTE: a galaxy server.\n-                default_err = 'Collection %s is not installed in any of the collection paths.' % collection.fqcn\n-                for search_path in search_paths:\n-                    b_search_path = to_bytes(\n-                        os.path.join(\n-                            search_path,\n-                            collection.namespace, collection.name,\n-                        ),\n-                        errors='surrogate_or_strict',\n-                    )\n-                    if not os.path.isdir(b_search_path):\n+                err_msg = f\"Collection {collection.fqcn} is not installed in any of the collection paths.\"\n+                for search_path in search_path_paths:\n+                    if not search_path.is_dir():\n                         continue\n-                    if not _is_installed_collection_dir(b_search_path):\n-                        default_err = (\n-                            \"Collection %s does not have a MANIFEST.json. \"\n-                            \"A MANIFEST.json is expected if the collection has been built \"\n-                            \"and installed via ansible-galaxy\" % collection.fqcn\n-                        )\n+                    if not _is_installed_collection_dir(search_path):\n+                        err_msg = (f\"Collection {collection.fqcn} does not have a MANIFEST.json. A MANIFEST.json \"\n+                                   \"is expected if the collection has been built and installed via ansible-galaxy.\")\n                         continue\n \n                     local_collection = Candidate.from_dir_path(\n-                        b_search_path, artifacts_manager,\n+                        to_bytes(search_path), artifacts_manager,\n                     )\n+",
      "comment": "As of e0e80ef4e2d7e5a1a0030c74e46011c3eb437b76 the `ansible-galaxy collection verify` api should work as described by moving the validation logic out of `verify_local_collection`.",
      "comment_id": 2688229265,
      "user": "pkingstonxyz",
      "created_at": "2026-01-13T21:47:31Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2688229265"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/cli/galaxy.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +123,7 @@ def _display_role(gr):\n \n def _display_collection(collection, cwidth=10, vwidth=7, min_cwidth=10, min_vwidth=7):\n     display.display('{fqcn:{cwidth}} {version:{vwidth}}'.format(\n-        fqcn=to_text(collection.fqcn),\n+        fqcn=to_text(\".\".join(pathlib.Path(to_text(collection.src)).parts[-2:])),",
      "comment": "This computation of the \"folder-based fqcn\" also occurs on line 137 in this file. It feels like something that could be pre-computed by a Candidate/Collection object (maybe in the `_ComputedReqKindsMixin`?) but I'm not sure. ",
      "comment_id": 2688233559,
      "user": "pkingstonxyz",
      "created_at": "2026-01-13T21:48:44Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2688233559"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/cli/galaxy.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +123,7 @@ def _display_role(gr):\n \n def _display_collection(collection, cwidth=10, vwidth=7, min_cwidth=10, min_vwidth=7):\n     display.display('{fqcn:{cwidth}} {version:{vwidth}}'.format(\n-        fqcn=to_text(collection.fqcn),\n+        fqcn=to_text(\".\".join(pathlib.Path(to_text(collection.src)).parts[-2:])),",
      "comment": "> It feels like something that could be pre-computed by a Candidate/Collection object (maybe in the _ComputedReqKindsMixin?) but I'm not sure.\r\n\r\nSometimes the FQCN does originate from the metadata (when building or installing collections). Thinking aloud...\r\n\r\n- verify requires a MANIFEST.json\r\n- build requires a galaxy.yml\r\n- install requires a MANIFEST.json (and will build one if given a galaxy.yml)\r\n- list and install do not require any metadata for existing collections (usually as a last resort, the FQCN is determined by the path, and version defaults to any).\r\n\r\nBoth list and install use `find_existing_collections`. Before yielding a collection, I think that function should check the FQCN matches the path. If it doesn't, it could give a warning and re-create the Candidate using the correct FQCN and version \"*\".",
      "comment_id": 2695587147,
      "user": "s-hertel",
      "created_at": "2026-01-15T18:57:51Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2695587147"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/galaxy/collection/__init__.py",
      "line": 873,
      "side": "RIGHT",
      "diff_hunk": "@@ -863,6 +863,12 @@ def verify_collections(\n                     local_collection = Candidate.from_dir_path(\n                         b_search_path, artifacts_manager,\n                     )\n+\n+                    actual_fqcn = \".\".join(pathlib.Path(to_text(local_collection.src)).parts[-2:])\n+                    if local_collection.fqcn != actual_fqcn:",
      "comment": "I overlooked the fact that we were in a loop with the requested collection, which contains the expected FQCN.\r\n```suggestion\r\n                    if local_collection.fqcn != collection.fqcn:\r\n```",
      "comment_id": 2695588602,
      "user": "s-hertel",
      "created_at": "2026-01-15T18:58:21Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2695588602"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/cli/galaxy.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +123,7 @@ def _display_role(gr):\n \n def _display_collection(collection, cwidth=10, vwidth=7, min_cwidth=10, min_vwidth=7):\n     display.display('{fqcn:{cwidth}} {version:{vwidth}}'.format(\n-        fqcn=to_text(collection.fqcn),\n+        fqcn=to_text(\".\".join(pathlib.Path(to_text(collection.src)).parts[-2:])),",
      "comment": "I'm hesitant to make this change to `find_existing_collections`. My argument is that `ansible-galaxy collection list` feels like it should be a read-only operation. This is only my intuition and I don't know the ins and outs of other similar package management systems.\r\n\r\nBecause this bug requires some conditions that are kinda convoluted, like you said,\r\n\r\n> I think the behavior on devel is problematic, but unlikely to affect many people since the prerequisite is meddling with the collections directory and not correcting the metadata.\r\n\r\nI think this is better solved by issuing warnings/errors and not changing things on the filesystem unless it's an operation that already does that (install, for example)",
      "comment_id": 2714215694,
      "user": "pkingstonxyz",
      "created_at": "2026-01-21T20:24:29Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2714215694"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/cli/galaxy.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +123,7 @@ def _display_role(gr):\n \n def _display_collection(collection, cwidth=10, vwidth=7, min_cwidth=10, min_vwidth=7):\n     display.display('{fqcn:{cwidth}} {version:{vwidth}}'.format(\n-        fqcn=to_text(collection.fqcn),\n+        fqcn=to_text(\".\".join(pathlib.Path(to_text(collection.src)).parts[-2:])),",
      "comment": "`find_existing_collections` would still only be a read-only operation. I'm not suggesting it should modify on-disk collections. It would just reflect reality instead of however the user managed to trash their metadata. The read-only operation works like this:\r\n\r\n- attempt to load metadata from the MANIFEST.json\r\n- fall back to attempting to load metadata from the galaxy.yml\r\n- fall back to no metadata\r\n\r\nSince `find_existing_collections` does not require metadata, it should not use obviously incorrect metadata, it should fall back to using no metadata.",
      "comment_id": 2717971830,
      "user": "s-hertel",
      "created_at": "2026-01-22T17:47:42Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2717971830"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/galaxy/dependency_resolution/dataclasses.py",
      "line": 621,
      "side": "RIGHT",
      "diff_hunk": "@@ -616,6 +616,15 @@ def is_pinned(self) -> bool:\n     def source_info(self) -> dict[str, object] | None:\n         return self._source_info\n \n+    @property\n+    def dir_fqcn(self) -> str | None:\n+        \"\"\"Return an fqcn based on the directory path rather than metadata\"\"\"",
      "comment": "```suggestion\r\n        \"\"\"Return an FQCN based on the directory path rather than metadata.\"\"\"\r\n```",
      "comment_id": 2732914877,
      "user": "webknjaz",
      "created_at": "2026-01-27T16:44:11Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2732914877"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/cli/galaxy.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +123,7 @@ def _display_role(gr):\n \n def _display_collection(collection, cwidth=10, vwidth=7, min_cwidth=10, min_vwidth=7):\n     display.display('{fqcn:{cwidth}} {version:{vwidth}}'.format(\n-        fqcn=to_text(collection.fqcn),\n+        fqcn=to_text(\".\".join(pathlib.Path(to_text(collection.src)).parts[-2:])),",
      "comment": "I completely misunderstood what you were saying. I see what you mean now. The current state of the PR uses what you suggest, it's way more elegant imo. I kept the old changes around in a branch [here](https://github.com/pkingstonxyz/ansible/tree/fix-galaxy-metadata-disk-mismatch-old-method-69813). \r\n\r\nThe one benefit to my previous method was that in `ansible-galaxy collection list`, it buffered the warning with the rest of `list`'s warnings. I don't think this minor UI change is enough to warrant adding a new property to the class and adding the warning/error logic to every function as in my old method.",
      "comment_id": 2734117533,
      "user": "pkingstonxyz",
      "created_at": "2026-01-27T22:46:16Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2734117533"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86402,
      "file_path": "lib/ansible/galaxy/collection/__init__.py",
      "line": 1476,
      "side": "RIGHT",
      "diff_hunk": "@@ -1467,6 +1472,10 @@ def find_existing_collections(path_filter, artifacts_manager, namespace_filter=N\n             display.warning(f'{val_err}')\n             continue\n \n+        if req.fqcn != '.'.join(pathlib.Path(to_text(req.src)).parts[-2:]):\n+            display.warning(f\"Collection at {to_text(req.src)} documents incorrect FQCN '{req.fqcn}' Ignoring metadata\")",
      "comment": "```suggestion\n            display.warning(f\"Collection at {to_text(req.src)} documents incorrect FQCN '{req.fqcn}'. Ignoring metadata.\")\n```",
      "comment_id": 2744082321,
      "user": "s-hertel",
      "created_at": "2026-01-30T00:26:27Z",
      "url": "https://github.com/ansible/ansible/pull/86402#discussion_r2744082321"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86473,
      "file_path": "test/units/plugins/become/test_su.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,4 +70,4 @@ def test_check_password_prompt_escaping(mocker) -> None:\n \n     mocker.patch.object(become, 'get_option', return_value=['(invalid regex'])\n \n-    assert become.check_password_prompt('(invalid regex:') is True\n+    assert become.check_password_prompt('(invalid regex:'.encode()) is True",
      "comment": "```suggestion\r\n    assert become.check_password_prompt(b'(invalid regex:') is True\r\n```",
      "comment_id": 2743368038,
      "user": "mattclay",
      "created_at": "2026-01-29T20:19:59Z",
      "url": "https://github.com/ansible/ansible/pull/86473#discussion_r2743368038"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86348,
      "file_path": "lib/ansible/modules/git.py",
      "line": 793,
      "side": "RIGHT",
      "diff_hunk": "@@ -785,6 +788,13 @@ def is_not_a_branch(git_path, module, dest):\n             return True\n     return False\n \n+def looks_like_sha1_string(version: str) -> bool:\n+    matches_long = re.match(r\"^[a-fA-F0-9]{40}$\", version)\n+    matches_short = re.match(r\"^[a-fA-F0-9]{7}$\", version)",
      "comment": "Why check these two lengths specifically? A commit hash can be as long as 64 characters (when using SHA-256, which will be the default in Git 3) or as short as 4.",
      "comment_id": 2624172698,
      "user": "flowerysong",
      "created_at": "2025-12-16T17:38:16Z",
      "url": "https://github.com/ansible/ansible/pull/86348#discussion_r2624172698"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86348,
      "file_path": "lib/ansible/modules/git.py",
      "line": 793,
      "side": "RIGHT",
      "diff_hunk": "@@ -785,6 +788,13 @@ def is_not_a_branch(git_path, module, dest):\n             return True\n     return False\n \n+def looks_like_sha1_string(version: str) -> bool:\n+    matches_long = re.match(r\"^[a-fA-F0-9]{40}$\", version)\n+    matches_short = re.match(r\"^[a-fA-F0-9]{7}$\", version)",
      "comment": "Ah this comes from a naive understanding of git objects. I went with these two specifically because the git docs sometimes refer to a 'full, 40-character SHA-1 hash' (https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection). 7 characters because that's the default short hash length on github. I hadn't seen the sha-256 switch in my earlier research. \r\n\r\nI'll convert this PR to a draft and rework this section.",
      "comment_id": 2624193289,
      "user": "pkingstonxyz",
      "created_at": "2025-12-16T17:45:22Z",
      "url": "https://github.com/ansible/ansible/pull/86348#discussion_r2624193289"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86348,
      "file_path": "lib/ansible/modules/git.py",
      "line": 685,
      "side": "RIGHT",
      "diff_hunk": "@@ -678,6 +679,20 @@ def get_diff(module, git_path, dest, repo, remote, depth, bare, before, after):\n     return {}\n \n \n+def get_sha_hash(module: AnsibleModule, git_path: str, remote: str, version: str) -> str:\n+    temporary_repository = pathlib.Path(module.tmpdir) / \"tmp_repo\"\n+\n+    module.run_command([git_path, 'init'], cwd=temporary_repository)  # Create a bare repo",
      "comment": "I think you'll need to create the temp dir before calling `run_command()`. The `ignore_invalid_cwd` param defaults to `True` here.",
      "comment_id": 2669994969,
      "user": "Shrews",
      "created_at": "2026-01-07T20:35:05Z",
      "url": "https://github.com/ansible/ansible/pull/86348#discussion_r2669994969"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86304,
      "file_path": "lib/ansible/utils/display.py",
      "line": 161,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,12 +158,12 @@ def get_text_width(text: str) -> int:\n     return width if width >= 0 else 0\n \n \n-class FilterBlackList(logging.Filter):\n-    def __init__(self, blacklist):\n-        self.blacklist = [logging.Filter(name) for name in blacklist]\n+class FilterDenyList(logging.Filter):",
      "comment": "Please create a [changelog fragment](https://docs.ansible.com/ansible/latest/community/development_process.html#creating-a-changelog-fragment). See [this fragment](https://github.com/ansible/ansible/blob/c2f528b7686c9573aa8493357219e0bbe4416dd3/changelogs/fragments/reboot-change-default-boot-command.yaml) as an example.",
      "comment_id": 2596969947,
      "user": "Akasurde",
      "created_at": "2025-12-08T04:07:32Z",
      "url": "https://github.com/ansible/ansible/pull/86304#discussion_r2596969947"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86437,
      "file_path": "test/lib/ansible_test/_internal/commands/integration/__init__.py",
      "line": 217,
      "side": "RIGHT",
      "diff_hunk": "@@ -175,6 +176,51 @@ def get_files_needed(target_dependencies: list[IntegrationTarget]) -> list[str]:\n     return files_needed\n \n \n+def get_collection_roots_needed(target_dependencies: list[IntegrationTarget]) -> list[str]:\n+    \"\"\"\n+    Return a list of collection roots needed by the given list of target dependencies.\n+    This feature is only supported for ansible-core, not collections.\n+    To be recognized, a collection must reside in the following directory:\n+    test/integration/targets/{target_name}/ansible_collections/ansible_test/{target_name}\n+    If the target name has dashes, they will be replaced with underscores for the collection name.\n+    It is an error if the collection root contains additional namespaces or collections.\n+    This is enforced to ensure there are no naming conflicts between collection roots.\n+    \"\"\"\n+    if not data_context().content.is_ansible:\n+        return []\n+\n+    collection_roots: list[str] = []\n+    namespace_name = 'ansible_test'\n+\n+    for target_dependency in target_dependencies:\n+        collection_root = os.path.join(data_context().content.integration_targets_path, target_dependency.name)\n+        collection_name = target_dependency.name.replace('-', '_')\n+        namespaces_path = os.path.join(collection_root, 'ansible_collections')\n+        namespace_path = os.path.join(namespaces_path, namespace_name)\n+        collection_path = os.path.join(namespace_path, collection_name)\n+\n+        if not os.path.isdir(collection_path):\n+            continue\n+\n+        namespaces = set(os.listdir(namespaces_path))\n+        namespaces.remove(namespace_name)\n+\n+        if namespaces:\n+            raise ApplicationError(f\"Additional test collection namespaces not supported: {', '.join(sorted(namespaces))}\")\n+\n+        collections = set(os.listdir(namespace_path))\n+        collections.remove(collection_name)\n+\n+        if collections:\n+            raise ApplicationError(f\"Additional test collections not supported: {', '.join(sorted(collections))}\")\n+\n+        collection_roots.append(collection_root)",
      "comment": "FTR, these lines have no coverage in Codecov at the time of the PR merge. I suspect #86432 will add some (except for the raise cases).",
      "comment_id": 2716340943,
      "user": "webknjaz",
      "created_at": "2026-01-22T10:46:22Z",
      "url": "https://github.com/ansible/ansible/pull/86437#discussion_r2716340943"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86437,
      "file_path": "test/lib/ansible_test/_internal/commands/integration/__init__.py",
      "line": 217,
      "side": "RIGHT",
      "diff_hunk": "@@ -175,6 +176,51 @@ def get_files_needed(target_dependencies: list[IntegrationTarget]) -> list[str]:\n     return files_needed\n \n \n+def get_collection_roots_needed(target_dependencies: list[IntegrationTarget]) -> list[str]:\n+    \"\"\"\n+    Return a list of collection roots needed by the given list of target dependencies.\n+    This feature is only supported for ansible-core, not collections.\n+    To be recognized, a collection must reside in the following directory:\n+    test/integration/targets/{target_name}/ansible_collections/ansible_test/{target_name}\n+    If the target name has dashes, they will be replaced with underscores for the collection name.\n+    It is an error if the collection root contains additional namespaces or collections.\n+    This is enforced to ensure there are no naming conflicts between collection roots.\n+    \"\"\"\n+    if not data_context().content.is_ansible:\n+        return []\n+\n+    collection_roots: list[str] = []\n+    namespace_name = 'ansible_test'\n+\n+    for target_dependency in target_dependencies:\n+        collection_root = os.path.join(data_context().content.integration_targets_path, target_dependency.name)\n+        collection_name = target_dependency.name.replace('-', '_')\n+        namespaces_path = os.path.join(collection_root, 'ansible_collections')\n+        namespace_path = os.path.join(namespaces_path, namespace_name)\n+        collection_path = os.path.join(namespace_path, collection_name)\n+\n+        if not os.path.isdir(collection_path):\n+            continue\n+\n+        namespaces = set(os.listdir(namespaces_path))\n+        namespaces.remove(namespace_name)\n+\n+        if namespaces:\n+            raise ApplicationError(f\"Additional test collection namespaces not supported: {', '.join(sorted(namespaces))}\")\n+\n+        collections = set(os.listdir(namespace_path))\n+        collections.remove(collection_name)\n+\n+        if collections:\n+            raise ApplicationError(f\"Additional test collections not supported: {', '.join(sorted(collections))}\")\n+\n+        collection_roots.append(collection_root)",
      "comment": "They're tested (except the exceptions). They just don't show up in coverage reports.",
      "comment_id": 2717824355,
      "user": "mattclay",
      "created_at": "2026-01-22T17:09:01Z",
      "url": "https://github.com/ansible/ansible/pull/86437#discussion_r2717824355"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86415,
      "file_path": "lib/ansible/modules/user.py",
      "line": 1589,
      "side": "RIGHT",
      "diff_hunk": "@@ -1586,7 +1586,7 @@ def modify_user(self):\n             cmd.append(self.comment)\n \n         if self.home is not None:\n-            if (info[5] != self.home and self.move_home) or (not os.path.exists(self.home) and self.create_home):\n+            if (info[5] != self.home and self.move_home) or (info[5] != '/nonexistent' and not os.path.exists(self.home) and self.create_home):",
      "comment": "Add a comment saying - `/nonexistent` should be created or something on that line ...",
      "comment_id": 2690104233,
      "user": "Akasurde",
      "created_at": "2026-01-14T11:42:11Z",
      "url": "https://github.com/ansible/ansible/pull/86415#discussion_r2690104233"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85799,
      "file_path": "lib/ansible/modules/unarchive.py",
      "line": 437,
      "side": "RIGHT",
      "diff_hunk": "@@ -428,17 +428,17 @@ def _valid_time_stamp(self, timestamp_str):\n         \"\"\" Return a valid time object from the given time string \"\"\"\n         DT_RE = re.compile(r'^(\\d{4})(\\d{2})(\\d{2})\\.(\\d{2})(\\d{2})(\\d{2})$')\n         match = DT_RE.match(timestamp_str)\n-        epoch_date_time = (1980, 1, 1, 0, 0, 0, 0, 0, 0)\n+        epoch_date_time = (1980, 1, 1, 0, 0, 0, 0, 0, -1)\n         if match:\n             try:\n                 if int(match.groups()[0]) < 1980:\n                     date_time = epoch_date_time\n                 elif int(match.groups()[0]) >= 2038 and _y2038_impacted():\n-                    date_time = (2038, 1, 1, 0, 0, 0, 0, 0, 0)\n+                    date_time = (2038, 1, 1, 0, 0, 0, 0, 0, -1)",
      "comment": "@Akasurde looks like you've changed an uncovered line w/o adding coverage for the new code either. Would you look into adding a test for this?",
      "comment_id": 2698879410,
      "user": "webknjaz",
      "created_at": "2026-01-16T15:07:41Z",
      "url": "https://github.com/ansible/ansible/pull/85799#discussion_r2698879410"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86373,
      "file_path": "lib/ansible/plugins/strategy/__init__.py",
      "line": 1002,
      "side": "RIGHT",
      "diff_hunk": "@@ -999,7 +999,7 @@ def _evaluate_conditional(conditional_host: Host) -> bool:\n                 msg = 'ending role %s for %s' % (task._role.get_name(), target_host.name)\n             else:\n                 skipped = True\n-                skip_reason += 'continuing role %s for %s' % (task._role.get_name(), target_host.name)\n+                skip_reason += ' continuing role %s for %s' % (task._role.get_name(), target_host.name)",
      "comment": "```suggestion\r\n                skip_reason += ', continuing role %s for %s' % (task._role.get_name(), target_host.name)\r\n```\r\nAll of the other skip messages add a comma as well.",
      "comment_id": 2663914396,
      "user": "flowerysong",
      "created_at": "2026-01-06T07:20:03Z",
      "url": "https://github.com/ansible/ansible/pull/86373#discussion_r2663914396"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86384,
      "file_path": "lib/ansible/module_utils/facts/system/distribution.py",
      "line": 441,
      "side": "RIGHT",
      "diff_hunk": "@@ -438,10 +438,10 @@ def parse_distribution_file_NA(self, name, data, path, collected_facts):\n         for line in data.splitlines():\n             distribution = re.search(\"^NAME=(.*)\", line)\n             if distribution and name == 'NA':\n-                na_facts['distribution'] = distribution.group(1).strip('\"')\n+                na_facts['distribution'] = distribution.group(1).strip('\"').strip(\"'\")",
      "comment": "Please create a [changelog fragment](https://docs.ansible.com/ansible/latest/community/development_process.html#creating-a-changelog-fragment). See [this fragment](https://github.com/ansible/ansible/blob/c2f528b7686c9573aa8493357219e0bbe4416dd3/changelogs/fragments/reboot-change-default-boot-command.yaml) as an example.",
      "comment_id": 2669646594,
      "user": "Akasurde",
      "created_at": "2026-01-07T18:33:58Z",
      "url": "https://github.com/ansible/ansible/pull/86384#discussion_r2669646594"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86384,
      "file_path": "lib/ansible/module_utils/facts/system/distribution.py",
      "line": 441,
      "side": "RIGHT",
      "diff_hunk": "@@ -438,10 +438,10 @@ def parse_distribution_file_NA(self, name, data, path, collected_facts):\n         for line in data.splitlines():\n             distribution = re.search(\"^NAME=(.*)\", line)\n             if distribution and name == 'NA':\n-                na_facts['distribution'] = distribution.group(1).strip('\"')\n+                na_facts['distribution'] = distribution.group(1).strip('\"').strip(\"'\")",
      "comment": "Use `https://github.com/ansible/ansible/blob/devel/hacking/tests/gen_distribution_version_testcase.py` to gather distro information and add create a JSON file [here](https://github.com/ansible/ansible/tree/devel/test/units/module_utils/facts/system/distribution/fixtures)",
      "comment_id": 2669652162,
      "user": "Akasurde",
      "created_at": "2026-01-07T18:36:00Z",
      "url": "https://github.com/ansible/ansible/pull/86384#discussion_r2669652162"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86384,
      "file_path": "lib/ansible/module_utils/facts/system/distribution.py",
      "line": 441,
      "side": "RIGHT",
      "diff_hunk": "@@ -438,10 +438,10 @@ def parse_distribution_file_NA(self, name, data, path, collected_facts):\n         for line in data.splitlines():\n             distribution = re.search(\"^NAME=(.*)\", line)\n             if distribution and name == 'NA':\n-                na_facts['distribution'] = distribution.group(1).strip('\"')\n+                na_facts['distribution'] = distribution.group(1).strip('\"').strip(\"'\")",
      "comment": "chained strip calls can be replaced with `strip(DistributionFiles.STRIP_QUOTES)` with the same effect.\r\n\r\nwhole module needs some serious love though, so it's just a nitpick.",
      "comment_id": 2672995625,
      "user": "allixx",
      "created_at": "2026-01-08T16:15:27Z",
      "url": "https://github.com/ansible/ansible/pull/86384#discussion_r2672995625"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86384,
      "file_path": "lib/ansible/module_utils/facts/system/distribution.py",
      "line": 441,
      "side": "RIGHT",
      "diff_hunk": "@@ -438,10 +438,10 @@ def parse_distribution_file_NA(self, name, data, path, collected_facts):\n         for line in data.splitlines():\n             distribution = re.search(\"^NAME=(.*)\", line)\n             if distribution and name == 'NA':\n-                na_facts['distribution'] = distribution.group(1).strip('\"')\n+                na_facts['distribution'] = distribution.group(1).strip('\"').strip(\"'\")",
      "comment": "Just added the Informations, not sure how usefull the Gentoo json will be, a lot of info in there are highly variable.",
      "comment_id": 2677723970,
      "user": "RealKelsar",
      "created_at": "2026-01-09T21:54:54Z",
      "url": "https://github.com/ansible/ansible/pull/86384#discussion_r2677723970"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85834,
      "file_path": "lib/ansible/plugins/action/copy.py",
      "line": 594,
      "side": "RIGHT",
      "diff_hunk": "@@ -588,7 +590,7 @@ def run(self, tmp=None, task_vars=None):\n \n             changed = changed or module_return.get('changed', False)\n \n-        if module_executed and len(source_files['files']) == 1:\n+        if module_executed and not source_is_dir:\n             result.update(module_return)",
      "comment": "Trying to normalize the result was one of the things I struggled with in #76996. I think this needs a larger refactoring.\r\n\r\nAlthough this results in showing the correct src and dest, it's also omitting all details from the module result and could be a breaking change:\r\n\r\n```console\r\nlocalhost | CHANGED => {\r\n    \"changed\": true,\r\n    \"dest\": \"/home/shertel/projects/ansible/85833/dest/\",\r\n    \"src\": \"/home/shertel/projects/ansible/85833/src/\"\r\n}\r\n```\r\n\r\nInstead of\r\n```console\r\nlocalhost | CHANGED => {\r\n    \"changed\": true,\r\n    \"checksum\": \"da39a3ee5e6b4b0d3255bfef95601890afd80709\",\r\n    \"dest\": \"/home/shertel/projects/ansible/85833/dest/dir1/file\",\r\n    \"gid\": 1000,\r\n    \"group\": \"shertel\",\r\n    \"md5sum\": \"d41d8cd98f00b204e9800998ecf8427e\",\r\n    \"mode\": \"0644\",\r\n    \"owner\": \"shertel\",\r\n    \"size\": 0,\r\n    \"src\": \"/home/shertel/.ansible/tmp/ansible-tmp-1761142475.6090798-46357-154668110609223/.source\",\r\n    \"state\": \"file\",\r\n    \"uid\": 1000\r\n}\r\n```\r\n\r\nOther than this, the code change and tests look good to me.",
      "comment_id": 2452311824,
      "user": "s-hertel",
      "created_at": "2025-10-22T14:30:34Z",
      "url": "https://github.com/ansible/ansible/pull/85834#discussion_r2452311824"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85834,
      "file_path": "lib/ansible/plugins/action/copy.py",
      "line": 594,
      "side": "RIGHT",
      "diff_hunk": "@@ -588,7 +590,7 @@ def run(self, tmp=None, task_vars=None):\n \n             changed = changed or module_return.get('changed', False)\n \n-        if module_executed and len(source_files['files']) == 1:\n+        if module_executed and not source_is_dir:\n             result.update(module_return)",
      "comment": "Thanks! I overlooked the fact that the change of result might be a breaking change. I've reverted it.\r\n\r\nOnce this is merged, let me open a new issue to discuss the right behavior and address the potential breaking change in a proper way.",
      "comment_id": 2455413689,
      "user": "fh-yuxiao-zeng",
      "created_at": "2025-10-23T14:48:25Z",
      "url": "https://github.com/ansible/ansible/pull/85834#discussion_r2455413689"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85834,
      "file_path": "lib/ansible/plugins/action/copy.py",
      "line": 535,
      "side": "RIGHT",
      "diff_hunk": "@@ -529,11 +529,11 @@ def run(self, tmp=None, task_vars=None):\n                 result.update(module_return)\n                 return self._ensure_invocation(result)\n \n-            paths = os.path.split(source_rel)\n-            dir_path = ''\n-            for dir_component in paths:\n-                os.path.join(dir_path, dir_component)\n-                implicit_directories.add(dir_path)\n+            source_rel_parent = os.path.dirname(source_rel)\n+            while source_rel_parent != '':\n+                implicit_directories.add(source_rel_parent)\n+                source_rel_parent = os.path.dirname(source_rel_parent)",
      "comment": "```suggestion\r\n            while (source_rel := os.path.dirname(source_rel)) != '':\r\n                implicit_directories.add(source_rel)\r\n```",
      "comment_id": 2586910217,
      "user": "s-hertel",
      "created_at": "2025-12-03T23:18:54Z",
      "url": "https://github.com/ansible/ansible/pull/85834#discussion_r2586910217"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86403,
      "file_path": "lib/ansible/modules/deb822_repository.py",
      "line": 572,
      "side": "RIGHT",
      "diff_hunk": "@@ -569,6 +569,7 @@ def main():\n     # popped non-deb822 args\n     mode = params.pop('mode')\n     state = params.pop('state')\n+    _install_python_debian_param = params.pop('install_python_debian')",
      "comment": "No need to save the popped value, since it's already been consulted above.",
      "comment_id": 2677972468,
      "user": "mattclay",
      "created_at": "2026-01-09T23:58:52Z",
      "url": "https://github.com/ansible/ansible/pull/86403#discussion_r2677972468"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85857,
      "file_path": "lib/ansible/executor/module_common.py",
      "line": 1396,
      "side": "RIGHT",
      "diff_hunk": "@@ -1393,7 +1393,7 @@ def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine) -\n \n \n def _apply_action_arg_defaults(action: str, task: Task, action_args: dict[str, t.Any], templar: Templar) -> dict[str, t.Any]:\n-    args = _get_action_arg_defaults(action, task, templar._engine)\n+    args = templar.template(_get_action_arg_defaults(action, task, templar._engine))",
      "comment": "```suggestion\r\n    # Perform templating for action plugins.\r\n    args = templar.template(_get_action_arg_defaults(action, task, templar._engine))\r\n```",
      "comment_id": 2665395885,
      "user": "s-hertel",
      "created_at": "2026-01-06T15:52:27Z",
      "url": "https://github.com/ansible/ansible/pull/85857#discussion_r2665395885"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85857,
      "file_path": "lib/ansible/executor/module_common.py",
      "line": 1390,
      "side": "RIGHT",
      "diff_hunk": "@@ -1387,13 +1387,16 @@ def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine) -\n                 tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n \n     # handle specific action defaults\n-    tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n+    if not template_fully:",
      "comment": "Since there's an `else` here, I think it would be more readable to invert the conditional.",
      "comment_id": 2665532055,
      "user": "mattclay",
      "created_at": "2026-01-06T16:34:23Z",
      "url": "https://github.com/ansible/ansible/pull/85857#discussion_r2665532055"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85857,
      "file_path": "lib/ansible/executor/module_common.py",
      "line": 1360,
      "side": "RIGHT",
      "diff_hunk": "@@ -1356,7 +1356,11 @@ def modify_module(\n     )\n \n \n-def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine) -> dict[str, t.Any]:\n+def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine, finalize: bool = False) -> dict[str, t.Any]:\n+    \"\"\"Get module_defaults that match or contain a fully qualified action/module name.",
      "comment": "For consistency with the majority of our multi-line docstrings, put start and end quotes on a line by themselves.",
      "comment_id": 2666408554,
      "user": "mattclay",
      "created_at": "2026-01-06T21:51:14Z",
      "url": "https://github.com/ansible/ansible/pull/85857#discussion_r2666408554"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85857,
      "file_path": "lib/ansible/executor/module_common.py",
      "line": 1413,
      "side": "RIGHT",
      "diff_hunk": "@@ -1384,16 +1389,28 @@ def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine) -\n         if default.startswith('group/'):\n             group_name = default.split('group/')[-1]\n             if group_name in group_names:\n-                tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n+                if finalize:\n+                    tmp_args.update(templar.template(module_defaults.get(f'group/{group_name}', {})))\n+                else:\n+                    tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n \n     # handle specific action defaults\n-    tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n+    if finalize:\n+        tmp_args.update(templar.template(module_defaults.get(action, {})))\n+    else:\n+        tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n \n     return tmp_args\n \n \n def _apply_action_arg_defaults(action: str, task: Task, action_args: dict[str, t.Any], templar: Templar) -> dict[str, t.Any]:\n-    args = _get_action_arg_defaults(action, task, templar._engine)\n+    \"\"\"\n+    Finalize arguments from module_defaults and update with action_args.\n+\n+    This is used by action plugins like gather_facts, package, and service,\n+    which select modules to execute after normal task argument finalization.\n+    \"\"\"\n+    args = _get_action_arg_defaults(action, task, templar._engine, finalize=True)",
      "comment": "Instead of having `_get_action_arg_defaults` finalize the arguments, we should probably drop `action_args` keys from `args`, template `args`, and then update it with `action_args`.\r\n\r\nThat will avoid unnecessarily templating `args` values which will be replaced by `action_args`, while also avoiding a second template pass over `action_args`.",
      "comment_id": 2670318991,
      "user": "mattclay",
      "created_at": "2026-01-07T22:52:22Z",
      "url": "https://github.com/ansible/ansible/pull/85857#discussion_r2670318991"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85857,
      "file_path": "lib/ansible/executor/module_common.py",
      "line": 1363,
      "side": "RIGHT",
      "diff_hunk": "@@ -1357,6 +1357,11 @@ def modify_module(\n \n \n def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine) -> dict[str, t.Any]:\n+    \"\"\"\n+    Get module_defaults that match or contain a fully qualified action/module name.\n+\n+    The return value is not finalized by default because it occurs in TaskArgsFinalizer.",
      "comment": "The docstring should be updated now that the finalize arg has been removed.",
      "comment_id": 2676943536,
      "user": "mattclay",
      "created_at": "2026-01-09T17:04:36Z",
      "url": "https://github.com/ansible/ansible/pull/85857#discussion_r2676943536"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85857,
      "file_path": "lib/ansible/executor/module_common.py",
      "line": 1413,
      "side": "RIGHT",
      "diff_hunk": "@@ -1384,16 +1389,28 @@ def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine) -\n         if default.startswith('group/'):\n             group_name = default.split('group/')[-1]\n             if group_name in group_names:\n-                tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n+                if finalize:\n+                    tmp_args.update(templar.template(module_defaults.get(f'group/{group_name}', {})))\n+                else:\n+                    tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n \n     # handle specific action defaults\n-    tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n+    if finalize:\n+        tmp_args.update(templar.template(module_defaults.get(action, {})))\n+    else:\n+        tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n \n     return tmp_args\n \n \n def _apply_action_arg_defaults(action: str, task: Task, action_args: dict[str, t.Any], templar: Templar) -> dict[str, t.Any]:\n-    args = _get_action_arg_defaults(action, task, templar._engine)\n+    \"\"\"\n+    Finalize arguments from module_defaults and update with action_args.\n+\n+    This is used by action plugins like gather_facts, package, and service,\n+    which select modules to execute after normal task argument finalization.\n+    \"\"\"\n+    args = _get_action_arg_defaults(action, task, templar._engine, finalize=True)",
      "comment": "@mattclay That's a good idea, I've pushed an update, but I've noticed another bug that I'm not sure how to fix. Since action_args has already been finalized, using \"{{ omit }}\" results in using the value from module_defaults instead of the argument default value. For example:\r\n\r\n\r\n```yaml\r\n- hosts: localhost\r\n  gather_facts: false\r\n  module_defaults:\r\n    setup:\r\n      gather_subset:\r\n        - \"!all\"\r\n        - min\r\n  tasks:\r\n    - setup:\r\n        gather_subset: \"{{ omit }}\"\r\n    - assert:\r\n       that:\r\n         # succeeds\r\n         - ansible_facts.gather_subset == [\"all\"]\r\n\r\n    - gather_facts:\r\n        gather_subset: \"{{ omit }}\"\r\n    - assert:\r\n        that:\r\n          # fails\r\n          - ansible_facts.gather_subset == [\"all\"]\r\n```",
      "comment_id": 2676945005,
      "user": "s-hertel",
      "created_at": "2026-01-09T17:05:09Z",
      "url": "https://github.com/ansible/ansible/pull/85857#discussion_r2676945005"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85857,
      "file_path": "lib/ansible/executor/module_common.py",
      "line": 1413,
      "side": "RIGHT",
      "diff_hunk": "@@ -1384,16 +1389,28 @@ def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine) -\n         if default.startswith('group/'):\n             group_name = default.split('group/')[-1]\n             if group_name in group_names:\n-                tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n+                if finalize:\n+                    tmp_args.update(templar.template(module_defaults.get(f'group/{group_name}', {})))\n+                else:\n+                    tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n \n     # handle specific action defaults\n-    tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n+    if finalize:\n+        tmp_args.update(templar.template(module_defaults.get(action, {})))\n+    else:\n+        tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n \n     return tmp_args\n \n \n def _apply_action_arg_defaults(action: str, task: Task, action_args: dict[str, t.Any], templar: Templar) -> dict[str, t.Any]:\n-    args = _get_action_arg_defaults(action, task, templar._engine)\n+    \"\"\"\n+    Finalize arguments from module_defaults and update with action_args.\n+\n+    This is used by action plugins like gather_facts, package, and service,\n+    which select modules to execute after normal task argument finalization.\n+    \"\"\"\n+    args = _get_action_arg_defaults(action, task, templar._engine, finalize=True)",
      "comment": "Maybe the expected behavior is debatable, at a minimum I'd expect the two to work the same way. I'm guessing I shouldn't reparse the task ds here, but I don't see a way to access the task arguments here as they were prior to being finalized.",
      "comment_id": 2676966967,
      "user": "s-hertel",
      "created_at": "2026-01-09T17:12:47Z",
      "url": "https://github.com/ansible/ansible/pull/85857#discussion_r2676966967"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85857,
      "file_path": "lib/ansible/executor/module_common.py",
      "line": 1413,
      "side": "RIGHT",
      "diff_hunk": "@@ -1384,16 +1389,28 @@ def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine) -\n         if default.startswith('group/'):\n             group_name = default.split('group/')[-1]\n             if group_name in group_names:\n-                tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n+                if finalize:\n+                    tmp_args.update(templar.template(module_defaults.get(f'group/{group_name}', {})))\n+                else:\n+                    tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n \n     # handle specific action defaults\n-    tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n+    if finalize:\n+        tmp_args.update(templar.template(module_defaults.get(action, {})))\n+    else:\n+        tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n \n     return tmp_args\n \n \n def _apply_action_arg_defaults(action: str, task: Task, action_args: dict[str, t.Any], templar: Templar) -> dict[str, t.Any]:\n-    args = _get_action_arg_defaults(action, task, templar._engine)\n+    \"\"\"\n+    Finalize arguments from module_defaults and update with action_args.\n+\n+    This is used by action plugins like gather_facts, package, and service,\n+    which select modules to execute after normal task argument finalization.\n+    \"\"\"\n+    args = _get_action_arg_defaults(action, task, templar._engine, finalize=True)",
      "comment": "It's not a new bug, so I'd address it in a separate PR. I have a few ideas about how we can fix it, but I need to experiment a little.",
      "comment_id": 2677015350,
      "user": "mattclay",
      "created_at": "2026-01-09T17:26:40Z",
      "url": "https://github.com/ansible/ansible/pull/85857#discussion_r2677015350"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85857,
      "file_path": "lib/ansible/executor/module_common.py",
      "line": 1413,
      "side": "RIGHT",
      "diff_hunk": "@@ -1384,16 +1389,28 @@ def _get_action_arg_defaults(action: str, task: Task, templar: TemplateEngine) -\n         if default.startswith('group/'):\n             group_name = default.split('group/')[-1]\n             if group_name in group_names:\n-                tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n+                if finalize:\n+                    tmp_args.update(templar.template(module_defaults.get(f'group/{group_name}', {})))\n+                else:\n+                    tmp_args.update(templar.resolve_to_container(module_defaults.get(f'group/{group_name}', {})))\n \n     # handle specific action defaults\n-    tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n+    if finalize:\n+        tmp_args.update(templar.template(module_defaults.get(action, {})))\n+    else:\n+        tmp_args.update(templar.resolve_to_container(module_defaults.get(action, {})))\n \n     return tmp_args\n \n \n def _apply_action_arg_defaults(action: str, task: Task, action_args: dict[str, t.Any], templar: Templar) -> dict[str, t.Any]:\n-    args = _get_action_arg_defaults(action, task, templar._engine)\n+    \"\"\"\n+    Finalize arguments from module_defaults and update with action_args.\n+\n+    This is used by action plugins like gather_facts, package, and service,\n+    which select modules to execute after normal task argument finalization.\n+    \"\"\"\n+    args = _get_action_arg_defaults(action, task, templar._engine, finalize=True)",
      "comment": ":relieved: So it is, I thought it had broken in 2.19.",
      "comment_id": 2677084251,
      "user": "s-hertel",
      "created_at": "2026-01-09T17:49:12Z",
      "url": "https://github.com/ansible/ansible/pull/85857#discussion_r2677084251"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86341,
      "file_path": "lib/ansible/cli/galaxy.py",
      "line": 1614,
      "side": "RIGHT",
      "diff_hunk": "@@ -1610,8 +1610,8 @@ def execute_list_role(self):\n             display.warning(w)\n \n         if not path_found:\n-            raise AnsibleOptionsError(\n-                \"- None of the provided paths were usable. Please specify a valid path with --{0}s-path\".format(context.CLIARGS['type'])\n+            display.warning(\n+                \"None of the provided paths were usable. Please specify a valid path with --{0}s-path.\".format(context.CLIARGS['type'])",
      "comment": "```suggestion\r\n                f\"None of the provided paths were usable. Please specify a valid path with --{context.CLIARGS['type']}s-path.\"\r\n```",
      "comment_id": 2669128263,
      "user": "webknjaz",
      "created_at": "2026-01-07T16:24:22Z",
      "url": "https://github.com/ansible/ansible/pull/86341#discussion_r2669128263"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86341,
      "file_path": "lib/ansible/cli/galaxy.py",
      "line": 1699,
      "side": "RIGHT",
      "diff_hunk": "@@ -1695,8 +1695,8 @@ def execute_list_collection(self, artifacts_manager=None):\n             display.warning(w)\n \n         if not collections and not path_found:\n-            raise AnsibleOptionsError(\n-                \"- None of the provided paths were usable. Please specify a valid path with --{0}s-path\".format(context.CLIARGS['type'])\n+            display.warning(\n+                \"None of the provided paths were usable. Please specify a valid path with --{0}s-path.\".format(context.CLIARGS['type'])",
      "comment": "```suggestion\r\n                f\"None of the provided paths were usable. Please specify a valid path with --{context.CLIARGS['type']}s-path.\"\r\n```",
      "comment_id": 2669129233,
      "user": "webknjaz",
      "created_at": "2026-01-07T16:24:41Z",
      "url": "https://github.com/ansible/ansible/pull/86341#discussion_r2669129233"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86123,
      "file_path": "lib/ansible/modules/dnf5.py",
      "line": 807,
      "side": "RIGHT",
      "diff_hunk": "@@ -803,9 +803,14 @@ def run(self):\n                         rc=1,\n                     )\n                 elif result != libdnf5.base.Transaction.TransactionRunResult_SUCCESS:\n+                    if result == libdnf5.base.Transaction.TransactionRunResult_ERROR_RPM_RUN:\n+                        failures = [transaction.get_rpm_messages()]",
      "comment": "`get_rpm_messages` was introduced in `5.2.7.0` (https://github.com/rpm-software-management/dnf5/commit/541a8479bb26af7c3ba7e8e71e82f9ab0abf924f) so we should have some kind of fallback for when it is not available. Does `get_transaction_problems` or `get_problems` or $other return anything for such failures?\n\nAlso, `get_rpm_messages` already returns an iterable so storing it in a list is not what we want, no? I would do something similar to what we do in the `else` branch below, depending on what `get_rpm_messages` individual items are. And since tests didn't catch it we should have something asserting an item in the `failures` list too.",
      "comment_id": 2494862621,
      "user": "mkrizek",
      "created_at": "2025-11-05T14:46:52Z",
      "url": "https://github.com/ansible/ansible/pull/86123#discussion_r2494862621"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86123,
      "file_path": "lib/ansible/modules/dnf5.py",
      "line": 812,
      "side": "RIGHT",
      "diff_hunk": "@@ -803,9 +803,18 @@ def run(self):\n                         rc=1,\n                     )\n                 elif result != libdnf5.base.Transaction.TransactionRunResult_SUCCESS:\n+                    failures = []\n+                    if result == libdnf5.base.Transaction.TransactionRunResult_ERROR_RPM_RUN:\n+                        try:\n+                            failures = transaction.get_rpm_messages()\n+                        except AttributeError:\n+                            pass",
      "comment": "Can you add an explaining comment that `get_rpm_messages` is available in a specific version?",
      "comment_id": 2564726118,
      "user": "mkrizek",
      "created_at": "2025-11-26T12:03:29Z",
      "url": "https://github.com/ansible/ansible/pull/86123#discussion_r2564726118"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86123,
      "file_path": "lib/ansible/modules/dnf5.py",
      "line": 813,
      "side": "RIGHT",
      "diff_hunk": "@@ -803,9 +803,19 @@ def run(self):\n                         rc=1,\n                     )\n                 elif result != libdnf5.base.Transaction.TransactionRunResult_SUCCESS:\n+                    failures = []\n+                    if result == libdnf5.base.Transaction.TransactionRunResult_ERROR_RPM_RUN:\n+                        try:\n+                            failures = transaction.get_rpm_messages()\n+                        except AttributeError:\n+                            # get_rpm_messages is not available in dnf5 < 5.2.7.0\n+                            pass\n+                    if not failures:",
      "comment": "It just occurred to me that we could probably extend `failures` with what we do below in every case (even with `get_rpm_messages` being called)? I suppose it wouldn't hurt to pass more information to the user.",
      "comment_id": 2584379344,
      "user": "mkrizek",
      "created_at": "2025-12-03T09:48:04Z",
      "url": "https://github.com/ansible/ansible/pull/86123#discussion_r2584379344"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85498,
      "file_path": "lib/ansible/plugins/doc_fragments/result_format_callback.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,6 +40,24 @@ class ModuleDocFragment(object):\n         ini:\n           - key: callback_result_indentation\n             section: defaults\n+      result_yaml_line_width:\n+        name: Line width of YAML output\n+        description:\n+          - Configure the line width used for YAML. The YAML serializer will try to break longer lines.\n+          - Set to V(default) for the PyYAML's default value, which is around 80 characters.\n+          - Set to V(no-break) to disable line breaks.\n+          - Set to V(terminal-width) to use the detected terminal width that is also used for other output of this callback.\n+        type: str\n+        default: default\n+        choices:\n+          - default\n+          - no-break\n+          - terminal-width\n+        env:\n+          - name: ANSIBLE_CALLBACK_YAML_LINE_WIDTH\n+        ini:\n+          - key: callback_result_yaml_line_width\n+            section: defaults\n         version_added: '2.20'",
      "comment": "did this just take the 'version_added' from the previous entry?",
      "comment_id": 2330313756,
      "user": "bcoca",
      "created_at": "2025-09-08T13:49:02Z",
      "url": "https://github.com/ansible/ansible/pull/85498#discussion_r2330313756"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85498,
      "file_path": "lib/ansible/plugins/doc_fragments/result_format_callback.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,6 +40,24 @@ class ModuleDocFragment(object):\n         ini:\n           - key: callback_result_indentation\n             section: defaults\n+      result_yaml_line_width:\n+        name: Line width of YAML output\n+        description:\n+          - Configure the line width used for YAML. The YAML serializer will try to break longer lines.\n+          - Set to V(default) for the PyYAML's default value, which is around 80 characters.\n+          - Set to V(no-break) to disable line breaks.\n+          - Set to V(terminal-width) to use the detected terminal width that is also used for other output of this callback.\n+        type: str\n+        default: default\n+        choices:\n+          - default\n+          - no-break\n+          - terminal-width\n+        env:\n+          - name: ANSIBLE_CALLBACK_YAML_LINE_WIDTH\n+        ini:\n+          - key: callback_result_yaml_line_width\n+            section: defaults\n         version_added: '2.20'",
      "comment": "That wasn't intentional. I fixed it in another rebase.",
      "comment_id": 2331062752,
      "user": "felixfontein",
      "created_at": "2025-09-08T18:36:01Z",
      "url": "https://github.com/ansible/ansible/pull/85498#discussion_r2331062752"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85498,
      "file_path": "lib/ansible/plugins/callback/__init__.py",
      "line": 272,
      "side": "RIGHT",
      "diff_hunk": "@@ -262,6 +262,24 @@ def _run_is_verbose(self, result: CallbackTaskResult, verbosity: int = 0) -> boo\n         return ((self._display.verbosity > verbosity or result.result.get('_ansible_verbose_always', False) is True)\n                 and result.result.get('_ansible_verbose_override', False) is False)\n \n+    def _get_yaml_width(self) -> t.Optional[int]:\n+        try:\n+            yaml_line_width = self.get_option('result_yaml_line_width')\n+        except KeyError:\n+            # Callback does not declare result_yaml_line_width nor extend result_format_callback\n+            return None\n+\n+        if yaml_line_width == 'default':",
      "comment": "not a blocker, but a `match/case`   might be a nicer pattern here",
      "comment_id": 2628405997,
      "user": "bcoca",
      "created_at": "2025-12-17T19:41:09Z",
      "url": "https://github.com/ansible/ansible/pull/85498#discussion_r2628405997"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 85498,
      "file_path": "lib/ansible/plugins/doc_fragments/result_format_callback.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,6 +41,25 @@ class ModuleDocFragment(object):\n           - key: callback_result_indentation\n             section: defaults\n         version_added: '2.20'\n+      result_yaml_line_width:\n+        name: Line width of YAML output\n+        description:\n+          - Configure the line width used for YAML. The YAML serializer will try to break longer lines.\n+          - Set to V(default) for the PyYAML's default value, which is around 80 characters.\n+          - Set to V(no-break) to disable line breaks.\n+          - Set to V(terminal-width) to use the detected terminal width that is also used for other output of this callback.\n+        type: str\n+        default: default\n+        choices:\n+          - default",
      "comment": "instead of the description of each choice in the general description, add it to each choice (as dict instead of list) ",
      "comment_id": 2628408149,
      "user": "bcoca",
      "created_at": "2025-12-17T19:41:58Z",
      "url": "https://github.com/ansible/ansible/pull/85498#discussion_r2628408149"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86234,
      "file_path": "lib/ansible/vars/manager.py",
      "line": 319,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,8 +316,7 @@ def plugins_by_groups():\n \n             for vars_file_item in vars_files:\n                 # create a set of temporary vars here, which incorporate the extra\n-                # and magic vars so we can properly template the vars_files entries\n-                # NOTE: this makes them depend on host vars/facts so things like\n+                # and magic vars so we can properly template the vars_files entries # NOTE: this makes them depend on host vars/facts so things like",
      "comment": "It looks like the second half of this comment was supposed to be on the next line down.",
      "comment_id": 2548088482,
      "user": "mattclay",
      "created_at": "2025-11-20T23:58:35Z",
      "url": "https://github.com/ansible/ansible/pull/86234#discussion_r2548088482"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86171,
      "file_path": "lib/ansible/modules/deb822_repository.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,6 +62,18 @@\n         description:\n         - Tells APT whether the source is enabled or not.\n         type: bool\n+    exclude:\n+        description:\n+        - Controls which packages APT should use from the repository.",
      "comment": "I believe you have the descriptions reversed between include/exclude/",
      "comment_id": 2514832592,
      "user": "sivel",
      "created_at": "2025-11-11T16:15:33Z",
      "url": "https://github.com/ansible/ansible/pull/86171#discussion_r2514832592"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86171,
      "file_path": "lib/ansible/modules/deb822_repository.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,6 +62,20 @@\n         description:\n         - Tells APT whether the source is enabled or not.\n         type: bool\n+    exclude:\n+        description:\n+        - Controls which packages APT should not use from the repository.",
      "comment": "```suggestion\r\n        - Controls which packages C(APT) should excludes from the repository.\r\n```",
      "comment_id": 2515042209,
      "user": "Akasurde",
      "created_at": "2025-11-11T17:21:37Z",
      "url": "https://github.com/ansible/ansible/pull/86171#discussion_r2515042209"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86171,
      "file_path": "lib/ansible/modules/deb822_repository.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,6 +62,20 @@\n         description:\n         - Tells APT whether the source is enabled or not.\n         type: bool\n+    exclude:\n+        description:\n+        - Controls which packages APT should not use from the repository.\n+        - Mutually exclusive with O(include).\n+        type: list\n+        elements: str\n+        version_added: '2.21'\n+    include:\n+        description:\n+        - Controls which packages APT should use from the repository.",
      "comment": "```suggestion\r\n        - Controls which packages C(APT) should use from the repository.\r\n```",
      "comment_id": 2515051313,
      "user": "Akasurde",
      "created_at": "2025-11-11T17:24:41Z",
      "url": "https://github.com/ansible/ansible/pull/86171#discussion_r2515051313"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86171,
      "file_path": "lib/ansible/modules/deb822_repository.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,6 +62,20 @@\n         description:\n         - Tells APT whether the source is enabled or not.\n         type: bool\n+    exclude:",
      "comment": "Please create a [changelog fragment](https://docs.ansible.com/ansible/latest/community/development_process.html#creating-a-changelog-fragment). See [this fragment](https://github.com/ansible/ansible/blob/c2f528b7686c9573aa8493357219e0bbe4416dd3/changelogs/fragments/reboot-change-default-boot-command.yaml) as an example. And test for this change.",
      "comment_id": 2515053194,
      "user": "Akasurde",
      "created_at": "2025-11-11T17:25:24Z",
      "url": "https://github.com/ansible/ansible/pull/86171#discussion_r2515053194"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86171,
      "file_path": "lib/ansible/modules/deb822_repository.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,6 +62,20 @@\n         description:\n         - Tells APT whether the source is enabled or not.\n         type: bool\n+    exclude:",
      "comment": "> And test for this change.\r\n\r\nWhat do you mean by that?",
      "comment_id": 2517801633,
      "user": "FestplattenSchnitzel",
      "created_at": "2025-11-12T10:40:53Z",
      "url": "https://github.com/ansible/ansible/pull/86171#discussion_r2517801633"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86171,
      "file_path": "lib/ansible/modules/deb822_repository.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,6 +62,20 @@\n         description:\n         - Tells APT whether the source is enabled or not.\n         type: bool\n+    exclude:",
      "comment": "Something like this in https://github.com/ansible/ansible/blob/dc3cc0f9ea4d5e3ada1e21f197962c81c9ebfd60/test/integration/targets/deb822_repository/tasks/install.yml#L36 \r\n\r\n```yaml\r\n---\r\n- hosts: debian\r\n  tasks:\r\n    - block:\r\n      - name: Remove repo\r\n        deb822_repository:\r\n          name: debian\r\n          state: absent\r\n      \r\n      - deb822_repository:\r\n          name: debian\r\n          types: deb\r\n          uris: file:///tmp/repo \r\n          suites: stable\r\n          components:\r\n            - main\r\n          architectures: all\r\n          exclude:\r\n              - foo\r\n          trusted: yes\r\n        register: deb822_add_repo\r\n\r\n      - name: Update apt cache\r\n        apt:\r\n          update_cache: yes\r\n        when: deb822_add_repo is changed\r\n\r\n      - name: Install package from local repo\r\n        apt:\r\n          name: foo=1.0.0\r\n        register: deb822_install_pkg_exclude \r\n        ignore_errors: true\r\n\r\n      - name: Check if package was not installed\r\n        shell: dpkg-query -l foo\r\n        register: deb822_install_pkg_exclude_result\r\n        ignore_errors: true\r\n      - assert:\r\n          that:\r\n            - deb822_install_pkg_exclude is failed\r\n            - \"'no packages found matching foo' in deb822_install_pkg_exclude_result.stderr\"\r\n\r\n      when: ansible_facts[\"distribution\"] == 'Ubuntu' and ansible_facts[\"distribution_version\"] is version('25.10', '>=')\r\n```",
      "comment_id": 2519407253,
      "user": "Akasurde",
      "created_at": "2025-11-12T18:44:02Z",
      "url": "https://github.com/ansible/ansible/pull/86171#discussion_r2519407253"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86171,
      "file_path": "lib/ansible/modules/deb822_repository.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,6 +62,20 @@\n         description:\n         - Tells APT whether the source is enabled or not.\n         type: bool\n+    exclude:",
      "comment": "Added the tests however the CI doesn't seem run tests on Ubuntu 25.10 or Debian Unstable so they're not being run.",
      "comment_id": 2527381457,
      "user": "FestplattenSchnitzel",
      "created_at": "2025-11-14T12:46:21Z",
      "url": "https://github.com/ansible/ansible/pull/86171#discussion_r2527381457"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86219,
      "file_path": "lib/ansible/modules/dnf.py",
      "line": 709,
      "side": "LEFT",
      "diff_hunk": "@@ -706,7 +706,10 @@ def list_items(self, command):\n         self.module.exit_json(msg=\"\", results=results)\n \n     def _is_installed(self, pkg):\n-        return bool(dnf.subject.Subject(pkg).get_best_query(sack=self.base.sack).installed())",
      "comment": "What's the purpose of changing this function? I ran the tests without this change and nothing failed",
      "comment_id": 2539957865,
      "user": "pkingstonxyz",
      "created_at": "2025-11-18T23:36:50Z",
      "url": "https://github.com/ansible/ansible/pull/86219#discussion_r2539957865"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86219,
      "file_path": "lib/ansible/modules/dnf.py",
      "line": 709,
      "side": "LEFT",
      "diff_hunk": "@@ -706,7 +706,10 @@ def list_items(self, command):\n         self.module.exit_json(msg=\"\", results=results)\n \n     def _is_installed(self, pkg):\n-        return bool(dnf.subject.Subject(pkg).get_best_query(sack=self.base.sack).installed())",
      "comment": "You are correct. This can be removed now. It was left over from trying to harmonize the implementations, but then the other needed something different in the end.\n\nI'll get it removed in a little.",
      "comment_id": 2547360773,
      "user": "sivel",
      "created_at": "2025-11-20T19:17:12Z",
      "url": "https://github.com/ansible/ansible/pull/86219#discussion_r2547360773"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86219,
      "file_path": "lib/ansible/modules/dnf.py",
      "line": 726,
      "side": "RIGHT",
      "diff_hunk": "@@ -717,9 +720,18 @@ def _is_newer_version_installed(self, pkg_spec):\n             else:\n                 solution = dnf.subject.Subject(pkg_spec).get_best_solution(self.base.sack)\n                 q = solution[\"query\"]\n-                if not q or not solution['nevra'] or solution['nevra'].has_just_name():\n+                if not q or not solution['nevra']:\n+                    return False\n+                nevra = solution['nevra']\n+                if nevra.has_just_name() or not nevra.version:",
      "comment": "We can move the `nevra` assignment/binding before the first `if` or just stick all of it (lines 723-726) under one `if`:\n```python\nnevra = solution['nevra']\nif not q or not nevra or nevra.has_just_name() or not nevra.version:\n    return False\n```\n\nApologies for nitpicking :-)",
      "comment_id": 2564784556,
      "user": "mkrizek",
      "created_at": "2025-11-26T12:20:37Z",
      "url": "https://github.com/ansible/ansible/pull/86219#discussion_r2564784556"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86141,
      "file_path": "lib/ansible/plugins/connection/ssh.py",
      "line": 618,
      "side": "RIGHT",
      "diff_hunk": "@@ -626,11 +614,17 @@ def wrapped(self: Connection, *args: P.args, **kwargs: P.kwargs) -> tuple[int, b\n     return wrapped\n \n \n-def _clean_shm(func):\n+def _clean_resources(func):\n+    @wraps(func)",
      "comment": "Maybe not related to this PR, but this should probably be rewritten via `@contextlib.contextmanager`.",
      "comment_id": 2514658700,
      "user": "webknjaz",
      "created_at": "2025-11-11T15:27:29Z",
      "url": "https://github.com/ansible/ansible/pull/86141#discussion_r2514658700"
    },
    {
      "repo": "ansible/ansible",
      "pr_number": 86277,
      "file_path": "lib/ansible/vars/manager.py",
      "line": 361,
      "side": "RIGHT",
      "diff_hunk": "@@ -349,18 +349,16 @@ def plugins_by_groups():\n                             data = preprocess_vars(self._loader.load_from_file(found_file, unsafe=True, cache='vaulted', trusted_as_template=True))\n                             if data is not None:\n                                 for item in data:\n-                                    all_vars = _combine_and_track(all_vars, item, \"play vars_files from '%s'\" % vars_file)\n+                                    all_vars = _combine_and_track(all_vars, item, f\"play vars_files from {vars_file!r}\")\n                             display.vvv(f\"Read `vars_file` {found_file!r}.\")\n                             break\n                         except AnsibleFileNotFound:\n                             # we continue on loader failures\n                             continue\n-                        except AnsibleParserError:\n+                        except (AnsibleParserError, AnsibleUndefinedVariable):\n                             raise\n-                        except AnsibleUndefinedVariable:\n-                            raise\n-                        except Exception as ex:\n-                            raise AnsibleParserError(f\"Error reading `vars_files` file {vars_file!r}.\", obj=vars_file) from ex\n+                        except AnsibleError as e:\n+                            raise AnsibleError(f\"Invalid vars_file {found_file!r}.\") from e",
      "comment": "```suggestion\r\n                            raise AnsibleError(f\"Invalid vars_files file {found_file!r}.\") from e\r\n```",
      "comment_id": 2582721434,
      "user": "Akasurde",
      "created_at": "2025-12-02T20:42:58Z",
      "url": "https://github.com/ansible/ansible/pull/86277#discussion_r2582721434"
    }
  ]
}