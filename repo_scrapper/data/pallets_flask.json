{
  "repo": "pallets/flask",
  "scraped_at": "2026-02-03T10:55:53.274973",
  "stats": {
    "total_comments": 63,
    "filtered": {
      "too_short": 17,
      "not_python": 28
    },
    "kept": 18
  },
  "examples": [
    {
      "repo": "pallets/flask",
      "pr_number": 2635,
      "file_path": "flask/app.py",
      "line": 1975,
      "side": "RIGHT",
      "diff_hunk": "@@ -1963,8 +1970,15 @@ def create_url_adapter(self, request):\n            URL adapter is created for the application context.\n         \"\"\"\n         if request is not None:\n-            return self.url_map.bind_to_environ(request.environ,\n+            rv = self.url_map.bind_to_environ(request.environ,\n                 server_name=self.config['SERVER_NAME'])\n+            # If subdomain matching is not enabled (which is the default",
      "comment": "Note that this line is missing a closing parenthesis",
      "comment_id": 169991222,
      "user": "Derrreks",
      "created_at": "2018-02-22T15:21:01Z",
      "url": "https://github.com/pallets/flask/pull/2635#discussion_r169991222"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 5127,
      "file_path": "src/flask/_static_mixin.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from __future__ import annotations\n+\n+import os\n+import typing as t\n+\n+from .helpers import send_from_directory\n+\n+if t.TYPE_CHECKING:  # pragma: no cover\n+    from .wrappers import Response\n+\n+\n+class ScaffoldMixin(t.Protocol):\n+    has_static_folder: bool\n+    root_path: str\n+    static_folder: str | None\n+\n+    def get_send_file_max_age(self, filename: str | None) -> int | None:\n+        ...\n+\n+\n+class _StaticMixin:",
      "comment": "Remove, implement in Blueprint and Flask (dupe is ok).\r\nNote \"This isn't Sansio, hence dupe in docstring\"",
      "comment_id": 1221931650,
      "user": "pgjones",
      "created_at": "2023-06-07T17:10:57Z",
      "url": "https://github.com/pallets/flask/pull/5127#discussion_r1221931650"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 5127,
      "file_path": "src/flask/app.py",
      "line": 229,
      "side": "RIGHT",
      "diff_hunk": "@@ -365,124 +226,18 @@ def __init__(\n         root_path: str | None = None,\n     ):\n         super().__init__(\n-            import_name=import_name,\n-            static_folder=static_folder,\n-            static_url_path=static_url_path,\n-            template_folder=template_folder,\n-            root_path=root_path,\n+            import_name,",
      "comment": "It's annoying to write, but these should be passed as keyword arguments, I don't like to rely on positions.",
      "comment_id": 1299206826,
      "user": "davidism",
      "created_at": "2023-08-19T14:41:44Z",
      "url": "https://github.com/pallets/flask/pull/5127#discussion_r1299206826"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4992,
      "file_path": "src/flask/config.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,7 +246,7 @@ def from_file(\n             app.config.from_file(\"config.json\", load=json.load)\n \n             import toml\n-            app.config.from_file(\"config.toml\", load=toml.load)\n+            app.config.from_file(\"config.toml\", load=toml.load, text=True)",
      "comment": "this parameter is a absolute lie - when true you take away the text and drop a buffer\r\n\r\nthis should be called `binary`\r\n\r\nand it should use the open mode ",
      "comment_id": 1114374958,
      "user": "RonnyPfannschmidt",
      "created_at": "2023-02-22T14:08:32Z",
      "url": "https://github.com/pallets/flask/pull/4992#discussion_r1114374958"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4992,
      "file_path": "src/flask/config.py",
      "line": 270,
      "side": "RIGHT",
      "diff_hunk": "@@ -256,12 +257,18 @@ def from_file(\n         :param silent: Ignore the file if it doesn't exist.\n         :return: ``True`` if the file was loaded successfully.\n \n+        .. versionchanged:: 2.3.0\n+            Added optional boolean argument \"text\" (False by default).\n+            You can now use .toml config file by specifying \"text=True\".\n+\n         .. versionadded:: 2.0\n         \"\"\"\n         filename = os.path.join(self.root_path, filename)\n \n         try:\n             with open(filename) as f:\n+                if text:",
      "comment": "This should change what `open` does, not try to access `buffer` after the fact (someone else pointed out this wasn't documented as a public API).\r\n\r\nAlso, it's backwards, `text=True`, the default, should result in a text file, `False` should result in a binary file.",
      "comment_id": 1114375396,
      "user": "davidism",
      "created_at": "2023-02-22T14:08:51Z",
      "url": "https://github.com/pallets/flask/pull/4992#discussion_r1114375396"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4992,
      "file_path": "src/flask/config.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,7 +246,7 @@ def from_file(\n             app.config.from_file(\"config.json\", load=json.load)\n \n             import toml\n-            app.config.from_file(\"config.toml\", load=toml.load)\n+            app.config.from_file(\"config.toml\", load=toml.load, text=True)",
      "comment": "This still uses the `toml` library, it needs to change to `tomllib` to be a useful example of the parameter.",
      "comment_id": 1114380087,
      "user": "davidism",
      "created_at": "2023-02-22T14:11:52Z",
      "url": "https://github.com/pallets/flask/pull/4992#discussion_r1114380087"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4840,
      "file_path": "tests/test_templating.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,6 +114,18 @@ def test_escaping_without_template_filename(app, client, req_ctx):\n     assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n \n \n+def test_escaping_svg(app, client):",
      "comment": "Don't need this test, it's just testing that Jinja works. At most, you wouuld test that `app.select_jinja_autoescape` returned `True` for a `.svg` filename.",
      "comment_id": 998530715,
      "user": "davidism",
      "created_at": "2022-10-18T17:39:09Z",
      "url": "https://github.com/pallets/flask/pull/4840#discussion_r998530715"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4692,
      "file_path": "src/flask/json/provider.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,310 @@\n+from __future__ import annotations\n+\n+import dataclasses\n+import decimal\n+import json\n+import typing as t\n+import uuid\n+import weakref\n+from datetime import date\n+\n+from werkzeug.http import http_date\n+\n+from ..globals import request\n+\n+if t.TYPE_CHECKING:  # pragma: no cover\n+    from ..app import Flask\n+    from ..wrappers import Response\n+\n+\n+class JSONProvider:\n+    \"\"\"A standard set of JSON operations for an application. Subclasses\n+    of this can be used to customize JSON behavior or use different\n+    JSON libraries.\n+\n+    To implement a provider for a specific library, subclass this base\n+    class and implement at least :meth:`dumps` and :meth:`loads`. All\n+    other methods have default implementations.\n+\n+    To use a different provider, either subclass ``Flask`` and set\n+    :attr:`~flask.Flask.json_provider_class` to a provider class, or set\n+    :attr:`app.json <flask.Flask.json>` to an instance of the class.\n+\n+    :param app: An application instance. This will be stored as a\n+        :class:`weakref.proxy` on the :attr:`_app` attribute.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+\n+    def __init__(self, app: Flask) -> None:\n+        self._app = weakref.proxy(app)\n+\n+    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n+        \"\"\"Serialize data as JSON.\n+\n+        :param obj: The data to serialize.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n+        \"\"\"Serialize data as JSON and write to a file.\n+\n+        :param obj: The data to serialize.\n+        :param fp: A file opened for writing text. Should use the UTF-8\n+            encoding to be valid JSON.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        fp.write(self.dumps(obj, **kwargs))\n+\n+    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON.\n+\n+        :param s: Text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON read from a file.\n+\n+        :param fp: A file opened for reading text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        return self.loads(fp.read(), **kwargs)\n+\n+    def _prepare_response_obj(\n+        self, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]\n+    ) -> t.Any:\n+        if args and kwargs:\n+            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n+\n+        if not args and not kwargs:\n+            return None\n+\n+        if len(args) == 1:\n+            return args[0]\n+\n+        return args or kwargs\n+\n+    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n+        \"\"\"Serialize the given arguments as JSON, and return a\n+        :class:`~flask.Response` object with the ``application/json``\n+        mimetype.\n+\n+        The :func:`~flask.json.jsonify` function calls this method for\n+        the current application.\n+\n+        Either positional or keyword arguments can be given, not both.\n+        If no arguments are given, ``None`` is serialized.\n+\n+        :param args: A single value to serialize, or multiple values to\n+            treat as a list to serialize.\n+        :param kwargs: Treat as a dict to serialize.\n+        \"\"\"\n+        obj = self._prepare_response_obj(args, kwargs)\n+        return self._app.response_class(self.dumps(obj), mimetype=\"application/json\")",
      "comment": "Worth a cls default_mimetype here to save extensions having to override this method and as matching with responses?",
      "comment_id": 920306595,
      "user": "pgjones",
      "created_at": "2022-07-13T16:55:07Z",
      "url": "https://github.com/pallets/flask/pull/4692#discussion_r920306595"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4692,
      "file_path": "src/flask/json/provider.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,310 @@\n+from __future__ import annotations\n+\n+import dataclasses\n+import decimal\n+import json\n+import typing as t\n+import uuid\n+import weakref\n+from datetime import date\n+\n+from werkzeug.http import http_date\n+\n+from ..globals import request\n+\n+if t.TYPE_CHECKING:  # pragma: no cover\n+    from ..app import Flask\n+    from ..wrappers import Response\n+\n+\n+class JSONProvider:\n+    \"\"\"A standard set of JSON operations for an application. Subclasses\n+    of this can be used to customize JSON behavior or use different\n+    JSON libraries.\n+\n+    To implement a provider for a specific library, subclass this base\n+    class and implement at least :meth:`dumps` and :meth:`loads`. All\n+    other methods have default implementations.\n+\n+    To use a different provider, either subclass ``Flask`` and set\n+    :attr:`~flask.Flask.json_provider_class` to a provider class, or set\n+    :attr:`app.json <flask.Flask.json>` to an instance of the class.\n+\n+    :param app: An application instance. This will be stored as a\n+        :class:`weakref.proxy` on the :attr:`_app` attribute.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+\n+    def __init__(self, app: Flask) -> None:\n+        self._app = weakref.proxy(app)\n+\n+    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n+        \"\"\"Serialize data as JSON.\n+\n+        :param obj: The data to serialize.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n+        \"\"\"Serialize data as JSON and write to a file.\n+\n+        :param obj: The data to serialize.\n+        :param fp: A file opened for writing text. Should use the UTF-8\n+            encoding to be valid JSON.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        fp.write(self.dumps(obj, **kwargs))\n+\n+    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON.\n+\n+        :param s: Text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON read from a file.\n+\n+        :param fp: A file opened for reading text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        return self.loads(fp.read(), **kwargs)\n+\n+    def _prepare_response_obj(\n+        self, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]\n+    ) -> t.Any:\n+        if args and kwargs:\n+            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n+\n+        if not args and not kwargs:\n+            return None\n+\n+        if len(args) == 1:\n+            return args[0]\n+\n+        return args or kwargs\n+\n+    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n+        \"\"\"Serialize the given arguments as JSON, and return a\n+        :class:`~flask.Response` object with the ``application/json``\n+        mimetype.\n+\n+        The :func:`~flask.json.jsonify` function calls this method for\n+        the current application.\n+\n+        Either positional or keyword arguments can be given, not both.\n+        If no arguments are given, ``None`` is serialized.\n+\n+        :param args: A single value to serialize, or multiple values to\n+            treat as a list to serialize.\n+        :param kwargs: Treat as a dict to serialize.\n+        \"\"\"\n+        obj = self._prepare_response_obj(args, kwargs)\n+        return self._app.response_class(self.dumps(obj), mimetype=\"application/json\")",
      "comment": "Discussed this more here: https://github.com/pallets/flask/pull/1728#issuecomment-1181806155\r\n\r\nI'm not sure this should actually be configurable at all. The original issue seemed to be about a specific type of response, not all JSON responses. *Maybe* if you want your whole API to have a different vendor type, like GitHub does, but even GitHub applies different mimetypes to different parts. APIs complex enough to use vendor types usually have versioning as well, so they still wouldn't apply globally.\r\n\r\nI did originally have this as a `JSONProvider.mimetype` attribute, but I ended up moving all existing behavior to `DefaultProvider` and keeping the base very simple.",
      "comment_id": 920311369,
      "user": "davidism",
      "created_at": "2022-07-13T17:00:28Z",
      "url": "https://github.com/pallets/flask/pull/4692#discussion_r920311369"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4692,
      "file_path": "src/flask/json/provider.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,310 @@\n+from __future__ import annotations\n+\n+import dataclasses\n+import decimal\n+import json\n+import typing as t\n+import uuid\n+import weakref\n+from datetime import date\n+\n+from werkzeug.http import http_date\n+\n+from ..globals import request\n+\n+if t.TYPE_CHECKING:  # pragma: no cover\n+    from ..app import Flask\n+    from ..wrappers import Response\n+\n+\n+class JSONProvider:\n+    \"\"\"A standard set of JSON operations for an application. Subclasses\n+    of this can be used to customize JSON behavior or use different\n+    JSON libraries.\n+\n+    To implement a provider for a specific library, subclass this base\n+    class and implement at least :meth:`dumps` and :meth:`loads`. All\n+    other methods have default implementations.\n+\n+    To use a different provider, either subclass ``Flask`` and set\n+    :attr:`~flask.Flask.json_provider_class` to a provider class, or set\n+    :attr:`app.json <flask.Flask.json>` to an instance of the class.\n+\n+    :param app: An application instance. This will be stored as a\n+        :class:`weakref.proxy` on the :attr:`_app` attribute.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+\n+    def __init__(self, app: Flask) -> None:\n+        self._app = weakref.proxy(app)\n+\n+    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n+        \"\"\"Serialize data as JSON.\n+\n+        :param obj: The data to serialize.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n+        \"\"\"Serialize data as JSON and write to a file.\n+\n+        :param obj: The data to serialize.\n+        :param fp: A file opened for writing text. Should use the UTF-8\n+            encoding to be valid JSON.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        fp.write(self.dumps(obj, **kwargs))\n+\n+    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON.\n+\n+        :param s: Text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON read from a file.\n+\n+        :param fp: A file opened for reading text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        return self.loads(fp.read(), **kwargs)\n+\n+    def _prepare_response_obj(\n+        self, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]\n+    ) -> t.Any:\n+        if args and kwargs:\n+            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n+\n+        if not args and not kwargs:\n+            return None\n+\n+        if len(args) == 1:\n+            return args[0]\n+\n+        return args or kwargs\n+\n+    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n+        \"\"\"Serialize the given arguments as JSON, and return a\n+        :class:`~flask.Response` object with the ``application/json``\n+        mimetype.\n+\n+        The :func:`~flask.json.jsonify` function calls this method for\n+        the current application.\n+\n+        Either positional or keyword arguments can be given, not both.\n+        If no arguments are given, ``None`` is serialized.\n+\n+        :param args: A single value to serialize, or multiple values to\n+            treat as a list to serialize.\n+        :param kwargs: Treat as a dict to serialize.\n+        \"\"\"\n+        obj = self._prepare_response_obj(args, kwargs)\n+        return self._app.response_class(self.dumps(obj), mimetype=\"application/json\")",
      "comment": "@davidism, maybe add your orjson example to the documentation?",
      "comment_id": 920417062,
      "user": "Yourun-proger",
      "created_at": "2022-07-13T19:11:17Z",
      "url": "https://github.com/pallets/flask/pull/4692#discussion_r920417062"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4692,
      "file_path": "src/flask/json/provider.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,310 @@\n+from __future__ import annotations\n+\n+import dataclasses\n+import decimal\n+import json\n+import typing as t\n+import uuid\n+import weakref\n+from datetime import date\n+\n+from werkzeug.http import http_date\n+\n+from ..globals import request\n+\n+if t.TYPE_CHECKING:  # pragma: no cover\n+    from ..app import Flask\n+    from ..wrappers import Response\n+\n+\n+class JSONProvider:\n+    \"\"\"A standard set of JSON operations for an application. Subclasses\n+    of this can be used to customize JSON behavior or use different\n+    JSON libraries.\n+\n+    To implement a provider for a specific library, subclass this base\n+    class and implement at least :meth:`dumps` and :meth:`loads`. All\n+    other methods have default implementations.\n+\n+    To use a different provider, either subclass ``Flask`` and set\n+    :attr:`~flask.Flask.json_provider_class` to a provider class, or set\n+    :attr:`app.json <flask.Flask.json>` to an instance of the class.\n+\n+    :param app: An application instance. This will be stored as a\n+        :class:`weakref.proxy` on the :attr:`_app` attribute.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+\n+    def __init__(self, app: Flask) -> None:\n+        self._app = weakref.proxy(app)\n+\n+    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n+        \"\"\"Serialize data as JSON.\n+\n+        :param obj: The data to serialize.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n+        \"\"\"Serialize data as JSON and write to a file.\n+\n+        :param obj: The data to serialize.\n+        :param fp: A file opened for writing text. Should use the UTF-8\n+            encoding to be valid JSON.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        fp.write(self.dumps(obj, **kwargs))\n+\n+    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON.\n+\n+        :param s: Text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON read from a file.\n+\n+        :param fp: A file opened for reading text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        return self.loads(fp.read(), **kwargs)\n+\n+    def _prepare_response_obj(\n+        self, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]\n+    ) -> t.Any:\n+        if args and kwargs:\n+            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n+\n+        if not args and not kwargs:\n+            return None\n+\n+        if len(args) == 1:\n+            return args[0]\n+\n+        return args or kwargs\n+\n+    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n+        \"\"\"Serialize the given arguments as JSON, and return a\n+        :class:`~flask.Response` object with the ``application/json``\n+        mimetype.\n+\n+        The :func:`~flask.json.jsonify` function calls this method for\n+        the current application.\n+\n+        Either positional or keyword arguments can be given, not both.\n+        If no arguments are given, ``None`` is serialized.\n+\n+        :param args: A single value to serialize, or multiple values to\n+            treat as a list to serialize.\n+        :param kwargs: Treat as a dict to serialize.\n+        \"\"\"\n+        obj = self._prepare_response_obj(args, kwargs)\n+        return self._app.response_class(self.dumps(obj), mimetype=\"application/json\")\n+\n+\n+def _default(o: t.Any) -> t.Any:\n+    if isinstance(o, date):\n+        return http_date(o)\n+\n+    if isinstance(o, (decimal.Decimal, uuid.UUID)):\n+        return str(o)\n+\n+    if dataclasses and dataclasses.is_dataclass(o):\n+        return dataclasses.asdict(o)\n+\n+    if hasattr(o, \"__html__\"):\n+        return str(o.__html__())\n+\n+    raise TypeError(f\"Object of type {type(o).__name__} is not JSON serializable\")\n+\n+\n+class DefaultJSONProvider(JSONProvider):\n+    \"\"\"Provide JSON operations using Python's built-in :mod:`json`\n+    library. Serializes the following additional data types:\n+\n+    -   :class:`datetime.datetime` and :class:`datetime.date` are\n+        serialized to :rfc:`822` strings. This is the same as the HTTP\n+        date format.\n+    -   :class:`uuid.UUID` is serialized to a string.\n+    -   :class:`dataclasses.dataclass` is passed to\n+        :func:`dataclasses.asdict`.\n+    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n+        method) will call the ``__html__`` method to get a string.\n+    \"\"\"\n+\n+    default: t.Callable[[t.Any], t.Any] = staticmethod(\n+        _default\n+    )  # type: ignore[assignment]\n+    \"\"\"Apply this function to any object that :meth:`json.dumps` does\n+    not know how to serialize. It should return a valid JSON type or\n+    raise a ``TypeError``.\n+    \"\"\"\n+",
      "comment": "What do you think about adding a dict_to_object hook here as well (for the loads side). Allows something like this,\r\n```python\r\nclass MoneyJSONProvider(DefaultJSONProvider):\r\n\r\n        @staticmethod\r\n        def default(object_):\r\n            if isinstance(object_, date):\r\n                return http_date(object_)\r\n            if isinstance(object_, (Decimal, UUID)):\r\n                return str(object_)\r\n            if is_dataclass(object_):\r\n                return asdict(object_)\r\n            if hasattr(object_, \"__html__\"):\r\n                return str(object_.__html__())\r\n            if isinstance(object_, Money):\r\n                return {'amount': object_.amount, 'currency': object_.currency}\r\n\r\n            raise TypeError(f\"Object of type {type(object_).__name__} is not JSON serializable\")\r\n\r\n        @staticmethod\r\n        def dict_to_object(dict_):\r\n            if 'amount' in dict_ and 'currency' in dict_:\r\n                return Money(Decimal(dict_['amount']), dict_['currency'])\r\n            else:\r\n                return dict_ \r\n```",
      "comment_id": 923352802,
      "user": "pgjones",
      "created_at": "2022-07-18T13:07:59Z",
      "url": "https://github.com/pallets/flask/pull/4692#discussion_r923352802"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4692,
      "file_path": "src/flask/json/provider.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,310 @@\n+from __future__ import annotations\n+\n+import dataclasses\n+import decimal\n+import json\n+import typing as t\n+import uuid\n+import weakref\n+from datetime import date\n+\n+from werkzeug.http import http_date\n+\n+from ..globals import request\n+\n+if t.TYPE_CHECKING:  # pragma: no cover\n+    from ..app import Flask\n+    from ..wrappers import Response\n+\n+\n+class JSONProvider:\n+    \"\"\"A standard set of JSON operations for an application. Subclasses\n+    of this can be used to customize JSON behavior or use different\n+    JSON libraries.\n+\n+    To implement a provider for a specific library, subclass this base\n+    class and implement at least :meth:`dumps` and :meth:`loads`. All\n+    other methods have default implementations.\n+\n+    To use a different provider, either subclass ``Flask`` and set\n+    :attr:`~flask.Flask.json_provider_class` to a provider class, or set\n+    :attr:`app.json <flask.Flask.json>` to an instance of the class.\n+\n+    :param app: An application instance. This will be stored as a\n+        :class:`weakref.proxy` on the :attr:`_app` attribute.\n+\n+    .. versionadded:: 2.2\n+    \"\"\"\n+\n+    def __init__(self, app: Flask) -> None:\n+        self._app = weakref.proxy(app)\n+\n+    def dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n+        \"\"\"Serialize data as JSON.\n+\n+        :param obj: The data to serialize.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def dump(self, obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n+        \"\"\"Serialize data as JSON and write to a file.\n+\n+        :param obj: The data to serialize.\n+        :param fp: A file opened for writing text. Should use the UTF-8\n+            encoding to be valid JSON.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        fp.write(self.dumps(obj, **kwargs))\n+\n+    def loads(self, s: str | bytes, **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON.\n+\n+        :param s: Text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        raise NotImplementedError\n+\n+    def load(self, fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n+        \"\"\"Deserialize data as JSON read from a file.\n+\n+        :param fp: A file opened for reading text or UTF-8 bytes.\n+        :param kwargs: May be passed to the underlying JSON library.\n+        \"\"\"\n+        return self.loads(fp.read(), **kwargs)\n+\n+    def _prepare_response_obj(\n+        self, args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]\n+    ) -> t.Any:\n+        if args and kwargs:\n+            raise TypeError(\"app.json.response() takes either args or kwargs, not both\")\n+\n+        if not args and not kwargs:\n+            return None\n+\n+        if len(args) == 1:\n+            return args[0]\n+\n+        return args or kwargs\n+\n+    def response(self, *args: t.Any, **kwargs: t.Any) -> Response:\n+        \"\"\"Serialize the given arguments as JSON, and return a\n+        :class:`~flask.Response` object with the ``application/json``\n+        mimetype.\n+\n+        The :func:`~flask.json.jsonify` function calls this method for\n+        the current application.\n+\n+        Either positional or keyword arguments can be given, not both.\n+        If no arguments are given, ``None`` is serialized.\n+\n+        :param args: A single value to serialize, or multiple values to\n+            treat as a list to serialize.\n+        :param kwargs: Treat as a dict to serialize.\n+        \"\"\"\n+        obj = self._prepare_response_obj(args, kwargs)\n+        return self._app.response_class(self.dumps(obj), mimetype=\"application/json\")\n+\n+\n+def _default(o: t.Any) -> t.Any:\n+    if isinstance(o, date):\n+        return http_date(o)\n+\n+    if isinstance(o, (decimal.Decimal, uuid.UUID)):\n+        return str(o)\n+\n+    if dataclasses and dataclasses.is_dataclass(o):\n+        return dataclasses.asdict(o)\n+\n+    if hasattr(o, \"__html__\"):\n+        return str(o.__html__())\n+\n+    raise TypeError(f\"Object of type {type(o).__name__} is not JSON serializable\")\n+\n+\n+class DefaultJSONProvider(JSONProvider):\n+    \"\"\"Provide JSON operations using Python's built-in :mod:`json`\n+    library. Serializes the following additional data types:\n+\n+    -   :class:`datetime.datetime` and :class:`datetime.date` are\n+        serialized to :rfc:`822` strings. This is the same as the HTTP\n+        date format.\n+    -   :class:`uuid.UUID` is serialized to a string.\n+    -   :class:`dataclasses.dataclass` is passed to\n+        :func:`dataclasses.asdict`.\n+    -   :class:`~markupsafe.Markup` (or any object with a ``__html__``\n+        method) will call the ``__html__`` method to get a string.\n+    \"\"\"\n+\n+    default: t.Callable[[t.Any], t.Any] = staticmethod(\n+        _default\n+    )  # type: ignore[assignment]\n+    \"\"\"Apply this function to any object that :meth:`json.dumps` does\n+    not know how to serialize. It should return a valid JSON type or\n+    raise a ``TypeError``.\n+    \"\"\"\n+",
      "comment": "I left it out for a few reasons. `object_hook` is not as consistently supported by different libraries as `default` is, and I didn't want to put a perceived requirement for it on all other providers. You usually want to perform validation when deserializing, and that gets very messy trying to cram it all in `object_hook` along with proper error collection. Instead, any project should use a serialization library, leaving the provider to only handle the JSON and basic types.",
      "comment_id": 923395880,
      "user": "davidism",
      "created_at": "2022-07-18T13:49:03Z",
      "url": "https://github.com/pallets/flask/pull/4692#discussion_r923395880"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 1728,
      "file_path": "tests/test_basic.py",
      "line": 1024,
      "side": "RIGHT",
      "diff_hunk": "@@ -1029,6 +1029,18 @@ def test_jsonify_prettyprint():\n         assert rv.data == pretty_response\n \n \n+def test_jsonify_mimetype():\n+    app = flask.Flask(__name__)\n+    app.config.update({\"JSONIFY_MIMETYPE\": 'application/vnd.api+json'})",
      "comment": "why not just `app.config['JSONIFY_MIMETYPE'] = '...'`?\n",
      "comment_id": 52982620,
      "user": "ThiefMaster",
      "created_at": "2016-02-16T08:57:16Z",
      "url": "https://github.com/pallets/flask/pull/1728#discussion_r52982620"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 1728,
      "file_path": "tests/test_basic.py",
      "line": 1024,
      "side": "RIGHT",
      "diff_hunk": "@@ -1029,6 +1029,18 @@ def test_jsonify_prettyprint():\n         assert rv.data == pretty_response\n \n \n+def test_jsonify_mimetype():\n+    app = flask.Flask(__name__)\n+    app.config.update({\"JSONIFY_MIMETYPE\": 'application/vnd.api+json'})",
      "comment": "I am following the conventions used in similar tests. For example: https://github.com/mitsuhiko/flask/pull/1728/files#diff-9e9ddedef65dec3da86063a067839e65R1021\n",
      "comment_id": 53270820,
      "user": "sloria",
      "created_at": "2016-02-18T04:40:35Z",
      "url": "https://github.com/pallets/flask/pull/1728#discussion_r53270820"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4682,
      "file_path": "src/flask/globals.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,59 +1,107 @@\n import typing as t\n-from functools import partial\n+from contextvars import ContextVar\n \n from werkzeug.local import LocalProxy\n-from werkzeug.local import LocalStack\n \n if t.TYPE_CHECKING:  # pragma: no cover\n     from .app import Flask\n     from .ctx import _AppCtxGlobals\n+    from .ctx import AppContext\n+    from .ctx import RequestContext\n     from .sessions import SessionMixin\n     from .wrappers import Request\n \n-_request_ctx_err_msg = \"\"\"\\\n-Working outside of request context.\n \n-This typically means that you attempted to use functionality that needed\n-an active HTTP request.  Consult the documentation on testing for\n-information about how to avoid this problem.\\\n-\"\"\"\n-_app_ctx_err_msg = \"\"\"\\\n+class _FakeStack:\n+    def __init__(self, name: str, cv: ContextVar[t.Any]) -> None:\n+        self.name = name\n+        self.cv = cv\n+\n+    def _warn(self):\n+        import warnings\n+\n+        warnings.warn(\n+            f\"'_{self.name}_ctx_stack' is deprecated and will be\"\n+            \" removed in Flask 2.3. Use 'g' to store data, or\"\n+            f\" '{self.name}_ctx' to access the current context.\",\n+            DeprecationWarning,\n+            stacklevel=3,\n+        )\n+\n+    def push(self, obj: t.Any) -> None:\n+        self._warn()\n+        self.cv.set(obj)\n+\n+    def pop(self) -> t.Any:\n+        self._warn()\n+        ctx = self.cv.get(None)\n+        self.cv.set(None)\n+        return ctx\n+\n+    @property\n+    def top(self) -> t.Optional[t.Any]:\n+        self._warn()\n+        return self.cv.get(None)\n+\n+\n+_no_app_msg = \"\"\"\\\n Working outside of application context.\n \n This typically means that you attempted to use functionality that needed\n-to interface with the current application object in some way. To solve\n-this, set up an application context with app.app_context().  See the\n-documentation for more information.\\\n+the current application. To solve this, set up an application context\n+with app.app_context(). See the documentation for more information.\\\n \"\"\"\n+_cv_app: ContextVar[\"AppContext\"] = ContextVar(\"flask.app_ctx\")\n+__app_ctx_stack = _FakeStack(\"app\", _cv_app)\n+app_ctx: \"AppContext\" = LocalProxy(  # type: ignore[assignment]\n+    _cv_app, unbound_message=_no_app_msg\n+)\n+current_app: \"Flask\" = LocalProxy(  # type: ignore[assignment]\n+    _cv_app, \"app\", unbound_message=_no_app_msg\n+)\n+g: \"_AppCtxGlobals\" = LocalProxy(  # type: ignore[assignment]\n+    _cv_app, \"g\", unbound_message=_no_app_msg\n+)\n \n+_no_req_msg = \"\"\"\\\n+Working outside of request context.\n \n-def _lookup_req_object(name):\n-    top = _request_ctx_stack.top\n-    if top is None:\n-        raise RuntimeError(_request_ctx_err_msg)\n-    return getattr(top, name)\n+This typically means that you attempted to use functionality that needed\n+an active HTTP request. Consult the documentation on testing for\n+information about how to avoid this problem.\\\n+\"\"\"\n+_cv_req: ContextVar[\"RequestContext\"] = ContextVar(\"flask.request_ctx\")",
      "comment": "Can this be `_cv_request`? I need a `_cv_websocket` as well in Quart and `_cv_web` isn't very clear.",
      "comment_id": 917122523,
      "user": "pgjones",
      "created_at": "2022-07-08T20:33:54Z",
      "url": "https://github.com/pallets/flask/pull/4682#discussion_r917122523"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4682,
      "file_path": "src/flask/globals.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,59 +1,107 @@\n import typing as t\n-from functools import partial\n+from contextvars import ContextVar\n \n from werkzeug.local import LocalProxy\n-from werkzeug.local import LocalStack\n \n if t.TYPE_CHECKING:  # pragma: no cover\n     from .app import Flask\n     from .ctx import _AppCtxGlobals\n+    from .ctx import AppContext\n+    from .ctx import RequestContext\n     from .sessions import SessionMixin\n     from .wrappers import Request\n \n-_request_ctx_err_msg = \"\"\"\\\n-Working outside of request context.\n \n-This typically means that you attempted to use functionality that needed\n-an active HTTP request.  Consult the documentation on testing for\n-information about how to avoid this problem.\\\n-\"\"\"\n-_app_ctx_err_msg = \"\"\"\\\n+class _FakeStack:\n+    def __init__(self, name: str, cv: ContextVar[t.Any]) -> None:\n+        self.name = name\n+        self.cv = cv\n+\n+    def _warn(self):\n+        import warnings\n+\n+        warnings.warn(\n+            f\"'_{self.name}_ctx_stack' is deprecated and will be\"\n+            \" removed in Flask 2.3. Use 'g' to store data, or\"\n+            f\" '{self.name}_ctx' to access the current context.\",\n+            DeprecationWarning,\n+            stacklevel=3,\n+        )\n+\n+    def push(self, obj: t.Any) -> None:\n+        self._warn()\n+        self.cv.set(obj)\n+\n+    def pop(self) -> t.Any:\n+        self._warn()\n+        ctx = self.cv.get(None)\n+        self.cv.set(None)\n+        return ctx\n+\n+    @property\n+    def top(self) -> t.Optional[t.Any]:\n+        self._warn()\n+        return self.cv.get(None)\n+\n+\n+_no_app_msg = \"\"\"\\\n Working outside of application context.\n \n This typically means that you attempted to use functionality that needed\n-to interface with the current application object in some way. To solve\n-this, set up an application context with app.app_context().  See the\n-documentation for more information.\\\n+the current application. To solve this, set up an application context\n+with app.app_context(). See the documentation for more information.\\\n \"\"\"\n+_cv_app: ContextVar[\"AppContext\"] = ContextVar(\"flask.app_ctx\")\n+__app_ctx_stack = _FakeStack(\"app\", _cv_app)\n+app_ctx: \"AppContext\" = LocalProxy(  # type: ignore[assignment]\n+    _cv_app, unbound_message=_no_app_msg\n+)\n+current_app: \"Flask\" = LocalProxy(  # type: ignore[assignment]\n+    _cv_app, \"app\", unbound_message=_no_app_msg\n+)\n+g: \"_AppCtxGlobals\" = LocalProxy(  # type: ignore[assignment]\n+    _cv_app, \"g\", unbound_message=_no_app_msg\n+)\n \n+_no_req_msg = \"\"\"\\\n+Working outside of request context.\n \n-def _lookup_req_object(name):\n-    top = _request_ctx_stack.top\n-    if top is None:\n-        raise RuntimeError(_request_ctx_err_msg)\n-    return getattr(top, name)\n+This typically means that you attempted to use functionality that needed\n+an active HTTP request. Consult the documentation on testing for\n+information about how to avoid this problem.\\\n+\"\"\"\n+_cv_req: ContextVar[\"RequestContext\"] = ContextVar(\"flask.request_ctx\")",
      "comment": "Oh yeah, I used the shorter name while I was working and forgot to change it.",
      "comment_id": 917165481,
      "user": "davidism",
      "created_at": "2022-07-08T22:14:47Z",
      "url": "https://github.com/pallets/flask/pull/4682#discussion_r917165481"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4576,
      "file_path": "src/flask/helpers.py",
      "line": 811,
      "side": "RIGHT",
      "diff_hunk": "@@ -788,3 +789,23 @@ def _split_blueprint_path(name: str) -> t.List[str]:\n         out.extend(_split_blueprint_path(name.rpartition(\".\")[0]))\n \n     return out\n+\n+\n+def abort(\n+    status: t.Union[int, \"Response\"], *args: t.Any, **kwargs: t.Any\n+) -> \"te.NoReturn\":\n+    \"\"\"Raises an :py:exc:`HTTPException` for the given status code or WSGI\n+    application using the :attr:`flask.Flask.aborter` instance.\n+\n+    If a status code is given, it will be looked up in the list of\n+    exceptions and will raise that exception.  If passed a WSGI application,\n+    it will wrap it in a proxy WSGI exception and raise that::\n+\n+       abort(404)  # 404 Not Found\n+       abort(Response('Hello World'))\n+\n+    .. versionchanged:: 2.2\n+       Call :attr:`flask.Flask.aborter` on the :data:`~flask.current_app`\n+       rather than exposing :class:`werkzeug.exceptions.abort` directly.\n+    \"\"\"\n+    current_app.aborter(status, *args, **kwargs)  # type: ignore[misc]",
      "comment": "The typing error here is: `src/flask/helpers.py:794: error: Implicit return in function which does not return  [misc]`.\r\n\r\nThe `aborter` is an instance of the `Aborter` class, which is [properly annotated to `NoReturn`](https://github.com/pallets/werkzeug/blob/main/src/werkzeug/exceptions.py#L851-L853) on it's `__call__` function. This seems like potentially a type-checking bug, unless I'm missing something",
      "comment_id": 863028116,
      "user": "dzcode",
      "created_at": "2022-05-02T17:15:04Z",
      "url": "https://github.com/pallets/flask/pull/4576#discussion_r863028116"
    },
    {
      "repo": "pallets/flask",
      "pr_number": 4560,
      "file_path": "src/flask/scaffold.py",
      "line": 736,
      "side": "RIGHT",
      "diff_hunk": "@@ -728,13 +714,32 @@ def _get_exc_class_and_code(\n         \"\"\"\n         exc_class: t.Type[Exception]\n         if isinstance(exc_class_or_code, int):\n-            exc_class = default_exceptions[exc_class_or_code]\n+            try:\n+                exc_class = default_exceptions[exc_class_or_code]\n+            except KeyError:\n+                raise KeyError(\n+                    f\"'{exc_class_or_code}' is not a recognized HTTP error\"\n+                    \" code. Use a subclass of HTTPException with that code\"\n+                    \" instead.\"\n+                ) from None\n         else:\n             exc_class = exc_class_or_code\n \n+        if isinstance(exc_class, Exception):\n+            raise ValueError(\n+                \"Tried to register a handler for an Exception instance\"\n+                f\" {exc_class!r}. Handlers can only be\"\n+                \" registered for Exception classes or HTTP error codes.\"\n+            )\n+\n+        # make sure `exc_class` is a class before checking subclass\n+        assert isinstance(",
      "comment": "This assertion is used to avoid the potential TypeError in `issubclass(exc_class, Exception)` since I found error msg `TypeError: issubclass() arg 1 must be a class` might be confusing to users. If it's deleted, we should be also fine.",
      "comment_id": 861203989,
      "user": "qingpeng9802",
      "created_at": "2022-04-28T18:33:04Z",
      "url": "https://github.com/pallets/flask/pull/4560#discussion_r861203989"
    }
  ]
}