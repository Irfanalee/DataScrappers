{
  "repo": "pydantic/pydantic",
  "scraped_at": "2026-02-03T12:11:17.881686",
  "stats": {
    "total_comments": 2745,
    "filtered": {
      "not_python": 695,
      "too_short": 592,
      "no_diff_hunk": 34,
      "too_long": 11,
      "skip_pattern:thank you": 2,
      "skip_pattern:awesome": 1,
      "skip_pattern:great!": 1
    },
    "kept": 1409
  },
  "examples": [
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12494,
      "file_path": "tests/test_json_schema.py",
      "line": 7198,
      "side": "RIGHT",
      "diff_hunk": "@@ -7193,3 +7193,25 @@ def test_union_format_primitive_type_array_deduplicated() -> None:\n             ]\n         )\n     ) == {'anyOf': [{'type': 'integer'}, {'type': 'string'}, {'type': 'string', 'maxLength': 1}]}\n+\n+\n+def test_nested_model_deduplication():",
      "comment": "```suggestion\r\ndef test_nested_model_deduplication() -> None:\r\n    \"\"\"https://github.com/pydantic/pydantic/issues/12492\"\"\"\r\n\r\n```",
      "comment_id": 2502696314,
      "user": "Viicos",
      "created_at": "2025-11-07T10:36:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/12494#discussion_r2502696314"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12741,
      "file_path": "tests/test_dataclasses.py",
      "line": 3308,
      "side": "RIGHT",
      "diff_hunk": "@@ -3282,3 +3282,27 @@ class Foo:\n     assert ta.dump_json(Foo(foo='bar', bar=1)).decode('utf-8') == '{\"bar\":1}'\n     assert ta.dump_json(Foo(foo='bar', bar=1), exclude={'bar'}).decode('utf-8') == '{}'\n     assert ta.dump_json(Foo(foo='bar', bar=2)).decode('utf-8') == '{}'\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 10), reason='kw_only is not available in python < 3.10')\n+@pytest.mark.parametrize('class_kw_only', [True, False], ids=['class_kw=True', 'class_kw=False'])\n+@pytest.mark.parametrize('field_kw_only', [True, False], ids=['field_kw=True', 'field_kw=False'])\n+def test_dataclass_field_override_kw_only(class_kw_only, field_kw_only) -> None:\n+    \"\"\"\n+    Verifies that pydantic.Field(kw_only=...) is able to correctly\n+        override class-level kw_only\n+    \"\"\"\n+\n+    @pydantic.dataclasses.dataclass(kw_only=class_kw_only)\n+    class Foo:\n+        a: int = Field(kw_only=field_kw_only)\n+\n+    sig = str(inspect.signature(Foo))\n+    if (field_kw_only) or (class_kw_only and field_kw_only is None):\n+        with pytest.raises(ValidationError):\n+            Foo(1)\n+\n+        assert re.match(r'\\(\\*,.+', sig)\n+\n+    else:\n+        assert re.match(r'\\([^\\*]+', sig)",
      "comment": "```suggestion\r\n@pytest.mark.skipif(sys.version_info < (3, 10), reason='kw_only is not available in python >= 3.10')\r\ndef test_dataclass_field_override_kw_only() -> None:\r\n    \"\"\"https://github.com/pydantic/pydantic/issues/12736\"\"\"\r\n\r\n    @pydantic.dataclasses.dataclass(kw_only=True)\r\n    class Foo:\r\n        a: int = Field(kw_only=False)\r\n\r\n    a_param = inspect.signature(Foo).parameters['a']\r\n\r\n    assert a_param.kind is inspect.Parameter.POSITIONAL_OR_KEYWORD\r\n    assert a_param.default is inspect.Parameter.empty\r\n```",
      "comment_id": 2726927326,
      "user": "Viicos",
      "created_at": "2026-01-26T09:41:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/12741#discussion_r2726927326"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12712,
      "file_path": "tests/test_pickle.py",
      "line": 328,
      "side": "RIGHT",
      "diff_hunk": "@@ -318,3 +321,51 @@ def test_pickle_model_with_config(model_type: type, use_cloudpickle: bool):\n         model_type = pickle.loads(pickle.dumps(model_type))\n \n     assert model_type.model_config['title'] == 'MyTitle'\n+\n+\n+@pytest.mark.skipif(\n+    sys.version_info[:2] != (3, 14),\n+    reason='Pickle data generated on 3.14',",
      "comment": "Rather than hard-coding, could potentially use `multiprocessing` to produce a pickle bytes, to unpickle in the current process?",
      "comment_id": 2701057019,
      "user": "davidhewitt",
      "created_at": "2026-01-17T12:38:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/12712#discussion_r2701057019"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12712,
      "file_path": "tests/test_pickle.py",
      "line": 328,
      "side": "RIGHT",
      "diff_hunk": "@@ -318,3 +321,51 @@ def test_pickle_model_with_config(model_type: type, use_cloudpickle: bool):\n         model_type = pickle.loads(pickle.dumps(model_type))\n \n     assert model_type.model_config['title'] == 'MyTitle'\n+\n+\n+@pytest.mark.skipif(\n+    sys.version_info[:2] != (3, 14),\n+    reason='Pickle data generated on 3.14',",
      "comment": "It doesn't pickle it properly, that's why I went with this option.\r\n\r\n```python\r\nfrom multiprocessing import Process, Manager\r\n\r\nimport cloudpickle\r\n\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Foo(BaseModel):\r\n    foo: int\r\n\r\n\r\nclass Bar(BaseModel):\r\n    bar1: Foo\r\n    bar2: Foo\r\n\r\n\r\ndef bar_repr() -> str:\r\n    json = '{\"bar1\": {\"foo\": 1}, \"bar2\": {\"foo\": 2}}'\r\n    bar = Bar.model_validate_json(json)\r\n    return repr(bar)\r\n\r\n\r\ndef create_pickled(return_dict):\r\n    pickled = cloudpickle.dumps(bar_repr)\r\n    return_dict['return'] = pickled\r\n\r\ndef test_tmp():\r\n    manager = Manager()\r\n    return_dict = manager.dict()\r\n\r\n    p = Process(target=create_pickled, args=(return_dict,))\r\n    p.start()\r\n    p.join()\r\n\r\n    print(return_dict)\r\n    #> {'return': b'\\x80\\x05\\x95\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x11tests.test_pickle\\x94\\x8c\\x08bar_repr\\x94\\x93\\x94.'}\r\n```",
      "comment_id": 2701209494,
      "user": "Viicos",
      "created_at": "2026-01-17T15:05:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/12712#discussion_r2701209494"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12712,
      "file_path": "tests/test_pickle.py",
      "line": 328,
      "side": "RIGHT",
      "diff_hunk": "@@ -318,3 +321,51 @@ def test_pickle_model_with_config(model_type: type, use_cloudpickle: bool):\n         model_type = pickle.loads(pickle.dumps(model_type))\n \n     assert model_type.model_config['title'] == 'MyTitle'\n+\n+\n+@pytest.mark.skipif(\n+    sys.version_info[:2] != (3, 14),\n+    reason='Pickle data generated on 3.14',",
      "comment": "I managed to find a way to make it work with `subprocess`. I've pushed a commit doing so, I also confirmed that the issue reproduces with that approach on the commit before #12689 merged.",
      "comment_id": 2708626832,
      "user": "davidhewitt",
      "created_at": "2026-01-20T14:34:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/12712#discussion_r2708626832"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12712,
      "file_path": "tests/test_pickle.py",
      "line": 328,
      "side": "RIGHT",
      "diff_hunk": "@@ -318,3 +321,51 @@ def test_pickle_model_with_config(model_type: type, use_cloudpickle: bool):\n         model_type = pickle.loads(pickle.dumps(model_type))\n \n     assert model_type.model_config['title'] == 'MyTitle'\n+\n+\n+@pytest.mark.skipif(\n+    sys.version_info[:2] != (3, 14),\n+    reason='Pickle data generated on 3.14',",
      "comment": "Did not want to mess with `subprocess` initially but this looks simple enough",
      "comment_id": 2709332051,
      "user": "Viicos",
      "created_at": "2026-01-20T17:20:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/12712#discussion_r2709332051"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12681,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,27 +311,27 @@ def collect_model_fields(  # noqa: C901\n                 f\"Unexpected field with name {ann_name!r}; only 'root' is allowed as a field of a `RootModel`\"\n             )\n \n-        # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don't get\n-        # \"... shadows an attribute\" warnings\n-        generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')\n         for base in bases:\n-            dataclass_fields = {\n-                field.name for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n-            }\n             if hasattr(base, ann_name):\n+                if ann_name not in cls_annotations:\n+                    # Don't warn when a field exists in a parent class but has not been defined in the current class\n+                    continue\n+\n+                # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don't get\n+                # \"... shadows an attribute\" warnings\n+                generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')",
      "comment": "I'm surprised this was worth moving to a lower loop level, it's presumably not expensive to evaluate. Should we instead be moving this up to the top level above the loop on line 273?",
      "comment_id": 2697569904,
      "user": "davidhewitt",
      "created_at": "2026-01-16T09:01:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/12681#discussion_r2697569904"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12681,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 329,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,27 +311,27 @@ def collect_model_fields(  # noqa: C901\n                 f\"Unexpected field with name {ann_name!r}; only 'root' is allowed as a field of a `RootModel`\"\n             )\n \n-        # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don't get\n-        # \"... shadows an attribute\" warnings\n-        generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')\n         for base in bases:\n-            dataclass_fields = {\n-                field.name for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n-            }\n             if hasattr(base, ann_name):\n+                if ann_name not in cls_annotations:\n+                    # Don't warn when a field exists in a parent class but has not been defined in the current class\n+                    continue\n+\n+                # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don't get\n+                # \"... shadows an attribute\" warnings\n+                generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')\n                 if base is generic_origin:\n                     # Don't warn when \"shadowing\" of attributes in parametrized generics\n                     continue\n \n+                dataclass_fields = {\n+                    field.name for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n+                }",
      "comment": "Is this worth caching in a function-local dict? We might evaluate this repeatedly for each `(ann_name, base)` pair when really it looks like we only need to ever evaluate this once per base?",
      "comment_id": 2697573727,
      "user": "davidhewitt",
      "created_at": "2026-01-16T09:03:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/12681#discussion_r2697573727"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12681,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,27 +311,27 @@ def collect_model_fields(  # noqa: C901\n                 f\"Unexpected field with name {ann_name!r}; only 'root' is allowed as a field of a `RootModel`\"\n             )\n \n-        # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don't get\n-        # \"... shadows an attribute\" warnings\n-        generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')\n         for base in bases:\n-            dataclass_fields = {\n-                field.name for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n-            }\n             if hasattr(base, ann_name):\n+                if ann_name not in cls_annotations:\n+                    # Don't warn when a field exists in a parent class but has not been defined in the current class\n+                    continue\n+\n+                # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don't get\n+                # \"... shadows an attribute\" warnings\n+                generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')",
      "comment": "My assumption was that hitting this code path is really uncommon (in fact I'm even wondering if the origin check is possible; it is currently uncovered and I'm not sure there's a case for this).\r\n\r\nWe could move the `generic_origin` fetch up, although I'm pretty sure both would be equivalent.",
      "comment_id": 2703881914,
      "user": "Viicos",
      "created_at": "2026-01-19T09:12:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/12681#discussion_r2703881914"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12681,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 329,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,27 +311,27 @@ def collect_model_fields(  # noqa: C901\n                 f\"Unexpected field with name {ann_name!r}; only 'root' is allowed as a field of a `RootModel`\"\n             )\n \n-        # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don't get\n-        # \"... shadows an attribute\" warnings\n-        generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')\n         for base in bases:\n-            dataclass_fields = {\n-                field.name for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n-            }\n             if hasattr(base, ann_name):\n+                if ann_name not in cls_annotations:\n+                    # Don't warn when a field exists in a parent class but has not been defined in the current class\n+                    continue\n+\n+                # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don't get\n+                # \"... shadows an attribute\" warnings\n+                generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')\n                 if base is generic_origin:\n                     # Don't warn when \"shadowing\" of attributes in parametrized generics\n                     continue\n \n+                dataclass_fields = {\n+                    field.name for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n+                }",
      "comment": "We could have a local cache of the `dataclass_fields` for each base, so that we can reuse it when we process the other `ann_names`, but hitting this path is really uncommon (see added test), so I don't think we should worry too much.",
      "comment_id": 2703888774,
      "user": "Viicos",
      "created_at": "2026-01-19T09:14:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/12681#discussion_r2703888774"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12689,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 602,
      "side": "RIGHT",
      "diff_hunk": "@@ -599,6 +599,7 @@ def complete_model_class(\n     raise_errors: bool = True,\n     call_on_complete_hook: bool = True,\n     create_model_module: str | None = None,\n+    rebuild: bool = False,",
      "comment": "```suggestion\r\n    is_force_rebuild: bool = False,\r\n```",
      "comment_id": 2689585331,
      "user": "Viicos",
      "created_at": "2026-01-14T09:08:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/12689#discussion_r2689585331"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12689,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 602,
      "side": "RIGHT",
      "diff_hunk": "@@ -599,6 +599,7 @@ def complete_model_class(\n     raise_errors: bool = True,\n     call_on_complete_hook: bool = True,\n     create_model_module: str | None = None,\n+    rebuild: bool = False,",
      "comment": "Just amended this here (not also in SchemaValidator/PluggableSchemaValidator) since they were not commented on [but let me know if that's the wrong assumption]",
      "comment_id": 2690124736,
      "user": "lmmx",
      "created_at": "2026-01-14T11:47:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/12689#discussion_r2690124736"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12568,
      "file_path": "pydantic-core/tests/serializers/test_functions.py",
      "line": 671,
      "side": "RIGHT",
      "diff_hunk": "@@ -667,7 +668,10 @@ def f(value, handler, _info):\n \n \n @pytest.mark.skipif(\n-    platform.python_implementation() in ('PyPy', 'GraalVM') or sys.platform in {'emscripten', 'win32'},\n+    # Also skip in local, as segfaults may happen on some platforms for Python < 3.14:",
      "comment": "```suggestion\n    # Also skip in local, as segfaults may happen on some platforms for Python < 3.14:\n    # TODO: re-enable locally after https://github.com/pydantic/pydantic/issues/12592\n```",
      "comment_id": 2697658712,
      "user": "davidhewitt",
      "created_at": "2026-01-16T09:25:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/12568#discussion_r2697658712"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12522,
      "file_path": "tests/test_missing_sentinel.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,3 +69,14 @@ class Model(BaseModel):\n     assert Model.model_json_schema()['properties'] == {\n         'f': {'title': 'F', 'type': 'integer'},\n     }\n+\n+\n+def test_model_construct_with_missing_default_does_not_crash():",
      "comment": "```suggestion\r\ndef test_model_construct_with_missing_default_does_not_crash() -> None:\r\n```",
      "comment_id": 2516006789,
      "user": "Viicos",
      "created_at": "2025-11-11T22:26:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/12522#discussion_r2516006789"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12604,
      "file_path": "tests/types/test_union.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,75 @@\n+from typing import ClassVar, Literal, TypedDict\n+\n+import pydantic\n+\n+\n+def test_field_serializer_in_nested_union_called_only_twice():\n+    class MyModel(pydantic.BaseModel):\n+        a: int\n+        b: int\n+\n+        field_a_serializer_calls: ClassVar[int] = 0\n+\n+        @pydantic.field_serializer('a')\n+        def serialize_my_field(self, value: int) -> str:\n+            self.__class__.field_a_serializer_calls += 1\n+            return str(value)\n+\n+    class Container(TypedDict):\n+        u: MyModel | int\n+\n+    class Container2(TypedDict):\n+        u: Container | int\n+\n+    value = MyModel(a=1, b=False)\n+    assert value.b is False\n+\n+    ta = pydantic.TypeAdapter(Container2 | int)\n+    ta.dump_json(Container2(u=Container(u=value)), warnings=False)\n+\n+    # Historical implementations of pydantic would call the field serializer many times\n+    # as nested unions were individually attempted with each of strict and lax checking.\n+    #\n+    # 2 comes from:\n+    # - one attempt in strict mode, which fails because of `b=False` as a subclass\n+    # - one attempt in lax mode, which succeeds\n+    assert MyModel.field_a_serializer_calls == 2\n+\n+\n+def test_field_serializer_in_nested_tagged_union_called_only_twice():\n+    class MyModel(pydantic.BaseModel):\n+        type_: Literal['a'] = 'a'\n+\n+        a: int\n+        b: int\n+\n+        field_a_serializer_calls: ClassVar[int] = 0\n+\n+        @pydantic.field_serializer('a')\n+        def serialize_my_field(self, value: int) -> str:\n+            self.__class__.field_a_serializer_calls += 1\n+            return str(value)\n+\n+    class ModelB(pydantic.BaseModel):\n+        type_: Literal['b'] = 'b'\n+\n+    class Container(pydantic.BaseModel):\n+        type_: Literal['a'] = 'a'\n+        u: MyModel | ModelB = pydantic.Field(..., discriminator='type_')\n+\n+    class Container2(pydantic.BaseModel):\n+        u: Container | ModelB = pydantic.Field(..., discriminator='type_')\n+\n+    ta = pydantic.TypeAdapter(Container2 | int)\n+    ta.dump_json(Container2(u=Container(u=MyModel.model_construct(a=1, b=False))), warnings=False)\n+\n+    # Historical implementations of pydantic would call the field serializer many MANY times\n+    # as nested unions were individually attempted with each of strict and lax checking.\n+    #\n+    # 5 comes from:\n+    # - tagged discriminator in outer union at strict mode\n+    # - fall back to left to right in outer union at strict mode\n+    # - tagged discriminator in inner union at strict mode\n+    # - fall back to left to right in inner union still at strict mode\n+    # - tagged discriminator in outer union at lax mode, which calls tagged discriminator in inner union at lax mode, which finally succeeds\n+    assert MyModel.field_a_serializer_calls == 5",
      "comment": "I think we could do better here; when making tagged union serialization fall back to left-to-right we could potentially try all variants except the one which we already attempted (and failed) in the tagged union serialization.\n\ni.e. this should be 2 like above, I think.",
      "comment_id": 2584568651,
      "user": "davidhewitt",
      "created_at": "2025-12-03T10:39:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/12604#discussion_r2584568651"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12627,
      "file_path": "tests/test_type_adapter.py",
      "line": 690,
      "side": "RIGHT",
      "diff_hunk": "@@ -681,3 +681,30 @@ def module_1() -> None:\n \n     with pytest.raises(ValidationError):\n         module_1.ta.validate_python('a')\n+\n+\n+def test_validate_python_with_incorrect_configuration():\n+    ta = TypeAdapter(int)\n+\n+    with pytest.raises(PydanticUserError) as exc_info:\n+        ta.validate_python({'foo': [1, '2']}, by_alias=False, by_name=False)",
      "comment": "```suggestion\r\n        ta.validate_python(1, by_alias=False, by_name=False)\r\n```",
      "comment_id": 2618579209,
      "user": "Viicos",
      "created_at": "2025-12-15T09:10:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/12627#discussion_r2618579209"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12627,
      "file_path": "tests/test_type_adapter.py",
      "line": 699,
      "side": "RIGHT",
      "diff_hunk": "@@ -681,3 +681,30 @@ def module_1() -> None:\n \n     with pytest.raises(ValidationError):\n         module_1.ta.validate_python('a')\n+\n+\n+def test_validate_python_with_incorrect_configuration():\n+    ta = TypeAdapter(int)\n+\n+    with pytest.raises(PydanticUserError) as exc_info:\n+        ta.validate_python({'foo': [1, '2']}, by_alias=False, by_name=False)\n+\n+    assert 'At least one of `by_alias` or `by_name` must be set to True.' in str(exc_info.value)\n+\n+\n+def test_validate_json_with_incorrect_configuration():\n+    ta = TypeAdapter(int)\n+\n+    with pytest.raises(PydanticUserError) as exc_info:\n+        ta.validate_json(json.dumps({'x': '1'}), by_alias=False, by_name=False)",
      "comment": "```suggestion\r\n        ta.validate_json(1, by_alias=False, by_name=False)\r\n```",
      "comment_id": 2618580194,
      "user": "Viicos",
      "created_at": "2025-12-15T09:10:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/12627#discussion_r2618580194"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12627,
      "file_path": "tests/test_type_adapter.py",
      "line": 708,
      "side": "RIGHT",
      "diff_hunk": "@@ -681,3 +681,30 @@ def module_1() -> None:\n \n     with pytest.raises(ValidationError):\n         module_1.ta.validate_python('a')\n+\n+\n+def test_validate_python_with_incorrect_configuration():\n+    ta = TypeAdapter(int)\n+\n+    with pytest.raises(PydanticUserError) as exc_info:\n+        ta.validate_python({'foo': [1, '2']}, by_alias=False, by_name=False)\n+\n+    assert 'At least one of `by_alias` or `by_name` must be set to True.' in str(exc_info.value)\n+\n+\n+def test_validate_json_with_incorrect_configuration():\n+    ta = TypeAdapter(int)\n+\n+    with pytest.raises(PydanticUserError) as exc_info:\n+        ta.validate_json(json.dumps({'x': '1'}), by_alias=False, by_name=False)\n+\n+    assert 'At least one of `by_alias` or `by_name` must be set to True.' in str(exc_info.value)\n+\n+\n+def test_validate_strings_with_incorrect_configuration():\n+    ta = TypeAdapter(int)\n+\n+    with pytest.raises(PydanticUserError) as exc_info:\n+        ta.validate_strings({'x': 'true', 'y': 'true'}, by_alias=False, by_name=False)",
      "comment": "```suggestion\r\n        ta.validate_strings(1, by_alias=False, by_name=False)\r\n```",
      "comment_id": 2618580573,
      "user": "Viicos",
      "created_at": "2025-12-15T09:11:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/12627#discussion_r2618580573"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12627,
      "file_path": "tests/test_internal.py",
      "line": 196,
      "side": "RIGHT",
      "diff_hunk": "@@ -188,3 +191,128 @@ def test_decimal_digits_calculation(decimal: Decimal, decimal_places: int, digit\n def test_decimal_digits_calculation_type_error(value) -> None:\n     with pytest.raises(TypeError, match=f'Unable to extract decimal digits info from supplied value {value}'):\n         _extract_decimal_digits_info(value)\n+\n+\n+class TestCoreMetadata:",
      "comment": "We don't use test classes, plain functions are fine.\r\n\r\nLet's keep only `test_update_js_extra_as_callable_when_existing_js_extra_is_dict_type()`, `test_update_js_extra_as_callable_when_existing_js_extra_is_callable_type()`, and a simple test with `pydantic_js_functions` only being provided.",
      "comment_id": 2618639511,
      "user": "Viicos",
      "created_at": "2025-12-15T09:28:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/12627#discussion_r2618639511"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12627,
      "file_path": "tests/test_plugin_loader.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,3 +93,49 @@ def test_disable_multiple(reset_plugins):\n     assert len(list(res)) == 1\n     assert 'test_plugin:plugin1' not in list(res)\n     assert 'test_plugin:plugin2' not in list(res)\n+\n+\n+def test_caching_of_loaded_plugins(reset_plugins):\n+    os.environ['PYDANTIC_DISABLE_PLUGINS'] = 'test_plugin1,test_plugin2'\n+    res = loader.get_plugins()\n+    assert list(res) == ['test_plugin:plugin3']\n+    res = loader.get_plugins()\n+    assert list(res) == ['test_plugin:plugin3']\n+\n+\n+def test_load_same_plugin_multiple_times(reset_plugins):\n+    mock_entry_1 = EntryPoint(name='test_plugin1', value='test_plugin:plugin1', group='pydantic')\n+    mock_dist = Dist([mock_entry_1, mock_entry_1])\n+\n+    os.environ.pop('PYDANTIC_DISABLE_PLUGINS', None)",
      "comment": "This should be done using the [`monkeypatch` fixture](https://docs.pytest.org/en/stable/reference/reference.html#pytest.MonkeyPatch.setenv).",
      "comment_id": 2618654388,
      "user": "Viicos",
      "created_at": "2025-12-15T09:32:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/12627#discussion_r2618654388"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12627,
      "file_path": "tests/test_internal.py",
      "line": 196,
      "side": "RIGHT",
      "diff_hunk": "@@ -188,3 +191,128 @@ def test_decimal_digits_calculation(decimal: Decimal, decimal_places: int, digit\n def test_decimal_digits_calculation_type_error(value) -> None:\n     with pytest.raises(TypeError, match=f'Unable to extract decimal digits info from supplied value {value}'):\n         _extract_decimal_digits_info(value)\n+\n+\n+class TestCoreMetadata:",
      "comment": "I understand. Removed the class. Retained only the tests sufficient to cover the missed lines.",
      "comment_id": 2620319121,
      "user": "sesmi123",
      "created_at": "2025-12-15T17:50:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/12627#discussion_r2620319121"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12627,
      "file_path": "tests/test_plugin_loader.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,3 +93,49 @@ def test_disable_multiple(reset_plugins):\n     assert len(list(res)) == 1\n     assert 'test_plugin:plugin1' not in list(res)\n     assert 'test_plugin:plugin2' not in list(res)\n+\n+\n+def test_caching_of_loaded_plugins(reset_plugins):\n+    os.environ['PYDANTIC_DISABLE_PLUGINS'] = 'test_plugin1,test_plugin2'\n+    res = loader.get_plugins()\n+    assert list(res) == ['test_plugin:plugin3']\n+    res = loader.get_plugins()\n+    assert list(res) == ['test_plugin:plugin3']\n+\n+\n+def test_load_same_plugin_multiple_times(reset_plugins):\n+    mock_entry_1 = EntryPoint(name='test_plugin1', value='test_plugin:plugin1', group='pydantic')\n+    mock_dist = Dist([mock_entry_1, mock_entry_1])\n+\n+    os.environ.pop('PYDANTIC_DISABLE_PLUGINS', None)",
      "comment": "Thanks for the review! I learnt to use monkeypatch for handling global state for tests :)",
      "comment_id": 2620324239,
      "user": "sesmi123",
      "created_at": "2025-12-15T17:52:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/12627#discussion_r2620324239"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12627,
      "file_path": "tests/test_internal.py",
      "line": 238,
      "side": "RIGHT",
      "diff_hunk": "@@ -188,3 +191,128 @@ def test_decimal_digits_calculation(decimal: Decimal, decimal_places: int, digit\n def test_decimal_digits_calculation_type_error(value) -> None:\n     with pytest.raises(TypeError, match=f'Unable to extract decimal digits info from supplied value {value}'):\n         _extract_decimal_digits_info(value)\n+\n+\n+class TestCoreMetadata:\n+    def test_update_adds_key_to_existing_metadata(self):\n+        metadata = {'pydantic_js_prefer_positional_arguments': True}\n+        update_core_metadata(metadata, pydantic_js_updates={'title': 'Test'})\n+        assert metadata['pydantic_js_prefer_positional_arguments']\n+        assert metadata['pydantic_js_updates'] == {'title': 'Test'}\n+\n+    def test_multiple_updates_merge_js_updates_dict(self):\n+        metadata: dict[str, Any] = {}\n+        update_core_metadata(metadata, pydantic_js_updates={'title': 'Test'})\n+        update_core_metadata(metadata, pydantic_js_updates={'description': 'A test field'})\n+\n+        assert metadata['pydantic_js_updates']['title'] == 'Test'\n+        assert metadata['pydantic_js_updates']['description'] == 'A test field'\n+\n+    def test_update_override_earlier_values_for_existing_keys(self):\n+        metadata: dict[str, Any] = {}\n+        update_core_metadata(metadata, pydantic_js_updates={'title': 'First'})\n+        update_core_metadata(metadata, pydantic_js_updates={'title': 'Second'})\n+        assert metadata['pydantic_js_updates']['title'] == 'Second'\n+\n+    def test_update_js_extra_as_callable_when_existing_js_extra_is_none(self):\n+        metadata: dict[str, Any] = {}\n+\n+        def extra_func(schema: JsonDict) -> None:\n+            schema['testKey'] = 'testValue'\n+\n+        update_core_metadata(metadata, pydantic_js_extra=extra_func)\n+        assert metadata['pydantic_js_extra'] is extra_func\n+\n+    def test_update_js_extra_as_callable_when_existing_js_extra_is_dict_type(self):\n+        \"\"\"\n+        It should ignore the callable with a warning.\n+        \"\"\"\n+        metadata: dict[str, Any] = {}\n+\n+        extra_dict: JsonDict = {'testKey': 'testValue'}\n+\n+        def extra_func(schema: JsonDict) -> None:\n+            schema['testKey'] = 'testValue'\n+\n+        update_core_metadata(metadata, pydantic_js_extra=extra_dict)\n+        from pydantic.json_schema import PydanticJsonSchemaWarning",
      "comment": "I've moved the import to the top of the file. Resolving.",
      "comment_id": 2620327577,
      "user": "sesmi123",
      "created_at": "2025-12-15T17:53:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/12627#discussion_r2620327577"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12579,
      "file_path": "pydantic/errors.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,7 +98,7 @@ def __str__(self) -> str:\n             return f'{self.message}\\n\\nFor further information visit {DEV_ERROR_DOCS_URL}{self.code}'\n \n \n-class PydanticUserError(PydanticErrorMixin, TypeError):\n+class PydanticUserError(PydanticErrorMixin, Exception):",
      "comment": "```suggestion\r\nclass PydanticUserError(PydanticErrorMixin, RuntimeError):\r\n```",
      "comment_id": 2577110115,
      "user": "Viicos",
      "created_at": "2025-12-01T13:37:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/12579#discussion_r2577110115"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -326,20 +326,17 @@ def collect_model_fields(  # noqa: C901\n                 # Note that we only do this for method descriptors for now, we might want to\n                 # extend this to any descriptor in the future (by simply checking for\n                 # `hasattr(assigned_value.default, '__get__')`).\n-                assigned_value.default = assigned_value.default.__get__(None, cls)\n-\n-            # The `from_annotated_attribute()` call below mutates the assigned `Field()`, so make a copy:\n-            original_assignment = (\n-                copy(assigned_value) if not evaluated and isinstance(assigned_value, FieldInfo_) else assigned_value\n-            )\n+                default = assigned_value.default.__get__(None, cls)\n+                assigned_value.default = default\n+                assigned_value._attributes_set['default'] = default",
      "comment": "Next step would be to get rid of the `_attributes_set` logic when merging instances, which is error prone as you need to update it whenever you do a manual assignment on a `FieldInfo` instance.",
      "comment_id": 2101124381,
      "user": "Viicos",
      "created_at": "2025-05-21T20:37:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2101124381"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/fields.py",
      "line": 217,
      "side": "RIGHT",
      "diff_hunk": "@@ -213,7 +213,7 @@ def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:\n \n         See the signature of `pydantic.fields.Field` for more details about the expected arguments.\n         \"\"\"\n-        self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset}\n+        self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset and k not in self.metadata_lookup}",
      "comment": "This is kind of important, although it also works without the change:\r\n\r\nWhen we merge field infos, we don't want to reinclude kwargs that are transformed to metadata elements (`gt` -> `annotated_types.Gt`, etc). This will result in unnecessary metadata classes to be created (at the end of the `FieldInfo.__init__()` logic). ",
      "comment_id": 2101126466,
      "user": "Viicos",
      "created_at": "2025-05-21T20:39:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2101126466"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/fields.py",
      "line": 762,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,6 +738,19 @@ def apply_typevars_map(\n             self._complete = False\n             self._original_annotation = self.annotation\n \n+    def _copy(self) -> Self:\n+        \"\"\"Return a copy of the `FieldInfo` instance.\"\"\"\n+        # Note: we can't define a custom `__copy__()`, as `FieldInfo` is being subclassed\n+        # by some third-party libraries with extra attributes defined (and as `FieldInfo`\n+        # is slotted, we can't make a copy of the `__dict__`).",
      "comment": "Alternatively, we can drop slots on `FieldInfo`, and do the following:\r\n\r\n\r\n```python\r\n    def __copy__(self) -> Self:\r\n        copied = type(self)()\r\n        copied.__dict__ = self.__dict__\r\n        for attr_name in ('metadata', '_attributes_set', '_qualifiers'):\r\n             # Apply \"deep-copy\" behavior on collections attributes:\r\n             value = getattr(self, attr_name).copy()\r\n             setattr(copied, attr_name, value)\r\n\r\n        return copied\r\n```",
      "comment_id": 2104889496,
      "user": "Viicos",
      "created_at": "2025-05-23T15:54:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2104889496"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "tests/test_annotated.py",
      "line": 508,
      "side": "LEFT",
      "diff_hunk": "@@ -505,28 +505,6 @@ class AnnotatedFieldModel(BaseModel):\n         }\n     ]\n \n-    # Ensure that the inner annotation does not override the outer, even for metadata:",
      "comment": "Due to one of the bugs being fixed in this PR (related to the usage of forward references), the constraint in `Annotated` was dropped. Now the test is failing because the unexpected order (described in https://github.com/pydantic/pydantic/issues/10507) applies.",
      "comment_id": 2104893756,
      "user": "Viicos",
      "created_at": "2025-05-23T15:56:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2104893756"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/fields.py",
      "line": 418,
      "side": "RIGHT",
      "diff_hunk": "@@ -417,57 +399,124 @@ class MyModel(pydantic.BaseModel):\n         final = 'final' in inspected_ann.qualifiers\n         metadata = inspected_ann.metadata\n \n-        if isinstance(default, FieldInfo):\n-            # e.g. `field: int = Field(...)`\n-            default.annotation = type_expr\n-            default.metadata += metadata\n-            merged_default = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                default,\n-                annotation=default.annotation,\n-            )\n-            merged_default.frozen = final or merged_default.frozen\n-            merged_default._qualifiers = inspected_ann.qualifiers\n-            return merged_default\n-\n-        if isinstance(default, dataclasses.Field):\n-            # `collect_dataclass_fields()` passes the dataclass Field as a default.\n-            pydantic_field = FieldInfo._from_dataclass_field(default)\n-            pydantic_field.annotation = type_expr\n-            pydantic_field.metadata += metadata\n-            pydantic_field = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                pydantic_field,\n-                annotation=pydantic_field.annotation,\n-            )\n-            pydantic_field.frozen = final or pydantic_field.frozen\n-            pydantic_field.init_var = 'init_var' in inspected_ann.qualifiers\n-            pydantic_field.init = getattr(default, 'init', None)\n-            pydantic_field.kw_only = getattr(default, 'kw_only', None)\n-            pydantic_field._qualifiers = inspected_ann.qualifiers\n-            return pydantic_field\n-\n-        if not metadata:\n-            # No metadata, e.g. `field: int = ...`, or `field: Final[str] = ...`:\n-            field_info = FieldInfo(annotation=type_expr, default=default, frozen=final or None)\n-            field_info._qualifiers = inspected_ann.qualifiers\n+        # HACK 1: the order in which the metadata is merged is inconsistent; we need to prepend\n+        # metadata from the assignment at the beginning of the metadata. Changing this is only\n+        # possible in v3 (at least). See https://github.com/pydantic/pydantic/issues/10507\n+        prepend_metadata: list[Any] | None = None\n+        attr_overrides = {'annotation': type_expr}\n+        if final:\n+            attr_overrides['frozen'] = True\n+\n+        # HACK 2: FastAPI is subclassing `FieldInfo` and historically expected the actual\n+        # instance's type to be preserved when constructing new models with its subclasses as assignments.\n+        # This code is never reached by Pydantic itself, and in an ideal world this shouldn't be necessary.\n+        if not metadata and isinstance(default, FieldInfo) and type(default) is not FieldInfo:\n+            field_info = default._copy()\n+            field_info._attributes_set.update(attr_overrides)\n+            for k, v in attr_overrides.items():\n+                setattr(field_info, k, v)",
      "comment": "Unfortunate stuff introduced since https://github.com/pydantic/pydantic/pull/6862..",
      "comment_id": 2104943652,
      "user": "Viicos",
      "created_at": "2025-05-23T16:12:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2104943652"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/fields.py",
      "line": 425,
      "side": "RIGHT",
      "diff_hunk": "@@ -417,58 +400,130 @@ class MyModel(pydantic.BaseModel):\n         final = 'final' in inspected_ann.qualifiers\n         metadata = inspected_ann.metadata\n \n-        if isinstance(default, FieldInfo):\n-            # e.g. `field: int = Field(...)`\n-            default.annotation = type_expr\n-            default.metadata += metadata\n-            merged_default = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                default,\n-                annotation=default.annotation,\n-            )\n-            merged_default.frozen = final or merged_default.frozen\n-            merged_default._qualifiers = inspected_ann.qualifiers\n-            return merged_default\n-\n-        if isinstance(default, dataclasses.Field):\n-            # `collect_dataclass_fields()` passes the dataclass Field as a default.\n-            pydantic_field = FieldInfo._from_dataclass_field(default)\n-            pydantic_field.annotation = type_expr\n-            pydantic_field.metadata += metadata\n-            pydantic_field = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                pydantic_field,\n-                annotation=pydantic_field.annotation,\n-            )\n-            pydantic_field.frozen = final or pydantic_field.frozen\n-            pydantic_field.init_var = 'init_var' in inspected_ann.qualifiers\n-            pydantic_field.init = getattr(default, 'init', None)\n-            pydantic_field.kw_only = getattr(default, 'kw_only', None)\n-            pydantic_field._qualifiers = inspected_ann.qualifiers\n-            return pydantic_field\n-\n-        if not metadata:\n-            # No metadata, e.g. `field: int = ...`, or `field: Final[str] = ...`:\n-            field_info = FieldInfo(annotation=type_expr, default=default, frozen=final or None)\n-            field_info._qualifiers = inspected_ann.qualifiers\n+        # HACK 1: the order in which the metadata is merged is inconsistent; we need to prepend\n+        # metadata from the assignment at the beginning of the metadata. Changing this is only\n+        # possible in v3 (at least). See https://github.com/pydantic/pydantic/issues/10507\n+        prepend_metadata: list[Any] | None = None\n+        attr_overrides = {'annotation': type_expr}\n+        if final:\n+            attr_overrides['frozen'] = True\n+\n+        # HACK 2: FastAPI is subclassing `FieldInfo` and historically expected the actual\n+        # instance's type to be preserved when constructing new models with its subclasses as assignments.\n+        # This code is never reached by Pydantic itself, and in an ideal world this shouldn't be necessary.\n+        if not metadata and isinstance(default, FieldInfo) and type(default) is not FieldInfo:\n+            field_info = default._copy()\n+            field_info._attributes_set.update(attr_overrides)\n+            for k, v in attr_overrides.items():\n+                setattr(field_info, k, v)\n             return field_info\n \n-        # With metadata, e.g. `field: Annotated[int, Field(...), Gt(1)] = ...`:\n-        field_infos = [a for a in metadata if isinstance(a, FieldInfo)]\n-        field_info = FieldInfo.merge_field_infos(*field_infos, annotation=type_expr, default=default)\n-        field_metadata: list[Any] = []\n-        for a in metadata:\n-            if typing_objects.is_deprecated(a):\n-                field_info.deprecated = a.message\n-            elif not isinstance(a, FieldInfo):\n-                field_metadata.append(a)\n-            else:\n-                field_metadata.extend(a.metadata)\n-        field_info.metadata = field_metadata\n+        if isinstance(default, FieldInfo):\n+            default_copy = default._copy()  # Copy unnecessary when we remove HACK 1.\n+            prepend_metadata = default_copy.metadata\n+            default_copy.metadata = []\n+            metadata = metadata + [default_copy]",
      "comment": "Why couldn't this be the following?\r\n\r\n```suggestion\r\n            metadata = [default] + metadata\r\n```\r\n\r\nI guess because we want other properties on `default` to still be applied at the end?",
      "comment_id": 2143393776,
      "user": "DouweM",
      "created_at": "2025-06-12T18:39:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2143393776"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/fields.py",
      "line": 444,
      "side": "RIGHT",
      "diff_hunk": "@@ -417,58 +400,130 @@ class MyModel(pydantic.BaseModel):\n         final = 'final' in inspected_ann.qualifiers\n         metadata = inspected_ann.metadata\n \n-        if isinstance(default, FieldInfo):\n-            # e.g. `field: int = Field(...)`\n-            default.annotation = type_expr\n-            default.metadata += metadata\n-            merged_default = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                default,\n-                annotation=default.annotation,\n-            )\n-            merged_default.frozen = final or merged_default.frozen\n-            merged_default._qualifiers = inspected_ann.qualifiers\n-            return merged_default\n-\n-        if isinstance(default, dataclasses.Field):\n-            # `collect_dataclass_fields()` passes the dataclass Field as a default.\n-            pydantic_field = FieldInfo._from_dataclass_field(default)\n-            pydantic_field.annotation = type_expr\n-            pydantic_field.metadata += metadata\n-            pydantic_field = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                pydantic_field,\n-                annotation=pydantic_field.annotation,\n-            )\n-            pydantic_field.frozen = final or pydantic_field.frozen\n-            pydantic_field.init_var = 'init_var' in inspected_ann.qualifiers\n-            pydantic_field.init = getattr(default, 'init', None)\n-            pydantic_field.kw_only = getattr(default, 'kw_only', None)\n-            pydantic_field._qualifiers = inspected_ann.qualifiers\n-            return pydantic_field\n-\n-        if not metadata:\n-            # No metadata, e.g. `field: int = ...`, or `field: Final[str] = ...`:\n-            field_info = FieldInfo(annotation=type_expr, default=default, frozen=final or None)\n-            field_info._qualifiers = inspected_ann.qualifiers\n+        # HACK 1: the order in which the metadata is merged is inconsistent; we need to prepend\n+        # metadata from the assignment at the beginning of the metadata. Changing this is only\n+        # possible in v3 (at least). See https://github.com/pydantic/pydantic/issues/10507\n+        prepend_metadata: list[Any] | None = None\n+        attr_overrides = {'annotation': type_expr}\n+        if final:\n+            attr_overrides['frozen'] = True\n+\n+        # HACK 2: FastAPI is subclassing `FieldInfo` and historically expected the actual\n+        # instance's type to be preserved when constructing new models with its subclasses as assignments.\n+        # This code is never reached by Pydantic itself, and in an ideal world this shouldn't be necessary.\n+        if not metadata and isinstance(default, FieldInfo) and type(default) is not FieldInfo:\n+            field_info = default._copy()\n+            field_info._attributes_set.update(attr_overrides)\n+            for k, v in attr_overrides.items():\n+                setattr(field_info, k, v)\n             return field_info\n \n-        # With metadata, e.g. `field: Annotated[int, Field(...), Gt(1)] = ...`:\n-        field_infos = [a for a in metadata if isinstance(a, FieldInfo)]\n-        field_info = FieldInfo.merge_field_infos(*field_infos, annotation=type_expr, default=default)\n-        field_metadata: list[Any] = []\n-        for a in metadata:\n-            if typing_objects.is_deprecated(a):\n-                field_info.deprecated = a.message\n-            elif not isinstance(a, FieldInfo):\n-                field_metadata.append(a)\n-            else:\n-                field_metadata.extend(a.metadata)\n-        field_info.metadata = field_metadata\n+        if isinstance(default, FieldInfo):\n+            default_copy = default._copy()  # Copy unnecessary when we remove HACK 1.\n+            prepend_metadata = default_copy.metadata\n+            default_copy.metadata = []\n+            metadata = metadata + [default_copy]\n+        elif isinstance(default, dataclasses.Field):\n+            from_field = FieldInfo._from_dataclass_field(default)\n+            prepend_metadata = from_field.metadata  # Unnecessary when we remove HACK 1.\n+            from_field.metadata = []\n+            metadata = metadata + [from_field]\n+            if 'init_var' in inspected_ann.qualifiers:\n+                attr_overrides['init_var'] = True\n+            if (init := getattr(default, 'init', None)) is not None:\n+                attr_overrides['init'] = init\n+            if (kw_only := getattr(default, 'kw_only', None)) is not None:\n+                attr_overrides['kw_only'] = kw_only\n+        else:\n+            # `default` is the actual default value\n+            attr_overrides['default'] = default\n+\n+        field_info = FieldInfo._construct(metadata, **attr_overrides)\n         field_info._qualifiers = inspected_ann.qualifiers\n+        if prepend_metadata is not None:\n+            field_info.metadata = prepend_metadata + field_info.metadata",
      "comment": "Why are we assigning this after `_construct` instead of passing it `prepend_metadata + metadata`?",
      "comment_id": 2143396716,
      "user": "DouweM",
      "created_at": "2025-06-12T18:41:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2143396716"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/fields.py",
      "line": 425,
      "side": "RIGHT",
      "diff_hunk": "@@ -417,58 +400,130 @@ class MyModel(pydantic.BaseModel):\n         final = 'final' in inspected_ann.qualifiers\n         metadata = inspected_ann.metadata\n \n-        if isinstance(default, FieldInfo):\n-            # e.g. `field: int = Field(...)`\n-            default.annotation = type_expr\n-            default.metadata += metadata\n-            merged_default = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                default,\n-                annotation=default.annotation,\n-            )\n-            merged_default.frozen = final or merged_default.frozen\n-            merged_default._qualifiers = inspected_ann.qualifiers\n-            return merged_default\n-\n-        if isinstance(default, dataclasses.Field):\n-            # `collect_dataclass_fields()` passes the dataclass Field as a default.\n-            pydantic_field = FieldInfo._from_dataclass_field(default)\n-            pydantic_field.annotation = type_expr\n-            pydantic_field.metadata += metadata\n-            pydantic_field = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                pydantic_field,\n-                annotation=pydantic_field.annotation,\n-            )\n-            pydantic_field.frozen = final or pydantic_field.frozen\n-            pydantic_field.init_var = 'init_var' in inspected_ann.qualifiers\n-            pydantic_field.init = getattr(default, 'init', None)\n-            pydantic_field.kw_only = getattr(default, 'kw_only', None)\n-            pydantic_field._qualifiers = inspected_ann.qualifiers\n-            return pydantic_field\n-\n-        if not metadata:\n-            # No metadata, e.g. `field: int = ...`, or `field: Final[str] = ...`:\n-            field_info = FieldInfo(annotation=type_expr, default=default, frozen=final or None)\n-            field_info._qualifiers = inspected_ann.qualifiers\n+        # HACK 1: the order in which the metadata is merged is inconsistent; we need to prepend\n+        # metadata from the assignment at the beginning of the metadata. Changing this is only\n+        # possible in v3 (at least). See https://github.com/pydantic/pydantic/issues/10507\n+        prepend_metadata: list[Any] | None = None\n+        attr_overrides = {'annotation': type_expr}\n+        if final:\n+            attr_overrides['frozen'] = True\n+\n+        # HACK 2: FastAPI is subclassing `FieldInfo` and historically expected the actual\n+        # instance's type to be preserved when constructing new models with its subclasses as assignments.\n+        # This code is never reached by Pydantic itself, and in an ideal world this shouldn't be necessary.\n+        if not metadata and isinstance(default, FieldInfo) and type(default) is not FieldInfo:\n+            field_info = default._copy()\n+            field_info._attributes_set.update(attr_overrides)\n+            for k, v in attr_overrides.items():\n+                setattr(field_info, k, v)\n             return field_info\n \n-        # With metadata, e.g. `field: Annotated[int, Field(...), Gt(1)] = ...`:\n-        field_infos = [a for a in metadata if isinstance(a, FieldInfo)]\n-        field_info = FieldInfo.merge_field_infos(*field_infos, annotation=type_expr, default=default)\n-        field_metadata: list[Any] = []\n-        for a in metadata:\n-            if typing_objects.is_deprecated(a):\n-                field_info.deprecated = a.message\n-            elif not isinstance(a, FieldInfo):\n-                field_metadata.append(a)\n-            else:\n-                field_metadata.extend(a.metadata)\n-        field_info.metadata = field_metadata\n+        if isinstance(default, FieldInfo):\n+            default_copy = default._copy()  # Copy unnecessary when we remove HACK 1.\n+            prepend_metadata = default_copy.metadata\n+            default_copy.metadata = []\n+            metadata = metadata + [default_copy]",
      "comment": "> I guess because we want other properties on `default` to still be applied at the end?\r\n\r\nExactly, as per https://github.com/pydantic/pydantic/issues/10507, any `FieldInfo` attribute that isn't converted into the `metadata` array (e.g. `description`) is applied correctly.",
      "comment_id": 2144537661,
      "user": "Viicos",
      "created_at": "2025-06-13T08:57:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2144537661"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/fields.py",
      "line": 444,
      "side": "RIGHT",
      "diff_hunk": "@@ -417,58 +400,130 @@ class MyModel(pydantic.BaseModel):\n         final = 'final' in inspected_ann.qualifiers\n         metadata = inspected_ann.metadata\n \n-        if isinstance(default, FieldInfo):\n-            # e.g. `field: int = Field(...)`\n-            default.annotation = type_expr\n-            default.metadata += metadata\n-            merged_default = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                default,\n-                annotation=default.annotation,\n-            )\n-            merged_default.frozen = final or merged_default.frozen\n-            merged_default._qualifiers = inspected_ann.qualifiers\n-            return merged_default\n-\n-        if isinstance(default, dataclasses.Field):\n-            # `collect_dataclass_fields()` passes the dataclass Field as a default.\n-            pydantic_field = FieldInfo._from_dataclass_field(default)\n-            pydantic_field.annotation = type_expr\n-            pydantic_field.metadata += metadata\n-            pydantic_field = FieldInfo.merge_field_infos(\n-                *[x for x in metadata if isinstance(x, FieldInfo)],\n-                pydantic_field,\n-                annotation=pydantic_field.annotation,\n-            )\n-            pydantic_field.frozen = final or pydantic_field.frozen\n-            pydantic_field.init_var = 'init_var' in inspected_ann.qualifiers\n-            pydantic_field.init = getattr(default, 'init', None)\n-            pydantic_field.kw_only = getattr(default, 'kw_only', None)\n-            pydantic_field._qualifiers = inspected_ann.qualifiers\n-            return pydantic_field\n-\n-        if not metadata:\n-            # No metadata, e.g. `field: int = ...`, or `field: Final[str] = ...`:\n-            field_info = FieldInfo(annotation=type_expr, default=default, frozen=final or None)\n-            field_info._qualifiers = inspected_ann.qualifiers\n+        # HACK 1: the order in which the metadata is merged is inconsistent; we need to prepend\n+        # metadata from the assignment at the beginning of the metadata. Changing this is only\n+        # possible in v3 (at least). See https://github.com/pydantic/pydantic/issues/10507\n+        prepend_metadata: list[Any] | None = None\n+        attr_overrides = {'annotation': type_expr}\n+        if final:\n+            attr_overrides['frozen'] = True\n+\n+        # HACK 2: FastAPI is subclassing `FieldInfo` and historically expected the actual\n+        # instance's type to be preserved when constructing new models with its subclasses as assignments.\n+        # This code is never reached by Pydantic itself, and in an ideal world this shouldn't be necessary.\n+        if not metadata and isinstance(default, FieldInfo) and type(default) is not FieldInfo:\n+            field_info = default._copy()\n+            field_info._attributes_set.update(attr_overrides)\n+            for k, v in attr_overrides.items():\n+                setattr(field_info, k, v)\n             return field_info\n \n-        # With metadata, e.g. `field: Annotated[int, Field(...), Gt(1)] = ...`:\n-        field_infos = [a for a in metadata if isinstance(a, FieldInfo)]\n-        field_info = FieldInfo.merge_field_infos(*field_infos, annotation=type_expr, default=default)\n-        field_metadata: list[Any] = []\n-        for a in metadata:\n-            if typing_objects.is_deprecated(a):\n-                field_info.deprecated = a.message\n-            elif not isinstance(a, FieldInfo):\n-                field_metadata.append(a)\n-            else:\n-                field_metadata.extend(a.metadata)\n-        field_info.metadata = field_metadata\n+        if isinstance(default, FieldInfo):\n+            default_copy = default._copy()  # Copy unnecessary when we remove HACK 1.\n+            prepend_metadata = default_copy.metadata\n+            default_copy.metadata = []\n+            metadata = metadata + [default_copy]\n+        elif isinstance(default, dataclasses.Field):\n+            from_field = FieldInfo._from_dataclass_field(default)\n+            prepend_metadata = from_field.metadata  # Unnecessary when we remove HACK 1.\n+            from_field.metadata = []\n+            metadata = metadata + [from_field]\n+            if 'init_var' in inspected_ann.qualifiers:\n+                attr_overrides['init_var'] = True\n+            if (init := getattr(default, 'init', None)) is not None:\n+                attr_overrides['init'] = init\n+            if (kw_only := getattr(default, 'kw_only', None)) is not None:\n+                attr_overrides['kw_only'] = kw_only\n+        else:\n+            # `default` is the actual default value\n+            attr_overrides['default'] = default\n+\n+        field_info = FieldInfo._construct(metadata, **attr_overrides)\n         field_info._qualifiers = inspected_ann.qualifiers\n+        if prepend_metadata is not None:\n+            field_info.metadata = prepend_metadata + field_info.metadata",
      "comment": "Both are equivalent, but indeed passing all the metadata directly to `_construct()` is cleaner. Applied.",
      "comment_id": 2144563306,
      "user": "Viicos",
      "created_at": "2025-06-13T09:12:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2144563306"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -326,20 +326,17 @@ def collect_model_fields(  # noqa: C901\n                 # Note that we only do this for method descriptors for now, we might want to\n                 # extend this to any descriptor in the future (by simply checking for\n                 # `hasattr(assigned_value.default, '__get__')`).\n-                assigned_value.default = assigned_value.default.__get__(None, cls)\n-\n-            # The `from_annotated_attribute()` call below mutates the assigned `Field()`, so make a copy:\n-            original_assignment = (\n-                copy(assigned_value) if not evaluated and isinstance(assigned_value, FieldInfo_) else assigned_value\n-            )\n+                default = assigned_value.default.__get__(None, cls)\n+                assigned_value.default = default\n+                assigned_value._attributes_set['default'] = default",
      "comment": "Where can I subscribe to see when this happens?\n\nApologies if this seems weird to respond to now, please let me know if I should turn this into a proper issue or some such for visibility.\n\nI just spent a few hours adjusting to the v2.12 release, which broke our filter-system. In essence, we're creating lots of filters dynamically using a MetaClass and these filters have pydantic `Field`s. We usually just pass some extra information by setting\n\n```python\n    field.json_schema_extra = {\"sqla_column\": name}\n```\n\nThis used to work with previous versions, but now we need to add\n\n```python\n    field._attributes_set[\"json_schema_extra\"] = {\"sqla_column\": name}\n```\n\nto make the final `pydantic.BaseModel.__new__()` call recognize the `json_schema_extra` attribute.\n\nSo thanks for providing the fix in this comment :)",
      "comment_id": 2413630831,
      "user": "glatterf42",
      "created_at": "2025-10-08T12:04:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2413630831"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -326,20 +326,17 @@ def collect_model_fields(  # noqa: C901\n                 # Note that we only do this for method descriptors for now, we might want to\n                 # extend this to any descriptor in the future (by simply checking for\n                 # `hasattr(assigned_value.default, '__get__')`).\n-                assigned_value.default = assigned_value.default.__get__(None, cls)\n-\n-            # The `from_annotated_attribute()` call below mutates the assigned `Field()`, so make a copy:\n-            original_assignment = (\n-                copy(assigned_value) if not evaluated and isinstance(assigned_value, FieldInfo_) else assigned_value\n-            )\n+                default = assigned_value.default.__get__(None, cls)\n+                assigned_value.default = default\n+                assigned_value._attributes_set['default'] = default",
      "comment": "Not really a specific issue for `_attributes_set`, but I gathered everything into https://github.com/pydantic/pydantic/issues/12374. To be help to give some feedback on your approach (and if extending our metaclass is the only possible option=, I would just require a small example of what your library achieves if possible!",
      "comment_id": 2418264128,
      "user": "Viicos",
      "created_at": "2025-10-10T00:52:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2418264128"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11898,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -326,20 +326,17 @@ def collect_model_fields(  # noqa: C901\n                 # Note that we only do this for method descriptors for now, we might want to\n                 # extend this to any descriptor in the future (by simply checking for\n                 # `hasattr(assigned_value.default, '__get__')`).\n-                assigned_value.default = assigned_value.default.__get__(None, cls)\n-\n-            # The `from_annotated_attribute()` call below mutates the assigned `Field()`, so make a copy:\n-            original_assignment = (\n-                copy(assigned_value) if not evaluated and isinstance(assigned_value, FieldInfo_) else assigned_value\n-            )\n+                default = assigned_value.default.__get__(None, cls)\n+                assigned_value.default = default\n+                assigned_value._attributes_set['default'] = default",
      "comment": "Thanks for your offer and sorry for the late reply! In the meantime, our library was refactored quite substantially, which eliminated our usage of `_attributes_set` :)",
      "comment_id": 2572118575,
      "user": "glatterf42",
      "created_at": "2025-11-28T16:33:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/11898#discussion_r2572118575"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12563,
      "file_path": "tests/test_forward_ref.py",
      "line": 1094,
      "side": "RIGHT",
      "diff_hunk": "@@ -1090,10 +1090,12 @@ def test_pydantic_extra_forward_ref_separate_module(create_module: Any) -> None:\n     def module_1():\n         from pydantic import BaseModel, ConfigDict\n \n+        MyDict = dict\n+",
      "comment": "This was wrongly updated when dropping support for Python 3.9.",
      "comment_id": 2553174445,
      "user": "Viicos",
      "created_at": "2025-11-22T14:55:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/12563#discussion_r2553174445"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12563,
      "file_path": "tests/test_forward_ref.py",
      "line": 1118,
      "side": "RIGHT",
      "diff_hunk": "@@ -1113,6 +1115,42 @@ class Foo(BaseModel):\n     assert extras_schema == {'type': 'int'}\n \n \n+def test_pydantic_extra_forward_ref_separate_module_subclass(create_module: Any) -> None:",
      "comment": "This was a use case that wasn't working until now.",
      "comment_id": 2553174547,
      "user": "Viicos",
      "created_at": "2025-11-22T14:55:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/12563#discussion_r2553174547"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12563,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,6 +42,13 @@ class PydanticMetadata(Representation):\n     __slots__ = ()\n \n \n+@dataclasses.dataclass(**slots_true)  # TODO: make kw_only when we drop support for 3.9.\n+class PydanticExtraInfo:\n+    # TODO: make use of PEP 747:\n+    annotation: Any",
      "comment": "`typing_extensions.TypeForm`? Or is the point that we'll need to update places across the code for this?",
      "comment_id": 2555593501,
      "user": "davidhewitt",
      "created_at": "2025-11-24T10:14:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/12563#discussion_r2555593501"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12563,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 970,
      "side": "RIGHT",
      "diff_hunk": "@@ -978,6 +965,9 @@ def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) ->\n         if args:\n             if isinstance(obj, GenericAlias):\n                 # PEP 585 generic aliases don't convert args to ForwardRefs, unlike `typing.List/Dict` etc.\n+                # This was fixed in https://github.com/python/cpython/pull/30900 (Python 3.11).\n+                # TODO: this shouldn't be necessary (probably even this `_get_args_resolving_forward_refs()` function)\n+                # once we drop support for Python 3.10 *or* if we implement our own `typing._eval_type()` implementation.",
      "comment": "Should we update the `isinstance` to have a condition on `sys.version_info < (3, 11)` (or even just make the whole function just return early)?",
      "comment_id": 2555611087,
      "user": "davidhewitt",
      "created_at": "2025-11-24T10:18:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/12563#discussion_r2555611087"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12563,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,6 +42,13 @@ class PydanticMetadata(Representation):\n     __slots__ = ()\n \n \n+@dataclasses.dataclass(**slots_true)  # TODO: make kw_only when we drop support for 3.9.\n+class PydanticExtraInfo:\n+    # TODO: make use of PEP 747:\n+    annotation: Any",
      "comment": "Yes, once the PEP is accepted I'll grep for this type of comment and replace.",
      "comment_id": 2555793503,
      "user": "Viicos",
      "created_at": "2025-11-24T11:00:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/12563#discussion_r2555793503"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12563,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 970,
      "side": "RIGHT",
      "diff_hunk": "@@ -978,6 +965,9 @@ def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) ->\n         if args:\n             if isinstance(obj, GenericAlias):\n                 # PEP 585 generic aliases don't convert args to ForwardRefs, unlike `typing.List/Dict` etc.\n+                # This was fixed in https://github.com/python/cpython/pull/30900 (Python 3.11).\n+                # TODO: this shouldn't be necessary (probably even this `_get_args_resolving_forward_refs()` function)\n+                # once we drop support for Python 3.10 *or* if we implement our own `typing._eval_type()` implementation.",
      "comment": "In theory we could, but I'm a bit worried this would introduce subtle regressions for other annotations that were not actually evaluated (and not due to the <3.11 bug). The end goal is to have the guarantee that everything passed to `GenerateSchema` is evaluated, but I'm not entirely sure this is the case yet, so probably I'll try to tackle this properly separately.",
      "comment_id": 2555802965,
      "user": "Viicos",
      "created_at": "2025-11-24T11:03:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/12563#discussion_r2555802965"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12560,
      "file_path": "pydantic/config.py",
      "line": 599,
      "side": "RIGHT",
      "diff_hunk": "@@ -588,10 +595,10 @@ class Transaction(BaseModel):\n \n     Defaults to `'iso8601'`.\n \n-    !!! note\n-        This setting was introduced in v2.12. It overlaps with the [`ser_json_timedelta`][pydantic.config.ConfigDict.ser_json_timedelta]\n-        setting which will be deprecated in v3. It also adds more configurability for\n-        the other temporal types.\n+    /// version-added | v2.12\n+    This setting is meant to be a replacement for [`ser_json_timedelta`][pydantic.config.ConfigDict.ser_json_timedelta],",
      "comment": "```suggestion\n    This setting replaces [`ser_json_timedelta`][pydantic.config.ConfigDict.ser_json_timedelta],\n```",
      "comment_id": 2549669485,
      "user": "davidhewitt",
      "created_at": "2025-11-21T12:51:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/12560#discussion_r2549669485"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12560,
      "file_path": "pydantic/config.py",
      "line": 1148,
      "side": "RIGHT",
      "diff_hunk": "@@ -1120,6 +1141,12 @@ class Model(BaseModel):\n         This would make it impossible to populate an attribute.\n \n         See [usage errors](../errors/usage_errors.md#validate-by-alias-and-name-false) for an example.\n+\n+    /// version-added | v2.11\n+    This setting was introduced in conjunction with [`validate_by_alias`][pydantic.ConfigDict.validate_by_alias]\n+    to empower users with more fine grained validation control. It is an alternative to [`populate_by_name`][pydantic.ConfigDict.populate_by_name],\n+    thas enames validation by name **and** by alias.",
      "comment": "```suggestion\n    that enables validation by name **and** by alias.\n```",
      "comment_id": 2549674368,
      "user": "davidhewitt",
      "created_at": "2025-11-21T12:53:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/12560#discussion_r2549674368"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12536,
      "file_path": "tests/test_decorators.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,3 +115,32 @@ def serializer():\n         inspect_annotated_serializer(serializer, mode=mode)\n \n     assert e.value.code == 'field-serializer-signature'\n+\n+\n+def test_plain_class_not_mutated() -> None:\n+    class A:\n+        @computed_field\n+        def func(self) -> int:\n+            return 1\n+\n+    class B(A, BaseModel):\n+        pass\n+\n+    assert B.__pydantic_decorators__.computed_fields['func'].cls_var_name == 'func'\n+\n+    assert '__pydantic_decorators__' not in A.__dict__\n+\n+\n+def test_decorator_info_not_mutated() -> None:\n+    class A(BaseModel):\n+        @computed_field\n+        def func(self) -> int:\n+            return 1\n+\n+    assert A.__pydantic_decorators__.computed_fields['func'].info.title is None\n+\n+    class B(A, field_title_generator=lambda _, __: 'test'):\n+        pass\n+\n+    assert A.__pydantic_decorators__.computed_fields['func'].info.title is None\n+    assert B.__pydantic_decorators__.computed_fields['func'].info.title == 'test'",
      "comment": "This seems strange that `B` is able to change semantics of fields on A?",
      "comment_id": 2534468162,
      "user": "davidhewitt",
      "created_at": "2025-11-17T15:10:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/12536#discussion_r2534468162"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12536,
      "file_path": "pydantic/fields.py",
      "line": 1522,
      "side": "RIGHT",
      "diff_hunk": "@@ -1519,7 +1519,7 @@ def PrivateAttr(\n     )\n \n \n-@dataclasses.dataclass(**_internal_dataclass.slots_true)\n+@dataclasses.dataclass",
      "comment": "I guess removing slots made the copy implementation _easier_, but if it's better performance to keep it, should we just do the more complex `copy` implementation which does all fields by hand?.",
      "comment_id": 2534473000,
      "user": "davidhewitt",
      "created_at": "2025-11-17T15:11:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/12536#discussion_r2534473000"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12536,
      "file_path": "tests/test_decorators.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,3 +115,32 @@ def serializer():\n         inspect_annotated_serializer(serializer, mode=mode)\n \n     assert e.value.code == 'field-serializer-signature'\n+\n+\n+def test_plain_class_not_mutated() -> None:\n+    class A:\n+        @computed_field\n+        def func(self) -> int:\n+            return 1\n+\n+    class B(A, BaseModel):\n+        pass\n+\n+    assert B.__pydantic_decorators__.computed_fields['func'].cls_var_name == 'func'\n+\n+    assert '__pydantic_decorators__' not in A.__dict__\n+\n+\n+def test_decorator_info_not_mutated() -> None:\n+    class A(BaseModel):\n+        @computed_field\n+        def func(self) -> int:\n+            return 1\n+\n+    assert A.__pydantic_decorators__.computed_fields['func'].info.title is None\n+\n+    class B(A, field_title_generator=lambda _, __: 'test'):\n+        pass\n+\n+    assert A.__pydantic_decorators__.computed_fields['func'].info.title is None\n+    assert B.__pydantic_decorators__.computed_fields['func'].info.title == 'test'",
      "comment": "It also applies to normal fields. In some way, the inheritance can be seen as a way to reuse existing fields, similar to what it means to make subclasses of `TypedDict`s. Anyway, this is only relevant for `field_title_generator` and `alias_generator` _and_ when subclassing and specifying these config, so quite unusual.",
      "comment_id": 2534611673,
      "user": "Viicos",
      "created_at": "2025-11-17T15:49:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/12536#discussion_r2534611673"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12500,
      "file_path": "pydantic-core/tests/validators/test_decimal.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +92,41 @@ def test_decimal(py_and_json: PyAndJson, input_value, expected):\n         assert isinstance(output, Decimal)\n \n \n+@pytest.mark.parametrize(\n+    'input_value,expected',\n+    [\n+        # Three-tuple constructor: (sign, (digits...), exponent)\n+        # sign: 0 for positive, 1 for negative\n+        # digits: tuple of digits\n+        # exponent: integer exponent\n+        ((0, (1, 4, 1, 4), -3), Decimal('1.414')),\n+        ((0, (1, 2, 3), 0), Decimal('123')),\n+        ((0, (1, 2, 3), 2), Decimal('12300')),\n+        ((0, (1, 2, 3), -2), Decimal('1.23')),\n+        ((1, (1, 4, 1, 4), -3), Decimal('-1.414')),\n+        ((1, (1, 2, 3), 0), Decimal('-123')),\n+        ((1, (1, 2, 3), 2), Decimal('-12300')),\n+        ((1, (1, 2, 3), -2), Decimal('-1.23')),\n+        ((0, (0,), 0), Decimal('0')),\n+        ((0, (5,), -1), Decimal('0.5')),\n+        ((1, (5,), -1), Decimal('-0.5')),\n+        ((0, (1, 0, 0), -2), Decimal('1.00')),\n+        ((0, (9, 9, 9), 3), Decimal('999000')),\n+    ],\n+    ids=repr,\n+)\n+def test_decimal_three_tuple_constructor(py_and_json: PyAndJson, input_value, expected):\n+    \"\"\"Test that Decimal can be constructed from a three-tuple (sign, digits, exponent).\"\"\"\n+    v = py_and_json({'type': 'decimal'})",
      "comment": "```suggestion\r\n    v = py_and_json(cs.decimal_schema())\r\n```",
      "comment_id": 2517465961,
      "user": "Viicos",
      "created_at": "2025-11-12T09:00:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/12500#discussion_r2517465961"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12500,
      "file_path": "pydantic-core/tests/validators/test_decimal.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +92,41 @@ def test_decimal(py_and_json: PyAndJson, input_value, expected):\n         assert isinstance(output, Decimal)\n \n \n+@pytest.mark.parametrize(\n+    'input_value,expected',\n+    [\n+        # Three-tuple constructor: (sign, (digits...), exponent)\n+        # sign: 0 for positive, 1 for negative\n+        # digits: tuple of digits\n+        # exponent: integer exponent\n+        ((0, (1, 4, 1, 4), -3), Decimal('1.414')),\n+        ((0, (1, 2, 3), 0), Decimal('123')),\n+        ((0, (1, 2, 3), 2), Decimal('12300')),\n+        ((0, (1, 2, 3), -2), Decimal('1.23')),\n+        ((1, (1, 4, 1, 4), -3), Decimal('-1.414')),\n+        ((1, (1, 2, 3), 0), Decimal('-123')),\n+        ((1, (1, 2, 3), 2), Decimal('-12300')),\n+        ((1, (1, 2, 3), -2), Decimal('-1.23')),\n+        ((0, (0,), 0), Decimal('0')),\n+        ((0, (5,), -1), Decimal('0.5')),\n+        ((1, (5,), -1), Decimal('-0.5')),\n+        ((0, (1, 0, 0), -2), Decimal('1.00')),\n+        ((0, (9, 9, 9), 3), Decimal('999000')),\n+    ],\n+    ids=repr,\n+)\n+def test_decimal_three_tuple_constructor(py_and_json: PyAndJson, input_value, expected):\n+    \"\"\"Test that Decimal can be constructed from a three-tuple (sign, digits, exponent).\"\"\"\n+    v = py_and_json({'type': 'decimal'})\n+    # Three-tuple constructor is only valid for Python input, not JSON\n+    if v.validator_type == 'json':\n+        # For JSON, we skip this test as tuples aren't JSON serializable\n+        pytest.skip('Three-tuple constructor is only valid for Python input')",
      "comment": "We actually want to validate in JSON as well (with array values).",
      "comment_id": 2517469953,
      "user": "Viicos",
      "created_at": "2025-11-12T09:01:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/12500#discussion_r2517469953"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12373,
      "file_path": "tests/test_fields.py",
      "line": 371,
      "side": "RIGHT",
      "diff_hunk": "@@ -353,3 +353,19 @@ def test_default_factory_validated_data_argument_unsupported() -> None:\n         ),\n     ):\n         TypeAdapter(Annotated[int, Field(default_factory=lambda v: v['key'])])\n+\n+\n+def test_default_factory_without_validated_data_unsupported() -> None:\n+    with pytest.raises(ValueError):\n+\n+        class FooBar(BaseModel):\n+            a: int = Field(default_factory=lambda x: x)\n+\n+        [field.get_default(call_default_factory=True) for field in FooBar.model_fields.values()]\n+\n+\n+def test_default_factory_without_flag() -> None:\n+    class FooBar(BaseModel):\n+        a: int = Field(default_factory=lambda x: x)\n+\n+    assert [field.get_default() for field in FooBar.model_fields.values()] == [None]",
      "comment": "```suggestion\r\ndef test_default_factory_without_validated_data_unsupported() -> None:\r\n    class FooBar(BaseModel):\r\n        a: int = Field(default_factory=lambda x: x)\r\n \r\n    assert FooBar.model_fields['a'].get_default() is None\r\n          \r\n    with pytest.raises(ValueError):\r\n        FooBar.model_fields['a'].get_default(call_default_factory=True)\r\n```",
      "comment_id": 2418103389,
      "user": "Viicos",
      "created_at": "2025-10-09T22:39:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/12373#discussion_r2418103389"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12511,
      "file_path": "pydantic/config.py",
      "line": 536,
      "side": "LEFT",
      "diff_hunk": "@@ -491,123 +491,70 @@ class Model(BaseModel):\n     # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'\n     revalidate_instances: Literal['always', 'never', 'subclass-instances']\n     \"\"\"\n-    When and how to revalidate models and dataclasses during validation. Accepts the string\n-    values of `'never'`, `'always'` and `'subclass-instances'`. Defaults to `'never'`.\n+    When and how to revalidate models and dataclasses during validation. Can be one of:\n \n-    - `'never'` will not revalidate models and dataclasses during validation\n-    - `'always'` will revalidate models and dataclasses during validation\n-    - `'subclass-instances'` will revalidate models and dataclasses during validation if the instance is a\n+    - `'never'`: will *not* revalidate models and dataclasses during validation\n+    - `'always'`: will revalidate models and dataclasses during validation\n+    - `'subclass-instances'`: will revalidate models and dataclasses during validation if the instance is a\n         subclass of the model or dataclass\n \n-    By default, model and dataclass instances are not revalidated during validation.\n+    The default is `'never'` (no revalidation).\n+\n+    This configuration only affects *the current model* it is applied on, and does *not* populate to the models\n+    referenced in fields.\n \n     ```python\n     from pydantic import BaseModel\n \n     class User(BaseModel, revalidate_instances='never'):  # (1)!\n-        hobbies: list[str]\n-\n-    class SubUser(User):\n-        sins: list[str]\n+        name: str\n \n     class Transaction(BaseModel):\n         user: User\n \n-    my_user = User(hobbies=['reading'])\n+    my_user = User(name='John')\n     t = Transaction(user=my_user)\n-    print(t)\n-    #> user=User(hobbies=['reading'])\n \n-    my_user.hobbies = [1]  # (2)!\n+    my_user.name = 1  # (2)!\n     t = Transaction(user=my_user)  # (3)!\n     print(t)\n-    #> user=User(hobbies=[1])\n-\n-    my_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\n-    t = Transaction(user=my_sub_user)\n-    print(t)\n-    #> user=SubUser(hobbies=['scuba diving'], sins=['lying'])\n+    #> user=User(name=1)\n     ```\n \n-    1. `revalidate_instances` is set to `'never'` by **default.\n-    2. The assignment is not validated, unless you set `validate_assignment` to `True` in the model's config.\n-    3. Since `revalidate_instances` is set to `never`, this is not revalidated.\n+    1. This is the default behavior.\n+    2. The assignment is *not* validated, unless you set [`validate_assignment`][pydantic.ConfigDict.validate_assignment] in the configuration.\n+    3. Since `revalidate_instances` is set to `'never'`, the user instance is not revalidated.\n \n-    If you want to revalidate instances during validation, you can set `revalidate_instances` to `'always'`",
      "comment": "Don't think this example hurt but it's also fine to delete",
      "comment_id": 2512032415,
      "user": "davidhewitt",
      "created_at": "2025-11-10T21:32:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/12511#discussion_r2512032415"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12511,
      "file_path": "pydantic/config.py",
      "line": 536,
      "side": "LEFT",
      "diff_hunk": "@@ -491,123 +491,70 @@ class Model(BaseModel):\n     # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'\n     revalidate_instances: Literal['always', 'never', 'subclass-instances']\n     \"\"\"\n-    When and how to revalidate models and dataclasses during validation. Accepts the string\n-    values of `'never'`, `'always'` and `'subclass-instances'`. Defaults to `'never'`.\n+    When and how to revalidate models and dataclasses during validation. Can be one of:\n \n-    - `'never'` will not revalidate models and dataclasses during validation\n-    - `'always'` will revalidate models and dataclasses during validation\n-    - `'subclass-instances'` will revalidate models and dataclasses during validation if the instance is a\n+    - `'never'`: will *not* revalidate models and dataclasses during validation\n+    - `'always'`: will revalidate models and dataclasses during validation\n+    - `'subclass-instances'`: will revalidate models and dataclasses during validation if the instance is a\n         subclass of the model or dataclass\n \n-    By default, model and dataclass instances are not revalidated during validation.\n+    The default is `'never'` (no revalidation).\n+\n+    This configuration only affects *the current model* it is applied on, and does *not* populate to the models\n+    referenced in fields.\n \n     ```python\n     from pydantic import BaseModel\n \n     class User(BaseModel, revalidate_instances='never'):  # (1)!\n-        hobbies: list[str]\n-\n-    class SubUser(User):\n-        sins: list[str]\n+        name: str\n \n     class Transaction(BaseModel):\n         user: User\n \n-    my_user = User(hobbies=['reading'])\n+    my_user = User(name='John')\n     t = Transaction(user=my_user)\n-    print(t)\n-    #> user=User(hobbies=['reading'])\n \n-    my_user.hobbies = [1]  # (2)!\n+    my_user.name = 1  # (2)!\n     t = Transaction(user=my_user)  # (3)!\n     print(t)\n-    #> user=User(hobbies=[1])\n-\n-    my_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\n-    t = Transaction(user=my_sub_user)\n-    print(t)\n-    #> user=SubUser(hobbies=['scuba diving'], sins=['lying'])\n+    #> user=User(name=1)\n     ```\n \n-    1. `revalidate_instances` is set to `'never'` by **default.\n-    2. The assignment is not validated, unless you set `validate_assignment` to `True` in the model's config.\n-    3. Since `revalidate_instances` is set to `never`, this is not revalidated.\n+    1. This is the default behavior.\n+    2. The assignment is *not* validated, unless you set [`validate_assignment`][pydantic.ConfigDict.validate_assignment] in the configuration.\n+    3. Since `revalidate_instances` is set to `'never'`, the user instance is not revalidated.\n \n-    If you want to revalidate instances during validation, you can set `revalidate_instances` to `'always'`",
      "comment": "I kept only the `'subclass-instances'` example as it somehow also shows what is the behavior with a \"direct\" instance, and the fact that it is _not_ revalidated with `'subclass-instances'` (and then users can easily assume it would have been with `'always'`). I generally try to reduce the size of the examples as it adds cognitive overhead to understand them, and when I see too long examples by brain usually just gives up.",
      "comment_id": 2513568128,
      "user": "Viicos",
      "created_at": "2025-11-11T09:55:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/12511#discussion_r2513568128"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12495,
      "file_path": "tests/test_dataclasses.py",
      "line": 706,
      "side": "RIGHT",
      "diff_hunk": "@@ -686,6 +686,35 @@ class TestInitVar:\n         TestInitVar(1, 2, 0)\n \n \n+def test_initvar_pydantic_field() -> None:\n+    @pydantic.dataclasses.dataclass\n+    class TestInitVar:\n+        x: InitVar[int] = Field(title='X')\n+\n+        def __post_init__(self, x: int):\n+            assert x == 1\n+\n+    assert TestInitVar.__pydantic_fields__['x'].init_var\n+\n+    t = TestInitVar(x=1)\n+\n+    with pytest.raises(AttributeError):\n+        t.x\n+\n+\n+@pytest.mark.xfail(reason='Ideally we should raise an attribute error, like stdlib dataclasses')\n+def test_initvar_pydantic_field() -> None:",
      "comment": "```suggestion\r\ndef test_initvar_pydantic_field_attribute_access() -> None:\r\n```",
      "comment_id": 2503936803,
      "user": "Viicos",
      "created_at": "2025-11-07T14:45:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/12495#discussion_r2503936803"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12028,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 429,
      "side": "LEFT",
      "diff_hunk": "@@ -413,22 +411,6 @@ def collect_model_fields(  # noqa: C901\n     return fields, class_vars\n \n \n-def _warn_on_nested_alias_in_annotation(ann_type: type[Any], ann_name: str) -> None:\n-    FieldInfo = import_cached_field_info()\n-\n-    args = getattr(ann_type, '__args__', None)\n-    if args:\n-        for anno_arg in args:\n-            if typing_objects.is_annotated(get_origin(anno_arg)):\n-                for anno_type_arg in _typing_extra.get_args(anno_arg):\n-                    if isinstance(anno_type_arg, FieldInfo) and anno_type_arg.alias is not None:\n-                        warnings.warn(\n-                            f'`alias` specification on field \"{ann_name}\" must be set on outermost annotation to take effect.',\n-                            UserWarning,\n-                        )\n-                        return",
      "comment": "This was fragile logic implemented a long time ago, that is now fully covered by the new warning.",
      "comment_id": 2175579732,
      "user": "Viicos",
      "created_at": "2025-06-30T17:36:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/12028#discussion_r2175579732"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12028,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 587,
      "side": "RIGHT",
      "diff_hunk": "@@ -562,7 +579,15 @@ def _mapping_schema(self, tp: Any, keys_type: Any, values_type: Any) -> CoreSche\n \n         mapped_origin = MAPPING_ORIGIN_MAP[tp]\n         keys_schema = self.generate_schema(keys_type)\n-        values_schema = self.generate_schema(values_type)\n+        with warnings.catch_warnings():\n+            # We kind of abused `Field()` default factories to be able to specify\n+            # the `defaultdict`'s `default_factory`. As a consequence, we get warnings\n+            # as normally `FieldInfo.default_factory` is unsupported in the context where\n+            # `Field()` is used and our only solution is to ignore them (note that this might\n+            # wrongfully ignore valid warnings, e.g. if the `value_type` to a PEP 695 type alias",
      "comment": "This is referring to the following use case:\n\n```python\nclass Model(BaseModel):\n    a: defaultdict[int, Annotated[list[int], Field(default_factory=lambda: MyList())]]\n```",
      "comment_id": 2175581350,
      "user": "Viicos",
      "created_at": "2025-06-30T17:37:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/12028#discussion_r2175581350"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12028,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1559,
      "side": "RIGHT",
      "diff_hunk": "@@ -1525,7 +1550,14 @@ def _generate_parameter_schema(\n         update_field_from_config(self._config_wrapper, name, field)\n \n         with self.field_name_stack.push(name):\n-            schema = self._apply_annotations(field.annotation, [field])\n+            schema = self._apply_annotations(\n+                field.annotation,\n+                [field],\n+                # Because we pass `field` as metadata above (required for attributes relevant for\n+                # JSON Scheme generation), we need to ignore the potential warnings about `FieldInfo`\n+                # attributes that will not be used:\n+                check_unsupported_field_info_attributes=False,",
      "comment": "This is for validated function calls (see `test_unsupported_field_attribute_nested_with_function()`). We don't want to raise a warning for:\n\n```python\n@validate_call\ndef func(a: Annotated[int, Field(alias='b')]): ...\n```",
      "comment_id": 2175584535,
      "user": "Viicos",
      "created_at": "2025-06-30T17:39:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/12028#discussion_r2175584535"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12028,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2220,
      "side": "RIGHT",
      "diff_hunk": "@@ -2159,10 +2202,27 @@ def inner_handler(obj: Any) -> CoreSchema:\n             update_core_metadata(core_metadata, pydantic_js_annotation_functions=pydantic_js_annotation_functions)\n         return _add_custom_serialization_from_json_encoders(self._config_wrapper.json_encoders, source_type, schema)\n \n-    def _apply_single_annotation(self, schema: core_schema.CoreSchema, metadata: Any) -> core_schema.CoreSchema:\n+    def _apply_single_annotation(\n+        self,\n+        schema: core_schema.CoreSchema,\n+        metadata: Any,\n+        check_unsupported_field_info_attributes: bool = True,\n+    ) -> core_schema.CoreSchema:\n         FieldInfo = import_cached_field_info()\n \n         if isinstance(metadata, FieldInfo):\n+            if check_unsupported_field_info_attributes and (\n+                unsupported_attributes := self._get_unsupported_field_info_attributes(metadata)\n+            ):\n+                for unsupported_attr in unsupported_attributes:\n+                    warnings.warn(\n+                        f'The {unsupported_attr[0]!r} attribute with value {unsupported_attr[1]!r} was provided '\n+                        'to the `Field()` function, which is unsupported in the context it was used. '",
      "comment": "```suggestion\n                        'to the `Field()` function, which has no effect in the context it was used. '\n```\n\nmaybe?",
      "comment_id": 2175585140,
      "user": "Viicos",
      "created_at": "2025-06-30T17:39:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/12028#discussion_r2175585140"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12028,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2217,
      "side": "RIGHT",
      "diff_hunk": "@@ -2158,10 +2202,27 @@ def inner_handler(obj: Any) -> CoreSchema:\n             update_core_metadata(core_metadata, pydantic_js_annotation_functions=pydantic_js_annotation_functions)\n         return _add_custom_serialization_from_json_encoders(self._config_wrapper.json_encoders, source_type, schema)\n \n-    def _apply_single_annotation(self, schema: core_schema.CoreSchema, metadata: Any) -> core_schema.CoreSchema:\n+    def _apply_single_annotation(\n+        self,\n+        schema: core_schema.CoreSchema,\n+        metadata: Any,\n+        check_unsupported_field_info_attributes: bool = True,\n+    ) -> core_schema.CoreSchema:\n         FieldInfo = import_cached_field_info()\n \n         if isinstance(metadata, FieldInfo):\n+            if check_unsupported_field_info_attributes and (\n+                unsupported_attributes := self._get_unsupported_field_info_attributes(metadata)\n+            ):\n+                for unsupported_attr in unsupported_attributes:",
      "comment": "Can we do `for (attr, value) in unsupported_attributes` so we don't need `[0]` and `[1]`?",
      "comment_id": 2177807207,
      "user": "DouweM",
      "created_at": "2025-07-01T14:46:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/12028#discussion_r2177807207"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12028,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2285,
      "side": "RIGHT",
      "diff_hunk": "@@ -2216,11 +2277,34 @@ def _apply_single_annotation_json_schema(\n             )\n         return schema\n \n+    def _get_unsupported_field_info_attributes(self, field_info: FieldInfo) -> list[tuple[str, Any]]:\n+        \"\"\"Get the list of unsupported `FieldInfo` attributes when not directly used in `Annotated` for field annotations.\"\"\"\n+        unused_metadata: list[tuple[str, Any]] = []\n+        for unused_metadata_name in UNSUPPORTED_STANDALONE_FIELDINFO_ATTRIBUTES:\n+            if (\n+                unused_metadata_name in field_info._attributes_set",
      "comment": "If we make `UNSUPPORTED_STANDALONE_FIELDINFO_ATTRIBUTES` a set as well, we could potentially clean this up a bit by using `unsupported_attributes = UNSUPPORTED_STANDALONE_FIELDINFO_ATTRIBUTES & field_info._attributes_set` and then iterating over those\r\n\r\nEdit: Likely not relevant because we added the default values to `UNSUPPORTED_STANDALONE_FIELDINFO_ATTRIBUTES` in a later commit",
      "comment_id": 2177816765,
      "user": "DouweM",
      "created_at": "2025-07-01T14:49:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/12028#discussion_r2177816765"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12420,
      "file_path": "tests/test_validators.py",
      "line": 3105,
      "side": "RIGHT",
      "diff_hunk": "@@ -3101,3 +3101,23 @@ def wrapped_field_serializer(cls, field_value, validator):\n \n     my_model = MyParentModel.model_validate({'nested': {'inner_value': 'foo'}})\n     assert my_model.nested.inner_value == 'after_prefix:wrap_prefix:foo'\n+\n+@pytest.mark.xfail(reason=\"Bug: Nested 'after' model_validator is re-executed. See issue #8452.\", raises=AssertionError)",
      "comment": "```suggestion\n@pytest.mark.xfail(reason=\"Bug: Nested 'after' model_validator is re-executed. See issue #8452.\", raises=ValidationError)\n```",
      "comment_id": 2454969535,
      "user": "davidhewitt",
      "created_at": "2025-10-23T12:31:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/12420#discussion_r2454969535"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12420,
      "file_path": "tests/test_validators.py",
      "line": 3123,
      "side": "RIGHT",
      "diff_hunk": "@@ -3101,3 +3101,23 @@ def wrapped_field_serializer(cls, field_value, validator):\n \n     my_model = MyParentModel.model_validate({'nested': {'inner_value': 'foo'}})\n     assert my_model.nested.inner_value == 'after_prefix:wrap_prefix:foo'\n+\n+@pytest.mark.xfail(reason=\"Bug: Nested 'after' model_validator is re-executed. See issue #8452.\", raises=AssertionError)\n+def test_nested_model_validator_not_reexecuted():\n+    \"\"\"See https://github.com/pydantic/pydantic/issues/8452 for context.\n+\n+    Reproduces the bug in issue #8452 where a nested model's `model_validator` with `mode='after'` is unexpectedly re-executed.\n+    \"\"\"\n+    class Sub(BaseModel):\n+        @model_validator(mode='after')\n+        def _validate(self):\n+            # This line should not be reached when `Sub` is nested inside `Base`\n+            assert False, 'Sub model_validator was re-executed'\n+\n+    class Base(BaseModel):\n+        sub: Sub #<-- This throws assertionerror\n+\n+    sub: Sub = Sub.model_construct() # Create a Sub instance without triggering validation (e.g., using model_construct)\n+    \n+    # Attempt to create Base with the Sub instance. This line should succeed if the bug is fixed, but currently raises ValidationError.\n+    base: Base = Base(sub=sub) # <-- This throws AssertionError because Sub's 'after' validator runs again.",
      "comment": "```suggestion\n    Base(sub=sub) # <-- This throws AssertionError because Sub's 'after' validator runs again.\n```",
      "comment_id": 2454970072,
      "user": "davidhewitt",
      "created_at": "2025-10-23T12:31:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/12420#discussion_r2454970072"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12430,
      "file_path": "pydantic/json_schema.py",
      "line": 1760,
      "side": "LEFT",
      "diff_hunk": "@@ -1756,13 +1756,19 @@ def field_is_required(\n         Returns:\n             `True` if the field should be marked as required in the generated JSON schema, `False` otherwise.\n         \"\"\"\n-        if self.mode == 'serialization' and self._config.json_schema_serialization_defaults_required:\n-            return not field.get('serialization_exclude')",
      "comment": "Note that there's a change in behavior here, but should be considered as a bug fix: we only take into account `serialization_exclude` if `json_schema_serialization_defaults_required=True`, which doesn't really make sense.",
      "comment_id": 2445335651,
      "user": "Viicos",
      "created_at": "2025-10-20T15:20:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/12430#discussion_r2445335651"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12411,
      "file_path": "pydantic/fields.py",
      "line": 241,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,10 +231,14 @@ def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:\n \n         See the signature of `pydantic.fields.Field` for more details about the expected arguments.\n         \"\"\"\n+        # Tracking the explicitly set attributes is necessary to correctly merge `Field()` functions\n+        # (e.g. with `Annotated[int, Field(alias='a'), Field(alias=None)]`, even though `None` is the default value,\n+        # we need to track that `alias=None` was explicitly set):\n         self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset and k not in self.metadata_lookup}\n         kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore\n         self.annotation = kwargs.get('annotation')\n \n+        # Note: in theory, the second `pop()` arguments are not required below, as defaults are already set from `_DefaultsValues`.",
      "comment": "As you can see in this PR, I added the missing default values in `_DefaultsValues`, including the one for `deprecated` (but it is only bound to happen again with this complex logic..)  ",
      "comment_id": 2439409032,
      "user": "Viicos",
      "created_at": "2025-10-17T11:14:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/12411#discussion_r2439409032"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11957,
      "file_path": "pydantic/functional_validators.py",
      "line": 716,
      "side": "RIGHT",
      "diff_hunk": "@@ -713,7 +713,8 @@ def verify_square(self) -> Self:\n \n     def dec(f: Any) -> _decorators.PydanticDescriptorProxy[Any]:\n         # auto apply the @classmethod decorator\n-        f = _decorators.ensure_classmethod_based_on_signature(f)\n+        if mode != 'after':",
      "comment": "I think it's worth putting a comment in to explain why we want this in all modes except for `after`.",
      "comment_id": 2143334773,
      "user": "DouweM",
      "created_at": "2025-06-12T17:55:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/11957#discussion_r2143334773"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11957,
      "file_path": "tests/test_model_validator.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,3 +136,13 @@ def validate_model_after(self) -> Model:\n     Model.model_validate({'inner': {'inner': {'inner': None}}})\n     assert calls == ['before'] * 3 + ['after'] * 3\n     calls.clear()\n+\n+\n+def test_after_validator_wrong_signature() -> None:\n+    with pytest.raises(PydanticUserError):\n+\n+        class Model(BaseModel):\n+            @model_validator(mode='after')\n+            # This used to be converted into a classmethod, resulting\n+            # in this inconsistent signature still accepted:\n+            def validator(cls, model, info): ...",
      "comment": "Shouldn't this be `self` instead of `cls` in this case?",
      "comment_id": 2417020325,
      "user": "antazoey",
      "created_at": "2025-10-09T14:32:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/11957#discussion_r2417020325"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11957,
      "file_path": "tests/test_model_validator.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,3 +136,13 @@ def validate_model_after(self) -> Model:\n     Model.model_validate({'inner': {'inner': {'inner': None}}})\n     assert calls == ['before'] * 3 + ['after'] * 3\n     calls.clear()\n+\n+\n+def test_after_validator_wrong_signature() -> None:\n+    with pytest.raises(PydanticUserError):\n+\n+        class Model(BaseModel):\n+            @model_validator(mode='after')\n+            # This used to be converted into a classmethod, resulting\n+            # in this inconsistent signature still accepted:\n+            def validator(cls, model, info): ...",
      "comment": "This is wrapped in a `pytest.raises()` context manager, and was meant to test that this particular invalid signature is now rejected.",
      "comment_id": 2417108247,
      "user": "Viicos",
      "created_at": "2025-10-09T15:17:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/11957#discussion_r2417108247"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12366,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 560,
      "side": "RIGHT",
      "diff_hunk": "@@ -554,7 +557,7 @@ def inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes)\n             return False\n \n     raise PydanticUserError(\n-        f'Unrecognized field_validator function signature for {validator} with `mode={mode}`:{sig}',\n+        f'Unrecognized {type} function signature for {validator} with `mode={mode}`: {sig}',",
      "comment": "```suggestion\n        f'Unrecognized {type}_validator function signature for {validator} with `mode={mode}`: {sig}',\n```",
      "comment_id": 2419159200,
      "user": "davidhewitt",
      "created_at": "2025-10-10T10:00:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/12366#discussion_r2419159200"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12366,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 560,
      "side": "RIGHT",
      "diff_hunk": "@@ -554,7 +557,7 @@ def inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes)\n             return False\n \n     raise PydanticUserError(\n-        f'Unrecognized field_validator function signature for {validator} with `mode={mode}`:{sig}',\n+        f'Unrecognized {type} function signature for {validator} with `mode={mode}`: {sig}',",
      "comment": "I removed the underscore in particular for field validators, that aren't necessarily defined using the `@field_validator` decorator (i.e. with the `*Validator` metadata classes).",
      "comment_id": 2422854022,
      "user": "Viicos",
      "created_at": "2025-10-11T13:41:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/12366#discussion_r2422854022"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12370,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 522,
      "side": "RIGHT",
      "diff_hunk": "@@ -518,7 +518,19 @@ def _eval_type(\n     localns: MappingNamespace | None = None,\n     type_params: tuple[Any, ...] | None = None,\n ) -> Any:\n-    if sys.version_info >= (3, 13):\n+    if sys.version_info >= (3, 14):\n+        # Starting in 3.14, `_eval_type()` does *not* apply `_type_convert()`",
      "comment": "Did `_type_convert()` do anything else, do those cases also matter?",
      "comment_id": 2419153873,
      "user": "davidhewitt",
      "created_at": "2025-10-10T09:57:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/12370#discussion_r2419153873"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12370,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 522,
      "side": "RIGHT",
      "diff_hunk": "@@ -518,7 +518,19 @@ def _eval_type(\n     localns: MappingNamespace | None = None,\n     type_params: tuple[Any, ...] | None = None,\n ) -> Any:\n-    if sys.version_info >= (3, 13):\n+    if sys.version_info >= (3, 14):\n+        # Starting in 3.14, `_eval_type()` does *not* apply `_type_convert()`",
      "comment": "It converts str values to forward refs, but this is already handled by `_eval_type()` so after calling it we are guaranteed to not have to deal with forward refs anymore.",
      "comment_id": 2422853593,
      "user": "Viicos",
      "created_at": "2025-10-11T13:40:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/12370#discussion_r2422853593"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12355,
      "file_path": "tests/test_deferred_annotations.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,3 +88,31 @@ class A:\n     Int = int\n \n     assert A(a='1').a == 1\n+\n+\n+def test_deferred_annotations_return_values() -> None:",
      "comment": "The decorated function inspection doesn't special case modes, so I think this should be fine",
      "comment_id": 2413886829,
      "user": "Viicos",
      "created_at": "2025-10-08T13:34:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/12355#discussion_r2413886829"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12001,
      "file_path": "pydantic/main.py",
      "line": 1751,
      "side": "RIGHT",
      "diff_hunk": "@@ -1744,6 +1748,7 @@ def create_model(  # noqa: C901\n     namespace: dict[str, Any] = {'__annotations__': annotations, '__module__': __module__}\n     if __doc__:\n         namespace.update({'__doc__': __doc__})\n+    namespace.update({'__qualname__': __qualname__ or model_name})",
      "comment": "```suggestion\r\n    if __qualname__ is not None:\r\n        namespace.update({'__qualname__': __qualname__})\r\n```",
      "comment_id": 2410781701,
      "user": "Viicos",
      "created_at": "2025-10-07T14:10:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/12001#discussion_r2410781701"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12001,
      "file_path": "pydantic/main.py",
      "line": 1752,
      "side": "RIGHT",
      "diff_hunk": "@@ -1744,6 +1748,8 @@ def create_model(  # noqa: C901\n     namespace: dict[str, Any] = {'__annotations__': annotations, '__module__': __module__}\n     if __doc__:\n         namespace.update({'__doc__': __doc__})\n+    if __qualname__ is not None:\n+        namespace.update({'__qualname__': __qualname__})",
      "comment": "```suggestion\r\n    if __doc__:\r\n        namespace['__doc__'] = __doc__\r\n    if __qualname__ is not None:\r\n        namespace['__qualname__'] = __qualname__\r\n```",
      "comment_id": 2410797171,
      "user": "Viicos",
      "created_at": "2025-10-07T14:15:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/12001#discussion_r2410797171"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12147,
      "file_path": "pydantic/main.py",
      "line": 544,
      "side": "RIGHT",
      "diff_hunk": "@@ -541,6 +541,7 @@ def model_json_schema(\n         cls,\n         by_alias: bool = True,\n         ref_template: str = DEFAULT_REF_TEMPLATE,\n+        union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',",
      "comment": "Adding extra parameters like this is fine, but can be annoying for users subclassing `BaseModel` and overriding the `model_json_schema()` method, as they will need to update the definition.\r\n\r\nOne alternative is to have a single parameter (e.g. `TypedDict`) holding all the configuration, but it adds complexity on the caller side:\r\n\r\n```python\r\nModel.model_json_schema(settings={'union_format': ...})\r\n```\r\n\r\nAnd overriding the method isn't really a robust solution anyway.\r\n\r\nHowever, we should definitely make these keyword only. This will be a breaking change, so either we do it know but make sure to properly announce it, or wait for V3 (and use deprecated overloads until then).",
      "comment_id": 2261377497,
      "user": "Viicos",
      "created_at": "2025-08-07T20:54:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/12147#discussion_r2261377497"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12147,
      "file_path": "pydantic/main.py",
      "line": 544,
      "side": "RIGHT",
      "diff_hunk": "@@ -541,6 +541,7 @@ def model_json_schema(\n         cls,\n         by_alias: bool = True,\n         ref_template: str = DEFAULT_REF_TEMPLATE,\n+        union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',",
      "comment": "Can you make `union_format` keyword-only now, and leave the rest for later? I guess that would also then not be breaking?",
      "comment_id": 2401562807,
      "user": "davidhewitt",
      "created_at": "2025-10-03T11:15:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/12147#discussion_r2401562807"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12147,
      "file_path": "tests/test_json_schema.py",
      "line": 7131,
      "side": "RIGHT",
      "diff_hunk": "@@ -7072,3 +7073,58 @@ def test_decimal_pattern_reject_invalid_not_numerical_values_with_decimal_places\n ) -> None:\n     pattern = get_decimal_pattern()\n     assert re.fullmatch(pattern, invalid_decimal) is None\n+\n+\n+def test_union_format_primitive_type_array() -> None:\n+    class Sub(BaseModel):\n+        pass\n+\n+    class Model(BaseModel):\n+        a: Optional[int]\n+        b: Union[int, str, bool]\n+        c: Union[Annotated[str, Field(max_length=3)], Annotated[str, Field(min_length=5)]]\n+        d: Union[int, str, Annotated[bool, Field(description='test')]]\n+        e: Union[int, list[int]]\n+        f: Union[int, Sub]\n+\n+    assert Model.model_json_schema(union_format='primitive_type_array') == {\n+        '$defs': {'Sub': {'properties': {}, 'title': 'Sub', 'type': 'object'}},\n+        'properties': {\n+            'a': {'title': 'A', 'type': ['integer', 'null']},\n+            'b': {'title': 'B', 'type': ['integer', 'string', 'boolean']},\n+            'c': {\n+                'anyOf': [\n+                    {'maxLength': 3, 'type': 'string'},\n+                    {'minLength': 5, 'type': 'string'},\n+                ],\n+                'title': 'C',\n+            },\n+            'd': {\n+                'anyOf': [\n+                    {'type': 'integer'},\n+                    {'type': 'string'},\n+                    {'description': 'test', 'type': 'boolean'},\n+                ],\n+                'title': 'D',\n+            },\n+            'e': {\n+                'anyOf': [\n+                    {'type': 'integer'},\n+                    {'items': {'type': 'integer'}, 'type': 'array'},\n+                ],\n+                'title': 'E',\n+            },\n+            'f': {'anyOf': [{'type': 'integer'}, {'$ref': '#/$defs/Sub'}], 'title': 'F'},\n+        },\n+        'required': ['a', 'b', 'c', 'd', 'e', 'f'],\n+        'title': 'Model',\n+        'type': 'object',\n+    }\n+\n+\n+def test_union_format_primitive_type_array_deduplicated() -> None:\n+    gen_js = GenerateJsonSchema(union_format='primitive_type_array')\n+\n+    assert gen_js.union_schema(\n+        core_schema.union_schema([core_schema.int_schema(), core_schema.str_schema(), core_schema.int_schema()])\n+    ) == {'type': ['integer', 'string']}",
      "comment": "Maybe add a case where there's a str schema with a constraint too, and check the result still deduplicates the ints even if it switches back to `anyOf`?",
      "comment_id": 2401567816,
      "user": "davidhewitt",
      "created_at": "2025-10-03T11:18:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/12147#discussion_r2401567816"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12147,
      "file_path": "pydantic/main.py",
      "line": 544,
      "side": "RIGHT",
      "diff_hunk": "@@ -541,6 +541,7 @@ def model_json_schema(\n         cls,\n         by_alias: bool = True,\n         ref_template: str = DEFAULT_REF_TEMPLATE,\n+        union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',",
      "comment": ":+1: , created https://github.com/pydantic/pydantic/issues/12332 as well.",
      "comment_id": 2406276369,
      "user": "Viicos",
      "created_at": "2025-10-06T13:22:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/12147#discussion_r2406276369"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11987,
      "file_path": "tests/test_json_schema.py",
      "line": 6951,
      "side": "RIGHT",
      "diff_hunk": "@@ -6811,3 +6946,147 @@ def test_json_schema_arguments_v3_aliases() -> None:\n         },\n         'required': ['b'],\n     }\n+\n+\n+class TestDecimalPattern:",
      "comment": "Let's flatten this to use functions instead of methods.",
      "comment_id": 2180865070,
      "user": "Viicos",
      "created_at": "2025-07-02T19:56:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/11987#discussion_r2180865070"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11987,
      "file_path": "pydantic/json_schema.py",
      "line": 690,
      "side": "RIGHT",
      "diff_hunk": "@@ -674,7 +674,31 @@ def decimal_schema(self, schema: core_schema.DecimalSchema) -> JsonSchemaValue:\n         Returns:\n             The generated JSON schema.\n         \"\"\"\n-        json_schema = self.str_schema(core_schema.str_schema())\n+\n+        def get_decimal_pattern(schema: core_schema.DecimalSchema) -> str:\n+            max_digits = schema.get('max_digits', '')\n+            decimal_places = schema.get('decimal_places', '')\n+            integer_places = max_digits\n+\n+            if isinstance(max_digits, int) and isinstance(decimal_places, int):\n+                if (diff := max_digits - decimal_places) > 0:\n+                    integer_places = diff\n+                else:\n+                    integer_places = 0\n+\n+            pattern = (\n+                r'^(?!^[+-\\.]*$)'  # check string is not empty and not single or sequence of \".+-\" characters.",
      "comment": "I think you don't need to escape the `.` when inside brackets.",
      "comment_id": 2180866129,
      "user": "Viicos",
      "created_at": "2025-07-02T19:56:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/11987#discussion_r2180866129"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11987,
      "file_path": "tests/test_json_schema.py",
      "line": 6951,
      "side": "RIGHT",
      "diff_hunk": "@@ -6811,3 +6946,147 @@ def test_json_schema_arguments_v3_aliases() -> None:\n         },\n         'required': ['b'],\n     }\n+\n+\n+class TestDecimalPattern:",
      "comment": "Resolved with [this commit](https://github.com/pydantic/pydantic/pull/11987/commits/73afd017f4cb1683540cdc08f3601dc90886cd61)\r\n",
      "comment_id": 2184144466,
      "user": "Dima-Bulavenko",
      "created_at": "2025-07-04T02:16:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/11987#discussion_r2184144466"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11987,
      "file_path": "pydantic/json_schema.py",
      "line": 690,
      "side": "RIGHT",
      "diff_hunk": "@@ -674,7 +674,31 @@ def decimal_schema(self, schema: core_schema.DecimalSchema) -> JsonSchemaValue:\n         Returns:\n             The generated JSON schema.\n         \"\"\"\n-        json_schema = self.str_schema(core_schema.str_schema())\n+\n+        def get_decimal_pattern(schema: core_schema.DecimalSchema) -> str:\n+            max_digits = schema.get('max_digits', '')\n+            decimal_places = schema.get('decimal_places', '')\n+            integer_places = max_digits\n+\n+            if isinstance(max_digits, int) and isinstance(decimal_places, int):\n+                if (diff := max_digits - decimal_places) > 0:\n+                    integer_places = diff\n+                else:\n+                    integer_places = 0\n+\n+            pattern = (\n+                r'^(?!^[+-\\.]*$)'  # check string is not empty and not single or sequence of \".+-\" characters.",
      "comment": "Thanks for pointing that out! I\u2019ve resolved it in commit https://github.com/pydantic/pydantic/commit/5874292e75f955fe80334c7c083be0832edcf0df.",
      "comment_id": 2184340350,
      "user": "Dima-Bulavenko",
      "created_at": "2025-07-04T04:38:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/11987#discussion_r2184340350"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11987,
      "file_path": "pydantic/json_schema.py",
      "line": 715,
      "side": "RIGHT",
      "diff_hunk": "@@ -674,7 +674,49 @@ def decimal_schema(self, schema: core_schema.DecimalSchema) -> JsonSchemaValue:\n         Returns:\n             The generated JSON schema.\n         \"\"\"\n-        json_schema = self.str_schema(core_schema.str_schema())\n+\n+        def get_decimal_pattern(schema: core_schema.DecimalSchema) -> str:\n+            max_digits = schema.get('max_digits')\n+            decimal_places = schema.get('decimal_places')\n+\n+            pattern = (\n+                r'^(?!^[-+.]*$)[+-]?0*'  # check it is not empty string and not one or sequence of \".+-\" characters.\n+            )\n+\n+            # Case 1: Both max_digits and decimal_places are set\n+            if max_digits is not None and decimal_places is not None:\n+                integer_places = max(0, max_digits - decimal_places)\n+                pattern += (\n+                    rf'(?:'\n+                    rf'\\d{{0,{integer_places}}}'\n+                    rf'|'\n+                    rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'\n+                    rf'\\d{{0,{integer_places}}}\\.\\d{{0,{decimal_places}}}0*$'\n+                    rf')'\n+                )\n+\n+            # Case 2: Only max_digits is set\n+            elif max_digits is not None and decimal_places is None:\n+                pattern += (\n+                    rf'(?:'\n+                    rf'\\d{{0,{max_digits}}}'\n+                    rf'|'\n+                    rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'\n+                    rf'\\d*\\.\\d*0*$'\n+                    rf')'\n+                )\n+\n+            # Case 3: Only decimal_places is set\n+            elif max_digits is None and decimal_places is not None:\n+                pattern += rf'\\d*\\.?\\d{{0,{decimal_places}}}0*$'\n+\n+            # Case 4: Both are None (no restrictions)\n+            else:\n+                pattern += r'\\d*\\.?\\d*$'  # look for arbitrary integer or decimal",
      "comment": "This allows `'.'` as an input, which can't be validated.",
      "comment_id": 2187005604,
      "user": "Viicos",
      "created_at": "2025-07-05T09:17:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/11987#discussion_r2187005604"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11987,
      "file_path": "pydantic/json_schema.py",
      "line": 699,
      "side": "RIGHT",
      "diff_hunk": "@@ -674,7 +674,49 @@ def decimal_schema(self, schema: core_schema.DecimalSchema) -> JsonSchemaValue:\n         Returns:\n             The generated JSON schema.\n         \"\"\"\n-        json_schema = self.str_schema(core_schema.str_schema())\n+\n+        def get_decimal_pattern(schema: core_schema.DecimalSchema) -> str:\n+            max_digits = schema.get('max_digits')\n+            decimal_places = schema.get('decimal_places')\n+\n+            pattern = (\n+                r'^(?!^[-+.]*$)[+-]?0*'  # check it is not empty string and not one or sequence of \".+-\" characters.\n+            )\n+\n+            # Case 1: Both max_digits and decimal_places are set\n+            if max_digits is not None and decimal_places is not None:\n+                integer_places = max(0, max_digits - decimal_places)\n+                pattern += (\n+                    rf'(?:'\n+                    rf'\\d{{0,{integer_places}}}'\n+                    rf'|'\n+                    rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'\n+                    rf'\\d{{0,{integer_places}}}\\.\\d{{0,{decimal_places}}}0*$'\n+                    rf')'\n+                )\n+\n+            # Case 2: Only max_digits is set\n+            elif max_digits is not None and decimal_places is None:",
      "comment": "With `max_digits` set to e.g. 5, it wrongfully matches `'1000.1111111'`, etc.",
      "comment_id": 2187013721,
      "user": "Viicos",
      "created_at": "2025-07-05T09:26:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/11987#discussion_r2187013721"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11987,
      "file_path": "pydantic/json_schema.py",
      "line": 715,
      "side": "RIGHT",
      "diff_hunk": "@@ -674,7 +674,49 @@ def decimal_schema(self, schema: core_schema.DecimalSchema) -> JsonSchemaValue:\n         Returns:\n             The generated JSON schema.\n         \"\"\"\n-        json_schema = self.str_schema(core_schema.str_schema())\n+\n+        def get_decimal_pattern(schema: core_schema.DecimalSchema) -> str:\n+            max_digits = schema.get('max_digits')\n+            decimal_places = schema.get('decimal_places')\n+\n+            pattern = (\n+                r'^(?!^[-+.]*$)[+-]?0*'  # check it is not empty string and not one or sequence of \".+-\" characters.\n+            )\n+\n+            # Case 1: Both max_digits and decimal_places are set\n+            if max_digits is not None and decimal_places is not None:\n+                integer_places = max(0, max_digits - decimal_places)\n+                pattern += (\n+                    rf'(?:'\n+                    rf'\\d{{0,{integer_places}}}'\n+                    rf'|'\n+                    rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'\n+                    rf'\\d{{0,{integer_places}}}\\.\\d{{0,{decimal_places}}}0*$'\n+                    rf')'\n+                )\n+\n+            # Case 2: Only max_digits is set\n+            elif max_digits is not None and decimal_places is None:\n+                pattern += (\n+                    rf'(?:'\n+                    rf'\\d{{0,{max_digits}}}'\n+                    rf'|'\n+                    rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'\n+                    rf'\\d*\\.\\d*0*$'\n+                    rf')'\n+                )\n+\n+            # Case 3: Only decimal_places is set\n+            elif max_digits is None and decimal_places is not None:\n+                pattern += rf'\\d*\\.?\\d{{0,{decimal_places}}}0*$'\n+\n+            # Case 4: Both are None (no restrictions)\n+            else:\n+                pattern += r'\\d*\\.?\\d*$'  # look for arbitrary integer or decimal",
      "comment": "Thank you for pointing this out.\r\nHowever, `r'\\d*\\.?\\d*$'` is not the full pattern used for validation.\r\n\r\nThe complete pattern includes an additional regex component that prevents `'.'` from being a valid input:\r\nhttps://github.com/pydantic/pydantic/blob/88adb2d4806a37fd21ae06f88d4670190759974f/pydantic/json_schema.py#L682-L684\r\n\r\nAdditionally, the edge case for `'.'` is covered by the following test:\r\nhttps://github.com/pydantic/pydantic/blob/88adb2d4806a37fd21ae06f88d4670190759974f/tests/test_json_schema.py#L7005-L7009",
      "comment_id": 2187273655,
      "user": "Dima-Bulavenko",
      "created_at": "2025-07-05T13:35:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/11987#discussion_r2187273655"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11987,
      "file_path": "pydantic/json_schema.py",
      "line": 699,
      "side": "RIGHT",
      "diff_hunk": "@@ -674,7 +674,49 @@ def decimal_schema(self, schema: core_schema.DecimalSchema) -> JsonSchemaValue:\n         Returns:\n             The generated JSON schema.\n         \"\"\"\n-        json_schema = self.str_schema(core_schema.str_schema())\n+\n+        def get_decimal_pattern(schema: core_schema.DecimalSchema) -> str:\n+            max_digits = schema.get('max_digits')\n+            decimal_places = schema.get('decimal_places')\n+\n+            pattern = (\n+                r'^(?!^[-+.]*$)[+-]?0*'  # check it is not empty string and not one or sequence of \".+-\" characters.\n+            )\n+\n+            # Case 1: Both max_digits and decimal_places are set\n+            if max_digits is not None and decimal_places is not None:\n+                integer_places = max(0, max_digits - decimal_places)\n+                pattern += (\n+                    rf'(?:'\n+                    rf'\\d{{0,{integer_places}}}'\n+                    rf'|'\n+                    rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'\n+                    rf'\\d{{0,{integer_places}}}\\.\\d{{0,{decimal_places}}}0*$'\n+                    rf')'\n+                )\n+\n+            # Case 2: Only max_digits is set\n+            elif max_digits is not None and decimal_places is None:",
      "comment": "Thank you for your feedback.\r\n\r\nFrom my testing, the pattern appears to work correctly when\u00a0`max_digits=5`\u00a0and the invalid value\u00a0`'1000.1111111'`\u00a0is rejected as expected.\r\n\r\nHere is a test demonstrating this behavior:\r\n```python\r\n@pytest.fixture\r\ndef get_decimal_pattern():\r\n    def pattern(max_digits=None, decimal_places=None) -> str:\r\n        field = TypeAdapter(Annotated[Decimal, Field(max_digits=max_digits, decimal_places=decimal_places)])\r\n        return field.json_schema()['anyOf'][1]['pattern']\r\n    return pattern\r\n\r\n@pytest.mark.parametrize('invalid_decimal', ['1000.1111111'])\r\ndef test_only_max_digits_set(invalid_decimal, get_decimal_pattern):\r\n    pattern = get_decimal_pattern(max_digits=5, decimal_places=None)\r\n    assert re.fullmatch(pattern, invalid_decimal) is None\r\n```\r\n\r\nLet me know if there's a specific case I may have missed!",
      "comment_id": 2187293022,
      "user": "Dima-Bulavenko",
      "created_at": "2025-07-05T13:47:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/11987#discussion_r2187293022"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12324,
      "file_path": "pydantic/type_adapter.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,19 +216,36 @@ def __init__(\n         self.pydantic_complete = False\n \n         parent_frame = self._fetch_parent_frame()\n-        if parent_frame is not None:\n-            globalns = parent_frame.f_globals\n-            # Do not provide a local ns if the type adapter happens to be instantiated at the module level:\n-            localns = parent_frame.f_locals if parent_frame.f_locals is not globalns else {}\n+        if isinstance(type, types.FunctionType):\n+            # Special case functions, which are *not* pushed to the `NsResolver` stack and without this special case\n+            # would only have access to the parent namespace where the `TypeAdapter` was instantiated (if the function is defined\n+            # in another module, we need to look at that module's globals).\n+            if parent_frame is not None:\n+                parent_ns = (\n+                    parent_frame.f_globals if parent_frame.f_globals is parent_frame.f_locals else parent_frame.f_locals",
      "comment": "`globals if globals is locals else locals` .. isn't this always going to be equivalent to `locals`?\r\n\r\n```suggestion\r\n                    parent_frame.f_locals\r\n```",
      "comment_id": 2404459009,
      "user": "davidhewitt",
      "created_at": "2025-10-05T12:22:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/12324#discussion_r2404459009"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12324,
      "file_path": "pydantic/type_adapter.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,19 +216,36 @@ def __init__(\n         self.pydantic_complete = False\n \n         parent_frame = self._fetch_parent_frame()\n-        if parent_frame is not None:\n-            globalns = parent_frame.f_globals\n-            # Do not provide a local ns if the type adapter happens to be instantiated at the module level:\n-            localns = parent_frame.f_locals if parent_frame.f_locals is not globalns else {}\n+        if isinstance(type, types.FunctionType):\n+            # Special case functions, which are *not* pushed to the `NsResolver` stack and without this special case\n+            # would only have access to the parent namespace where the `TypeAdapter` was instantiated (if the function is defined\n+            # in another module, we need to look at that module's globals).\n+            if parent_frame is not None:\n+                parent_ns = (\n+                    parent_frame.f_globals if parent_frame.f_globals is parent_frame.f_locals else parent_frame.f_locals",
      "comment": "In other words, this means _use the globals if the TypeAdapter was created at the module level, else use the locals (e.g. in a function)_. In the former, globals and locals are the same (module's `__dict__`).",
      "comment_id": 2404659532,
      "user": "Viicos",
      "created_at": "2025-10-05T20:43:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/12324#discussion_r2404659532"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12324,
      "file_path": "pydantic/type_adapter.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,19 +216,36 @@ def __init__(\n         self.pydantic_complete = False\n \n         parent_frame = self._fetch_parent_frame()\n-        if parent_frame is not None:\n-            globalns = parent_frame.f_globals\n-            # Do not provide a local ns if the type adapter happens to be instantiated at the module level:\n-            localns = parent_frame.f_locals if parent_frame.f_locals is not globalns else {}\n+        if isinstance(type, types.FunctionType):\n+            # Special case functions, which are *not* pushed to the `NsResolver` stack and without this special case\n+            # would only have access to the parent namespace where the `TypeAdapter` was instantiated (if the function is defined\n+            # in another module, we need to look at that module's globals).\n+            if parent_frame is not None:\n+                parent_ns = (\n+                    parent_frame.f_globals if parent_frame.f_globals is parent_frame.f_locals else parent_frame.f_locals",
      "comment": "Right, but even if the intent is to do that, the expression written here completely simplifies away? Maybe a bug?",
      "comment_id": 2404675968,
      "user": "davidhewitt",
      "created_at": "2025-10-05T21:27:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/12324#discussion_r2404675968"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12324,
      "file_path": "pydantic/type_adapter.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,19 +216,36 @@ def __init__(\n         self.pydantic_complete = False\n \n         parent_frame = self._fetch_parent_frame()\n-        if parent_frame is not None:\n-            globalns = parent_frame.f_globals\n-            # Do not provide a local ns if the type adapter happens to be instantiated at the module level:\n-            localns = parent_frame.f_locals if parent_frame.f_locals is not globalns else {}\n+        if isinstance(type, types.FunctionType):\n+            # Special case functions, which are *not* pushed to the `NsResolver` stack and without this special case\n+            # would only have access to the parent namespace where the `TypeAdapter` was instantiated (if the function is defined\n+            # in another module, we need to look at that module's globals).\n+            if parent_frame is not None:\n+                parent_ns = (\n+                    parent_frame.f_globals if parent_frame.f_globals is parent_frame.f_locals else parent_frame.f_locals",
      "comment": "Hum I'm not sure? It's not `locals if globals is locals else locals`, but `globals if globals is locals else locals`",
      "comment_id": 2405256165,
      "user": "Viicos",
      "created_at": "2025-10-06T08:01:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/12324#discussion_r2405256165"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12324,
      "file_path": "pydantic/type_adapter.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,19 +216,36 @@ def __init__(\n         self.pydantic_complete = False\n \n         parent_frame = self._fetch_parent_frame()\n-        if parent_frame is not None:\n-            globalns = parent_frame.f_globals\n-            # Do not provide a local ns if the type adapter happens to be instantiated at the module level:\n-            localns = parent_frame.f_locals if parent_frame.f_locals is not globalns else {}\n+        if isinstance(type, types.FunctionType):\n+            # Special case functions, which are *not* pushed to the `NsResolver` stack and without this special case\n+            # would only have access to the parent namespace where the `TypeAdapter` was instantiated (if the function is defined\n+            # in another module, we need to look at that module's globals).\n+            if parent_frame is not None:\n+                parent_ns = (\n+                    parent_frame.f_globals if parent_frame.f_globals is parent_frame.f_locals else parent_frame.f_locals",
      "comment": "But I think that `if globals is locals` implies that `locals` and `globals` are the same object, so\r\n\r\n`locals if globals is locals else locals`\r\nand\r\n`globals if globals is locals else locals`\r\n\r\nare equivalent?\r\n",
      "comment_id": 2405461212,
      "user": "davidhewitt",
      "created_at": "2025-10-06T09:21:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/12324#discussion_r2405461212"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12324,
      "file_path": "pydantic/type_adapter.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,19 +216,36 @@ def __init__(\n         self.pydantic_complete = False\n \n         parent_frame = self._fetch_parent_frame()\n-        if parent_frame is not None:\n-            globalns = parent_frame.f_globals\n-            # Do not provide a local ns if the type adapter happens to be instantiated at the module level:\n-            localns = parent_frame.f_locals if parent_frame.f_locals is not globalns else {}\n+        if isinstance(type, types.FunctionType):\n+            # Special case functions, which are *not* pushed to the `NsResolver` stack and without this special case\n+            # would only have access to the parent namespace where the `TypeAdapter` was instantiated (if the function is defined\n+            # in another module, we need to look at that module's globals).\n+            if parent_frame is not None:\n+                parent_ns = (\n+                    parent_frame.f_globals if parent_frame.f_globals is parent_frame.f_locals else parent_frame.f_locals",
      "comment": "Ah yeah right, I'll use locals but add a comment to explain what it is referring to ~~(also update the same code later in this branch)~~.",
      "comment_id": 2405470178,
      "user": "Viicos",
      "created_at": "2025-10-06T09:24:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/12324#discussion_r2405470178"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12254,
      "file_path": "pydantic/mypy.py",
      "line": 213,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,14 +209,16 @@ def _pydantic_field_callback(self, ctx: FunctionContext) -> 'Type':\n                     default_factory_type = default_factory_type.items()[0]  # type: ignore[operator]\n \n             if isinstance(default_factory_type, CallableType):\n-                ret_type = default_factory_type.ret_type\n+                ret_type = get_proper_type(default_factory_type.ret_type)\n                 # mypy doesn't think `ret_type` has `args`, you'd think mypy should know,",
      "comment": "This comment is now obsolete (and has never been correct, `ret_type` isn't guaranteed to be an Instance)",
      "comment_id": 2353155864,
      "user": "sterliakov",
      "created_at": "2025-09-16T17:15:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/12254#discussion_r2353155864"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12289,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 302,
      "side": "RIGHT",
      "diff_hunk": "@@ -296,25 +297,28 @@ def _apply_constraint_with_incompatibility_info(\n             )\n             continue\n         elif isinstance(annotation, (at.Predicate, at.Not)):\n-            predicate_name = f'{annotation.func.__qualname__}' if hasattr(annotation.func, '__qualname__') else ''\n+            predicate_name = f'{annotation.func.__qualname__!r} ' if hasattr(annotation.func, '__qualname__') else ''\n \n             def val_func(v: Any) -> Any:",
      "comment": "For performance we could consider formatting the error message before the `def val_func`, so it's reused on each error. Or could have it be cached in some way.\n\nSimilarly might want to have the `at.Predicate` / `at.Not` branches define two separate `val_func`?\n\n",
      "comment_id": 2401609542,
      "user": "davidhewitt",
      "created_at": "2025-10-03T11:40:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/12289#discussion_r2401609542"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12077,
      "file_path": "tests/test_dataclasses.py",
      "line": 1844,
      "side": "RIGHT",
      "diff_hunk": "@@ -1841,6 +1841,20 @@ class Child(Parent):\n     assert child.y == 1\n \n \n+def test_kw_only_inheritance_on_field() -> None:",
      "comment": "This would previously fail with an unhandled exception with 3.9. Although it doesn't make sense to use it in 3.9 (and we could add a warning -- not worth the effort as we'll drop support for it soon), still better to not hard error.",
      "comment_id": 2219806416,
      "user": "Viicos",
      "created_at": "2025-07-21T17:21:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/12077#discussion_r2219806416"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12179,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1493,
      "side": "RIGHT",
      "diff_hunk": "@@ -1474,13 +1479,44 @@ def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -> core_schema.Co\n                         UserWarning,\n                     )\n \n+                extra_behavior: core_schema.ExtraBehavior = 'ignore'\n+                extras_schema: CoreSchema | None = None  # For 'allow', equivalent to `Any` - no validation performed.\n+\n+                # `__closed__` is `None` when not specified (equivalent to `False`):\n+                is_closed = bool(getattr(typed_dict_cls, '__closed__', False))\n+                extra_items = getattr(typed_dict_cls, '__extra_items__', typing_extensions.NoExtraItems)\n+                if is_closed:\n+                    extra_behavior = 'forbid'\n+                    extras_schema = None\n+                elif not typing_objects.is_noextraitems(extra_items):\n+                    extra_behavior = 'allow'\n+                    extras_schema = self.generate_schema(replace_types(extra_items, typevars_map))",
      "comment": "Under what conditions does `extra_behavior` remain `'ignore'`?",
      "comment_id": 2394077681,
      "user": "davidhewitt",
      "created_at": "2025-10-01T10:12:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/12179#discussion_r2394077681"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12179,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1493,
      "side": "RIGHT",
      "diff_hunk": "@@ -1474,13 +1479,44 @@ def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -> core_schema.Co\n                         UserWarning,\n                     )\n \n+                extra_behavior: core_schema.ExtraBehavior = 'ignore'\n+                extras_schema: CoreSchema | None = None  # For 'allow', equivalent to `Any` - no validation performed.\n+\n+                # `__closed__` is `None` when not specified (equivalent to `False`):\n+                is_closed = bool(getattr(typed_dict_cls, '__closed__', False))\n+                extra_items = getattr(typed_dict_cls, '__extra_items__', typing_extensions.NoExtraItems)\n+                if is_closed:\n+                    extra_behavior = 'forbid'\n+                    extras_schema = None\n+                elif not typing_objects.is_noextraitems(extra_items):\n+                    extra_behavior = 'allow'\n+                    extras_schema = self.generate_schema(replace_types(extra_items, typevars_map))",
      "comment": "It is first assigned the value of `'ignore'`, so if:\r\n- the TD is not closed\r\n- the TD has no extra items\r\n- the extra from the config is not `'allow'` or `'forbid'`",
      "comment_id": 2394130478,
      "user": "Viicos",
      "created_at": "2025-10-01T10:37:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/12179#discussion_r2394130478"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12179,
      "file_path": "tests/test_types_typeddict.py",
      "line": 971,
      "side": "RIGHT",
      "diff_hunk": "@@ -957,3 +958,111 @@ class Foo(TypedDict):\n     assert ta.dump_json(Foo(foo='bar', bar=1)).decode('utf-8') == '{\"bar\":1}'\n     assert ta.dump_json(Foo(foo='bar', bar=1), exclude={'bar'}).decode('utf-8') == '{}'\n     assert ta.dump_json(Foo(foo='bar', bar=2)).decode('utf-8') == '{}'\n+\n+\n+def test_typeddict_extra_allow_serialization() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/11136.\n+\n+    Seems like specifying `extra_behavior` in the core schema (which was done when implementing PEP 728)\n+    was necessary to make this work.\n+    \"\"\"\n+\n+    @with_config(extra='allow')\n+    class TD(TypedDict, closed=False):",
      "comment": "Answering in https://github.com/pydantic/pydantic/issues/10785.",
      "comment_id": 2394135784,
      "user": "Viicos",
      "created_at": "2025-10-01T10:39:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/12179#discussion_r2394135784"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12290,
      "file_path": "tests/mypy/modules/frozen_field.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,3 +8,16 @@ class Foo(BaseModel):\n foo = Foo()\n \n foo.a = 2\n+\n+\n+class Parent(BaseModel):\n+    parent_attr: str = Field(exclude=True)\n+\n+\n+# We don't wan't to froze `parent_attr` in the plugin:",
      "comment": "See the fixed issue, it results in unexpected errors.",
      "comment_id": 2387753994,
      "user": "Viicos",
      "created_at": "2025-09-29T12:24:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/12290#discussion_r2387753994"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12290,
      "file_path": "tests/mypy/modules/frozen_field.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,3 +8,16 @@ class Foo(BaseModel):\n foo = Foo()\n \n foo.a = 2\n+\n+\n+class Parent(BaseModel):\n+    parent_attr: str = Field(exclude=True)\n+\n+\n+# We don't wan't to froze `parent_attr` in the plugin:",
      "comment": "I see, maybe this is clearer:\n\n```suggestion\n# `parent_attr` is writable, mypy should error when overriding with a read-only property\n```",
      "comment_id": 2390980473,
      "user": "davidhewitt",
      "created_at": "2025-09-30T11:17:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/12290#discussion_r2390980473"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12290,
      "file_path": "tests/mypy/modules/frozen_field.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,3 +8,16 @@ class Foo(BaseModel):\n foo = Foo()\n \n foo.a = 2\n+\n+\n+class Parent(BaseModel):\n+    parent_attr: str = Field(exclude=True)\n+\n+\n+# We don't want to freeze `parent_attr` in the plugin:",
      "comment": "```suggestion\r\n# `parent_attr` is writable, mypy should error when overriding with a read-only property\r\n```",
      "comment_id": 2391286202,
      "user": "Viicos",
      "created_at": "2025-09-30T12:42:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/12290#discussion_r2391286202"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12290,
      "file_path": "tests/mypy/outputs/mypy-plugin_ini/frozen_field.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,3 +9,18 @@ class Foo(BaseModel):\n \n foo.a = 2\n # MYPY: error: Property \"a\" defined in \"Foo\" is read-only  [misc]\n+\n+\n+class Parent(BaseModel):\n+    parent_attr: str = Field(exclude=True)\n+\n+\n+# We don't want to freeze `parent_attr` in the plugin:",
      "comment": "```suggestion\r\n# `parent_attr` is writable, mypy should error when overriding with a read-only property\r\n```",
      "comment_id": 2391286422,
      "user": "Viicos",
      "created_at": "2025-09-30T12:42:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/12290#discussion_r2391286422"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 7196,
      "file_path": "tests/test_abc.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +11,7 @@ class Model(BaseModel, abc.ABC):\n         some_field: str\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='error value different on older versions')",
      "comment": "I'd rather don't throw out tests for everything except an unreleased Python version.",
      "comment_id": 1331429375,
      "user": "lig",
      "created_at": "2023-09-20T10:40:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/7196#discussion_r1331429375"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9953,
      "file_path": "pydantic/_internal/_config.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,37 +166,38 @@ def core_config(self, obj: Any) -> core_schema.CoreConfig:\n         Returns:\n             A `CoreConfig` object created from config.\n         \"\"\"\n-\n-        def dict_not_none(**kwargs: Any) -> Any:\n-            return {k: v for k, v in kwargs.items() if v is not None}\n-\n-        core_config = core_schema.CoreConfig(\n-            **dict_not_none(\n-                title=self.config_dict.get('title') or (obj and obj.__name__),\n-                extra_fields_behavior=self.config_dict.get('extra'),\n-                allow_inf_nan=self.config_dict.get('allow_inf_nan'),\n-                populate_by_name=self.config_dict.get('populate_by_name'),\n-                str_strip_whitespace=self.config_dict.get('str_strip_whitespace'),\n-                str_to_lower=self.config_dict.get('str_to_lower'),\n-                str_to_upper=self.config_dict.get('str_to_upper'),\n-                strict=self.config_dict.get('strict'),\n-                ser_json_timedelta=self.config_dict.get('ser_json_timedelta'),\n-                ser_json_bytes=self.config_dict.get('ser_json_bytes'),\n-                ser_json_inf_nan=self.config_dict.get('ser_json_inf_nan'),\n-                from_attributes=self.config_dict.get('from_attributes'),\n-                loc_by_alias=self.config_dict.get('loc_by_alias'),\n-                revalidate_instances=self.config_dict.get('revalidate_instances'),\n-                validate_default=self.config_dict.get('validate_default'),\n-                str_max_length=self.config_dict.get('str_max_length'),\n-                str_min_length=self.config_dict.get('str_min_length'),\n-                hide_input_in_errors=self.config_dict.get('hide_input_in_errors'),\n-                coerce_numbers_to_str=self.config_dict.get('coerce_numbers_to_str'),\n-                regex_engine=self.config_dict.get('regex_engine'),\n-                validation_error_cause=self.config_dict.get('validation_error_cause'),\n-                cache_strings=self.config_dict.get('cache_strings'),\n-            )\n-        )\n-        return core_config\n+        config = self.config_dict\n+        title = config.get('title') or (obj and obj.__name__)\n+\n+        core_config_values = {\n+            'title': title,",
      "comment": "```suggestion\r\n\r\n        core_config_values = {\r\n            'title': config.get('title') or (obj and obj.__name__),\r\n```",
      "comment_id": 1689989522,
      "user": "sydney-runkle",
      "created_at": "2024-07-24T15:07:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/9953#discussion_r1689989522"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9953,
      "file_path": "pydantic/_internal/_config.py",
      "line": 200,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,37 +166,38 @@ def core_config(self, obj: Any) -> core_schema.CoreConfig:\n         Returns:\n             A `CoreConfig` object created from config.\n         \"\"\"\n-\n-        def dict_not_none(**kwargs: Any) -> Any:\n-            return {k: v for k, v in kwargs.items() if v is not None}\n-\n-        core_config = core_schema.CoreConfig(\n-            **dict_not_none(\n-                title=self.config_dict.get('title') or (obj and obj.__name__),\n-                extra_fields_behavior=self.config_dict.get('extra'),\n-                allow_inf_nan=self.config_dict.get('allow_inf_nan'),\n-                populate_by_name=self.config_dict.get('populate_by_name'),\n-                str_strip_whitespace=self.config_dict.get('str_strip_whitespace'),\n-                str_to_lower=self.config_dict.get('str_to_lower'),\n-                str_to_upper=self.config_dict.get('str_to_upper'),\n-                strict=self.config_dict.get('strict'),\n-                ser_json_timedelta=self.config_dict.get('ser_json_timedelta'),\n-                ser_json_bytes=self.config_dict.get('ser_json_bytes'),\n-                ser_json_inf_nan=self.config_dict.get('ser_json_inf_nan'),\n-                from_attributes=self.config_dict.get('from_attributes'),\n-                loc_by_alias=self.config_dict.get('loc_by_alias'),\n-                revalidate_instances=self.config_dict.get('revalidate_instances'),\n-                validate_default=self.config_dict.get('validate_default'),\n-                str_max_length=self.config_dict.get('str_max_length'),\n-                str_min_length=self.config_dict.get('str_min_length'),\n-                hide_input_in_errors=self.config_dict.get('hide_input_in_errors'),\n-                coerce_numbers_to_str=self.config_dict.get('coerce_numbers_to_str'),\n-                regex_engine=self.config_dict.get('regex_engine'),\n-                validation_error_cause=self.config_dict.get('validation_error_cause'),\n-                cache_strings=self.config_dict.get('cache_strings'),\n-            )\n-        )\n-        return core_config\n+        config = self.config_dict\n+        title = config.get('title') or (obj and obj.__name__)\n+\n+        core_config_values = {\n+            'title': title,\n+            'extra_fields_behavior': config.get('extra'),\n+            'allow_inf_nan': config.get('allow_inf_nan'),\n+            'populate_by_name': config.get('populate_by_name'),\n+            'str_strip_whitespace': config.get('str_strip_whitespace'),\n+            'str_to_lower': config.get('str_to_lower'),\n+            'str_to_upper': config.get('str_to_upper'),\n+            'strict': config.get('strict'),\n+            'ser_json_timedelta': config.get('ser_json_timedelta'),\n+            'ser_json_bytes': config.get('ser_json_bytes'),\n+            'ser_json_inf_nan': config.get('ser_json_inf_nan'),\n+            'from_attributes': config.get('from_attributes'),\n+            'loc_by_alias': config.get('loc_by_alias'),\n+            'revalidate_instances': config.get('revalidate_instances'),\n+            'validate_default': config.get('validate_default'),\n+            'str_max_length': config.get('str_max_length'),\n+            'str_min_length': config.get('str_min_length'),\n+            'hide_input_in_errors': config.get('hide_input_in_errors'),\n+            'coerce_numbers_to_str': config.get('coerce_numbers_to_str'),\n+            'regex_engine': config.get('regex_engine'),\n+            'validation_error_cause': config.get('validation_error_cause'),\n+            'cache_strings': config.get('cache_strings'),\n+        }\n+\n+        # Create dictionary excluding None values\n+        non_none_config = {k: v for k, v in core_config_values.items() if v is not None}\n+\n+        return core_schema.CoreConfig(**non_none_config)",
      "comment": "```suggestion\r\n        return core_schema.CoreConfig(**{k: v for k, v in core_config_values.items() if v is not None})\r\n```",
      "comment_id": 1689990512,
      "user": "sydney-runkle",
      "created_at": "2024-07-24T15:07:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/9953#discussion_r1689990512"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12173,
      "file_path": "tests/test_dataclasses.py",
      "line": 3189,
      "side": "RIGHT",
      "diff_hunk": "@@ -3152,7 +3186,7 @@ class MyDataclass2:\n     try:\n         inst.x = 'other'\n     except ValidationError as e:\n-        assert 'Instance is frozen' in repr(e)\n+        assert \"cannot assign to field 'x'\" in repr(e)",
      "comment": "Previously the error was thrown from pydantic-core. I think it's better this way, as it is now consistent with the `frozen=True` dataclass argument above this one.",
      "comment_id": 2282016535,
      "user": "Viicos",
      "created_at": "2025-08-18T10:38:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/12173#discussion_r2282016535"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12219,
      "file_path": "tests/test_types.py",
      "line": 1053,
      "side": "RIGHT",
      "diff_hunk": "@@ -1050,6 +1050,18 @@ class ImportThings(BaseModel):\n     assert import_things.model_dump_json() == '{\"obj\":\"sys.stdout\"}'\n \n \n+def test_import_string_thing_with_name() -> None:",
      "comment": "```suggestion\r\ndef test_import_string_thing_with_name() -> None:\r\n    \"\"\"https://github.com/pydantic/pydantic/issues/12218\"\"\"\r\n```",
      "comment_id": 2346394555,
      "user": "Viicos",
      "created_at": "2025-09-13T11:13:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/12219#discussion_r2346394555"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12219,
      "file_path": "tests/test_types.py",
      "line": 1054,
      "side": "RIGHT",
      "diff_hunk": "@@ -1050,6 +1050,19 @@ class ImportThings(BaseModel):\n     assert import_things.model_dump_json() == '{\"obj\":\"sys.stdout\"}'\n \n \n+def test_import_string_thing_with_name() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/12218\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"https://github.com/pydantic/pydantic/issues/12218\"\"\"\r\n\r\n```",
      "comment_id": 2346646743,
      "user": "Viicos",
      "created_at": "2025-09-13T13:38:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/12219#discussion_r2346646743"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12068,
      "file_path": "pydantic/config.py",
      "line": 601,
      "side": "RIGHT",
      "diff_hunk": "@@ -594,10 +594,43 @@ class Transaction(BaseModel):\n     The format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and\n     `'float'`. Defaults to `'iso8601'`.\n \n-    - `'iso8601'` will serialize timedeltas to ISO 8601 durations.\n+    !!! warning\n+        In v2.11+ it is recommended to use the [`ser_json_temporal`][pydantic.config.ConfigDict.ser_json_temporal]\n+        setting instead of `ser_json_timedelta`. This setting will be deprecated in v3.\n+    - `'iso8601'` will serialize timedeltas to [ISO 8601 text format](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n     - `'float'` will serialize timedeltas to the total number of seconds.",
      "comment": "```suggestion\r\n    - `'iso8601'` will serialize timedeltas to [ISO 8601 text format](https://en.wikipedia.org/wiki/ISO_8601#Durations).\r\n    - `'float'` will serialize timedeltas to the total number of seconds.\r\n    \r\n    !!! warning\r\n        Starting in v2.11, it is recommended to use the [`ser_json_temporal`][pydantic.config.ConfigDict.ser_json_temporal]\r\n        setting instead of `ser_json_timedelta`. This setting will be deprecated in v3.\r\n```",
      "comment_id": 2281395813,
      "user": "Viicos",
      "created_at": "2025-08-18T06:18:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/12068#discussion_r2281395813"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12068,
      "file_path": "pydantic/config.py",
      "line": 631,
      "side": "RIGHT",
      "diff_hunk": "@@ -594,10 +594,43 @@ class Transaction(BaseModel):\n     The format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and\n     `'float'`. Defaults to `'iso8601'`.\n \n-    - `'iso8601'` will serialize timedeltas to ISO 8601 durations.\n+    !!! warning\n+        In v2.11+ it is recommended to use the [`ser_json_temporal`][pydantic.config.ConfigDict.ser_json_temporal]\n+        setting instead of `ser_json_timedelta`. This setting will be deprecated in v3.\n+    - `'iso8601'` will serialize timedeltas to [ISO 8601 text format](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n     - `'float'` will serialize timedeltas to the total number of seconds.\n     \"\"\"\n \n+    ser_json_temporal: Literal['iso8601', 'seconds', 'milliseconds']\n+    \"\"\"\n+    The format of JSON serialized temporal types from the `datetime` library. This includes:\n+    - [`datetime.datetime`][]\n+    - [`datetime.date`][]\n+    - [`datetime.time`][]\n+    - [`datetime.timedelta`][]\n+    !!! note\n+        This setting was introduced in v2.11. It overlaps with the `ser_json_timedelta`\n+        setting which will likely be deprecated in v3. It also adds more configurability for\n+        the other temporal types.\n+    Accepts the string values of `'iso8601'`, `'milliseconds'`, and `'seconds'`. Defaults to `'iso8601'`.\n+    - `'iso8601'` will serialize date-like types to [ISO 8601 text format](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n+    - `'milliseconds'` will serialize date-like types to a floating point number of milliseconds since the epoch.\n+    - `'seconds'` will serialize date-like types to a floating point number of seconds since the epoch.\n+    \"\"\"\n+\n+    val_temporal_unit: Literal['seconds', 'milliseconds', 'infer']\n+    \"\"\"\n+    The unit to assume for validating numeric input for datetime-like types. This includes:\n+    - [`datetime.datetime`][]\n+    - [`datetime.date`][]\n+    Defaults to `'infer'`.\n+    The \"epoch\" references below refer to the Unix epoch, which is 1970-01-01 00:00:00 UTC.\n+    - `'seconds'` will validate date or time numeric inputs as seconds since the epoch.\n+    - `'milliseconds'` will validate date or time numeric inputs as milliseconds since the epoch.\n+    - `'infer'` will infer the unit from the string numeric input on unix time:\n+        i.e. seconds (if >= -2^10 and <= 2^10) or milliseconds (if < -2^10or > 2^10) since the epoch.",
      "comment": "Let's add the necessary [configuration for MathJax](https://squidfunk.github.io/mkdocs-material/reference/math/#mathjax) and use it:\r\n\r\n```suggestion\r\n    The unit to assume for validating numeric input for datetime-like types ([`datetime.datetime`][] and [`datetime.date`][]). Can be one of:\r\n\r\n    - `'seconds'` will validate date or time numeric inputs as seconds since the [epoch].\r\n    - `'milliseconds'` will validate date or time numeric inputs as milliseconds since the [epoch].\r\n    - `'infer'` will infer the unit from the string numeric input on unix time as:\r\n\r\n        * seconds since the [epoch] if $-2^{10} <= v <= 2^{10}$\r\n        * milliseconds since the [epoch] (if $v < -2^{10}$ or $v > 2^{10}$).\r\n\r\n    Defaults to `'infer'`.\r\n\r\n    [epoch]: https://en.wikipedia.org/wiki/Unix_time\r\n```",
      "comment_id": 2281435837,
      "user": "Viicos",
      "created_at": "2025-08-18T06:42:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/12068#discussion_r2281435837"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12068,
      "file_path": "pydantic/config.py",
      "line": 618,
      "side": "RIGHT",
      "diff_hunk": "@@ -594,10 +594,43 @@ class Transaction(BaseModel):\n     The format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and\n     `'float'`. Defaults to `'iso8601'`.\n \n-    - `'iso8601'` will serialize timedeltas to ISO 8601 durations.\n+    !!! warning\n+        In v2.11+ it is recommended to use the [`ser_json_temporal`][pydantic.config.ConfigDict.ser_json_temporal]\n+        setting instead of `ser_json_timedelta`. This setting will be deprecated in v3.\n+    - `'iso8601'` will serialize timedeltas to [ISO 8601 text format](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n     - `'float'` will serialize timedeltas to the total number of seconds.\n     \"\"\"\n \n+    ser_json_temporal: Literal['iso8601', 'seconds', 'milliseconds']\n+    \"\"\"\n+    The format of JSON serialized temporal types from the `datetime` library. This includes:\n+    - [`datetime.datetime`][]\n+    - [`datetime.date`][]\n+    - [`datetime.time`][]\n+    - [`datetime.timedelta`][]\n+    !!! note\n+        This setting was introduced in v2.11. It overlaps with the `ser_json_timedelta`\n+        setting which will likely be deprecated in v3. It also adds more configurability for\n+        the other temporal types.\n+    Accepts the string values of `'iso8601'`, `'milliseconds'`, and `'seconds'`. Defaults to `'iso8601'`.\n+    - `'iso8601'` will serialize date-like types to [ISO 8601 text format](https://en.wikipedia.org/wiki/ISO_8601#Durations).\n+    - `'milliseconds'` will serialize date-like types to a floating point number of milliseconds since the epoch.\n+    - `'seconds'` will serialize date-like types to a floating point number of seconds since the epoch.",
      "comment": "```suggestion\r\n    The format of JSON serialized temporal types from the [`datetime`][] module. This includes:\r\n\r\n    - [`datetime.datetime`][]\r\n    - [`datetime.date`][]\r\n    - [`datetime.time`][]\r\n    - [`datetime.timedelta`][]\r\n\r\n    Can be one of:\r\n\r\n    - `'iso8601'` will serialize date-like types to [ISO 8601 text format](https://en.wikipedia.org/wiki/ISO_8601#Durations).\r\n    - `'milliseconds'` will serialize date-like types to a floating point number of milliseconds since the epoch.\r\n    - `'seconds'` will serialize date-like types to a floating point number of seconds since the epoch.\r\n\r\n    Defaults to `'iso8601'`.\r\n\r\n    !!! note\r\n        This setting was introduced in v2.11. It overlaps with the [`ser_json_timedelta`][pydantic.config.ConfigDict.ser_json_timedelta]\r\n        setting which will be deprecated in v3. It also adds more configurability for\r\n        the other temporal types.\r\n```",
      "comment_id": 2281436895,
      "user": "Viicos",
      "created_at": "2025-08-18T06:43:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/12068#discussion_r2281436895"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 7188,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1599,
      "side": "LEFT",
      "diff_hunk": "@@ -1497,7 +1498,6 @@ def _get_prepare_pydantic_annotations_for_known_type(\n     ) -> tuple[Any, list[Any]] | None:\n         from ._std_types_schema import PREPARE_METHODS\n \n-        # This check for hashability is only necessary for python 3.7",
      "comment": "Seem we need this check for other versions as well. by removing this check some tests fail. like https://github.com/pydantic/pydantic/blob/8989f96415b0c693585fa9363eaf520d5b9a30a2/tests/test_json_schema.py#L4891",
      "comment_id": 1300047061,
      "user": "hramezani",
      "created_at": "2023-08-21T12:31:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/7188#discussion_r1300047061"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12196,
      "file_path": "pydantic/version.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,8 +77,26 @@ def version_info() -> str:\n \n def check_pydantic_core_version() -> bool:\n     \"\"\"Check that the installed `pydantic-core` dependency is compatible.\"\"\"\n-    # Keep this in sync with the version constraint in the `pyproject.toml` dependencies:\n-    return __pydantic_core_version__ == '2.37.2'\n+    return __pydantic_core_version__ == _COMPATIBLE_PYDANTIC_CORE_VERSION\n+\n+\n+def _ensure_pydantic_core_version() -> None:  # pragma: no cover\n+    if not check_pydantic_core_version():\n+        raise_error = True\n+        # Do not raise the error if pydantic is installed in editable mode (i.e. in development):\n+        if sys.version_info >= (3, 13):  # origin property added in 3.13",
      "comment": "Do we potentially want an env var to silence this for development on older Python versions?",
      "comment_id": 2303898997,
      "user": "davidhewitt",
      "created_at": "2025-08-27T13:14:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/12196#discussion_r2303898997"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12196,
      "file_path": "pydantic/version.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,8 +77,26 @@ def version_info() -> str:\n \n def check_pydantic_core_version() -> bool:\n     \"\"\"Check that the installed `pydantic-core` dependency is compatible.\"\"\"\n-    # Keep this in sync with the version constraint in the `pyproject.toml` dependencies:\n-    return __pydantic_core_version__ == '2.37.2'\n+    return __pydantic_core_version__ == _COMPATIBLE_PYDANTIC_CORE_VERSION\n+\n+\n+def _ensure_pydantic_core_version() -> None:  # pragma: no cover\n+    if not check_pydantic_core_version():\n+        raise_error = True\n+        # Do not raise the error if pydantic is installed in editable mode (i.e. in development):\n+        if sys.version_info >= (3, 13):  # origin property added in 3.13",
      "comment": "I thought about it, but I think most one-time contributors will have the version right on `uv sync`, and for us well I can only recommend using 3.13 or soon 3.14 :smile: ",
      "comment_id": 2304000700,
      "user": "Viicos",
      "created_at": "2025-08-27T13:49:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/12196#discussion_r2304000700"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11942,
      "file_path": "pydantic/functional_validators.py",
      "line": 881,
      "side": "RIGHT",
      "diff_hunk": "@@ -831,3 +831,53 @@ def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler\n             )\n \n         __hash__ = object.__hash__\n+\n+\n+_FromTypeT = TypeVar('_FromTypeT')\n+\n+\n+class ValidateFrom:\n+    \"\"\"A helper class to validate a custom type from a type natively supported by Pydantic.\n+\n+    Args:\n+        from_type: The type natively supported by Pydantic to use to perform validation.\n+        instantiation_hook: A callable taking the validated type as an argument, and returning\n+            the populated custom type.\n+\n+    Example:\n+        ```python {lint=\"skip\"}\n+        from typing import Annotated\n+\n+        from pydantic import BaseModel, TypeAdapter, ValidateFrom\n+\n+        class MyCls:\n+            def __init__(self, a: int) -> None:\n+                self.a = a\n+\n+            def __repr__(self) -> str:\n+                return f\"MyCls(a={self.a})\"\n+\n+        class Model(BaseModel):\n+            a: int\n+\n+\n+        ta = TypeAdapter(\n+            Annotated[MyCls, ValidateFrom(Model, instantiation_hook=lambda v: MyCls(a=v.a))]\n+        )\n+\n+        print(ta.validate_python({'a': 1}))\n+        #> MyCls(a=1)\n+        ```\n+    \"\"\"\n+\n+    # TODO: make use of PEP 747\n+    def __init__(self, from_type: type[_FromTypeT], /, *, instantiation_hook: Callable[[_FromTypeT], Any]) -> None:\n+        self.from_type = from_type\n+        self.instantiation_hook = instantiation_hook\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(self.from_type)\n+        return core_schema.no_info_after_validator_function(\n+            lambda value: self.instantiation_hook(value),",
      "comment": "Would this work?\r\n\r\n```suggestion\r\n            self.instantiation_hook,\r\n```",
      "comment_id": 2278964398,
      "user": "DouweM",
      "created_at": "2025-08-15T13:10:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/11942#discussion_r2278964398"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11942,
      "file_path": "pydantic/functional_validators.py",
      "line": 881,
      "side": "RIGHT",
      "diff_hunk": "@@ -831,3 +831,53 @@ def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler\n             )\n \n         __hash__ = object.__hash__\n+\n+\n+_FromTypeT = TypeVar('_FromTypeT')\n+\n+\n+class ValidateFrom:\n+    \"\"\"A helper class to validate a custom type from a type natively supported by Pydantic.\n+\n+    Args:\n+        from_type: The type natively supported by Pydantic to use to perform validation.\n+        instantiation_hook: A callable taking the validated type as an argument, and returning\n+            the populated custom type.\n+\n+    Example:\n+        ```python {lint=\"skip\"}\n+        from typing import Annotated\n+\n+        from pydantic import BaseModel, TypeAdapter, ValidateFrom\n+\n+        class MyCls:\n+            def __init__(self, a: int) -> None:\n+                self.a = a\n+\n+            def __repr__(self) -> str:\n+                return f\"MyCls(a={self.a})\"\n+\n+        class Model(BaseModel):\n+            a: int\n+\n+\n+        ta = TypeAdapter(\n+            Annotated[MyCls, ValidateFrom(Model, instantiation_hook=lambda v: MyCls(a=v.a))]\n+        )\n+\n+        print(ta.validate_python({'a': 1}))\n+        #> MyCls(a=1)\n+        ```\n+    \"\"\"\n+\n+    # TODO: make use of PEP 747\n+    def __init__(self, from_type: type[_FromTypeT], /, *, instantiation_hook: Callable[[_FromTypeT], Any]) -> None:\n+        self.from_type = from_type\n+        self.instantiation_hook = instantiation_hook\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(self.from_type)\n+        return core_schema.no_info_after_validator_function(\n+            lambda value: self.instantiation_hook(value),",
      "comment": "> > It can currently be anything (supported by Pydantic: models, dataclasses, typeddicts, etc), but we will have to constrain it to some specific types (perhaps only supporting Pydantic models?) as we will most likely have to assume `__dict__` is present to fetch the instance attributes and pass them to `__new__()`.\r\n\r\nCould `TypeAdapter(from_type).dump_python(value)` work instead of `__dict__`?",
      "comment_id": 2278971975,
      "user": "DouweM",
      "created_at": "2025-08-15T13:16:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/11942#discussion_r2278971975"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11942,
      "file_path": "pydantic/functional_validators.py",
      "line": 874,
      "side": "RIGHT",
      "diff_hunk": "@@ -831,3 +831,53 @@ def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler\n             )\n \n         __hash__ = object.__hash__\n+\n+\n+_FromTypeT = TypeVar('_FromTypeT')\n+\n+\n+class ValidateFrom:\n+    \"\"\"A helper class to validate a custom type from a type natively supported by Pydantic.\n+\n+    Args:\n+        from_type: The type natively supported by Pydantic to use to perform validation.\n+        instantiation_hook: A callable taking the validated type as an argument, and returning\n+            the populated custom type.\n+\n+    Example:\n+        ```python {lint=\"skip\"}\n+        from typing import Annotated\n+\n+        from pydantic import BaseModel, TypeAdapter, ValidateFrom\n+\n+        class MyCls:\n+            def __init__(self, a: int) -> None:\n+                self.a = a\n+\n+            def __repr__(self) -> str:\n+                return f\"MyCls(a={self.a})\"\n+\n+        class Model(BaseModel):\n+            a: int\n+\n+\n+        ta = TypeAdapter(\n+            Annotated[MyCls, ValidateFrom(Model, instantiation_hook=lambda v: MyCls(a=v.a))]\n+        )\n+\n+        print(ta.validate_python({'a': 1}))\n+        #> MyCls(a=1)\n+        ```\n+    \"\"\"\n+\n+    # TODO: make use of PEP 747\n+    def __init__(self, from_type: type[_FromTypeT], /, *, instantiation_hook: Callable[[_FromTypeT], Any]) -> None:",
      "comment": "`instantiation_hook` is pretty long, does it have to be a kwarg? `ValidateFrom(Model, lambda v: MyCls(a=v.a))` is pretty clear ",
      "comment_id": 2278973814,
      "user": "DouweM",
      "created_at": "2025-08-15T13:17:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/11942#discussion_r2278973814"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11942,
      "file_path": "pydantic/functional_validators.py",
      "line": 881,
      "side": "RIGHT",
      "diff_hunk": "@@ -831,3 +831,53 @@ def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler\n             )\n \n         __hash__ = object.__hash__\n+\n+\n+_FromTypeT = TypeVar('_FromTypeT')\n+\n+\n+class ValidateFrom:\n+    \"\"\"A helper class to validate a custom type from a type natively supported by Pydantic.\n+\n+    Args:\n+        from_type: The type natively supported by Pydantic to use to perform validation.\n+        instantiation_hook: A callable taking the validated type as an argument, and returning\n+            the populated custom type.\n+\n+    Example:\n+        ```python {lint=\"skip\"}\n+        from typing import Annotated\n+\n+        from pydantic import BaseModel, TypeAdapter, ValidateFrom\n+\n+        class MyCls:\n+            def __init__(self, a: int) -> None:\n+                self.a = a\n+\n+            def __repr__(self) -> str:\n+                return f\"MyCls(a={self.a})\"\n+\n+        class Model(BaseModel):\n+            a: int\n+\n+\n+        ta = TypeAdapter(\n+            Annotated[MyCls, ValidateFrom(Model, instantiation_hook=lambda v: MyCls(a=v.a))]\n+        )\n+\n+        print(ta.validate_python({'a': 1}))\n+        #> MyCls(a=1)\n+        ```\n+    \"\"\"\n+\n+    # TODO: make use of PEP 747\n+    def __init__(self, from_type: type[_FromTypeT], /, *, instantiation_hook: Callable[[_FromTypeT], Any]) -> None:\n+        self.from_type = from_type\n+        self.instantiation_hook = instantiation_hook\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(self.from_type)\n+        return core_schema.no_info_after_validator_function(\n+            lambda value: self.instantiation_hook(value),",
      "comment": "> Would this work?\r\n\r\nNice catch, updated.\r\n\r\n> Could `TypeAdapter(from_type).dump_python(value)` work instead of `__dict__`?\r\n\r\nWell even this way, if `from_type` happens to be e.g. a list we can't make assumptions on the dumped value, and how to use it to populate the final custom type.",
      "comment_id": 2279216054,
      "user": "Viicos",
      "created_at": "2025-08-15T15:19:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/11942#discussion_r2279216054"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11942,
      "file_path": "pydantic/functional_validators.py",
      "line": 874,
      "side": "RIGHT",
      "diff_hunk": "@@ -831,3 +831,53 @@ def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler\n             )\n \n         __hash__ = object.__hash__\n+\n+\n+_FromTypeT = TypeVar('_FromTypeT')\n+\n+\n+class ValidateFrom:\n+    \"\"\"A helper class to validate a custom type from a type natively supported by Pydantic.\n+\n+    Args:\n+        from_type: The type natively supported by Pydantic to use to perform validation.\n+        instantiation_hook: A callable taking the validated type as an argument, and returning\n+            the populated custom type.\n+\n+    Example:\n+        ```python {lint=\"skip\"}\n+        from typing import Annotated\n+\n+        from pydantic import BaseModel, TypeAdapter, ValidateFrom\n+\n+        class MyCls:\n+            def __init__(self, a: int) -> None:\n+                self.a = a\n+\n+            def __repr__(self) -> str:\n+                return f\"MyCls(a={self.a})\"\n+\n+        class Model(BaseModel):\n+            a: int\n+\n+\n+        ta = TypeAdapter(\n+            Annotated[MyCls, ValidateFrom(Model, instantiation_hook=lambda v: MyCls(a=v.a))]\n+        )\n+\n+        print(ta.validate_python({'a': 1}))\n+        #> MyCls(a=1)\n+        ```\n+    \"\"\"\n+\n+    # TODO: make use of PEP 747\n+    def __init__(self, from_type: type[_FromTypeT], /, *, instantiation_hook: Callable[[_FromTypeT], Any]) -> None:",
      "comment": "I'm a bit worried that if users end up using the positional form, it won't be obvious to know what `ValidateFrom` is doing:\r\n\r\n```python\r\nclass Model(BaseModel):\r\n    a: Annotated[MyType, ValidateFrom(SomeModel, lambda v: ...)]\r\n```\r\n\r\nbut if I don't manage to find a shorter name, I'll make it positional or kw.",
      "comment_id": 2279226566,
      "user": "Viicos",
      "created_at": "2025-08-15T15:21:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/11942#discussion_r2279226566"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11942,
      "file_path": "pydantic/functional_validators.py",
      "line": 881,
      "side": "RIGHT",
      "diff_hunk": "@@ -831,3 +831,53 @@ def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler\n             )\n \n         __hash__ = object.__hash__\n+\n+\n+_FromTypeT = TypeVar('_FromTypeT')\n+\n+\n+class ValidateFrom:\n+    \"\"\"A helper class to validate a custom type from a type natively supported by Pydantic.\n+\n+    Args:\n+        from_type: The type natively supported by Pydantic to use to perform validation.\n+        instantiation_hook: A callable taking the validated type as an argument, and returning\n+            the populated custom type.\n+\n+    Example:\n+        ```python {lint=\"skip\"}\n+        from typing import Annotated\n+\n+        from pydantic import BaseModel, TypeAdapter, ValidateFrom\n+\n+        class MyCls:\n+            def __init__(self, a: int) -> None:\n+                self.a = a\n+\n+            def __repr__(self) -> str:\n+                return f\"MyCls(a={self.a})\"\n+\n+        class Model(BaseModel):\n+            a: int\n+\n+\n+        ta = TypeAdapter(\n+            Annotated[MyCls, ValidateFrom(Model, instantiation_hook=lambda v: MyCls(a=v.a))]\n+        )\n+\n+        print(ta.validate_python({'a': 1}))\n+        #> MyCls(a=1)\n+        ```\n+    \"\"\"\n+\n+    # TODO: make use of PEP 747\n+    def __init__(self, from_type: type[_FromTypeT], /, *, instantiation_hook: Callable[[_FromTypeT], Any]) -> None:\n+        self.from_type = from_type\n+        self.instantiation_hook = instantiation_hook\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(self.from_type)\n+        return core_schema.no_info_after_validator_function(\n+            lambda value: self.instantiation_hook(value),",
      "comment": "@Viicos Right, then keeping it like this at least to start makes sense",
      "comment_id": 2279274658,
      "user": "DouweM",
      "created_at": "2025-08-15T15:31:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/11942#discussion_r2279274658"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11942,
      "file_path": "pydantic/functional_validators.py",
      "line": 874,
      "side": "RIGHT",
      "diff_hunk": "@@ -831,3 +831,53 @@ def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler\n             )\n \n         __hash__ = object.__hash__\n+\n+\n+_FromTypeT = TypeVar('_FromTypeT')\n+\n+\n+class ValidateFrom:\n+    \"\"\"A helper class to validate a custom type from a type natively supported by Pydantic.\n+\n+    Args:\n+        from_type: The type natively supported by Pydantic to use to perform validation.\n+        instantiation_hook: A callable taking the validated type as an argument, and returning\n+            the populated custom type.\n+\n+    Example:\n+        ```python {lint=\"skip\"}\n+        from typing import Annotated\n+\n+        from pydantic import BaseModel, TypeAdapter, ValidateFrom\n+\n+        class MyCls:\n+            def __init__(self, a: int) -> None:\n+                self.a = a\n+\n+            def __repr__(self) -> str:\n+                return f\"MyCls(a={self.a})\"\n+\n+        class Model(BaseModel):\n+            a: int\n+\n+\n+        ta = TypeAdapter(\n+            Annotated[MyCls, ValidateFrom(Model, instantiation_hook=lambda v: MyCls(a=v.a))]\n+        )\n+\n+        print(ta.validate_python({'a': 1}))\n+        #> MyCls(a=1)\n+        ```\n+    \"\"\"\n+\n+    # TODO: make use of PEP 747\n+    def __init__(self, from_type: type[_FromTypeT], /, *, instantiation_hook: Callable[[_FromTypeT], Any]) -> None:",
      "comment": "I think `Annotated[MyType, ValidateAs(SomeModel, lambda v: ...)]` implies pretty well that the input will be validated as a `SomeModel`, and then you're supposed to turn a `SomeModel` into a `MyType`. `ValidateAs` implies that a bit more clearly to me than `ValidateFrom`",
      "comment_id": 2279282215,
      "user": "DouweM",
      "created_at": "2025-08-15T15:32:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/11942#discussion_r2279282215"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12002,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 622,
      "side": "RIGHT",
      "diff_hunk": "@@ -619,7 +619,7 @@ def _arbitrary_type_schema(self, tp: Any) -> CoreSchema:\n                 ' Pydantic will allow any object with no validation since we cannot even'\n                 ' enforce that the input is an instance of the given type.'\n                 ' To get rid of this error wrap the type with `pydantic.SkipValidation`.',\n-                UserWarning,\n+                PydanticSkipValidationWarning,  # Updated warning type,",
      "comment": "```suggestion\r\n                PydanticArbitraryTypeWarning,\r\n```",
      "comment_id": 2161109248,
      "user": "Viicos",
      "created_at": "2025-06-23T09:10:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/12002#discussion_r2161109248"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12002,
      "file_path": "pydantic/functional_validators.py",
      "line": 831,
      "side": "RIGHT",
      "diff_hunk": "@@ -817,13 +819,15 @@ def __class_getitem__(cls, item: Any) -> Any:\n \n         @classmethod\n         def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n-            original_schema = handler(source)\n-            metadata = {'pydantic_js_annotation_functions': [lambda _c, h: h(original_schema)]}\n-            return core_schema.any_schema(\n-                metadata=metadata,\n-                serialization=core_schema.wrap_serializer_function_ser_schema(\n-                    function=lambda v, h: h(v), schema=original_schema\n-                ),\n-            )\n+            with warnings.catch_warnings():\n+                warnings.simplefilter('ignore', PydanticSkipValidationWarning)\n+                original_schema = handler(source)\n+                metadata = {'pydantic_js_annotation_functions': [lambda _c, h: h(original_schema)]}\n+                return core_schema.any_schema(\n+                    metadata=metadata,\n+                    serialization=core_schema.wrap_serializer_function_ser_schema(\n+                        function=lambda v, h: h(v), schema=original_schema\n+                    ),\n+                )",
      "comment": "```suggestion\r\n            metadata = {'pydantic_js_annotation_functions': [lambda _c, h: h(original_schema)]}\r\n            return core_schema.any_schema(\r\n                metadata=metadata,\r\n                serialization=core_schema.wrap_serializer_function_ser_schema(\r\n                    function=lambda v, h: h(v), schema=original_schema\r\n                ),\r\n            )\r\n```",
      "comment_id": 2161110729,
      "user": "Viicos",
      "created_at": "2025-06-23T09:11:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/12002#discussion_r2161110729"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12002,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,7 +62,7 @@\n from ..functional_validators import AfterValidator, BeforeValidator, FieldValidatorModes, PlainValidator, WrapValidator\n from ..json_schema import JsonSchemaValue\n from ..version import version_short\n-from ..warnings import PydanticDeprecatedSince20\n+from ..warnings import PydanticDeprecatedSince20, PydanticSkipValidationWarning",
      "comment": "```suggestion\r\nfrom ..warnings import PydanticArbitraryTypeWarning, PydanticDeprecatedSince20\r\n```",
      "comment_id": 2161114862,
      "user": "Viicos",
      "created_at": "2025-06-23T09:13:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/12002#discussion_r2161114862"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12002,
      "file_path": "pydantic/functional_validators.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,6 +15,7 @@\n from ._internal import _decorators, _generics, _internal_dataclass\n from .annotated_handlers import GetCoreSchemaHandler\n from .errors import PydanticUserError\n+from .warnings import PydanticSkipValidationWarning",
      "comment": "```suggestion\r\nfrom .warnings import PydanticArbitraryTypeWarning\r\n```",
      "comment_id": 2161115592,
      "user": "Viicos",
      "created_at": "2025-06-23T09:13:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/12002#discussion_r2161115592"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12002,
      "file_path": "pydantic/functional_validators.py",
      "line": 823,
      "side": "RIGHT",
      "diff_hunk": "@@ -817,13 +819,15 @@ def __class_getitem__(cls, item: Any) -> Any:\n \n         @classmethod\n         def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n-            original_schema = handler(source)\n-            metadata = {'pydantic_js_annotation_functions': [lambda _c, h: h(original_schema)]}\n-            return core_schema.any_schema(\n-                metadata=metadata,\n-                serialization=core_schema.wrap_serializer_function_ser_schema(\n-                    function=lambda v, h: h(v), schema=original_schema\n-                ),\n-            )\n+            with warnings.catch_warnings():\n+                warnings.simplefilter('ignore', PydanticSkipValidationWarning)",
      "comment": "```suggestion\r\n                warnings.simplefilter('ignore', PydanticArbitraryTypeWarning)\r\n```",
      "comment_id": 2161115936,
      "user": "Viicos",
      "created_at": "2025-06-23T09:13:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/12002#discussion_r2161115936"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12002,
      "file_path": "pydantic/warnings.py",
      "line": 100,
      "side": "RIGHT",
      "diff_hunk": "@@ -94,3 +94,7 @@ class PydanticExperimentalWarning(Warning):\n     This warning is raised when using experimental functionality in Pydantic.\n     It is raised to warn users that the functionality may change or be removed in future versions of Pydantic.\n     \"\"\"\n+\n+\n+class PydanticSkipValidationWarning(UserWarning):\n+    \"\"\"Warning raised when SkipValidation is used for unsupported types.\"\"\"",
      "comment": "```suggestion\r\nclass PydanticArbitraryTypeWarning(UserWarning):\r\n    \"\"\"Warning raised when Pydantic fails to generate a core schema for an arbitrary type.\"\"\"\r\n```",
      "comment_id": 2161117398,
      "user": "Viicos",
      "created_at": "2025-06-23T09:14:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/12002#discussion_r2161117398"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11858,
      "file_path": "pydantic/functional_validators.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -94,7 +94,7 @@ class BeforeValidator:\n \n     Attributes:\n         func: The validator function.\n-        json_schema_input_type: The input type of the function. This is only used to generate the appropriate\n+        json_schema_input_type: This is only used to generate the appropriate\n             JSON Schema (in validation mode).",
      "comment": "```suggestion\r\n        json_schema_input_type: The input type used to generate the appropriate\r\n            JSON Schema (in validation mode). The actual input type is `Any`.\r\n```",
      "comment_id": 2084439283,
      "user": "DouweM",
      "created_at": "2025-05-12T11:06:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/11858#discussion_r2084439283"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "pydantic/main.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -313,6 +313,7 @@ def __new__(mcs, name, bases, namespace, **kwargs):  # noqa C901\n             '__schema_cache__': {},\n             '__json_encoder__': staticmethod(json_encoder),\n             '__custom_root_type__': _custom_root_type,\n+            '__hash__': (lambda self: hash(tuple(self.__dict__.values()))) if not config.allow_mutation else None,",
      "comment": "Instead of `.values` we should probably have `.items` here.  The keys ought to be considered a part of the identity of the object.\r\n\r\nExample:\r\n```\r\nx = {\"a\": 1, \"b\": True}\r\ny = {\"d\": 1, \"c\": True}\r\nhash(tuple(x.values())) == hash(tuple(y.values()))  # True\r\nhash(tuple(x.items())) == hash(tuple(y.items()))  # False\r\n```",
      "comment_id": 490409076,
      "user": "wozniakty",
      "created_at": "2020-09-17T16:45:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r490409076"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "tests/test_main.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,6 +386,32 @@ class Config:\n     assert '\"TestModel\" object has no field \"b\"' in exc_info.value.args[0]\n \n \n+def test_immutable_with_hashable_fields_are_hashable():\n+    class TestModel(BaseModel):\n+        a: int = 10\n+\n+        class Config:\n+            allow_mutation = False\n+\n+    m = TestModel()\n+    assert m.__hash__ is not None\n+    assert isinstance(hash(m), int)\n+\n+\n+def test_immutable_with_unhashable_fields_are_not_hashable():\n+    class TestModel(BaseModel):\n+        a: int = 10\n+        y: List[int] = [1, 2, 3]\n+\n+        class Config:\n+            allow_mutation = False\n+\n+    m = TestModel()\n+    with pytest.raises(TypeError) as exc_info:\n+        hash(m)\n+    assert \"unhashable type: 'list'\" in exc_info.value.args[0]",
      "comment": "IMO would be nice for the exception message to be more like \"unhashable type: 'TestModel' contains unhashable type: 'list'  but I wouldn't say it's a strong opinion.  Food for thought.",
      "comment_id": 490416671,
      "user": "wozniakty",
      "created_at": "2020-09-17T16:57:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r490416671"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "pydantic/main.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -313,6 +313,7 @@ def __new__(mcs, name, bases, namespace, **kwargs):  # noqa C901\n             '__schema_cache__': {},\n             '__json_encoder__': staticmethod(json_encoder),\n             '__custom_root_type__': _custom_root_type,\n+            '__hash__': (lambda self: hash(tuple(self.__dict__.values()))) if not config.allow_mutation else None,",
      "comment": "In that case, we diverge from behaviour of the built-in dataclass. But I do not know if it is a problem.\r\nIf it not a problem, then I agree with you ! :)",
      "comment_id": 498257798,
      "user": "rhuille",
      "created_at": "2020-10-01T13:48:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r498257798"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "pydantic/main.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -313,6 +313,7 @@ def __new__(mcs, name, bases, namespace, **kwargs):  # noqa C901\n             '__schema_cache__': {},\n             '__json_encoder__': staticmethod(json_encoder),\n             '__custom_root_type__': _custom_root_type,\n+            '__hash__': (lambda self: hash(tuple(self.__dict__.values()))) if not config.allow_mutation else None,",
      "comment": "I don't think this needs to be a lambda, it can be proper method on `BaseModel` I imagine. It could raise an error if `allow_mutation is True` .\r\n",
      "comment_id": 502362557,
      "user": "samuelcolvin",
      "created_at": "2020-10-09T11:25:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r502362557"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "pydantic/main.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -313,6 +313,7 @@ def __new__(mcs, name, bases, namespace, **kwargs):  # noqa C901\n             '__schema_cache__': {},\n             '__json_encoder__': staticmethod(json_encoder),\n             '__custom_root_type__': _custom_root_type,\n+            '__hash__': (lambda self: hash(tuple(self.__dict__.values()))) if not config.allow_mutation else None,",
      "comment": "okay, so it can't just be a method on `BaseModel`, but let's make it a proper function, not a lambda.",
      "comment_id": 502392221,
      "user": "samuelcolvin",
      "created_at": "2020-10-09T12:28:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r502392221"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "pydantic/main.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -313,6 +313,7 @@ def __new__(mcs, name, bases, namespace, **kwargs):  # noqa C901\n             '__schema_cache__': {},\n             '__json_encoder__': staticmethod(json_encoder),\n             '__custom_root_type__': _custom_root_type,\n+            '__hash__': (lambda self: hash(tuple(self.__dict__.values()))) if not config.allow_mutation else None,",
      "comment": "> Instead of `.values` we should probably have `.items` here. The keys ought to be considered a part of the identity of the object.\r\n\r\nI think this would be unnecessary if we include a reference to the model class.",
      "comment_id": 502398896,
      "user": "layday",
      "created_at": "2020-10-09T12:40:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r502398896"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "pydantic/main.py",
      "line": 332,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,6 +329,7 @@ def __new__(mcs, name, bases, namespace, **kwargs):  # noqa C901\n             '__custom_root_type__': _custom_root_type,\n             '__private_attributes__': private_attributes,\n             '__slots__': slots | private_attributes.keys(),\n+            '__hash__': generate_hash_function(config.frozen, super()),",
      "comment": "`super()` is the metaclass here. I don't understand why you need to do that \ud83e\udd14 ",
      "comment_id": 560801908,
      "user": "PrettyWood",
      "created_at": "2021-01-20T09:16:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r560801908"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "pydantic/main.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -198,6 +199,13 @@ def validate_custom_root_type(fields: Dict[str, ModelField]) -> None:\n         raise ValueError('__root__ cannot be mixed with other fields')\n \n \n+def generate_hash_function(frozen: bool, super_class: Any) -> Optional[Callable[[Any], int]]:\n+    def hash_function(self_: Any) -> int:\n+        return hash(super_class) + hash(tuple(self_.__dict__.values()))",
      "comment": "IMO you could just do `hash(self_.__class__)` instead of using `super_class`",
      "comment_id": 560802090,
      "user": "PrettyWood",
      "created_at": "2021-01-20T09:17:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r560802090"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "pydantic/main.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -198,6 +199,13 @@ def validate_custom_root_type(fields: Dict[str, ModelField]) -> None:\n         raise ValueError('__root__ cannot be mixed with other fields')\n \n \n+def generate_hash_function(frozen: bool, super_class: Any) -> Optional[Callable[[Any], int]]:\n+    def hash_function(self_: Any) -> int:\n+        return hash(super_class) + hash(tuple(self_.__dict__.values()))",
      "comment": "Yes your are right ! https://github.com/samuelcolvin/pydantic/pull/1881/commits/12cff48de640035718d1308c04eb007fe5e1ef05 (I was overthinked this...)",
      "comment_id": 565464587,
      "user": "rhuille",
      "created_at": "2021-01-27T16:45:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r565464587"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "tests/mypy/modules/plugin_fail.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -202,3 +202,37 @@ class AddProject:\n \n \n p = AddProject(name='x', slug='y', description='z')\n+\n+\n+# Same as Model, but with frozen = True\n+class FrozenModel(BaseModel):\n+    x: int\n+    y: str\n+\n+    def method(self) -> None:\n+        pass\n+\n+    class Config:\n+        alias_generator = None\n+        frozen = True\n+        extra = Extra.forbid\n+\n+        def config_method(self) -> None:\n+            ...\n+\n+\n+frozenmodel = FrozenModel(x=1, y='y', z='z')",
      "comment": "this isn't testing frozen behaviour I think, again can be removed.",
      "comment_id": 575662771,
      "user": "samuelcolvin",
      "created_at": "2021-02-13T12:40:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r575662771"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "tests/mypy/modules/plugin_success.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -139,3 +139,22 @@ class Model(BaseModel):\n \n dynamic_model = DynamicModel(x=1, y='y')\n dynamic_model.x = 2\n+\n+\n+class FrozenModel(BaseModel):\n+    x: int\n+\n+    class Config:\n+        frozen = True\n+\n+\n+class NotFrozenModel(FrozenModel):\n+    a = 1",
      "comment": "add a type here to avoid extra errors in `plugin-success-strict.txt `",
      "comment_id": 575662903,
      "user": "samuelcolvin",
      "created_at": "2021-02-13T12:42:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r575662903"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 1881,
      "file_path": "tests/test_main.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -351,39 +351,96 @@ class Model(BaseModel):\n     assert exc_info.value.errors() == [{'loc': ('a',), 'msg': 'field required', 'type': 'value_error.missing'}]\n \n \n-def test_not_immutability():\n+@pytest.mark.parametrize('allow_mutation_, frozen_', [(False, False), (True, False), (False, True), (True, True)])\n+def test_immutability(allow_mutation_, frozen_):\n     class TestModel(BaseModel):\n         a: int = 10\n \n         class Config:\n-            allow_mutation = True\n+            allow_mutation = allow_mutation_\n             extra = Extra.forbid\n+            frozen = frozen_\n \n     m = TestModel()\n-    assert m.a == 10\n-    m.a = 11\n-    assert m.a == 11\n-    with pytest.raises(ValueError) as exc_info:\n-        m.b = 11\n-    assert '\"TestModel\" object has no field \"b\"' in exc_info.value.args[0]\n+\n+    immutable = allow_mutation_ is False or frozen_ is True\n+\n+    if immutable:",
      "comment": "rather than this if clause, better to setup two separate tests.",
      "comment_id": 575662957,
      "user": "samuelcolvin",
      "created_at": "2021-02-13T12:43:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/1881#discussion_r575662957"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12051,
      "file_path": "tests/test_dataclasses.py",
      "line": 2146,
      "side": "RIGHT",
      "diff_hunk": "@@ -2115,6 +2115,34 @@ class Child(Parent):\n     assert Child().a == 1\n \n \n+def test_dataclasses_inheritance_bare_class_not_used() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/12045\"\"\"\n+\n+    class BareClass:\n+        a: int = Field(kw_only=True)\n+\n+    @pydantic.dataclasses.dataclass\n+    class DC(BareClass):\n+        pass\n+\n+    assert len(DC.__dataclass_fields__) == 0\n+    assert len(DC.__pydantic_fields__) == 0\n+\n+\n+def test_dataclasses_type_override_pydantic_field() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/12045\"\"\"\n+\n+    @dataclasses.dataclass\n+    class A:\n+        a: int = Field()\n+\n+    @pydantic.dataclasses.dataclass\n+    class B(A):\n+        a: str = dataclasses.field()\n+\n+    assert B(a='test').a == 'test'",
      "comment": "These two tests are technically breaking changes, but this was just undefined behavior and imo actual bugs. I think we should update our [stability policy](https://docs.pydantic.dev/latest/version-policy/#pydantic-v2) to state that bug fixes resulting in theoretical breaking change can be occur in minor releases. ",
      "comment_id": 2197144618,
      "user": "Viicos",
      "created_at": "2025-07-10T09:38:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/12051#discussion_r2197144618"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12051,
      "file_path": "tests/test_dataclasses.py",
      "line": 2146,
      "side": "RIGHT",
      "diff_hunk": "@@ -2115,6 +2115,34 @@ class Child(Parent):\n     assert Child().a == 1\n \n \n+def test_dataclasses_inheritance_bare_class_not_used() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/12045\"\"\"\n+\n+    class BareClass:\n+        a: int = Field(kw_only=True)\n+\n+    @pydantic.dataclasses.dataclass\n+    class DC(BareClass):\n+        pass\n+\n+    assert len(DC.__dataclass_fields__) == 0\n+    assert len(DC.__pydantic_fields__) == 0\n+\n+\n+def test_dataclasses_type_override_pydantic_field() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/12045\"\"\"\n+\n+    @dataclasses.dataclass\n+    class A:\n+        a: int = Field()\n+\n+    @pydantic.dataclasses.dataclass\n+    class B(A):\n+        a: str = dataclasses.field()\n+\n+    assert B(a='test').a == 'test'",
      "comment": "I think yes, as long as we also qualify that by saying that we'll make judgement call based on how much we expect the theoretical breaking change to actually be a real-world problem.",
      "comment_id": 2197348987,
      "user": "davidhewitt",
      "created_at": "2025-07-10T10:45:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/12051#discussion_r2197348987"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12051,
      "file_path": "tests/test_dataclasses.py",
      "line": 2146,
      "side": "RIGHT",
      "diff_hunk": "@@ -2115,6 +2115,34 @@ class Child(Parent):\n     assert Child().a == 1\n \n \n+def test_dataclasses_inheritance_bare_class_not_used() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/12045\"\"\"\n+\n+    class BareClass:\n+        a: int = Field(kw_only=True)\n+\n+    @pydantic.dataclasses.dataclass\n+    class DC(BareClass):\n+        pass\n+\n+    assert len(DC.__dataclass_fields__) == 0\n+    assert len(DC.__pydantic_fields__) == 0\n+\n+\n+def test_dataclasses_type_override_pydantic_field() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/12045\"\"\"\n+\n+    @dataclasses.dataclass\n+    class A:\n+        a: int = Field()\n+\n+    @pydantic.dataclasses.dataclass\n+    class B(A):\n+        a: str = dataclasses.field()\n+\n+    assert B(a='test').a == 'test'",
      "comment": "Yep, in this case you'd have to make use of a stdlib (that is not a Pydantic) dataclass or a bare class _with_ a Pydantic field used on it, which is pretty uncommon already.",
      "comment_id": 2197559701,
      "user": "Viicos",
      "created_at": "2025-07-10T12:15:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/12051#discussion_r2197559701"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12051,
      "file_path": "pydantic/_internal/_dataclasses.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,3 +208,105 @@ def is_stdlib_dataclass(cls: type[Any], /) -> TypeIs[type[StandardDataclass]]:\n         `True` if the class is a stdlib dataclass, `False` otherwise.\n     \"\"\"\n     return '__dataclass_fields__' in cls.__dict__ and not hasattr(cls, '__pydantic_validator__')\n+\n+\n+def as_dataclass_field(pydantic_field: FieldInfo) -> dataclasses.Field[Any]:\n+    field_args: dict[str, Any] = {'default': pydantic_field}\n+\n+    if sys.version_info >= (3, 10) and pydantic_field.kw_only:\n+        field_args['kw_only'] = True\n+\n+    if pydantic_field.repr is not True:\n+        field_args['repr'] = pydantic_field.repr\n+\n+    return dataclasses.field(**field_args)\n+\n+\n+DcFields: TypeAlias = dict[str, dataclasses.Field[Any]]\n+\n+\n+@contextmanager\n+def patch_base_fields(cls: type[Any]) -> Generator[None]:\n+    \"\"\"Temporarily patch the stdlib dataclasses bases of `cls` if the Pydantic `Field()` function is used.\n+\n+    When creating a Pydantic dataclass, it is possible to inherit from stdlib dataclasses, where\n+    the Pydantic `Field()` function is used. To create this Pydantic dataclass, we first apply\n+    the stdlib `@dataclass` decorator on it. During the construction of the stdlib dataclass,\n+    the `kw_only` and `repr` field arguments need to be understood by the stdlib *during* the\n+    dataclass construction. To do so, we temporarily patch the fields dictionary of the affected\n+    bases.\n+\n+    For instance, with the following example:\n+\n+    ```python {test=\"skip\" lint=\"skip\"}\n+    import dataclasses as stdlib_dc\n+\n+    import pydantic\n+    import pydantic.dataclasses as pydantic_dc\n+\n+    @stdlib_dc.dataclass\n+    class A:\n+        a: int = pydantic.Field(repr=False)\n+\n+    # Notice that the `repr` attribute of the dataclass field is `True`:\n+    A.__dataclass_fields__['a']\n+    #> dataclass.Field(default=FieldInfo(repr=False), repr=True, ...)\n+\n+    @pydantic_dc.dataclass\n+    class B(A):\n+        b: int = pydantic.Field(repr=False)\n+    ```\n+\n+    When passing `B` to the stdlib `@dataclass` decorator, it will look for fields in the parent classes\n+    and reuse them directly. When this contextmanager is active, `A` will be temporarily patched to be\n+    equivalent to:\n+\n+    ```python {test=\"skip\" lint=\"skip\"}\n+    @stdlib_dc.dataclass\n+    class A:\n+        a: int = stdlib_dc.field(default=Field(repr=False), repr=False)\n+    ```\n+\n+    !!! note\n+        This is only applied to the bases of `cls`, and not `cls` itself. The reason is that the Pydantic\n+        dataclass decorator \"owns\" `cls` (in the previous example, `B`). As such, we instead modify the fields\n+        directly (in the previous example, we simply do `setattr(B, 'b', as_dataclass_field(pydantic_field))`).\n+\n+    !!! note\n+        This approach is far from ideal, and can probably be the source of unwanted side effects/race conditions.\n+        The previous implemented approach was mutating the `__annotations__` dict of `cls`, which is no longer a\n+        safe operation in Python 3.14+, and resulted in unexpected behavior with field ordering anyway.",
      "comment": "Agreed, scary. If this became a problem, I think we could do stuff like set the field to be a wrapper object which checks what thread it's on and only exhibits the patched behaviour on this thread, but even that is observable so why bother \ud83d\ude22 ",
      "comment_id": 2210853813,
      "user": "davidhewitt",
      "created_at": "2025-07-16T16:02:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/12051#discussion_r2210853813"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12051,
      "file_path": "pydantic/_internal/_dataclasses.py",
      "line": 305,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,3 +208,105 @@ def is_stdlib_dataclass(cls: type[Any], /) -> TypeIs[type[StandardDataclass]]:\n         `True` if the class is a stdlib dataclass, `False` otherwise.\n     \"\"\"\n     return '__dataclass_fields__' in cls.__dict__ and not hasattr(cls, '__pydantic_validator__')\n+\n+\n+def as_dataclass_field(pydantic_field: FieldInfo) -> dataclasses.Field[Any]:\n+    field_args: dict[str, Any] = {'default': pydantic_field}\n+\n+    if sys.version_info >= (3, 10) and pydantic_field.kw_only:\n+        field_args['kw_only'] = True\n+\n+    if pydantic_field.repr is not True:\n+        field_args['repr'] = pydantic_field.repr\n+\n+    return dataclasses.field(**field_args)\n+\n+\n+DcFields: TypeAlias = dict[str, dataclasses.Field[Any]]\n+\n+\n+@contextmanager\n+def patch_base_fields(cls: type[Any]) -> Generator[None]:\n+    \"\"\"Temporarily patch the stdlib dataclasses bases of `cls` if the Pydantic `Field()` function is used.\n+\n+    When creating a Pydantic dataclass, it is possible to inherit from stdlib dataclasses, where\n+    the Pydantic `Field()` function is used. To create this Pydantic dataclass, we first apply\n+    the stdlib `@dataclass` decorator on it. During the construction of the stdlib dataclass,\n+    the `kw_only` and `repr` field arguments need to be understood by the stdlib *during* the\n+    dataclass construction. To do so, we temporarily patch the fields dictionary of the affected\n+    bases.\n+\n+    For instance, with the following example:\n+\n+    ```python {test=\"skip\" lint=\"skip\"}\n+    import dataclasses as stdlib_dc\n+\n+    import pydantic\n+    import pydantic.dataclasses as pydantic_dc\n+\n+    @stdlib_dc.dataclass\n+    class A:\n+        a: int = pydantic.Field(repr=False)\n+\n+    # Notice that the `repr` attribute of the dataclass field is `True`:\n+    A.__dataclass_fields__['a']\n+    #> dataclass.Field(default=FieldInfo(repr=False), repr=True, ...)\n+\n+    @pydantic_dc.dataclass\n+    class B(A):\n+        b: int = pydantic.Field(repr=False)\n+    ```\n+\n+    When passing `B` to the stdlib `@dataclass` decorator, it will look for fields in the parent classes\n+    and reuse them directly. When this contextmanager is active, `A` will be temporarily patched to be\n+    equivalent to:\n+\n+    ```python {test=\"skip\" lint=\"skip\"}\n+    @stdlib_dc.dataclass\n+    class A:\n+        a: int = stdlib_dc.field(default=Field(repr=False), repr=False)\n+    ```\n+\n+    !!! note\n+        This is only applied to the bases of `cls`, and not `cls` itself. The reason is that the Pydantic\n+        dataclass decorator \"owns\" `cls` (in the previous example, `B`). As such, we instead modify the fields\n+        directly (in the previous example, we simply do `setattr(B, 'b', as_dataclass_field(pydantic_field))`).\n+\n+    !!! note\n+        This approach is far from ideal, and can probably be the source of unwanted side effects/race conditions.\n+        The previous implemented approach was mutating the `__annotations__` dict of `cls`, which is no longer a\n+        safe operation in Python 3.14+, and resulted in unexpected behavior with field ordering anyway.\n+    \"\"\"\n+    # A list of two-tuples, the first element being a reference to the\n+    # dataclass fields dictionary, the second element being a mapping between\n+    # the field names that were modified, and their original `Field`:\n+    original_fields_list: list[tuple[DcFields, DcFields]] = []\n+\n+    for base in cls.__mro__[1:]:\n+        dc_fields: dict[str, dataclasses.Field[Any]] = base.__dict__.get('__dataclass_fields__', {})\n+        dc_fields_with_pydantic_field_defaults = {\n+            field_name: field\n+            for field_name, field in dc_fields.items()\n+            if isinstance(field.default, FieldInfo)\n+            # Only do the patching if one of the affected attributes is set:\n+            and (field.default.kw_only or field.default.repr is not True)\n+        }\n+        if dc_fields_with_pydantic_field_defaults:\n+            original_fields_list.append((dc_fields, dc_fields_with_pydantic_field_defaults))\n+            for field_name, field in dc_fields_with_pydantic_field_defaults.items():\n+                default = cast(FieldInfo, field.default)\n+                # `dataclasses.Field` isn't documented as working with `copy.copy()`.\n+                # It is a class with `__slots__`, so should work (and we hope for the best):\n+                new_dc_field = copy.copy(field)\n+                if default.kw_only:\n+                    new_dc_field.kw_only = True\n+                if default.repr is not True:\n+                    new_dc_field.repr = default.repr\n+                dc_fields[field_name] = new_dc_field",
      "comment": "I wonder, rather than mutating the fields of the base objects, is there a world where we instead patch the class attributes of the type under construction? That might be significantly less far-reaching in potential conflict?",
      "comment_id": 2210866912,
      "user": "davidhewitt",
      "created_at": "2025-07-16T16:08:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/12051#discussion_r2210866912"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12051,
      "file_path": "pydantic/_internal/_dataclasses.py",
      "line": 305,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,3 +208,105 @@ def is_stdlib_dataclass(cls: type[Any], /) -> TypeIs[type[StandardDataclass]]:\n         `True` if the class is a stdlib dataclass, `False` otherwise.\n     \"\"\"\n     return '__dataclass_fields__' in cls.__dict__ and not hasattr(cls, '__pydantic_validator__')\n+\n+\n+def as_dataclass_field(pydantic_field: FieldInfo) -> dataclasses.Field[Any]:\n+    field_args: dict[str, Any] = {'default': pydantic_field}\n+\n+    if sys.version_info >= (3, 10) and pydantic_field.kw_only:\n+        field_args['kw_only'] = True\n+\n+    if pydantic_field.repr is not True:\n+        field_args['repr'] = pydantic_field.repr\n+\n+    return dataclasses.field(**field_args)\n+\n+\n+DcFields: TypeAlias = dict[str, dataclasses.Field[Any]]\n+\n+\n+@contextmanager\n+def patch_base_fields(cls: type[Any]) -> Generator[None]:\n+    \"\"\"Temporarily patch the stdlib dataclasses bases of `cls` if the Pydantic `Field()` function is used.\n+\n+    When creating a Pydantic dataclass, it is possible to inherit from stdlib dataclasses, where\n+    the Pydantic `Field()` function is used. To create this Pydantic dataclass, we first apply\n+    the stdlib `@dataclass` decorator on it. During the construction of the stdlib dataclass,\n+    the `kw_only` and `repr` field arguments need to be understood by the stdlib *during* the\n+    dataclass construction. To do so, we temporarily patch the fields dictionary of the affected\n+    bases.\n+\n+    For instance, with the following example:\n+\n+    ```python {test=\"skip\" lint=\"skip\"}\n+    import dataclasses as stdlib_dc\n+\n+    import pydantic\n+    import pydantic.dataclasses as pydantic_dc\n+\n+    @stdlib_dc.dataclass\n+    class A:\n+        a: int = pydantic.Field(repr=False)\n+\n+    # Notice that the `repr` attribute of the dataclass field is `True`:\n+    A.__dataclass_fields__['a']\n+    #> dataclass.Field(default=FieldInfo(repr=False), repr=True, ...)\n+\n+    @pydantic_dc.dataclass\n+    class B(A):\n+        b: int = pydantic.Field(repr=False)\n+    ```\n+\n+    When passing `B` to the stdlib `@dataclass` decorator, it will look for fields in the parent classes\n+    and reuse them directly. When this contextmanager is active, `A` will be temporarily patched to be\n+    equivalent to:\n+\n+    ```python {test=\"skip\" lint=\"skip\"}\n+    @stdlib_dc.dataclass\n+    class A:\n+        a: int = stdlib_dc.field(default=Field(repr=False), repr=False)\n+    ```\n+\n+    !!! note\n+        This is only applied to the bases of `cls`, and not `cls` itself. The reason is that the Pydantic\n+        dataclass decorator \"owns\" `cls` (in the previous example, `B`). As such, we instead modify the fields\n+        directly (in the previous example, we simply do `setattr(B, 'b', as_dataclass_field(pydantic_field))`).\n+\n+    !!! note\n+        This approach is far from ideal, and can probably be the source of unwanted side effects/race conditions.\n+        The previous implemented approach was mutating the `__annotations__` dict of `cls`, which is no longer a\n+        safe operation in Python 3.14+, and resulted in unexpected behavior with field ordering anyway.\n+    \"\"\"\n+    # A list of two-tuples, the first element being a reference to the\n+    # dataclass fields dictionary, the second element being a mapping between\n+    # the field names that were modified, and their original `Field`:\n+    original_fields_list: list[tuple[DcFields, DcFields]] = []\n+\n+    for base in cls.__mro__[1:]:\n+        dc_fields: dict[str, dataclasses.Field[Any]] = base.__dict__.get('__dataclass_fields__', {})\n+        dc_fields_with_pydantic_field_defaults = {\n+            field_name: field\n+            for field_name, field in dc_fields.items()\n+            if isinstance(field.default, FieldInfo)\n+            # Only do the patching if one of the affected attributes is set:\n+            and (field.default.kw_only or field.default.repr is not True)\n+        }\n+        if dc_fields_with_pydantic_field_defaults:\n+            original_fields_list.append((dc_fields, dc_fields_with_pydantic_field_defaults))\n+            for field_name, field in dc_fields_with_pydantic_field_defaults.items():\n+                default = cast(FieldInfo, field.default)\n+                # `dataclasses.Field` isn't documented as working with `copy.copy()`.\n+                # It is a class with `__slots__`, so should work (and we hope for the best):\n+                new_dc_field = copy.copy(field)\n+                if default.kw_only:\n+                    new_dc_field.kw_only = True\n+                if default.repr is not True:\n+                    new_dc_field.repr = default.repr\n+                dc_fields[field_name] = new_dc_field",
      "comment": "The issue is that the dataclasses module is doing roughly:\r\n\r\n```python\r\nfields: dict[str, Field] = {}\r\n\r\nfor b in cls.__mro__[-1:0:-1]:\r\n    base_fields = getattr(b, '__dataclass_fields__', None)\r\n    if base_fields is not None:\r\n        for f_name, f in base_fields.items():\r\n            fields[f_name] = f\r\n\r\n# Then fetch the annotations of the class under construction and build fields for it\r\n```\r\n\r\nI thought about patching the whole `__dataclass_fields__` attribute directly, without mutating the original dict, but I don't know which one is best. I think we can revisit if we ever get issues.",
      "comment_id": 2212331202,
      "user": "Viicos",
      "created_at": "2025-07-17T05:46:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/12051#discussion_r2212331202"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12051,
      "file_path": "pydantic/_internal/_dataclasses.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,3 +208,105 @@ def is_stdlib_dataclass(cls: type[Any], /) -> TypeIs[type[StandardDataclass]]:\n         `True` if the class is a stdlib dataclass, `False` otherwise.\n     \"\"\"\n     return '__dataclass_fields__' in cls.__dict__ and not hasattr(cls, '__pydantic_validator__')\n+\n+\n+def as_dataclass_field(pydantic_field: FieldInfo) -> dataclasses.Field[Any]:\n+    field_args: dict[str, Any] = {'default': pydantic_field}\n+\n+    if sys.version_info >= (3, 10) and pydantic_field.kw_only:\n+        field_args['kw_only'] = True\n+\n+    if pydantic_field.repr is not True:\n+        field_args['repr'] = pydantic_field.repr\n+\n+    return dataclasses.field(**field_args)\n+\n+\n+DcFields: TypeAlias = dict[str, dataclasses.Field[Any]]\n+\n+\n+@contextmanager\n+def patch_base_fields(cls: type[Any]) -> Generator[None]:\n+    \"\"\"Temporarily patch the stdlib dataclasses bases of `cls` if the Pydantic `Field()` function is used.\n+\n+    When creating a Pydantic dataclass, it is possible to inherit from stdlib dataclasses, where\n+    the Pydantic `Field()` function is used. To create this Pydantic dataclass, we first apply\n+    the stdlib `@dataclass` decorator on it. During the construction of the stdlib dataclass,\n+    the `kw_only` and `repr` field arguments need to be understood by the stdlib *during* the\n+    dataclass construction. To do so, we temporarily patch the fields dictionary of the affected\n+    bases.\n+\n+    For instance, with the following example:\n+\n+    ```python {test=\"skip\" lint=\"skip\"}\n+    import dataclasses as stdlib_dc\n+\n+    import pydantic\n+    import pydantic.dataclasses as pydantic_dc\n+\n+    @stdlib_dc.dataclass\n+    class A:\n+        a: int = pydantic.Field(repr=False)\n+\n+    # Notice that the `repr` attribute of the dataclass field is `True`:\n+    A.__dataclass_fields__['a']\n+    #> dataclass.Field(default=FieldInfo(repr=False), repr=True, ...)\n+\n+    @pydantic_dc.dataclass\n+    class B(A):\n+        b: int = pydantic.Field(repr=False)\n+    ```\n+\n+    When passing `B` to the stdlib `@dataclass` decorator, it will look for fields in the parent classes\n+    and reuse them directly. When this contextmanager is active, `A` will be temporarily patched to be\n+    equivalent to:\n+\n+    ```python {test=\"skip\" lint=\"skip\"}\n+    @stdlib_dc.dataclass\n+    class A:\n+        a: int = stdlib_dc.field(default=Field(repr=False), repr=False)\n+    ```\n+\n+    !!! note\n+        This is only applied to the bases of `cls`, and not `cls` itself. The reason is that the Pydantic\n+        dataclass decorator \"owns\" `cls` (in the previous example, `B`). As such, we instead modify the fields\n+        directly (in the previous example, we simply do `setattr(B, 'b', as_dataclass_field(pydantic_field))`).\n+\n+    !!! note\n+        This approach is far from ideal, and can probably be the source of unwanted side effects/race conditions.\n+        The previous implemented approach was mutating the `__annotations__` dict of `cls`, which is no longer a\n+        safe operation in Python 3.14+, and resulted in unexpected behavior with field ordering anyway.",
      "comment": "Yeah I think if we ever get issues about this, we could wrap the mutation in a threading lock (similar to what I've initially tried to do in https://github.com/pydantic/pydantic/pull/11851). For this to be an issue, a user would have to dynamically create Pydantic dataclasses in a multi-threaded environment, and have them subclassing a stdlib dataclass with at least one field using the Pydantic's `Field()` function which is quite unlikely to happen.",
      "comment_id": 2212339644,
      "user": "Viicos",
      "created_at": "2025-07-17T05:53:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/12051#discussion_r2212339644"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11759,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 588,
      "side": "RIGHT",
      "diff_hunk": "@@ -587,6 +586,27 @@ def complete_model_class(\n             and `raise_errors=True`.\n     \"\"\"\n     typevars_map = get_model_typevars_map(cls)\n+\n+    if not cls.__pydantic_fields_complete__:",
      "comment": "Was the change required to implement the hook?\r\n\r\nIn both situations, we have inconsistent behavior but this can only be easily fixed if/when we remove support for accessing incomplete `model_fields` (well we can also make it so that `collect_model_fields()` \u2014 currently lenient to unresolvable type hints \u2014 also returns the `NameError`s, but this is quite ugly).\r\n\r\nWhen a model with unresolvable forward references is defined:\r\n\r\n- On `main`, we call `collect_model_fields()`, and then go through the `GenerateSchema` process, which will end up calling `rebuild_model_fields()`:\r\n\r\n    https://github.com/pydantic/pydantic/blob/625dd4284b266c17f0b70d282f237dd3ee7ec9f2/pydantic/_internal/_generate_schema.py#L741-L749\r\n\r\n- On this branch, we call `collect_model_fields()` and then call `rebuild_model_fields()` here.\r\n\r\n(In both cases, fields collection happens twice).",
      "comment_id": 2046466779,
      "user": "Viicos",
      "created_at": "2025-04-16T09:08:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/11759#discussion_r2046466779"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11759,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 588,
      "side": "RIGHT",
      "diff_hunk": "@@ -587,6 +586,27 @@ def complete_model_class(\n             and `raise_errors=True`.\n     \"\"\"\n     typevars_map = get_model_typevars_map(cls)\n+\n+    if not cls.__pydantic_fields_complete__:",
      "comment": "@Viicos Not strictly necessary to implement the hook, but I want to guarantee that when the hook is called (and the complete boolean is set), the fields are complete as well (see first two paragraphs of the PR description).\r\n\r\nThe __pydantic_init_subclass__ description states that model_fields will be present (although not necessarily complete), so I think we need to keep separataly collecting the model fields quietly and rebuilding them loudly. We could possibly also have collect_model_fields behave quietly but return an extra list of names that raised NameErrors.\r\n\r\nLet me know if you'd like to see a change here or if this is acceptable.",
      "comment_id": 2047206101,
      "user": "DouweM",
      "created_at": "2025-04-16T15:36:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/11759#discussion_r2047206101"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11759,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 588,
      "side": "RIGHT",
      "diff_hunk": "@@ -587,6 +586,27 @@ def complete_model_class(\n             and `raise_errors=True`.\n     \"\"\"\n     typevars_map = get_model_typevars_map(cls)\n+\n+    if not cls.__pydantic_fields_complete__:",
      "comment": "> We now do the same on `ModelMetaclass.__new__`, to make sure that subclasses of incomplete superclasses don't incorrectly get marked as complete.\r\n\r\nHum, did you have any example where this happened? When we create the model fields for a subclass, we copy the parent `FieldInfo` instances, keeping the `_complete` property.",
      "comment_id": 2047469054,
      "user": "Viicos",
      "created_at": "2025-04-16T18:12:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/11759#discussion_r2047469054"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11759,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 588,
      "side": "RIGHT",
      "diff_hunk": "@@ -587,6 +586,27 @@ def complete_model_class(\n             and `raise_errors=True`.\n     \"\"\"\n     typevars_map = get_model_typevars_map(cls)\n+\n+    if not cls.__pydantic_fields_complete__:",
      "comment": "@Viicos This is what I was describing in https://github.com/pydantic/pydantic/issues/11453#issuecomment-2803435274, where I added `assert cls.__pydantic_fields_complete__` at the end of `complete_model_class` (after `__pydantic_complete__ = True` and it failed in one test with a super and submodel. Rebuilding the fields solved the issue, because `SubModel` can resolve the `'SubModel'` ref to itself. You mentioned there that that was expected but not ideal, so I thought I'd fix it.",
      "comment_id": 2047478795,
      "user": "DouweM",
      "created_at": "2025-04-16T18:19:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/11759#discussion_r2047478795"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11759,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 562,
      "side": "RIGHT",
      "diff_hunk": "@@ -562,9 +559,9 @@ def set_model_fields(\n def complete_model_class(\n     cls: type[BaseModel],\n     config_wrapper: ConfigWrapper,\n+    ns_resolver: NsResolver,",
      "comment": "Let's update the order in the docstring and also where `complete_model_class()` is called.",
      "comment_id": 2048493997,
      "user": "Viicos",
      "created_at": "2025-04-17T08:30:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/11759#discussion_r2048493997"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11759,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 589,
      "side": "RIGHT",
      "diff_hunk": "@@ -587,6 +584,27 @@ def complete_model_class(\n             and `raise_errors=True`.\n     \"\"\"\n     typevars_map = get_model_typevars_map(cls)\n+\n+    if not cls.__pydantic_fields_complete__:\n+        # Rebuild the model fields so we can get the NameError for the specific undefined annotation",
      "comment": "```suggestion\r\n        # Note: when coming from `ModelMetaclass.__new__()`, this results in fields being built twice.\r\n        # We do so a second time here so that we can get the `NameError` for the specific undefined annotation.\r\n        # Alternatively, we could let `GenerateSchema()` raise the error, but there are cases where incomplete\r\n        # fields are inherited in `collect_model_fields()` and can actually have their annotation resolved in the\r\n        # generate schema process. As we want to avoid having `__pydantic_fields_complete__` set to `False`\r\n        # when `__pydantic_complete__` is `True`, we rebuild here:\r\n```",
      "comment_id": 2048511273,
      "user": "Viicos",
      "created_at": "2025-04-17T08:41:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/11759#discussion_r2048511273"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11991,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 263,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,7 +260,13 @@ def collect_model_fields(  # noqa: C901\n \n     # https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-object-in-python-3-9-and-older\n     # annotations is only used for finding fields in parent classes\n-    annotations = cls.__dict__.get('__annotations__', {})\n+    if sys.version_info >= (3, 14):",
      "comment": "I'll try to move this logic into a reusable function",
      "comment_id": 2190208996,
      "user": "Viicos",
      "created_at": "2025-07-07T14:01:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/11991#discussion_r2190208996"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11991,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,7 +260,13 @@ def collect_model_fields(  # noqa: C901\n \n     # https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-object-in-python-3-9-and-older\n     # annotations is only used for finding fields in parent classes\n-    annotations = cls.__dict__.get('__annotations__', {})\n+    if sys.version_info >= (3, 14):\n+        from annotationlib import Format, get_annotations\n+\n+        annotations = get_annotations(cls, format=Format.FORWARDREF)\n+    else:\n+        annotations = cls.__dict__.get('__annotations__', {})",
      "comment": "Think there's a call to `_typing_extra.safe_get_annotations(cls)` still to be added here?\r\n\r\n```suggestion\r\n    annotations = _typing_extra.safe_get_annotations(cls)\r\n```",
      "comment_id": 2197049949,
      "user": "davidhewitt",
      "created_at": "2025-07-10T08:57:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/11991#discussion_r2197049949"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 12008,
      "file_path": "pydantic/types.py",
      "line": 1532,
      "side": "RIGHT",
      "diff_hunk": "@@ -1530,7 +1530,7 @@ def __eq__(self, other: Any) -> bool:\n \n # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SECRET TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n ",
      "comment": "```suggestion\r\n\r\n# The `Secret` class being conceptually immutable, make the type variable covariant:\r\n```",
      "comment_id": 2177759350,
      "user": "Viicos",
      "created_at": "2025-07-01T14:28:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/12008#discussion_r2177759350"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11914,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,6 +282,20 @@ def collect_model_fields(  # noqa: C901\n             continue\n \n         assigned_value = getattr(cls, ann_name, PydanticUndefined)\n+        if (",
      "comment": "I think we can make this a bit more performant by skipping the checks if `assigned_values is PydanticUndefined`",
      "comment_id": 2143344719,
      "user": "DouweM",
      "created_at": "2025-06-12T18:00:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/11914#discussion_r2143344719"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/main.py",
      "line": 688,
      "side": "LEFT",
      "diff_hunk": "@@ -671,30 +671,6 @@ def model_validate_strings(\n         __tracebackhide__ = True\n         return cls.__pydantic_validator__.validate_strings(obj, strict=strict, context=context)\n \n-    @classmethod\n-    def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -> CoreSchema:",
      "comment": "I dont think this is a good idea. This is definitely being relied on. Its not internal and also documented for customizing the schema.",
      "comment_id": 1847732698,
      "user": "MarkusSintonen",
      "created_at": "2024-11-19T06:50:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1847732698"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/main.py",
      "line": 688,
      "side": "LEFT",
      "diff_hunk": "@@ -671,30 +671,6 @@ def model_validate_strings(\n         __tracebackhide__ = True\n         return cls.__pydantic_validator__.validate_strings(obj, strict=strict, context=context)\n \n-    @classmethod\n-    def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -> CoreSchema:",
      "comment": "But the perf improvement could be maybe done so that the `__get_pydantic_core_schema__` can not be overriden but instead coming from model_config (with similar args). Users then have option to migrate into that. Then if its defined in model config the perf improvements are not applied. (Didnt fully follow why its causing issues here but maybe possible)",
      "comment_id": 1847824205,
      "user": "MarkusSintonen",
      "created_at": "2024-11-19T07:52:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1847824205"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -66,6 +67,7 @@ def is_list_like_schema_with_items_schema(\n     return schema['type'] in _LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES\n \n \n+@lru_cache",
      "comment": "Should it be some weak cache like in generics side to avoid (dynamic cough cough) models being leaked.",
      "comment_id": 1847840249,
      "user": "MarkusSintonen",
      "created_at": "2024-11-19T07:56:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1847840249"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -66,6 +67,7 @@ def is_list_like_schema_with_items_schema(\n     return schema['type'] in _LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES\n \n \n+@lru_cache",
      "comment": "Yeah, I currently went with the default maxsize here (128) to avoid memory leaks, but this can still hold references to types/classes that should be gc'd, and with a small application where you have less than 128 referenceable types, this will never reach the limit and thus keep a reference to all of them.\r\n\r\nIt's a bit annoying that the `functools` cache utilities are limited in that aspect. It would be great if we could define our own cache key (currently hash) and customize the internal cache implementation (currently a dict). The `cachetools` 3rd party lib states [it supports](https://cachetools.readthedocs.io/en/latest/#cachetools.cached) using a `WeakValueDictionary`.\r\n\r\nOn the K8S file, with the cache impl, `get_type_ref` takes 30ms/~7s, without it takes 100ms/~7s, so I think we can live without it. Alternatively, we could a class level cached property on Pydantic models so that we only compute the reference once, I can take a look. ",
      "comment_id": 1848279501,
      "user": "Viicos",
      "created_at": "2024-11-19T12:33:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848279501"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/main.py",
      "line": 688,
      "side": "LEFT",
      "diff_hunk": "@@ -671,30 +671,6 @@ def model_validate_strings(\n         __tracebackhide__ = True\n         return cls.__pydantic_validator__.validate_strings(obj, strict=strict, context=context)\n \n-    @classmethod\n-    def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -> CoreSchema:",
      "comment": "To be clear, this doesn't remove support for `__get_pydantic_core_schema__`. This is still handled by the added `_generate_schema_from_get_schema_method` method.\r\n\r\nUsers are still free to implement `__get_pydantic_core_schema__` on Pydantic models, however we provide no guarantees (and never did, see the _breaking changes concerns_ section in my original post) it will work flawlessly. ",
      "comment_id": 1848282518,
      "user": "Viicos",
      "created_at": "2024-11-19T12:36:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848282518"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/main.py",
      "line": 688,
      "side": "LEFT",
      "diff_hunk": "@@ -671,30 +671,6 @@ def model_validate_strings(\n         __tracebackhide__ = True\n         return cls.__pydantic_validator__.validate_strings(obj, strict=strict, context=context)\n \n-    @classmethod\n-    def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -> CoreSchema:",
      "comment": "Ah interesting. Will give this another review then. Didn't realize users could still implement support. Nice!",
      "comment_id": 1848312831,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T12:56:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848312831"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 839,
      "side": "RIGHT",
      "diff_hunk": "@@ -861,6 +836,9 @@ def _get_first_two_args_or_any(self, obj: Any) -> tuple[Any, Any]:\n         return args[0], args[1]\n \n     def _generate_schema_inner(self, obj: Any) -> core_schema.CoreSchema:\n+        if _typing_extra.is_self(obj):\n+            obj = self._resolve_self_type(obj)\n+",
      "comment": "Just curious, why do we need to add this here now?",
      "comment_id": 1848385488,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T13:39:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848385488"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1724,
      "side": "RIGHT",
      "diff_hunk": "@@ -1734,6 +1712,16 @@ def _dataclass_schema(\n             if maybe_schema is not None:\n                 return maybe_schema\n \n+            schema = dataclass.__dict__.get('__pydantic_core_schema__')\n+            if schema is not None and not isinstance(schema, MockCoreSchema):\n+                schema = self._unpack_refs_defs(schema)\n+                ref = get_ref(schema)\n+                if ref:\n+                    self.defs.definitions[ref] = schema\n+                    return core_schema.definition_reference_schema(ref)\n+                else:\n+                    return schema",
      "comment": "Let's consolidate this shared pattern to avoid potential inconsistencies across models, dataclasses, etc",
      "comment_id": 1848387102,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T13:40:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848387102"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2037,
      "side": "RIGHT",
      "diff_hunk": "@@ -2032,11 +2020,12 @@ def _apply_annotations(\n         pydantic_js_annotation_functions: list[GetJsonSchemaFunction] = []\n \n         def inner_handler(obj: Any) -> CoreSchema:\n-            from_property = self._generate_schema_from_property(obj, source_type)\n-            if from_property is None:\n+            # TODO can obj be != source? if not, then just call self.generate_schema\n+            schema = self._generate_schema_from_get_schema_method(obj, source_type)\n+\n+            if schema is None:\n                 schema = self._generate_schema_inner(obj)",
      "comment": "Have you tried with the `self.generate_schema` approach? Seems like it would make more sense here...",
      "comment_id": 1848389752,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T13:41:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848389752"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 627,
      "side": "RIGHT",
      "diff_hunk": "@@ -627,6 +618,23 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n             if maybe_schema is not None:\n                 return maybe_schema\n \n+            schema = cls.__dict__.get('__pydantic_core_schema__')\n+            if (\n+                schema is not None\n+                and not isinstance(schema, MockCoreSchema)\n+                # Due to the way generic classes are built, it's possible that an invalid schema may be temporarily\n+                # set on generic classes. Probably we could resolve this to ensure that we get proper schema caching\n+                # for generics, but for simplicity for now, we just always rebuild if the class has a generic origin:\n+                and not cls.__pydantic_generic_metadata__['origin']\n+            ):",
      "comment": "@MarkusSintonen did a good job at intuitively extracting some of this logic as follows:\r\n\r\n```py\r\ndef get_existing_core_schema(obj: Any) -> core_schema.CoreSchema | None:\r\n    # Only use the cached value from this _exact_ class; we don't want one from a parent class\r\n    # This is why we check `cls.__dict__` and don't use `cls.__pydantic_core_schema__` or similar.\r\n    if (\r\n        hasattr(obj, '__dict__')\r\n        and (existing_schema := obj.__dict__.get('__pydantic_core_schema__')) is not None\r\n        and not isinstance(existing_schema, MockCoreSchema)\r\n    ):\r\n        return existing_schema\r\n    return None\r\n```\r\n\r\nMaybe we could eagerly pull changes like that into this PR, given that https://github.com/pydantic/pydantic/pull/10655 isn't quite ready to merge yet?",
      "comment_id": 1848393876,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T13:44:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848393876"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 873,
      "side": "LEFT",
      "diff_hunk": "@@ -783,25 +776,7 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n                     '`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.',\n                     PydanticDeprecatedSince20,\n                 )\n-            schema = core_schema.chain_schema([core_schema.with_info_plain_validator_function(v) for v in validators()])\n-        else:\n-            # we have no existing schema information on the property, exit early so that we can go generate a schema\n-            return None\n-\n-        schema = self._unpack_refs_defs(schema)\n-\n-        if is_function_with_inner_schema(schema):\n-            ref = schema['schema'].pop('ref', None)  # pyright: ignore[reportCallIssue, reportArgumentType]\n-            if ref:\n-                schema['ref'] = ref\n-        else:\n-            ref = get_ref(schema)",
      "comment": "Seems like we lost this logic - is this needed anywhere?",
      "comment_id": 1848394960,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T13:45:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848394960"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 839,
      "side": "RIGHT",
      "diff_hunk": "@@ -861,6 +836,9 @@ def _get_first_two_args_or_any(self, obj: Any) -> tuple[Any, Any]:\n         return args[0], args[1]\n \n     def _generate_schema_inner(self, obj: Any) -> core_schema.CoreSchema:\n+        if _typing_extra.is_self(obj):\n+            obj = self._resolve_self_type(obj)\n+",
      "comment": "This was present inside `_generate_schema_from_property` before, but actually I think it should come first. Whenever you call `generate_schema`, if we pass in `typing(_extensions).Self`, we need to resolve the type before trying to build the schema.\r\n\r\nI moved it at the top of `GenerateSchema.generate_schema`",
      "comment_id": 1848502818,
      "user": "Viicos",
      "created_at": "2024-11-19T14:47:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848502818"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 627,
      "side": "RIGHT",
      "diff_hunk": "@@ -627,6 +618,23 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n             if maybe_schema is not None:\n                 return maybe_schema\n \n+            schema = cls.__dict__.get('__pydantic_core_schema__')\n+            if (\n+                schema is not None\n+                and not isinstance(schema, MockCoreSchema)\n+                # Due to the way generic classes are built, it's possible that an invalid schema may be temporarily\n+                # set on generic classes. Probably we could resolve this to ensure that we get proper schema caching\n+                # for generics, but for simplicity for now, we just always rebuild if the class has a generic origin:\n+                and not cls.__pydantic_generic_metadata__['origin']\n+            ):",
      "comment": "I also need to check that `cls.__pydantic_generic_metadata__['origin']` is `None` for Pydantic models, so maybe it's best to keep the (small) duplication of code here.",
      "comment_id": 1848522677,
      "user": "Viicos",
      "created_at": "2024-11-19T14:58:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848522677"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1724,
      "side": "RIGHT",
      "diff_hunk": "@@ -1734,6 +1712,16 @@ def _dataclass_schema(\n             if maybe_schema is not None:\n                 return maybe_schema\n \n+            schema = dataclass.__dict__.get('__pydantic_core_schema__')\n+            if schema is not None and not isinstance(schema, MockCoreSchema):\n+                schema = self._unpack_refs_defs(schema)\n+                ref = get_ref(schema)\n+                if ref:\n+                    self.defs.definitions[ref] = schema\n+                    return core_schema.definition_reference_schema(ref)\n+                else:\n+                    return schema",
      "comment": "This certainly should be in a shared pattern, but seems like https://github.com/pydantic/pydantic/pull/10655 does something similar already. Maybe it's best to have it implemented there when rebasing?",
      "comment_id": 1848525378,
      "user": "Viicos",
      "created_at": "2024-11-19T14:59:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848525378"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1724,
      "side": "RIGHT",
      "diff_hunk": "@@ -1734,6 +1712,16 @@ def _dataclass_schema(\n             if maybe_schema is not None:\n                 return maybe_schema\n \n+            schema = dataclass.__dict__.get('__pydantic_core_schema__')\n+            if schema is not None and not isinstance(schema, MockCoreSchema):\n+                schema = self._unpack_refs_defs(schema)\n+                ref = get_ref(schema)\n+                if ref:\n+                    self.defs.definitions[ref] = schema\n+                    return core_schema.definition_reference_schema(ref)\n+                else:\n+                    return schema",
      "comment": "Hmm I'd rather have it shared now, then that refactor should look more simple in the long run? That PR is already big enough \ud83d\ude05 ",
      "comment_id": 1848547791,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T15:12:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848547791"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2037,
      "side": "RIGHT",
      "diff_hunk": "@@ -2032,11 +2020,12 @@ def _apply_annotations(\n         pydantic_js_annotation_functions: list[GetJsonSchemaFunction] = []\n \n         def inner_handler(obj: Any) -> CoreSchema:\n-            from_property = self._generate_schema_from_property(obj, source_type)\n-            if from_property is None:\n+            # TODO can obj be != source? if not, then just call self.generate_schema\n+            schema = self._generate_schema_from_get_schema_method(obj, source_type)\n+\n+            if schema is None:\n                 schema = self._generate_schema_inner(obj)",
      "comment": "Turns out there's some cases where `obj != source_type` :/",
      "comment_id": 1848712466,
      "user": "Viicos",
      "created_at": "2024-11-19T16:47:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848712466"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -66,6 +67,7 @@ def is_list_like_schema_with_items_schema(\n     return schema['type'] in _LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES\n \n \n+@lru_cache",
      "comment": "It could be maybe simple as:\r\n\r\n```python\r\nclass _TypeRefCache(WeakKeyDictionary):\r\n    def __setitem__(self, key: type[Any], value: Any) -> None:\r\n        size = len(self)\r\n        if size >= 1000:\r\n            for remove_key in [*self.keys()][: size // 10]:  # Remove 10% of the cache (FIFO)\r\n                del self[remove_key]\r\n        super().__setitem__(key, value)\r\n\r\n\r\n_TYPE_REF_CACHE = _TypeRefCache()\r\n\r\n\r\ndef get_type_ref(type_: type[Any], args_override: tuple[type[Any], ...] | None = None) -> str:\r\n    \"\"\"....\"\"\"\r\n    if isinstance(type_, type) and not args_override:\r\n        if (cached := _TYPE_REF_CACHE.get(type_)) is not None:\r\n            return cached\r\n        type_ref = _get_type_ref(type_, args_override)\r\n        _TYPE_REF_CACHE[type_] = type_ref\r\n        return type_ref\r\n    else:\r\n        return _get_type_ref(type_, args_override)\r\n\r\n\r\ndef _get_type_ref(type_: type[Any], args_override: tuple[type[Any], ...] | None = None) -> str:\r\n    ... rest of stuff\r\n```",
      "comment_id": 1848837011,
      "user": "MarkusSintonen",
      "created_at": "2024-11-19T18:15:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848837011"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -66,6 +67,7 @@ def is_list_like_schema_with_items_schema(\n     return schema['type'] in _LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES\n \n \n+@lru_cache",
      "comment": "A better API would be for each type to compute the ref, as currently `get_type_ref` is doing useless work as it needs to account for type alias types, dataclasses, etc. Instead, we should be able to decouple everything from this function. Postponing for now.",
      "comment_id": 1848965033,
      "user": "Viicos",
      "created_at": "2024-11-19T19:42:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1848965033"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 839,
      "side": "RIGHT",
      "diff_hunk": "@@ -861,6 +836,9 @@ def _get_first_two_args_or_any(self, obj: Any) -> tuple[Any, Any]:\n         return args[0], args[1]\n \n     def _generate_schema_inner(self, obj: Any) -> core_schema.CoreSchema:\n+        if _typing_extra.is_self(obj):\n+            obj = self._resolve_self_type(obj)\n+",
      "comment": "Oops, seems like moving it breaks things, it needs to be right after the `__get_pydantic_core_schema__` check, so I'll leave it here",
      "comment_id": 1850672364,
      "user": "Viicos",
      "created_at": "2024-11-20T16:51:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1850672364"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/main.py",
      "line": 697,
      "side": "RIGHT",
      "diff_hunk": "@@ -687,23 +687,17 @@ def model_validate_strings(\n \n     @classmethod\n     def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -> CoreSchema:\n-        \"\"\"Hook into generating the model's CoreSchema.\n-\n-        Args:\n-            source: The class we are generating a schema for.\n-                This will generally be the same as the `cls` argument if this is a classmethod.\n-            handler: A callable that calls into Pydantic's internal CoreSchema generation logic.\n-\n-        Returns:\n-            A `pydantic-core` `CoreSchema`.\n-        \"\"\"\n-        # Only use the cached value from this _exact_ class; we don't want one from a parent class\n-        # This is why we check `cls.__dict__` and don't use `cls.__pydantic_core_schema__` or similar.\n+        warnings.warn(\n+            'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n+            '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n+            '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n+            'side effects.',\n+            PydanticDeprecatedSince211,\n+            stacklevel=2,\n+        )",
      "comment": "As discussed in person, let's add a comment that this warning is only omitted when calling super. I think we need to make it more clear what the consequences of this deprecation are.",
      "comment_id": 1914654183,
      "user": "sydney-runkle",
      "created_at": "2025-01-14T11:20:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1914654183"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 873,
      "side": "LEFT",
      "diff_hunk": "@@ -783,25 +776,7 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n                     '`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.',\n                     PydanticDeprecatedSince20,\n                 )\n-            schema = core_schema.chain_schema([core_schema.with_info_plain_validator_function(v) for v in validators()])\n-        else:\n-            # we have no existing schema information on the property, exit early so that we can go generate a schema\n-            return None\n-\n-        schema = self._unpack_refs_defs(schema)\n-\n-        if is_function_with_inner_schema(schema):\n-            ref = schema['schema'].pop('ref', None)  # pyright: ignore[reportCallIssue, reportArgumentType]\n-            if ref:\n-                schema['ref'] = ref\n-        else:\n-            ref = get_ref(schema)",
      "comment": "Would it make sense to break this change out into a different PR?",
      "comment_id": 1914860077,
      "user": "sydney-runkle",
      "created_at": "2025-01-14T13:58:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1914860077"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1830,
      "side": "RIGHT",
      "diff_hunk": "@@ -1817,6 +1819,16 @@ def _dataclass_schema(\n             if maybe_schema is not None:\n                 return maybe_schema\n \n+            schema = dataclass.__dict__.get('__pydantic_core_schema__')\n+            if schema is not None and not isinstance(schema, MockCoreSchema):\n+                if schema['type'] == 'definitions':\n+                    schema = self.defs.unpack_definitions(schema)\n+                ref = get_ref(schema)\n+                if ref:\n+                    return self.defs.create_definition_reference_schema(schema)\n+                else:\n+                    return schema",
      "comment": "Does it make sense to do this in a different PR as well?",
      "comment_id": 1914864884,
      "user": "sydney-runkle",
      "created_at": "2025-01-14T14:01:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1914864884"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 873,
      "side": "LEFT",
      "diff_hunk": "@@ -783,25 +776,7 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n                     '`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.',\n                     PydanticDeprecatedSince20,\n                 )\n-            schema = core_schema.chain_schema([core_schema.with_info_plain_validator_function(v) for v in validators()])\n-        else:\n-            # we have no existing schema information on the property, exit early so that we can go generate a schema\n-            return None\n-\n-        schema = self._unpack_refs_defs(schema)\n-\n-        if is_function_with_inner_schema(schema):\n-            ref = schema['schema'].pop('ref', None)  # pyright: ignore[reportCallIssue, reportArgumentType]\n-            if ref:\n-                schema['ref'] = ref\n-        else:\n-            ref = get_ref(schema)",
      "comment": "iirc (but I'm not sure), I was able to remove it only thanks to the other changes. This won't clutter the git diff though, because it's just a removal. Probably by having a proper commit description when merging, I can add a note about this?",
      "comment_id": 1916202889,
      "user": "Viicos",
      "created_at": "2025-01-15T09:13:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1916202889"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10863,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1830,
      "side": "RIGHT",
      "diff_hunk": "@@ -1817,6 +1819,16 @@ def _dataclass_schema(\n             if maybe_schema is not None:\n                 return maybe_schema\n \n+            schema = dataclass.__dict__.get('__pydantic_core_schema__')\n+            if schema is not None and not isinstance(schema, MockCoreSchema):\n+                if schema['type'] == 'definitions':\n+                    schema = self.defs.unpack_definitions(schema)\n+                ref = get_ref(schema)\n+                if ref:\n+                    return self.defs.create_definition_reference_schema(schema)\n+                else:\n+                    return schema",
      "comment": "It has to be done together with the rest of the changes iirc, because in `pydantic/_internal/_dataclasses.py` we also have the `from_dunder_get_core_schema` logic which was removed",
      "comment_id": 1916214847,
      "user": "Viicos",
      "created_at": "2025-01-15T09:20:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10863#discussion_r1916214847"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11941,
      "file_path": "pydantic/types.py",
      "line": 3108,
      "side": "RIGHT",
      "diff_hunk": "@@ -3093,10 +3095,23 @@ def _convert_schema(self, original_schema: core_schema.CoreSchema) -> core_schem\n             if metadata is not None:\n                 tag = metadata.get('pydantic_internal_union_tag_key') or tag\n             if tag is None:\n-                raise PydanticUserError(\n-                    f'`Tag` not provided for choice {choice} used with `Discriminator`',\n-                    code='callable-discriminator-no-tag',\n-                )\n+                # `handler` is None when this method is called from `apply_discriminator()` (deferred discriminators)\n+                if handler is not None and choice['type'] == 'definition-ref':\n+                    # If choice was built from a PEP 695 type alias, try to resolve the def:\n+                    try:\n+                        choice = handler.resolve_ref_schema(choice)\n+                    except LookupError:\n+                        pass\n+                    else:\n+                        metadata = cast('CoreMetadata | None', choice.get('metadata'))\n+                        if metadata is not None:\n+                            tag = metadata.get('pydantic_internal_union_tag_key') or tag",
      "comment": "`tag` is known to be `None` here so we don't need the `or tag`",
      "comment_id": 2143351247,
      "user": "DouweM",
      "created_at": "2025-06-12T18:05:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/11941#discussion_r2143351247"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11902,
      "file_path": "pydantic/fields.py",
      "line": 598,
      "side": "RIGHT",
      "diff_hunk": "@@ -588,6 +588,15 @@ def _collect_metadata(kwargs: dict[str, Any]) -> list[Any]:\n             metadata.append(_fields.pydantic_general_metadata(**general_metadata))\n         return metadata\n \n+    def _copy(self) -> Self:\n+        copied = copy(self)\n+        for attr_name in ('metadata', '_attributes_set', '_qualifiers'):\n+            # Apply \"deep-copy\" behavior on collections attributes:\n+            value = getattr(copied, attr_name).copy()\n+            setattr(copied, attr_name, value)\n+\n+        return copied",
      "comment": "We can't define a custom `__copy__()`, because I couldn't find a way to delegate to `copy.copy()` and then apply the special case for `metadata`, `_attributes_set` and `_qualifiers`.\r\n\r\nThe following could still be done:\r\n\r\n```python\r\n    def __copy__(self) -> Self:\r\n        cls = type(self)\r\n        copied = cls()\r\n        for attr_name in cls.__slots__:\r\n            value = getattr(self, attr_name)\r\n            if attr_name in ('metadata', '_attributes_set', '_qualifiers'):\r\n                # Apply \"deep-copy\" behavior on collections attributes:\r\n                value = value.copy()\r\n            setattr(copied, attr_name, value)\r\n\r\n        return copied\r\n```\r\n\r\nBut this blows up on libraries (FastAPI/SQLModel) subclassing `FieldInfo` (not the first time this is causing issues..) as we don't know which extra attributes are defined on these classes.",
      "comment_id": 2103354317,
      "user": "Viicos",
      "created_at": "2025-05-22T20:31:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/11902#discussion_r2103354317"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11834,
      "file_path": "pydantic/main.py",
      "line": 217,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,13 +211,17 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n     __pydantic_computed_fields__: ClassVar[Dict[str, ComputedFieldInfo]]  # noqa: UP006\n     \"\"\"A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\"\"\"\n \n-    __pydantic_extra__: dict[str, Any] | None = _model_construction.NoInitField(init=False)\n+    __pydantic_extra__: Dict[str, Any] | None = _model_construction.NoInitField(\n+        init=False\n+    )\n     \"\"\"A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra] is set to `'allow'`.\"\"\"",
      "comment": "```suggestion\r\n    __pydantic_extra__: Dict[str, Any] | None = _model_construction.NoInitField(init=False)  # noqa: UP006\r\n    \"\"\"A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra] is set to `'allow'`.\"\"\"\r\n```",
      "comment_id": 2072029669,
      "user": "jinnovation",
      "created_at": "2025-05-02T18:58:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/11834#discussion_r2072029669"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11834,
      "file_path": "pydantic/main.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,13 +211,17 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n     __pydantic_computed_fields__: ClassVar[Dict[str, ComputedFieldInfo]]  # noqa: UP006\n     \"\"\"A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\"\"\"\n \n-    __pydantic_extra__: dict[str, Any] | None = _model_construction.NoInitField(init=False)\n+    __pydantic_extra__: Dict[str, Any] | None = _model_construction.NoInitField(\n+        init=False\n+    )\n     \"\"\"A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra] is set to `'allow'`.\"\"\"\n \n     __pydantic_fields_set__: set[str] = _model_construction.NoInitField(init=False)\n     \"\"\"The names of fields explicitly set during instantiation.\"\"\"\n \n-    __pydantic_private__: dict[str, Any] | None = _model_construction.NoInitField(init=False)\n+    __pydantic_private__: Dict[str, Any] | None = _model_construction.NoInitField(\n+        init=False\n+    )",
      "comment": "```suggestion\r\n    __pydantic_private__: Dict[str, Any] | None = _model_construction.NoInitField(init=False)  # noqa: UP006\r\n```",
      "comment_id": 2072029841,
      "user": "jinnovation",
      "created_at": "2025-05-02T18:59:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/11834#discussion_r2072029841"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11803,
      "file_path": "tests/test_private_attributes.py",
      "line": 582,
      "side": "RIGHT",
      "diff_hunk": "@@ -577,3 +577,24 @@ class Model(BaseModel):\n     # Checks below are just to ensure that everything is the same as in `test_private_attr_set_name`\n     # The main check is that model class definition above doesn't crash\n     assert Model()._private_attr == 2\n+\n+\n+def test_models_contain_consistent_private_attributes_type(create_module):",
      "comment": "The test written in this way did not work:\r\n```python\r\ndef test_models_contain_consistent_private_attributes_type(create_module):\r\n    @create_module\r\n    def module():\r\n        import enum\r\n\r\n        from pydantic import BaseModel\r\n\r\n        class Table(enum.Enum):\r\n            TABLE_1 = enum.auto()\r\n\r\n        class FirstModel(BaseModel):\r\n            _table: enum.Enum = Table\r\n\r\n        class SecondModel(BaseModel):\r\n            _table: enum.Enum = Table\r\n\r\n    assert module.FirstModel._table == module.SecondModel._table\r\n```\r\nIn other words, the error could not be reproduced.",
      "comment_id": 2063706095,
      "user": "karta9821",
      "created_at": "2025-04-28T13:51:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/11803#discussion_r2063706095"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11803,
      "file_path": "tests/test_private_attributes.py",
      "line": 582,
      "side": "RIGHT",
      "diff_hunk": "@@ -577,3 +577,24 @@ class Model(BaseModel):\n     # Checks below are just to ensure that everything is the same as in `test_private_attr_set_name`\n     # The main check is that model class definition above doesn't crash\n     assert Model()._private_attr == 2\n+\n+\n+def test_models_contain_consistent_private_attributes_type(create_module):",
      "comment": "The test you added is unrelated to your change, which makes me believe your contribution is AI generated. If so, please state it explicitly in the PR description.\r\n\r\nYou can replace by the following test:\r\n\r\n```python\r\ndef test_private_attribute_not_skipped_during_ns_inspection() -> None:\r\n    # It is important for the enum name to start with the class name\r\n    # (it previously caused issues as we were comparing qualnames without\r\n    # taking this into account):\r\n    class Fullname(str, Enum):\r\n        pass\r\n\r\n    class Full(BaseModel):\r\n        _priv: object = Fullname\r\n\r\n    assert isinstance(Full._priv, ModelPrivateAttr)\r\n```",
      "comment_id": 2063956365,
      "user": "Viicos",
      "created_at": "2025-04-28T15:40:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/11803#discussion_r2063956365"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11803,
      "file_path": "tests/test_private_attributes.py",
      "line": 582,
      "side": "RIGHT",
      "diff_hunk": "@@ -577,3 +577,24 @@ class Model(BaseModel):\n     # Checks below are just to ensure that everything is the same as in `test_private_attr_set_name`\n     # The main check is that model class definition above doesn't crash\n     assert Model()._private_attr == 2\n+\n+\n+def test_models_contain_consistent_private_attributes_type(create_module):",
      "comment": "It wasn\u2019t generated by AI \u2014 I just didn\u2019t really know how to approach writing this test. I wanted to create a case as close as possible to the one in the issues. \ud83e\udd72 \r\n\r\nThanks for the example of how to write this test differently.\r\n",
      "comment_id": 2063999031,
      "user": "karta9821",
      "created_at": "2025-04-28T16:01:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/11803#discussion_r2063999031"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11803,
      "file_path": "tests/test_private_attributes.py",
      "line": 582,
      "side": "RIGHT",
      "diff_hunk": "@@ -577,3 +577,24 @@ class Model(BaseModel):\n     # Checks below are just to ensure that everything is the same as in `test_private_attr_set_name`\n     # The main check is that model class definition above doesn't crash\n     assert Model()._private_attr == 2\n+\n+\n+def test_models_contain_consistent_private_attributes_type(create_module):",
      "comment": "Now I finally understand where the problem in this test lies.",
      "comment_id": 2064009190,
      "user": "karta9821",
      "created_at": "2025-04-28T16:07:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/11803#discussion_r2064009190"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11803,
      "file_path": "tests/test_private_attributes.py",
      "line": 583,
      "side": "RIGHT",
      "diff_hunk": "@@ -577,3 +578,16 @@ class Model(BaseModel):\n     # Checks below are just to ensure that everything is the same as in `test_private_attr_set_name`\n     # The main check is that model class definition above doesn't crash\n     assert Model()._private_attr == 2\n+\n+\n+def test_private_attribute_not_skipped_during_ns_inspection():",
      "comment": "```suggestion\r\ndef test_private_attribute_not_skipped_during_ns_inspection() -> None:\r\n```",
      "comment_id": 2064348711,
      "user": "Viicos",
      "created_at": "2025-04-28T19:08:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/11803#discussion_r2064348711"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11831,
      "file_path": ".github/actions/people/people.py",
      "line": 364,
      "side": "RIGHT",
      "diff_hunk": "@@ -302,8 +359,21 @@ def get_graphql_response(\n     *,\n     settings: Settings,\n     query: str,\n-    after: Union[str, None] = None,\n+    after: str | None = None,\n ) -> dict[str, Any]:\n+    \"\"\"Make a GraphQL request to GitHub API and handle errors.",
      "comment": "```suggestion\r\n    \"\"\"Make a GraphQL request to GitHub API.\r\n```",
      "comment_id": 2071728456,
      "user": "Viicos",
      "created_at": "2025-05-02T14:49:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/11831#discussion_r2071728456"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11831,
      "file_path": ".github/actions/people/people.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -302,8 +359,21 @@ def get_graphql_response(\n     *,\n     settings: Settings,\n     query: str,\n-    after: Union[str, None] = None,\n+    after: str | None = None,\n ) -> dict[str, Any]:\n+    \"\"\"Make a GraphQL request to GitHub API and handle errors.\n+\n+    Args:\n+        settings: Configuration settings including API token\n+        query: GraphQL query string\n+        after: Cursor for pagination, if any\n+\n+    Returns:\n+        dict[str, Any]: Response data from GitHub API",
      "comment": "No need to include the type annotation (same for the whole file).",
      "comment_id": 2071728911,
      "user": "Viicos",
      "created_at": "2025-05-02T14:50:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/11831#discussion_r2071728911"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11733,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1540,
      "side": "LEFT",
      "diff_hunk": "@@ -1537,7 +1415,8 @@ def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -> core_schema.Co\n                         and field_name in field_docstrings\n                     ):\n                         field_info.description = field_docstrings[field_name]\n-                    self._apply_field_title_generator_to_field_info(self._config_wrapper, field_info, field_name)",
      "comment": "This was actually called twice, here in the `_typed_dict_schema()` and later in `_common_field_schema()`.",
      "comment_id": 2039029541,
      "user": "Viicos",
      "created_at": "2025-04-11T08:08:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/11733#discussion_r2039029541"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11733,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,13 +69,136 @@ def __init__(self, metadata: Any):\n     return _PydanticGeneralMetadata  # type: ignore\n \n \n+def _check_protected_namespaces(\n+    protected_namespaces: tuple[str | Pattern[str], ...],\n+    ann_name: str,\n+    bases: tuple[type[Any], ...],\n+    cls_name: str,\n+) -> None:\n+    BaseModel = import_cached_base_model()\n+\n+    for protected_namespace in protected_namespaces:\n+        ns_violation = False\n+        if isinstance(protected_namespace, Pattern):\n+            ns_violation = protected_namespace.match(ann_name) is not None\n+        elif isinstance(protected_namespace, str):\n+            ns_violation = ann_name.startswith(protected_namespace)\n+\n+        if ns_violation:\n+            for b in bases:\n+                if hasattr(b, ann_name):\n+                    if not (issubclass(b, BaseModel) and ann_name in getattr(b, '__pydantic_fields__', {})):\n+                        raise ValueError(\n+                            f'Field {ann_name!r} conflicts with member {getattr(b, ann_name)}'\n+                            f' of protected namespace {protected_namespace!r}.'\n+                        )\n+            else:\n+                valid_namespaces: list[str] = []\n+                for pn in protected_namespaces:\n+                    if isinstance(pn, Pattern):\n+                        if not pn.match(ann_name):\n+                            valid_namespaces.append(f're.compile({pn.pattern!r})')\n+                    else:\n+                        if not ann_name.startswith(pn):\n+                            valid_namespaces.append(f\"'{pn}'\")\n+\n+                valid_namespaces_str = f'({\", \".join(valid_namespaces)}{\",)\" if len(valid_namespaces) == 1 else \")\"}'",
      "comment": "Double-check the formatting logic for valid_namespaces_str to ensure it produces the intended output, especially when exactly one valid namespace is present.\n```suggestion\n                valid_namespaces_str = (\n                    f\"('{valid_namespaces[0]}')\" if len(valid_namespaces) == 1 else f\"({', '.join(valid_namespaces)})\"\n                )\n```",
      "comment_id": 2060908159,
      "user": "Copilot",
      "created_at": "2025-04-25T21:36:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/11733#discussion_r2060908159"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11733,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,13 +69,136 @@ def __init__(self, metadata: Any):\n     return _PydanticGeneralMetadata  # type: ignore\n \n \n+def _check_protected_namespaces(\n+    protected_namespaces: tuple[str | Pattern[str], ...],\n+    ann_name: str,\n+    bases: tuple[type[Any], ...],\n+    cls_name: str,\n+) -> None:\n+    BaseModel = import_cached_base_model()\n+\n+    for protected_namespace in protected_namespaces:\n+        ns_violation = False\n+        if isinstance(protected_namespace, Pattern):\n+            ns_violation = protected_namespace.match(ann_name) is not None\n+        elif isinstance(protected_namespace, str):\n+            ns_violation = ann_name.startswith(protected_namespace)\n+\n+        if ns_violation:\n+            for b in bases:\n+                if hasattr(b, ann_name):\n+                    if not (issubclass(b, BaseModel) and ann_name in getattr(b, '__pydantic_fields__', {})):\n+                        raise ValueError(\n+                            f'Field {ann_name!r} conflicts with member {getattr(b, ann_name)}'\n+                            f' of protected namespace {protected_namespace!r}.'\n+                        )\n+            else:\n+                valid_namespaces: list[str] = []\n+                for pn in protected_namespaces:\n+                    if isinstance(pn, Pattern):\n+                        if not pn.match(ann_name):\n+                            valid_namespaces.append(f're.compile({pn.pattern!r})')\n+                    else:\n+                        if not ann_name.startswith(pn):\n+                            valid_namespaces.append(f\"'{pn}'\")\n+\n+                valid_namespaces_str = f'({\", \".join(valid_namespaces)}{\",)\" if len(valid_namespaces) == 1 else \")\"}'",
      "comment": "I don't think this is right lol, I get what it's trying to do to make the 1 vs multi case clearer, but it seems to insert extra single quotes around a single value....",
      "comment_id": 2060909864,
      "user": "DouweM",
      "created_at": "2025-04-25T21:39:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/11733#discussion_r2060909864"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11714,
      "file_path": "pydantic/main.py",
      "line": 1765,
      "side": "LEFT",
      "diff_hunk": "@@ -1762,7 +1756,7 @@ def create_model(  # noqa: C901\n         namespace.update(__validators__)\n     namespace.update(fields)\n     if __config__:\n-        namespace['model_config'] = _config.ConfigWrapper(__config__).config_dict",
      "comment": "It is done already in the metaclass, taking into account the config from the bases:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/876bf76f34f9ab313923a3428a4d4aaf00144f43/pydantic/_internal/_model_construction.py#L107-L111",
      "comment_id": 2033219576,
      "user": "Viicos",
      "created_at": "2025-04-08T13:39:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/11714#discussion_r2033219576"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11769,
      "file_path": "tests/test_dataclasses.py",
      "line": 2433,
      "side": "RIGHT",
      "diff_hunk": "@@ -2430,6 +2430,23 @@ class Model:\n     assert dc.b == 'bar'\n \n \n+# Must be defined at the module level to be pickable:",
      "comment": "```suggestion\r\n# Must be defined at the module level to be picklable:\r\n```",
      "comment_id": 2060874390,
      "user": "DouweM",
      "created_at": "2025-04-25T20:56:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/11769#discussion_r2060874390"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11769,
      "file_path": "pydantic/dataclasses.py",
      "line": 280,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,6 +265,35 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             **kwargs,\n         )\n \n+        if config_wrapper.validate_assignment:\n+\n+            @functools.wraps(cls.__setattr__)\n+            def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n+                type(instance).__pydantic_validator__.validate_assignment(instance, field, value)\n+\n+            cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n+\n+            if slots and not hasattr(cls, '__setstate__'):\n+                # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n+                # `__setattr__()` to reconstruct the dataclass. However, the custom\n+                # `__setattr__()` set above relies on `validate_assignment()`, which\n+                # in turn excepts all the field values to be already present on the",
      "comment": "```suggestion\r\n                # in turn expects all the field values to be already present on the\r\n```",
      "comment_id": 2060875996,
      "user": "DouweM",
      "created_at": "2025-04-25T20:58:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/11769#discussion_r2060875996"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11769,
      "file_path": "pydantic/dataclasses.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,6 +265,35 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             **kwargs,\n         )\n \n+        if config_wrapper.validate_assignment:\n+\n+            @functools.wraps(cls.__setattr__)\n+            def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n+                type(instance).__pydantic_validator__.validate_assignment(instance, field, value)\n+\n+            cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n+\n+            if slots and not hasattr(cls, '__setstate__'):\n+                # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n+                # `__setattr__()` to reconstruct the dataclass. However, the custom\n+                # `__setattr__()` set above relies on `validate_assignment()`, which\n+                # in turn excepts all the field values to be already present on the\n+                # instance, resulting in attribute errors.\n+                # As such, we make use of `object.__setattr__()` instead.\n+                # Note that we do so only if `__setstate__()` isn't already set (this is the\n+                # case if on top of `slots`, `frozen` is used).\n+\n+                # Taken from `dataclasses._dataclass_get/setstate()`:\n+                def _dataclass_getstate(self: Any) -> list[Any]:\n+                    return [getattr(self, f.name) for f in dataclasses.fields(self)]",
      "comment": "Could we use a `dict` here instead of relying on `dataclasses.fields` being stable, which it may not be if the pickle and unpickle happen on different versions of the code?\r\n\r\nI haven't looked into this deeply, but https://stackoverflow.com/questions/76143398/pickle-ignores-getstate-on-frozen-dataclasses-with-slots suggests it's fine.",
      "comment_id": 2060879435,
      "user": "DouweM",
      "created_at": "2025-04-25T21:02:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/11769#discussion_r2060879435"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11769,
      "file_path": "pydantic/dataclasses.py",
      "line": 284,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,6 +265,35 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             **kwargs,\n         )\n \n+        if config_wrapper.validate_assignment:\n+\n+            @functools.wraps(cls.__setattr__)\n+            def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n+                type(instance).__pydantic_validator__.validate_assignment(instance, field, value)\n+\n+            cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n+\n+            if slots and not hasattr(cls, '__setstate__'):\n+                # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n+                # `__setattr__()` to reconstruct the dataclass. However, the custom\n+                # `__setattr__()` set above relies on `validate_assignment()`, which\n+                # in turn excepts all the field values to be already present on the\n+                # instance, resulting in attribute errors.\n+                # As such, we make use of `object.__setattr__()` instead.\n+                # Note that we do so only if `__setstate__()` isn't already set (this is the\n+                # case if on top of `slots`, `frozen` is used).",
      "comment": "Is it required to skip this when frozen is set on top of slots? https://github.com/python/cpython/pull/104041#issue-1690829773 suggests a bug was fixed hereabouts.",
      "comment_id": 2060879953,
      "user": "DouweM",
      "created_at": "2025-04-25T21:03:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/11769#discussion_r2060879953"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11769,
      "file_path": "pydantic/dataclasses.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,6 +265,35 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             **kwargs,\n         )\n \n+        if config_wrapper.validate_assignment:\n+\n+            @functools.wraps(cls.__setattr__)\n+            def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n+                type(instance).__pydantic_validator__.validate_assignment(instance, field, value)\n+\n+            cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n+\n+            if slots and not hasattr(cls, '__setstate__'):\n+                # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n+                # `__setattr__()` to reconstruct the dataclass. However, the custom\n+                # `__setattr__()` set above relies on `validate_assignment()`, which\n+                # in turn excepts all the field values to be already present on the\n+                # instance, resulting in attribute errors.\n+                # As such, we make use of `object.__setattr__()` instead.\n+                # Note that we do so only if `__setstate__()` isn't already set (this is the\n+                # case if on top of `slots`, `frozen` is used).\n+\n+                # Taken from `dataclasses._dataclass_get/setstate()`:\n+                def _dataclass_getstate(self: Any) -> list[Any]:\n+                    return [getattr(self, f.name) for f in dataclasses.fields(self)]\n+\n+                def _dataclass_setstate(self: Any, state: list[Any]) -> None:\n+                    for field, value in zip(dataclasses.fields(self), state):\n+                        object.__setattr__(self, field.name, value)",
      "comment": "Pickling is used with the assumption that the data is trusted already (if you need validation to be performed, then you have bigger problems as you are most likely vulnerable to arbitrary code execution). See `BaseModel.__setstate__()` as well for reference where we don't apply validation.",
      "comment_id": 2061207921,
      "user": "Viicos",
      "created_at": "2025-04-26T07:31:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/11769#discussion_r2061207921"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11769,
      "file_path": "pydantic/dataclasses.py",
      "line": 284,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,6 +265,35 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             **kwargs,\n         )\n \n+        if config_wrapper.validate_assignment:\n+\n+            @functools.wraps(cls.__setattr__)\n+            def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n+                type(instance).__pydantic_validator__.validate_assignment(instance, field, value)\n+\n+            cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n+\n+            if slots and not hasattr(cls, '__setstate__'):\n+                # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n+                # `__setattr__()` to reconstruct the dataclass. However, the custom\n+                # `__setattr__()` set above relies on `validate_assignment()`, which\n+                # in turn excepts all the field values to be already present on the\n+                # instance, resulting in attribute errors.\n+                # As such, we make use of `object.__setattr__()` instead.\n+                # Note that we do so only if `__setstate__()` isn't already set (this is the\n+                # case if on top of `slots`, `frozen` is used).",
      "comment": "When a frozen and slotted dataclass is created, the stdlib adds a `__set/getstate__()` implementation (and we actually reuse this implementation below). We could also unconditionally set our own `__set/getstate__()`, but this would also override any user-defined one (the CPython PR you linked is actually a fix for this on their end)?",
      "comment_id": 2061208930,
      "user": "Viicos",
      "created_at": "2025-04-26T07:37:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/11769#discussion_r2061208930"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11769,
      "file_path": "pydantic/dataclasses.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,6 +265,35 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             **kwargs,\n         )\n \n+        if config_wrapper.validate_assignment:\n+\n+            @functools.wraps(cls.__setattr__)\n+            def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n+                type(instance).__pydantic_validator__.validate_assignment(instance, field, value)\n+\n+            cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n+\n+            if slots and not hasattr(cls, '__setstate__'):\n+                # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n+                # `__setattr__()` to reconstruct the dataclass. However, the custom\n+                # `__setattr__()` set above relies on `validate_assignment()`, which\n+                # in turn excepts all the field values to be already present on the\n+                # instance, resulting in attribute errors.\n+                # As such, we make use of `object.__setattr__()` instead.\n+                # Note that we do so only if `__setstate__()` isn't already set (this is the\n+                # case if on top of `slots`, `frozen` is used).\n+\n+                # Taken from `dataclasses._dataclass_get/setstate()`:\n+                def _dataclass_getstate(self: Any) -> list[Any]:\n+                    return [getattr(self, f.name) for f in dataclasses.fields(self)]",
      "comment": "`dataclasses.fields` is documented so should be stable across all versions, and I don't think it will ever change even as a breaking change.",
      "comment_id": 2061209114,
      "user": "Viicos",
      "created_at": "2025-04-26T07:39:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/11769#discussion_r2061209114"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11769,
      "file_path": "pydantic/dataclasses.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,6 +265,35 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             **kwargs,\n         )\n \n+        if config_wrapper.validate_assignment:\n+\n+            @functools.wraps(cls.__setattr__)\n+            def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n+                type(instance).__pydantic_validator__.validate_assignment(instance, field, value)\n+\n+            cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n+\n+            if slots and not hasattr(cls, '__setstate__'):\n+                # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n+                # `__setattr__()` to reconstruct the dataclass. However, the custom\n+                # `__setattr__()` set above relies on `validate_assignment()`, which\n+                # in turn excepts all the field values to be already present on the\n+                # instance, resulting in attribute errors.\n+                # As such, we make use of `object.__setattr__()` instead.\n+                # Note that we do so only if `__setstate__()` isn't already set (this is the\n+                # case if on top of `slots`, `frozen` is used).\n+\n+                # Taken from `dataclasses._dataclass_get/setstate()`:\n+                def _dataclass_getstate(self: Any) -> list[Any]:\n+                    return [getattr(self, f.name) for f in dataclasses.fields(self)]",
      "comment": "@Viicos I was thinking about a case where a user-defined dataclass is modified and its `fields` change as a result. Then if we have a pickle from one version and unpickle on the next, the order (and length) of pickled values and dataclass fields may not match so the setstate below could fail. I haven't verified this though.",
      "comment_id": 2064194384,
      "user": "DouweM",
      "created_at": "2025-04-28T17:56:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/11769#discussion_r2064194384"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11769,
      "file_path": "pydantic/dataclasses.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,6 +265,35 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             **kwargs,\n         )\n \n+        if config_wrapper.validate_assignment:\n+\n+            @functools.wraps(cls.__setattr__)\n+            def validated_setattr(instance: Any, field: str, value: str, /) -> None:\n+                type(instance).__pydantic_validator__.validate_assignment(instance, field, value)\n+\n+            cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n+\n+            if slots and not hasattr(cls, '__setstate__'):\n+                # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n+                # `__setattr__()` to reconstruct the dataclass. However, the custom\n+                # `__setattr__()` set above relies on `validate_assignment()`, which\n+                # in turn excepts all the field values to be already present on the\n+                # instance, resulting in attribute errors.\n+                # As such, we make use of `object.__setattr__()` instead.\n+                # Note that we do so only if `__setstate__()` isn't already set (this is the\n+                # case if on top of `slots`, `frozen` is used).\n+\n+                # Taken from `dataclasses._dataclass_get/setstate()`:\n+                def _dataclass_getstate(self: Any) -> list[Any]:\n+                    return [getattr(self, f.name) for f in dataclasses.fields(self)]",
      "comment": "I'm not entirely sure I follow, but I think it should be fine: the provided `__get/setstate__()` implementations are used to pickle the dataclass _instances_. If the class definition changes between pickling/unpickling, then it is expected to fail anyway",
      "comment_id": 2064341168,
      "user": "Viicos",
      "created_at": "2025-04-28T19:03:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/11769#discussion_r2064341168"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11762,
      "file_path": "pydantic/main.py",
      "line": 648,
      "side": "RIGHT",
      "diff_hunk": "@@ -642,6 +645,7 @@ def model_rebuild(\n             _config.ConfigWrapper(cls.model_config, check=False),\n             ns_resolver,\n             raise_errors=raise_errors,\n+            call_on_complete_hook=call_on_complete_hook,",
      "comment": "```suggestion\r\n            # If the model is already complete, we don't need to call the on_complete hook again.\r\n            call_on_complete_hook=not cls.__pydantic_complete__,\r\n```\r\nAnd by removing the assignment above.",
      "comment_id": 2056640820,
      "user": "Viicos",
      "created_at": "2025-04-23T18:10:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/11762#discussion_r2056640820"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11762,
      "file_path": "pydantic/main.py",
      "line": 832,
      "side": "RIGHT",
      "diff_hunk": "@@ -809,19 +813,34 @@ def __get_pydantic_json_schema__(\n     @classmethod\n     def __pydantic_init_subclass__(cls, **kwargs: Any) -> None:\n         \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n-        only after the class is actually fully initialized. In particular, attributes like `model_fields` will\n-        be present when this is called.\n+        only after basic class initialization is complete. In particular, attributes like `model_fields` will\n+        be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n+        meaning that creating an instance of the class may fail.\n \n         This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n         and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n         `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n \n         This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n-        any kwargs passed to the class definition that aren't used internally by pydantic.\n+        any kwargs passed to the class definition that aren't used internally by Pydantic.\n \n         Args:\n             **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n-                by pydantic.\n+                by Pydantic.\n+\n+        Note:\n+            You may want to override `__pydantic_on_complete__` instead, which is called once the class",
      "comment": "```suggestion\r\n            You may want to override [`__pydantic_on_complete__()`][pydantic.BaseModel.__pydantic_on_complete__] instead, which is called once the class\r\n```\r\n\r\nline length might have to be adjusted.",
      "comment_id": 2056642169,
      "user": "Viicos",
      "created_at": "2025-04-23T18:11:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/11762#discussion_r2056642169"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11762,
      "file_path": "pydantic/main.py",
      "line": 841,
      "side": "RIGHT",
      "diff_hunk": "@@ -809,19 +813,34 @@ def __get_pydantic_json_schema__(\n     @classmethod\n     def __pydantic_init_subclass__(cls, **kwargs: Any) -> None:\n         \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n-        only after the class is actually fully initialized. In particular, attributes like `model_fields` will\n-        be present when this is called.\n+        only after basic class initialization is complete. In particular, attributes like `model_fields` will\n+        be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n+        meaning that creating an instance of the class may fail.\n \n         This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n         and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n         `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n \n         This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n-        any kwargs passed to the class definition that aren't used internally by pydantic.\n+        any kwargs passed to the class definition that aren't used internally by Pydantic.\n \n         Args:\n             **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n-                by pydantic.\n+                by Pydantic.\n+\n+        Note:\n+            You may want to override `__pydantic_on_complete__` instead, which is called once the class\n+            and its fields are fully initialized and ready for validation.\n+        \"\"\"\n+        pass\n+\n+    @classmethod\n+    def __pydantic_on_complete__(cls) -> None:\n+        \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n+\n+        This typically happens when the class is created (just before `__pydantic_init_subclass__` is",
      "comment": "```suggestion\r\n        This typically happens when the class is created (just before [`__pydantic_init_subclass__()`][pydantic.BaseModel.__pydantic_init_subclass__] is\r\n```\r\n\r\nline length might have to be adjusted.",
      "comment_id": 2056643554,
      "user": "Viicos",
      "created_at": "2025-04-23T18:12:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/11762#discussion_r2056643554"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11762,
      "file_path": "pydantic/main.py",
      "line": 843,
      "side": "RIGHT",
      "diff_hunk": "@@ -809,19 +813,34 @@ def __get_pydantic_json_schema__(\n     @classmethod\n     def __pydantic_init_subclass__(cls, **kwargs: Any) -> None:\n         \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n-        only after the class is actually fully initialized. In particular, attributes like `model_fields` will\n-        be present when this is called.\n+        only after basic class initialization is complete. In particular, attributes like `model_fields` will\n+        be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n+        meaning that creating an instance of the class may fail.\n \n         This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n         and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n         `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n \n         This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n-        any kwargs passed to the class definition that aren't used internally by pydantic.\n+        any kwargs passed to the class definition that aren't used internally by Pydantic.\n \n         Args:\n             **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n-                by pydantic.\n+                by Pydantic.\n+\n+        Note:\n+            You may want to override `__pydantic_on_complete__` instead, which is called once the class\n+            and its fields are fully initialized and ready for validation.\n+        \"\"\"\n+        pass\n+\n+    @classmethod\n+    def __pydantic_on_complete__(cls) -> None:\n+        \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n+\n+        This typically happens when the class is created (just before `__pydantic_init_subclass__` is\n+        called on the superclass), except when forward annotations are used that could not immediately be resolved.\n+        In that case, it will be called later, when the model is rebuilt automatically or explicitly using `model_rebuild`.",
      "comment": "```suggestion\r\n        In that case, it will be called later, when the model is rebuilt automatically or explicitly using [`model_rebuild()`][pydantic.BaseModel.base_rebuild].\r\n```",
      "comment_id": 2056643888,
      "user": "Viicos",
      "created_at": "2025-04-23T18:12:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/11762#discussion_r2056643888"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11762,
      "file_path": "pydantic/main.py",
      "line": 648,
      "side": "RIGHT",
      "diff_hunk": "@@ -642,6 +645,7 @@ def model_rebuild(\n             _config.ConfigWrapper(cls.model_config, check=False),\n             ns_resolver,\n             raise_errors=raise_errors,\n+            call_on_complete_hook=call_on_complete_hook,",
      "comment": "@Viicos Also the `cls.__pydantic_complete__ = False` on line 628? Otherwise this won't work right.",
      "comment_id": 2056759099,
      "user": "DouweM",
      "created_at": "2025-04-23T19:31:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/11762#discussion_r2056759099"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11775,
      "file_path": "tests/test_generics.py",
      "line": 1721,
      "side": "RIGHT",
      "diff_hunk": "@@ -1704,6 +1704,23 @@ class Model2(BaseModel, Generic[S]):\n     Model2[str].model_rebuild()\n \n \n+def test_generic_recursive_models_parametrized_with_model() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/11748\"\"\"\n+\n+    T = TypeVar('T')\n+\n+    class Base(BaseModel, Generic[T]):\n+        t: T\n+\n+    class Other(BaseModel):\n+        child: 'Base[Other]'\n+\n+    with pytest.raises(ValidationError):\n+        # In v2.0-2.10, this validated fine (The core schema of Base[Other].t was an empty model).\n+        # Since v2.11, building `Other` raised an unhandled exception.\n+        Base[Other].model_validate({'t': {}})",
      "comment": "Can we also add an example that does validate? Just to make sure that we didn't (and won't in the future) accidentally break this pattern entirely.",
      "comment_id": 2060893901,
      "user": "DouweM",
      "created_at": "2025-04-25T21:18:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/11775#discussion_r2060893901"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10678,
      "file_path": "pydantic/fields.py",
      "line": 582,
      "side": "RIGHT",
      "diff_hunk": "@@ -554,23 +555,36 @@ def deprecation_message(self) -> str | None:\n             return 'deprecated' if self.deprecated else None\n         return self.deprecated if isinstance(self.deprecated, str) else self.deprecated.message\n \n-    def get_default(self, *, call_default_factory: bool = False) -> Any:\n+    @overload\n+    def get_default(self, *, call_default_factory: Literal[False]) -> Any: ...\n+\n+    @overload\n+    def get_default(self, *, call_default_factory: Literal[True], validated_data: dict[str, Any]) -> Any: ...\n+\n+    def get_default(self, *, call_default_factory: bool, validated_data: dict[str, Any] | None = None) -> Any:\n         \"\"\"Get the default value.\n \n         We expose an option for whether to call the default_factory (if present), as calling it may\n         result in side effects that we want to avoid. However, there are times when it really should\n         be called (namely, when instantiating a model via `model_construct`).\n \n         Args:\n-            call_default_factory: Whether to call the default_factory or not. Defaults to `False`.\n+            call_default_factory: Whether to call the default factory or not.\n+            validated_data: The already validated data to be passed to the default factory.\n \n         Returns:\n             The default value, calling the default factory if requested or `None` if not set.\n         \"\"\"\n         if self.default_factory is None:\n             return _utils.smart_deepcopy(self.default)\n         elif call_default_factory:\n-            return self.default_factory()\n+            if validated_data is None:\n+                raise ValueError(\"'validated_data' must be provided if 'call_default_factory' is True.\")",
      "comment": "Is this true? Doesn't it only need to be not `None` when `_fields.takes_validated_data_argument(self.default_factory)` is True?",
      "comment_id": 1815062438,
      "user": "sydney-runkle",
      "created_at": "2024-10-24T14:06:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/10678#discussion_r1815062438"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10678,
      "file_path": "pydantic/fields.py",
      "line": 582,
      "side": "RIGHT",
      "diff_hunk": "@@ -554,23 +555,36 @@ def deprecation_message(self) -> str | None:\n             return 'deprecated' if self.deprecated else None\n         return self.deprecated if isinstance(self.deprecated, str) else self.deprecated.message\n \n-    def get_default(self, *, call_default_factory: bool = False) -> Any:\n+    @overload\n+    def get_default(self, *, call_default_factory: Literal[False]) -> Any: ...\n+\n+    @overload\n+    def get_default(self, *, call_default_factory: Literal[True], validated_data: dict[str, Any]) -> Any: ...\n+\n+    def get_default(self, *, call_default_factory: bool, validated_data: dict[str, Any] | None = None) -> Any:\n         \"\"\"Get the default value.\n \n         We expose an option for whether to call the default_factory (if present), as calling it may\n         result in side effects that we want to avoid. However, there are times when it really should\n         be called (namely, when instantiating a model via `model_construct`).\n \n         Args:\n-            call_default_factory: Whether to call the default_factory or not. Defaults to `False`.\n+            call_default_factory: Whether to call the default factory or not.\n+            validated_data: The already validated data to be passed to the default factory.\n \n         Returns:\n             The default value, calling the default factory if requested or `None` if not set.\n         \"\"\"\n         if self.default_factory is None:\n             return _utils.smart_deepcopy(self.default)\n         elif call_default_factory:\n-            return self.default_factory()\n+            if validated_data is None:\n+                raise ValueError(\"'validated_data' must be provided if 'call_default_factory' is True.\")",
      "comment": "Yes I can probably move the check below, but I prefer enforcing the data to be provided as external users of this method don't know whether the default factory requires the argument or not, and I think it's best to unconditionally raise here (and enforcing the argument in the overload).",
      "comment_id": 1815550723,
      "user": "Viicos",
      "created_at": "2024-10-24T18:44:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10678#discussion_r1815550723"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10182,
      "file_path": "tests/conftest.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,21 +10,23 @@\n import textwrap\n from dataclasses import dataclass\n from pathlib import Path\n-from types import FunctionType\n-from typing import Any, Optional\n+from types import FunctionType, ModuleType\n+from typing import Any, Callable\n \n import pytest\n from _pytest.assertion.rewrite import AssertionRewritingHook\n+from jsonschema import Draft202012Validator, SchemaError\n \n from pydantic import GenerateSchema\n+from pydantic.json_schema import GenerateJsonSchema\n \n \n def pytest_addoption(parser: pytest.Parser):\n     parser.addoption('--test-mypy', action='store_true', help='run mypy tests')\n     parser.addoption('--update-mypy', action='store_true', help='update mypy tests')\n \n \n-def _extract_source_code_from_function(function):\n+def _extract_source_code_from_function(function: FunctionType):\n     if function.__code__.co_argcount:\n         raise RuntimeError(f'function {function.__qualname__} cannot have any arguments')",
      "comment": "Nice work on the typing improvements here across the board",
      "comment_id": 1723486957,
      "user": "sydney-runkle",
      "created_at": "2024-08-20T15:07:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/10182#discussion_r1723486957"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10182,
      "file_path": "tests/conftest.py",
      "line": 168,
      "side": "RIGHT",
      "diff_hunk": "@@ -143,3 +153,20 @@ def generate_schema_call_counter(*args: Any, **kwargs: Any) -> Any:\n \n     monkeypatch.setattr(GenerateSchema, 'generate_schema', generate_schema_call_counter)\n     return counter\n+\n+\n+@pytest.fixture(scope='function', autouse=True)\n+def validate_json_schemas(monkeypatch: pytest.MonkeyPatch, request: pytest.FixtureRequest) -> None:\n+    orig_generate = GenerateJsonSchema.generate\n+\n+    def generate(*args: Any, **kwargs: Any) -> Any:\n+        json_schema = orig_generate(*args, **kwargs)\n+        if not request.node.get_closest_marker('skip_json_schema_validation'):\n+            try:\n+                Draft202012Validator.check_schema(json_schema)\n+            except SchemaError:\n+                pytest.fail('Failed to validate the JSON Schema against the Draft 2020-12 spec')",
      "comment": "Perhaps this could be a bit more verbose:\r\n\r\n1. Can we include the `SchemaError` information in this result?\r\n2. Could we add a note about the fact that this is purely a testing feature, not a runtime `pydantic` check (at this point)?\r\n\r\nPerhaps this is a bit excessive, but can we test this test? As in, run a test within a test, and check that this is raised for invalid schema? If not, no worries, but could you document an example of a failing test on this PR just to have as a reference for the blame later?",
      "comment_id": 1723491589,
      "user": "sydney-runkle",
      "created_at": "2024-08-20T15:10:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/10182#discussion_r1723491589"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11761,
      "file_path": "tests/test_validators.py",
      "line": 2798,
      "side": "RIGHT",
      "diff_hunk": "@@ -2779,6 +2781,42 @@ class MyModel(BaseModel):\n     assert m.foobar == {'value': '1', 'field_name': 'foobar', 'data': {'x': 123}}\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 type keyword')\n+def test_validator_field_name_with_reused_type(create_module):\n+    mod = create_module(\n+        textwrap.dedent(\n+            \"\"\"\n+        from typing import Annotated\n+        from pydantic import BaseModel, AfterValidator, ValidationInfo\n+\n+        calls = []\n+\n+        def validate_my_field(value: str, info: ValidationInfo):\n+            calls.append((info.field_name, value))\n+            return value\n+\n+        type MyField = Annotated[str, AfterValidator(validate_my_field)]",
      "comment": "```suggestion\r\n        MyField =  TypeAliasType('MyField', Annotated[str, AfterValidator(validate_my_field)])\r\n```\r\nYou can make use of `typing_extensions.TypeAliasType` so that the test can run on all versions, without the `create_module()` helper.",
      "comment_id": 2050711696,
      "user": "Viicos",
      "created_at": "2025-04-18T14:28:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/11761#discussion_r2050711696"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11755,
      "file_path": "tests/test_generics.py",
      "line": 531,
      "side": "RIGHT",
      "diff_hunk": "@@ -519,6 +520,37 @@ class M(BaseModel):\n     del generics\n \n \n+def test_generics_reused() -> None:\n+    \"\"\"https://github.com/pydantic/pydantic/issues/11747\n+\n+    To fix an issue with recursive generics, we introduced a change in 2.11 that would\n+    skip caching the parameterized model under specific circumstances. The following setup\n+    is an example of where this happens. As a result, we end up with two different `A[float]`\n+    classes, although they are the same in practice.\n+    When serializing, we check that the value instances are matching the type, but we end up\n+    with warnings as `isinstance(value, A[float])` fails.",
      "comment": "`int` not `float`? Also I think the tense might be past tense...\r\n\r\n```suggestion\r\n    is an example of where this would happen. As a result, we ended up with two different `A[int]`\r\n    classes, although they were the same in practice.\r\n    When serializing, we check that the value instances are matching the type, but we ended up\r\n    with warnings as `isinstance(value, A[int])` fails.\r\n```",
      "comment_id": 2044544492,
      "user": "davidhewitt",
      "created_at": "2025-04-15T13:28:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/11755#discussion_r2044544492"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/fields.py",
      "line": 220,
      "side": "LEFT",
      "diff_hunk": "@@ -209,14 +211,10 @@ def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:\n         self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset}\n         kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore\n         self.annotation = kwargs.get('annotation')\n-        self.evaluated = False\n \n         default = kwargs.pop('default', PydanticUndefined)\n         if default is Ellipsis:\n             self.default = PydanticUndefined\n-            # Also remove it from the attributes set, otherwise\n-            # `GenerateSchema._common_field_schema` mistakenly\n-            # uses it:",
      "comment": "This is no longer relevant as `GenerateSchema._common_field_schema()` doesn't do funky stuff anymore. However, the `_attributes_set` logic is still there as is it used in `merge_field_infos()`. This can be refactored/removed (more easily with this PR) later.",
      "comment_id": 1946736901,
      "user": "Viicos",
      "created_at": "2025-02-07T15:44:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1946736901"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_generics.py",
      "line": 226,
      "side": "LEFT",
      "diff_hunk": "@@ -223,7 +223,7 @@ def get_standard_typevars_map(cls: Any) -> dict[TypeVar, Any] | None:\n     return dict(zip(parameters, args))\n \n \n-def get_model_typevars_map(cls: type[BaseModel]) -> dict[TypeVar, Any] | None:",
      "comment": "Split in https://github.com/pydantic/pydantic/pull/11409.",
      "comment_id": 1946844914,
      "user": "Viicos",
      "created_at": "2025-02-07T16:46:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1946844914"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 574,
      "side": "LEFT",
      "diff_hunk": "@@ -569,10 +583,6 @@ def complete_model_class(\n         PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n             and `raise_errors=True`.\n     \"\"\"\n-    if config_wrapper.defer_build:\n-        set_model_mocks(cls)\n-        return False",
      "comment": "Moved in `ModelMetaclass.__new__`, as it makes more sense to be there (we also don't need to build a different config wrapper with a hardcoded `defer_build=True` value in `model_rebuild()`).",
      "comment_id": 1946846648,
      "user": "Viicos",
      "created_at": "2025-02-07T16:47:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1946846648"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/fields.py",
      "line": 220,
      "side": "LEFT",
      "diff_hunk": "@@ -209,14 +211,10 @@ def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:\n         self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset}\n         kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore\n         self.annotation = kwargs.get('annotation')\n-        self.evaluated = False\n \n         default = kwargs.pop('default', PydanticUndefined)\n         if default is Ellipsis:\n             self.default = PydanticUndefined\n-            # Also remove it from the attributes set, otherwise\n-            # `GenerateSchema._common_field_schema` mistakenly\n-            # uses it:",
      "comment": "What do you mean `_attributes_set` logic is still there? Isn't it removed above?",
      "comment_id": 1949392627,
      "user": "sydney-runkle",
      "created_at": "2025-02-10T15:58:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949392627"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/main.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +147,11 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n     __pydantic_complete__: ClassVar[bool] = False\n     \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n \n+    __pydantic_fields_complete__: ClassVar[bool] = False\n+    \"\"\"Whether the fields where successfully collected. This is a private attribute, not meant\n+    to be used outside Pydantic.",
      "comment": "Maybe add a note about what successfully collected means - specifically, that annotations were successfully evaluated?",
      "comment_id": 1949401408,
      "user": "sydney-runkle",
      "created_at": "2025-02-10T16:02:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949401408"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 228,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,21 +211,23 @@ def collect_model_fields(  # noqa: C901\n \n         if assigned_value is PydanticUndefined:\n             if ann_name in annotations:\n+                # field is present in the current model's annotations (and *not* from parent classes)\n                 field_info = FieldInfo_.from_annotation(ann_type)\n-                field_info.evaluated = evaluated\n+            elif ann_name in parent_fields_lookup:\n+                # The field was present on one of the (possibly multiple) base classes\n+                # copy the field to make sure typevar substitutions don't cause issues with the base classes\n+                field_info = copy(parent_fields_lookup[ann_name])\n             else:\n-                # if field has no default value and is not in __annotations__ this means that it is\n-                # defined in a base class and we can take it from there\n-                if ann_name in parent_fields_lookup:\n-                    # The field was present on one of the (possibly multiple) base classes\n-                    # copy the field to make sure typevar substitutions don't cause issues with the base classes\n-                    field_info = copy(parent_fields_lookup[ann_name])\n-                else:\n-                    # The field was not found on any base classes; this seems to be caused by fields not getting\n-                    # generated thanks to models not being fully defined while initializing recursive models.\n-                    # Nothing stops us from just creating a new FieldInfo for this type hint, so we do this.\n-                    field_info = FieldInfo_.from_annotation(ann_type)\n-                    field_info.evaluated = evaluated\n+                # The field was not found on any base classes; this seems to be caused by fields not getting\n+                # generated thanks to models not being fully defined while initializing recursive models.\n+                # Nothing stops us from just creating a new FieldInfo for this type hint, so we do this.\n+                field_info = FieldInfo_.from_annotation(ann_type)\n+\n+            if not evaluated:\n+                field_info._complete = False",
      "comment": "I like using `complete` here to be more consistent with other areas where we use `complete` like on the `BaseModel` level",
      "comment_id": 1949413677,
      "user": "sydney-runkle",
      "created_at": "2025-02-10T16:06:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949413677"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 231,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,21 +211,23 @@ def collect_model_fields(  # noqa: C901\n \n         if assigned_value is PydanticUndefined:\n             if ann_name in annotations:\n+                # field is present in the current model's annotations (and *not* from parent classes)\n                 field_info = FieldInfo_.from_annotation(ann_type)\n-                field_info.evaluated = evaluated\n+            elif ann_name in parent_fields_lookup:\n+                # The field was present on one of the (possibly multiple) base classes\n+                # copy the field to make sure typevar substitutions don't cause issues with the base classes\n+                field_info = copy(parent_fields_lookup[ann_name])\n             else:\n-                # if field has no default value and is not in __annotations__ this means that it is\n-                # defined in a base class and we can take it from there\n-                if ann_name in parent_fields_lookup:\n-                    # The field was present on one of the (possibly multiple) base classes\n-                    # copy the field to make sure typevar substitutions don't cause issues with the base classes\n-                    field_info = copy(parent_fields_lookup[ann_name])\n-                else:\n-                    # The field was not found on any base classes; this seems to be caused by fields not getting\n-                    # generated thanks to models not being fully defined while initializing recursive models.\n-                    # Nothing stops us from just creating a new FieldInfo for this type hint, so we do this.\n-                    field_info = FieldInfo_.from_annotation(ann_type)\n-                    field_info.evaluated = evaluated\n+                # The field was not found on any base classes; this seems to be caused by fields not getting\n+                # generated thanks to models not being fully defined while initializing recursive models.\n+                # Nothing stops us from just creating a new FieldInfo for this type hint, so we do this.\n+                field_info = FieldInfo_.from_annotation(ann_type)\n+\n+            if not evaluated:\n+                field_info._complete = False\n+                # Store the original annotation that should be used to rebuild\n+                # the field info later:\n+                field_info._original_annotation = ann_type\n         else:",
      "comment": "Can we add a comment explaining what this else block is (default present)",
      "comment_id": 1949419010,
      "user": "sydney-runkle",
      "created_at": "2025-02-10T16:07:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949419010"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 245,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,8 +238,19 @@ def collect_model_fields(  # noqa: C901\n                 # `hasattr(assigned_value.default, '__get__')`).\n                 assigned_value.default = assigned_value.default.__get__(None, cls)\n \n+            # The `from_annotated_attribute()` call below mutates the assigned `Field()`, so make a copy:\n+            original_assignment = (\n+                copy(assigned_value) if not evaluated and isinstance(assigned_value, FieldInfo_) else assigned_value\n+            )",
      "comment": "Any metrics on perf impact of this copy? Seems like a pretty special case...",
      "comment_id": 1949420742,
      "user": "sydney-runkle",
      "created_at": "2025-02-10T16:08:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949420742"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -290,6 +306,49 @@ def _is_finalvar_with_default_val(ann_type: type[Any], assigned_value: Any) -> b\n         return True\n \n \n+def rebuild_model_fields(\n+    cls: type[BaseModel],\n+    *,\n+    ns_resolver: NsResolver,\n+    typevars_map: dict[TypeVar, Any],\n+    raise_errors: bool = True,\n+) -> dict[str, FieldInfo]:\n+    \"\"\"Rebuild the (already present) model fields by trying to reevaluate annotations.\n+\n+    This function should be called whenever a model with incomplete fields is encountered.\n+\n+    Note:\n+        This function *doesn't* mutate the model fields in place, as it can be called during\n+        schema generation, where you don't want to mutate other model's fields.\n+    \"\"\"\n+    FieldInfo_ = import_cached_field_info()\n+\n+    rebuilt_fields: dict[str, FieldInfo] = {}",
      "comment": "Understandable, but downside - this is going to increate memory usage. Could you benchmark this with memray and see what the difference is like?",
      "comment_id": 1949422871,
      "user": "sydney-runkle",
      "created_at": "2025-02-10T16:09:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949422871"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/fields.py",
      "line": 220,
      "side": "LEFT",
      "diff_hunk": "@@ -209,14 +211,10 @@ def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:\n         self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset}\n         kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore\n         self.annotation = kwargs.get('annotation')\n-        self.evaluated = False\n \n         default = kwargs.pop('default', PydanticUndefined)\n         if default is Ellipsis:\n             self.default = PydanticUndefined\n-            # Also remove it from the attributes set, otherwise\n-            # `GenerateSchema._common_field_schema` mistakenly\n-            # uses it:",
      "comment": "We don't use it anymore in `GenerateSchema`, but we still need it to keep track of the explicitly set attributes when merging multiple field infos instances together in `merge_field_infos()`. However, there should be an easier way to do the merging, without having to use this `_attributes_set` logic.",
      "comment_id": 1949895822,
      "user": "Viicos",
      "created_at": "2025-02-10T21:09:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949895822"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 245,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,8 +238,19 @@ def collect_model_fields(  # noqa: C901\n                 # `hasattr(assigned_value.default, '__get__')`).\n                 assigned_value.default = assigned_value.default.__get__(None, cls)\n \n+            # The `from_annotated_attribute()` call below mutates the assigned `Field()`, so make a copy:\n+            original_assignment = (\n+                copy(assigned_value) if not evaluated and isinstance(assigned_value, FieldInfo_) else assigned_value\n+            )",
      "comment": "It's only relevant if an annotation fails to evaluate and has a `Field()` assigned:\r\n\r\n```python\r\na: Undefined = Field()\r\n```\r\n\r\nSo not that common, + this copy could be removed if we manage to refactor how we merge field infos together.",
      "comment_id": 1949899826,
      "user": "Viicos",
      "created_at": "2025-02-10T21:12:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949899826"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -290,6 +306,49 @@ def _is_finalvar_with_default_val(ann_type: type[Any], assigned_value: Any) -> b\n         return True\n \n \n+def rebuild_model_fields(\n+    cls: type[BaseModel],\n+    *,\n+    ns_resolver: NsResolver,\n+    typevars_map: dict[TypeVar, Any],\n+    raise_errors: bool = True,\n+) -> dict[str, FieldInfo]:\n+    \"\"\"Rebuild the (already present) model fields by trying to reevaluate annotations.\n+\n+    This function should be called whenever a model with incomplete fields is encountered.\n+\n+    Note:\n+        This function *doesn't* mutate the model fields in place, as it can be called during\n+        schema generation, where you don't want to mutate other model's fields.\n+    \"\"\"\n+    FieldInfo_ = import_cached_field_info()\n+\n+    rebuilt_fields: dict[str, FieldInfo] = {}",
      "comment": "It's only going to make temporary memory allocations, as:\r\n- if this is called from `model_rebuild()`, it will override the existing `__pydantic_fields__`, so the old ones will be gc'ed.\r\n- if this is called in `GenerateSchema._model_schema()`, as part of another model build, they are going to be gc'ed at the end of the method.",
      "comment_id": 1949902245,
      "user": "Viicos",
      "created_at": "2025-02-10T21:14:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949902245"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,6 +218,14 @@ def wrapped_model_post_init(self: BaseModel, context: Any, /) -> None:\n             if isinstance(parent_namespace, dict):\n                 parent_namespace = unpack_lenient_weakvaluedict(parent_namespace)\n \n+            # This is also set in `complete_model_class()`, after schema gen because they are recreated.\n+            # We set them here as well for backwards compatibility:\n+            cls.__pydantic_computed_fields__ = {\n+                k: v.info for k, v in cls.__pydantic_decorators__.computed_fields.items()\n+            }",
      "comment": "Users can inspect computed fields on models that are not fully built yet, so we need them even though they are going to change after core schema build (the impact is limited compared to normal fields, as it is only the `return_type` property that changes -- see the comment in `complete_model_class()`).",
      "comment_id": 1949905556,
      "user": "Viicos",
      "created_at": "2025-02-10T21:17:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1949905556"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 245,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,8 +238,19 @@ def collect_model_fields(  # noqa: C901\n                 # `hasattr(assigned_value.default, '__get__')`).\n                 assigned_value.default = assigned_value.default.__get__(None, cls)\n \n+            # The `from_annotated_attribute()` call below mutates the assigned `Field()`, so make a copy:\n+            original_assignment = (\n+                copy(assigned_value) if not evaluated and isinstance(assigned_value, FieldInfo_) else assigned_value\n+            )",
      "comment": "I think it's definitely worth investigating refactoring how we merge field infos :).",
      "comment_id": 1951785917,
      "user": "sydney-runkle",
      "created_at": "2025-02-12T00:22:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1951785917"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/fields.py",
      "line": 255,
      "side": "RIGHT",
      "diff_hunk": "@@ -251,6 +249,11 @@ def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:\n \n         self.metadata = self._collect_metadata(kwargs)  # type: ignore\n \n+        # Private attributes, used to rebuild FieldInfo instances:\n+        self._complete = True\n+        self._original_annotation: Any = PydanticUndefined\n+        self._original_assignment: Any = PydanticUndefined",
      "comment": "Should this be `_original_default`? Or is that confusing for the `Field()` case?",
      "comment_id": 1952827127,
      "user": "sydney-runkle",
      "created_at": "2025-02-12T15:00:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1952827127"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11388,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 233,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,26 +218,32 @@ def wrapped_model_post_init(self: BaseModel, context: Any, /) -> None:\n \n             ns_resolver = NsResolver(parent_namespace=parent_namespace)\n \n-            set_model_fields(cls, bases, config_wrapper, ns_resolver)\n+            set_model_fields(cls, config_wrapper=config_wrapper, ns_resolver=ns_resolver)\n \n-            if config_wrapper.frozen and '__hash__' not in namespace:\n-                set_default_hash_func(cls, bases)\n-\n-            complete_model_class(\n-                cls,\n-                config_wrapper,\n-                raise_errors=False,\n-                ns_resolver=ns_resolver,\n-                create_model_module=_create_model_module,\n-            )\n-\n-            # If this is placed before the complete_model_class call above,\n-            # the generic computed fields return type is set to PydanticUndefined\n+            # This is also set in `complete_model_class()`, after schema gen because they are recreated.\n+            # We set them here as well for backwards compatibility:\n             cls.__pydantic_computed_fields__ = {\n                 k: v.info for k, v in cls.__pydantic_decorators__.computed_fields.items()\n             }\n \n-            set_deprecated_descriptors(cls)\n+            if config_wrapper.defer_build:\n+                # TODO we can also stop there if `__pydantic_fields_complete__` is False.\n+                # However, `set_model_fields()` is currently lenient and we don't have access to the `NameError`.\n+                # (which is useful as we can provide the name in the error message: `set_model_mock(cls, e.name)`)\n+                set_model_mocks(cls)",
      "comment": "Created https://github.com/pydantic/pydantic/issues/11453.",
      "comment_id": 1958681094,
      "user": "Viicos",
      "created_at": "2025-02-17T18:51:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/11388#discussion_r1958681094"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11032,
      "file_path": "tests/test_create_model.py",
      "line": 123,
      "side": "LEFT",
      "diff_hunk": "@@ -112,17 +138,6 @@ def test_create_model_must_not_reset_parent_namespace():\n     ]\n \n \n-def test_invalid_name():\n-    with pytest.warns(RuntimeWarning):\n-        model = create_model('FooModel', _foo=(str, ...))\n-    assert len(model.model_fields) == 0\n-\n-\n-def test_field_wrong_tuple():\n-    with pytest.raises(errors.PydanticUserError):\n-        create_model('FooModel', foo=(1, 2, 3))",
      "comment": "Why is this valid now? What would be the implication here?",
      "comment_id": 1868023241,
      "user": "sydney-runkle",
      "created_at": "2024-12-03T16:18:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/11032#discussion_r1868023241"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/main.py",
      "line": 692,
      "side": "RIGHT",
      "diff_hunk": "@@ -679,8 +683,15 @@ def model_validate(\n         \"\"\"\n         # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n         __tracebackhide__ = True\n+\n+        if by_alias is False and by_name is not True:\n+            raise PydanticUserError(\n+                'At least one of `by_alias` or `by_name` must be set to True.',\n+                code='validate-by-alias-and-name-false',\n+            )\n+",
      "comment": "Up for debate if we should do this here (and in other model validation methods, including on type adapter)... also happy to use a helper function if we want, though I think the verbosity here is helpful.",
      "comment_id": 1966887252,
      "user": "sydney-runkle",
      "created_at": "2025-02-23T21:05:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1966887252"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "tests/test_aliases.py",
      "line": 800,
      "side": "RIGHT",
      "diff_hunk": "@@ -765,3 +766,89 @@ def b(self) -> str:\n     assert Model.model_fields['a'].serialization_alias == ''\n     assert Model.model_fields['a'].alias == 'a_alias'\n     assert Model.model_computed_fields['b'].alias == ''\n+\n+\n+@pytest.mark.parametrize('config_by_alias', [None, True, False])\n+@pytest.mark.parametrize('config_by_name', [None, True, False])\n+@pytest.mark.parametrize('runtime_by_alias', [None, True, False])\n+@pytest.mark.parametrize('runtime_by_name', [None, True, False])\n+def test_validation_alias_settings(\n+    config_by_alias: Union[bool, None],\n+    config_by_name: Union[bool, None],\n+    runtime_by_alias: Union[bool, None],\n+    runtime_by_name: Union[bool, None],\n+) -> None:\n+    \"\"\"This test reflects the priority that applies for config vs runtime validation alias configuration.\n+\n+    Runtime values take precedence over config values, when set.\n+    By default, `by_alias` is True and `by_name` is False.\n+    \"\"\"\n+\n+    if (config_by_alias is False and config_by_name is not True) or (\n+        runtime_by_alias is False and runtime_by_name is not True\n+    ):\n+        pytest.skip(\"Can't have both validate_by_alias and validate_by_name as effectively False\")\n+\n+    config_dict = {\n+        **({'validate_by_alias': config_by_alias} if config_by_alias is not None else {}),\n+        **({'validate_by_name': config_by_name} if config_by_name is not None else {}),\n+    }\n+\n+    class Model(BaseModel):\n+        model_config = ConfigDict(**config_dict)\n+\n+        a: int = Field(validation_alias='A')",
      "comment": "I've heavily tested all of the config / runtime setting combos for each applicable schema type in `pydantic-core`. It feels redundant to do so here as well, so I've gone with the simple model only approach.",
      "comment_id": 1967863301,
      "user": "sydney-runkle",
      "created_at": "2025-02-24T15:22:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1967863301"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -168,30 +168,38 @@ class Model(BaseModel):\n     Whether an aliased field may be populated by its name as given by the model\n     attribute, as well as the alias. Defaults to `False`.\n \n-    Note:\n-        The name of this configuration setting was changed in **v2.0** from\n-        `allow_population_by_field_name` to `populate_by_name`.\n+    !!! warning\n+        `populate_by_name` usage is not recommended in v2.11+ and will be deprecated in v3.\n+         Instead, you should use the [`validate_by_name`][pydantic.config.ConfigDict.validate_by_name] configuration setting.",
      "comment": "Maybe emphasize on the fact that it is strictly equivalent?\r\n",
      "comment_id": 1969755589,
      "user": "Viicos",
      "created_at": "2025-02-25T13:11:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1969755589"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 1072,
      "side": "RIGHT",
      "diff_hunk": "@@ -1025,6 +1033,123 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    validate_by_alias: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its alias. Defaults to `True`.\n+\n+    !!! note\n+        In v2.11, `validate_by_alias` was introduced in conjunction with [`validate_by_name`][pydantic.ConfigDict.validate_by_name]\n+        to empower users with more fine grained validation control. In <v2.11, disabling validation by alias was not possible.\n+\n+    !!! tip\n+        If you set `validate_by_alias` to `False`, you should set `validate_by_name` to `True` to ensure that the field can still be populated.\n+\n+    Here's an example of disabling validation by alias:\n+\n+    ```py\n+    from datetime import datetime\n+\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+    class User(BaseModel):\n+        model_config = ConfigDict(validate_by_name=True, validate_by_alias=False)\n+\n+        date_of_birth: datetime = Field(alias='DOB')  # (1)!\n+        name: str\n+\n+    user = User(date_of_birth='2022-01-01', name='John Doe')  # (2)!\n+    print(user)\n+    #> date_of_birth=datetime.datetime(2022, 1, 1, 0, 0) name='John Doe'\n+    ```\n+\n+    1. The field `'date_of_birth'` has an alias `'DOB'`.\n+    2. The model can only be populated by the attribute name `'date_of_birth'`.\n+\n+    !!! warning\n+        You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+        This would make it impossible to populate an attribute. A [`PydanticUserError`][pydantic.errors.PydanticUserError]\n+        will be raised if you try to do this.\n+",
      "comment": "I don't know if it's worth mentioning the exception raised, as the usage error is linked below?",
      "comment_id": 1969763018,
      "user": "Viicos",
      "created_at": "2025-02-25T13:16:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1969763018"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 1045,
      "side": "RIGHT",
      "diff_hunk": "@@ -1025,6 +1033,123 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    validate_by_alias: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its alias. Defaults to `True`.\n+\n+    !!! note\n+        In v2.11, `validate_by_alias` was introduced in conjunction with [`validate_by_name`][pydantic.ConfigDict.validate_by_name]\n+        to empower users with more fine grained validation control. In <v2.11, disabling validation by alias was not possible.\n+\n+    !!! tip\n+        If you set `validate_by_alias` to `False`, you should set `validate_by_name` to `True` to ensure that the field can still be populated.",
      "comment": "This makes me think the literal pattern would really fit better here.. If having this boolean pattern on two configuration values only introduced the inconsistency when setting both `validate_by_alias=False, validate_by_name=False`, it would be fine (I don't see why users would do so), but I won't be surprised if many users find it counter-intuitive that you also need to set `validate_by_name=True` here.\r\n\r\nI think it's worth reconsidering, cc @samuelcolvin ",
      "comment_id": 1969774768,
      "user": "Viicos",
      "created_at": "2025-02-25T13:22:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1969774768"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 1118,
      "side": "RIGHT",
      "diff_hunk": "@@ -1025,6 +1033,123 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    validate_by_alias: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its alias. Defaults to `True`.\n+\n+    !!! note\n+        In v2.11, `validate_by_alias` was introduced in conjunction with [`validate_by_name`][pydantic.ConfigDict.validate_by_name]\n+        to empower users with more fine grained validation control. In <v2.11, disabling validation by alias was not possible.\n+\n+    !!! tip\n+        If you set `validate_by_alias` to `False`, you should set `validate_by_name` to `True` to ensure that the field can still be populated.\n+\n+    Here's an example of disabling validation by alias:\n+\n+    ```py\n+    from datetime import datetime\n+\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+    class User(BaseModel):\n+        model_config = ConfigDict(validate_by_name=True, validate_by_alias=False)\n+\n+        date_of_birth: datetime = Field(alias='DOB')  # (1)!\n+        name: str\n+\n+    user = User(date_of_birth='2022-01-01', name='John Doe')  # (2)!\n+    print(user)\n+    #> date_of_birth=datetime.datetime(2022, 1, 1, 0, 0) name='John Doe'\n+    ```\n+\n+    1. The field `'date_of_birth'` has an alias `'DOB'`.\n+    2. The model can only be populated by the attribute name `'date_of_birth'`.\n+\n+    !!! warning\n+        You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+        This would make it impossible to populate an attribute. A [`PydanticUserError`][pydantic.errors.PydanticUserError]\n+        will be raised if you try to do this.\n+\n+        See [usage errors](../errors/usage_errors.md#validate-by-alias-and-name-false) for an example.\n+    \"\"\"\n+\n+    validate_by_name: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its name as given by the model\n+    attribute. Defaults to `False`.\n+\n+    !!! note\n+        In v2.0-v2.10, the `populate_by_name` configuration setting was used to specify\n+        whether or not a field could be populated by its name **and** alias.\n+\n+        In v2.11, `validate_by_name` was introduced in conjunction with [`validate_by_alias`][pydantic.ConfigDict.validate_by_alias]\n+        to empower users with more fine grained validation behavior control.\n+\n+    ```python\n+    from datetime import datetime\n+\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+    class User(BaseModel):\n+        model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n+\n+        date_of_birth: datetime = Field(alias='DOB')  # (1)!\n+        name: str\n+\n+    user = User(DOB='2022-01-01', name='John Doe')  # (2)!\n+    print(user)\n+    #> date_of_birth=datetime.datetime(2022, 1, 1, 0, 0) name='John Doe'\n+\n+    user = User(date_of_birth='2022-01-01', name='John Doe')  # (3)!\n+    print(user)\n+    #> date_of_birth=datetime.datetime(2022, 1, 1, 0, 0) name='John Doe'\n+    ```\n+\n+    1. The field `'date_of_birth'` has an alias `'DOB'`.\n+    2. The model is populated by the alias `'DOB'`.\n+    3. The model is populated by the attribute name `'date_of_birth'`.\n+\n+    !!! warning\n+        You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+        This would make it impossible to populate an attribute. A [`PydanticUserError`][pydantic.errors.PydanticUserError]\n+        will be raised if you try to do this.\n+\n+        This also means you can't set `validate_by_alias` to `False` and leave `validate_by_name` unset,\n+        as `validate_by_name` defaults to `False.",
      "comment": "```suggestion\r\n        as `validate_by_name` defaults to `False`.\r\n```",
      "comment_id": 1969779505,
      "user": "Viicos",
      "created_at": "2025-02-25T13:24:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1969779505"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 1133,
      "side": "RIGHT",
      "diff_hunk": "@@ -1025,6 +1033,123 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    validate_by_alias: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its alias. Defaults to `True`.\n+\n+    !!! note\n+        In v2.11, `validate_by_alias` was introduced in conjunction with [`validate_by_name`][pydantic.ConfigDict.validate_by_name]\n+        to empower users with more fine grained validation control. In <v2.11, disabling validation by alias was not possible.\n+\n+    !!! tip\n+        If you set `validate_by_alias` to `False`, you should set `validate_by_name` to `True` to ensure that the field can still be populated.\n+\n+    Here's an example of disabling validation by alias:\n+\n+    ```py\n+    from datetime import datetime\n+\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+    class User(BaseModel):\n+        model_config = ConfigDict(validate_by_name=True, validate_by_alias=False)\n+\n+        date_of_birth: datetime = Field(alias='DOB')  # (1)!\n+        name: str\n+\n+    user = User(date_of_birth='2022-01-01', name='John Doe')  # (2)!\n+    print(user)\n+    #> date_of_birth=datetime.datetime(2022, 1, 1, 0, 0) name='John Doe'\n+    ```\n+\n+    1. The field `'date_of_birth'` has an alias `'DOB'`.\n+    2. The model can only be populated by the attribute name `'date_of_birth'`.\n+\n+    !!! warning\n+        You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+        This would make it impossible to populate an attribute. A [`PydanticUserError`][pydantic.errors.PydanticUserError]\n+        will be raised if you try to do this.\n+\n+        See [usage errors](../errors/usage_errors.md#validate-by-alias-and-name-false) for an example.\n+    \"\"\"\n+\n+    validate_by_name: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its name as given by the model\n+    attribute. Defaults to `False`.\n+\n+    !!! note\n+        In v2.0-v2.10, the `populate_by_name` configuration setting was used to specify\n+        whether or not a field could be populated by its name **and** alias.\n+\n+        In v2.11, `validate_by_name` was introduced in conjunction with [`validate_by_alias`][pydantic.ConfigDict.validate_by_alias]\n+        to empower users with more fine grained validation behavior control.\n+\n+    ```python\n+    from datetime import datetime\n+\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+    class User(BaseModel):\n+        model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n+\n+        date_of_birth: datetime = Field(alias='DOB')  # (1)!\n+        name: str\n+\n+    user = User(DOB='2022-01-01', name='John Doe')  # (2)!\n+    print(user)\n+    #> date_of_birth=datetime.datetime(2022, 1, 1, 0, 0) name='John Doe'\n+\n+    user = User(date_of_birth='2022-01-01', name='John Doe')  # (3)!\n+    print(user)\n+    #> date_of_birth=datetime.datetime(2022, 1, 1, 0, 0) name='John Doe'\n+    ```\n+\n+    1. The field `'date_of_birth'` has an alias `'DOB'`.\n+    2. The model is populated by the alias `'DOB'`.\n+    3. The model is populated by the attribute name `'date_of_birth'`.\n+\n+    !!! warning\n+        You cannot set both `validate_by_alias` and `validate_by_name` to `False`.\n+        This would make it impossible to populate an attribute. A [`PydanticUserError`][pydantic.errors.PydanticUserError]\n+        will be raised if you try to do this.\n+\n+        This also means you can't set `validate_by_alias` to `False` and leave `validate_by_name` unset,\n+        as `validate_by_name` defaults to `False.\n+\n+        See [usage errors](../errors/usage_errors.md#validate-by-alias-and-name-false) for an example.\n+    \"\"\"\n+\n+    serialize_by_alias: bool\n+    \"\"\"\n+    Whether an aliased field should be serialized by its alias. Defaults to `False`.\n+\n+    Note: In v2.11, `serialize_by_alias` was introduced to address the\n+    [popular request](https://github.com/pydantic/pydantic/issues/8379)\n+    for consistency with alias behavior for validation and serialization settings.\n+\n+    The defaults are inconsistent in V2 (aliases are used by default for validation,\n+    but not for serialization), and we anticipate changing this in V3. However, as a patch for now,\n+    we've introduced this configuration setting to allow users to control this behavior.",
      "comment": "I feel like this explanation fits better in a changelog, but maybe we should just describe:\r\n\r\n> Note: this configuration was added in v2.11. In v3, the default value will change to `True`\r\n\r\nOr something similar.",
      "comment_id": 1969783125,
      "user": "Viicos",
      "created_at": "2025-02-25T13:27:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1969783125"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 1045,
      "side": "RIGHT",
      "diff_hunk": "@@ -1025,6 +1033,123 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    validate_by_alias: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its alias. Defaults to `True`.\n+\n+    !!! note\n+        In v2.11, `validate_by_alias` was introduced in conjunction with [`validate_by_name`][pydantic.ConfigDict.validate_by_name]\n+        to empower users with more fine grained validation control. In <v2.11, disabling validation by alias was not possible.\n+\n+    !!! tip\n+        If you set `validate_by_alias` to `False`, you should set `validate_by_name` to `True` to ensure that the field can still be populated.",
      "comment": "Also, what should happen if you set `validate_by_alias=False`, but explicitly set `by_alias=True` or `by_name=True` during validation?",
      "comment_id": 1969787804,
      "user": "Viicos",
      "created_at": "2025-02-25T13:29:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1969787804"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 1045,
      "side": "RIGHT",
      "diff_hunk": "@@ -1025,6 +1033,123 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    validate_by_alias: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its alias. Defaults to `True`.\n+\n+    !!! note\n+        In v2.11, `validate_by_alias` was introduced in conjunction with [`validate_by_name`][pydantic.ConfigDict.validate_by_name]\n+        to empower users with more fine grained validation control. In <v2.11, disabling validation by alias was not possible.\n+\n+    !!! tip\n+        If you set `validate_by_alias` to `False`, you should set `validate_by_name` to `True` to ensure that the field can still be populated.",
      "comment": "> Also, what should happen if you set validate_by_alias=False, but explicitly set by_alias=True or by_name=True during validation?\r\n\r\nValidation time settings always take priority, when set. This is the same with `strict`.",
      "comment_id": 1970135718,
      "user": "sydney-runkle",
      "created_at": "2025-02-25T16:30:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1970135718"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 1045,
      "side": "RIGHT",
      "diff_hunk": "@@ -1025,6 +1033,123 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    validate_by_alias: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its alias. Defaults to `True`.\n+\n+    !!! note\n+        In v2.11, `validate_by_alias` was introduced in conjunction with [`validate_by_name`][pydantic.ConfigDict.validate_by_name]\n+        to empower users with more fine grained validation control. In <v2.11, disabling validation by alias was not possible.\n+\n+    !!! tip\n+        If you set `validate_by_alias` to `False`, you should set `validate_by_name` to `True` to ensure that the field can still be populated.",
      "comment": "I'm sympathetic to the literal pattern argument. If we were starting fully from scratch, I think it might make more sense. Specifically, the boolean traps can be a bit confusing. In particular, the fact that you have to set `validate_by_name=True` if `validate_by_alias=False` explicitly is a bit confusing, especially for new users.\r\n\r\nOne thing we could do to mitigate this challenge is automatically set `validate_by_name=True` if a user sets `validate_By_alias=False`.\r\n\r\nMy thoughts re why we should stick with the 2 boolean flags:\r\n\r\n* It represents less change to this setting compared to a switch to literals - there's already a lot of change going on here, and I'm hesitant to introduce a setting `type` change as well.\r\n* 2 boolean flags provide greater configurability for interaction between config and runtime settings, as you can override one behavior and not the other. It's also helpful to have unset markers for each thing. For example:\r\n\r\n```\r\nM1: validate_by_alias = True, validate_by_name = False\r\nM2: validate_by_alias = False, validate_by_name = True\r\n\r\nruntime setting: by_name = True\r\n\r\n==>\r\n\r\nM1: alias and name validation\r\nM2: name only validation\r\n```\r\n\r\nThis can't be achieved with the literal approach. Either you'd use:\r\n* `validate_by='name'`, and M1 would lose alias validation\r\n* `validate_by='name and alias'` and M2 would no longer avoid validating with alias\r\n\r\n* Autocomplete is easier with boolean flags, and the behavior is relatively intuitive\r\n\r\nAliases are one of the most common (if not the most commonly used) field tool, so I do think this decision is quite important. I also understand that if we go with bools here, we're stuck with that until at least V4. ",
      "comment_id": 1970151411,
      "user": "sydney-runkle",
      "created_at": "2025-02-25T16:37:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1970151411"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 1045,
      "side": "RIGHT",
      "diff_hunk": "@@ -1025,6 +1033,123 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    validate_by_alias: bool\n+    \"\"\"\n+    Whether an aliased field may be populated by its alias. Defaults to `True`.\n+\n+    !!! note\n+        In v2.11, `validate_by_alias` was introduced in conjunction with [`validate_by_name`][pydantic.ConfigDict.validate_by_name]\n+        to empower users with more fine grained validation control. In <v2.11, disabling validation by alias was not possible.\n+\n+    !!! tip\n+        If you set `validate_by_alias` to `False`, you should set `validate_by_name` to `True` to ensure that the field can still be populated.",
      "comment": "Yes, as discussed on Slack, thanks for summing things up here, this might be useful as a reference in case we get questions about the current API.\r\n\r\nAs we discussed as well, defaulting `validate_by_name` to `True` if `validate_by_alias` is set to `False` is postponed after this PR, and should be tackled either before 2.11 or after. Leaving this conversation unresolved so that it's easier to find it later.",
      "comment_id": 1971318650,
      "user": "Viicos",
      "created_at": "2025-02-26T10:16:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1971318650"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/_internal/_config.py",
      "line": 179,
      "side": "RIGHT",
      "diff_hunk": "@@ -172,14 +175,26 @@ def core_config(self, title: str | None) -> core_schema.CoreConfig:\n                 stacklevel=2,\n             )\n \n+        if (populate_by_name := config.get('populate_by_name')) is not None:\n+            # We include this patch for backwards compatibility purposes, but this config setting will be officially removed in v3.0.",
      "comment": "```suggestion\r\n            # We include this patch for backwards compatibility purposes, but this config setting will be deprecated in v3.0, and likely removed in v4.0.\r\n```",
      "comment_id": 1971333294,
      "user": "Viicos",
      "created_at": "2025-02-26T10:25:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1971333294"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/config.py",
      "line": 183,
      "side": "RIGHT",
      "diff_hunk": "@@ -168,30 +168,41 @@ class Model(BaseModel):\n     Whether an aliased field may be populated by its name as given by the model\n     attribute, as well as the alias. Defaults to `False`.\n \n-    Note:\n-        The name of this configuration setting was changed in **v2.0** from\n-        `allow_population_by_field_name` to `populate_by_name`.\n+    !!! warning\n+        `populate_by_name` usage is not recommended in v2.11+ and will be deprecated in v3.\n+        Instead, you should use the [`validate_by_name`][pydantic.config.ConfigDict.validate_by_name] configuration setting.\n \n-    ```python\n-    from pydantic import BaseModel, ConfigDict, Field\n+        When `validate_by_name=True` and `validate_by_alias=True`, this is strictly equivalent to the\n+        previous behavior of `populate_by_name=True`.\n \n-    class User(BaseModel):\n-        model_config = ConfigDict(populate_by_name=True)\n+        In v2.11, we also introduced a [`validate_by_alias`][pydantic.config.ConfigDict.validate_by_alias] setting that introduces more fine grained\n+        control for validation behavior.\n \n-        name: str = Field(alias='full_name')  # (1)!\n-        age: int\n+        Here's how you might go about using the new settings to achieve the same behavior:\n \n-    user = User(full_name='John Doe', age=20)  # (2)!\n-    print(user)\n-    #> name='John Doe' age=20\n-    user = User(name='John Doe', age=20)  # (3)!\n-    print(user)\n-    #> name='John Doe' age=20\n-    ```\n+        ```python",
      "comment": "Could we also change the example to not use `datetime` here?",
      "comment_id": 1971482665,
      "user": "Viicos",
      "created_at": "2025-02-26T12:15:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1971482665"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11468,
      "file_path": "pydantic/main.py",
      "line": 676,
      "side": "RIGHT",
      "diff_hunk": "@@ -670,6 +672,8 @@ def model_validate(\n             strict: Whether to enforce types strictly.\n             from_attributes: Whether to extract data from object attributes.\n             context: Additional context to pass to the validator.\n+            by_alias: Whether to use the field's alias to match the input data to an attribute.\n+            by_name: Whether to use the field's name to match the input data to an attribute.",
      "comment": "```suggestion\r\n            by_alias: Whether to use the field's alias when validating against the provided input data.            by_name: Whether to use the field's name when validating against the provided input data.\r\n```\r\n\r\n(and on the other docstrings)",
      "comment_id": 1971485546,
      "user": "Viicos",
      "created_at": "2025-02-26T12:17:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/11468#discussion_r1971485546"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11246,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1777,
      "side": "RIGHT",
      "diff_hunk": "@@ -1772,14 +1772,19 @@ def _dataclass_schema(\n \n             with self._ns_resolver.push(dataclass), self._config_wrapper_stack.push(config):\n                 if is_pydantic_dataclass(dataclass):\n-                    fields = deepcopy(dataclass.__pydantic_fields__)\n+                    # Copy the field info instances to avoid mutating the `FieldInfo` instances\n+                    # of the generic dataclass generic origin (e.g. `apply_typevars_map` below).\n+                    # Note that we don't apply `deepcopy` on `__pydantic_fields__`, we don't want",
      "comment": "```suggestion\r\n                    # Note that we don't apply `deepcopy` on `__pydantic_fields__` because we don't want\r\n```",
      "comment_id": 1910610457,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T16:20:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/11246#discussion_r1910610457"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11246,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -64,12 +64,11 @@ def __init__(self, metadata: Any):\n     return _PydanticGeneralMetadata  # type: ignore\n \n \n-def _update_fields_from_docstrings(cls: type[Any], fields: dict[str, FieldInfo], config_wrapper: ConfigWrapper) -> None:\n-    if config_wrapper.use_attribute_docstrings:\n-        fields_docs = extract_docstrings_from_cls(cls)\n-        for ann_name, field_info in fields.items():\n-            if field_info.description is None and ann_name in fields_docs:\n-                field_info.description = fields_docs[ann_name]\n+def _update_fields_from_docstrings(cls: type[Any], fields: dict[str, FieldInfo], use_inspect: bool = False) -> None:\n+    fields_docs = extract_docstrings_from_cls(cls, use_inspect=use_inspect)\n+    for ann_name, field_info in fields.items():\n+        if field_info.description is None and ann_name in fields_docs:\n+            field_info.description = fields_docs[ann_name]",
      "comment": "Re letting callers decide if this is necessary - I assume this is for general cleanliness and to avoid the overhead of a function call if not necessary?",
      "comment_id": 1910615092,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T16:22:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/11246#discussion_r1910615092"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11246,
      "file_path": "pydantic/dataclasses.py",
      "line": 365,
      "side": "LEFT",
      "diff_hunk": "@@ -362,6 +366,6 @@ def is_pydantic_dataclass(class_: type[Any], /) -> TypeGuard[type[PydanticDatacl\n         `True` if the class is a pydantic dataclass, `False` otherwise.\n     \"\"\"\n     try:\n-        return '__pydantic_validator__' in class_.__dict__ and dataclasses.is_dataclass(class_)",
      "comment": "Can't we just check `__is_pydantic_dataclass__` here instead?",
      "comment_id": 1913287896,
      "user": "sydney-runkle",
      "created_at": "2025-01-13T14:33:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/11246#discussion_r1913287896"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11721,
      "file_path": "pydantic/json_schema.py",
      "line": 1123,
      "side": "RIGHT",
      "diff_hunk": "@@ -1112,31 +1112,41 @@ def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaVal\n         if default is NoDefault:\n             return json_schema\n \n+        def _get_ser_schema(schema: CoreSchema) -> core_schema.PlainSerializerFunctionSerSchema | None:\n+            if (\n+                (ser_schema := schema.get('serialization'))\n+                and ser_schema['type'] == 'function-plain'\n+                and not ser_schema.get('info_arg')\n+            ):\n+                return ser_schema\n+            if _core_utils.is_function_with_inner_schema(schema):\n+                return _get_ser_schema(schema['schema'])",
      "comment": "Looks like this function doesn't capture any state from the surrounding body, maybe move it to the top level to avoid the perf hit of creating a new function object each time?",
      "comment_id": 2034929710,
      "user": "davidhewitt",
      "created_at": "2025-04-09T09:30:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/11721#discussion_r2034929710"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11658,
      "file_path": "tests/test_types.py",
      "line": 6958,
      "side": "RIGHT",
      "diff_hunk": "@@ -6951,17 +6951,23 @@ class Foo(BaseModel):\n     assert exc_info.value.errors(include_url=False) == errors\n \n \n-def test_mutable_mapping() -> None:\n+def test_mutable_mapping_userdict_subclass() -> None:\n     \"\"\"Addresses https://github.com/pydantic/pydantic/issues/9549.\n \n     Note - we still don't do a good job of handling subclasses, as we convert the input to a dict\n     via the MappingValidator annotation's schema.",
      "comment": "Good catch -- well the `MappingValidator` is not a thing anymore but I think the comment is still relevant.",
      "comment_id": 2025556029,
      "user": "Viicos",
      "created_at": "2025-04-02T20:34:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/11658#discussion_r2025556029"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11572,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1998,
      "side": "RIGHT",
      "diff_hunk": "@@ -1905,27 +1949,58 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n \n         TODO support functional validators once we support them in Config\n         \"\"\"\n-        sig = signature(function)\n-        globalns, localns = self._types_namespace\n-        type_hints = _typing_extra.get_function_type_hints(function, globalns=globalns, localns=localns)\n+        arguments_schema = self._arguments_schema(function)\n+\n+        return_schema: core_schema.CoreSchema | None = None\n+        config_wrapper = self._config_wrapper\n+        if config_wrapper.validate_return:\n+            sig = signature(function)\n+            return_hint = sig.return_annotation\n+            if return_hint is not sig.empty:\n+                globalns, localns = self._types_namespace\n+                type_hints = _typing_extra.get_function_type_hints(\n+                    function, globalns=globalns, localns=localns, include_keys={'return'}\n+                )\n+                return_schema = self.generate_schema(type_hints['return'])\n \n+        return core_schema.call_schema(\n+            arguments_schema,\n+            function,\n+            return_schema=return_schema,\n+        )\n+\n+    def _arguments_schema(\n+        self, function: ValidateCallSupportedTypes, parameters_callback: Callable[[int, str, Any], Any] | None = None\n+    ) -> core_schema.ArgumentsSchema:\n+        \"\"\"Generate schema for a Signature.\"\"\"\n         mode_lookup: dict[_ParameterKind, Literal['positional_only', 'positional_or_keyword', 'keyword_only']] = {\n             Parameter.POSITIONAL_ONLY: 'positional_only',\n             Parameter.POSITIONAL_OR_KEYWORD: 'positional_or_keyword',\n             Parameter.KEYWORD_ONLY: 'keyword_only',\n         }\n \n+        sig = signature(function)\n+        globalns, localns = self._types_namespace\n+        type_hints = _typing_extra.get_function_type_hints(function, globalns=globalns, localns=localns)\n+\n         arguments_list: list[core_schema.ArgumentsParameter] = []\n         var_args_schema: core_schema.CoreSchema | None = None\n         var_kwargs_schema: core_schema.CoreSchema | None = None\n         var_kwargs_mode: core_schema.VarKwargsMode | None = None\n \n-        for name, p in sig.parameters.items():\n+        for i, (name, p) in enumerate(sig.parameters.items()):\n             if p.annotation is sig.empty:\n                 annotation = typing.cast(Any, Any)\n             else:\n                 annotation = type_hints[name]\n \n+            if parameters_callback is not None:\n+                from pydantic.validate_call_decorator import SKIP",
      "comment": "```suggestion\r\n                from ..validate_call_decorator import SKIP\r\n```\r\nlooks like we mostly do relative imports in this file.\r\n\r\nAlso shouldn't this be outside the for loop?",
      "comment_id": 2006053347,
      "user": "samuelcolvin",
      "created_at": "2025-03-20T16:42:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11572#discussion_r2006053347"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11572,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2085,
      "side": "RIGHT",
      "diff_hunk": "@@ -1958,27 +2033,80 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n \n                     var_kwargs_mode = 'unpacked-typed-dict'\n                     var_kwargs_schema = self._typed_dict_schema(unpack_type, get_origin(unpack_type))\n+\n+        return core_schema.arguments_schema(\n+            arguments_list,\n+            var_args_schema=var_args_schema,\n+            var_kwargs_mode=var_kwargs_mode,\n+            var_kwargs_schema=var_kwargs_schema,\n+            validate_by_name=self._config_wrapper.validate_by_name,\n+        )\n+\n+    def _arguments_v3_schema(\n+        self, function: ValidateCallSupportedTypes, parameters_callback: Callable[[int, str, Any], Any] | None = None\n+    ) -> core_schema.ArgumentsV3Schema:\n+        mode_lookup: dict[\n+            _ParameterKind, Literal['positional_only', 'positional_or_keyword', 'var_args', 'keyword_only']\n+        ] = {\n+            Parameter.POSITIONAL_ONLY: 'positional_only',\n+            Parameter.POSITIONAL_OR_KEYWORD: 'positional_or_keyword',\n+            Parameter.VAR_POSITIONAL: 'var_args',\n+            Parameter.KEYWORD_ONLY: 'keyword_only',\n+        }\n+\n+        sig = signature(function)\n+        globalns, localns = self._types_namespace\n+        type_hints = _typing_extra.get_function_type_hints(function, globalns=globalns, localns=localns)\n+\n+        parameters_list: list[core_schema.ArgumentsV3Parameter] = []\n+\n+        for i, (name, p) in enumerate(sig.parameters.items()):\n+            if p.annotation is sig.empty:\n+                annotation = typing.cast(Any, Any)\n+            else:\n+                annotation = type_hints[name]\n+\n+            if parameters_callback is not None:\n+                from pydantic.validate_call_decorator import SKIP\n+\n+                result = parameters_callback(i, name, annotation)\n+                if result is SKIP:\n+                    continue\n+\n+            parameter_mode = mode_lookup.get(p.kind)\n+            if parameter_mode is None:\n+                assert p.kind == Parameter.VAR_KEYWORD, p.kind\n+\n+                unpack_type = _typing_extra.unpack_type(annotation)\n+                if unpack_type is not None:\n+                    origin = get_origin(unpack_type) or unpack_type\n+                    if not is_typeddict(origin):\n+                        raise PydanticUserError(\n+                            f'Expected a `TypedDict` class, got {unpack_type!r}', code='unpack-typed-dict'",
      "comment": "```suggestion\r\n                            f'Expected a `TypedDict` class for kwargs unpacking, got {unpack_type!r}', code='unpack-typed-dict'\r\n```\r\nor something",
      "comment_id": 2006058198,
      "user": "samuelcolvin",
      "created_at": "2025-03-20T16:45:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11572#discussion_r2006058198"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11572,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2085,
      "side": "RIGHT",
      "diff_hunk": "@@ -1958,27 +2033,80 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n \n                     var_kwargs_mode = 'unpacked-typed-dict'\n                     var_kwargs_schema = self._typed_dict_schema(unpack_type, get_origin(unpack_type))\n+\n+        return core_schema.arguments_schema(\n+            arguments_list,\n+            var_args_schema=var_args_schema,\n+            var_kwargs_mode=var_kwargs_mode,\n+            var_kwargs_schema=var_kwargs_schema,\n+            validate_by_name=self._config_wrapper.validate_by_name,\n+        )\n+\n+    def _arguments_v3_schema(\n+        self, function: ValidateCallSupportedTypes, parameters_callback: Callable[[int, str, Any], Any] | None = None\n+    ) -> core_schema.ArgumentsV3Schema:\n+        mode_lookup: dict[\n+            _ParameterKind, Literal['positional_only', 'positional_or_keyword', 'var_args', 'keyword_only']\n+        ] = {\n+            Parameter.POSITIONAL_ONLY: 'positional_only',\n+            Parameter.POSITIONAL_OR_KEYWORD: 'positional_or_keyword',\n+            Parameter.VAR_POSITIONAL: 'var_args',\n+            Parameter.KEYWORD_ONLY: 'keyword_only',\n+        }\n+\n+        sig = signature(function)\n+        globalns, localns = self._types_namespace\n+        type_hints = _typing_extra.get_function_type_hints(function, globalns=globalns, localns=localns)\n+\n+        parameters_list: list[core_schema.ArgumentsV3Parameter] = []\n+\n+        for i, (name, p) in enumerate(sig.parameters.items()):\n+            if p.annotation is sig.empty:\n+                annotation = typing.cast(Any, Any)\n+            else:\n+                annotation = type_hints[name]\n+\n+            if parameters_callback is not None:\n+                from pydantic.validate_call_decorator import SKIP\n+\n+                result = parameters_callback(i, name, annotation)\n+                if result is SKIP:\n+                    continue\n+\n+            parameter_mode = mode_lookup.get(p.kind)\n+            if parameter_mode is None:\n+                assert p.kind == Parameter.VAR_KEYWORD, p.kind\n+\n+                unpack_type = _typing_extra.unpack_type(annotation)\n+                if unpack_type is not None:\n+                    origin = get_origin(unpack_type) or unpack_type\n+                    if not is_typeddict(origin):\n+                        raise PydanticUserError(\n+                            f'Expected a `TypedDict` class, got {unpack_type!r}', code='unpack-typed-dict'",
      "comment": "```suggestion\r\n                            f'Expected a `TypedDict` class for kwargs unpacking, got {unpack_type!r}', code='unpack-typed-dict'\r\n```\r\nor something",
      "comment_id": 2006058230,
      "user": "samuelcolvin",
      "created_at": "2025-03-20T16:45:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/11572#discussion_r2006058230"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11572,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1998,
      "side": "RIGHT",
      "diff_hunk": "@@ -1905,27 +1949,58 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n \n         TODO support functional validators once we support them in Config\n         \"\"\"\n-        sig = signature(function)\n-        globalns, localns = self._types_namespace\n-        type_hints = _typing_extra.get_function_type_hints(function, globalns=globalns, localns=localns)\n+        arguments_schema = self._arguments_schema(function)\n+\n+        return_schema: core_schema.CoreSchema | None = None\n+        config_wrapper = self._config_wrapper\n+        if config_wrapper.validate_return:\n+            sig = signature(function)\n+            return_hint = sig.return_annotation\n+            if return_hint is not sig.empty:\n+                globalns, localns = self._types_namespace\n+                type_hints = _typing_extra.get_function_type_hints(\n+                    function, globalns=globalns, localns=localns, include_keys={'return'}\n+                )\n+                return_schema = self.generate_schema(type_hints['return'])\n \n+        return core_schema.call_schema(\n+            arguments_schema,\n+            function,\n+            return_schema=return_schema,\n+        )\n+\n+    def _arguments_schema(\n+        self, function: ValidateCallSupportedTypes, parameters_callback: Callable[[int, str, Any], Any] | None = None\n+    ) -> core_schema.ArgumentsSchema:\n+        \"\"\"Generate schema for a Signature.\"\"\"\n         mode_lookup: dict[_ParameterKind, Literal['positional_only', 'positional_or_keyword', 'keyword_only']] = {\n             Parameter.POSITIONAL_ONLY: 'positional_only',\n             Parameter.POSITIONAL_OR_KEYWORD: 'positional_or_keyword',\n             Parameter.KEYWORD_ONLY: 'keyword_only',\n         }\n \n+        sig = signature(function)\n+        globalns, localns = self._types_namespace\n+        type_hints = _typing_extra.get_function_type_hints(function, globalns=globalns, localns=localns)\n+\n         arguments_list: list[core_schema.ArgumentsParameter] = []\n         var_args_schema: core_schema.CoreSchema | None = None\n         var_kwargs_schema: core_schema.CoreSchema | None = None\n         var_kwargs_mode: core_schema.VarKwargsMode | None = None\n \n-        for name, p in sig.parameters.items():\n+        for i, (name, p) in enumerate(sig.parameters.items()):\n             if p.annotation is sig.empty:\n                 annotation = typing.cast(Any, Any)\n             else:\n                 annotation = type_hints[name]\n \n+            if parameters_callback is not None:\n+                from pydantic.validate_call_decorator import SKIP",
      "comment": "I wanted to avoid the import unless necessary (if a callback is defined). But I don't mind either way.",
      "comment_id": 2012421186,
      "user": "Viicos",
      "created_at": "2025-03-25T15:52:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/11572#discussion_r2012421186"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11572,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1982,
      "side": "RIGHT",
      "diff_hunk": "@@ -1905,27 +1958,58 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n \n         TODO support functional validators once we support them in Config\n         \"\"\"\n-        sig = signature(function)\n-        globalns, localns = self._types_namespace\n-        type_hints = _typing_extra.get_function_type_hints(function, globalns=globalns, localns=localns)\n+        arguments_schema = self._arguments_schema(function)\n+\n+        return_schema: core_schema.CoreSchema | None = None\n+        config_wrapper = self._config_wrapper\n+        if config_wrapper.validate_return:\n+            sig = signature(function)\n+            return_hint = sig.return_annotation\n+            if return_hint is not sig.empty:\n+                globalns, localns = self._types_namespace\n+                type_hints = _typing_extra.get_function_type_hints(\n+                    function, globalns=globalns, localns=localns, include_keys={'return'}\n+                )\n+                return_schema = self.generate_schema(type_hints['return'])\n \n+        return core_schema.call_schema(\n+            arguments_schema,\n+            function,\n+            return_schema=return_schema,\n+        )\n+\n+    def _arguments_schema(\n+        self, function: ValidateCallSupportedTypes, parameters_callback: Callable[[int, str, Any], Any] | None = None",
      "comment": "```suggestion\r\n        self, function: ValidateCallSupportedTypes, parameters_callback: Callable[[int, str, Any], None | Literal['skip']] | None = None\r\n```",
      "comment_id": 2016861064,
      "user": "samuelcolvin",
      "created_at": "2025-03-27T14:52:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/11572#discussion_r2016861064"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11572,
      "file_path": "pydantic/experimental/arguments_schema.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,44 @@\n+\"\"\"Experimental module exposing a function to generate a core schema that validates callable arguments.\"\"\"\n+\n+from __future__ import annotations\n+\n+from collections.abc import Callable\n+from typing import Any, Literal\n+\n+from pydantic_core import CoreSchema\n+\n+from pydantic import ConfigDict\n+from pydantic._internal import _config, _generate_schema, _namespace_utils\n+\n+\n+def generate_arguments_schema(\n+    func: Callable[..., Any],\n+    schema_type: Literal['arguments', 'arguments-v3'] = 'arguments-v3',\n+    parameters_callback: Callable[[int, str, Any], Any] | None = None,",
      "comment": "```suggestion\r\n    parameters_callback: Callable[[int, str, Any], Literal[None, 'skip']] | None = None,\r\n```",
      "comment_id": 2017090492,
      "user": "dmontagu",
      "created_at": "2025-03-27T16:40:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11572#discussion_r2017090492"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11611,
      "file_path": "pydantic/networks.py",
      "line": 377,
      "side": "RIGHT",
      "diff_hunk": "@@ -374,7 +374,7 @@ def query(self) -> str | None:\n     def query_params(self) -> list[tuple[str, str]]:\n         \"\"\"The query part of the URL as a list of key-value pairs.\n \n-        e.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?query#fragment`\n+        e.g. `[('baz', 'qux')]` in `https://foo.com,bar.com/path?baz=qux#fragment`",
      "comment": "```suggestion\r\n        e.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?foo=bar#fragment`\r\n```",
      "comment_id": 2012126439,
      "user": "Viicos",
      "created_at": "2025-03-25T13:38:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/11611#discussion_r2012126439"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11580,
      "file_path": "pydantic/networks.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -217,6 +217,14 @@ def unicode_string(self) -> str:\n         \"\"\"\n         return self._url.unicode_string()\n \n+    @property\n+    def encoded(self) -> str:",
      "comment": "```suggestion\r\n    def encoded_string(self) -> str:\r\n```",
      "comment_id": 2002736585,
      "user": "Viicos",
      "created_at": "2025-03-19T08:31:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/11580#discussion_r2002736585"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10303,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 388,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,31 +372,20 @@ def __init__(\n         types_namespace: dict[str, Any] | None,\n         typevars_map: dict[Any, Any] | None = None,\n     ) -> None:\n-        # we need a stack for recursing into child models\n+        # we need a stack for recursing into nested models\n         self._config_wrapper_stack = ConfigWrapperStack(config_wrapper)\n         self._types_namespace_stack = TypesNamespaceStack(types_namespace)\n         self._typevars_map = typevars_map\n         self.field_name_stack = _FieldNameStack()\n         self.model_type_stack = _ModelTypeStack()\n         self.defs = _Definitions()\n \n-    @classmethod\n-    def __from_parent(\n-        cls,\n-        config_wrapper_stack: ConfigWrapperStack,\n-        types_namespace_stack: TypesNamespaceStack,\n-        model_type_stack: _ModelTypeStack,\n-        typevars_map: dict[Any, Any] | None,\n-        defs: _Definitions,\n-    ) -> GenerateSchema:\n-        obj = cls.__new__(cls)\n-        obj._config_wrapper_stack = config_wrapper_stack\n-        obj._types_namespace_stack = types_namespace_stack\n-        obj.model_type_stack = model_type_stack\n-        obj._typevars_map = typevars_map\n-        obj.field_name_stack = _FieldNameStack()\n-        obj.defs = defs\n-        return obj\n+    def __init_subclass__(cls, **kwargs) -> None:\n+        super().__init_subclass__(**kwargs)\n+        warnings.warn(\n+            'Subclassing `GenerateSchema` is not supported. The API is highly subject to change in minor versions.',\n+            UserWarning,\n+        )",
      "comment": "```suggestion\r\n            UserWarning,\r\n            stack_level=2,\r\n        )\r\n```",
      "comment_id": 1745822281,
      "user": "Viicos",
      "created_at": "2024-09-05T16:08:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10303#discussion_r1745822281"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10303,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 383,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,31 +372,20 @@ def __init__(\n         types_namespace: dict[str, Any] | None,\n         typevars_map: dict[Any, Any] | None = None,\n     ) -> None:\n-        # we need a stack for recursing into child models\n+        # we need a stack for recursing into nested models\n         self._config_wrapper_stack = ConfigWrapperStack(config_wrapper)\n         self._types_namespace_stack = TypesNamespaceStack(types_namespace)\n         self._typevars_map = typevars_map\n         self.field_name_stack = _FieldNameStack()\n         self.model_type_stack = _ModelTypeStack()\n         self.defs = _Definitions()\n \n-    @classmethod\n-    def __from_parent(\n-        cls,\n-        config_wrapper_stack: ConfigWrapperStack,\n-        types_namespace_stack: TypesNamespaceStack,\n-        model_type_stack: _ModelTypeStack,\n-        typevars_map: dict[Any, Any] | None,\n-        defs: _Definitions,\n-    ) -> GenerateSchema:\n-        obj = cls.__new__(cls)\n-        obj._config_wrapper_stack = config_wrapper_stack\n-        obj._types_namespace_stack = types_namespace_stack\n-        obj.model_type_stack = model_type_stack\n-        obj._typevars_map = typevars_map\n-        obj.field_name_stack = _FieldNameStack()\n-        obj.defs = defs\n-        return obj\n+    def __init_subclass__(cls, **kwargs) -> None:",
      "comment": "```suggestion\r\n    def __init_subclass__(cls) -> None:\r\n```\r\nWe can safely omit the kwargs here",
      "comment_id": 1745823050,
      "user": "Viicos",
      "created_at": "2024-09-05T16:09:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/10303#discussion_r1745823050"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10303,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 418,
      "side": "LEFT",
      "diff_hunk": "@@ -406,25 +395,10 @@ def _config_wrapper(self) -> ConfigWrapper:\n     def _types_namespace(self) -> dict[str, Any] | None:\n         return self._types_namespace_stack.tail\n \n-    @property\n-    def _current_generate_schema(self) -> GenerateSchema:\n-        cls = self._config_wrapper.schema_generator or GenerateSchema\n-        return cls.__from_parent(\n-            self._config_wrapper_stack,\n-            self._types_namespace_stack,\n-            self.model_type_stack,\n-            self._typevars_map,\n-            self.defs,\n-        )",
      "comment": "But I'm wondering, what was the purpose of creating new instances, if every attribute was being passed in?\r\n\r\nApart from `field_name_stack` where a new instance is created. By the way, doesn't that break anything?",
      "comment_id": 1745825147,
      "user": "Viicos",
      "created_at": "2024-09-05T16:11:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10303#discussion_r1745825147"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10303,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 418,
      "side": "LEFT",
      "diff_hunk": "@@ -406,25 +395,10 @@ def _config_wrapper(self) -> ConfigWrapper:\n     def _types_namespace(self) -> dict[str, Any] | None:\n         return self._types_namespace_stack.tail\n \n-    @property\n-    def _current_generate_schema(self) -> GenerateSchema:\n-        cls = self._config_wrapper.schema_generator or GenerateSchema\n-        return cls.__from_parent(\n-            self._config_wrapper_stack,\n-            self._types_namespace_stack,\n-            self.model_type_stack,\n-            self._typevars_map,\n-            self.defs,\n-        )",
      "comment": "The purpose of creating new instances was to give the model a change to inject its custom core schema generator (some subclass of `GenerateSchema`).\r\n\r\nRe `field_name_stack` - I believe it continues to operate as expected.",
      "comment_id": 1745832649,
      "user": "sydney-runkle",
      "created_at": "2024-09-05T16:16:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/10303#discussion_r1745832649"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10303,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 388,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,31 +372,20 @@ def __init__(\n         types_namespace: dict[str, Any] | None,\n         typevars_map: dict[Any, Any] | None = None,\n     ) -> None:\n-        # we need a stack for recursing into child models\n+        # we need a stack for recursing into nested models\n         self._config_wrapper_stack = ConfigWrapperStack(config_wrapper)\n         self._types_namespace_stack = TypesNamespaceStack(types_namespace)\n         self._typevars_map = typevars_map\n         self.field_name_stack = _FieldNameStack()\n         self.model_type_stack = _ModelTypeStack()\n         self.defs = _Definitions()\n \n-    @classmethod\n-    def __from_parent(\n-        cls,\n-        config_wrapper_stack: ConfigWrapperStack,\n-        types_namespace_stack: TypesNamespaceStack,\n-        model_type_stack: _ModelTypeStack,\n-        typevars_map: dict[Any, Any] | None,\n-        defs: _Definitions,\n-    ) -> GenerateSchema:\n-        obj = cls.__new__(cls)\n-        obj._config_wrapper_stack = config_wrapper_stack\n-        obj._types_namespace_stack = types_namespace_stack\n-        obj.model_type_stack = model_type_stack\n-        obj._typevars_map = typevars_map\n-        obj.field_name_stack = _FieldNameStack()\n-        obj.defs = defs\n-        return obj\n+    def __init_subclass__(cls, **kwargs) -> None:\n+        super().__init_subclass__(**kwargs)\n+        warnings.warn(\n+            'Subclassing `GenerateSchema` is not supported. The API is highly subject to change in minor versions.',\n+            UserWarning,\n+        )",
      "comment": " I don't think this is actually right - then we don't get warnings in the associated test. I added a stacklevel to the other warning, though.",
      "comment_id": 1745838375,
      "user": "sydney-runkle",
      "created_at": "2024-09-05T16:21:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10303#discussion_r1745838375"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10303,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 388,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,31 +372,20 @@ def __init__(\n         types_namespace: dict[str, Any] | None,\n         typevars_map: dict[Any, Any] | None = None,\n     ) -> None:\n-        # we need a stack for recursing into child models\n+        # we need a stack for recursing into nested models\n         self._config_wrapper_stack = ConfigWrapperStack(config_wrapper)\n         self._types_namespace_stack = TypesNamespaceStack(types_namespace)\n         self._typevars_map = typevars_map\n         self.field_name_stack = _FieldNameStack()\n         self.model_type_stack = _ModelTypeStack()\n         self.defs = _Definitions()\n \n-    @classmethod\n-    def __from_parent(\n-        cls,\n-        config_wrapper_stack: ConfigWrapperStack,\n-        types_namespace_stack: TypesNamespaceStack,\n-        model_type_stack: _ModelTypeStack,\n-        typevars_map: dict[Any, Any] | None,\n-        defs: _Definitions,\n-    ) -> GenerateSchema:\n-        obj = cls.__new__(cls)\n-        obj._config_wrapper_stack = config_wrapper_stack\n-        obj._types_namespace_stack = types_namespace_stack\n-        obj.model_type_stack = model_type_stack\n-        obj._typevars_map = typevars_map\n-        obj.field_name_stack = _FieldNameStack()\n-        obj.defs = defs\n-        return obj\n+    def __init_subclass__(cls, **kwargs) -> None:\n+        super().__init_subclass__(**kwargs)\n+        warnings.warn(\n+            'Subclassing `GenerateSchema` is not supported. The API is highly subject to change in minor versions.',\n+            UserWarning,\n+        )",
      "comment": "It's because you still had `kwargs` used in the body but it was undefined. So the warn call was never reached.",
      "comment_id": 1745985155,
      "user": "Viicos",
      "created_at": "2024-09-05T18:25:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10303#discussion_r1745985155"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10303,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 418,
      "side": "LEFT",
      "diff_hunk": "@@ -406,25 +395,10 @@ def _config_wrapper(self) -> ConfigWrapper:\n     def _types_namespace(self) -> dict[str, Any] | None:\n         return self._types_namespace_stack.tail\n \n-    @property\n-    def _current_generate_schema(self) -> GenerateSchema:\n-        cls = self._config_wrapper.schema_generator or GenerateSchema\n-        return cls.__from_parent(\n-            self._config_wrapper_stack,\n-            self._types_namespace_stack,\n-            self.model_type_stack,\n-            self._typevars_map,\n-            self.defs,\n-        )",
      "comment": "In theory this can lead to inconsistent state, where in the process of generating a core schema for a field (and thus having one field name in the stack), we end up generating something else. However, the field names are only used when generating schema for `*Validator` classes, that can only be used when defining a field (meaning a new field name will be added to the stack, so it doesn't matter if the stack was reset or not).",
      "comment_id": 1746032390,
      "user": "Viicos",
      "created_at": "2024-09-05T19:08:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10303#discussion_r1746032390"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10303,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 418,
      "side": "LEFT",
      "diff_hunk": "@@ -406,25 +395,10 @@ def _config_wrapper(self) -> ConfigWrapper:\n     def _types_namespace(self) -> dict[str, Any] | None:\n         return self._types_namespace_stack.tail\n \n-    @property\n-    def _current_generate_schema(self) -> GenerateSchema:\n-        cls = self._config_wrapper.schema_generator or GenerateSchema\n-        return cls.__from_parent(\n-            self._config_wrapper_stack,\n-            self._types_namespace_stack,\n-            self.model_type_stack,\n-            self._typevars_map,\n-            self.defs,\n-        )",
      "comment": "Hmm. Interesting. Not sure I follow entirely - happy to take a closer look together and potentially refactor that structure.",
      "comment_id": 1746081486,
      "user": "sydney-runkle",
      "created_at": "2024-09-05T19:48:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10303#discussion_r1746081486"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10303,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 418,
      "side": "LEFT",
      "diff_hunk": "@@ -406,25 +395,10 @@ def _config_wrapper(self) -> ConfigWrapper:\n     def _types_namespace(self) -> dict[str, Any] | None:\n         return self._types_namespace_stack.tail\n \n-    @property\n-    def _current_generate_schema(self) -> GenerateSchema:\n-        cls = self._config_wrapper.schema_generator or GenerateSchema\n-        return cls.__from_parent(\n-            self._config_wrapper_stack,\n-            self._types_namespace_stack,\n-            self.model_type_stack,\n-            self._typevars_map,\n-            self.defs,\n-        )",
      "comment": "For instance:\r\n\r\n```python\r\nclass Sub(BaseModel):\r\n    f: 'Forward'\r\n\r\nForward = int\r\n\r\nclass Model(BaseModel):\r\n    sub: Sub\r\n```\r\n\r\nWhen `Sub` is defined, schema generation fails because `Forward` isn't defined. when `Model.sub` is being defined, the field name stack is `['sub']`. We try to get the core schema of `Sub` but it needs to be rebuilt. Previous to your change, we would create a new `GenerateSchema` instance with an empty field name stack. But now, we build the core schema of `Sub` with the same instance. When we try to build the core schema of `Sub.f`, the field name stack is `['sub', 'f']`, so it is still valid. It can be inconsistent if we try to build something _not_ related to a field in `Sub` (e.g. evaluating the type annotation of `__pydantic_extra__`, etc), but anyway the field name stack is only used by `*Validator` classes and such classes could only be used (in our example) in the context of field `f`, so the field name stack would be `['sub', 'f']` so all good.",
      "comment_id": 1746117326,
      "user": "Viicos",
      "created_at": "2024-09-05T20:24:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10303#discussion_r1746117326"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11516,
      "file_path": "tests/test_discriminated_union.py",
      "line": 2153,
      "side": "RIGHT",
      "diff_hunk": "@@ -2149,6 +2150,7 @@ class Yard(BaseModel):\n     assert str(yard_dict['pet']['type']) == 'dog'\n \n \n+@pytest.mark.thread_unsafe(reason='Passes on multithreaded. This needs to be investigated further.')",
      "comment": "While all the other tests marked as thread unsafe made sense, I have no idea why this one passes. Core schemas are identical, and verified it isn't a late lambda binding issue. Might be something in core?",
      "comment_id": 1978024887,
      "user": "Viicos",
      "created_at": "2025-03-03T18:56:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/11516#discussion_r1978024887"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11516,
      "file_path": "pydantic/_internal/_generics.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -94,7 +94,7 @@ def __delitem__(self, key: KT) -> None:\n # and discover later on that we need to re-add all this infrastructure...\n # _GENERIC_TYPES_CACHE = DeepChainMap(GenericTypesCache(), LimitedDict())\n \n-_GENERIC_TYPES_CACHE = GenericTypesCache()\n+_GENERIC_TYPES_CACHE: ContextVar[GenericTypesCache | None] = ContextVar('_GENERIC_TYPES_CACHE', default=None)",
      "comment": "The idea here is to make a separate cache for each thread?",
      "comment_id": 1981793648,
      "user": "davidhewitt",
      "created_at": "2025-03-05T16:44:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/11516#discussion_r1981793648"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11516,
      "file_path": "pydantic/_internal/_generics.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -94,7 +94,7 @@ def __delitem__(self, key: KT) -> None:\n # and discover later on that we need to re-add all this infrastructure...\n # _GENERIC_TYPES_CACHE = DeepChainMap(GenericTypesCache(), LimitedDict())\n \n-_GENERIC_TYPES_CACHE = GenericTypesCache()\n+_GENERIC_TYPES_CACHE: ContextVar[GenericTypesCache | None] = ContextVar('_GENERIC_TYPES_CACHE', default=None)",
      "comment": "Yes exactly, identical to the recursion cache:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/bff747748e57c0db384dbd0df886fa623fa3a703/pydantic/_internal/_generics.py#L396",
      "comment_id": 1988894827,
      "user": "Viicos",
      "created_at": "2025-03-11T10:17:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/11516#discussion_r1988894827"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_generics.py",
      "line": 277,
      "side": "RIGHT",
      "diff_hunk": "@@ -266,15 +268,13 @@ def replace_types(type_: Any, type_map: Mapping[TypeVar, Any] | None) -> Any:\n         return type_\n \n     type_args = get_args(type_)\n+    origin_type = get_origin(type_)\n \n-    if _typing_extra.is_annotated(type_):\n+    if typing_objects.is_annotated(origin_type):\n         annotated_type, *annotations = type_args\n-        annotated = replace_types(annotated_type, type_map)\n-        for annotation in annotations:\n-            annotated = typing.Annotated[annotated, annotation]\n-        return annotated\n-\n-    origin_type = get_origin(type_)\n+        annotated_type = replace_types(annotated_type, type_map)\n+        # TODO remove parentheses when we drop support for Python 3.10:\n+        return Annotated[(annotated_type, *annotations)]",
      "comment": "In Python 3.11, `Annotated[annotated_type, *annotations]` no longer raise a Syntax error. The workaround on main was to create an `Annotated` form for each metadata element, but doing it in one go is cleaner/more efficient.",
      "comment_id": 1971300939,
      "user": "Viicos",
      "created_at": "2025-02-26T10:05:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1971300939"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/fields.py",
      "line": 409,
      "side": "RIGHT",
      "diff_hunk": "@@ -394,68 +395,68 @@ class MyModel(pydantic.BaseModel):\n                 code='unevaluable-type-annotation',\n             )\n \n-        final = _typing_extra.is_finalvar(annotation)\n-        if final and _typing_extra.is_generic_alias(annotation):\n-            annotation = typing_extensions.get_args(annotation)[0]\n+        try:\n+            inspected_ann = inspect_annotation(\n+                annotation,\n+                annotation_source=_source,\n+                unpack_type_aliases='skip',\n+            )\n+        except ForbiddenQualifier as e:\n+            raise PydanticForbiddenQualifier(e.qualifier, annotation)\n \n-        if isinstance(default, FieldInfo):\n-            if _typing_extra.is_annotated(annotation):\n-                annotation, *annotation_metadata = typing_extensions.get_args(annotation)\n-            else:\n-                annotation_metadata = []\n+        # TODO check for classvar and error?\n \n-            default.annotation = annotation\n-            default.metadata += annotation_metadata\n-            default = default.merge_field_infos(\n-                *[x for x in annotation_metadata if isinstance(x, FieldInfo)], default, annotation=default.annotation\n+        # TODO infer from the default",
      "comment": "This can wait for v3, as if the field has a default it is currently treated as a class var anyway. This todo is thus linked in https://github.com/pydantic/pydantic/issues/11119.",
      "comment_id": 1971313841,
      "user": "Viicos",
      "created_at": "2025-02-26T10:13:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1971313841"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_generics.py",
      "line": 277,
      "side": "RIGHT",
      "diff_hunk": "@@ -266,15 +268,13 @@ def replace_types(type_: Any, type_map: Mapping[TypeVar, Any] | None) -> Any:\n         return type_\n \n     type_args = get_args(type_)\n+    origin_type = get_origin(type_)\n \n-    if _typing_extra.is_annotated(type_):\n+    if typing_objects.is_annotated(origin_type):\n         annotated_type, *annotations = type_args\n-        annotated = replace_types(annotated_type, type_map)\n-        for annotation in annotations:\n-            annotated = typing.Annotated[annotated, annotation]\n-        return annotated\n-\n-    origin_type = get_origin(type_)\n+        annotated_type = replace_types(annotated_type, type_map)\n+        # TODO remove parentheses when we drop support for Python 3.10:\n+        return Annotated[(annotated_type, *annotations)]",
      "comment": "Sounds good, thanks for including 3.10 explicitly in the comment, this will make it much easier to drop later on.",
      "comment_id": 1972564553,
      "user": "sydney-runkle",
      "created_at": "2025-02-26T23:13:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1972564553"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,9 +8,10 @@\n from pydantic_core import CoreSchema, core_schema\n from pydantic_core import validate_core_schema as _validate_core_schema\n from typing_extensions import TypeGuard, get_args, get_origin\n+from typing_inspection import typing_objects\n \n from . import _repr\n-from ._typing_extra import is_generic_alias, is_type_alias_type\n+from ._typing_extra import is_generic_alias",
      "comment": "Why is `is_generic_alias` not included in `typing_inspection`?",
      "comment_id": 1972625739,
      "user": "sydney-runkle",
      "created_at": "2025-02-27T00:33:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1972625739"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -286,7 +287,7 @@ def _warn_on_nested_alias_in_annotation(ann_type: type[Any], ann_name: str) -> N\n     args = getattr(ann_type, '__args__', None)\n     if args:\n         for anno_arg in args:\n-            if _typing_extra.is_annotated(anno_arg):\n+            if typing_objects.is_annotated(get_origin(anno_arg)):",
      "comment": "I presume it's expected that the origin is always fetched before feeding into a typing objects check?",
      "comment_id": 1972626255,
      "user": "sydney-runkle",
      "created_at": "2025-02-27T00:34:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1972626255"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/json_schema.py",
      "line": 309,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,9 +306,7 @@ def build_schema_type_to_method(\n             TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type.\n         \"\"\"\n         mapping: dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]] = {}\n-        core_schema_types: list[CoreSchemaOrFieldType] = _typing_extra.literal_values(\n-            CoreSchemaOrFieldType  # type: ignore\n-        )\n+        core_schema_types: list[CoreSchemaOrFieldType] = list(get_literal_values(CoreSchemaOrFieldType))",
      "comment": "Why are we yielding from `get_literal_values`? Seems like we always wrap in a `list`?",
      "comment_id": 1972628632,
      "user": "sydney-runkle",
      "created_at": "2025-02-27T00:38:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1972628632"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/fields.py",
      "line": 338,
      "side": "RIGHT",
      "diff_hunk": "@@ -317,53 +321,49 @@ class MyModel(pydantic.BaseModel):\n         Returns:\n             An instance of the field metadata.\n         \"\"\"\n-        # 1. Check if the annotation is the `Final` type qualifier:\n-        final = _typing_extra.is_finalvar(annotation)\n-        if final:\n-            if _typing_extra.is_generic_alias(annotation):\n-                # 1.1. The annotation is a parametrized `Final`, e.g. `Final[int]`.\n-                #      In this case, `annotation` will be `int`:\n-                annotation = typing_extensions.get_args(annotation)[0]\n+        try:\n+            inspected_ann = inspect_annotation(\n+                annotation,\n+                annotation_source=_source,\n+                unpack_type_aliases='skip',\n+            )\n+        except ForbiddenQualifier as e:\n+            raise PydanticForbiddenQualifier(e.qualifier, annotation)\n+\n+        # TODO check for classvar and error?\n+\n+        # No assigned value, so infer the type as `Any` if no type expression is available (in the case of `Final`):\n+        type_expr: Any = Any if inspected_ann.type is UNKNOWN else inspected_ann.type\n+        final = 'final' in inspected_ann.qualifiers\n+        metadata = inspected_ann.metadata",
      "comment": "Can we add back a few of the comments that we had before? This part is very typing heavy so a few guiding comments were helpful (especially with the branches)",
      "comment_id": 1972630351,
      "user": "sydney-runkle",
      "created_at": "2025-02-27T00:40:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1972630351"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,9 +8,10 @@\n from pydantic_core import CoreSchema, core_schema\n from pydantic_core import validate_core_schema as _validate_core_schema\n from typing_extensions import TypeGuard, get_args, get_origin\n+from typing_inspection import typing_objects\n \n from . import _repr\n-from ._typing_extra import is_generic_alias, is_type_alias_type\n+from ._typing_extra import is_generic_alias",
      "comment": "`is_generic_alias` does an `isinstance()` check against `typing._GenericAlias` (e.g. `List[int]` is an instance of such a class), which isn't documented and technically private (although I don't think it will change). So it's best to avoid relying on it.\r\n\r\nIt is also a footgun as while `is_generic_alias()` works for all parameterized typing objects, it doesn't check for new unions (`is_generic_alias(int | str) == False`, but `is_generic_alias(Union[int, str]) == True`). For instance, I'm not sure we expected new unions to be skipped here:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/acb0f10fda1c78441e052c57b4288bc91431f852/pydantic/_internal/_core_utils.py#L66-L74\r\n\r\nSimilarly, I've used this function here as a way to check for `type[list[int]]` forms (here `type_param` is `list[int]`):\r\n\r\nhttps://github.com/pydantic/pydantic/blob/acb0f10fda1c78441e052c57b4288bc91431f852/pydantic/_internal/_generate_schema.py#L1711-L1715\r\n\r\nThis would also match `type[Union[int, str]]`, which we actually want to support! Thankfully there's a specific check for unions just before, but this could easily be missed.\r\n\r\n---\r\n\r\nI think there are still valid use cases where you want to check if something is a generic alias (and by that I don't mean `isinstance(obj, (types.GenericAlias, typing._GenericAlias)`, but if the `obj` is a parameterized generic class -- excluding unions, typing special forms like `Literal`, `Annotated`, etc), but it's probably best to rely on `get_origin()` and the `typing_objects` check functions.\r\n",
      "comment_id": 1973268698,
      "user": "Viicos",
      "created_at": "2025-02-27T10:06:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1973268698"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -286,7 +287,7 @@ def _warn_on_nested_alias_in_annotation(ann_type: type[Any], ann_name: str) -> N\n     args = getattr(ann_type, '__args__', None)\n     if args:\n         for anno_arg in args:\n-            if _typing_extra.is_annotated(anno_arg):\n+            if typing_objects.is_annotated(get_origin(anno_arg)):",
      "comment": "Yes, as per the guide, for performance reasons and also to have a cleaner approach, you should call `get_origin()` once, and the use the `typing_objects.is_smth(origin)` functions to analyze the object.\r\n\r\nIn Pydantic, our `is_smth()` functions were already calling `get_origin()`, but then we can end up with patterns like:\r\n\r\n```python\r\nif is_annotated(obj):  # one get_origin() call under the hood\r\n    ...\r\nelif is_literal(obj):  # two get_origin() calls now\r\n    ...\r\n```\r\n\r\nThis was convenient as shown on this `if _typing_extra.is_annotated()` call, but can decrease performance overall.",
      "comment_id": 1973274447,
      "user": "Viicos",
      "created_at": "2025-02-27T10:09:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1973274447"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1110,
      "side": "RIGHT",
      "diff_hunk": "@@ -1104,9 +1107,9 @@ def _match_generic_type(self, obj: Any, origin: Any) -> CoreSchema:  # noqa: C90\n         if schema is not None:\n             return schema\n \n-        if _typing_extra.is_type_alias_type(origin):\n+        if typing_objects.is_typealiastype(origin):",
      "comment": "I wanted to avoid having the name depending on the capitalization of the object, and simply have `is_<name>`, but both make sense I think",
      "comment_id": 1973287182,
      "user": "Viicos",
      "created_at": "2025-02-27T10:17:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1973287182"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_generics.py",
      "line": 300,
      "side": "RIGHT",
      "diff_hunk": "@@ -297,15 +297,15 @@ def replace_types(type_: Any, type_map: Mapping[TypeVar, Any] | None) -> Any:\n             origin_type = getattr(typing, type_._name)\n         assert origin_type is not None\n \n-        if _typing_extra.origin_is_union(origin_type):\n-            if any(_typing_extra.is_any(arg) for arg in resolved_type_args):\n+        if is_union_origin(origin_type):",
      "comment": "To not confuse it with `typing_object.is_union()`, which only checks for `typing.Union` (as it does for all the other functions in `typing_objects`), I've tried finding a better name but couldn't find any",
      "comment_id": 1973288879,
      "user": "Viicos",
      "created_at": "2025-02-27T10:18:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1973288879"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/json_schema.py",
      "line": 309,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,9 +306,7 @@ def build_schema_type_to_method(\n             TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type.\n         \"\"\"\n         mapping: dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]] = {}\n-        core_schema_types: list[CoreSchemaOrFieldType] = _typing_extra.literal_values(\n-            CoreSchemaOrFieldType  # type: ignore\n-        )\n+        core_schema_types: list[CoreSchemaOrFieldType] = list(get_literal_values(CoreSchemaOrFieldType))",
      "comment": "We (Pydantic) always wrap in a list, but others might not:\r\n\r\n```python\r\nfor elem in get_literal_values(Literal[1, 2]):\r\n    ...\r\n```",
      "comment_id": 1973295461,
      "user": "Viicos",
      "created_at": "2025-02-27T10:22:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1973295461"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -286,7 +287,7 @@ def _warn_on_nested_alias_in_annotation(ann_type: type[Any], ann_name: str) -> N\n     args = getattr(ann_type, '__args__', None)\n     if args:\n         for anno_arg in args:\n-            if _typing_extra.is_annotated(anno_arg):\n+            if typing_objects.is_annotated(get_origin(anno_arg)):",
      "comment": "Yes, definitely good to minimize `get_origin` calls.",
      "comment_id": 1973831192,
      "user": "sydney-runkle",
      "created_at": "2025-02-27T15:30:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1973831192"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1110,
      "side": "RIGHT",
      "diff_hunk": "@@ -1104,9 +1107,9 @@ def _match_generic_type(self, obj: Any, origin: Any) -> CoreSchema:  # noqa: C90\n         if schema is not None:\n             return schema\n \n-        if _typing_extra.is_type_alias_type(origin):\n+        if typing_objects.is_typealiastype(origin):",
      "comment": "I'd prefer `is_type_alias_type` just bc it's easier to read, but it's up to you, doesn't really matter!",
      "comment_id": 1973832092,
      "user": "sydney-runkle",
      "created_at": "2025-02-27T15:31:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1973832092"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/_internal/_generics.py",
      "line": 300,
      "side": "RIGHT",
      "diff_hunk": "@@ -297,15 +297,15 @@ def replace_types(type_: Any, type_map: Mapping[TypeVar, Any] | None) -> Any:\n             origin_type = getattr(typing, type_._name)\n         assert origin_type is not None\n \n-        if _typing_extra.origin_is_union(origin_type):\n-            if any(_typing_extra.is_any(arg) for arg in resolved_type_args):\n+        if is_union_origin(origin_type):",
      "comment": "Discussed at standup today, could be changed for clarity on the `typing-inspection` end, but I don't think this PR needs to be held up because of it.",
      "comment_id": 1973834208,
      "user": "sydney-runkle",
      "created_at": "2025-02-27T15:32:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1973834208"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11479,
      "file_path": "pydantic/json_schema.py",
      "line": 309,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,9 +306,7 @@ def build_schema_type_to_method(\n             TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type.\n         \"\"\"\n         mapping: dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]] = {}\n-        core_schema_types: list[CoreSchemaOrFieldType] = _typing_extra.literal_values(\n-            CoreSchemaOrFieldType  # type: ignore\n-        )\n+        core_schema_types: list[CoreSchemaOrFieldType] = list(get_literal_values(CoreSchemaOrFieldType))",
      "comment": "Doesn't strike me as necessary, but also, very low stakes, feel free to leave it as you wish",
      "comment_id": 1973837137,
      "user": "sydney-runkle",
      "created_at": "2025-02-27T15:33:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/11479#discussion_r1973837137"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11481,
      "file_path": "pydantic/types.py",
      "line": 1727,
      "side": "RIGHT",
      "diff_hunk": "@@ -1719,20 +1719,19 @@ def get_json_schema(_core_schema: core_schema.CoreSchema, handler: GetJsonSchema\n             )\n             return json_schema\n \n-        json_schema = core_schema.no_info_after_validator_function(\n-            source,  # construct the type\n-            cls._inner_schema,\n-        )\n-\n         def get_secret_schema(strict: bool) -> CoreSchema:\n+            inner_schema = {**cls._inner_schema, 'strict': strict}\n+            json_schema = core_schema.no_info_after_validator_function(\n+                source,  # construct the type\n+                inner_schema,  # pyright: ignore[reportArgumentType]\n+            )",
      "comment": "This is kind of gross, but so is this whole custom core schema construct for secret types",
      "comment_id": 1967719830,
      "user": "sydney-runkle",
      "created_at": "2025-02-24T14:14:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/11481#discussion_r1967719830"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11475,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 131,
      "side": "LEFT",
      "diff_hunk": "@@ -128,89 +128,6 @@ def annotated_type(tp: Any, /) -> Any | None:\n     return get_args(tp)[0] if is_annotated(tp) else None\n \n \n-def unpack_annotated(annotation: Any, /) -> tuple[Any, list[Any]]:",
      "comment": "This logic is not lost, it is present in `typing-inspection` and type aliases unpacking is configurable there",
      "comment_id": 1965722198,
      "user": "Viicos",
      "created_at": "2025-02-21T15:47:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/11475#discussion_r1965722198"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11475,
      "file_path": "pydantic/json_schema.py",
      "line": 555,
      "side": "RIGHT",
      "diff_hunk": "@@ -553,10 +552,7 @@ def new_handler_func(\n                 current_handler: GetJsonSchemaHandler = current_handler,\n                 js_modify_function: GetJsonSchemaFunction = js_modify_function,\n             ) -> JsonSchemaValue:\n-                json_schema = js_modify_function(schema_or_field, current_handler)\n-                if _core_utils.is_core_schema(schema_or_field):\n-                    json_schema = populate_defs(schema_or_field, json_schema)\n-                return json_schema\n+                return js_modify_function(schema_or_field, current_handler)",
      "comment": "Surprised we drop the populate_defs here - why is that?",
      "comment_id": 1967588883,
      "user": "sydney-runkle",
      "created_at": "2025-02-24T12:52:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/11475#discussion_r1967588883"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11475,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2061,
      "side": "LEFT",
      "diff_hunk": "@@ -2050,25 +2050,11 @@ def _computed_field_schema(\n     def _annotated_schema(self, annotated_type: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for an Annotated type, e.g. `Annotated[int, Field(...)]` or `Annotated[int, Gt(0)]`.\"\"\"\n         FieldInfo = import_cached_field_info()\n-        # Ideally, we should delegate all this to `_typing_extra.unpack_annotated`, e.g.:\n-        # `typ, annotations = _typing_extra.unpack_annotated(annotated_type); schema = self.apply_annotations(...)`\n-        # if it was able to use a `NsResolver`. But because `unpack_annotated` is also used\n-        # when constructing `FieldInfo` instances (where we don't have access to a `NsResolver`),\n-        # the implementation of the function does *not* resolve forward annotations. This could\n-        # be solved by calling `unpack_annotated` directly inside `collect_model_fields`.\n-        # For now, we at least resolve the annotated type if it is a forward ref, but note that\n-        # unexpected results will happen if you have something like `Annotated[Alias, ...]` and\n-        # `Alias` is a PEP 695 type alias containing forward references.",
      "comment": "This is no longer an issue because we no longer eagerly unpack type aliases here. So all the concerns written here don't stand anymore, as if you have something like:\r\n\r\n```python\r\ntype Alias = list['ForwardRef']\r\n\r\nGenerateSchema().generate_schema(Annotated[Alias, ...])\r\n```\r\n\r\nWe previously tried to call `unpack_annotated` with `Alias` (and we couldn't resolve forward annotations inside `unpack_annotated`).\r\n\r\nNow, We just leave `Alias` as is, generate a schema for it (so it will go through `GenerateSchema._type_alias_type_schema()`, and we can use the type namespace here if we have forward references), and apply the annotations after.\r\n\r\n",
      "comment_id": 1967609712,
      "user": "Viicos",
      "created_at": "2025-02-24T13:07:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/11475#discussion_r1967609712"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11475,
      "file_path": "pydantic/json_schema.py",
      "line": 555,
      "side": "RIGHT",
      "diff_hunk": "@@ -553,10 +552,7 @@ def new_handler_func(\n                 current_handler: GetJsonSchemaHandler = current_handler,\n                 js_modify_function: GetJsonSchemaFunction = js_modify_function,\n             ) -> JsonSchemaValue:\n-                json_schema = js_modify_function(schema_or_field, current_handler)\n-                if _core_utils.is_core_schema(schema_or_field):\n-                    json_schema = populate_defs(schema_or_field, json_schema)\n-                return json_schema\n+                return js_modify_function(schema_or_field, current_handler)",
      "comment": "Forgot to add an explanation, but basically this `new_handler_func` is the last handler to be defined. It is the first one to be called, but by calling `js_modify_function`, it will trigger the chain of calls to the inner handlers, meaning at this point (after L556, on `main`), all the handlers have been called.\r\n\r\nOn L560 (on this branch), we also call `populate_defs`, meaning the now removed call to `populate_defs` was redundant",
      "comment_id": 1967618533,
      "user": "Viicos",
      "created_at": "2025-02-24T13:13:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/11475#discussion_r1967618533"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11459,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,7 +264,10 @@ def collect_model_fields(  # noqa: C901\n         # to make sure the decorators have already been built for this exact class\n         decorators: DecoratorInfos = cls.__dict__['__pydantic_decorators__']\n         if ann_name in decorators.computed_fields:\n-            raise ValueError(\"you can't override a field with a computed field\")\n+            raise TypeError(\n+                f'Field \"{ann_name}\" of class \"{cls.__name__}\" overrides symbol of same name in \"{cls.__bases__[0].__name__}\".\\n'",
      "comment": "```suggestion\r\n                f'Field {ann_name!r} of class {cls.__name__!r} overrides symbol of same name in {cls.__bases__[0].__name__!r}. '\r\n```\r\na couple notes:\r\n- The parent symbol might not be in `cls.__bases__[0]` but in another base class, and I don't think there's a simple way to actually know which base class it is.\r\n- Probably we should avoid explicit newlines in exception messages",
      "comment_id": 1961882131,
      "user": "Viicos",
      "created_at": "2025-02-19T15:20:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/11459#discussion_r1961882131"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11451,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 790,
      "side": "RIGHT",
      "diff_hunk": "@@ -754,37 +755,50 @@ def unwrap_wrapped_function(\n     return func\n \n \n-def get_function_return_type(\n-    func: Any,\n-    explicit_return_type: Any,\n+_function_like = (\n+    partial,\n+    partialmethod,\n+    types.FunctionType,\n+    types.BuiltinFunctionType,\n+    types.MethodType,\n+    types.WrapperDescriptorType,\n+    types.MethodWrapperType,\n+    types.MemberDescriptorType,\n+)\n+\n+\n+def get_callable_return_type(\n+    callable_obj: Any,\n     globalns: GlobalsNamespace | None = None,\n     localns: MappingNamespace | None = None,\n-) -> Any:\n-    \"\"\"Get the function return type.\n-\n-    It gets the return type from the type annotation if `explicit_return_type` is `None`.\n-    Otherwise, it returns `explicit_return_type`.\n+) -> Any | PydanticUndefinedType:\n+    \"\"\"Get the callable return type.\n \n     Args:\n-        func: The function to get its return type.\n-        explicit_return_type: The explicit return type.\n+        callable_obj: The callable to analyze.\n         globalns: The globals namespace to use during type annotation evaluation.\n         localns: The locals namespace to use during type annotation evaluation.\n \n     Returns:\n         The function return type.\n     \"\"\"\n-    if explicit_return_type is PydanticUndefined:\n-        # try to get it from the type annotation\n-        hints = get_function_type_hints(\n-            unwrap_wrapped_function(func),\n-            include_keys={'return'},\n-            globalns=globalns,\n-            localns=localns,\n-        )\n-        return hints.get('return', PydanticUndefined)\n-    else:\n-        return explicit_return_type\n+    if isinstance(callable_obj, type):\n+        # types are callables, and we assume the return type\n+        # is the type itself (e.g. `int()` results in an instance of `int`).\n+        return callable_obj\n+\n+    if not isinstance(callable_obj, _function_like):",
      "comment": "This is the annoying thing we need to do: manually check for something that is _not_ a function, assume it is an instance (it isn't a type thanks to the added check above) and check for `__call__`.\r\n\r\nThis is also handled by `inspect.signature`, but we need to do this on our end as well so that we can evaluate forward refs.\r\n\r\ncc @dmontagu ",
      "comment_id": 1958425421,
      "user": "Viicos",
      "created_at": "2025-02-17T15:31:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/11451#discussion_r1958425421"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11451,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 790,
      "side": "RIGHT",
      "diff_hunk": "@@ -754,37 +755,50 @@ def unwrap_wrapped_function(\n     return func\n \n \n-def get_function_return_type(\n-    func: Any,\n-    explicit_return_type: Any,\n+_function_like = (\n+    partial,\n+    partialmethod,\n+    types.FunctionType,\n+    types.BuiltinFunctionType,\n+    types.MethodType,\n+    types.WrapperDescriptorType,\n+    types.MethodWrapperType,\n+    types.MemberDescriptorType,\n+)\n+\n+\n+def get_callable_return_type(\n+    callable_obj: Any,\n     globalns: GlobalsNamespace | None = None,\n     localns: MappingNamespace | None = None,\n-) -> Any:\n-    \"\"\"Get the function return type.\n-\n-    It gets the return type from the type annotation if `explicit_return_type` is `None`.\n-    Otherwise, it returns `explicit_return_type`.\n+) -> Any | PydanticUndefinedType:\n+    \"\"\"Get the callable return type.\n \n     Args:\n-        func: The function to get its return type.\n-        explicit_return_type: The explicit return type.\n+        callable_obj: The callable to analyze.\n         globalns: The globals namespace to use during type annotation evaluation.\n         localns: The locals namespace to use during type annotation evaluation.\n \n     Returns:\n         The function return type.\n     \"\"\"\n-    if explicit_return_type is PydanticUndefined:\n-        # try to get it from the type annotation\n-        hints = get_function_type_hints(\n-            unwrap_wrapped_function(func),\n-            include_keys={'return'},\n-            globalns=globalns,\n-            localns=localns,\n-        )\n-        return hints.get('return', PydanticUndefined)\n-    else:\n-        return explicit_return_type\n+    if isinstance(callable_obj, type):\n+        # types are callables, and we assume the return type\n+        # is the type itself (e.g. `int()` results in an instance of `int`).\n+        return callable_obj\n+\n+    if not isinstance(callable_obj, _function_like):",
      "comment": "Seems reasonable enough. Not the most odd thing we do with typing inspection.",
      "comment_id": 1960491697,
      "user": "sydney-runkle",
      "created_at": "2025-02-18T19:49:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/11451#discussion_r1960491697"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11451,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 783,
      "side": "RIGHT",
      "diff_hunk": "@@ -754,37 +755,50 @@ def unwrap_wrapped_function(\n     return func\n \n \n-def get_function_return_type(\n-    func: Any,\n-    explicit_return_type: Any,\n+_function_like = (\n+    partial,\n+    partialmethod,\n+    types.FunctionType,\n+    types.BuiltinFunctionType,\n+    types.MethodType,\n+    types.WrapperDescriptorType,\n+    types.MethodWrapperType,\n+    types.MemberDescriptorType,\n+)\n+\n+\n+def get_callable_return_type(\n+    callable_obj: Any,\n     globalns: GlobalsNamespace | None = None,\n     localns: MappingNamespace | None = None,\n-) -> Any:\n-    \"\"\"Get the function return type.\n-\n-    It gets the return type from the type annotation if `explicit_return_type` is `None`.\n-    Otherwise, it returns `explicit_return_type`.\n+) -> Any | PydanticUndefinedType:\n+    \"\"\"Get the callable return type.\n \n     Args:\n-        func: The function to get its return type.\n-        explicit_return_type: The explicit return type.\n+        callable_obj: The callable to analyze.\n         globalns: The globals namespace to use during type annotation evaluation.\n         localns: The locals namespace to use during type annotation evaluation.\n \n     Returns:\n         The function return type.",
      "comment": "Can we add more detail here now that we return `| PydanticUndefinedType` as well",
      "comment_id": 1960493561,
      "user": "sydney-runkle",
      "created_at": "2025-02-18T19:51:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/11451#discussion_r1960493561"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11451,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 931,
      "side": "LEFT",
      "diff_hunk": "@@ -922,13 +920,8 @@ def get_function_type_hints(\n         else:\n             annotations = function.__annotations__\n     except AttributeError:\n-        type_hints = get_type_hints(function)\n-        if isinstance(function, type):\n-            # `type[...]` is a callable, which returns an instance of itself.\n-            # At some point, we might even look into the return type of `__new__`\n-            # if it returns something else.\n-            type_hints.setdefault('return', function)\n-        return type_hints",
      "comment": "This check did not really make sense in this `get_function_type_hints()`, but rather in `get_callable_return_type()` (this PR moved the check in this one), which has a smaller scope (i.e. analyzing callables used for validators/serializers functions)",
      "comment_id": 1961909607,
      "user": "Viicos",
      "created_at": "2025-02-19T15:35:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/11451#discussion_r1961909607"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -164,6 +164,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if hasattr(email_validator, '__version__') and email_validator.__version__.partition('.')[0] == '2':\n+        return\n+    else:\n+        input_email = 'testaddr@example.tld'\n+        valid_email = validate_email(input_email)\n+        if not hasattr(valid_email, 'normalized'):\n+            raise ImportError('email-validator version >= 2.0 required')",
      "comment": "Is there a cleaner way in which we could check for the case where the version is between `2.0.0` and `2.0.0post1`?",
      "comment_id": 1391635503,
      "user": "sydney-runkle",
      "created_at": "2023-11-13T20:01:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1391635503"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -164,6 +164,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if hasattr(email_validator, '__version__') and email_validator.__version__.partition('.')[0] == '2':\n+        return\n+    else:\n+        input_email = 'testaddr@example.tld'\n+        valid_email = validate_email(input_email)\n+        if not hasattr(valid_email, 'normalized'):\n+            raise ImportError('email-validator version >= 2.0 required')",
      "comment": "normalized is the documented discriminator for 2.0\r\nhttps://github.com/JoshData/python-email-validator/blob/main/CHANGELOG.md#200-april-15-2023\r\n2.1 has __version__\r\nhttps://github.com/JoshData/python-email-validator/blob/main/CHANGELOG.md#210-october-22-2023",
      "comment_id": 1392272045,
      "user": "commonism",
      "created_at": "2023-11-14T09:29:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1392272045"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 366,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if hasattr(email_validator, '__version__') and getattr(email_validator, '__version__', '').partition('.')[0] == '2':",
      "comment": "```suggestion\r\n    if getattr(email_validator, '__version__', '').partition('.')[0] == '2':\r\n```\r\nWith `''` as a default value, `''.partition('.')` returns `('', '', '')`",
      "comment_id": 1403320348,
      "user": "Viicos",
      "created_at": "2023-11-23T12:29:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1403320348"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 366,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if hasattr(email_validator, '__version__') and getattr(email_validator, '__version__', '').partition('.')[0] == '2':",
      "comment": "which is fine - \r\nv2.1 has `__version__` and will pass\r\nv1.x/v2.0 lack `__version__` and the test below distinguishes in v1.x and v2.0 by testing for `normalized`.",
      "comment_id": 1403587427,
      "user": "commonism",
      "created_at": "2023-11-23T16:33:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1403587427"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 366,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if hasattr(email_validator, '__version__') and getattr(email_validator, '__version__', '').partition('.')[0] == '2':",
      "comment": "Yes, what I meant is that the `hasattr` check is not necessary because of the `getattr` fallback to `''`. But I think it's fine to keep it for clarity",
      "comment_id": 1403598610,
      "user": "Viicos",
      "created_at": "2023-11-23T16:47:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1403598610"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if getattr(email_validator, '__version__', '').partition('.')[0] == '2':\n+        return\n+    else:\n+        input_email = 'testaddr@example.tld'\n+        valid_email = email_validator.validate_email(input_email, check_deliverability=False)\n+        if not hasattr(valid_email, 'normalized'):\n+            raise ImportError('email-validator version >= 2.0 required')",
      "comment": "@commonism and @Viicos,\r\n\r\nWhat are your thoughts on something like this:\r\n\r\n```py\r\nversion_above_2_1 = getattr(email_validator, '__version__', '').partition('.')[0] == '2'\r\n\r\ninput_email = 'testaddr@example.tld'\r\nvalid_email = email_validator.validate_email(input_email, check_deliverability=False)\r\nversion_above_2_0 = hasattr(valid_email, 'normalized')\r\n\r\nif not (version_above_2_0 or version_above_2_1):\r\n    raise ImportError('email-validator version >= 2.0 required')\r\n```\r\n\r\nCertainly a tad bit less efficient, but I think the logic is much easier to understand. Happy to accept either way, but wanted to get your thoughts on this first. ",
      "comment_id": 1406506701,
      "user": "sydney-runkle",
      "created_at": "2023-11-27T17:28:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1406506701"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if getattr(email_validator, '__version__', '').partition('.')[0] == '2':\n+        return\n+    else:\n+        input_email = 'testaddr@example.tld'\n+        valid_email = email_validator.validate_email(input_email, check_deliverability=False)\n+        if not hasattr(valid_email, 'normalized'):\n+            raise ImportError('email-validator version >= 2.0 required')",
      "comment": "Why not using `importlib.metadata` instead? (we don't need the backport since Python 3.8):\r\n\r\n```python\r\nfrom importlib.metadata import version\r\n\r\nif not version(\"email-validator\").partition('.')[0] == '2':\r\n    ...\r\n```\r\n\r\n(Unless I'm missing something?)",
      "comment_id": 1406601519,
      "user": "Viicos",
      "created_at": "2023-11-27T18:46:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1406601519"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if getattr(email_validator, '__version__', '').partition('.')[0] == '2':\n+        return\n+    else:\n+        input_email = 'testaddr@example.tld'\n+        valid_email = email_validator.validate_email(input_email, check_deliverability=False)\n+        if not hasattr(valid_email, 'normalized'):\n+            raise ImportError('email-validator version >= 2.0 required')",
      "comment": "Good call. Let's go with:\r\n\r\n```suggestion\r\n    if not version(\"email-validator\").partition('.')[0] == '2':\r\n        raise ImportError('email-validator version >= 2.0 required, run pip install -U email-validator')\r\n```",
      "comment_id": 1406610267,
      "user": "sydney-runkle",
      "created_at": "2023-11-27T18:53:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1406610267"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if getattr(email_validator, '__version__', '').partition('.')[0] == '2':\n+        return\n+    else:\n+        input_email = 'testaddr@example.tld'\n+        valid_email = email_validator.validate_email(input_email, check_deliverability=False)\n+        if not hasattr(valid_email, 'normalized'):\n+            raise ImportError('email-validator version >= 2.0 required')",
      "comment": "@commonism, once we add that, assuming all tests are passing, we can merge :)",
      "comment_id": 1406623162,
      "user": "sydney-runkle",
      "created_at": "2023-11-27T19:05:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1406623162"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if getattr(email_validator, '__version__', '').partition('.')[0] == '2':\n+        return\n+    else:\n+        input_email = 'testaddr@example.tld'\n+        valid_email = email_validator.validate_email(input_email, check_deliverability=False)\n+        if not hasattr(valid_email, 'normalized'):\n+            raise ImportError('email-validator version >= 2.0 required')",
      "comment": "The check you provide is for email-validator >= 2.1 - won't make that much of a difference but allowing to uncrustify the version check to get rid of the v2.0 oddity.\r\n\r\nv2.0 does not have __version__ (as v1.x), therefore __version__ alone is not enough and checking for normalized attribute would be required to test for v2.0.\r\nIf you intent to go with v2.1, change the requirements in the pyproject.toml to match the version check?\r\n\r\n",
      "comment_id": 1406763264,
      "user": "commonism",
      "created_at": "2023-11-27T21:22:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1406763264"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if getattr(email_validator, '__version__', '').partition('.')[0] == '2':\n+        return\n+    else:\n+        input_email = 'testaddr@example.tld'\n+        valid_email = email_validator.validate_email(input_email, check_deliverability=False)\n+        if not hasattr(valid_email, 'normalized'):\n+            raise ImportError('email-validator version >= 2.0 required')",
      "comment": "@commonism,\r\n\r\nThe check works with `2.0.0`:\r\n\r\n```py\r\nimport email_validator\r\nfrom importlib.metadata import version\r\n\r\ndef import_email_validator() -> None:\r\n    global email_validator\r\n    try:\r\n        import email_validator\r\n    except ImportError as e:\r\n        raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\r\n\r\n    print(version(\"email-validator\"))\r\n    #> 2.0.0\r\n    \r\n    if not version(\"email-validator\").partition('.')[0] == '2':\r\n        raise ImportError('email-validator version >= 2.0 required, run pip install -U email-validator')\r\n\r\nimport_email_validator()\r\n```\r\n\r\nThis doesn't raise an error. I don't get an error if I'm using 2.1 either. I do get an error if I'm using < v2",
      "comment_id": 1406777742,
      "user": "sydney-runkle",
      "created_at": "2023-11-27T21:39:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1406777742"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6033,
      "file_path": "pydantic/networks.py",
      "line": 372,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,13 @@ def import_email_validator() -> None:\n         import email_validator\n     except ImportError as e:\n         raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n+    if getattr(email_validator, '__version__', '').partition('.')[0] == '2':\n+        return\n+    else:\n+        input_email = 'testaddr@example.tld'\n+        valid_email = email_validator.validate_email(input_email, check_deliverability=False)\n+        if not hasattr(valid_email, 'normalized'):\n+            raise ImportError('email-validator version >= 2.0 required')",
      "comment": "You are right, importlib.metadata.version is pure magic.",
      "comment_id": 1407287098,
      "user": "commonism",
      "created_at": "2023-11-28T06:32:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/6033#discussion_r1407287098"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11434,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 719,
      "side": "LEFT",
      "diff_hunk": "@@ -711,14 +711,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                 return maybe_schema\n \n             schema = cls.__dict__.get('__pydantic_core_schema__')\n-            if (\n-                schema is not None\n-                and not isinstance(schema, MockCoreSchema)\n-                # Due to the way generic classes are built, it's possible that an invalid schema may be temporarily\n-                # set on generic classes. Probably we could resolve this to ensure that we get proper schema caching\n-                # for generics, but for simplicity for now, we just always rebuild if the class has a generic origin:",
      "comment": "This is pretty weird stuff here... All tests pass fine. Looking at git blame this has been copied over through different refactorings. Most likely not a relevant thing anymore as everything works fine... ",
      "comment_id": 1953313440,
      "user": "MarkusSintonen",
      "created_at": "2025-02-12T19:56:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11434#discussion_r1953313440"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11434,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 719,
      "side": "LEFT",
      "diff_hunk": "@@ -711,14 +711,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                 return maybe_schema\n \n             schema = cls.__dict__.get('__pydantic_core_schema__')\n-            if (\n-                schema is not None\n-                and not isinstance(schema, MockCoreSchema)\n-                # Due to the way generic classes are built, it's possible that an invalid schema may be temporarily\n-                # set on generic classes. Probably we could resolve this to ensure that we get proper schema caching\n-                # for generics, but for simplicity for now, we just always rebuild if the class has a generic origin:",
      "comment": "Makes me a bit nervous, but given you are probably one of the heaviest users of pydantic generics, my guess is that if you aren't seeing bugs, it's probably working okay? \ud83d\ude05  Admittedly this code has gotten a lot of refactoring since I was last looking at it heavily",
      "comment_id": 1953348404,
      "user": "dmontagu",
      "created_at": "2025-02-12T20:26:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/11434#discussion_r1953348404"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11434,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 719,
      "side": "LEFT",
      "diff_hunk": "@@ -711,14 +711,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                 return maybe_schema\n \n             schema = cls.__dict__.get('__pydantic_core_schema__')\n-            if (\n-                schema is not None\n-                and not isinstance(schema, MockCoreSchema)\n-                # Due to the way generic classes are built, it's possible that an invalid schema may be temporarily\n-                # set on generic classes. Probably we could resolve this to ensure that we get proper schema caching\n-                # for generics, but for simplicity for now, we just always rebuild if the class has a generic origin:",
      "comment": "I can do some integration testing to stuff on our end. But I think the existing unit tests around here cover everything already.",
      "comment_id": 1953355587,
      "user": "MarkusSintonen",
      "created_at": "2025-02-12T20:32:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/11434#discussion_r1953355587"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11434,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 719,
      "side": "LEFT",
      "diff_hunk": "@@ -711,14 +711,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                 return maybe_schema\n \n             schema = cls.__dict__.get('__pydantic_core_schema__')\n-            if (\n-                schema is not None\n-                and not isinstance(schema, MockCoreSchema)\n-                # Due to the way generic classes are built, it's possible that an invalid schema may be temporarily\n-                # set on generic classes. Probably we could resolve this to ensure that we get proper schema caching\n-                # for generics, but for simplicity for now, we just always rebuild if the class has a generic origin:",
      "comment": "Given the example I shared below I'm a little more confident it's safe",
      "comment_id": 1953565316,
      "user": "dmontagu",
      "created_at": "2025-02-12T23:47:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/11434#discussion_r1953565316"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11434,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 719,
      "side": "LEFT",
      "diff_hunk": "@@ -711,14 +711,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                 return maybe_schema\n \n             schema = cls.__dict__.get('__pydantic_core_schema__')\n-            if (\n-                schema is not None\n-                and not isinstance(schema, MockCoreSchema)\n-                # Due to the way generic classes are built, it's possible that an invalid schema may be temporarily\n-                # set on generic classes. Probably we could resolve this to ensure that we get proper schema caching\n-                # for generics, but for simplicity for now, we just always rebuild if the class has a generic origin:",
      "comment": "> An integration test on your end would be great \ud83d\udc4d\r\n\r\nRun the tests on our end and everything works. Did it on 2.10.6 with this change on top.",
      "comment_id": 1953924930,
      "user": "MarkusSintonen",
      "created_at": "2025-02-13T06:59:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/11434#discussion_r1953924930"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11432,
      "file_path": "pydantic/main.py",
      "line": 954,
      "side": "RIGHT",
      "diff_hunk": "@@ -938,17 +943,32 @@ def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, str, A\n                     _object_setattr(self, name, value)\n                     return None  # Can not return memoized handler with possibly freeform attr names\n \n-            cls._check_frozen(name, value)\n-\n             attr = getattr(cls, name, None)\n             # NOTE: We currently special case properties and `cached_property`, but we might need\n             # to generalize this to all data/non-data descriptors at some point. For non-data descriptors\n             # (such as `cached_property`), it isn't obvious though. `cached_property` caches the value\n             # to the instance's `__dict__`, but other non-data descriptors might do things differently.\n+            if isinstance(attr, cached_property):\n+                return _SIMPLE_SETATTR_HANDLERS['cached_property']\n+\n+            model_frozen = cls.model_config.get('frozen')",
      "comment": "I inlined the logic as I couldn't find a good way to keep it in a single method as I need to raise it differently in `__delattr__`. A bit unfortunate, but at least this removes the `_check_frozen` method on the `BaseModel` class, so it avoids polluting the namespace.",
      "comment_id": 1952489773,
      "user": "Viicos",
      "created_at": "2025-02-12T11:41:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/11432#discussion_r1952489773"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11432,
      "file_path": "pydantic/main.py",
      "line": 951,
      "side": "RIGHT",
      "diff_hunk": "@@ -938,17 +943,32 @@ def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, str, A\n                     _object_setattr(self, name, value)\n                     return None  # Can not return memoized handler with possibly freeform attr names\n \n-            cls._check_frozen(name, value)\n-\n             attr = getattr(cls, name, None)\n             # NOTE: We currently special case properties and `cached_property`, but we might need\n             # to generalize this to all data/non-data descriptors at some point. For non-data descriptors\n             # (such as `cached_property`), it isn't obvious though. `cached_property` caches the value\n             # to the instance's `__dict__`, but other non-data descriptors might do things differently.\n+            if isinstance(attr, cached_property):",
      "comment": "Can you apply the same thing that I requested in https://github.com/pydantic/pydantic/pull/11431#discussion_r1952456838 ?",
      "comment_id": 1952545672,
      "user": "ddorian",
      "created_at": "2025-02-12T12:20:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11432#discussion_r1952545672"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11432,
      "file_path": "pydantic/main.py",
      "line": 951,
      "side": "RIGHT",
      "diff_hunk": "@@ -938,17 +943,32 @@ def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, str, A\n                     _object_setattr(self, name, value)\n                     return None  # Can not return memoized handler with possibly freeform attr names\n \n-            cls._check_frozen(name, value)\n-\n             attr = getattr(cls, name, None)\n             # NOTE: We currently special case properties and `cached_property`, but we might need\n             # to generalize this to all data/non-data descriptors at some point. For non-data descriptors\n             # (such as `cached_property`), it isn't obvious though. `cached_property` caches the value\n             # to the instance's `__dict__`, but other non-data descriptors might do things differently.\n+            if isinstance(attr, cached_property):",
      "comment": "As per the comment above this line, we currently only special case `@cached_property`, and could extend to other descriptors (but it isn't obvious to do so, as per the comment).\r\n\r\nWe currently don't plan on changing the behavior unless someone has an explicit request for it",
      "comment_id": 1952576031,
      "user": "Viicos",
      "created_at": "2025-02-12T12:42:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/11432#discussion_r1952576031"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11432,
      "file_path": "pydantic/main.py",
      "line": 1008,
      "side": "RIGHT",
      "diff_hunk": "@@ -977,13 +999,36 @@ def __delattr__(self, item: str) -> Any:\n                     del self.__pydantic_private__[item]  # type: ignore\n                     return\n                 except KeyError as exc:\n-                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n-\n-            self._check_frozen(item, None)\n-\n-            if item in self.__pydantic_fields__:\n+                    raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n+\n+            model_frozen = cls.model_config.get('frozen', False)\n+\n+            field_info = self.__pydantic_fields__.get(item)\n+            if field_info is not None:\n+                if model_frozen or field_info.frozen:",
      "comment": "```suggestion\r\n            model_frozen = cls.model_config.get('frozen')\r\n            field_frozen = getattr(cls.__pydantic_fields__.get(name), 'frozen', False)\r\n            if model_frozen or field_frozen:\r\n```",
      "comment_id": 1952857182,
      "user": "sydney-runkle",
      "created_at": "2025-02-12T15:14:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/11432#discussion_r1952857182"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11432,
      "file_path": "pydantic/main.py",
      "line": 1008,
      "side": "RIGHT",
      "diff_hunk": "@@ -977,13 +999,36 @@ def __delattr__(self, item: str) -> Any:\n                     del self.__pydantic_private__[item]  # type: ignore\n                     return\n                 except KeyError as exc:\n-                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n-\n-            self._check_frozen(item, None)\n-\n-            if item in self.__pydantic_fields__:\n+                    raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n+\n+            model_frozen = cls.model_config.get('frozen', False)\n+\n+            field_info = self.__pydantic_fields__.get(item)\n+            if field_info is not None:\n+                if model_frozen or field_info.frozen:",
      "comment": "We should make this consistent with the above pattern.\r\n\r\nIt's hard - we're not at the 3 repetition rule here that necessitates abstraction. I'm ok with keeping this duplicated code as long as it's as consistent as possible.",
      "comment_id": 1952864207,
      "user": "sydney-runkle",
      "created_at": "2025-02-12T15:17:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/11432#discussion_r1952864207"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11432,
      "file_path": "pydantic/main.py",
      "line": 1013,
      "side": "RIGHT",
      "diff_hunk": "@@ -977,13 +999,36 @@ def __delattr__(self, item: str) -> Any:\n                     del self.__pydantic_private__[item]  # type: ignore\n                     return\n                 except KeyError as exc:\n-                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n-\n-            self._check_frozen(item, None)\n-\n-            if item in self.__pydantic_fields__:\n+                    raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n+\n+            model_frozen = cls.model_config.get('frozen', False)\n+\n+            field_info = self.__pydantic_fields__.get(item)\n+            if field_info is not None:\n+                if model_frozen or field_info.frozen:\n+                    raise ValidationError.from_exception_data(\n+                        cls.__name__,\n+                        [\n+                            {\n+                                'type': 'frozen_field' if field_info.frozen else 'frozen_instance',",
      "comment": "```suggestion\r\n                                'type': 'frozen_field' if field_frozen else 'frozen_instance',\r\n```",
      "comment_id": 1952864536,
      "user": "sydney-runkle",
      "created_at": "2025-02-12T15:17:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/11432#discussion_r1952864536"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11429,
      "file_path": "pydantic/dataclasses.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -327,8 +327,13 @@ def rebuild_dataclass(\n     if not force and cls.__pydantic_complete__:\n         return None\n \n-    if '__pydantic_core_schema__' in cls.__dict__:\n-        delattr(cls, '__pydantic_core_schema__')  # delete cached value to ensure full rebuild happens\n+    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n+        if attr in cls.__dict__:\n+            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n+            # core. Same applies for the core schema that can be reused in schema generation.",
      "comment": "```suggestion\r\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\r\n            # pydantic-core. Same applies for the core schema that can be reused in schema generation.\r\n```",
      "comment_id": 1951789121,
      "user": "sydney-runkle",
      "created_at": "2025-02-12T00:27:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/11429#discussion_r1951789121"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11429,
      "file_path": "pydantic/main.py",
      "line": 594,
      "side": "RIGHT",
      "diff_hunk": "@@ -588,8 +588,13 @@ def model_rebuild(\n         if not force and cls.__pydantic_complete__:\n             return None\n \n-        if '__pydantic_core_schema__' in cls.__dict__:\n-            delattr(cls, '__pydantic_core_schema__')  # delete cached value to ensure full rebuild happens\n+        for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n+            if attr in cls.__dict__:\n+                # Deleting the validator/serializer is necessary as otherwise they can get reused in\n+                # core. Same applies for the core schema that can be reused in schema generation.",
      "comment": "```suggestion\r\n                # Deleting the validator/serializer is necessary as otherwise they can get reused in\r\n                # pydantic-core. Same applies for the core schema that can be reused in schema generation.\r\n```",
      "comment_id": 1951789296,
      "user": "sydney-runkle",
      "created_at": "2025-02-12T00:27:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/11429#discussion_r1951789296"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "tests/test_type_alias_type.py",
      "line": 391,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,8 +387,8 @@ class MyModel(BaseModel):\n     assert MyModel(my_int_seq=range(1, 4)).my_int_seq == [1, 2, 3]\n \n     assert MyModel.model_json_schema() == {\n-        '$defs': {'MySeq_int_': {'items': {'type': 'integer'}, 'type': 'array'}},\n-        'properties': {'my_int_seq': {'$ref': '#/$defs/MySeq_int_'}},\n+        '$defs': {'MyIntSeq': {'items': {'type': 'integer'}, 'type': 'array'}},\n+        'properties': {'my_int_seq': {'$ref': '#/$defs/MyIntSeq'}},",
      "comment": "A note about this change, discussed in detail previously: https://github.com/pydantic/pydantic/pull/10655#discussion_r1846844351",
      "comment_id": 1925474157,
      "user": "sydney-runkle",
      "created_at": "2025-01-22T15:00:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1925474157"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2539,
      "side": "RIGHT",
      "diff_hunk": "@@ -2532,6 +2536,7 @@ class _Definitions:\n     def __init__(self) -> None:\n         self._recursively_seen = set()\n         self._definitions = {}\n+        self._unpacked_definitions: dict[str, CoreSchema] = {}",
      "comment": "Could you shine some light on the important differences between these? Can we add a type hint to `_definitions`  as well?",
      "comment_id": 1925479889,
      "user": "sydney-runkle",
      "created_at": "2025-01-22T15:03:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1925479889"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2597,
      "side": "RIGHT",
      "diff_hunk": "@@ -2580,24 +2585,72 @@ def create_definition_reference_schema(self, schema: CoreSchema) -> core_schema.\n         return core_schema.definition_reference_schema(ref)\n \n     def unpack_definitions(self, schema: core_schema.DefinitionsSchema) -> CoreSchema:\n-        \"\"\"Store the definitions of the `'definitions` core schema and return the inner core schema.\"\"\"\n+        \"\"\"Store the definitions of the `'definitions'` core schema and return the inner core schema.\"\"\"\n         for def_schema in schema['definitions']:\n-            self._definitions[def_schema['ref']] = def_schema  # pyright: ignore\n+            self._unpacked_definitions[def_schema['ref']] = def_schema  # pyright: ignore\n         return schema['schema']\n \n-    def as_definitions_schema(self, schema: CoreSchema) -> CoreSchema:\n-        \"\"\"Create a `'definitions'` schema containing all the collected definitions.\n+    def finalize_schema(self, schema: CoreSchema) -> CoreSchema:\n+        \"\"\"Finalize the core schema.\n \n-        If the passed schema contains a reference, it is also stored in the definitions list,\n-        and substituted by a `'definition-reference'` schema.\n+        This traverses the core schema and referenced definitions, replace `'definition-ref'` schemas\n+        by the referenced definition if possible, and apply deferred discriminators.",
      "comment": "```suggestion\r\n        This traverses the core schema and referenced definitions, replaces `'definition-ref'` schemas\r\n        by the referenced definition if possible, and applies deferred discriminators.\r\n```",
      "comment_id": 1925481290,
      "user": "sydney-runkle",
      "created_at": "2025-01-22T15:04:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1925481290"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_schema_gather.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,184 @@\n+from dataclasses import dataclass, field\n+from typing import TypedDict\n+\n+from pydantic_core.core_schema import CoreSchema, DefinitionReferenceSchema, SerSchema\n+\n+\n+class GatherResult(TypedDict):\n+    \"\"\"Schema traversing result.\"\"\"\n+\n+    collected_references: dict[str, DefinitionReferenceSchema | None]\n+    \"\"\"The collected definition references.\n+\n+    If a definition reference schema can be inlined, it means that there is\n+    only one in the whole core schema. As such, it is stored as the value.\n+    Otherwise, the value is set to `None`.\n+    \"\"\"\n+\n+    deferred_discriminator_schemas: list[CoreSchema]\n+    \"\"\"The list of core schemas having the discriminator application deferred.\"\"\"\n+\n+\n+class MissingDefinitionError(LookupError):\n+    \"\"\"A reference was pointing to a non-existing core schema.\"\"\"\n+\n+    def __init__(self, schema_reference: str, /) -> None:\n+        self.schema_reference = schema_reference\n+\n+\n+@dataclass\n+class GatherContext:\n+    \"\"\"The current context used during core schema traversing.\n+\n+    Context instances should only be used during schema traversing.\n+    \"\"\"\n+\n+    definitions: dict[str, CoreSchema]\n+    \"\"\"The available definitions.\"\"\"\n+\n+    deferred_discriminator_schemas: list[CoreSchema] = field(init=False, default_factory=list)\n+    \"\"\"The list of core schemas having the discriminator application deferred.\n+\n+    Internally, these core schemas have a specific key set in the core metadata dict.\n+    \"\"\"\n+\n+    collected_references: dict[str, DefinitionReferenceSchema | None] = field(init=False, default_factory=dict)\n+    \"\"\"The collected definition references.\n+\n+    If a definition reference schema can be inlined, it means that there is\n+    only one in the whole core schema. As such, it is stored as the value.\n+    Otherwise, the value is set to `None`.\n+\n+    During schema traversing, definition reference schemas can be added as candidates, or removed\n+    (by setting the value to `None`).\n+    \"\"\"\n+\n+\n+def gather_meta(schema: CoreSchema, ctx: GatherContext) -> None:",
      "comment": "Let's just use `metadata` here (and in the function) to be explicit. Maybe even `cast` to `CoreMetadata` for type safety.",
      "comment_id": 1925490349,
      "user": "sydney-runkle",
      "created_at": "2025-01-22T15:09:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1925490349"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 858,
      "side": "RIGHT",
      "diff_hunk": "@@ -858,6 +850,10 @@ def _generate_schema_from_get_schema_method(self, obj: Any, source: Any) -> core\n             ref = get_ref(schema)\n             if ref:\n                 return self.defs.create_definition_reference_schema(schema)\n+\n+            # if schema['type'] == 'definition-ref':\n+            #     return schema.copy()\n+",
      "comment": "Still TBD: https://github.com/pydantic/pydantic/pull/11208#discussion_r1901313586. Adding the copy will not alter performance considering how small these schemas are, so probably it will be added.",
      "comment_id": 1925602123,
      "user": "Viicos",
      "created_at": "2025-01-22T16:17:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1925602123"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2539,
      "side": "RIGHT",
      "diff_hunk": "@@ -2532,6 +2536,7 @@ class _Definitions:\n     def __init__(self) -> None:\n         self._recursively_seen = set()\n         self._definitions = {}\n+        self._unpacked_definitions: dict[str, CoreSchema] = {}",
      "comment": "Still TBD as well: https://github.com/pydantic/pydantic/pull/11208#discussion_r1901312387. I need to investigate a bit more on this one.",
      "comment_id": 1925603059,
      "user": "Viicos",
      "created_at": "2025-01-22T16:18:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1925603059"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2539,
      "side": "RIGHT",
      "diff_hunk": "@@ -2532,6 +2536,7 @@ class _Definitions:\n     def __init__(self) -> None:\n         self._recursively_seen = set()\n         self._definitions = {}\n+        self._unpacked_definitions: dict[str, CoreSchema] = {}",
      "comment": "> Can we add a type hint to _definitions as well?\r\n\r\nNot required as it is annotated in the class body with the docstring (and `_unpacked_definitions` should align as well, will do after deciding if we keep it or not)",
      "comment_id": 1925607290,
      "user": "Viicos",
      "created_at": "2025-01-22T16:20:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1925607290"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2520,
      "side": "RIGHT",
      "diff_hunk": "@@ -2508,6 +2506,23 @@ def _common_field(\n     }\n \n \n+def resolve_original_schema(schema: CoreSchema, definitions: _Definitions) -> CoreSchema | None:\n+    if schema['type'] == 'definition-ref':\n+        return definitions.get_schema_from_ref(schema['schema_ref'])\n+    elif schema['type'] == 'definitions':\n+        return schema['schema']\n+    else:\n+        return schema\n+\n+\n+def _can_be_inlined(def_ref: core_schema.DefinitionReferenceSchema) -> bool:",
      "comment": "Difference from MS PR: instead of checking for specific keys in the metadata schema, we just check that there are no metadata at all.",
      "comment_id": 1930994867,
      "user": "Viicos",
      "created_at": "2025-01-27T18:18:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1930994867"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "tests/test_utils.py",
      "line": 741,
      "side": "LEFT",
      "diff_hunk": "@@ -547,210 +545,3 @@ def test_to_snake(value: str, result: str) -> None:\n \n def test_to_camel_from_camel() -> None:\n     assert to_camel('alreadyCamel') == 'alreadyCamel'\n-\n-\n-def test_handle_tuple_schema():\n-    schema = core_schema.tuple_schema([core_schema.float_schema(), core_schema.int_schema()])\n-\n-    def walk(s, recurse):\n-        # change extra_schema['type'] to 'str'\n-        if s['type'] == 'float':\n-            s['type'] = 'str'\n-        return s\n-\n-    schema = _WalkCoreSchema().handle_tuple_schema(schema, walk)\n-    assert schema == {\n-        'items_schema': [{'type': 'str'}, {'type': 'int'}],\n-        'type': 'tuple',\n-    }\n-\n-\n-@pytest.mark.parametrize(\n-    'params,expected_extra_schema',\n-    (\n-        pytest.param({}, {}, id='Model fields without extra_validator'),\n-        pytest.param(\n-            {'extras_schema': core_schema.float_schema()},\n-            {'extras_schema': {'type': 'str'}},\n-            id='Model fields with extra_validator',\n-        ),\n-    ),\n-)\n-def test_handle_model_fields_schema(params, expected_extra_schema):\n-    schema = core_schema.model_fields_schema(\n-        {\n-            'foo': core_schema.model_field(core_schema.int_schema()),\n-        },\n-        **params,\n-    )\n-\n-    def walk(s, recurse):\n-        # change extra_schema['type'] to 'str'\n-        if s['type'] == 'float':\n-            s['type'] = 'str'\n-        return s\n-\n-    schema = _WalkCoreSchema().handle_model_fields_schema(schema, walk)\n-    assert schema == {\n-        **expected_extra_schema,\n-        'type': 'model-fields',\n-        'fields': {'foo': {'type': 'model-field', 'schema': {'type': 'int'}}},\n-    }\n-\n-\n-@pytest.mark.parametrize(\n-    'params,expected_extra_schema',\n-    (\n-        pytest.param({}, {}, id='Typeddict without extra_validator'),\n-        pytest.param(\n-            {'extras_schema': core_schema.float_schema()},\n-            {'extras_schema': {'type': 'str'}},\n-            id='Typeddict with extra_validator',\n-        ),\n-    ),\n-)\n-def test_handle_typed_dict_schema(params, expected_extra_schema):\n-    schema = core_schema.typed_dict_schema(\n-        {\n-            'foo': core_schema.model_field(core_schema.int_schema()),\n-        },\n-        **params,\n-    )\n-\n-    def walk(s, recurse):\n-        # change extra_validator['type'] to 'str'\n-        if s['type'] == 'float':\n-            s['type'] = 'str'\n-        return s\n-\n-    schema = _WalkCoreSchema().handle_typed_dict_schema(schema, walk)\n-    assert schema == {\n-        **expected_extra_schema,\n-        'type': 'typed-dict',\n-        'fields': {'foo': {'type': 'model-field', 'schema': {'type': 'int'}}},\n-    }\n-\n-\n-def test_handle_call_schema():\n-    param_a = core_schema.arguments_parameter(name='a', schema=core_schema.str_schema(), mode='positional_only')\n-    args_schema = core_schema.arguments_schema([param_a])\n-\n-    schema = core_schema.call_schema(\n-        arguments=args_schema,\n-        function=lambda a: int(a),\n-        return_schema=core_schema.str_schema(),\n-    )\n-\n-    def walk(s, recurse):\n-        # change return schema\n-        if 'return_schema' in schema:\n-            schema['return_schema']['type'] = 'int'\n-        return s\n-\n-    schema = _WalkCoreSchema().handle_call_schema(schema, walk)\n-    assert schema['return_schema'] == {'type': 'int'}\n-\n-\n-class TestModel:\n-    __slots__ = (\n-        '__dict__',\n-        '__pydantic_fields_set__',\n-        '__pydantic_extra__',\n-        '__pydantic_private__',\n-    )\n-\n-\n-@pytest.mark.parametrize(\n-    'include_metadata, schema, expected',\n-    [\n-        # including metadata with a simple any schema\n-        (\n-            True,\n-            core_schema.AnySchema(\n-                type='any',\n-                ref='meta_schema',\n-                metadata={'schema_type': 'any', 'test_id': '42'},\n-                serialization=core_schema.simple_ser_schema('bool'),\n-            ),\n-            {\n-                'type': 'any',\n-                'ref': 'meta_schema',\n-                'metadata': {'schema_type': 'any', 'test_id': '42'},\n-                'serialization': {'type': 'bool'},\n-            },\n-        ),\n-        # excluding metadata with a model_fields_schema\n-        (\n-            False,\n-            core_schema.model_fields_schema(\n-                ref='meta_schema',\n-                metadata={'schema_type': 'model', 'test_id': '43'},\n-                computed_fields=[\n-                    core_schema.computed_field(\n-                        property_name='TestModel',\n-                        return_schema=core_schema.model_fields_schema(\n-                            fields={'a': core_schema.model_field(core_schema.str_schema())},\n-                        ),\n-                        alias='comp_field_1',\n-                        metadata={'comp_field_key': 'comp_field_data'},\n-                    )\n-                ],\n-                fields={'a': core_schema.model_field(core_schema.str_schema())},\n-            ),\n-            {\n-                'type': 'model-fields',\n-                'fields': {'a': {'type': 'model-field', 'schema': {'type': 'str'}}},\n-                'computed_fields': [\n-                    {\n-                        'type': 'computed-field',\n-                        'property_name': 'TestModel',\n-                        'return_schema': {\n-                            'type': 'model-fields',\n-                            'fields': {'a': {'type': 'model-field', 'schema': {'type': 'str'}}},\n-                        },\n-                        'alias': 'comp_field_1',\n-                        'metadata': {'comp_field_key': 'comp_field_data'},\n-                    }\n-                ],\n-                'ref': 'meta_schema',\n-            },\n-        ),\n-        # exclude metadata with a model_schema\n-        (\n-            False,\n-            core_schema.model_schema(\n-                ref='meta_schema',\n-                metadata={'schema_type': 'model', 'test_id': '43'},\n-                custom_init=False,\n-                root_model=False,\n-                cls=TestModel,\n-                config=core_schema.CoreConfig(str_max_length=5),\n-                schema=core_schema.model_fields_schema(\n-                    fields={'a': core_schema.model_field(core_schema.str_schema())},\n-                ),\n-            ),\n-            {\n-                'type': 'model',\n-                'schema': {'type': 'model-fields', 'fields': {'a': {'type': 'model-field', 'schema': {'type': 'str'}}}},\n-                'config': {'str_max_length': 5},\n-                'ref': 'meta_schema',\n-            },\n-        ),\n-    ],\n-)\n-def test_pretty_print(include_metadata, schema, expected, capfd, monkeypatch):",
      "comment": "Again, as above, I thought we weren't removing this functionality?",
      "comment_id": 1931044764,
      "user": "sydney-runkle",
      "created_at": "2025-01-27T18:58:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931044764"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "tests/test_internal.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,185 +3,139 @@\n \"\"\"\n \n import sys\n+from copy import deepcopy\n from dataclasses import dataclass\n from decimal import Decimal\n+from typing import Any, Union\n \n import pytest\n-from pydantic_core import CoreSchema, SchemaValidator\n+from dirty_equals import Contains, IsPartialDict\n+from pydantic_core import CoreSchema\n from pydantic_core import core_schema as cs\n \n-from pydantic._internal._core_utils import (\n-    Walk,\n-    collect_invalid_schemas,\n-    simplify_schema_references,\n-    walk_core_schema,\n-)\n+from pydantic import BaseModel, TypeAdapter\n+from pydantic._internal._config import ConfigWrapper\n+from pydantic._internal._generate_schema import GenerateSchema\n from pydantic._internal._repr import Representation\n from pydantic._internal._validators import _extract_decimal_digits_info\n \n \n-def remove_metadata(schema: CoreSchema) -> CoreSchema:\n-    def inner(s: CoreSchema, recurse: Walk) -> CoreSchema:\n-        s = s.copy()\n-        s.pop('metadata', None)\n-        return recurse(s, inner)\n+def init_schema_and_cleaned_schema(type_: Any) -> tuple[CoreSchema, CoreSchema]:\n+    gen = GenerateSchema(ConfigWrapper(None))\n+    schema = gen.generate_schema(type_)\n+    cleaned_schema = deepcopy(schema)\n+    cleaned_schema = gen.clean_schema(cleaned_schema)\n+    assert TypeAdapter(type_).pydantic_complete  # Just to make sure it works and test setup is sane\n+    return schema, cleaned_schema\n \n-    return walk_core_schema(schema, inner)\n \n+def test_simple_core_schema_with_no_references() -> None:\n+    init, cleaned = init_schema_and_cleaned_schema(list[int])\n+    assert init == cs.list_schema(cs.int_schema())\n+    assert cleaned == cs.list_schema(cs.int_schema())\n \n-@pytest.mark.parametrize(\n-    'input_schema,inlined',\n-    [\n-        # Test case 1: Simple schema with no references\n-        (cs.list_schema(cs.int_schema()), cs.list_schema(cs.int_schema())),\n-        # Test case 2: Schema with single-level nested references\n-        (\n-            cs.definitions_schema(\n-                cs.list_schema(cs.definition_reference_schema('list_of_ints')),\n-                definitions=[\n-                    cs.list_schema(cs.definition_reference_schema('int'), ref='list_of_ints'),\n-                    cs.int_schema(ref='int'),\n-                ],\n-            ),\n-            cs.list_schema(cs.list_schema(cs.int_schema(ref='int'), ref='list_of_ints')),\n-        ),\n-        # Test case 3: Schema with multiple single-level nested references\n-        (\n-            cs.list_schema(\n-                cs.definitions_schema(cs.definition_reference_schema('int'), definitions=[cs.int_schema(ref='int')])\n-            ),\n-            cs.list_schema(cs.int_schema(ref='int')),\n-        ),\n-        # Test case 4: A simple recursive schema\n-        (\n-            cs.list_schema(cs.definition_reference_schema(schema_ref='list'), ref='list'),\n-            cs.definitions_schema(\n-                cs.definition_reference_schema(schema_ref='list'),\n-                definitions=[cs.list_schema(cs.definition_reference_schema(schema_ref='list'), ref='list')],\n-            ),\n-        ),\n-        # Test case 5: Deeply nested schema with multiple references\n-        (\n-            cs.definitions_schema(\n-                cs.list_schema(cs.definition_reference_schema('list_of_lists_of_ints')),\n-                definitions=[\n-                    cs.list_schema(cs.definition_reference_schema('list_of_ints'), ref='list_of_lists_of_ints'),\n-                    cs.list_schema(cs.definition_reference_schema('int'), ref='list_of_ints'),\n-                    cs.int_schema(ref='int'),\n-                ],\n-            ),\n-            cs.list_schema(\n-                cs.list_schema(\n-                    cs.list_schema(cs.int_schema(ref='int'), ref='list_of_ints'), ref='list_of_lists_of_ints'\n-                )\n-            ),\n-        ),\n-        # Test case 6: More complex recursive schema\n-        (\n-            cs.definitions_schema(\n-                cs.list_schema(cs.definition_reference_schema(schema_ref='list_of_ints_and_lists')),\n-                definitions=[\n-                    cs.list_schema(\n-                        cs.definitions_schema(\n-                            cs.definition_reference_schema(schema_ref='int_or_list'),\n-                            definitions=[\n-                                cs.int_schema(ref='int'),\n-                                cs.tuple_variable_schema(\n-                                    cs.definition_reference_schema(schema_ref='list_of_ints_and_lists'), ref='a tuple'\n-                                ),\n-                            ],\n-                        ),\n-                        ref='list_of_ints_and_lists',\n-                    ),\n-                    cs.int_schema(ref='int_or_list'),\n-                ],\n-            ),\n-            cs.list_schema(cs.list_schema(cs.int_schema(ref='int_or_list'), ref='list_of_ints_and_lists')),\n-        ),\n-        # Test case 7: Schema with multiple definitions and nested references, some of which are unused\n-        (\n-            cs.definitions_schema(\n-                cs.list_schema(cs.definition_reference_schema('list_of_ints')),\n-                definitions=[\n-                    cs.list_schema(\n-                        cs.definitions_schema(\n-                            cs.definition_reference_schema('int'), definitions=[cs.int_schema(ref='int')]\n-                        ),\n-                        ref='list_of_ints',\n-                    )\n-                ],\n-            ),\n-            cs.list_schema(cs.list_schema(cs.int_schema(ref='int'), ref='list_of_ints')),\n-        ),\n-        # Test case 8: Reference is used in multiple places\n-        (\n-            cs.definitions_schema(\n-                cs.union_schema(\n-                    [\n-                        cs.definition_reference_schema('list_of_ints'),\n-                        cs.tuple_variable_schema(cs.definition_reference_schema('int')),\n-                    ]\n-                ),\n-                definitions=[\n-                    cs.list_schema(cs.definition_reference_schema('int'), ref='list_of_ints'),\n-                    cs.int_schema(ref='int'),\n-                ],\n-            ),\n-            cs.definitions_schema(\n-                cs.union_schema(\n-                    [\n-                        cs.list_schema(cs.definition_reference_schema('int'), ref='list_of_ints'),\n-                        cs.tuple_variable_schema(cs.definition_reference_schema('int')),\n-                    ]\n-                ),\n-                definitions=[cs.int_schema(ref='int')],\n-            ),\n-        ),\n-        # Test case 9: https://github.com/pydantic/pydantic/issues/6270\n-        (\n-            cs.definitions_schema(\n-                cs.definition_reference_schema('model'),\n-                definitions=[\n-                    cs.typed_dict_schema(\n-                        {\n-                            'a': cs.typed_dict_field(\n-                                cs.nullable_schema(\n-                                    cs.int_schema(ref='ref'),\n-                                ),\n-                            ),\n-                            'b': cs.typed_dict_field(\n-                                cs.nullable_schema(\n-                                    cs.int_schema(ref='ref'),\n-                                ),\n-                            ),\n-                        },\n-                        ref='model',\n-                    ),\n-                ],\n-            ),\n-            cs.definitions_schema(\n-                cs.typed_dict_schema(\n-                    {\n-                        'a': cs.typed_dict_field(\n-                            cs.nullable_schema(cs.definition_reference_schema(schema_ref='ref')),\n-                        ),\n-                        'b': cs.typed_dict_field(\n-                            cs.nullable_schema(cs.definition_reference_schema(schema_ref='ref')),\n-                        ),\n-                    },\n-                    ref='model',\n-                ),\n-                definitions=[\n-                    cs.int_schema(ref='ref'),\n-                ],\n-            ),\n-        ),\n-    ],\n+\n+@pytest.mark.parametrize('deep_ref', [False, True])\n+def test_core_schema_with_different_reference_depths_gets_inlined(deep_ref: bool) -> None:\n+    class M1(BaseModel):\n+        a: int\n+\n+    class M2(BaseModel):\n+        b: M1\n+\n+    init, cleaned = init_schema_and_cleaned_schema(list[M2] if deep_ref else M2)\n+\n+    inner = IsPartialDict(type='definition-ref', schema_ref=Contains('M2'))\n+    assert init == (IsPartialDict(type='list', items_schema=inner) if deep_ref else inner)\n+\n+    inner = IsPartialDict(\n+        type='model',\n+        cls=M2,\n+        schema=IsPartialDict(fields={'b': IsPartialDict(schema=IsPartialDict(type='model', cls=M1))}),\n+    )\n+    assert cleaned == (IsPartialDict(type='list', items_schema=inner) if deep_ref else inner)\n+\n+\n+@pytest.mark.parametrize('deep_ref', [False, True])\n+@pytest.mark.xfail(\n+    reason=(\n+        \"While the cleaned schema is of type 'definitions', the inner schema is inlined. This is not an \"\n+        'issue, but the test is kept so that we notice the change when tweaking core schema generation.'\n+    )\n )\n-def test_build_schema_defs(input_schema: cs.CoreSchema, inlined: cs.CoreSchema):\n-    actual_inlined = remove_metadata(simplify_schema_references(input_schema))\n-    assert actual_inlined == inlined\n-    SchemaValidator(actual_inlined)  # check for validity\n+def test_core_schema_simple_recursive_schema_uses_refs(deep_ref: bool) -> None:\n+    class M1(BaseModel):\n+        a: 'M2'\n+\n+    class M2(BaseModel):\n+        b: M1\n+\n+    init, cleaned = init_schema_and_cleaned_schema(list[M1] if deep_ref else M1)\n+\n+    inner = IsPartialDict(type='definition-ref', schema_ref=Contains('M1'))\n+    assert init == (IsPartialDict(type='list', items_schema=inner) if deep_ref else inner)\n+\n+    inner = IsPartialDict(type='definition-ref', schema_ref=Contains('M1'))\n+    assert cleaned == IsPartialDict(\n+        type='definitions',\n+        schema=IsPartialDict(type='list', items_schema=inner) if deep_ref else inner,\n+        definitions=[IsPartialDict(type='model', ref=Contains('M1')), IsPartialDict(type='model', ref=Contains('M2'))],\n+    )\n+\n+\n+@pytest.mark.parametrize('deep_ref', [False, True])",
      "comment": "Could you explain the deep ref concept here? Just that the ref to said model is nested in a list? Maybe we could name it something more intuitive to do with lists?",
      "comment_id": 1931051130,
      "user": "sydney-runkle",
      "created_at": "2025-01-27T19:04:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931051130"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2520,
      "side": "RIGHT",
      "diff_hunk": "@@ -2508,6 +2506,23 @@ def _common_field(\n     }\n \n \n+def resolve_original_schema(schema: CoreSchema, definitions: _Definitions) -> CoreSchema | None:\n+    if schema['type'] == 'definition-ref':\n+        return definitions.get_schema_from_ref(schema['schema_ref'])\n+    elif schema['type'] == 'definitions':\n+        return schema['schema']\n+    else:\n+        return schema\n+\n+\n+def _can_be_inlined(def_ref: core_schema.DefinitionReferenceSchema) -> bool:",
      "comment": "Why can't we inline if there's metadata, ex json schema related metadata?",
      "comment_id": 1931055372,
      "user": "sydney-runkle",
      "created_at": "2025-01-27T19:07:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931055372"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2550,
      "side": "RIGHT",
      "diff_hunk": "@@ -2529,9 +2544,15 @@ class _Definitions:\n     manager.\n     \"\"\"\n \n+    # TODO: more reasoning should be added as to why this is necessary (or at least used, as\n+    # *not* making the distinction with other collected definitions does not break anything).\n+    _unpacked_definitions: dict[str, core_schema.CoreSchema]\n+    \"\"\"Definitions coming from an external source (e.g. cached model schemas or from the `__get_pydantic_core_schema__` method).\"\"\"",
      "comment": "Yeah, would like clarification on this before we merge",
      "comment_id": 1931060731,
      "user": "sydney-runkle",
      "created_at": "2025-01-27T19:12:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931060731"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2605,
      "side": "RIGHT",
      "diff_hunk": "@@ -2580,34 +2601,73 @@ def create_definition_reference_schema(self, schema: CoreSchema) -> core_schema.\n         return core_schema.definition_reference_schema(ref)\n \n     def unpack_definitions(self, schema: core_schema.DefinitionsSchema) -> CoreSchema:\n-        \"\"\"Store the definitions of the `'definitions` core schema and return the inner core schema.\"\"\"\n+        \"\"\"Store the definitions of the `'definitions'` core schema and return the inner core schema.\"\"\"\n         for def_schema in schema['definitions']:\n-            self._definitions[def_schema['ref']] = def_schema  # pyright: ignore\n+            self._unpacked_definitions[def_schema['ref']] = def_schema  # pyright: ignore\n         return schema['schema']\n \n-    def as_definitions_schema(self, schema: CoreSchema) -> CoreSchema:\n-        \"\"\"Create a `'definitions'` schema containing all the collected definitions.\n+    def finalize_schema(self, schema: CoreSchema) -> CoreSchema:",
      "comment": "This is much cleaner and easier to understand, nice work on the comments",
      "comment_id": 1931065799,
      "user": "sydney-runkle",
      "created_at": "2025-01-27T19:15:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931065799"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2645,
      "side": "RIGHT",
      "diff_hunk": "@@ -2580,34 +2601,73 @@ def create_definition_reference_schema(self, schema: CoreSchema) -> core_schema.\n         return core_schema.definition_reference_schema(ref)\n \n     def unpack_definitions(self, schema: core_schema.DefinitionsSchema) -> CoreSchema:\n-        \"\"\"Store the definitions of the `'definitions` core schema and return the inner core schema.\"\"\"\n+        \"\"\"Store the definitions of the `'definitions'` core schema and return the inner core schema.\"\"\"\n         for def_schema in schema['definitions']:\n-            self._definitions[def_schema['ref']] = def_schema  # pyright: ignore\n+            self._unpacked_definitions[def_schema['ref']] = def_schema  # pyright: ignore\n         return schema['schema']\n \n-    def as_definitions_schema(self, schema: CoreSchema) -> CoreSchema:\n-        \"\"\"Create a `'definitions'` schema containing all the collected definitions.\n+    def finalize_schema(self, schema: CoreSchema) -> CoreSchema:\n+        \"\"\"Finalize the core schema.\n \n-        If the passed schema contains a reference, it is also stored in the definitions list,\n-        and substituted by a `'definition-reference'` schema.\n+        This traverses the core schema and referenced definitions, replaces `'definition-ref'` schemas\n+        by the referenced definition if possible, and applies deferred discriminators.\n         \"\"\"\n-        if 'ref' in schema:\n-            schema = self.create_definition_reference_schema(schema)\n-\n-        return core_schema.definitions_schema(\n-            schema,\n-            list(self._definitions.values()),\n-        )\n-\n-\n-def resolve_original_schema(schema: CoreSchema, definitions: _Definitions) -> CoreSchema | None:\n-    if schema['type'] == 'definition-ref':\n-        return definitions.get_schema_from_ref(schema['schema_ref'])\n-    elif schema['type'] == 'definitions':\n-        return schema['schema']\n-    else:\n+        definitions = self._definitions\n+        if self._unpacked_definitions:\n+            definitions = {**self._unpacked_definitions, **definitions}\n+        try:\n+            gather_result = gather_schemas_for_cleaning(\n+                schema,\n+                definitions=definitions,\n+            )\n+        except MissingDefinitionError as e:\n+            raise InvalidSchemaError from e\n+\n+        remaining_defs: dict[str, CoreSchema] = {}\n+\n+        for ref, inlinable_def_ref in gather_result['collected_references'].items():\n+            if inlinable_def_ref is not None and _can_be_inlined(inlinable_def_ref):\n+                # `ref` was encountered, and only once:\n+                #  - `inlinable_def_ref` is a `'definition-ref'` schema and is guaranteed to be\n+                #    the only one. Transform it into the definition it points to.\n+                #  - Do not store the definition in the `remaining_defs`.\n+                inlinable_def_ref.clear()  # pyright: ignore[reportAttributeAccessIssue]\n+                inlinable_def_ref.update(self._resolve_definition(ref, definitions))  # pyright: ignore\n+            else:\n+                # `ref` was encountered, at least two times:\n+                # - Do not inline the `'definition-ref'` schemas (they are not provided in the gather result anyway).\n+                # - Store the the definition in the `remaining_defs`\n+                remaining_defs[ref] = self._resolve_definition(ref, definitions)\n+\n+        for cs in gather_result['deferred_discriminator_schemas']:\n+            discriminator = cs['metadata']['pydantic_internal_union_discriminator']  # pyright: ignore[reportTypedDictNotRequiredAccess]\n+            applied = _discriminated_union.apply_discriminator(cs.copy(), discriminator, remaining_defs)\n+            # Mutate the schema directly to have the discriminator applied\n+            cs.clear()  # pyright: ignore[reportAttributeAccessIssue]\n+            cs.update(applied)  # pyright: ignore\n+\n+        if remaining_defs:\n+            schema = core_schema.definitions_schema(schema=schema, definitions=[*remaining_defs.values()])\n         return schema",
      "comment": "Is it possible that `schema` would have already been a `definitions` schema? No, right?",
      "comment_id": 1931067795,
      "user": "sydney-runkle",
      "created_at": "2025-01-27T19:17:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931067795"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 600,
      "side": "LEFT",
      "diff_hunk": "@@ -107,499 +103,6 @@ def get_ref(s: core_schema.CoreSchema) -> None | str:\n     return s.get('ref', None)\n \n \n-def collect_definitions(schema: core_schema.CoreSchema) -> dict[str, core_schema.CoreSchema]:\n-    defs: dict[str, CoreSchema] = {}\n-\n-    def _record_valid_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n-        ref = get_ref(s)\n-        if ref:\n-            defs[ref] = s\n-        return recurse(s, _record_valid_refs)\n-\n-    walk_core_schema(schema, _record_valid_refs, copy=False)\n-\n-    return defs\n-\n-\n-def define_expected_missing_refs(\n-    schema: core_schema.CoreSchema, allowed_missing_refs: set[str]\n-) -> core_schema.CoreSchema | None:\n-    if not allowed_missing_refs:\n-        # in this case, there are no missing refs to potentially substitute, so there's no need to walk the schema\n-        # this is a common case (will be hit for all non-generic models), so it's worth optimizing for\n-        return None\n-\n-    refs = collect_definitions(schema).keys()\n-\n-    expected_missing_refs = allowed_missing_refs.difference(refs)\n-    if expected_missing_refs:\n-        definitions: list[core_schema.CoreSchema] = [\n-            core_schema.invalid_schema(ref=ref) for ref in expected_missing_refs\n-        ]\n-        return core_schema.definitions_schema(schema, definitions)\n-    return None\n-\n-\n-def collect_invalid_schemas(schema: core_schema.CoreSchema) -> bool:\n-    invalid = False\n-\n-    def _is_schema_valid(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n-        nonlocal invalid\n-\n-        if s['type'] == 'invalid':\n-            invalid = True\n-            return s\n-\n-        return recurse(s, _is_schema_valid)\n-\n-    walk_core_schema(schema, _is_schema_valid, copy=False)\n-    return invalid\n-\n-\n-T = TypeVar('T')\n-\n-\n-Recurse = Callable[[core_schema.CoreSchema, 'Walk'], core_schema.CoreSchema]\n-Walk = Callable[[core_schema.CoreSchema, Recurse], core_schema.CoreSchema]\n-\n-# TODO: Should we move _WalkCoreSchema into pydantic_core proper?\n-#   Issue: https://github.com/pydantic/pydantic-core/issues/615\n-\n-CoreSchemaT = TypeVar('CoreSchemaT')\n-\n-\n-class _WalkCoreSchema:\n-    def __init__(self, *, copy: bool = True):\n-        self._schema_type_to_method = self._build_schema_type_to_method()\n-        self._copy = copy\n-\n-    def _copy_schema(self, schema: CoreSchemaT) -> CoreSchemaT:\n-        return schema.copy() if self._copy else schema  # pyright: ignore[reportAttributeAccessIssue]\n-\n-    def _build_schema_type_to_method(self) -> dict[core_schema.CoreSchemaType, Recurse]:\n-        mapping: dict[core_schema.CoreSchemaType, Recurse] = {}\n-        key: core_schema.CoreSchemaType\n-        for key in get_args(core_schema.CoreSchemaType):\n-            method_name = f'handle_{key.replace(\"-\", \"_\")}_schema'\n-            mapping[key] = getattr(self, method_name, self._handle_other_schemas)\n-        return mapping\n-\n-    def walk(self, schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:\n-        return f(schema, self._walk)\n-\n-    def _walk(self, schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:\n-        schema = self._schema_type_to_method[schema['type']](self._copy_schema(schema), f)\n-        ser_schema: core_schema.SerSchema | None = schema.get('serialization')  # type: ignore\n-        if ser_schema:\n-            schema['serialization'] = self._handle_ser_schemas(ser_schema, f)\n-        return schema\n-\n-    def _handle_other_schemas(self, schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:\n-        sub_schema = schema.get('schema', None)\n-        if sub_schema is not None:\n-            schema['schema'] = self.walk(sub_schema, f)  # type: ignore\n-        return schema\n-\n-    def _handle_ser_schemas(self, ser_schema: core_schema.SerSchema, f: Walk) -> core_schema.SerSchema:\n-        schema: core_schema.CoreSchema | None = ser_schema.get('schema', None)\n-        return_schema: core_schema.CoreSchema | None = ser_schema.get('return_schema', None)\n-        if schema is not None or return_schema is not None:\n-            ser_schema = self._copy_schema(ser_schema)\n-            if schema is not None:\n-                ser_schema['schema'] = self.walk(schema, f)  # type: ignore\n-            if return_schema is not None:\n-                ser_schema['return_schema'] = self.walk(return_schema, f)  # type: ignore\n-        return ser_schema\n-\n-    def handle_definitions_schema(self, schema: core_schema.DefinitionsSchema, f: Walk) -> core_schema.CoreSchema:\n-        new_definitions: list[core_schema.CoreSchema] = []\n-        for definition in schema['definitions']:\n-            if 'schema_ref' in definition and 'ref' in definition:\n-                # This indicates a purposely indirect reference\n-                # We want to keep such references around for implications related to JSON schema, etc.:\n-                new_definitions.append(definition)\n-                # However, we still need to walk the referenced definition:\n-                self.walk(definition, f)\n-                continue\n-\n-            updated_definition = self.walk(definition, f)\n-            if 'ref' in updated_definition:\n-                # If the updated definition schema doesn't have a 'ref', it shouldn't go in the definitions\n-                # This is most likely to happen due to replacing something with a definition reference, in\n-                # which case it should certainly not go in the definitions list\n-                new_definitions.append(updated_definition)\n-        new_inner_schema = self.walk(schema['schema'], f)\n-\n-        if not new_definitions and len(schema) == 3:\n-            # This means we'd be returning a \"trivial\" definitions schema that just wrapped the inner schema\n-            return new_inner_schema\n-\n-        new_schema = self._copy_schema(schema)\n-        new_schema['schema'] = new_inner_schema\n-        new_schema['definitions'] = new_definitions\n-        return new_schema\n-\n-    def handle_list_schema(self, schema: core_schema.ListSchema, f: Walk) -> core_schema.CoreSchema:\n-        items_schema = schema.get('items_schema')\n-        if items_schema is not None:\n-            schema['items_schema'] = self.walk(items_schema, f)\n-        return schema\n-\n-    def handle_set_schema(self, schema: core_schema.SetSchema, f: Walk) -> core_schema.CoreSchema:\n-        items_schema = schema.get('items_schema')\n-        if items_schema is not None:\n-            schema['items_schema'] = self.walk(items_schema, f)\n-        return schema\n-\n-    def handle_frozenset_schema(self, schema: core_schema.FrozenSetSchema, f: Walk) -> core_schema.CoreSchema:\n-        items_schema = schema.get('items_schema')\n-        if items_schema is not None:\n-            schema['items_schema'] = self.walk(items_schema, f)\n-        return schema\n-\n-    def handle_generator_schema(self, schema: core_schema.GeneratorSchema, f: Walk) -> core_schema.CoreSchema:\n-        items_schema = schema.get('items_schema')\n-        if items_schema is not None:\n-            schema['items_schema'] = self.walk(items_schema, f)\n-        return schema\n-\n-    def handle_tuple_schema(self, schema: core_schema.TupleSchema, f: Walk) -> core_schema.CoreSchema:\n-        schema['items_schema'] = [self.walk(v, f) for v in schema['items_schema']]\n-        return schema\n-\n-    def handle_dict_schema(self, schema: core_schema.DictSchema, f: Walk) -> core_schema.CoreSchema:\n-        keys_schema = schema.get('keys_schema')\n-        if keys_schema is not None:\n-            schema['keys_schema'] = self.walk(keys_schema, f)\n-        values_schema = schema.get('values_schema')\n-        if values_schema:\n-            schema['values_schema'] = self.walk(values_schema, f)\n-        return schema\n-\n-    def handle_function_after_schema(\n-        self, schema: core_schema.AfterValidatorFunctionSchema, f: Walk\n-    ) -> core_schema.CoreSchema:\n-        schema['schema'] = self.walk(schema['schema'], f)\n-        return schema\n-\n-    def handle_function_before_schema(\n-        self, schema: core_schema.BeforeValidatorFunctionSchema, f: Walk\n-    ) -> core_schema.CoreSchema:\n-        schema['schema'] = self.walk(schema['schema'], f)\n-        if 'json_schema_input_schema' in schema:\n-            schema['json_schema_input_schema'] = self.walk(schema['json_schema_input_schema'], f)\n-        return schema\n-\n-    # TODO duplicate schema types for serializers and validators, needs to be deduplicated:\n-    def handle_function_plain_schema(\n-        self, schema: core_schema.PlainValidatorFunctionSchema | core_schema.PlainSerializerFunctionSerSchema, f: Walk\n-    ) -> core_schema.CoreSchema:\n-        if 'json_schema_input_schema' in schema:\n-            schema['json_schema_input_schema'] = self.walk(schema['json_schema_input_schema'], f)\n-        return schema  # pyright: ignore[reportReturnType]\n-\n-    # TODO duplicate schema types for serializers and validators, needs to be deduplicated:\n-    def handle_function_wrap_schema(\n-        self, schema: core_schema.WrapValidatorFunctionSchema | core_schema.WrapSerializerFunctionSerSchema, f: Walk\n-    ) -> core_schema.CoreSchema:\n-        if 'schema' in schema:\n-            schema['schema'] = self.walk(schema['schema'], f)\n-        if 'json_schema_input_schema' in schema:\n-            schema['json_schema_input_schema'] = self.walk(schema['json_schema_input_schema'], f)\n-        return schema  # pyright: ignore[reportReturnType]\n-\n-    def handle_union_schema(self, schema: core_schema.UnionSchema, f: Walk) -> core_schema.CoreSchema:\n-        new_choices: list[CoreSchema | tuple[CoreSchema, str]] = []\n-        for v in schema['choices']:\n-            if isinstance(v, tuple):\n-                new_choices.append((self.walk(v[0], f), v[1]))\n-            else:\n-                new_choices.append(self.walk(v, f))\n-        schema['choices'] = new_choices\n-        return schema\n-\n-    def handle_tagged_union_schema(self, schema: core_schema.TaggedUnionSchema, f: Walk) -> core_schema.CoreSchema:\n-        new_choices: dict[Hashable, core_schema.CoreSchema] = {}\n-        for k, v in schema['choices'].items():\n-            new_choices[k] = v if isinstance(v, (str, int)) else self.walk(v, f)\n-        schema['choices'] = new_choices\n-        return schema\n-\n-    def handle_chain_schema(self, schema: core_schema.ChainSchema, f: Walk) -> core_schema.CoreSchema:\n-        schema['steps'] = [self.walk(v, f) for v in schema['steps']]\n-        return schema\n-\n-    def handle_lax_or_strict_schema(self, schema: core_schema.LaxOrStrictSchema, f: Walk) -> core_schema.CoreSchema:\n-        schema['lax_schema'] = self.walk(schema['lax_schema'], f)\n-        schema['strict_schema'] = self.walk(schema['strict_schema'], f)\n-        return schema\n-\n-    def handle_json_or_python_schema(self, schema: core_schema.JsonOrPythonSchema, f: Walk) -> core_schema.CoreSchema:\n-        schema['json_schema'] = self.walk(schema['json_schema'], f)\n-        schema['python_schema'] = self.walk(schema['python_schema'], f)\n-        return schema\n-\n-    def handle_model_fields_schema(self, schema: core_schema.ModelFieldsSchema, f: Walk) -> core_schema.CoreSchema:\n-        extras_schema = schema.get('extras_schema')\n-        if extras_schema is not None:\n-            schema['extras_schema'] = self.walk(extras_schema, f)\n-        replaced_fields: dict[str, core_schema.ModelField] = {}\n-        replaced_computed_fields: list[core_schema.ComputedField] = []\n-        for computed_field in schema.get('computed_fields', ()):\n-            replaced_field = self._copy_schema(computed_field)\n-            replaced_field['return_schema'] = self.walk(computed_field['return_schema'], f)\n-            replaced_computed_fields.append(replaced_field)\n-        if replaced_computed_fields:\n-            schema['computed_fields'] = replaced_computed_fields\n-        for k, v in schema['fields'].items():\n-            replaced_field = self._copy_schema(v)\n-            replaced_field['schema'] = self.walk(v['schema'], f)\n-            replaced_fields[k] = replaced_field\n-        schema['fields'] = replaced_fields\n-        return schema\n-\n-    def handle_typed_dict_schema(self, schema: core_schema.TypedDictSchema, f: Walk) -> core_schema.CoreSchema:\n-        extras_schema = schema.get('extras_schema')\n-        if extras_schema is not None:\n-            schema['extras_schema'] = self.walk(extras_schema, f)\n-        replaced_computed_fields: list[core_schema.ComputedField] = []\n-        for computed_field in schema.get('computed_fields', ()):\n-            replaced_field = self._copy_schema(computed_field)\n-            replaced_field['return_schema'] = self.walk(computed_field['return_schema'], f)\n-            replaced_computed_fields.append(replaced_field)\n-        if replaced_computed_fields:\n-            schema['computed_fields'] = replaced_computed_fields\n-        replaced_fields: dict[str, core_schema.TypedDictField] = {}\n-        for k, v in schema['fields'].items():\n-            replaced_field = self._copy_schema(v)\n-            replaced_field['schema'] = self.walk(v['schema'], f)\n-            replaced_fields[k] = replaced_field\n-        schema['fields'] = replaced_fields\n-        return schema\n-\n-    def handle_dataclass_args_schema(self, schema: core_schema.DataclassArgsSchema, f: Walk) -> core_schema.CoreSchema:\n-        replaced_fields: list[core_schema.DataclassField] = []\n-        replaced_computed_fields: list[core_schema.ComputedField] = []\n-        for computed_field in schema.get('computed_fields', ()):\n-            replaced_field = self._copy_schema(computed_field)\n-            replaced_field['return_schema'] = self.walk(computed_field['return_schema'], f)\n-            replaced_computed_fields.append(replaced_field)\n-        if replaced_computed_fields:\n-            schema['computed_fields'] = replaced_computed_fields\n-        for field in schema['fields']:\n-            replaced_field = self._copy_schema(field)\n-            replaced_field['schema'] = self.walk(field['schema'], f)\n-            replaced_fields.append(replaced_field)\n-        schema['fields'] = replaced_fields\n-        return schema\n-\n-    def handle_arguments_schema(self, schema: core_schema.ArgumentsSchema, f: Walk) -> core_schema.CoreSchema:\n-        replaced_arguments_schema: list[core_schema.ArgumentsParameter] = []\n-        for param in schema['arguments_schema']:\n-            replaced_param = self._copy_schema(param)\n-            replaced_param['schema'] = self.walk(param['schema'], f)\n-            replaced_arguments_schema.append(replaced_param)\n-        schema['arguments_schema'] = replaced_arguments_schema\n-        if 'var_args_schema' in schema:\n-            schema['var_args_schema'] = self.walk(schema['var_args_schema'], f)\n-        if 'var_kwargs_schema' in schema:\n-            schema['var_kwargs_schema'] = self.walk(schema['var_kwargs_schema'], f)\n-        return schema\n-\n-    def handle_call_schema(self, schema: core_schema.CallSchema, f: Walk) -> core_schema.CoreSchema:\n-        schema['arguments_schema'] = self.walk(schema['arguments_schema'], f)\n-        if 'return_schema' in schema:\n-            schema['return_schema'] = self.walk(schema['return_schema'], f)\n-        return schema\n-\n-\n-_dispatch = _WalkCoreSchema().walk\n-_dispatch_no_copy = _WalkCoreSchema(copy=False).walk\n-\n-\n-def walk_core_schema(schema: core_schema.CoreSchema, f: Walk, *, copy: bool = True) -> core_schema.CoreSchema:\n-    \"\"\"Recursively traverse a CoreSchema.\n-\n-    Args:\n-        schema (core_schema.CoreSchema): The CoreSchema to process, it will not be modified.\n-        f (Walk): A function to apply. This function takes two arguments:\n-          1. The current CoreSchema that is being processed\n-             (not the same one you passed into this function, one level down).\n-          2. The \"next\" `f` to call. This lets you for example use `f=functools.partial(some_method, some_context)`\n-             to pass data down the recursive calls without using globals or other mutable state.\n-        copy: Whether schema should be recursively copied.\n-\n-    Returns:\n-        core_schema.CoreSchema: A processed CoreSchema.\n-    \"\"\"\n-    return f(schema.copy() if copy else schema, _dispatch if copy else _dispatch_no_copy)\n-\n-\n-def simplify_schema_references(schema: core_schema.CoreSchema) -> core_schema.CoreSchema:  # noqa: C901\n-    definitions: dict[str, core_schema.CoreSchema] = {}\n-    ref_counts: dict[str, int] = defaultdict(int)\n-    involved_in_recursion: dict[str, bool] = {}\n-    current_recursion_ref_count: dict[str, int] = defaultdict(int)\n-\n-    def collect_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n-        if s['type'] == 'definitions':\n-            for definition in s['definitions']:\n-                ref = get_ref(definition)\n-                assert ref is not None\n-                if ref not in definitions:\n-                    definitions[ref] = definition\n-                recurse(definition, collect_refs)\n-            return recurse(s['schema'], collect_refs)\n-        else:\n-            ref = get_ref(s)\n-            if ref is not None:\n-                new = recurse(s, collect_refs)\n-                new_ref = get_ref(new)\n-                if new_ref:\n-                    definitions[new_ref] = new\n-                return core_schema.definition_reference_schema(schema_ref=ref)\n-            else:\n-                return recurse(s, collect_refs)\n-\n-    schema = walk_core_schema(schema, collect_refs)\n-\n-    def count_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n-        if s['type'] != 'definition-ref':\n-            return recurse(s, count_refs)\n-        ref = s['schema_ref']\n-        ref_counts[ref] += 1\n-\n-        if ref_counts[ref] >= 2:\n-            # If this model is involved in a recursion this should be detected\n-            # on its second encounter, we can safely stop the walk here.\n-            if current_recursion_ref_count[ref] != 0:\n-                involved_in_recursion[ref] = True\n-            return s\n-\n-        current_recursion_ref_count[ref] += 1\n-        if 'serialization' in s:\n-            # Even though this is a `'definition-ref'` schema, there might\n-            # be more references inside the serialization schema:\n-            recurse(s, count_refs)\n-\n-        next_s = definitions[ref]\n-        visited: set[str] = set()\n-        while next_s['type'] == 'definition-ref':\n-            if next_s['schema_ref'] in visited:\n-                raise PydanticUserError(\n-                    f'{ref} contains a circular reference to itself.', code='circular-reference-schema'\n-                )\n-\n-            visited.add(next_s['schema_ref'])\n-            ref_counts[next_s['schema_ref']] += 1\n-            next_s = definitions[next_s['schema_ref']]\n-\n-        recurse(next_s, count_refs)\n-        current_recursion_ref_count[ref] -= 1\n-        return s\n-\n-    schema = walk_core_schema(schema, count_refs, copy=False)\n-\n-    assert all(c == 0 for c in current_recursion_ref_count.values()), 'this is a bug! please report it'\n-\n-    def can_be_inlined(s: core_schema.DefinitionReferenceSchema, ref: str) -> bool:\n-        if ref_counts[ref] > 1:\n-            return False\n-        if involved_in_recursion.get(ref, False):\n-            return False\n-        if 'serialization' in s:\n-            return False\n-        if 'metadata' in s:\n-            metadata = s['metadata']\n-            for k in [\n-                *CoreMetadata.__annotations__.keys(),\n-                'pydantic.internal.union_discriminator',\n-                'pydantic.internal.tagged_union_tag',\n-            ]:\n-                if k in metadata:\n-                    # we need to keep this as a ref\n-                    return False\n-        return True\n-\n-    def inline_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n-        # Assume there are no infinite loops, because we already checked for that in `count_refs`\n-        while s['type'] == 'definition-ref':\n-            ref = s['schema_ref']\n-\n-            # Check if the reference is only used once, not involved in recursion and does not have\n-            # any extra keys (like 'serialization')\n-            if can_be_inlined(s, ref):\n-                # Inline the reference by replacing the reference with the actual schema\n-                new = definitions.pop(ref)\n-                ref_counts[ref] -= 1  # because we just replaced it!\n-                # put all other keys that were on the def-ref schema into the inlined version\n-                # in particular this is needed for `serialization`\n-                if 'serialization' in s:\n-                    new['serialization'] = s['serialization']\n-                s = new\n-            else:\n-                break\n-        return recurse(s, inline_refs)\n-\n-    schema = walk_core_schema(schema, inline_refs, copy=False)\n-\n-    def_values = [v for v in definitions.values() if ref_counts[v['ref']] > 0]  # type: ignore\n-\n-    if def_values:\n-        schema = core_schema.definitions_schema(schema=schema, definitions=def_values)\n-    return schema\n-\n-\n-def _strip_metadata(schema: CoreSchema) -> CoreSchema:\n-    def strip_metadata(s: CoreSchema, recurse: Recurse) -> CoreSchema:\n-        s = s.copy()\n-        s.pop('metadata', None)\n-        if s['type'] == 'model-fields':\n-            s = s.copy()\n-            s['fields'] = {k: v.copy() for k, v in s['fields'].items()}\n-            for field_name, field_schema in s['fields'].items():\n-                field_schema.pop('metadata', None)\n-                s['fields'][field_name] = field_schema\n-            computed_fields = s.get('computed_fields', None)\n-            if computed_fields:\n-                s['computed_fields'] = [cf.copy() for cf in computed_fields]\n-                for cf in computed_fields:\n-                    cf.pop('metadata', None)\n-            else:\n-                s.pop('computed_fields', None)\n-        elif s['type'] == 'model':\n-            # remove some defaults\n-            if s.get('custom_init', True) is False:\n-                s.pop('custom_init')\n-            if s.get('root_model', True) is False:\n-                s.pop('root_model')\n-            if {'title'}.issuperset(s.get('config', {}).keys()):\n-                s.pop('config', None)\n-\n-        return recurse(s, strip_metadata)\n-\n-    return walk_core_schema(schema, strip_metadata)\n-\n-\n-def pretty_print_core_schema(\n-    schema: CoreSchema,\n-    include_metadata: bool = False,\n-) -> None:\n-    \"\"\"Pretty print a CoreSchema using rich.\n-    This is intended for debugging purposes.\n-\n-    Args:\n-        schema: The CoreSchema to print.\n-        include_metadata: Whether to include metadata in the output. Defaults to `False`.\n-    \"\"\"\n-    from rich import print  # type: ignore  # install it manually in your dev env\n-\n-    if not include_metadata:\n-        schema = _strip_metadata(schema)\n-\n-    return print(schema)",
      "comment": "We did not come to a conclusion, but I'll add the `pydantic-devtools` version and make use of it for the custom pdb class",
      "comment_id": 1931900623,
      "user": "Viicos",
      "created_at": "2025-01-28T10:19:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931900623"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 857,
      "side": "RIGHT",
      "diff_hunk": "@@ -858,6 +850,12 @@ def _generate_schema_from_get_schema_method(self, obj: Any, source: Any) -> core\n             ref = get_ref(schema)\n             if ref:\n                 return self.defs.create_definition_reference_schema(schema)\n+\n+            if schema['type'] == 'definition-ref':\n+                # As a safety measure (because `'definition-ref'` schemas are inlined\n+                # in place -- i.e. mutated directly), copy the schema:\n+                return schema.copy()",
      "comment": "Although we don't have anything preventing it from happening, we always generate a new `'definition-ref'` schema if necessary. But as `schema` comes from a GPCS method here, it might be that some user is returning the same `'definition-ref'` schema instance from previous calls.\r\n\r\nThe chances that this can happen are probably really low, so I'm +-0 on keeping/removing this safety copy",
      "comment_id": 1931910017,
      "user": "Viicos",
      "created_at": "2025-01-28T10:26:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931910017"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2645,
      "side": "RIGHT",
      "diff_hunk": "@@ -2580,34 +2601,73 @@ def create_definition_reference_schema(self, schema: CoreSchema) -> core_schema.\n         return core_schema.definition_reference_schema(ref)\n \n     def unpack_definitions(self, schema: core_schema.DefinitionsSchema) -> CoreSchema:\n-        \"\"\"Store the definitions of the `'definitions` core schema and return the inner core schema.\"\"\"\n+        \"\"\"Store the definitions of the `'definitions'` core schema and return the inner core schema.\"\"\"\n         for def_schema in schema['definitions']:\n-            self._definitions[def_schema['ref']] = def_schema  # pyright: ignore\n+            self._unpacked_definitions[def_schema['ref']] = def_schema  # pyright: ignore\n         return schema['schema']\n \n-    def as_definitions_schema(self, schema: CoreSchema) -> CoreSchema:\n-        \"\"\"Create a `'definitions'` schema containing all the collected definitions.\n+    def finalize_schema(self, schema: CoreSchema) -> CoreSchema:\n+        \"\"\"Finalize the core schema.\n \n-        If the passed schema contains a reference, it is also stored in the definitions list,\n-        and substituted by a `'definition-reference'` schema.\n+        This traverses the core schema and referenced definitions, replaces `'definition-ref'` schemas\n+        by the referenced definition if possible, and applies deferred discriminators.\n         \"\"\"\n-        if 'ref' in schema:\n-            schema = self.create_definition_reference_schema(schema)\n-\n-        return core_schema.definitions_schema(\n-            schema,\n-            list(self._definitions.values()),\n-        )\n-\n-\n-def resolve_original_schema(schema: CoreSchema, definitions: _Definitions) -> CoreSchema | None:\n-    if schema['type'] == 'definition-ref':\n-        return definitions.get_schema_from_ref(schema['schema_ref'])\n-    elif schema['type'] == 'definitions':\n-        return schema['schema']\n-    else:\n+        definitions = self._definitions\n+        if self._unpacked_definitions:\n+            definitions = {**self._unpacked_definitions, **definitions}\n+        try:\n+            gather_result = gather_schemas_for_cleaning(\n+                schema,\n+                definitions=definitions,\n+            )\n+        except MissingDefinitionError as e:\n+            raise InvalidSchemaError from e\n+\n+        remaining_defs: dict[str, CoreSchema] = {}\n+\n+        for ref, inlinable_def_ref in gather_result['collected_references'].items():\n+            if inlinable_def_ref is not None and _can_be_inlined(inlinable_def_ref):\n+                # `ref` was encountered, and only once:\n+                #  - `inlinable_def_ref` is a `'definition-ref'` schema and is guaranteed to be\n+                #    the only one. Transform it into the definition it points to.\n+                #  - Do not store the definition in the `remaining_defs`.\n+                inlinable_def_ref.clear()  # pyright: ignore[reportAttributeAccessIssue]\n+                inlinable_def_ref.update(self._resolve_definition(ref, definitions))  # pyright: ignore\n+            else:\n+                # `ref` was encountered, at least two times:\n+                # - Do not inline the `'definition-ref'` schemas (they are not provided in the gather result anyway).\n+                # - Store the the definition in the `remaining_defs`\n+                remaining_defs[ref] = self._resolve_definition(ref, definitions)\n+\n+        for cs in gather_result['deferred_discriminator_schemas']:\n+            discriminator = cs['metadata']['pydantic_internal_union_discriminator']  # pyright: ignore[reportTypedDictNotRequiredAccess]\n+            applied = _discriminated_union.apply_discriminator(cs.copy(), discriminator, remaining_defs)\n+            # Mutate the schema directly to have the discriminator applied\n+            cs.clear()  # pyright: ignore[reportAttributeAccessIssue]\n+            cs.update(applied)  # pyright: ignore\n+\n+        if remaining_defs:\n+            schema = core_schema.definitions_schema(schema=schema, definitions=[*remaining_defs.values()])\n         return schema",
      "comment": "We also don't have anything preventing this, so it could happen. In practice, we don't manually create any `'definitions'` schema when handling type, and we make sure to call `unpack_definitions()` whenever we fetch a schema from a GPCS method/a cached attribute. But yes, this is error prone.",
      "comment_id": 1931919510,
      "user": "Viicos",
      "created_at": "2025-01-28T10:32:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931919510"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2520,
      "side": "RIGHT",
      "diff_hunk": "@@ -2508,6 +2506,23 @@ def _common_field(\n     }\n \n \n+def resolve_original_schema(schema: CoreSchema, definitions: _Definitions) -> CoreSchema | None:\n+    if schema['type'] == 'definition-ref':\n+        return definitions.get_schema_from_ref(schema['schema_ref'])\n+    elif schema['type'] == 'definitions':\n+        return schema['schema']\n+    else:\n+        return schema\n+\n+\n+def _can_be_inlined(def_ref: core_schema.DefinitionReferenceSchema) -> bool:",
      "comment": "```python\r\nfrom typing import Annotated\r\n\r\nfrom pydantic import BaseModel, WithJsonSchema\r\n\r\ntype Test = int\r\n\r\nclass Model(BaseModel):\r\n    f: Annotated[Test, WithJsonSchema({})]\r\n\r\nModel.__pydantic_core_schema__\r\n\r\n{\r\n\u2502   'type': 'definitions',\r\n\u2502   'schema': {\r\n\u2502   \u2502   'type': 'model',\r\n\u2502   \u2502   'cls': <class '__main__.Model'>,\r\n\u2502   \u2502   'schema': {\r\n\u2502   \u2502   \u2502   'type': 'model-fields',\r\n\u2502   \u2502   \u2502   'fields': {\r\n\u2502   \u2502   \u2502   \u2502   't1': {'type': 'model-field', 'schema': {'type': 'int'}, 'metadata': {}},\r\n\u2502   \u2502   \u2502   \u2502   't2': {\r\n\u2502   \u2502   \u2502   \u2502   \u2502   'type': 'model-field',\r\n\u2502   \u2502   \u2502   \u2502   \u2502   'schema': {'type': 'definition-ref', 'schema_ref': '__main__.Test:124259184101792', 'metadata': {'<stripped>'}},\r\n\u2502   \u2502   \u2502   \u2502   \u2502   'metadata': {}\r\n\u2502   \u2502   \u2502   \u2502   }\r\n\u2502   \u2502   \u2502   },\r\n\u2502   \u2502   \u2502   'model_name': 'Model',\r\n\u2502   \u2502   \u2502   'computed_fields': []\r\n\u2502   \u2502   },\r\n\u2502   \u2502   'config': {'title': 'Model'},\r\n\u2502   \u2502   'ref': '__main__.Model:107106664271472',\r\n\u2502   \u2502   'metadata': {'<stripped>'}\r\n\u2502   },\r\n\u2502   'definitions': [{'type': 'int', 'ref': '__main__.Test:124259184101792'}]\r\n}\r\n```\r\n\r\nIf you inline the definition ref, you loose the JSON Schema metadata. It could still be inlined and the metadata moved to the referenced schema, but you'll need to make a copy of it and merge metadata somehow.",
      "comment_id": 1931938259,
      "user": "Viicos",
      "created_at": "2025-01-28T10:45:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1931938259"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2550,
      "side": "RIGHT",
      "diff_hunk": "@@ -2529,9 +2544,15 @@ class _Definitions:\n     manager.\n     \"\"\"\n \n+    # TODO: more reasoning should be added as to why this is necessary (or at least used, as\n+    # *not* making the distinction with other collected definitions does not break anything).\n+    _unpacked_definitions: dict[str, core_schema.CoreSchema]\n+    \"\"\"Definitions coming from an external source (e.g. cached model schemas or from the `__get_pydantic_core_schema__` method).\"\"\"",
      "comment": "I went and removed it. I can't think of cases where it is necessary. By _not_ making the distinction, we avoid rebuilding a schema that is already present in an unpacked definition, e.g. in:\r\n\r\n```python\r\ntype Test = int\r\n\r\nclass M1(BaseModel):\r\n    t1: Test\r\n    t2: Test\r\n\r\nclass Model(BaseModel):\r\n    m1: M1\r\n    t: Test  # With the distinction, this is in the unpacked definitions and so will be built again\r\n```\r\n\r\nWe can easily add it back anyway.",
      "comment_id": 1932112279,
      "user": "Viicos",
      "created_at": "2025-01-28T12:52:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1932112279"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2645,
      "side": "RIGHT",
      "diff_hunk": "@@ -2580,34 +2601,73 @@ def create_definition_reference_schema(self, schema: CoreSchema) -> core_schema.\n         return core_schema.definition_reference_schema(ref)\n \n     def unpack_definitions(self, schema: core_schema.DefinitionsSchema) -> CoreSchema:\n-        \"\"\"Store the definitions of the `'definitions` core schema and return the inner core schema.\"\"\"\n+        \"\"\"Store the definitions of the `'definitions'` core schema and return the inner core schema.\"\"\"\n         for def_schema in schema['definitions']:\n-            self._definitions[def_schema['ref']] = def_schema  # pyright: ignore\n+            self._unpacked_definitions[def_schema['ref']] = def_schema  # pyright: ignore\n         return schema['schema']\n \n-    def as_definitions_schema(self, schema: CoreSchema) -> CoreSchema:\n-        \"\"\"Create a `'definitions'` schema containing all the collected definitions.\n+    def finalize_schema(self, schema: CoreSchema) -> CoreSchema:\n+        \"\"\"Finalize the core schema.\n \n-        If the passed schema contains a reference, it is also stored in the definitions list,\n-        and substituted by a `'definition-reference'` schema.\n+        This traverses the core schema and referenced definitions, replaces `'definition-ref'` schemas\n+        by the referenced definition if possible, and applies deferred discriminators.\n         \"\"\"\n-        if 'ref' in schema:\n-            schema = self.create_definition_reference_schema(schema)\n-\n-        return core_schema.definitions_schema(\n-            schema,\n-            list(self._definitions.values()),\n-        )\n-\n-\n-def resolve_original_schema(schema: CoreSchema, definitions: _Definitions) -> CoreSchema | None:\n-    if schema['type'] == 'definition-ref':\n-        return definitions.get_schema_from_ref(schema['schema_ref'])\n-    elif schema['type'] == 'definitions':\n-        return schema['schema']\n-    else:\n+        definitions = self._definitions\n+        if self._unpacked_definitions:\n+            definitions = {**self._unpacked_definitions, **definitions}\n+        try:\n+            gather_result = gather_schemas_for_cleaning(\n+                schema,\n+                definitions=definitions,\n+            )\n+        except MissingDefinitionError as e:\n+            raise InvalidSchemaError from e\n+\n+        remaining_defs: dict[str, CoreSchema] = {}\n+\n+        for ref, inlinable_def_ref in gather_result['collected_references'].items():\n+            if inlinable_def_ref is not None and _can_be_inlined(inlinable_def_ref):\n+                # `ref` was encountered, and only once:\n+                #  - `inlinable_def_ref` is a `'definition-ref'` schema and is guaranteed to be\n+                #    the only one. Transform it into the definition it points to.\n+                #  - Do not store the definition in the `remaining_defs`.\n+                inlinable_def_ref.clear()  # pyright: ignore[reportAttributeAccessIssue]\n+                inlinable_def_ref.update(self._resolve_definition(ref, definitions))  # pyright: ignore\n+            else:\n+                # `ref` was encountered, at least two times:\n+                # - Do not inline the `'definition-ref'` schemas (they are not provided in the gather result anyway).\n+                # - Store the the definition in the `remaining_defs`\n+                remaining_defs[ref] = self._resolve_definition(ref, definitions)\n+\n+        for cs in gather_result['deferred_discriminator_schemas']:\n+            discriminator = cs['metadata']['pydantic_internal_union_discriminator']  # pyright: ignore[reportTypedDictNotRequiredAccess]\n+            applied = _discriminated_union.apply_discriminator(cs.copy(), discriminator, remaining_defs)\n+            # Mutate the schema directly to have the discriminator applied\n+            cs.clear()  # pyright: ignore[reportAttributeAccessIssue]\n+            cs.update(applied)  # pyright: ignore\n+\n+        if remaining_defs:\n+            schema = core_schema.definitions_schema(schema=schema, definitions=[*remaining_defs.values()])\n         return schema",
      "comment": "I mean, it's not more error prone than the last implementation.\r\n\r\nI think we have a lot of holes for cases where GPCS is implemented in user code, but this seems ok to me here. Thanks for clarifying!",
      "comment_id": 1932558905,
      "user": "sydney-runkle",
      "created_at": "2025-01-28T17:11:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1932558905"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_schema_gather.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,201 @@\n+# pyright: reportTypedDictNotRequiredAccess=false, reportGeneralTypeIssues=false, reportArgumentType=false, reportAttributeAccessIssue=false\n+from __future__ import annotations\n+\n+from dataclasses import dataclass, field\n+from typing import TypedDict\n+\n+from pydantic_core.core_schema import ComputedField, CoreSchema, DefinitionReferenceSchema, SerSchema\n+from typing_extensions import TypeAlias\n+\n+AllSchemas: TypeAlias = 'CoreSchema | SerSchema | ComputedField'\n+\n+\n+class GatherResult(TypedDict):\n+    \"\"\"Schema traversing result.\"\"\"\n+\n+    collected_references: dict[str, DefinitionReferenceSchema | None]\n+    \"\"\"The collected definition references.\n+\n+    If a definition reference schema can be inlined, it means that there is\n+    only one in the whole core schema. As such, it is stored as the value.\n+    Otherwise, the value is set to `None`.\n+    \"\"\"\n+\n+    deferred_discriminator_schemas: list[CoreSchema]\n+    \"\"\"The list of core schemas having the discriminator application deferred.\"\"\"\n+\n+\n+class MissingDefinitionError(LookupError):\n+    \"\"\"A reference was pointing to a non-existing core schema.\"\"\"\n+\n+    def __init__(self, schema_reference: str, /) -> None:\n+        self.schema_reference = schema_reference\n+\n+\n+@dataclass\n+class GatherContext:\n+    \"\"\"The current context used during core schema traversing.\n+\n+    Context instances should only be used during schema traversing.\n+    \"\"\"\n+\n+    definitions: dict[str, CoreSchema]\n+    \"\"\"The available definitions.\"\"\"\n+\n+    deferred_discriminator_schemas: list[CoreSchema] = field(init=False, default_factory=list)\n+    \"\"\"The list of core schemas having the discriminator application deferred.\n+\n+    Internally, these core schemas have a specific key set in the core metadata dict.\n+    \"\"\"\n+\n+    collected_references: dict[str, DefinitionReferenceSchema | None] = field(init=False, default_factory=dict)\n+    \"\"\"The collected definition references.\n+\n+    If a definition reference schema can be inlined, it means that there is\n+    only one in the whole core schema. As such, it is stored as the value.\n+    Otherwise, the value is set to `None`.\n+\n+    During schema traversing, definition reference schemas can be added as candidates, or removed\n+    (by setting the value to `None`).\n+    \"\"\"\n+\n+\n+def traverse_metadata(schema: AllSchemas, ctx: GatherContext) -> None:\n+    meta = schema.get('metadata')",
      "comment": "Shall we do a cast here for type checking purposes? To `CoreMetadata`?",
      "comment_id": 1932564380,
      "user": "sydney-runkle",
      "created_at": "2025-01-28T17:15:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1932564380"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11244,
      "file_path": "pydantic/_internal/_schema_gather.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,201 @@\n+# pyright: reportTypedDictNotRequiredAccess=false, reportGeneralTypeIssues=false, reportArgumentType=false, reportAttributeAccessIssue=false\n+from __future__ import annotations\n+\n+from dataclasses import dataclass, field\n+from typing import TypedDict\n+\n+from pydantic_core.core_schema import ComputedField, CoreSchema, DefinitionReferenceSchema, SerSchema\n+from typing_extensions import TypeAlias\n+\n+AllSchemas: TypeAlias = 'CoreSchema | SerSchema | ComputedField'\n+\n+\n+class GatherResult(TypedDict):\n+    \"\"\"Schema traversing result.\"\"\"\n+\n+    collected_references: dict[str, DefinitionReferenceSchema | None]\n+    \"\"\"The collected definition references.\n+\n+    If a definition reference schema can be inlined, it means that there is\n+    only one in the whole core schema. As such, it is stored as the value.\n+    Otherwise, the value is set to `None`.\n+    \"\"\"\n+\n+    deferred_discriminator_schemas: list[CoreSchema]\n+    \"\"\"The list of core schemas having the discriminator application deferred.\"\"\"\n+\n+\n+class MissingDefinitionError(LookupError):\n+    \"\"\"A reference was pointing to a non-existing core schema.\"\"\"\n+\n+    def __init__(self, schema_reference: str, /) -> None:\n+        self.schema_reference = schema_reference\n+\n+\n+@dataclass\n+class GatherContext:\n+    \"\"\"The current context used during core schema traversing.\n+\n+    Context instances should only be used during schema traversing.\n+    \"\"\"\n+\n+    definitions: dict[str, CoreSchema]\n+    \"\"\"The available definitions.\"\"\"\n+\n+    deferred_discriminator_schemas: list[CoreSchema] = field(init=False, default_factory=list)\n+    \"\"\"The list of core schemas having the discriminator application deferred.\n+\n+    Internally, these core schemas have a specific key set in the core metadata dict.\n+    \"\"\"\n+\n+    collected_references: dict[str, DefinitionReferenceSchema | None] = field(init=False, default_factory=dict)\n+    \"\"\"The collected definition references.\n+\n+    If a definition reference schema can be inlined, it means that there is\n+    only one in the whole core schema. As such, it is stored as the value.\n+    Otherwise, the value is set to `None`.\n+\n+    During schema traversing, definition reference schemas can be added as candidates, or removed\n+    (by setting the value to `None`).\n+    \"\"\"\n+\n+\n+def traverse_metadata(schema: AllSchemas, ctx: GatherContext) -> None:\n+    meta = schema.get('metadata')",
      "comment": "This is a function that is called a lot, so I tried to avoid adding extra function calls (even though `cast` is just an identity function). In this case, having type checking on it does not provide any benefits anyway",
      "comment_id": 1932574966,
      "user": "Viicos",
      "created_at": "2025-01-28T17:21:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/11244#discussion_r1932574966"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11332,
      "file_path": "tests/test_generics.py",
      "line": 312,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,6 +306,28 @@ class Model(BaseModel, Generic[T, S]):\n     )\n \n \n+def test_arguments_count_validation() -> None:\n+    T = TypeVar('T')\n+    S = TypeVar('S')\n+    U = TypingExtensionsTypeVar('U', default=int)",
      "comment": "```suggestion\r\n    S = TypeVar('S')\r\n    T = TypeVar('T')\r\n    U = TypingExtensionsTypeVar('U', default=int)\r\n```",
      "comment_id": 1927980009,
      "user": "sydney-runkle",
      "created_at": "2025-01-24T01:56:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/11332#discussion_r1927980009"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11332,
      "file_path": "pydantic/_internal/_generics.py",
      "line": 414,
      "side": "RIGHT",
      "diff_hunk": "@@ -382,21 +383,55 @@ def has_instance_in_type(type_: Any, isinstance_target: Any) -> bool:\n     return False\n \n \n-def check_parameters_count(cls: type[BaseModel], parameters: tuple[Any, ...]) -> None:\n-    \"\"\"Check the generic model parameters count is equal.\n+def map_generic_model_arguments(cls: type[BaseModel], args: tuple[Any, ...]) -> dict[TypeVar, Any]:\n+    \"\"\"Return a mapping between the arguments of a generic model and the provided arguments during parametrization.\n \n-    Args:\n-        cls: The generic model.\n-        parameters: A tuple of passed parameters to the generic model.\n+    If the number of arguments does not match the parameters (e.g. if providing too few or too many arguments),\n+    a `TypeError` is raised.\n \n-    Raises:\n-        TypeError: If the passed parameters count is not equal to generic model parameters count.\n+    Example:\n+        ```python {test=\"skip\" lint=\"skip\"}\n+        class Model[T, U, V = int](BaseModel): ...\n+\n+        map_generic_model_arguments(Model, (str, bytes))\n+        #> {T: str, U: bytes, V: int}\n+\n+        map_generic_model_arguments(Model, (str,))\n+        #> TypeError: Too few arguments for <class '__main__.Model'>; actual 1, expected at least 2\n+\n+        map_generic_model_argumenst(Model, (str, bytes, int, complex))\n+        #> TypeError: Too many arguments for <class '__main__.Model'>; actual 4, expected 3\n+        ```\n+\n+    Note:\n+        This function is analogous to the private `typing._check_generic_specialization` function.\n     \"\"\"\n-    actual = len(parameters)\n-    expected = len(cls.__pydantic_generic_metadata__['parameters'])\n-    if actual != expected:\n-        description = 'many' if actual > expected else 'few'\n-        raise TypeError(f'Too {description} parameters for {cls}; actual {actual}, expected {expected}')\n+    parameters = cls.__pydantic_generic_metadata__['parameters']\n+    expected_len = len(parameters)\n+    typevars_map: dict[TypeVar, Any] = {}\n+\n+    _missing = object()\n+    for parameter, argument in zip_longest(parameters, args, fillvalue=_missing):",
      "comment": "Cool, didn't know about this function (`zip_longest`)",
      "comment_id": 1927981850,
      "user": "sydney-runkle",
      "created_at": "2025-01-24T02:00:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/11332#discussion_r1927981850"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11332,
      "file_path": "pydantic/main.py",
      "line": 772,
      "side": "RIGHT",
      "diff_hunk": "@@ -766,12 +766,10 @@ def __class_getitem__(\n \n         if not isinstance(typevar_values, tuple):\n             typevar_values = (typevar_values,)\n-        _generics.check_parameters_count(cls, typevar_values)\n \n-        # Build map from generic typevars to passed params\n-        typevars_map: dict[TypeVar, type[Any]] = dict(\n-            zip(cls.__pydantic_generic_metadata__['parameters'], typevar_values)\n-        )\n+        typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n+        # In case type variables have defaults and a type wasn't provided, use the defaults:\n+        typevar_values = tuple(v for v in typevars_map.values())",
      "comment": "Before I looked at the internals of `map_generic_model_arguments`, it wasn't evident to me why this made sense.\r\n\r\nI'm ok with this approach, but just wanted to note that this was a little bit confusing at first. I'll think overnight on how we might be able to make this more intuitive on a first scan.",
      "comment_id": 1927983496,
      "user": "sydney-runkle",
      "created_at": "2025-01-24T02:03:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/11332#discussion_r1927983496"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11332,
      "file_path": "pydantic/main.py",
      "line": 772,
      "side": "RIGHT",
      "diff_hunk": "@@ -766,12 +766,10 @@ def __class_getitem__(\n \n         if not isinstance(typevar_values, tuple):\n             typevar_values = (typevar_values,)\n-        _generics.check_parameters_count(cls, typevar_values)\n \n-        # Build map from generic typevars to passed params\n-        typevars_map: dict[TypeVar, type[Any]] = dict(\n-            zip(cls.__pydantic_generic_metadata__['parameters'], typevar_values)\n-        )\n+        typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n+        # In case type variables have defaults and a type wasn't provided, use the defaults:\n+        typevar_values = tuple(v for v in typevars_map.values())",
      "comment": "Yes it's a bit implicit, I'm going to add a comment giving an example",
      "comment_id": 1928438772,
      "user": "Viicos",
      "created_at": "2025-01-24T10:05:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/11332#discussion_r1928438772"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11350,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,7 +220,10 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n             if constraint == 'union_mode' and schema_type == 'union':\n                 schema['mode'] = value  # type: ignore  # schema is UnionSchema\n             else:\n-                schema[constraint] = value\n+                if schema_type == 'decimal' and constraint in {'multiple_of', 'le', 'ge', 'lt', 'gt'}:\n+                    schema[constraint] = Decimal(value)\n+                else:\n+                    schema[constraint] = value",
      "comment": "Is it better to put this in `pydantic-core` rather than coupling this to what `pydantic-core` expects?",
      "comment_id": 1930724769,
      "user": "davidhewitt",
      "created_at": "2025-01-27T15:32:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/11350#discussion_r1930724769"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11350,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,7 +220,10 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n             if constraint == 'union_mode' and schema_type == 'union':\n                 schema['mode'] = value  # type: ignore  # schema is UnionSchema\n             else:\n-                schema[constraint] = value\n+                if schema_type == 'decimal' and constraint in {'multiple_of', 'le', 'ge', 'lt', 'gt'}:\n+                    schema[constraint] = Decimal(value)\n+                else:\n+                    schema[constraint] = value",
      "comment": "I thought about this, only concern is that as is, the core schema will not comply to the corresponding typed dict definition (e.g. with `f: Decimal = Field(gt=1)`, the core_schema is `{'type': 'decimal', 'gt': 1}`).\r\n\r\nUnless we change the constraints type on the typed dict to be `Decimal | float`, and then do the coercion during the validator build in `pydantic-core`?",
      "comment_id": 1930748853,
      "user": "Viicos",
      "created_at": "2025-01-27T15:47:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/11350#discussion_r1930748853"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11350,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,7 +220,10 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n             if constraint == 'union_mode' and schema_type == 'union':\n                 schema['mode'] = value  # type: ignore  # schema is UnionSchema\n             else:\n-                schema[constraint] = value\n+                if schema_type == 'decimal' and constraint in {'multiple_of', 'le', 'ge', 'lt', 'gt'}:\n+                    schema[constraint] = Decimal(value)\n+                else:\n+                    schema[constraint] = value",
      "comment": "It seems ok to me to make the core schema definition more lax in this way? \ud83e\udd14 ",
      "comment_id": 1930752074,
      "user": "davidhewitt",
      "created_at": "2025-01-27T15:49:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/11350#discussion_r1930752074"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11350,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,7 +220,10 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n             if constraint == 'union_mode' and schema_type == 'union':\n                 schema['mode'] = value  # type: ignore  # schema is UnionSchema\n             else:\n-                schema[constraint] = value\n+                if schema_type == 'decimal' and constraint in {'multiple_of', 'le', 'ge', 'lt', 'gt'}:\n+                    schema[constraint] = Decimal(value)\n+                else:\n+                    schema[constraint] = value",
      "comment": "Hum but then how easy will it be to do so e.g. for date constraints? As ideally we'd want to do Pydantic coercion on it. Is it possible to perform such validation/coercion during `pydantic-core` schema build?\r\n\r\nI know the current change looks ugly, but this is inherent to the current implementation of the known metadata application that has several flaws.",
      "comment_id": 1930829576,
      "user": "Viicos",
      "created_at": "2025-01-27T16:34:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/11350#discussion_r1930829576"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11350,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,7 +220,10 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n             if constraint == 'union_mode' and schema_type == 'union':\n                 schema['mode'] = value  # type: ignore  # schema is UnionSchema\n             else:\n-                schema[constraint] = value\n+                if schema_type == 'decimal' and constraint in {'multiple_of', 'le', 'ge', 'lt', 'gt'}:\n+                    schema[constraint] = Decimal(value)\n+                else:\n+                    schema[constraint] = value",
      "comment": "How about proceeding as is, can you open an issue in core for these cases and I'll propose it there another time?",
      "comment_id": 1931041558,
      "user": "davidhewitt",
      "created_at": "2025-01-27T18:56:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/11350#discussion_r1931041558"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11350,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,7 +220,10 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n             if constraint == 'union_mode' and schema_type == 'union':\n                 schema['mode'] = value  # type: ignore  # schema is UnionSchema\n             else:\n-                schema[constraint] = value\n+                if schema_type == 'decimal' and constraint in {'multiple_of', 'le', 'ge', 'lt', 'gt'}:\n+                    schema[constraint] = Decimal(value)\n+                else:\n+                    schema[constraint] = value",
      "comment": "https://github.com/pydantic/pydantic-core/issues/1608",
      "comment_id": 1931882831,
      "user": "Viicos",
      "created_at": "2025-01-28T10:07:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/11350#discussion_r1931882831"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11324,
      "file_path": "pydantic/version.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,6 +65,11 @@ def version_info() -> str:\n     return '\\n'.join('{:>30} {}'.format(k + ':', str(v).replace('\\n', ' ')) for k, v in info.items())\n \n \n+def check_pydantic_core_version() -> bool:\n+    \"\"\"Check that the installed `pydantic-core` dependency is compatible.\"\"\"\n+    return version('pydantic_core') == '2.27.2'",
      "comment": "Does pydantic_core offer a `__version__` attribute? If so we should use that.",
      "comment_id": 1928225249,
      "user": "samuelcolvin",
      "created_at": "2025-01-24T07:30:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/11324#discussion_r1928225249"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11324,
      "file_path": "pydantic/version.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,6 +65,12 @@ def version_info() -> str:\n     return '\\n'.join('{:>30} {}'.format(k + ':', str(v).replace('\\n', ' ')) for k, v in info.items())\n \n \n+def check_pydantic_core_version() -> bool:\n+    \"\"\"Check that the installed `pydantic-core` dependency is compatible.\"\"\"\n+    # Keep this in sync with the version constraint in the `pyproject.toml` dependencies:",
      "comment": "Probably overkill imo, considering the added test fails if this function was not updated after a `pydantic-core` version bump",
      "comment_id": 1928816638,
      "user": "Viicos",
      "created_at": "2025-01-24T14:54:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/11324#discussion_r1928816638"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11319,
      "file_path": "pydantic/networks.py",
      "line": 889,
      "side": "RIGHT",
      "diff_hunk": "@@ -886,7 +886,7 @@ class ClickHouseDsn(AnyUrl):\n     \"\"\"\n \n     _constraints = UrlConstraints(\n-        allowed_schemes=['clickhouse+native', 'clickhouse+asynch'],\n+        allowed_schemes=['clickhouse+native', 'clickhouse+asynch', 'clickhouse', 'clickhouses', 'clickhousedb'],",
      "comment": "```suggestion\r\n        allowed_schemes=['clickhouse+native', 'clickhouse+asynch', 'clickhouse+http', 'clickhouse', 'clickhouses', 'clickhousedb'],\r\n```",
      "comment_id": 1928494196,
      "user": "Viicos",
      "created_at": "2025-01-24T10:48:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/11319#discussion_r1928494196"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11319,
      "file_path": "tests/test_networks.py",
      "line": 535,
      "side": "RIGHT",
      "diff_hunk": "@@ -530,6 +530,9 @@ class Model(BaseModel):\n     [\n         'clickhouse+native://user:pass@localhost:9000/app',\n         'clickhouse+asynch://user:pass@localhost:9000/app',\n+        'clickhouse://user:pass@localhost:9000/app',\n+        'clickhouses://user:pass@localhost:9000/app',\n+        'clickhousedb://user:pass@localhost:9000/app',",
      "comment": "```suggestion\r\n        'clickhouse+native://user:pass@localhost:9000/app',\r\n        'clickhouse+asynch://user:pass@localhost:9000/app',\r\n        'clickhouse+http://user:pass@localhost:9000/app',\r\n        'clickhouse://user:pass@localhost:9000/app',\r\n        'clickhouses://user:pass@localhost:9000/app',\r\n        'clickhousedb://user:pass@localhost:9000/app',\r\n```",
      "comment_id": 1928495029,
      "user": "Viicos",
      "created_at": "2025-01-24T10:49:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/11319#discussion_r1928495029"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11319,
      "file_path": "pydantic/networks.py",
      "line": 889,
      "side": "RIGHT",
      "diff_hunk": "@@ -886,7 +886,7 @@ class ClickHouseDsn(AnyUrl):\n     \"\"\"\n \n     _constraints = UrlConstraints(\n-        allowed_schemes=['clickhouse+native', 'clickhouse+asynch'],\n+        allowed_schemes=['clickhouse+native', 'clickhouse+asynch', 'clickhouse+http', 'clickhouse', 'clickhouses', 'clickhousedb'],",
      "comment": "```suggestion\r\n        allowed_schemes=[\r\n            'clickhouse+native',\r\n            'clickhouse+asynch',\r\n            'clickhouse+http',\r\n            'clickhouse',\r\n            'clickhouses',\r\n            'clickhousedb',\r\n        ],\r\n```",
      "comment_id": 1928498009,
      "user": "Viicos",
      "created_at": "2025-01-24T10:51:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/11319#discussion_r1928498009"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11305,
      "file_path": "tests/test_json_schema.py",
      "line": 6612,
      "side": "LEFT",
      "diff_hunk": "@@ -6609,7 +6609,26 @@ class Test(BaseModel):\n         'type': 'object',\n     }\n \n-    # raises KeyError: '#/components/schemas/Pet'",
      "comment": "The previous test, it was taken from a MRE of a user but isn't really relevant (because the key error doesn't happen anymore)",
      "comment_id": 1923999806,
      "user": "Viicos",
      "created_at": "2025-01-21T16:07:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/11305#discussion_r1923999806"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11298,
      "file_path": "tests/mypy/outputs/1.10.1/mypy-plugin_ini/decorator_implicit_classmethod.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+\"\"\"Test that the mypy plugin implicitly transforms the right decorators into class methods.\"\"\"\n+\n+from pydantic import BaseModel, field_validator, model_serializer, model_validator\n+\n+\n+class Model(BaseModel):\n+    a: int\n+\n+    @field_validator('a')\n+    def f_val(cls, value: int) -> int:\n+        reveal_type(cls)\n+# MYPY: note: Revealed type is \"type[tests.mypy.modules.decorator_implicit_classmethod.Model]\"\n+        return value\n+\n+    @model_validator(mode='before')\n+    def m_val_before(self, values: dict[str, object]) -> dict[str, object]:\n+        reveal_type(self)\n+# MYPY: note: Revealed type is \"type[tests.mypy.modules.decorator_implicit_classmethod.Model]\"\n+        return values",
      "comment": "Surprising that it would be different from an `after` model validator...",
      "comment_id": 1923992045,
      "user": "sydney-runkle",
      "created_at": "2025-01-21T16:02:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/11298#discussion_r1923992045"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11298,
      "file_path": "tests/mypy/outputs/1.10.1/mypy-plugin_ini/decorator_implicit_classmethod.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+\"\"\"Test that the mypy plugin implicitly transforms the right decorators into class methods.\"\"\"\n+\n+from pydantic import BaseModel, field_validator, model_serializer, model_validator\n+\n+\n+class Model(BaseModel):\n+    a: int\n+\n+    @field_validator('a')\n+    def f_val(cls, value: int) -> int:\n+        reveal_type(cls)\n+# MYPY: note: Revealed type is \"type[tests.mypy.modules.decorator_implicit_classmethod.Model]\"\n+        return value\n+\n+    @model_validator(mode='before')\n+    def m_val_before(self, values: dict[str, object]) -> dict[str, object]:\n+        reveal_type(self)\n+# MYPY: note: Revealed type is \"type[tests.mypy.modules.decorator_implicit_classmethod.Model]\"\n+        return values",
      "comment": "Yes it's confusing I should rename `self` to `cls`, but otherwise this is correct: only _after_ model validators are instance methods",
      "comment_id": 1924002948,
      "user": "Viicos",
      "created_at": "2025-01-21T16:09:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/11298#discussion_r1924002948"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11271,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 603,
      "side": "RIGHT",
      "diff_hunk": "@@ -600,6 +600,6 @@ def pretty_print_core_schema(\n \n \n def validate_core_schema(schema: CoreSchema) -> CoreSchema:\n-    if 'PYDANTIC_SKIP_VALIDATING_CORE_SCHEMAS' in os.environ:\n-        return schema\n-    return _validate_core_schema(schema)\n+    if os.environ.get('PYDANTIC_VALIDATE_CORE_SCHEMAS') == 1:",
      "comment": "```suggestion\r\n    if os.getenv('PYDANTIC_VALIDATE_CORE_SCHEMAS'):\r\n```\r\n\r\nnit: this follows the same logic for `PYDANTIC_PRIVATE_ALLOW_UNHANDLED_SCHEMA_TYPES` and how CPython handles environment variables (it just checks for the present of the environment variable)",
      "comment_id": 1924171768,
      "user": "Viicos",
      "created_at": "2025-01-21T18:07:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/11271#discussion_r1924171768"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11271,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 603,
      "side": "RIGHT",
      "diff_hunk": "@@ -600,6 +600,6 @@ def pretty_print_core_schema(\n \n \n def validate_core_schema(schema: CoreSchema) -> CoreSchema:\n-    if 'PYDANTIC_SKIP_VALIDATING_CORE_SCHEMAS' in os.environ:\n-        return schema\n-    return _validate_core_schema(schema)\n+    if os.environ.get('PYDANTIC_VALIDATE_CORE_SCHEMAS') == 1:",
      "comment": "Sounds good, cc @davidhewitt, you mentioned this check recently as well",
      "comment_id": 1924230372,
      "user": "sydney-runkle",
      "created_at": "2025-01-21T18:59:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/11271#discussion_r1924230372"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11295,
      "file_path": "pydantic/mypy.py",
      "line": 1053,
      "side": "RIGHT",
      "diff_hunk": "@@ -1040,15 +1040,17 @@ def get_alias_info(stmt: AssignmentStmt) -> tuple[str | None, bool]:\n             # Assigned value is not a call to pydantic.fields.Field\n             return None, False\n \n-        for i, arg_name in enumerate(expr.arg_names):\n-            if arg_name != 'alias':\n-                continue\n-            arg = expr.args[i]\n-            if isinstance(arg, StrExpr):\n-                return arg.value, False\n-            else:\n-                return None, True\n-        return None, False\n+        if 'validation_alias' in expr.arg_names:\n+            arg = expr.args[expr.arg_names.index('validation_alias')]\n+        elif 'alias' in expr.arg_names:\n+            arg = expr.args[expr.arg_names.index('alias')]\n+        else:\n+            return None, False\n+\n+        if isinstance(arg, StrExpr):\n+            return arg.value, False\n+        else:\n+            return None, True",
      "comment": "Are the index calls here expensive? Could we refactor to be slightly more performance friendly?",
      "comment_id": 1923985919,
      "user": "sydney-runkle",
      "created_at": "2025-01-21T15:58:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/11295#discussion_r1923985919"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11295,
      "file_path": "tests/mypy/outputs/1.10.1/mypy-default_ini/plugin_success_baseConfig.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,11 +118,17 @@ class MultiInheritanceModel(BaseModel, Mixin):\n \n \n class AliasModel(BaseModel):\n-    x: str = Field(..., alias='y')\n+    x: str = Field(alias='x_alias')\n+    y: str = Field(validation_alias='y_alias')\n+    z: str = Field(validation_alias='z_alias', alias='unused')\n \n \n-alias_model = AliasModel(y='hello')\n-assert alias_model.x == 'hello'\n+alias_model = AliasModel(x_alias='a', y_alias='a', z_alias='a')\n+# MYPY: error: Unexpected keyword argument \"y_alias\" for \"AliasModel\"; did you mean \"x_alias\"?  [call-arg]\n+# MYPY: error: Unexpected keyword argument \"z_alias\" for \"AliasModel\"; did you mean \"x_alias\"?  [call-arg]\n+assert alias_model.x == 'a'\n+assert alias_model.y == 'a'\n+assert alias_model.z == 'a'",
      "comment": "This is the default config output, without the mypy plugin",
      "comment_id": 1923992167,
      "user": "Viicos",
      "created_at": "2025-01-21T16:02:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/11295#discussion_r1923992167"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11295,
      "file_path": "pydantic/mypy.py",
      "line": 1053,
      "side": "RIGHT",
      "diff_hunk": "@@ -1040,15 +1040,17 @@ def get_alias_info(stmt: AssignmentStmt) -> tuple[str | None, bool]:\n             # Assigned value is not a call to pydantic.fields.Field\n             return None, False\n \n-        for i, arg_name in enumerate(expr.arg_names):\n-            if arg_name != 'alias':\n-                continue\n-            arg = expr.args[i]\n-            if isinstance(arg, StrExpr):\n-                return arg.value, False\n-            else:\n-                return None, True\n-        return None, False\n+        if 'validation_alias' in expr.arg_names:\n+            arg = expr.args[expr.arg_names.index('validation_alias')]\n+        elif 'alias' in expr.arg_names:\n+            arg = expr.args[expr.arg_names.index('alias')]\n+        else:\n+            return None, False\n+\n+        if isinstance(arg, StrExpr):\n+            return arg.value, False\n+        else:\n+            return None, True",
      "comment": "You generally don't have much arguments specified in the `Field()` function, so in worst cases this is looking for the index in an array of 5-10 elements (and performance wise, this is most probably nothing compared to the rest of the mypy work).",
      "comment_id": 1923995724,
      "user": "Viicos",
      "created_at": "2025-01-21T16:04:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/11295#discussion_r1923995724"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/dataclasses.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,7 +176,7 @@ def make_pydantic_fields_compatible(cls: type[Any]) -> None:\n                     field_args['repr'] = field_value.repr\n \n                 setattr(cls, field_name, dataclasses.field(**field_args))\n-                # In Python 3.8, dataclasses checks cls.__dict__['__annotations__'] for annotations,\n+                # When subclassing, information is pulled from cls.__dict__['__annotations__'] for annotations,\n                 # so we must make sure it's initialized before we add to it.\n                 if cls.__dict__.get('__annotations__') is None:\n                     cls.__annotations__ = {}",
      "comment": "I believe this is still required, tests fail without it.",
      "comment_id": 1911276767,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T20:29:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1911276767"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/dataclasses.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,8 +157,6 @@ def make_pydantic_fields_compatible(cls: type[Any]) -> None:\n           `x: int = dataclasses.field(default=pydantic.Field(..., kw_only=True), kw_only=True)`\n         \"\"\"\n         for annotation_cls in cls.__mro__:\n-            # In Python < 3.9, `__annotations__` might not be present if there are no fields.\n-            # we therefore need to use `getattr` to avoid an `AttributeError`.\n             annotations = getattr(annotation_cls, '__annotations__', [])",
      "comment": "I believe this getattr is still required, tests fail without it.",
      "comment_id": 1911277846,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T20:29:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1911277846"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 475,
      "side": "RIGHT",
      "diff_hunk": "@@ -472,7 +472,6 @@ def type_var_default_factory() -> None:\n \n     # Assume Annotated[..., Field(...)]\n     if _typing_extra.is_annotated(values_source_type):\n-        # Important that we use typing_extensions.get_args here in order to support 3.8\n         field_info = next((v for v in typing_extensions.get_args(values_source_type) if isinstance(v, FieldInfo)), None)",
      "comment": "Still best practice to use this from `typing_extensions`, I believe, cc @Viicos",
      "comment_id": 1911278839,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T20:30:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1911278839"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "tests/test_internal.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,12 +194,20 @@ class Obj(Representation):\n \n     obj = Obj()\n \n-    assert str(devtools.debug.format(obj)).split('\\n')[1:] == [\n-        '    Obj(',\n-        '        int_attr=42,',\n-        \"        str_attr='Marvin',\",\n-        '    ) (Obj)',\n-    ]\n+    if sys.version_info < (3, 11):\n+        assert str(devtools.debug.format(obj)).split('\\n')[1:] == [\n+            '    Obj(',\n+            '        int_attr=42,',\n+            \"        str_attr='Marvin',\",\n+            '    ) (Obj)',\n+        ]\n+    else:\n+        assert str(devtools.debug.format(obj)).split('\\n')[1:] == [\n+            '    obj: Obj(',\n+            '        int_attr=42,',\n+            \"        str_attr='Marvin',\",\n+            '    ) (Obj)',\n+        ]",
      "comment": "This change is just related to a version bump in `uv.lock`. The only one of its kind in this PR.",
      "comment_id": 1911284121,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T20:32:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1911284121"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 93,
      "side": "LEFT",
      "diff_hunk": "@@ -89,10 +89,6 @@ def literal_values(tp: Any, /) -> list[Any]:\n     *doesn't* check that the type alias is referencing a `Literal` special form,\n     so unexpected values could be unpacked.\n     \"\"\"\n-    # TODO: SYDNEY - determine changes to make here\n-    # TODO When we drop support for Python 3.8, there's no need to check of `is_literal`\n-    # here, as Python unpacks nested `Literal` forms in 3.9+.\n-    # (see https://docs.python.org/3/whatsnew/3.9.html#id4).",
      "comment": "@Viicos, lmk if you prefer a different approach for this function",
      "comment_id": 1911343512,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T20:53:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1911343512"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "tests/test_generics.py",
      "line": 1469,
      "side": "RIGHT",
      "diff_hunk": "@@ -1466,9 +1466,6 @@ class InnerModel(OuterModelA[K, V], OuterModelB[T], Generic[K, V, T]):\n     }\n \n \n-# TODO: SYDNEY - determine changes to make here (next 4 tests with 3.9 notes)\n-\n-\n def test_generic_with_referenced_generic_type_1():",
      "comment": "@Viicos, I don't think I fully understand the changes you want made to these functions, perhaps you could help me out on this part? Thanks!",
      "comment_id": 1911344256,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T20:53:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1911344256"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 93,
      "side": "LEFT",
      "diff_hunk": "@@ -89,10 +89,6 @@ def literal_values(tp: Any, /) -> list[Any]:\n     *doesn't* check that the type alias is referencing a `Literal` special form,\n     so unexpected values could be unpacked.\n     \"\"\"\n-    # TODO: SYDNEY - determine changes to make here\n-    # TODO When we drop support for Python 3.8, there's no need to check of `is_literal`\n-    # here, as Python unpacks nested `Literal` forms in 3.9+.\n-    # (see https://docs.python.org/3/whatsnew/3.9.html#id4).",
      "comment": "Discussed offline, we're going to leave as is for now.",
      "comment_id": 1911370418,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T21:04:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1911370418"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "tests/benchmarks/test_model_schema_generation_recursive.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,7 +52,7 @@ class GenericNode(DeferredModel, Generic[T]):\n \n     class GenericTree(DeferredModel, Generic[T]):\n         root: GenericNode[T]\n-        metadata: Dict[str, 'GenericTree[T]'] = Field(default_factory=dict)\n+        metadata: dict[str, 'GenericTree[T]'] = Field(default_factory=dict)",
      "comment": "This is currently broken on 3.9 and 3.10, not sure why...",
      "comment_id": 1913120350,
      "user": "sydney-runkle",
      "created_at": "2025-01-13T12:31:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1913120350"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "tests/test_generics.py",
      "line": 2237,
      "side": "RIGHT",
      "diff_hunk": "@@ -2240,7 +2232,7 @@ def test_generic_model_as_parameter_to_generic_type_alias() -> None:\n     class GenericPydanticModel(BaseModel, Generic[T]):\n         x: T\n \n-    GenericPydanticModelList = List[GenericPydanticModel[T]]\n+    GenericPydanticModelList = list[GenericPydanticModel[T]]",
      "comment": "This test is broken in 3.9 with:\r\n\r\n```\r\n[XPASS(strict)] Generic models are not type aliases\r\n```",
      "comment_id": 1913124990,
      "user": "sydney-runkle",
      "created_at": "2025-01-13T12:35:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1913124990"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "tests/test_edge_cases.py",
      "line": 1495,
      "side": "RIGHT",
      "diff_hunk": "@@ -1472,12 +1474,12 @@ class Model(BaseModel):\n \n \n def test_type_on_generic_alias() -> None:\n-    error_msg = 'Instead of using type[typing.List[int]], use type[list].'\n+    error_msg = 'Instead of using type[list[int]], use type[list].'\n \n     with pytest.raises(PydanticUserError) as exc_info:\n \n         class Model(BaseModel):\n-            a: Type[List[int]]\n+            a: Type[list[int]]\n \n     assert error_msg in exc_info.value.message",
      "comment": "I believe this is fixed by https://github.com/pydantic/pydantic/pull/11258/commits/b6f20f6552997bb66980bbcd01bcd3786d2934c6",
      "comment_id": 1913184210,
      "user": "sydney-runkle",
      "created_at": "2025-01-13T13:21:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1913184210"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 582,
      "side": "RIGHT",
      "diff_hunk": "@@ -592,24 +571,20 @@ def origin_is_union(tp: Any, /) -> bool:\n         \"\"\"Return whether the provided argument is the `Union` special form.\"\"\"\n         return tp is _t_union or tp is _te_union\n \n-    def is_generic_alias(type_: type[Any]) -> bool:\n-        return isinstance(type_, typing._GenericAlias)  # pyright: ignore[reportAttributeAccessIssue]\n-\n else:\n \n     def origin_is_union(tp: Any, /) -> bool:\n         \"\"\"Return whether the provided argument is the `Union` special form or the `UnionType`.\"\"\"\n         return tp is _t_union or tp is _te_union or tp is types.UnionType\n \n-    def is_generic_alias(tp: Any, /) -> bool:\n-        return isinstance(tp, (types.GenericAlias, typing._GenericAlias))  # pyright: ignore[reportAttributeAccessIssue]\n+\n+def is_generic_alias(tp: Any, /) -> bool:\n+    return isinstance(tp, (types.GenericAlias, typing._GenericAlias))  # pyright: ignore[reportAttributeAccessIssue]",
      "comment": "Important change - this is relevant for 3.9, despite being included in a 3.10+ block before.",
      "comment_id": 1913202316,
      "user": "sydney-runkle",
      "created_at": "2025-01-13T13:35:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1913202316"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "tests/test_generics.py",
      "line": 2237,
      "side": "RIGHT",
      "diff_hunk": "@@ -2240,7 +2232,7 @@ def test_generic_model_as_parameter_to_generic_type_alias() -> None:\n     class GenericPydanticModel(BaseModel, Generic[T]):\n         x: T\n \n-    GenericPydanticModelList = List[GenericPydanticModel[T]]\n+    GenericPydanticModelList = list[GenericPydanticModel[T]]",
      "comment": "So this unexpectedly works in 3.9, but I can't explain why. `GenericPydanticModelList` is a `GenericAlias`...",
      "comment_id": 1913203254,
      "user": "sydney-runkle",
      "created_at": "2025-01-13T13:36:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1913203254"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "tests/test_generics.py",
      "line": 2237,
      "side": "RIGHT",
      "diff_hunk": "@@ -2240,7 +2232,7 @@ def test_generic_model_as_parameter_to_generic_type_alias() -> None:\n     class GenericPydanticModel(BaseModel, Generic[T]):\n         x: T\n \n-    GenericPydanticModelList = List[GenericPydanticModel[T]]\n+    GenericPydanticModelList = list[GenericPydanticModel[T]]",
      "comment": "Update - we've determined that this is expected to work with Python 3.9's `list` implementation, so I've added a skip for that case.",
      "comment_id": 1913361568,
      "user": "sydney-runkle",
      "created_at": "2025-01-13T15:18:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1913361568"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "tests/benchmarks/test_model_schema_generation_recursive.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,7 +52,7 @@ class GenericNode(DeferredModel, Generic[T]):\n \n     class GenericTree(DeferredModel, Generic[T]):\n         root: GenericNode[T]\n-        metadata: Dict[str, 'GenericTree[T]'] = Field(default_factory=dict)\n+        metadata: dict[str, 'GenericTree[T]'] = Field(default_factory=dict)",
      "comment": "Seems like a `typing._eval_type` bug in those Python versions, were string annotations inside `types.GenericAlias` instances are not properly evaluated:\r\n\r\n```python\r\nfrom typing import get_type_hints\r\n\r\nB = int\r\n\r\nclass A:\r\n    b: dict[str, 'B']\r\n\r\nget_type_hints(A)\r\n# {'b': dict[str, 'B']}\r\n```\r\n\r\nusing `metadata: 'dict[str, GenericTree[T]]'` instead works (and anyway it is usually recommended to stringify the whole annotation, and not parts of it).",
      "comment_id": 1913429138,
      "user": "Viicos",
      "created_at": "2025-01-13T16:00:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1913429138"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 911,
      "side": "RIGHT",
      "diff_hunk": "@@ -909,12 +908,11 @@ def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None:\n     def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n         args = get_args(obj)\n         if args:\n-            if sys.version_info >= (3, 9):\n-                from types import GenericAlias\n+            from types import GenericAlias",
      "comment": "Can we move the import at the beginning of the file?",
      "comment_id": 1914889803,
      "user": "Viicos",
      "created_at": "2025-01-14T14:12:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1914889803"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1674,
      "side": "RIGHT",
      "diff_hunk": "@@ -1673,11 +1671,6 @@ def _type_schema(self) -> core_schema.CoreSchema:\n \n     def _zoneinfo_schema(self) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a zone_info.ZoneInfo object\"\"\"\n-        # we're def >=py3.9 if ZoneInfo was included in input\n-        if sys.version_info < (3, 9):\n-            assert False, 'Unreachable'\n-\n-        # import in this path is safe\n         from zoneinfo import ZoneInfo, ZoneInfoNotFoundError",
      "comment": "Let's move the import at the beginning of the file",
      "comment_id": 1914913698,
      "user": "Viicos",
      "created_at": "2025-01-14T14:25:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1914913698"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1730,
      "side": "RIGHT",
      "diff_hunk": "@@ -1734,6 +1725,10 @@ def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n                     code=None,\n                 )\n             if not inspect.isclass(type_param):\n+                # when using type[None], this doesn't type convert to type[NoneType], and None isn't a class\n+                # so we handle it manually here\n+                if _typing_extra.is_none_type(type_param):",
      "comment": "```suggestion\r\n                if type_param is None:\r\n```",
      "comment_id": 1914915120,
      "user": "Viicos",
      "created_at": "2025-01-14T14:26:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1914915120"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/dataclasses.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,8 +157,6 @@ def make_pydantic_fields_compatible(cls: type[Any]) -> None:\n           `x: int = dataclasses.field(default=pydantic.Field(..., kw_only=True), kw_only=True)`\n         \"\"\"\n         for annotation_cls in cls.__mro__:\n-            # In Python < 3.9, `__annotations__` might not be present if there are no fields.\n-            # we therefore need to use `getattr` to avoid an `AttributeError`.\n             annotations = getattr(annotation_cls, '__annotations__', [])",
      "comment": "Can we change to:\r\n\r\n```python\r\nannotations: dict[str, Any] = getattr(annotation_cls, '__annotations__', {})\r\n```\r\n\r\nto have a consistent type for `annotations`?",
      "comment_id": 1914921781,
      "user": "Viicos",
      "created_at": "2025-01-14T14:30:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1914921781"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/dataclasses.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,7 +176,7 @@ def make_pydantic_fields_compatible(cls: type[Any]) -> None:\n                     field_args['repr'] = field_value.repr\n \n                 setattr(cls, field_name, dataclasses.field(**field_args))\n-                # In Python 3.8, dataclasses checks cls.__dict__['__annotations__'] for annotations,\n+                # When subclassing, information is pulled from cls.__dict__['__annotations__'] for annotations,\n                 # so we must make sure it's initialized before we add to it.\n                 if cls.__dict__.get('__annotations__') is None:\n                     cls.__annotations__ = {}",
      "comment": "Let's update the comment with _In Python 3.9_, the mentioned version was wrong actually.",
      "comment_id": 1914930329,
      "user": "Viicos",
      "created_at": "2025-01-14T14:35:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1914930329"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/dataclasses.py",
      "line": 287,
      "side": "RIGHT",
      "diff_hunk": "@@ -286,7 +284,7 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n \n __getattr__ = getattr_migration(__name__)\n \n-if (3, 8) <= sys.version_info < (3, 11):\n+if (3, 9) <= sys.version_info < (3, 11):",
      "comment": "```suggestion\r\nif sys.version_info < (3, 11):\r\n```",
      "comment_id": 1914932978,
      "user": "Viicos",
      "created_at": "2025-01-14T14:36:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1914932978"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "tests/test_typing.py",
      "line": 117,
      "side": "LEFT",
      "diff_hunk": "@@ -114,26 +114,6 @@ def f(x: int, y: None) -> int:\n     assert get_function_type_hints(f) == {'return': int, 'x': int, 'y': NoneType}\n \n \n-@pytest.mark.skipif(sys.version_info[:2] > (3, 9), reason='testing using a feature not supported by older Python')",
      "comment": "Also maybe cleaner to go with `sys.version_info >= (3, 10)`",
      "comment_id": 1914948852,
      "user": "Viicos",
      "created_at": "2025-01-14T14:44:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1914948852"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1674,
      "side": "RIGHT",
      "diff_hunk": "@@ -1673,11 +1671,6 @@ def _type_schema(self) -> core_schema.CoreSchema:\n \n     def _zoneinfo_schema(self) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a zone_info.ZoneInfo object\"\"\"\n-        # we're def >=py3.9 if ZoneInfo was included in input\n-        if sys.version_info < (3, 9):\n-            assert False, 'Unreachable'\n-\n-        # import in this path is safe\n         from zoneinfo import ZoneInfo, ZoneInfoNotFoundError",
      "comment": "I thought this was intentionally here to skirt the need for the import if `ZoneInfo` isn't used...",
      "comment_id": 1916420662,
      "user": "sydney-runkle",
      "created_at": "2025-01-15T11:46:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1916420662"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11258,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1674,
      "side": "RIGHT",
      "diff_hunk": "@@ -1673,11 +1671,6 @@ def _type_schema(self) -> core_schema.CoreSchema:\n \n     def _zoneinfo_schema(self) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a zone_info.ZoneInfo object\"\"\"\n-        # we're def >=py3.9 if ZoneInfo was included in input\n-        if sys.version_info < (3, 9):\n-            assert False, 'Unreachable'\n-\n-        # import in this path is safe\n         from zoneinfo import ZoneInfo, ZoneInfoNotFoundError",
      "comment": "We timed the import, it's slow enough that we're fine with moving up above.",
      "comment_id": 1916774110,
      "user": "sydney-runkle",
      "created_at": "2025-01-15T14:40:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/11258#discussion_r1916774110"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11232,
      "file_path": "pydantic/typing.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,7 +58,7 @@\n     def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n         return type_._evaluate(globalns, localns)\n \n-elif sys.version_info < (3, 12):\n+elif sys.version_info < (3, 12, 8):",
      "comment": "```suggestion\r\nelif sys.version_info < (3, 12, 4):\r\n```",
      "comment_id": 1907372301,
      "user": "Viicos",
      "created_at": "2025-01-08T15:27:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/11232#discussion_r1907372301"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11232,
      "file_path": "pydantic/typing.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,7 +58,7 @@\n     def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n         return type_._evaluate(globalns, localns)\n \n-elif sys.version_info < (3, 12):\n+elif sys.version_info < (3, 12, 8):",
      "comment": "Ah... guess I misread the bug description. Have amended and force-pushed your suggestion.",
      "comment_id": 1907447866,
      "user": "griels",
      "created_at": "2025-01-08T16:18:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/11232#discussion_r1907447866"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11255,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -100,7 +84,7 @@ def literal_values(tp: Any, /) -> list[Any]:\n         # Note: we could also check for generic aliases with a type alias as an origin.\n         # However, it is very unlikely that this happens as type variables can't appear in\n         # `Literal` forms, so the only valid (but unnecessary) use case would be something like:\n-        # `type Test[T] = Literal['whatever']` (and then use `Test[SomeType]`).\n+        # `type test[T] = Literal['whatever']` (and then use `Test[SomeType]`).",
      "comment": "```suggestion\r\n        # `type Test[T] = Literal['whatever']` (and then use `Test[SomeType]`).\r\n```",
      "comment_id": 1910856274,
      "user": "samuelcolvin",
      "created_at": "2025-01-10T18:24:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/11255#discussion_r1910856274"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11255,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -120,7 +105,8 @@ def is_annotated(tp: Any, /) -> bool:\n     #> True\n     ```\n     \"\"\"\n-    return _is_typing_name(get_origin(tp), name='Annotated')\n+    origin = get_origin(tp)\n+    return origin is t_e.Annotated or (hasattr(typing, 'Annotated') and origin is typing.Annotated)",
      "comment": "Note: this can also be done differently, e.g.:\r\n\r\n```python\r\nIS_PY39 = sys.version_info >= (3, 9)\r\n\r\ndef is_annotated(tp: Any, /) -> bool:\r\n    origin = get_origin(tp)\r\n    return origin is t_e.Annotated or IS_PY39 and origin is typing.Annotated\r\n```\r\n\r\nBut all the approaches are equivalent in term of performance",
      "comment_id": 1910858139,
      "user": "Viicos",
      "created_at": "2025-01-10T18:25:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/11255#discussion_r1910858139"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11255,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,7 +40,7 @@ def is_any(tp: Any, /) -> bool:\n     #> True\n     ```\n     \"\"\"\n-    return _is_typing_name(tp, name='Any')\n+    return tp is typing.Any or tp is t_e.Any",
      "comment": "I wonder if it's worth importing everything by name and avoiding the attribute access, in my test it reduced the time from about 30ns to 20ns?",
      "comment_id": 1910863141,
      "user": "samuelcolvin",
      "created_at": "2025-01-10T18:26:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/11255#discussion_r1910863141"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11255,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -120,7 +105,8 @@ def is_annotated(tp: Any, /) -> bool:\n     #> True\n     ```\n     \"\"\"\n-    return _is_typing_name(get_origin(tp), name='Annotated')\n+    origin = get_origin(tp)\n+    return origin is t_e.Annotated or (hasattr(typing, 'Annotated') and origin is typing.Annotated)",
      "comment": "surely worth having two version of the function for 3.8 and 3.9?",
      "comment_id": 1910864937,
      "user": "samuelcolvin",
      "created_at": "2025-01-10T18:27:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/11255#discussion_r1910864937"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11255,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,6 +96,7 @@ def literal_values(tp: Any, /) -> list[Any]:\n     return [x for value in values for x in literal_values(value)]\n \n \n+# Drop Python 3.8: `origin is typing.Annotated or origin is t_e.Annotated`",
      "comment": "Does this mean, when we drop 3.8, we can change to XXX? Can we make that more explicit?",
      "comment_id": 1910878272,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T18:29:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/11255#discussion_r1910878272"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/config.py",
      "line": 568,
      "side": "RIGHT",
      "diff_hunk": "@@ -563,7 +563,7 @@ class Transaction(BaseModel):\n     3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.\n     \"\"\"\n \n-    ser_json_timedelta: Literal['iso8601', 'float']\n+    ser_json_timedelta: Literal['iso8601', 'float', 'millisecond']\n     \"\"\"\n     The format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and",
      "comment": "Will need to change the docstring here.\r\n\r\nI'm wondering if we should add support for `'second'` as well, and deprecate `'float'` down the line (equivalent to `'second'`...",
      "comment_id": 1752345600,
      "user": "sydney-runkle",
      "created_at": "2024-09-10T17:08:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1752345600"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/_internal/_config.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,6 +169,13 @@ def core_config(self, obj: Any) -> core_schema.CoreConfig:\n         \"\"\"\n         config = self.config_dict\n \n+        if config.get('ser_json_timedelta') == 'float':",
      "comment": "I think this is the right place for the deprecation warning, but do let me know if theres a better place to put it/someone else wants to take over this part.",
      "comment_id": 1755211919,
      "user": "ollz272",
      "created_at": "2024-09-11T17:27:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1755211919"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/config.py",
      "line": 569,
      "side": "RIGHT",
      "diff_hunk": "@@ -563,13 +563,16 @@ class Transaction(BaseModel):\n     3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.\n     \"\"\"\n \n-    ser_json_timedelta: Literal['iso8601', 'float']\n+    ser_json_timedelta: Literal['iso8601', 'float', 'milliseconds_float', 'seconds_float']\n     \"\"\"\n     The format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and\n-    `'float'`. Defaults to `'iso8601'`.\n+    'float_seconds'`, `'float_milliseconds'` and `'float'`. Defaults to `'iso8601'`.",
      "comment": "Hopefully these docs cover it, i couldn't see this anywhere else. Lemme know if this needs changing!",
      "comment_id": 1755213089,
      "user": "ollz272",
      "created_at": "2024-09-11T17:28:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1755213089"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/warnings.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +67,13 @@ def __init__(self, message: str, *args: object) -> None:\n         super().__init__(message, *args, since=(2, 9), expected_removal=(3, 0))\n \n \n+class PydanticDeprecatedSince210(PydanticDeprecationWarning):",
      "comment": "Since this doesn't exist yet i went to the liberty of creating the new deprecation warning for 2.10",
      "comment_id": 1755213707,
      "user": "ollz272",
      "created_at": "2024-09-11T17:29:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1755213707"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "tests/test_json_schema.py",
      "line": 1787,
      "side": "RIGHT",
      "diff_hunk": "@@ -1778,21 +1779,42 @@ class Outer(BaseModel):\n     'ser_json_timedelta,properties',\n     [\n         ('float', {'duration': {'default': 300.0, 'title': 'Duration', 'type': 'number'}}),\n+        ('seconds_float', {'duration': {'default': 300.0, 'title': 'Duration', 'type': 'number'}}),\n+        ('milliseconds_float', {'duration': {'default': 300000.0, 'title': 'Duration', 'type': 'number'}}),\n         ('iso8601', {'duration': {'default': 'PT5M', 'format': 'duration', 'title': 'Duration', 'type': 'string'}}),\n     ],\n )\n-def test_model_default_timedelta(ser_json_timedelta: Literal['float', 'iso8601'], properties: typing.Dict[str, Any]):\n-    class Model(BaseModel):\n-        model_config = ConfigDict(ser_json_timedelta=ser_json_timedelta)\n+def test_model_default_timedelta(",
      "comment": "After submitting this im pretty sure the float options should have their own tests, but i'll let you guys decide on this \ud83d\udc4d\ud83c\udffb ",
      "comment_id": 1755214920,
      "user": "ollz272",
      "created_at": "2024-09-11T17:30:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1755214920"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/_internal/_config.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,6 +169,13 @@ def core_config(self, obj: Any) -> core_schema.CoreConfig:\n         \"\"\"\n         config = self.config_dict\n \n+        if config.get('ser_json_timedelta') == 'float':\n+            warnings.warn(\n+                'Using a `float` as an option for `ser_json_timedelta` is deprecated, use a `float_seconds` instead.',",
      "comment": "```suggestion\r\n                The `float` option for `ser_json_timedelta` has been deprecated in favor of `seconds_float`. Please use this setting instead.',\r\n```",
      "comment_id": 1757085492,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T15:14:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1757085492"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/_internal/_config.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,6 +169,13 @@ def core_config(self, obj: Any) -> core_schema.CoreConfig:\n         \"\"\"\n         config = self.config_dict\n \n+        if config.get('ser_json_timedelta') == 'float':",
      "comment": "LGTM for now. Reminds me - I should probably add back `schema_generator` to the config and add a deprecation warning here before v2.10.",
      "comment_id": 1757086427,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T15:15:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1757086427"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/config.py",
      "line": 569,
      "side": "RIGHT",
      "diff_hunk": "@@ -563,13 +563,16 @@ class Transaction(BaseModel):\n     3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.\n     \"\"\"\n \n-    ser_json_timedelta: Literal['iso8601', 'float']\n+    ser_json_timedelta: Literal['iso8601', 'float', 'milliseconds_float', 'seconds_float']\n     \"\"\"\n     The format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and\n-    `'float'`. Defaults to `'iso8601'`.\n+    'float_seconds'`, `'float_milliseconds'` and `'float'`. Defaults to `'iso8601'`.",
      "comment": "Got these backwards here - we want `seconds_float` not `float_seconds`",
      "comment_id": 1757087494,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T15:15:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1757087494"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/config.py",
      "line": 569,
      "side": "RIGHT",
      "diff_hunk": "@@ -563,13 +563,16 @@ class Transaction(BaseModel):\n     3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.\n     \"\"\"\n \n-    ser_json_timedelta: Literal['iso8601', 'float']\n+    ser_json_timedelta: Literal['iso8601', 'float', 'milliseconds_float', 'seconds_float']\n     \"\"\"\n     The format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and\n-    `'float'`. Defaults to `'iso8601'`.\n+    'float_seconds'`, `'float_milliseconds'` and `'float'`. Defaults to `'iso8601'`.",
      "comment": "I'd say leave out the part that says you can use `float`.",
      "comment_id": 1757089186,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T15:16:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1757089186"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/_internal/_config.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,6 +169,13 @@ def core_config(self, obj: Any) -> core_schema.CoreConfig:\n         \"\"\"\n         config = self.config_dict\n \n+        if config.get('ser_json_timedelta') == 'float':\n+            warnings.warn(\n+                'Using a `float` as an option for `ser_json_timedelta` is deprecated, use a `float_seconds` instead.',",
      "comment": "On second thought - why don't we remove support for `float`. So don't include it in type hints, etc.\r\n\r\nTo preserve backwards compatibility for a short period of time, we can manually coerce `float` to `seconds_float` in this function.",
      "comment_id": 1757090553,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T15:17:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1757090553"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/_internal/_config.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,6 +169,13 @@ def core_config(self, obj: Any) -> core_schema.CoreConfig:\n         \"\"\"\n         config = self.config_dict\n \n+        if config.get('ser_json_timedelta') == 'float':\n+            warnings.warn(\n+                'Using a `float` as an option for `ser_json_timedelta` is deprecated, use a `float_seconds` instead.',",
      "comment": "We should continue to emit this warning, even if we remove \"support\". We can remove the coercion in v3, I think.",
      "comment_id": 1757632172,
      "user": "davidhewitt",
      "created_at": "2024-09-12T21:50:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1757632172"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/config.py",
      "line": 565,
      "side": "RIGHT",
      "diff_hunk": "@@ -562,13 +562,15 @@ class Transaction(BaseModel):\n     3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.\n     \"\"\"\n \n-    ser_json_timedelta: Literal['iso8601', 'float']\n+    ser_json_timedelta: Literal['iso8601', 'milliseconds_float', 'seconds_float']",
      "comment": "```suggestion\r\n    ser_json_timedelta: Literal['iso8601', 'seconds_float', 'milliseconds_float']\r\n```\r\n\r\nNit pick, let's keep the order the same as that of `pydantic-core`",
      "comment_id": 1765146302,
      "user": "sydney-runkle",
      "created_at": "2024-09-18T14:15:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1765146302"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "pydantic/config.py",
      "line": 568,
      "side": "RIGHT",
      "diff_hunk": "@@ -562,13 +562,15 @@ class Transaction(BaseModel):\n     3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.\n     \"\"\"\n \n-    ser_json_timedelta: Literal['iso8601', 'float']\n+    ser_json_timedelta: Literal['iso8601', 'milliseconds_float', 'seconds_float']\n     \"\"\"\n     The format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and\n-    `'float'`. Defaults to `'iso8601'`.\n+    'seconds_float'`, `'float_milliseconds'` and `'float'`. Defaults to `'iso8601'`.",
      "comment": "Should read:\r\n\r\n```\r\nThe format of JSON serialized timedeltas. Accepts the string values of `'iso8601'`, `'seconds_float'`, and `'milliseconds_float'`. Defaults to `'iso8601'`.\r\n```\r\n",
      "comment_id": 1765147899,
      "user": "sydney-runkle",
      "created_at": "2024-09-18T14:16:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1765147899"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10293,
      "file_path": "tests/test_json_schema.py",
      "line": 1787,
      "side": "RIGHT",
      "diff_hunk": "@@ -1778,21 +1779,42 @@ class Outer(BaseModel):\n     'ser_json_timedelta,properties',\n     [\n         ('float', {'duration': {'default': 300.0, 'title': 'Duration', 'type': 'number'}}),\n+        ('seconds_float', {'duration': {'default': 300.0, 'title': 'Duration', 'type': 'number'}}),\n+        ('milliseconds_float', {'duration': {'default': 300000.0, 'title': 'Duration', 'type': 'number'}}),\n         ('iso8601', {'duration': {'default': 'PT5M', 'format': 'duration', 'title': 'Duration', 'type': 'string'}}),\n     ],\n )\n-def test_model_default_timedelta(ser_json_timedelta: Literal['float', 'iso8601'], properties: typing.Dict[str, Any]):\n-    class Model(BaseModel):\n-        model_config = ConfigDict(ser_json_timedelta=ser_json_timedelta)\n+def test_model_default_timedelta(",
      "comment": "Yeah, I think having their own tests would be good so that we can avoid the conditional warning checks.",
      "comment_id": 1765154229,
      "user": "sydney-runkle",
      "created_at": "2024-09-18T14:20:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10293#discussion_r1765154229"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11247,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1094,
      "side": "LEFT",
      "diff_hunk": "@@ -1087,11 +1121,6 @@ def _match_generic_type(self, obj: Any, origin: Any) -> CoreSchema:  # noqa: C90\n         elif origin in (re.Pattern, typing.Pattern):\n             return self._pattern_schema(obj)\n \n-        res = self._get_prepare_pydantic_annotations_for_known_type(obj, ())\n-        if res is not None:\n-            source_type, annotations = res\n-            return self._apply_annotations(source_type, annotations)\n-",
      "comment": "Yay! This is what we've been trying to remove for a long time :)",
      "comment_id": 1910616289,
      "user": "sydney-runkle",
      "created_at": "2025-01-10T16:23:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/11247#discussion_r1910616289"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11247,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 475,
      "side": "RIGHT",
      "diff_hunk": "@@ -403,8 +409,79 @@ def decimal_places_validator(x: Any, decimal_places: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'decimal_places' to supplied value {x}\")\n \n \n-def deque_validator(input_value: Any, handler: core_schema.ValidatorFunctionWrapHandler) -> deque[Any]:\n-    return deque(handler(input_value), maxlen=getattr(input_value, 'maxlen', None))\n+def deque_validator(input_value: Any, handler: core_schema.ValidatorFunctionWrapHandler) -> collections.deque[Any]:\n+    return collections.deque(handler(input_value), maxlen=getattr(input_value, 'maxlen', None))\n+\n+\n+def defaultdict_validator(\n+    input_value: Any, handler: core_schema.ValidatorFunctionWrapHandler, default_default_factory: Callable[[], Any]\n+) -> collections.defaultdict[Any, Any]:\n+    if isinstance(input_value, collections.defaultdict):\n+        default_factory = input_value.default_factory\n+        return collections.defaultdict(default_factory, handler(input_value))\n+    else:\n+        return collections.defaultdict(default_default_factory, handler(input_value))\n+\n+\n+def get_defaultdict_default_default_factory(values_source_type: Any) -> Callable[[], Any]:\n+    FieldInfo = import_cached_field_info()\n+\n+    def infer_default() -> Callable[[], Any]:\n+        allowed_default_types: dict[Any, Any] = {\n+            typing.Tuple: tuple,\n+            tuple: tuple,\n+            collections.abc.Sequence: tuple,\n+            collections.abc.MutableSequence: list,\n+            typing.List: list,\n+            list: list,\n+            typing.Sequence: list,\n+            typing.Set: set,\n+            set: set,\n+            typing.MutableSet: set,\n+            collections.abc.MutableSet: set,\n+            collections.abc.Set: frozenset,\n+            typing.MutableMapping: dict,\n+            typing.Mapping: dict,\n+            collections.abc.Mapping: dict,\n+            collections.abc.MutableMapping: dict,\n+            float: float,\n+            int: int,\n+            str: str,\n+            bool: bool,\n+        }\n+        values_type_origin = get_origin(values_source_type) or values_source_type\n+        instructions = 'set using `DefaultDict[..., Annotated[..., Field(default_factory=...)]]`'\n+        if isinstance(values_type_origin, TypeVar):\n+\n+            def type_var_default_factory() -> None:\n+                raise RuntimeError(\n+                    'Generic defaultdict cannot be used without a concrete value type or an'\n+                    ' explicit default factory, ' + instructions\n+                )\n+\n+            return type_var_default_factory\n+        elif values_type_origin not in allowed_default_types:\n+            # a somewhat subjective set of types that have reasonable default values\n+            allowed_msg = ', '.join([t.__name__ for t in set(allowed_default_types.values())])\n+            raise PydanticSchemaGenerationError(\n+                f'Unable to infer a default factory for keys of type {values_source_type}.'\n+                f' Only {allowed_msg} are supported, other types require an explicit default factory'\n+                ' ' + instructions\n+            )\n+        return allowed_default_types[values_type_origin]\n+\n+    # Assume Annotated[..., Field(...)]\n+    if _typing_extra.is_annotated(values_source_type):\n+        # Important that we use typing_extensions.get_args here in order to support 3.8",
      "comment": "```suggestion\r\n```\r\n\r\nOr in the PR droping 3.8, as you wish",
      "comment_id": 1910695829,
      "user": "Viicos",
      "created_at": "2025-01-10T17:27:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/11247#discussion_r1910695829"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10847,
      "file_path": "pydantic/main.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,6 +282,12 @@ def is_untouched(v: Any) -> bool:\n         cls = super().__new__(mcs, name, bases, new_namespace, **kwargs)\n         # set __signature__ attr only for model class, but not for its instances\n         cls.__signature__ = ClassAttribute('__signature__', generate_model_signature(cls.__init__, fields, config))\n+\n+        if not _is_base_model_class_defined:\n+            # Cython does not understand the `if TYPE_CHECKING:` condition in the\n+            # BaseModel's body (where annotations are set), so clear them manually:\n+            getattr(cls, '__annotations__', {}).clear()\n+",
      "comment": "Why is this necessary? Maybe I'm missing context above...",
      "comment_id": 1879289610,
      "user": "sydney-runkle",
      "created_at": "2024-12-11T03:46:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/10847#discussion_r1879289610"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10847,
      "file_path": "pydantic/typing.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +67,13 @@ def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n         # TypeError: ForwardRef._evaluate() missing 1 required keyword-only argument: 'recursive_guard'\n         return cast(Any, type_)._evaluate(globalns, localns, recursive_guard=set())\n \n+else:\n+\n+    def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n+        # Pydantic 1.x will not support PEP 695 syntax, but provide `type_params` to avoid\n+        # warnings:",
      "comment": "```suggestion\r\n        # Pydantic 1.x will not support PEP 695 syntax, but provide `type_params` to avoid warnings\r\n```\r\n\r\nThanks for the comment, looks good",
      "comment_id": 1879290153,
      "user": "sydney-runkle",
      "created_at": "2024-12-11T03:47:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10847#discussion_r1879290153"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10847,
      "file_path": "tests/test_model_signature.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,6 +4,12 @@\n from typing_extensions import Annotated\n \n from pydantic import BaseModel, Extra, Field, create_model\n+from pydantic.version import compiled\n+\n+# Cython 3.x uses stringified annotations by default. When a signature is generated\n+# for Pydantic models, we use the `BaseModel.__init__` signature which has a type\n+# of `Any` for the data. This annotation is reused and will be stringified only when compiled:\n+Any_ann = \"'Any'\" if compiled else 'Any'",
      "comment": "This is a bit over my head, but the comment does clear things up a bit. Thanks for the note here.",
      "comment_id": 1879293179,
      "user": "sydney-runkle",
      "created_at": "2024-12-11T03:52:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10847#discussion_r1879293179"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10847,
      "file_path": "pydantic/main.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,6 +282,12 @@ def is_untouched(v: Any) -> bool:\n         cls = super().__new__(mcs, name, bases, new_namespace, **kwargs)\n         # set __signature__ attr only for model class, but not for its instances\n         cls.__signature__ = ClassAttribute('__signature__', generate_model_signature(cls.__init__, fields, config))\n+\n+        if not _is_base_model_class_defined:\n+            # Cython does not understand the `if TYPE_CHECKING:` condition in the\n+            # BaseModel's body (where annotations are set), so clear them manually:\n+            getattr(cls, '__annotations__', {}).clear()\n+",
      "comment": "`BaseModel` is defining some annotations in an `if TYPE_CHECKING:` block:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/7c70a4af4e07a1d1783334692384da78866dc3e9/pydantic/main.py#L310-L315\r\n\r\nbut Cython (at least on 3.x) assumes `TYPE_CHECKING` is `True` at runtime. ",
      "comment_id": 1879694818,
      "user": "Viicos",
      "created_at": "2024-12-11T09:30:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10847#discussion_r1879694818"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10847,
      "file_path": "pydantic/utils.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,7 +159,7 @@ def sequence_like(v: Any) -> bool:\n     return isinstance(v, (list, tuple, set, frozenset, GeneratorType, deque))\n \n \n-def validate_field_name(bases: List[Type['BaseModel']], field_name: str) -> None:\n+def validate_field_name(bases: Iterable[Type[Any]], field_name: str) -> None:",
      "comment": "`validate_field_name` is called from `ModelMetaclass.__new__`, where `bases` is a tuple. This caused an Cython error as in 3.x it is able to understand and check type annotations using `list`. This turns out being not necessary I believe because I disabled the [`annotation_typing` directive](https://cython.readthedocs.io/en/latest/src/tutorial/pure.html#disabling-annotations) as I was getting more errors, but still good to have the annotation fixed anyway.",
      "comment_id": 1879707569,
      "user": "Viicos",
      "created_at": "2024-12-11T09:34:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/10847#discussion_r1879707569"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10847,
      "file_path": "pydantic/main.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,6 +282,12 @@ def is_untouched(v: Any) -> bool:\n         cls = super().__new__(mcs, name, bases, new_namespace, **kwargs)\n         # set __signature__ attr only for model class, but not for its instances\n         cls.__signature__ = ClassAttribute('__signature__', generate_model_signature(cls.__init__, fields, config))\n+\n+        if not _is_base_model_class_defined:\n+            # Cython does not understand the `if TYPE_CHECKING:` condition in the\n+            # BaseModel's body (where annotations are set), so clear them manually:\n+            getattr(cls, '__annotations__', {}).clear()\n+",
      "comment": "See https://cython.readthedocs.io/en/latest/src/tutorial/pure.html#magic-attributes\r\n\r\nI think a cleaner solution might be to change the guard to `if TYPE_CHECKING and not cython.compiled`.",
      "comment_id": 1879768393,
      "user": "davidhewitt",
      "created_at": "2024-12-11T10:10:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10847#discussion_r1879768393"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10847,
      "file_path": "pydantic/main.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,6 +282,12 @@ def is_untouched(v: Any) -> bool:\n         cls = super().__new__(mcs, name, bases, new_namespace, **kwargs)\n         # set __signature__ attr only for model class, but not for its instances\n         cls.__signature__ = ClassAttribute('__signature__', generate_model_signature(cls.__init__, fields, config))\n+\n+        if not _is_base_model_class_defined:\n+            # Cython does not understand the `if TYPE_CHECKING:` condition in the\n+            # BaseModel's body (where annotations are set), so clear them manually:\n+            getattr(cls, '__annotations__', {}).clear()\n+",
      "comment": "Not sure how Cython is handling this, but turns out it is not related to `typing.TYPE_CHECKING`. Any condition in the class body is discarded, as long as it is not directly using the `False` literal, e.g.:\r\n\r\n```python\r\nvar = False\r\n\r\nclass A:\r\n    if var:\r\n        ann: int\r\n\r\nA.__annotations__\r\n#> {'ann': int}",
      "comment_id": 1879871216,
      "user": "Viicos",
      "created_at": "2024-12-11T11:08:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10847#discussion_r1879871216"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10847,
      "file_path": "pydantic/typing.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +67,13 @@ def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n         # TypeError: ForwardRef._evaluate() missing 1 required keyword-only argument: 'recursive_guard'\n         return cast(Any, type_)._evaluate(globalns, localns, recursive_guard=set())\n \n+else:\n+\n+    def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n+        # Pydantic 1.x will not support PEP 695 syntax, but provide `type_params` to avoid\n+        # warnings:\n+        return cast(Any, type_)._evaluate(globalns, localns, type_params=(), recursive_guard=set())\n+",
      "comment": "@Viicos @sydney-runkle Seems this block has introduced a regression for some python3.12 versions https://github.com/pydantic/pydantic/issues/11230",
      "comment_id": 1906086954,
      "user": "masenf",
      "created_at": "2025-01-07T21:55:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/10847#discussion_r1906086954"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10847,
      "file_path": "pydantic/typing.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +67,13 @@ def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n         # TypeError: ForwardRef._evaluate() missing 1 required keyword-only argument: 'recursive_guard'\n         return cast(Any, type_)._evaluate(globalns, localns, recursive_guard=set())\n \n+else:\n+\n+    def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n+        # Pydantic 1.x will not support PEP 695 syntax, but provide `type_params` to avoid\n+        # warnings:\n+        return cast(Any, type_)._evaluate(globalns, localns, type_params=(), recursive_guard=set())\n+",
      "comment": "This! Please revert this specific change. EDIT: I've gone one better and fixed it so it should work for 3.12.0, *and* >=3.12.4. Thanks to @Viicos for his prompt assistance :)",
      "comment_id": 1907132329,
      "user": "griels",
      "created_at": "2025-01-08T12:47:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10847#discussion_r1907132329"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11208,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2501,
      "side": "RIGHT",
      "diff_hunk": "@@ -2501,12 +2477,30 @@ def _common_field(\n class _Definitions:\n     \"\"\"Keeps track of references and definitions.\"\"\"\n \n+    _recursively_seen: set[str]\n+    \"\"\"A set of recursively seen references.\n+\n+    When a referenceable type is encountered, the `get_schema_or_ref` context manager is\n+    entered to compute the reference. If the type references itself by some way (e.g. for\n+    a dataclass a Pydantic model, the class can be referenced as a field annotation),\n+    entering the context manager again will yield a `'definition-ref'` schema that should\n+    short-circuit the normal generation process, as the reference was already in this set.\n+    \"\"\"\n+\n+    _definitions: dict[str, core_schema.CoreSchema]\n+    \"\"\"A mapping of references to their corresponding schema.\n+\n+    When a schema for a referenceable type is generated, it is stored in this mapping. If the\n+    same type is encountered again, the reference is yielded by the `get_schema_or_ref` context\n+    manager.\n+    \"\"\"\n+\n     def __init__(self) -> None:\n-        self.seen: set[str] = set()\n-        self.definitions: dict[str, core_schema.CoreSchema] = {}\n+        self._recursively_seen = set()\n+        self._definitions = {}",
      "comment": "@MarkusSintonen, in your PR, you made a distinction between definitions stored from `create_reference_to_schema` and definitions coming from `unpack_definitions` (in your PR, as `_unpacked_definitions`), i.e. definitions potentially coming from the cached attribute of Pydantic models.\r\n\r\nWhat was the reason to do so?",
      "comment_id": 1901312387,
      "user": "Viicos",
      "created_at": "2025-01-02T22:20:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/11208#discussion_r1901312387"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11208,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 829,
      "side": "RIGHT",
      "diff_hunk": "@@ -843,8 +821,11 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n             ref = get_ref(schema)\n \n         if ref:\n-            self.defs.definitions[ref] = schema\n-            return core_schema.definition_reference_schema(ref)\n+            return self.defs.create_reference_to_schema(schema)\n+\n+        # TODO\n+        # if schema['type'] == 'definition-ref':\n+        #     return core_schema.definition_reference_schema(schema_ref=schema['schema_ref'])",
      "comment": "@MarkusSintonen, this is an addition in your PR. Seems like test passes without it. Do you remember why this might be required? I'm assuming this is part of https://github.com/pydantic/pydantic/pull/10655, where `'definition-ref'` schemas are inlined in place, and thus this might some kind of safety copy?",
      "comment_id": 1901313586,
      "user": "Viicos",
      "created_at": "2025-01-02T22:23:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/11208#discussion_r1901313586"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11208,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2536,
      "side": "RIGHT",
      "diff_hunk": "@@ -2520,26 +2515,61 @@ def get_schema_or_ref(self, tp: Any) -> Iterator[tuple[str, None] | tuple[str, C\n \n         At present the following types can be named/recursive:\n \n-        - BaseModel\n-        - Dataclasses\n-        - TypedDict\n-        - TypeAliasType\n+        - Pydantic model\n+        - Pydantic and stdlib dataclasses\n+        - Typed dictionaries\n+        - Named tuples\n+        - `TypeAliasType` instances\n+        - Enums\n         \"\"\"\n         ref = get_type_ref(tp)\n-        # return the reference if we're either (1) in a cycle or (2) it was already defined\n-        if ref in self.seen or ref in self.definitions:\n+        # return the reference if we're either (1) in a cycle or (2) it the reference was already encountered:\n+        if ref in self._recursively_seen or ref in self._definitions:\n             yield (ref, core_schema.definition_reference_schema(ref))\n         else:\n-            self.seen.add(ref)\n+            self._recursively_seen.add(ref)\n             try:\n                 yield (ref, None)\n             finally:\n-                self.seen.discard(ref)\n+                self._recursively_seen.discard(ref)\n+\n+    def get_from_ref(self, ref: str) -> CoreSchema | None:",
      "comment": "```suggestion\r\n    def get_def_from_ref(self, ref: str) -> CoreSchema | None:\r\n```\r\n\r\nIs this more clear?",
      "comment_id": 1905595502,
      "user": "sydney-runkle",
      "created_at": "2025-01-07T15:07:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/11208#discussion_r1905595502"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11208,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2540,
      "side": "RIGHT",
      "diff_hunk": "@@ -2520,26 +2515,61 @@ def get_schema_or_ref(self, tp: Any) -> Iterator[tuple[str, None] | tuple[str, C\n \n         At present the following types can be named/recursive:\n \n-        - BaseModel\n-        - Dataclasses\n-        - TypedDict\n-        - TypeAliasType\n+        - Pydantic model\n+        - Pydantic and stdlib dataclasses\n+        - Typed dictionaries\n+        - Named tuples\n+        - `TypeAliasType` instances\n+        - Enums\n         \"\"\"\n         ref = get_type_ref(tp)\n-        # return the reference if we're either (1) in a cycle or (2) it was already defined\n-        if ref in self.seen or ref in self.definitions:\n+        # return the reference if we're either (1) in a cycle or (2) it the reference was already encountered:\n+        if ref in self._recursively_seen or ref in self._definitions:\n             yield (ref, core_schema.definition_reference_schema(ref))\n         else:\n-            self.seen.add(ref)\n+            self._recursively_seen.add(ref)\n             try:\n                 yield (ref, None)\n             finally:\n-                self.seen.discard(ref)\n+                self._recursively_seen.discard(ref)\n+\n+    def get_from_ref(self, ref: str) -> CoreSchema | None:\n+        \"\"\"Resolve the schema from the given reference.\"\"\"\n+        return self._definitions.get(ref)\n+\n+    def create_reference_to_schema(self, schema: CoreSchema) -> core_schema.DefinitionReferenceSchema:",
      "comment": "```suggestion\r\n    def create_def_ref_schema(self, schema: CoreSchema) -> core_schema.DefinitionReferenceSchema:\r\n```\r\n\r\nIs this more clear?",
      "comment_id": 1905596504,
      "user": "sydney-runkle",
      "created_at": "2025-01-07T15:08:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/11208#discussion_r1905596504"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11208,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2536,
      "side": "RIGHT",
      "diff_hunk": "@@ -2520,26 +2515,61 @@ def get_schema_or_ref(self, tp: Any) -> Iterator[tuple[str, None] | tuple[str, C\n \n         At present the following types can be named/recursive:\n \n-        - BaseModel\n-        - Dataclasses\n-        - TypedDict\n-        - TypeAliasType\n+        - Pydantic model\n+        - Pydantic and stdlib dataclasses\n+        - Typed dictionaries\n+        - Named tuples\n+        - `TypeAliasType` instances\n+        - Enums\n         \"\"\"\n         ref = get_type_ref(tp)\n-        # return the reference if we're either (1) in a cycle or (2) it was already defined\n-        if ref in self.seen or ref in self.definitions:\n+        # return the reference if we're either (1) in a cycle or (2) it the reference was already encountered:\n+        if ref in self._recursively_seen or ref in self._definitions:\n             yield (ref, core_schema.definition_reference_schema(ref))\n         else:\n-            self.seen.add(ref)\n+            self._recursively_seen.add(ref)\n             try:\n                 yield (ref, None)\n             finally:\n-                self.seen.discard(ref)\n+                self._recursively_seen.discard(ref)\n+\n+    def get_from_ref(self, ref: str) -> CoreSchema | None:",
      "comment": "This is probably better, given that we have the above `get_schema_or_ref` function",
      "comment_id": 1905600470,
      "user": "sydney-runkle",
      "created_at": "2025-01-07T15:10:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/11208#discussion_r1905600470"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11208,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2540,
      "side": "RIGHT",
      "diff_hunk": "@@ -2520,26 +2515,61 @@ def get_schema_or_ref(self, tp: Any) -> Iterator[tuple[str, None] | tuple[str, C\n \n         At present the following types can be named/recursive:\n \n-        - BaseModel\n-        - Dataclasses\n-        - TypedDict\n-        - TypeAliasType\n+        - Pydantic model\n+        - Pydantic and stdlib dataclasses\n+        - Typed dictionaries\n+        - Named tuples\n+        - `TypeAliasType` instances\n+        - Enums\n         \"\"\"\n         ref = get_type_ref(tp)\n-        # return the reference if we're either (1) in a cycle or (2) it was already defined\n-        if ref in self.seen or ref in self.definitions:\n+        # return the reference if we're either (1) in a cycle or (2) it the reference was already encountered:\n+        if ref in self._recursively_seen or ref in self._definitions:\n             yield (ref, core_schema.definition_reference_schema(ref))\n         else:\n-            self.seen.add(ref)\n+            self._recursively_seen.add(ref)\n             try:\n                 yield (ref, None)\n             finally:\n-                self.seen.discard(ref)\n+                self._recursively_seen.discard(ref)\n+\n+    def get_from_ref(self, ref: str) -> CoreSchema | None:\n+        \"\"\"Resolve the schema from the given reference.\"\"\"\n+        return self._definitions.get(ref)\n+\n+    def create_reference_to_schema(self, schema: CoreSchema) -> core_schema.DefinitionReferenceSchema:",
      "comment": "Or even `create_definition_reference_schema` to be more explicit",
      "comment_id": 1905606673,
      "user": "sydney-runkle",
      "created_at": "2025-01-07T15:15:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/11208#discussion_r1905606673"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11208,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1551,
      "side": "RIGHT",
      "diff_hunk": "@@ -1567,7 +1547,8 @@ def _namedtuple_schema(self, namedtuple_cls: Any, origin: Any) -> core_schema.Co\n                 ],\n                 metadata={'pydantic_js_prefer_positional_arguments': True},\n             )\n-            return core_schema.call_schema(arguments_schema, namedtuple_cls, ref=namedtuple_ref)\n+            schema = core_schema.call_schema(arguments_schema, namedtuple_cls, ref=namedtuple_ref)\n+            return self.defs.create_reference_to_schema(schema)",
      "comment": "Indeed, seems like namedtuple schemas were not inlined before. ",
      "comment_id": 1905629755,
      "user": "Viicos",
      "created_at": "2025-01-07T15:30:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/11208#discussion_r1905629755"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11208,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 829,
      "side": "RIGHT",
      "diff_hunk": "@@ -843,8 +821,11 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n             ref = get_ref(schema)\n \n         if ref:\n-            self.defs.definitions[ref] = schema\n-            return core_schema.definition_reference_schema(ref)\n+            return self.defs.create_reference_to_schema(schema)\n+\n+        # TODO\n+        # if schema['type'] == 'definition-ref':\n+        #     return core_schema.definition_reference_schema(schema_ref=schema['schema_ref'])",
      "comment": "I'm removing it from this PR, as if it needs to be included, this will be in the schema walking refactor PR.",
      "comment_id": 1905805335,
      "user": "Viicos",
      "created_at": "2025-01-07T17:14:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/11208#discussion_r1905805335"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10704,
      "file_path": "tests/test_forward_ref.py",
      "line": 762,
      "side": "LEFT",
      "diff_hunk": "@@ -758,13 +764,9 @@ class Bar(BaseModel, Generic[T]):\n     finally:\n         del sys.modules['eval_type_backport']\n \n-    assert module.Foo.model_fields['bar'].annotation == typing.Optional[module.Bar[str]]\n-    assert module.Foo.model_fields['bar2'].annotation == typing.Union[int, module.Bar[float]]",
      "comment": "These assertions are not valid anymore, as the `Bar[str]` class on the annotation is no longer the same that the one we create by calling `module.Bar[str]` here (as it isn't cached anymore).",
      "comment_id": 1904523436,
      "user": "Viicos",
      "created_at": "2025-01-06T18:58:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10704#discussion_r1904523436"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10846,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,6 +322,15 @@ def min_length_validator(x: Any, min_length: Any) -> Any:\n             )\n         return x\n     except TypeError:\n+        if isinstance(x, pathlib.PurePath):\n+            try:\n+                if not (len(str(x)) >= min_length):\n+                    raise PydanticKnownError(\n+                        'too_short', {'field_type': 'Value', 'min_length': min_length, 'actual_length': len(str(x))}\n+                    )\n+                return x\n+            except TypeError:\n+                ...",
      "comment": "As mentioned above, I'd really prefer if this wasn't the long term solution here.",
      "comment_id": 1842744907,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T18:54:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/10846#discussion_r1842744907"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10846,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -308,6 +309,11 @@ def multiple_of_validator(x: Any, multiple_of: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'multiple_of' to supplied value {x}\")\n \n \n+# TODO: we have a sort of hacky way of supporting min_length and max_length for path like types as a consequence\n+# of prior design that supported out of order metadata injection during core schema generation, which we have since abandoned\n+# see: https://github.com/pydantic/pydantic/pull/10846/",
      "comment": "It's notable that we add hacky support for `min_length` and `max_length` below, but we don't support things like `strip_whitespace` or `to_upper` - those are now broken for path like types.",
      "comment_id": 1842745550,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T18:55:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10846#discussion_r1842745550"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10846,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,6 +322,15 @@ def min_length_validator(x: Any, min_length: Any) -> Any:\n             )\n         return x\n     except TypeError:\n+        if isinstance(x, pathlib.PurePath):\n+            try:\n+                if not (len(str(x)) >= min_length):\n+                    raise PydanticKnownError(\n+                        'too_short', {'field_type': 'Value', 'min_length': min_length, 'actual_length': len(str(x))}\n+                    )\n+                return x\n+            except TypeError:\n+                ...",
      "comment": "```suggestion\r\n                pass\r\n```\r\n\r\nThe ellipsis is best used for stub definitions",
      "comment_id": 1846624559,
      "user": "Viicos",
      "created_at": "2024-11-18T13:50:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10846#discussion_r1846624559"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10846,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,6 +322,15 @@ def min_length_validator(x: Any, min_length: Any) -> Any:\n             )\n         return x\n     except TypeError:\n+        if isinstance(x, pathlib.PurePath):\n+            try:\n+                if not (len(str(x)) >= min_length):\n+                    raise PydanticKnownError(\n+                        'too_short', {'field_type': 'Value', 'min_length': min_length, 'actual_length': len(str(x))}\n+                    )\n+                return x\n+            except TypeError:\n+                pass",
      "comment": "IMO it would be more correct to convert this to `bytes()` instead of `str()`",
      "comment_id": 1848982157,
      "user": "adriangb",
      "created_at": "2024-11-19T19:57:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10846#discussion_r1848982157"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10846,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,6 +322,15 @@ def min_length_validator(x: Any, min_length: Any) -> Any:\n             )\n         return x\n     except TypeError:\n+        if isinstance(x, pathlib.PurePath):\n+            try:\n+                if not (len(str(x)) >= min_length):\n+                    raise PydanticKnownError(\n+                        'too_short', {'field_type': 'Value', 'min_length': min_length, 'actual_length': len(str(x))}\n+                    )\n+                return x\n+            except TypeError:\n+                pass",
      "comment": "https://docs.python.org/3/library/pathlib.html\r\n\r\n> Calling [bytes](https://docs.python.org/3/library/stdtypes.html#bytes) is only recommended under Unix. Under Windows, the unicode form is the canonical representation of filesystem paths.\r\n\r\nAlso I think people will mean \"the number of characters\" not \"the number of bytes\".\r\n\r\nIdk what the right thing to do is \ud83d\ude22.",
      "comment_id": 1848983762,
      "user": "adriangb",
      "created_at": "2024-11-19T19:58:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10846#discussion_r1848983762"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10846,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 486,
      "side": "RIGHT",
      "diff_hunk": "@@ -482,6 +482,54 @@ def ser_ip(ip: Any, info: core_schema.SerializationInfo) -> str | IpType:\n             },\n         )\n \n+    def _path_schema(self, tp: Any, path_type: Any) -> CoreSchema:\n+        if tp is os.PathLike and path_type not in {str, bytes, Any}:",
      "comment": "We need to account for `typing.Any` and `typing_extensions.Any`, something like:\r\n\r\n```suggestion\r\n        if tp is os.PathLike and path_type not in {str, bytes} or not _typing_extra.is_any(tp):\r\n```",
      "comment_id": 1876052262,
      "user": "Viicos",
      "created_at": "2024-12-09T14:16:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10846#discussion_r1876052262"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11189,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 580,
      "side": "RIGHT",
      "diff_hunk": "@@ -524,35 +524,62 @@ def is_generic_alias(tp: Any, /) -> bool:\n \n \n def parent_frame_namespace(*, parent_depth: int = 2, force: bool = False) -> dict[str, Any] | None:\n-    \"\"\"We allow use of items in parent namespace to get around the issue with `get_type_hints` only looking in the\n-    global module namespace. See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope\n-    and suggestion at the end of the next comment by @gvanrossum.\n+    \"\"\"Fetch the local namespace of the parent frame where this function is called.\n \n-    WARNING 1: it matters exactly where this is called. By default, this function will build a namespace from the\n-    parent of where it is called.\n+    Using this function is mostly useful to resolve forward annotations pointing to members defined in a local namespace,\n+    such as assignments inside a function. Using the standard library tools, it is currently not possible to resolve\n+    such annotations:\n \n-    WARNING 2: this only looks in the parent namespace, not other parents since (AFAIK) there's no way to collect a\n-    dict of exactly what's in scope. Using `f_back` would work sometimes but would be very wrong and confusing in many\n-    other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.\n+    ```python {lint=\"skip\" test=\"skip\"}\n+    from typing import get_type_hints\n \n-    There are some cases where we want to force fetching the parent namespace, ex: during a `model_rebuild` call.\n-    In this case, we want both the namespace of the class' module, if applicable, and the parent namespace of the\n-    module where the rebuild is called.\n+    def func() -> None:\n+        Alias = int\n \n-    In other cases, like during initial schema build, if a class is defined at the top module level, we don't need to\n-    fetch that module's namespace, because the class' __module__ attribute can be used to access the parent namespace.\n-    This is done in `_namespace_utils.get_module_ns_of`. Thus, there's no need to cache the parent frame namespace in this case.\n+        class C:\n+            a: 'Alias'\n+\n+        # Raises a `NameError: 'Alias' is not defined`\n+        get_type_hints(C)\n+    ```\n+\n+    Pydantic uses this function when a Pydantic model is being defined to fetch the parent frame locals. However,\n+    this only allows us to fetch the parent frame namespace and not other parents (e.g. a model defined in a function,\n+    itself defined in another function). Inspecting the next outer frames (using `f_back`) is not reliable enough\n+    (see https://discuss.python.org/t/20659).\n+\n+    Because this function is mostly used to better resolve forward annotations, nothing is returned if the parent frame's\n+    code object is defined at the module level. In this case, the locals of the frame will be the same as the module\n+    globals where the class is defined (see `_namespace_utils.get_module_ns_of`). However, if you still want to fetch\n+    the module globals (e.g. when rebuilding a model, where the frame where the rebuild call is performed might contain\n+    members that you want to use for forward annotations evaluation), you can use the `force` parameter.\n+\n+    Args:\n+        parent_depth: The depth at which to get the frame. Defaults to 2, meaning the parent frame where this function\n+            is called will be used.\n+        force: Whether to always return the frame locals, even if the frame's code object is defined at the module level.\n+\n+    Returns:\n+        The locals of the namespace, or `None` if it was skipped as per the described logic.\n     \"\"\"\n     frame = sys._getframe(parent_depth)\n \n-    # note, we don't copy frame.f_locals here (or during the last return call), because we don't expect the namespace to be modified down the line\n-    # if this becomes a problem, we could implement some sort of frozen mapping structure to enforce this\n+    if frame.f_code.co_name.startswith('<generic parameters of'):\n+        # As `parent_frame_namespace` is mostly called in `ModelMetaclass.__new__`,\n+        # the parent frame can be the annotation scope if the PEP 695 generic syntax is used.\n+        # (see https://docs.python.org/3/reference/executionmodel.html#annotation-scopes,\n+        # https://docs.python.org/3/reference/compound_stmts.html#generic-classes).\n+        # In this case, we need to skip this frame as it is irrelevant.\n+        frame = cast(types.FrameType, frame.f_back)  # guaranteed to not be `None`\n+\n+    # note, we don't copy frame.f_locals here (or during the last return call), because we don't expect the namespace to be\n+    # modified down the line if this becomes a problem, we could implement some sort of frozen mapping structure to enforce this.\n     if force:\n         return frame.f_locals\n \n-    # if either of the following conditions are true, the class is defined at the top module level\n-    # to better understand why we need both of these checks, see\n-    # https://github.com/pydantic/pydantic/pull/10113#discussion_r1714981531\n+    # if either of the following conditions are true, the class is defined at the top module level.",
      "comment": "```suggestion\r\n    # If either of the following conditions are true, the class is defined at the top module level.\r\n```",
      "comment_id": 1899645232,
      "user": "sydney-runkle",
      "created_at": "2024-12-30T16:05:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/11189#discussion_r1899645232"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11189,
      "file_path": "tests/test_typing.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,13 +146,17 @@ def test_func_ns_excludes_default_globals() -> None:\n         assert default_global_var not in func_ns\n \n \n-module_foo = 'global_foo'\n-module_ns = parent_frame_namespace(parent_depth=1)\n+def test_module_ns_is_none(create_module) -> None:",
      "comment": "Can we add a test with `force=True`, and guarantee that the result is not `None` as well?",
      "comment_id": 1899646401,
      "user": "sydney-runkle",
      "created_at": "2024-12-30T16:07:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/11189#discussion_r1899646401"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11189,
      "file_path": "tests/test_forward_ref.py",
      "line": 1370,
      "side": "RIGHT",
      "diff_hunk": "@@ -1365,3 +1365,78 @@ class Model(BaseModel, A):\n         ReturnedModel = inner()  # noqa: F841\n \n     assert module_1.ReturnedModel.__pydantic_complete__ is False\n+\n+\n+# Tests related to forward annotations evaluation coupled with PEP 695 generic syntax:",
      "comment": "Fine if you want to keep it, just wanted to check :)",
      "comment_id": 1899650451,
      "user": "sydney-runkle",
      "created_at": "2024-12-30T16:14:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/11189#discussion_r1899650451"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11189,
      "file_path": "tests/test_forward_ref.py",
      "line": 1370,
      "side": "RIGHT",
      "diff_hunk": "@@ -1365,3 +1365,78 @@ class Model(BaseModel, A):\n         ReturnedModel = inner()  # noqa: F841\n \n     assert module_1.ReturnedModel.__pydantic_complete__ is False\n+\n+\n+# Tests related to forward annotations evaluation coupled with PEP 695 generic syntax:",
      "comment": "The comment acts as some kind of \"grouping\" of tests (which in reality is a sign that we should split our test files :sweat_smile:), and at some point (in a really long time) the skipifs will be removed but the comment should remains",
      "comment_id": 1899664797,
      "user": "Viicos",
      "created_at": "2024-12-30T16:40:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/11189#discussion_r1899664797"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11169,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 364,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,26 +361,8 @@ def __fields__(self) -> dict[str, FieldInfo]:\n             PydanticDeprecatedSince20,\n             stacklevel=2,\n         )\n-        return self.model_fields\n-\n-    @property\n-    def model_fields(self) -> dict[str, FieldInfo]:\n-        \"\"\"Get metadata about the fields defined on the model.\n-\n-        Returns:\n-            A mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n-        \"\"\"\n         return getattr(self, '__pydantic_fields__', {})",
      "comment": "We followed the pattern of `__fields__` above, can we follow the same pattern for that as well (removal, and deprecation in `main.py`)?",
      "comment_id": 1898618015,
      "user": "sydney-runkle",
      "created_at": "2024-12-27T16:48:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/11169#discussion_r1898618015"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11169,
      "file_path": "pydantic/_internal/_utils.py",
      "line": 414,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,3 +390,35 @@ def __getitem__(self, key: str, /) -> Any:\n \n         def __contains__(self, key: str, /) -> bool:\n             return self.wrapped.__contains__(key)\n+\n+\n+_ModelT = TypeVar('_ModelT', bound='BaseModel')\n+_R = TypeVar('_R')\n+\n+\n+class deprecatedinstanceproperty(Generic[_ModelT, _R]):\n+    \"\"\"A decorator exposing the decorated class method as a property, with a warning on instance access.\n+\n+    This decorator takes a class method defined on the `BaseModel` class and transforms it into\n+    an attribute. The attribute can be accessed on both the class and instances of the class. If accessed\n+    via an instance, a deprecation warning is emitted stating that instance access will be removed in V3.\n+    \"\"\"\n+\n+    def __init__(self, fget: Callable[[type[_ModelT]], _R], /) -> None:\n+        self.fget = fget\n+\n+    @overload\n+    def __get__(self, instance: None, objtype: type[_ModelT]) -> _R: ...\n+    @overload\n+    @deprecated(\n+        'Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3.',",
      "comment": "Maybe add a note about proper access on the class to guide / assist users?",
      "comment_id": 1898619257,
      "user": "sydney-runkle",
      "created_at": "2024-12-27T16:51:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/11169#discussion_r1898619257"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11169,
      "file_path": "pydantic/_internal/_utils.py",
      "line": 399,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,3 +390,35 @@ def __getitem__(self, key: str, /) -> Any:\n \n         def __contains__(self, key: str, /) -> bool:\n             return self.wrapped.__contains__(key)\n+\n+\n+_ModelT = TypeVar('_ModelT', bound='BaseModel')\n+_R = TypeVar('_R')\n+\n+\n+class deprecatedinstanceproperty(Generic[_ModelT, _R]):",
      "comment": "```suggestion\r\nclass deprecated_instance_property(Generic[_ModelT, _R]):\r\n```\r\n\r\nmaybe? easier to read",
      "comment_id": 1898619474,
      "user": "sydney-runkle",
      "created_at": "2024-12-27T16:52:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/11169#discussion_r1898619474"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11169,
      "file_path": "pydantic/_internal/_utils.py",
      "line": 414,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,3 +390,35 @@ def __getitem__(self, key: str, /) -> Any:\n \n         def __contains__(self, key: str, /) -> bool:\n             return self.wrapped.__contains__(key)\n+\n+\n+_ModelT = TypeVar('_ModelT', bound='BaseModel')\n+_R = TypeVar('_R')\n+\n+\n+class deprecatedinstanceproperty(Generic[_ModelT, _R]):\n+    \"\"\"A decorator exposing the decorated class method as a property, with a warning on instance access.\n+\n+    This decorator takes a class method defined on the `BaseModel` class and transforms it into\n+    an attribute. The attribute can be accessed on both the class and instances of the class. If accessed\n+    via an instance, a deprecation warning is emitted stating that instance access will be removed in V3.\n+    \"\"\"\n+\n+    def __init__(self, fget: Callable[[type[_ModelT]], _R], /) -> None:\n+        self.fget = fget\n+\n+    @overload\n+    def __get__(self, instance: None, objtype: type[_ModelT]) -> _R: ...\n+    @overload\n+    @deprecated(\n+        'Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3.',",
      "comment": "Like you've done below:\r\n\r\nInstead, you should access this attribute from the model class.",
      "comment_id": 1898619884,
      "user": "sydney-runkle",
      "created_at": "2024-12-27T16:52:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/11169#discussion_r1898619884"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11169,
      "file_path": "pydantic/_internal/_utils.py",
      "line": 396,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,3 +390,35 @@ def __getitem__(self, key: str, /) -> Any:\n \n         def __contains__(self, key: str, /) -> bool:\n             return self.wrapped.__contains__(key)\n+\n+\n+_ModelT = TypeVar('_ModelT', bound='BaseModel')\n+_R = TypeVar('_R')",
      "comment": "Can we make this typevar more clear, maybe like `PropertyReturnType` or `ReturnType` or something like that?",
      "comment_id": 1898620168,
      "user": "sydney-runkle",
      "created_at": "2024-12-27T16:53:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/11169#discussion_r1898620168"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11169,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 364,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,26 +361,8 @@ def __fields__(self) -> dict[str, FieldInfo]:\n             PydanticDeprecatedSince20,\n             stacklevel=2,\n         )\n-        return self.model_fields\n-\n-    @property\n-    def model_fields(self) -> dict[str, FieldInfo]:\n-        \"\"\"Get metadata about the fields defined on the model.\n-\n-        Returns:\n-            A mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n-        \"\"\"\n         return getattr(self, '__pydantic_fields__', {})",
      "comment": "Hum, not sure what you mean. Moving `__fields__` on `BaseModel`, and use the `deprecated_instance_property` decorator as well?",
      "comment_id": 1898630798,
      "user": "Viicos",
      "created_at": "2024-12-27T17:19:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/11169#discussion_r1898630798"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11169,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 364,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,26 +361,8 @@ def __fields__(self) -> dict[str, FieldInfo]:\n             PydanticDeprecatedSince20,\n             stacklevel=2,\n         )\n-        return self.model_fields\n-\n-    @property\n-    def model_fields(self) -> dict[str, FieldInfo]:\n-        \"\"\"Get metadata about the fields defined on the model.\n-\n-        Returns:\n-            A mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n-        \"\"\"\n         return getattr(self, '__pydantic_fields__', {})",
      "comment": "I think it won't be possible because we want `__fields__` to have the following deprecation message:\r\n\r\n> The `__fields__` attribute is deprecated, use `model_fields` instead\r\n\r\nAnd using the decorator will \"override\" this message with\r\n\r\n> Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3.",
      "comment_id": 1898631648,
      "user": "Viicos",
      "created_at": "2024-12-27T17:21:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/11169#discussion_r1898631648"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11169,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 364,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,26 +361,8 @@ def __fields__(self) -> dict[str, FieldInfo]:\n             PydanticDeprecatedSince20,\n             stacklevel=2,\n         )\n-        return self.model_fields\n-\n-    @property\n-    def model_fields(self) -> dict[str, FieldInfo]:\n-        \"\"\"Get metadata about the fields defined on the model.\n-\n-        Returns:\n-            A mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n-        \"\"\"\n         return getattr(self, '__pydantic_fields__', {})",
      "comment": "That's fine, we can just deprecate fully in v3 then.",
      "comment_id": 1898669906,
      "user": "sydney-runkle",
      "created_at": "2024-12-27T18:51:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/11169#discussion_r1898669906"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11186,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2145,
      "side": "RIGHT",
      "diff_hunk": "@@ -2134,14 +2134,15 @@ def _get_wrapped_inner_schema(\n         annotation: Any,\n         pydantic_js_annotation_functions: list[GetJsonSchemaFunction],\n     ) -> CallbackGetCoreSchemaHandler:\n-        metadata_get_schema: GetCoreSchemaFunction = getattr(annotation, '__get_pydantic_core_schema__', None) or (\n-            lambda source, handler: handler(source)\n-        )\n+        annotation_get_schema: GetCoreSchemaFunction | None = getattr(annotation, '__get_pydantic_core_schema__', None)\n \n         def new_handler(source: Any) -> core_schema.CoreSchema:\n-            schema = metadata_get_schema(source, get_inner_schema)\n-            schema = self._apply_single_annotation(schema, annotation)\n-            schema = self._apply_single_annotation_json_schema(schema, annotation)\n+            if annotation_get_schema is not None:\n+                schema = annotation_get_schema(source, get_inner_schema)\n+            else:\n+                schema = get_inner_schema(source)\n+                schema = self._apply_single_annotation(schema, annotation)\n+                schema = self._apply_single_annotation_json_schema(schema, annotation)",
      "comment": "This way, we don't go through `_appy_single_annotation*` for annotations with a custom `__get_pydantic_core_schema__` as it is unnecessary. ",
      "comment_id": 1899153117,
      "user": "Viicos",
      "created_at": "2024-12-29T15:41:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/11186#discussion_r1899153117"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11168,
      "file_path": "pydantic/warnings.py",
      "line": 9,
      "side": "LEFT",
      "diff_hunk": "@@ -6,8 +6,11 @@\n \n __all__ = (\n     'PydanticDeprecatedSince20',\n-    'PydanticDeprecationWarning',",
      "comment": "We should probably still export this, might be used in user code, and we export in `__init__.py`?",
      "comment_id": 1898612995,
      "user": "sydney-runkle",
      "created_at": "2024-12-27T16:36:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/11168#discussion_r1898612995"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11168,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,7 +159,18 @@ def collect_model_fields(  # noqa: C901\n         if _typing_extra.is_classvar_annotation(ann_type):\n             class_vars.add(ann_name)\n             continue\n-        if _is_finalvar_with_default_val(ann_type, getattr(cls, ann_name, PydanticUndefined)):\n+\n+        assigned_value = getattr(cls, ann_name, PydanticUndefined)\n+\n+        if _is_finalvar_with_default_val(ann_type, assigned_value):\n+            warnings.warn(\n+                f'Annotation {ann_name!r} is marked as final and has a default value. Pydantic treats {ann_name!r} as a '\n+                f'class variable, but it will be considered as an normal field in V3. If you still want {ann_name!r} to be '\n+                'considered as a class variable, annotate it as: `ClassVar[<type>] = <default>.`',\n+                category=PydanticDeprecatedSince211,\n+                # Incorrect when `create_model` is used, but the chance that final with a default is used is low in that case:\n+                stacklevel=4,",
      "comment": "I'm fine with this for now, should be easy enough to change if we get an issue report.",
      "comment_id": 1898614047,
      "user": "sydney-runkle",
      "created_at": "2024-12-27T16:38:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/11168#discussion_r1898614047"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11168,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,7 +159,18 @@ def collect_model_fields(  # noqa: C901\n         if _typing_extra.is_classvar_annotation(ann_type):\n             class_vars.add(ann_name)\n             continue\n-        if _is_finalvar_with_default_val(ann_type, getattr(cls, ann_name, PydanticUndefined)):\n+\n+        assigned_value = getattr(cls, ann_name, PydanticUndefined)\n+\n+        if _is_finalvar_with_default_val(ann_type, assigned_value):\n+            warnings.warn(\n+                f'Annotation {ann_name!r} is marked as final and has a default value. Pydantic treats {ann_name!r} as a '\n+                f'class variable, but it will be considered as an normal field in V3. If you still want {ann_name!r} to be '\n+                'considered as a class variable, annotate it as: `ClassVar[<type>] = <default>.`',",
      "comment": "Can we link to the typing spec change that motivated this change?",
      "comment_id": 1898615323,
      "user": "sydney-runkle",
      "created_at": "2024-12-27T16:41:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/11168#discussion_r1898615323"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11168,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,7 +159,18 @@ def collect_model_fields(  # noqa: C901\n         if _typing_extra.is_classvar_annotation(ann_type):\n             class_vars.add(ann_name)\n             continue\n-        if _is_finalvar_with_default_val(ann_type, getattr(cls, ann_name, PydanticUndefined)):\n+\n+        assigned_value = getattr(cls, ann_name, PydanticUndefined)\n+\n+        if _is_finalvar_with_default_val(ann_type, assigned_value):\n+            warnings.warn(\n+                f'Annotation {ann_name!r} is marked as final and has a default value. Pydantic treats {ann_name!r} as a '\n+                f'class variable, but it will be considered as an normal field in V3. If you still want {ann_name!r} to be '\n+                'considered as a class variable, annotate it as: `ClassVar[<type>] = <default>.`',",
      "comment": "I added \"to be aligned with dataclasses\" as the typing spec change was actually just an update to follow what stdlib dataclasses where doing.",
      "comment_id": 1898627566,
      "user": "Viicos",
      "created_at": "2024-12-27T17:10:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/11168#discussion_r1898627566"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11109,
      "file_path": "pydantic/fields.py",
      "line": 407,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,34 +391,50 @@ class MyModel(pydantic.BaseModel):\n         Returns:\n             An instance of the field metadata.\n         \"\"\"\n-        final = False\n-        if _typing_extra.is_finalvar(annotation):\n-            final = True\n-            if annotation is not typing_extensions.Final:\n+        # 1. Check if the annotation is the `Final` type qualifier:\n+        final = _typing_extra.is_finalvar(annotation)\n+        if final:\n+            if _typing_extra.is_generic_alias(annotation):\n+                # The annotation is a parametrized `Final`, e.g. `Final[int]`.\n+                # In this case, `annotation` will be `int`:\n                 annotation = typing_extensions.get_args(annotation)[0]\n-\n-        if _typing_extra.is_annotated(annotation):\n-            first_arg, *extra_args = typing_extensions.get_args(annotation)\n-            if _typing_extra.is_finalvar(first_arg):\n-                final = True\n-            field_info_annotations = [a for a in extra_args if isinstance(a, FieldInfo)]\n-            field_info = FieldInfo.merge_field_infos(*field_info_annotations, annotation=first_arg)\n+            else:\n+                # The annotation is a bare `Final`. Use `Any` as a type annotation:\n+                return FieldInfo(annotation=Any, frozen=True)  # pyright: ignore[reportArgumentType] (PEP 747)\n+\n+        # 2. Check if the annotation is an `Annotated` form.\n+        #    In this case, `annotation` will be the annotated type:\n+        annotation, metadata = _unpack_annotated(annotation)",
      "comment": "This replaces:\r\n\r\n```python\r\nif _typing_extra.is_annotated(annotation):\r\n    first_arg, *extra_args = typing_extensions.get_args(annotation)\r\n```\r\n\r\nif `metadata == []`, it means `_typing_extra.is_annotated(annotation) == False`.",
      "comment_id": 1888501743,
      "user": "Viicos",
      "created_at": "2024-12-17T13:15:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/11109#discussion_r1888501743"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11109,
      "file_path": "pydantic/fields.py",
      "line": 210,
      "side": "LEFT",
      "diff_hunk": "@@ -207,7 +288,7 @@ def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:\n         \"\"\"\n         self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset}\n         kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore\n-        self.annotation, annotation_metadata = self._extract_metadata(kwargs.get('annotation'))",
      "comment": "`annotation` is only provided in kwargs from `from_annotation` and `from_annotated_attribute`, and in both cases the metadata from `Annotated` is already extracted, so it isn't necessary to do it a second time here.",
      "comment_id": 1888512603,
      "user": "Viicos",
      "created_at": "2024-12-17T13:23:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/11109#discussion_r1888512603"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11109,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1978,
      "side": "RIGHT",
      "diff_hunk": "@@ -1973,12 +1973,25 @@ def _computed_field_schema(\n     def _annotated_schema(self, annotated_type: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for an Annotated type, e.g. `Annotated[int, Field(...)]` or `Annotated[int, Gt(0)]`.\"\"\"\n         FieldInfo = import_cached_field_info()\n-\n-        source_type, *annotations = self._get_args_resolving_forward_refs(\n-            annotated_type,\n-            required=True,\n-        )\n-        schema = self._apply_annotations(source_type, annotations)\n+        # Ideally, we should delegate all this to `_typing_extra.unpack_annotated`, e.g.:\n+        # `typ, annotations = _typing_extra.unpack_annotated(annotated_type); schema = self.apply_annotations(...)`\n+        # if it was able to use a `NsResolver`. But because `unpack_annotated` is also used\n+        # when constructing `FieldInfo` instances (where we don't have access to a `NsResolver`),\n+        # the implementation of the function does *not* resolve forward annotations. This could\n+        # be solved by calling `unpack_annotated` directly inside `collect_model_fields`.\n+        # For now, we at least resolve the annotated type if it is a forward ref, but note that\n+        # unexpected results will happen if you have something like `Annotated[Alias, ...]` and\n+        # `Alias` is a PEP 695 type alias containing forward references.",
      "comment": "See `test_nested_annotated_with_type_aliases_and_forward_ref` showing an example of when it fails.\r\n\r\n",
      "comment_id": 1888903043,
      "user": "Viicos",
      "created_at": "2024-12-17T17:06:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/11109#discussion_r1888903043"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11109,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1978,
      "side": "RIGHT",
      "diff_hunk": "@@ -1973,12 +1973,25 @@ def _computed_field_schema(\n     def _annotated_schema(self, annotated_type: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for an Annotated type, e.g. `Annotated[int, Field(...)]` or `Annotated[int, Gt(0)]`.\"\"\"\n         FieldInfo = import_cached_field_info()\n-\n-        source_type, *annotations = self._get_args_resolving_forward_refs(\n-            annotated_type,\n-            required=True,\n-        )\n-        schema = self._apply_annotations(source_type, annotations)\n+        # Ideally, we should delegate all this to `_typing_extra.unpack_annotated`, e.g.:\n+        # `typ, annotations = _typing_extra.unpack_annotated(annotated_type); schema = self.apply_annotations(...)`\n+        # if it was able to use a `NsResolver`. But because `unpack_annotated` is also used\n+        # when constructing `FieldInfo` instances (where we don't have access to a `NsResolver`),\n+        # the implementation of the function does *not* resolve forward annotations. This could\n+        # be solved by calling `unpack_annotated` directly inside `collect_model_fields`.\n+        # For now, we at least resolve the annotated type if it is a forward ref, but note that\n+        # unexpected results will happen if you have something like `Annotated[Alias, ...]` and\n+        # `Alias` is a PEP 695 type alias containing forward references.",
      "comment": "Yeesh. This comment is helpful, as this logic is pretty specialized and complicated. Thanks for including.\r\n\r\nI honestly don't know if my mind is fully wrapped around this yet.",
      "comment_id": 1894505264,
      "user": "sydney-runkle",
      "created_at": "2024-12-20T23:46:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/11109#discussion_r1894505264"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11109,
      "file_path": "pydantic/fields.py",
      "line": 318,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,34 +311,50 @@ class MyModel(pydantic.BaseModel):\n         Returns:\n             An instance of the field metadata.\n         \"\"\"\n-        final = False\n-        if _typing_extra.is_finalvar(annotation):\n-            final = True\n-            if annotation is not typing_extensions.Final:\n+        # 1. Check if the annotation is the `Final` type qualifier:\n+        final = _typing_extra.is_finalvar(annotation)\n+        if final:\n+            if _typing_extra.is_generic_alias(annotation):\n+                # The annotation is a parametrized `Final`, e.g. `Final[int]`.",
      "comment": "Maybe prefix with 1.1, like you've done below for #3? And same for else block below",
      "comment_id": 1894506448,
      "user": "sydney-runkle",
      "created_at": "2024-12-20T23:50:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/11109#discussion_r1894506448"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11109,
      "file_path": "pydantic/fields.py",
      "line": 392,
      "side": "RIGHT",
      "diff_hunk": "@@ -367,16 +384,16 @@ class MyModel(pydantic.BaseModel):\n         if annotation is default:\n             raise PydanticUserError(\n                 'Error when building FieldInfo from annotated attribute. '\n-                \"Make sure you don't have any field name clashing with a type annotation \",\n+                \"Make sure you don't have any field name clashing with a type annotation.\",\n                 code='unevaluable-type-annotation',\n             )\n \n         final = _typing_extra.is_finalvar(annotation)\n-        if final and annotation is not typing_extensions.Final:\n+        if final and _typing_extra.is_generic_alias(annotation):",
      "comment": "Curious - why do you feel like it's better to use the generic alias check here, rather than just `is not typing_extensions.Final`? Maybe we could add another comment here explaining that it's a parametrized `Final`, just so that it's clear to future devs...",
      "comment_id": 1894506910,
      "user": "sydney-runkle",
      "created_at": "2024-12-20T23:51:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/11109#discussion_r1894506910"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11109,
      "file_path": "pydantic/fields.py",
      "line": 392,
      "side": "RIGHT",
      "diff_hunk": "@@ -367,16 +384,16 @@ class MyModel(pydantic.BaseModel):\n         if annotation is default:\n             raise PydanticUserError(\n                 'Error when building FieldInfo from annotated attribute. '\n-                \"Make sure you don't have any field name clashing with a type annotation \",\n+                \"Make sure you don't have any field name clashing with a type annotation.\",\n                 code='unevaluable-type-annotation',\n             )\n \n         final = _typing_extra.is_finalvar(annotation)\n-        if final and annotation is not typing_extensions.Final:\n+        if final and _typing_extra.is_generic_alias(annotation):",
      "comment": "At some point, `typing_extensions` might not reexport `typing.<member>` when an upstream cpython change is backported in `typing_extensions`. This means that `typing_extensions.Final is typing.Final` can be `False` in the future.\r\n\r\nSee https://typing-extensions.readthedocs.io/en/latest/#runtime-use-of-types.\r\n\r\n> Maybe we could add another comment here explaining that it's a parametrized `Final`, just so that it's clear to future devs...\r\n\r\nThe logic here is meant to be merged with the one from `from_annotation`, but leaving it for https://github.com/pydantic/pydantic/issues/11122.\r\n",
      "comment_id": 1895653056,
      "user": "Viicos",
      "created_at": "2024-12-23T11:39:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/11109#discussion_r1895653056"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10911,
      "file_path": "tests/typechecking/base_model.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,3 +28,6 @@ class Knight(BaseModel):\n \n \n k = Knight()  # type: ignore[call-arg]  # pyright: ignore[reportCallIssue]\n+\n+MyModel.model_fields.keys()\n+MyModel.model_computed_fields.keys()",
      "comment": "```suggestion\r\nassert_type(Knight.model_fields, dict[str, FieldInfo])\r\nassert_type(Knight.model_computed_fields, dict[str, ComputedFieldInfo])\r\nassert_type(k.model_fields, dict[str, FieldInfo])\r\nassert_type(k.model_computed_fields, dict[str, ComputedFieldInfo])\r\n```\r\n\r\nimporting `assert_type` from `typing_extensions`",
      "comment_id": 1852241283,
      "user": "Viicos",
      "created_at": "2024-11-21T14:29:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10911#discussion_r1852241283"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11108,
      "file_path": "pydantic/functional_validators.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,7 +26,8 @@\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class AfterValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators\n+    \"\"\"!!! abstract \"Usage Documentation\"\n+        [field **after** validators](../concepts/validators.md#field-after-validator)",
      "comment": "```suggestion\r\n        [field *after* validators](../concepts/validators.md#field-after-validator)\r\n```\r\n\r\nsame for the others",
      "comment_id": 1884529669,
      "user": "Viicos",
      "created_at": "2024-12-13T20:51:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/11108#discussion_r1884529669"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11108,
      "file_path": "pydantic/config.py",
      "line": 1008,
      "side": "RIGHT",
      "diff_hunk": "@@ -1004,7 +1004,8 @@ class Model(BaseModel):\n \n \n def with_config(config: ConfigDict) -> Callable[[_TypeT], _TypeT]:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/config/#configuration-with-dataclass-from-the-standard-library-or-typeddict\n+    \"\"\"!!! abstract \"Usage Documentation\"\n+        [Configuration with a `dataclass` or `TypedDict`](../concepts/config.md#configuration--with-dataclass-from-the-standard-library-or-typeddict)",
      "comment": "Seems like there is a warning for this one (check with `mkdocs serve`)",
      "comment_id": 1884530091,
      "user": "Viicos",
      "created_at": "2024-12-13T20:52:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/11108#discussion_r1884530091"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11108,
      "file_path": "pydantic/json_schema.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,5 +1,5 @@\n-\"\"\"\n-Usage docs: https://docs.pydantic.dev/2.5/concepts/json_schema/\n+\"\"\"!!! abstract \"Usage Documentation\"\n+    [Json Schema](../concepts/json_schema.md)",
      "comment": "```suggestion\r\n    [JSON Schema](../concepts/json_schema.md)\r\n```\r\n\r\n(and maybe update the linked heading name if this is also formatted like this)",
      "comment_id": 1884530515,
      "user": "Viicos",
      "created_at": "2024-12-13T20:52:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/11108#discussion_r1884530515"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11108,
      "file_path": "pydantic/functional_validators.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -86,7 +87,8 @@ def _from_decorator(cls, decorator: _decorators.Decorator[_decorators.FieldValid\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class BeforeValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators\n+    \"\"\"!!! abstract \"Usage Documentation\"\n+        [field **before** validator](../concepts/validators.md#field-before-validator)",
      "comment": "```suggestion\r\n        [field **before** validators](../concepts/validators.md#field-before-validator)\r\n```\r\n\r\nsame for the others",
      "comment_id": 1884533097,
      "user": "Viicos",
      "created_at": "2024-12-13T20:55:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/11108#discussion_r1884533097"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11108,
      "file_path": "pydantic/json_schema.py",
      "line": 2,
      "side": "LEFT",
      "diff_hunk": "@@ -1,5 +1,5 @@\n-\"\"\"\n-Usage docs: https://docs.pydantic.dev/2.5/concepts/json_schema/",
      "comment": "> Also, removes the burden of updating version numbers in docs links and ensures we're using markdown links instead of a mix of markdown ant http refs.\r\n\r\nIndeed!",
      "comment_id": 1890426023,
      "user": "Viicos",
      "created_at": "2024-12-18T15:26:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/11108#discussion_r1890426023"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11085,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 283,
      "side": "LEFT",
      "diff_hunk": "@@ -280,12 +280,37 @@ def handle_dict_schema(self, schema: core_schema.DictSchema, f: Walk) -> core_sc\n             schema['values_schema'] = self.walk(values_schema, f)\n         return schema\n \n-    def handle_function_schema(self, schema: AnyFunctionSchema, f: Walk) -> core_schema.CoreSchema:",
      "comment": "This method was in reality never used: there's no `'function'` core schema. Instead, a method for each type was created.",
      "comment_id": 1878865948,
      "user": "Viicos",
      "created_at": "2024-12-10T21:14:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/11085#discussion_r1878865948"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11085,
      "file_path": "tests/test_utils.py",
      "line": 640,
      "side": "LEFT",
      "diff_hunk": "@@ -637,29 +637,6 @@ def walk(s, recurse):\n     }\n \n \n-def test_handle_function_schema():",
      "comment": "This test was added for coverage purposes, because as mentioned the method couldn't be called in \"real\" code",
      "comment_id": 1878866955,
      "user": "Viicos",
      "created_at": "2024-12-10T21:15:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/11085#discussion_r1878866955"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11085,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 297,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,12 +280,37 @@ def handle_dict_schema(self, schema: core_schema.DictSchema, f: Walk) -> core_sc\n             schema['values_schema'] = self.walk(values_schema, f)\n         return schema\n \n-    def handle_function_schema(self, schema: AnyFunctionSchema, f: Walk) -> core_schema.CoreSchema:\n-        if not is_function_with_inner_schema(schema):\n-            return schema\n+    def handle_function_after_schema(\n+        self, schema: core_schema.AfterValidatorFunctionSchema, f: Walk\n+    ) -> core_schema.CoreSchema:\n         schema['schema'] = self.walk(schema['schema'], f)\n         return schema\n \n+    def handle_function_before_schema(\n+        self, schema: core_schema.BeforeValidatorFunctionSchema, f: Walk\n+    ) -> core_schema.CoreSchema:\n+        schema['schema'] = self.walk(schema['schema'], f)\n+        if 'json_schema_input_schema' in schema:\n+            schema['json_schema_input_schema'] = self.walk(schema['json_schema_input_schema'], f)\n+        return schema\n+\n+    # TODO duplicate schema types for serializers and validators, needs to be deduplicated:",
      "comment": "Great. Can you open an issue just so we can track?",
      "comment_id": 1879287225,
      "user": "sydney-runkle",
      "created_at": "2024-12-11T03:41:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/11085#discussion_r1879287225"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11085,
      "file_path": "pydantic/functional_validators.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -229,13 +223,6 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaH\n             serialization = None\n \n         input_schema = handler.generate_schema(self.json_schema_input_type)",
      "comment": "Note to self: although the default `json_schema_input_type` value is `Any`, we should also account for `PydanticUndefined` if explicitly set.",
      "comment_id": 1888443094,
      "user": "Viicos",
      "created_at": "2024-12-17T12:34:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/11085#discussion_r1888443094"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11114,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -85,11 +85,27 @@ def is_literal(tp: Any, /) -> bool:\n     return _is_typing_name(get_origin(tp), name='Literal')\n \n \n-# TODO remove and replace with `get_args` when we drop support for Python 3.8\n-# (see https://docs.python.org/3/whatsnew/3.9.html#id4).\n def literal_values(tp: Any, /) -> list[Any]:\n-    \"\"\"Return the values contained in the provided `Literal` special form.\"\"\"\n+    \"\"\"Return the values contained in the provided `Literal` special form.\n+\n+    If one of the literal values is a PEP 695 type alias, recursively parse\n+    the type alias' `__value__` to unpack literal values as well. This function\n+    *doesn't* check that the type alias is referencing a `Literal` special form,\n+    so unexpected values could be unpacked.\n+    \"\"\"\n+    # TODO When we drop support for Python 3.8, there's no need to check of `is_literal`\n+    # here, as Python unpacks nested `Literal` forms in 3.9+.\n+    # (see https://docs.python.org/3/whatsnew/3.9.html#id4).\n     if not is_literal(tp):\n+        # Note: we could also check for generic aliases with a type alias as an origin.\n+        # However, it is very unlikely that this happens as type variables can't appear in\n+        # `Literal` forms, so the only valid (but unnecessary) use case would be something like:\n+        # `type Test[T] = Literal['a']` (and then use `Test[int]`).",
      "comment": "Yes, if you do:\r\n\r\n```python\r\ntype Test[T] = Literal['whatever']\r\nMyLit = Literal[Test[int]]\r\n```\r\n\r\n`MyLit.__args__[0]` is a `GenericAlias` instance, and here we only check for `is_type_alias_type`. But as I mentioned in the comment it is very unlikely to encounter such use cases, as it is not necessary (the type variable is useless here as you can't do something like `type Test[T] = Literal[T]`).",
      "comment_id": 1887094562,
      "user": "Viicos",
      "created_at": "2024-12-16T16:06:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/11114#discussion_r1887094562"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11121,
      "file_path": "pydantic/mypy.py",
      "line": 765,
      "side": "RIGHT",
      "diff_hunk": "@@ -761,6 +761,10 @@ def collect_field_or_class_var_from_stmt(  # noqa C901\n                 )\n                 node.type = AnyType(TypeOfAny.from_error)\n \n+        if node.is_final and has_default:\n+            # TODO this path should be removed (see https://github.com/pydantic/pydantic/issues/11119)",
      "comment": "Can you add a note about when, or what is blocking this?",
      "comment_id": 1887068720,
      "user": "sydney-runkle",
      "created_at": "2024-12-16T15:52:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/11121#discussion_r1887068720"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11060,
      "file_path": "docs/plugins/main.py",
      "line": 192,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,7 +189,7 @@ def add_tabs(match: re.Match[str]) -> str:\n         else:\n             return '\\n\\n'.join(output)\n \n-    return re.sub(r'^(``` *py.*?)\\n(.+?)^```(\\s+(?:^\\d+\\. .+?\\n)*)', add_tabs, markdown, flags=re.M | re.S)\n+    return re.sub(r'^(``` *py.*?)\\n(.+?)^```(\\s+(?:^\\d+\\. .+\\n)*)', add_tabs, markdown, flags=re.M | re.S)",
      "comment": "The current regex did not work correctly with:\r\n\r\n``````markdown\r\n```python\r\nsome_code  # (1)!\r\n```\r\n\r\n1. Some annotation\r\n   spanning multiple lines\r\n``````\r\n\r\n\"Some annotation\" was parsed correctly, but \"spanning multiple lines\" was interpreted as normal text.\r\n\r\nThe regex also does not match nested code blocks, e.g.:\r\n\r\n``````markdown\r\n- some list element:\r\n  ```python\r\n  ...\r\n  ```\r\n``````\r\n\r\nBut it's too much of a pain and I don't want to lose any more time on this. As I mentioned in https://github.com/pydantic/pydantic/issues/10083, the regex approach is really not ideal but the mkdocs/markdown Python implementation design is quite limiting here. ",
      "comment_id": 1876429235,
      "user": "Viicos",
      "created_at": "2024-12-09T17:48:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/11060#discussion_r1876429235"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11060,
      "file_path": "pydantic/functional_validators.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,7 +26,7 @@\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class AfterValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#annotated-validators\n+    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators",
      "comment": "```suggestion\r\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-after-validator\r\n```",
      "comment_id": 1881227442,
      "user": "sydney-runkle",
      "created_at": "2024-12-12T01:18:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/11060#discussion_r1881227442"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11060,
      "file_path": "pydantic/functional_validators.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -86,7 +86,7 @@ def _from_decorator(cls, decorator: _decorators.Decorator[_decorators.FieldValid\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class BeforeValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#annotated-validators\n+    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators",
      "comment": "```suggestion\r\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-before-validator\r\n```",
      "comment_id": 1881227632,
      "user": "sydney-runkle",
      "created_at": "2024-12-12T01:18:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/11060#discussion_r1881227632"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11060,
      "file_path": "pydantic/functional_validators.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,7 +159,7 @@ def _from_decorator(cls, decorator: _decorators.Decorator[_decorators.FieldValid\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class PlainValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#annotated-validators\n+    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators",
      "comment": "```suggestion\r\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-plain-validator\r\n```",
      "comment_id": 1881227930,
      "user": "sydney-runkle",
      "created_at": "2024-12-12T01:19:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/11060#discussion_r1881227930"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11060,
      "file_path": "pydantic/functional_validators.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,7 +264,7 @@ def _from_decorator(cls, decorator: _decorators.Decorator[_decorators.FieldValid\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class WrapValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#annotated-validators\n+    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators",
      "comment": "```suggestion\r\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-wrap-validator\r\n```",
      "comment_id": 1881228068,
      "user": "sydney-runkle",
      "created_at": "2024-12-12T01:19:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/11060#discussion_r1881228068"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11060,
      "file_path": "pydantic/functional_validators.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,7 +26,7 @@\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class AfterValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#annotated-validators\n+    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators",
      "comment": "We have a [plugin](https://github.com/pydantic/pydantic/blob/main/docs/plugins/griffe_doclinks.py) that enforces linking between these sections, and it needs the anchor to be a heading.",
      "comment_id": 1881899565,
      "user": "Viicos",
      "created_at": "2024-12-12T11:35:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/11060#discussion_r1881899565"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11060,
      "file_path": "pydantic/functional_validators.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,7 +26,7 @@\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class AfterValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#annotated-validators\n+    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators",
      "comment": "Hmph. Unfortunate. How much effort would be required to support this?",
      "comment_id": 1882177030,
      "user": "sydney-runkle",
      "created_at": "2024-12-12T13:57:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/11060#discussion_r1882177030"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11060,
      "file_path": "pydantic/functional_validators.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,7 +26,7 @@\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class AfterValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#annotated-validators\n+    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators",
      "comment": "Well imo we should probably drop this plugin. It adds an admonition below the related heading to link API documentation, but we could do it manually. Sometimes it's also not necessary because we do something like:\r\n\r\n``````markdown\r\n## The validate_call decorator\r\n\r\n??? API docs\r\n    [`validate_call()`][pydantic.validate_call]\r\n\r\nThe [`validate_call()`][pydantic.validate_call] decorator ...\r\n// The link to validate_call is repeated here\r\n``````\r\n\r\nAnd not having the plugin manually adding the crosslink could give more flexibility, like in this case where we don't have a proper heading to attach to.",
      "comment_id": 1882221976,
      "user": "Viicos",
      "created_at": "2024-12-12T14:15:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/11060#discussion_r1882221976"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11060,
      "file_path": "pydantic/functional_validators.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,7 +26,7 @@\n \n @dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\n class AfterValidator:\n-    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#annotated-validators\n+    \"\"\"Usage docs: https://docs.pydantic.dev/2.10/concepts/validators/#field-validators",
      "comment": "Fair enough, we can leave as is then and drop the plugin in a separate PR?",
      "comment_id": 1882228245,
      "user": "sydney-runkle",
      "created_at": "2024-12-12T14:19:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/11060#discussion_r1882228245"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11093,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 126,
      "side": "LEFT",
      "diff_hunk": "@@ -123,7 +125,11 @@ def ns_for_function(obj: Callable[..., Any], parent_namespace: MappingNamespace\n     # passed as a separate argument. However, internally, `_eval_type` calls\n     # `ForwardRef._evaluate` which will merge type params with the localns,\n     # essentially mimicking what we do here.\n-    type_params: tuple[TypeVar, ...] = ()",
      "comment": "I somehow forgot to actually fetch the type params here :thinking: ",
      "comment_id": 1880710044,
      "user": "Viicos",
      "created_at": "2024-12-11T18:30:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/11093#discussion_r1880710044"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11093,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 126,
      "side": "LEFT",
      "diff_hunk": "@@ -123,7 +125,11 @@ def ns_for_function(obj: Callable[..., Any], parent_namespace: MappingNamespace\n     # passed as a separate argument. However, internally, `_eval_type` calls\n     # `ForwardRef._evaluate` which will merge type params with the localns,\n     # essentially mimicking what we do here.\n-    type_params: tuple[TypeVar, ...] = ()",
      "comment": "Turns out the test did not use forward annotations, so it was fixed as well.",
      "comment_id": 1881841823,
      "user": "Viicos",
      "created_at": "2024-12-12T10:53:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/11093#discussion_r1881841823"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11093,
      "file_path": "tests/test_validate_call.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +121,9 @@ def __call__(self, x: int) -> int:\n \n \n def test_invalid_signature() -> None:\n-    # In some versions, these functions may not have a valid signature\n-    for func in (max, min, breakpoint, sorted, compile, print, [].append, {}.popitem, int().bit_length):\n-        try:\n-            inspect.signature(func)\n-            assert validate_call(func).__name__ == func.__name__\n-            assert validate_call(func).__qualname__ == func.__qualname__\n-            assert validate_call(partial(func)).__name__ == f'partial({func.__name__})'\n-            assert validate_call(partial(func)).__qualname__ == f'partial({func.__qualname__})'\n-        except ValueError:\n-            with pytest.raises(PydanticUserError, match=(f\"Input function `{func}` doesn't have a valid signature\")):\n-                validate_call(func)\n+    # Builtins functions not supported:\n+    with pytest.raises(PydanticUserError, match=(f'Input built-in function `{breakpoint}` is not supported')):\n+        validate_call(breakpoint)",
      "comment": "There's no real value in parametrizing as they are all the same type (a builtin function). This would be equivalent to something like:\r\n\r\n```python\r\n@pytest.mark.parametrize('value', [1, 2, 3])\r\ndef test(value):\r\n    assert isinstance(value, int)\r\n```",
      "comment_id": 1883779337,
      "user": "Viicos",
      "created_at": "2024-12-13T11:15:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/11093#discussion_r1883779337"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 2768,
      "file_path": "pydantic/main.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,12 +184,17 @@ def __new__(mcs, name, bases, namespace, **kwargs):  # noqa C901\n         def is_untouched(v: Any) -> bool:\n             return isinstance(v, untouched_types) or v.__class__.__name__ == 'cython_function_or_method'\n \n+        def is_finalvar_with_default_val(type_: Type[Any], val: Any) -> bool:",
      "comment": "This can be moved into the module scope of `fields.py`.",
      "comment_id": 937667098,
      "user": "samuelcolvin",
      "created_at": "2022-08-04T11:24:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/2768#discussion_r937667098"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 2768,
      "file_path": "pydantic/main.py",
      "line": 357,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,6 +353,10 @@ def __setattr__(self, name, value):  # noqa: C901 (ignore complexity)\n             raise ValueError(f'\"{self.__class__.__name__}\" object has no field \"{name}\"')\n         elif not self.__config__.allow_mutation or self.__config__.frozen:\n             raise TypeError(f'\"{self.__class__.__name__}\" is immutable and does not support item assignment')\n+        elif name in self.__fields__ and self.__fields__[name].final:\n+            raise TypeError(",
      "comment": "https://github.com/samuelcolvin/pydantic-core/issues/219",
      "comment_id": 937669849,
      "user": "samuelcolvin",
      "created_at": "2022-08-04T11:27:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/2768#discussion_r937669849"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 2768,
      "file_path": "pydantic/typing.py",
      "line": 390,
      "side": "RIGHT",
      "diff_hunk": "@@ -386,10 +387,21 @@ def _check_classvar(v: Optional[Type[Any]]) -> bool:\n     return v.__class__ == ClassVar.__class__ and getattr(v, '_name', None) == 'ClassVar'\n \n \n+def _check_finalvar(v: Optional[Type[Any]]) -> bool:",
      "comment": "can you add a docstring explaining what this is doing.",
      "comment_id": 937670516,
      "user": "samuelcolvin",
      "created_at": "2022-08-04T11:28:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/2768#discussion_r937670516"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 2768,
      "file_path": "tests/test_main.py",
      "line": 2183,
      "side": "RIGHT",
      "diff_hunk": "@@ -2156,3 +2156,56 @@ class Model(BaseModel):\n         'properties': {'x': {'title': 'X', 'anyOf': [{'type': 'integer'}, {'type': 'string'}]}},\n         'required': ['x'],\n     }\n+\n+\n+@pytest.mark.parametrize(\n+    'ann',\n+    [Final, Final[int]],\n+    ids=['no-arg', 'with-arg'],\n+)\n+@pytest.mark.parametrize(\n+    'value',\n+    [None, Field(...)],\n+    ids=['none', 'field'],\n+)\n+def test_final_field_decl_withou_default_val(ann, value):\n+    class Model(BaseModel):\n+        a: ann\n+\n+        if value is not None:\n+            a = value\n+\n+    Model.update_forward_refs(ann=ann)\n+\n+    assert 'a' not in Model.__class_vars__\n+    assert 'a' in Model.__fields__\n+\n+    assert Model.__fields__['a'].final",
      "comment": "we we add a check somewhere else that `final` is normally false.",
      "comment_id": 937671813,
      "user": "samuelcolvin",
      "created_at": "2022-08-04T11:30:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/2768#discussion_r937671813"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11088,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1653,
      "side": "RIGHT",
      "diff_hunk": "@@ -1647,7 +1647,12 @@ def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         else:\n             if _typing_extra.is_self(type_param):\n                 type_param = self._resolve_self_type(type_param)\n-\n+            if _typing_extra.is_generic_alias(type_param):\n+                raise PydanticUserError(\n+                    'Subscripting `type[]` with an already parametrized type is not supported. '\n+                    f'Instead of using type[{type_param!r}], use type[{_repr.display_as_type(get_origin(type_param))}].',",
      "comment": "Because `type_param` is a generic alias, we can rely on its `__repr__` implementation, which uses `typing._type_repr` to do a pretty representation already.\r\n\r\nHowever, we still use our `_repr.display_as_type` (inspired by `typing._type_repr`) for the origin, which is _not_ a generic alias anymore but a proper class.\r\n\r\nThis should cover most use cases.",
      "comment_id": 1880199920,
      "user": "Viicos",
      "created_at": "2024-12-11T13:27:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/11088#discussion_r1880199920"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11088,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1653,
      "side": "RIGHT",
      "diff_hunk": "@@ -1647,7 +1647,12 @@ def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         else:\n             if _typing_extra.is_self(type_param):\n                 type_param = self._resolve_self_type(type_param)\n-\n+            if _typing_extra.is_generic_alias(type_param):\n+                raise PydanticUserError(\n+                    'Subscripting `type[]` with an already parametrized type is not supported. '\n+                    f'Instead of using type[{type_param!r}], use type[{_repr.display_as_type(get_origin(type_param))}].',",
      "comment": "This looks good. @dmontagu mentioned that we might want to support this eventually, so can we say \"not yet supported\", and link to the issue?",
      "comment_id": 1882239157,
      "user": "sydney-runkle",
      "created_at": "2024-12-12T14:25:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/11088#discussion_r1882239157"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 11088,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1653,
      "side": "RIGHT",
      "diff_hunk": "@@ -1647,7 +1647,12 @@ def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         else:\n             if _typing_extra.is_self(type_param):\n                 type_param = self._resolve_self_type(type_param)\n-\n+            if _typing_extra.is_generic_alias(type_param):\n+                raise PydanticUserError(\n+                    'Subscripting `type[]` with an already parametrized type is not supported. '\n+                    f'Instead of using type[{type_param!r}], use type[{_repr.display_as_type(get_origin(type_param))}].',",
      "comment": "Imo trying to support this is going to introduce lots of maintenance burden for the reason I mentioned in https://github.com/pydantic/pydantic/issues/11000#issuecomment-2527730758, and maybe not possible at all as mentioned in https://github.com/pydantic/pydantic/issues/10462#issuecomment-2367301169.",
      "comment_id": 1882244954,
      "user": "Viicos",
      "created_at": "2024-12-12T14:28:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/11088#discussion_r1882244954"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10493,
      "file_path": "tests/test_computed_fields.py",
      "line": 820,
      "side": "RIGHT",
      "diff_hunk": "@@ -815,3 +815,26 @@ def my_field_serializer(self, value: Any, info: FieldSerializationInfo) -> Any:\n             return f'{info.field_name} = {value}'\n \n     assert MyModel().model_dump() == {'my_field': 'my_field = foo', 'other_field': 'other_field = 42'}\n+\n+\n+def test__fields_on_instance_and_cls() -> None:",
      "comment": "```suggestion\r\ndef test_fields_on_instance_and_cls() -> None:\r\n```\r\n\r\nor maybe it is intentional",
      "comment_id": 1778651084,
      "user": "Viicos",
      "created_at": "2024-09-27T13:40:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10493#discussion_r1778651084"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10662,
      "file_path": "pydantic/networks.py",
      "line": 430,
      "side": "RIGHT",
      "diff_hunk": "@@ -228,130 +388,123 @@ class MyModel(BaseModel):\n             'postgresql+py-postgresql',\n             'postgresql+pygresql',\n         ],\n-    ),\n-]\n-\"\"\"A type that will accept any Postgres DSN.\n-\n-* User info required\n-* TLD not required\n-* Host required\n-* Supports multiple hosts\n-\n-If further validation is required, these properties can be used by validators to enforce specific behaviour:\n-\n-```py\n-from pydantic import (\n-    BaseModel,\n-    HttpUrl,\n-    PostgresDsn,\n-    ValidationError,\n-    field_validator,\n-)\n-\n-class MyModel(BaseModel):\n-    url: HttpUrl\n-\n-m = MyModel(url='http://www.example.com')\n-\n-# the repr() method for a url will display all properties of the url\n-print(repr(m.url))\n-#> Url('http://www.example.com/')\n-print(m.url.scheme)\n-#> http\n-print(m.url.host)\n-#> www.example.com\n-print(m.url.port)\n-#> 80\n-\n-class MyDatabaseModel(BaseModel):\n-    db: PostgresDsn\n-\n-    @field_validator('db')\n-    def check_db_name(cls, v):\n-        assert v.path and len(v.path) > 1, 'database must be provided'\n-        return v\n-\n-m = MyDatabaseModel(db='postgres://user:pass@localhost:5432/foobar')\n-print(m.db)\n-#> postgres://user:pass@localhost:5432/foobar\n-\n-try:\n-    MyDatabaseModel(db='postgres://user:pass@localhost:5432')\n-except ValidationError as e:\n-    print(e)\n-    '''\n-    1 validation error for MyDatabaseModel\n-    db\n-      Assertion failed, database must be provided\n-    assert (None)\n-     +  where None = MultiHostUrl('postgres://user:pass@localhost:5432').path [type=assertion_error, input_value='postgres://user:pass@localhost:5432', input_type=str]\n-    '''\n-```\n-\"\"\"\n+    )\n+\n+    @property\n+    def host(self) -> str:\n+        \"\"\"The required URL host.\"\"\"\n+        ...\n+\n \n-CockroachDsn = Annotated[\n-    Url,\n-    UrlConstraints(\n+class CockroachDsn(_BaseUrl):\n+    \"\"\"A type that will accept any Cockroach DSN.\n+\n+    * User info required\n+    * TLD not required\n+    * Host required\n+    \"\"\"\n+\n+    _constraints = UrlConstraints(\n         host_required=True,\n         allowed_schemes=[\n             'cockroachdb',\n             'cockroachdb+psycopg2',\n             'cockroachdb+asyncpg',\n         ],\n-    ),\n-]\n-\"\"\"A type that will accept any Cockroach DSN.\n+    )\n \n-* User info required\n-* TLD not required\n-* Host required\n-\"\"\"\n-AmqpDsn = Annotated[Url, UrlConstraints(allowed_schemes=['amqp', 'amqps'])]\n-\"\"\"A type that will accept any AMQP DSN.\n+    @property\n+    def host(self) -> str:\n+        \"\"\"The required URL host.\"\"\"\n+        ...\n \n-* User info required\n-* TLD not required\n-* Host required\n-\"\"\"\n-RedisDsn = Annotated[\n-    Url,\n-    UrlConstraints(allowed_schemes=['redis', 'rediss'], default_host='localhost', default_port=6379, default_path='/0'),\n-]\n-\"\"\"A type that will accept any Redis DSN.\n \n-* User info required\n-* TLD not required\n-* Host required (e.g., `rediss://:pass@localhost`)\n-\"\"\"\n-MongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=['mongodb', 'mongodb+srv'], default_port=27017)]\n-\"\"\"A type that will accept any MongoDB DSN.\n+class AmqpDsn(_BaseUrl):\n+    \"\"\"A type that will accept any AMQP DSN.\n \n-* User info not required\n-* Database name not required\n-* Port not required\n-* User info may be passed without user part (e.g., `mongodb://mongodb0.example.com:27017`).\n-\"\"\"\n-KafkaDsn = Annotated[Url, UrlConstraints(allowed_schemes=['kafka'], default_host='localhost', default_port=9092)]\n-\"\"\"A type that will accept any Kafka DSN.\n+    * User info required\n+    * TLD not required\n+    * Host not required\n+    \"\"\"\n \n-* User info required\n-* TLD not required\n-* Host required\n-\"\"\"\n-NatsDsn = Annotated[\n-    MultiHostUrl,\n-    UrlConstraints(allowed_schemes=['nats', 'tls', 'ws', 'wss'], default_host='localhost', default_port=4222),\n-]\n-\"\"\"A type that will accept any NATS DSN.\n+    _constraints = UrlConstraints(allowed_schemes=['amqp', 'amqps'])",
      "comment": "https://www.rabbitmq.com/docs/uri-spec\r\n\r\nThe `host` is \"required\" but can be zero in length... we previously didn't enforce `host_required` here, so leaving as is, but adding `not` to the docs.",
      "comment_id": 1806997466,
      "user": "sydney-runkle",
      "created_at": "2024-10-18T20:40:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10662#discussion_r1806997466"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10662,
      "file_path": "tests/test_networks.py",
      "line": 110,
      "side": "LEFT",
      "diff_hunk": "@@ -107,7 +107,6 @@\n         'http://example.org/path#fragment',\n         'http://example.org/path?query#',\n         'http://example.org/path?query#fragment',\n-        'file://localhost/foo/bar',",
      "comment": "I don't think this is a valid `AnyUrl` because `FileUrl`s don't require a host, but `AnyUrl`s do.",
      "comment_id": 1807001852,
      "user": "sydney-runkle",
      "created_at": "2024-10-18T20:46:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10662#discussion_r1807001852"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10662,
      "file_path": "pydantic/networks.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -86,136 +88,294 @@ def __hash__(self) -> int:\n             )\n         )\n \n+    @property\n+    def set_constraints(self) -> dict[str, Any]:\n+        \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n+        return {k: v for k, v in self.__dict__.items() if v is not None}",
      "comment": "```suggestion\r\n        return {field.name: getattr(self, field.name) for field in fields(self)}\r\n```\r\n\r\nusing `dataclass.fields`",
      "comment_id": 1812674722,
      "user": "Viicos",
      "created_at": "2024-10-23T12:43:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/10662#discussion_r1812674722"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10662,
      "file_path": "pydantic/networks.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -86,136 +88,294 @@ def __hash__(self) -> int:\n             )\n         )\n \n+    @property\n+    def set_constraints(self) -> dict[str, Any]:",
      "comment": "```suggestion\r\n    def defined_constraints(self) -> dict[str, Any]:\r\n```\r\n\r\nmaybe? set_constraints can be confusing at first, feels like this is representing an action of _setting_ something",
      "comment_id": 1812676526,
      "user": "Viicos",
      "created_at": "2024-10-23T12:44:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/10662#discussion_r1812676526"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10662,
      "file_path": "pydantic/networks.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -86,136 +88,294 @@ def __hash__(self) -> int:\n             )\n         )\n \n+    @property\n+    def set_constraints(self) -> dict[str, Any]:\n+        \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n+        return {k: v for k, v in self.__dict__.items() if v is not None}\n \n-AnyUrl = Url\n-\"\"\"Base type for all URLs.\n \n-* Any scheme allowed\n-* Top-level domain (TLD) not required\n-* Host required\n+# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n+# the complexity enough that it's not worth saving a few lines?\n \n-Assuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\n-the types export the following properties:\n \n-- `scheme`: the URL scheme (`http`), always set.\n-- `host`: the URL host (`example.com`), always set.\n-- `username`: optional username if included (`samuel`).\n-- `password`: optional password if included (`pass`).\n-- `port`: optional port (`8000`).\n-- `path`: optional path (`/the/path/`).\n-- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`).\n-- `fragment`: optional fragment (`fragment=is;this=bit`).\n-\"\"\"\n-AnyHttpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['http', 'https'])]\n-\"\"\"A type that will accept any http or https URL.\n+class _BaseUrl(Url):\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n \n-* TLD not required\n-* Host required\n-\"\"\"\n-HttpUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['http', 'https'])]\n-\"\"\"A type that will accept any http or https URL.\n-\n-* TLD not required\n-* Host required\n-* Max length 2083\n-\n-```py\n-from pydantic import BaseModel, HttpUrl, ValidationError\n-\n-class MyModel(BaseModel):\n-    url: HttpUrl\n-\n-m = MyModel(url='http://www.example.com')  # (1)!\n-print(m.url)\n-#> http://www.example.com/\n-\n-try:\n-    MyModel(url='ftp://invalid.url')\n-except ValidationError as e:\n-    print(e)\n-    '''\n-    1 validation error for MyModel\n-    url\n-      URL scheme should be 'http' or 'https' [type=url_scheme, input_value='ftp://invalid.url', input_type=str]\n-    '''\n-\n-try:\n-    MyModel(url='not a url')\n-except ValidationError as e:\n-    print(e)\n-    '''\n-    1 validation error for MyModel\n-    url\n-      Input should be a valid URL, relative URL without a base [type=url_parsing, input_value='not a url', input_type=str]\n-    '''\n-```\n-\n-1. Note: mypy would prefer `m = MyModel(url=HttpUrl('http://www.example.com'))`, but Pydantic will convert the string to an HttpUrl instance anyway.\n-\n-\"International domains\" (e.g. a URL where the host or TLD includes non-ascii characters) will be encoded via\n-[punycode](https://en.wikipedia.org/wiki/Punycode) (see\n-[this article](https://www.xudongz.com/blog/2017/idn-phishing/) for a good description of why this is important):\n-\n-```py\n-from pydantic import BaseModel, HttpUrl\n-\n-class MyModel(BaseModel):\n-    url: HttpUrl\n-\n-m1 = MyModel(url='http://puny\u00a3code.com')\n-print(m1.url)\n-#> http://xn--punycode-eja.com/\n-m2 = MyModel(url='https://www.\u0430\u0440\u0440\u04cf\u0435.com/')\n-print(m2.url)\n-#> https://www.xn--80ak6aa92e.com/\n-m3 = MyModel(url='https://www.example.\u73e0\u5b9d/')\n-print(m3.url)\n-#> https://www.example.xn--pbt977c/\n-```\n-\n-\n-!!! warning \"Underscores in Hostnames\"\n-    In Pydantic, underscores are allowed in all parts of a domain except the TLD.\n-    Technically this might be wrong - in theory the hostname cannot have underscores, but subdomains can.\n-\n-    To explain this; consider the following two cases:\n-\n-    - `exam_ple.co.uk`: the hostname is `exam_ple`, which should not be allowed since it contains an underscore.\n-    - `foo_bar.example.com` the hostname is `example`, which should be allowed since the underscore is in the subdomain.\n-\n-    Without having an exhaustive list of TLDs, it would be impossible to differentiate between these two. Therefore\n-    underscores are allowed, but you can always do further validation in a validator if desired.\n-\n-    Also, Chrome, Firefox, and Safari all currently accept `http://exam_ple.com` as a URL, so we're in good\n-    (or at least big) company.\n-\"\"\"\n-AnyWebsocketUrl = Annotated[Url, UrlConstraints(allowed_schemes=['ws', 'wss'])]\n-\"\"\"A type that will accept any ws or wss URL.\n+    @classmethod\n+    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        if cls is source:",
      "comment": "This means that `_BaseUrl` would be used as an annotation?\r\n\r\n```python\r\nclass Model(BaseModel):\r\n    a: _BaseUrl\r\n```\r\n\r\nPerhaps you meant using `issubclass`?",
      "comment_id": 1812688635,
      "user": "Viicos",
      "created_at": "2024-10-23T12:49:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/10662#discussion_r1812688635"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10662,
      "file_path": "pydantic/networks.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -86,136 +88,294 @@ def __hash__(self) -> int:\n             )\n         )\n \n+    @property\n+    def set_constraints(self) -> dict[str, Any]:\n+        \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n+        return {k: v for k, v in self.__dict__.items() if v is not None}\n \n-AnyUrl = Url\n-\"\"\"Base type for all URLs.\n \n-* Any scheme allowed\n-* Top-level domain (TLD) not required\n-* Host required\n+# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n+# the complexity enough that it's not worth saving a few lines?\n \n-Assuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\n-the types export the following properties:\n \n-- `scheme`: the URL scheme (`http`), always set.\n-- `host`: the URL host (`example.com`), always set.\n-- `username`: optional username if included (`samuel`).\n-- `password`: optional password if included (`pass`).\n-- `port`: optional port (`8000`).\n-- `path`: optional path (`/the/path/`).\n-- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`).\n-- `fragment`: optional fragment (`fragment=is;this=bit`).\n-\"\"\"\n-AnyHttpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['http', 'https'])]\n-\"\"\"A type that will accept any http or https URL.\n+class _BaseUrl(Url):\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n \n-* TLD not required\n-* Host required\n-\"\"\"\n-HttpUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['http', 'https'])]\n-\"\"\"A type that will accept any http or https URL.\n-\n-* TLD not required\n-* Host required\n-* Max length 2083\n-\n-```py\n-from pydantic import BaseModel, HttpUrl, ValidationError\n-\n-class MyModel(BaseModel):\n-    url: HttpUrl\n-\n-m = MyModel(url='http://www.example.com')  # (1)!\n-print(m.url)\n-#> http://www.example.com/\n-\n-try:\n-    MyModel(url='ftp://invalid.url')\n-except ValidationError as e:\n-    print(e)\n-    '''\n-    1 validation error for MyModel\n-    url\n-      URL scheme should be 'http' or 'https' [type=url_scheme, input_value='ftp://invalid.url', input_type=str]\n-    '''\n-\n-try:\n-    MyModel(url='not a url')\n-except ValidationError as e:\n-    print(e)\n-    '''\n-    1 validation error for MyModel\n-    url\n-      Input should be a valid URL, relative URL without a base [type=url_parsing, input_value='not a url', input_type=str]\n-    '''\n-```\n-\n-1. Note: mypy would prefer `m = MyModel(url=HttpUrl('http://www.example.com'))`, but Pydantic will convert the string to an HttpUrl instance anyway.\n-\n-\"International domains\" (e.g. a URL where the host or TLD includes non-ascii characters) will be encoded via\n-[punycode](https://en.wikipedia.org/wiki/Punycode) (see\n-[this article](https://www.xudongz.com/blog/2017/idn-phishing/) for a good description of why this is important):\n-\n-```py\n-from pydantic import BaseModel, HttpUrl\n-\n-class MyModel(BaseModel):\n-    url: HttpUrl\n-\n-m1 = MyModel(url='http://puny\u00a3code.com')\n-print(m1.url)\n-#> http://xn--punycode-eja.com/\n-m2 = MyModel(url='https://www.\u0430\u0440\u0440\u04cf\u0435.com/')\n-print(m2.url)\n-#> https://www.xn--80ak6aa92e.com/\n-m3 = MyModel(url='https://www.example.\u73e0\u5b9d/')\n-print(m3.url)\n-#> https://www.example.xn--pbt977c/\n-```\n-\n-\n-!!! warning \"Underscores in Hostnames\"\n-    In Pydantic, underscores are allowed in all parts of a domain except the TLD.\n-    Technically this might be wrong - in theory the hostname cannot have underscores, but subdomains can.\n-\n-    To explain this; consider the following two cases:\n-\n-    - `exam_ple.co.uk`: the hostname is `exam_ple`, which should not be allowed since it contains an underscore.\n-    - `foo_bar.example.com` the hostname is `example`, which should be allowed since the underscore is in the subdomain.\n-\n-    Without having an exhaustive list of TLDs, it would be impossible to differentiate between these two. Therefore\n-    underscores are allowed, but you can always do further validation in a validator if desired.\n-\n-    Also, Chrome, Firefox, and Safari all currently accept `http://exam_ple.com` as a URL, so we're in good\n-    (or at least big) company.\n-\"\"\"\n-AnyWebsocketUrl = Annotated[Url, UrlConstraints(allowed_schemes=['ws', 'wss'])]\n-\"\"\"A type that will accept any ws or wss URL.\n+    @classmethod\n+    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        if cls is source:\n+            return core_schema.url_schema(**cls._constraints.set_constraints)\n+        else:\n+            schema = handler(source)\n+            # TODO: this logic is used in types.py as well in the _check_annotated_type function, should we move that to somewhere more central?\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'{cls.__name__}' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in cls._constraints.set_constraints.items():\n+                schema[constraint_key] = constraint_value\n+            return schema\n \n-* TLD not required\n-* Host required\n-\"\"\"\n-WebsocketUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['ws', 'wss'])]\n-\"\"\"A type that will accept any ws or wss URL.\n \n-* TLD not required\n-* Host required\n-* Max length 2083\n-\"\"\"\n-FileUrl = Annotated[Url, UrlConstraints(allowed_schemes=['file'])]\n-\"\"\"A type that will accept any file URL.\n+class _BaseMultiHostUrl(MultiHostUrl):\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n \n-* Host not required\n-\"\"\"\n-FtpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['ftp'])]\n-\"\"\"A type that will accept ftp URL.\n+    @classmethod\n+    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        if cls is source:\n+            return core_schema.multi_host_url_schema(**cls._constraints.set_constraints)\n+        else:\n+            schema = handler(source)\n+            # TODO: this logic is used in types.py as well in the _check_annotated_type function, should we move that to somewhere more central?\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'{cls.__name__}' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in cls._constraints.set_constraints.items():\n+                schema[constraint_key] = constraint_value\n+            return schema\n+\n+\n+class AnyUrl(_BaseUrl):\n+    \"\"\"Base type for all URLs.\n+\n+    * Any scheme allowed\n+    * Top-level domain (TLD) not required\n+    * Host required\n+\n+    Assuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\n+    the types export the following properties:\n+\n+    - `scheme`: the URL scheme (`http`), always set.\n+    - `host`: the URL host (`example.com`), always set.\n+    - `username`: optional username if included (`samuel`).\n+    - `password`: optional password if included (`pass`).\n+    - `port`: optional port (`8000`).\n+    - `path`: optional path (`/the/path/`).\n+    - `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`).\n+    - `fragment`: optional fragment (`fragment=is;this=bit`).\n+    \"\"\"\n \n-* TLD not required\n-* Host required\n-\"\"\"\n-PostgresDsn = Annotated[\n-    MultiHostUrl,\n-    UrlConstraints(\n+    _constraints = UrlConstraints(host_required=True)",
      "comment": "Probably this fixes https://github.com/pydantic/pydantic/issues/10684, maybe a test can confirm",
      "comment_id": 1812690280,
      "user": "Viicos",
      "created_at": "2024-10-23T12:50:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10662#discussion_r1812690280"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10662,
      "file_path": "pydantic/networks.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -86,136 +88,294 @@ def __hash__(self) -> int:\n             )\n         )\n \n+    @property\n+    def set_constraints(self) -> dict[str, Any]:\n+        \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n+        return {k: v for k, v in self.__dict__.items() if v is not None}\n \n-AnyUrl = Url\n-\"\"\"Base type for all URLs.\n \n-* Any scheme allowed\n-* Top-level domain (TLD) not required\n-* Host required\n+# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n+# the complexity enough that it's not worth saving a few lines?\n \n-Assuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\n-the types export the following properties:\n \n-- `scheme`: the URL scheme (`http`), always set.\n-- `host`: the URL host (`example.com`), always set.\n-- `username`: optional username if included (`samuel`).\n-- `password`: optional password if included (`pass`).\n-- `port`: optional port (`8000`).\n-- `path`: optional path (`/the/path/`).\n-- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`).\n-- `fragment`: optional fragment (`fragment=is;this=bit`).\n-\"\"\"\n-AnyHttpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['http', 'https'])]\n-\"\"\"A type that will accept any http or https URL.\n+class _BaseUrl(Url):\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n \n-* TLD not required\n-* Host required\n-\"\"\"\n-HttpUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['http', 'https'])]\n-\"\"\"A type that will accept any http or https URL.\n-\n-* TLD not required\n-* Host required\n-* Max length 2083\n-\n-```py\n-from pydantic import BaseModel, HttpUrl, ValidationError\n-\n-class MyModel(BaseModel):\n-    url: HttpUrl\n-\n-m = MyModel(url='http://www.example.com')  # (1)!\n-print(m.url)\n-#> http://www.example.com/\n-\n-try:\n-    MyModel(url='ftp://invalid.url')\n-except ValidationError as e:\n-    print(e)\n-    '''\n-    1 validation error for MyModel\n-    url\n-      URL scheme should be 'http' or 'https' [type=url_scheme, input_value='ftp://invalid.url', input_type=str]\n-    '''\n-\n-try:\n-    MyModel(url='not a url')\n-except ValidationError as e:\n-    print(e)\n-    '''\n-    1 validation error for MyModel\n-    url\n-      Input should be a valid URL, relative URL without a base [type=url_parsing, input_value='not a url', input_type=str]\n-    '''\n-```\n-\n-1. Note: mypy would prefer `m = MyModel(url=HttpUrl('http://www.example.com'))`, but Pydantic will convert the string to an HttpUrl instance anyway.\n-\n-\"International domains\" (e.g. a URL where the host or TLD includes non-ascii characters) will be encoded via\n-[punycode](https://en.wikipedia.org/wiki/Punycode) (see\n-[this article](https://www.xudongz.com/blog/2017/idn-phishing/) for a good description of why this is important):\n-\n-```py\n-from pydantic import BaseModel, HttpUrl\n-\n-class MyModel(BaseModel):\n-    url: HttpUrl\n-\n-m1 = MyModel(url='http://puny\u00a3code.com')\n-print(m1.url)\n-#> http://xn--punycode-eja.com/\n-m2 = MyModel(url='https://www.\u0430\u0440\u0440\u04cf\u0435.com/')\n-print(m2.url)\n-#> https://www.xn--80ak6aa92e.com/\n-m3 = MyModel(url='https://www.example.\u73e0\u5b9d/')\n-print(m3.url)\n-#> https://www.example.xn--pbt977c/\n-```\n-\n-\n-!!! warning \"Underscores in Hostnames\"\n-    In Pydantic, underscores are allowed in all parts of a domain except the TLD.\n-    Technically this might be wrong - in theory the hostname cannot have underscores, but subdomains can.\n-\n-    To explain this; consider the following two cases:\n-\n-    - `exam_ple.co.uk`: the hostname is `exam_ple`, which should not be allowed since it contains an underscore.\n-    - `foo_bar.example.com` the hostname is `example`, which should be allowed since the underscore is in the subdomain.\n-\n-    Without having an exhaustive list of TLDs, it would be impossible to differentiate between these two. Therefore\n-    underscores are allowed, but you can always do further validation in a validator if desired.\n-\n-    Also, Chrome, Firefox, and Safari all currently accept `http://exam_ple.com` as a URL, so we're in good\n-    (or at least big) company.\n-\"\"\"\n-AnyWebsocketUrl = Annotated[Url, UrlConstraints(allowed_schemes=['ws', 'wss'])]\n-\"\"\"A type that will accept any ws or wss URL.\n+    @classmethod\n+    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        if cls is source:\n+            return core_schema.url_schema(**cls._constraints.set_constraints)\n+        else:\n+            schema = handler(source)\n+            # TODO: this logic is used in types.py as well in the _check_annotated_type function, should we move that to somewhere more central?\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'{cls.__name__}' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in cls._constraints.set_constraints.items():\n+                schema[constraint_key] = constraint_value\n+            return schema\n \n-* TLD not required\n-* Host required\n-\"\"\"\n-WebsocketUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['ws', 'wss'])]\n-\"\"\"A type that will accept any ws or wss URL.\n \n-* TLD not required\n-* Host required\n-* Max length 2083\n-\"\"\"\n-FileUrl = Annotated[Url, UrlConstraints(allowed_schemes=['file'])]\n-\"\"\"A type that will accept any file URL.\n+class _BaseMultiHostUrl(MultiHostUrl):\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n \n-* Host not required\n-\"\"\"\n-FtpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['ftp'])]\n-\"\"\"A type that will accept ftp URL.\n+    @classmethod\n+    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        if cls is source:\n+            return core_schema.multi_host_url_schema(**cls._constraints.set_constraints)\n+        else:\n+            schema = handler(source)\n+            # TODO: this logic is used in types.py as well in the _check_annotated_type function, should we move that to somewhere more central?\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'{cls.__name__}' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in cls._constraints.set_constraints.items():\n+                schema[constraint_key] = constraint_value\n+            return schema\n+\n+\n+class AnyUrl(_BaseUrl):\n+    \"\"\"Base type for all URLs.\n+\n+    * Any scheme allowed\n+    * Top-level domain (TLD) not required\n+    * Host required\n+\n+    Assuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\n+    the types export the following properties:\n+\n+    - `scheme`: the URL scheme (`http`), always set.\n+    - `host`: the URL host (`example.com`), always set.\n+    - `username`: optional username if included (`samuel`).\n+    - `password`: optional password if included (`pass`).\n+    - `port`: optional port (`8000`).\n+    - `path`: optional path (`/the/path/`).\n+    - `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`).\n+    - `fragment`: optional fragment (`fragment=is;this=bit`).\n+    \"\"\"\n \n-* TLD not required\n-* Host required\n-\"\"\"\n-PostgresDsn = Annotated[\n-    MultiHostUrl,\n-    UrlConstraints(\n+    _constraints = UrlConstraints(host_required=True)",
      "comment": "You're correct, I think the removal of that `file` test from the parametrized `AnyUrl` test shows this fix.",
      "comment_id": 1812925469,
      "user": "sydney-runkle",
      "created_at": "2024-10-23T14:37:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/10662#discussion_r1812925469"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,93 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, cast\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n+\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n+\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n+    on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n+    issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n     pydantic_js_functions: list[GetJsonSchemaFunction]\n     pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,",
      "comment": "This is probably overkill (these params specifically). Happy to remove. The others make more sense given that they need special update logic.",
      "comment_id": 1813075494,
      "user": "sydney-runkle",
      "created_at": "2024-10-23T15:46:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813075494"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 291,
      "side": "LEFT",
      "diff_hunk": "@@ -247,41 +245,17 @@ def apply_each_item_validators(\n     return schema\n \n \n-def modify_model_json_schema(\n-    schema_or_field: CoreSchemaOrField,\n-    handler: GetJsonSchemaHandler,\n-    *,\n-    cls: type[Any],\n-    title: str | None = None,\n-) -> JsonSchemaValue:\n-    \"\"\"Add title and description for model-like classes' JSON schema.\n-\n-    Args:\n-        schema_or_field: The schema data to generate a JSON schema from.\n-        handler: The `GetCoreSchemaHandler` instance.\n-        cls: The model-like class.\n-        title: The title to set for the model's schema, defaults to the model's name\n-\n-    Returns:\n-        JsonSchemaValue: The updated JSON schema.\n-    \"\"\"\n-    from ..root_model import RootModel\n-\n-    BaseModel = import_cached_base_model()\n-\n-    json_schema = handler(schema_or_field)\n-    original_schema = handler.resolve_ref_schema(json_schema)\n-    if title is not None:\n-        original_schema['title'] = title\n-    elif 'title' not in original_schema:\n-        original_schema['title'] = cls.__name__\n-    # BaseModel and dataclasses; don't use cls.__doc__ as it will contain the verbose class signature by default\n-    docstring = None if cls is BaseModel or dataclasses.is_dataclass(cls) else cls.__doc__\n-    if docstring and 'description' not in original_schema:\n-        original_schema['description'] = inspect.cleandoc(docstring)\n-    elif issubclass(cls, RootModel) and cls.__pydantic_fields__['root'].description:\n-        original_schema['description'] = cls.__pydantic_fields__['root'].description\n-    return json_schema",
      "comment": "See ya! Don't like having this sort of thing here - belongs in `json_schema.py`.",
      "comment_id": 1813077675,
      "user": "sydney-runkle",
      "created_at": "2024-10-23T15:48:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813077675"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 769,
      "side": "LEFT",
      "diff_hunk": "@@ -728,34 +696,13 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                         post_init=getattr(cls, '__pydantic_post_init__', None),\n                         config=core_config,\n                         ref=model_ref,\n-                        metadata=metadata,\n                     )\n \n                 schema = self._apply_model_serializers(model_schema, decorators.model_serializers.values())\n                 schema = apply_model_validators(schema, model_validators, 'outer')\n                 self.defs.definitions[model_ref] = schema\n                 return core_schema.definition_reference_schema(model_ref)\n \n-    @staticmethod\n-    def _get_model_title_from_config(\n-        model: type[BaseModel | StandardDataclass], config_wrapper: ConfigWrapper | None = None\n-    ) -> str | None:\n-        \"\"\"Get the title of a model if `model_title_generator` or `title` are set in the config, else return None\"\"\"\n-        if config_wrapper is None:\n-            return None\n-\n-        if config_wrapper.title:\n-            return config_wrapper.title\n-\n-        model_title_generator = config_wrapper.model_title_generator\n-        if model_title_generator:\n-            title = model_title_generator(model)\n-            if not isinstance(title, str):\n-                raise TypeError(f'model_title_generator {model_title_generator} must return str, not {title.__class__}')\n-            return title\n-\n-        return None\n-",
      "comment": "See ya! Don't like having this sort of thing here - belongs in `json_schema.py`.",
      "comment_id": 1813077921,
      "user": "sydney-runkle",
      "created_at": "2024-10-23T15:48:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813077921"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 114,
      "side": "LEFT",
      "diff_hunk": "@@ -96,22 +96,6 @@\n         CONSTRAINTS_TO_ALLOWED_SCHEMAS[c].update(schemas)\n \n \n-def add_js_update_schema(s: cs.CoreSchema, f: Callable[[], dict[str, Any]]) -> None:\n-    def update_js_schema(s: cs.CoreSchema, handler: GetJsonSchemaHandler) -> dict[str, Any]:\n-        js_schema = handler(s)\n-        js_schema.update(f())\n-        return js_schema\n-\n-    if 'metadata' in s:\n-        metadata = s['metadata']\n-        if 'pydantic_js_functions' in s:\n-            metadata['pydantic_js_functions'].append(update_js_schema)\n-        else:\n-            metadata['pydantic_js_functions'] = [update_js_schema]\n-    else:\n-        s['metadata'] = {'pydantic_js_functions': [update_js_schema]}\n-\n-",
      "comment": "Again... shouldn't be anywhere but `json_schema.py`, but this shouldn't require a functional wrapper here.",
      "comment_id": 1813080087,
      "user": "sydney-runkle",
      "created_at": "2024-10-23T15:49:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813080087"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/json_schema.py",
      "line": 115,
      "side": "LEFT",
      "diff_hunk": "@@ -93,26 +93,6 @@\n _MODE_TITLE_MAPPING: dict[JsonSchemaMode, str] = {'validation': 'Input', 'serialization': 'Output'}\n \n \n-@deprecated(\n-    '`update_json_schema` is deprecated, use a simple `my_dict.update(update_dict)` call instead.',\n-    category=None,\n-)\n-def update_json_schema(schema: JsonSchemaValue, updates: dict[str, Any]) -> JsonSchemaValue:\n-    \"\"\"Update a JSON schema in-place by providing a dictionary of updates.\n-\n-    This function sets the provided key-value pairs in the schema and returns the updated schema.\n-\n-    Args:\n-        schema: The JSON schema to update.\n-        updates: A dictionary of key-value pairs to set in the schema.\n-\n-    Returns:\n-        The updated JSON schema.\n-    \"\"\"\n-    schema.update(updates)\n-    return schema\n-\n-",
      "comment": "This has been deprecated for a while, and was never public, so we can remove.",
      "comment_id": 1813080898,
      "user": "sydney-runkle",
      "created_at": "2024-10-23T15:50:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813080898"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/json_schema.py",
      "line": 1494,
      "side": "RIGHT",
      "diff_hunk": "@@ -1463,13 +1473,56 @@ def model_schema(self, schema: core_schema.ModelSchema) -> JsonSchemaValue:\n         # because it could lead to inconsistent refs handling, etc.\n         cls = cast('type[BaseModel]', schema['cls'])\n         config = cls.model_config\n-        title = config.get('title')\n \n         with self._config_wrapper_stack.push(config):\n             json_schema = self.generate_inner(schema['schema'])\n \n+        self._update_class_schema(json_schema, cls, config)\n+\n+        return json_schema\n+\n+    def _update_class_schema(self, json_schema: JsonSchemaValue, cls: type[Any], config: ConfigDict) -> None:\n+        \"\"\"Update json_schema with the following, extracted from `config` and `cls`:\n+\n+        * title\n+        * description\n+        * additional properties\n+        * json_schema_extra\n+        * deprecated\n+\n+        Done in place, hence there's no return value as the original json_schema is mutated.\n+        No ref resolving is involved here, as that's not appropriate for simple updates.",
      "comment": "This now has lots of the logic that was mistakenly in `_generate_schema.py`",
      "comment_id": 1813082148,
      "user": "sydney-runkle",
      "created_at": "2024-10-23T15:51:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813082148"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/json_schema.py",
      "line": 1571,
      "side": "RIGHT",
      "diff_hunk": "@@ -1536,14 +1561,14 @@ def resolve_schema_to_update(self, json_schema: JsonSchemaValue) -> JsonSchemaVa\n         Returns:\n             The resolved schema.\n         \"\"\"\n-        if '$ref' in json_schema:\n-            schema_to_update = self.get_schema_from_definitions(JsonRef(json_schema['$ref']))\n-            if schema_to_update is None:\n-                raise RuntimeError(f'Cannot update undefined schema for $ref={json_schema[\"$ref\"]}')\n-            return self.resolve_schema_to_update(schema_to_update)\n-        else:\n-            schema_to_update = json_schema\n-        return schema_to_update\n+        if '$ref' not in json_schema:\n+            return json_schema\n+\n+        ref = json_schema['$ref']\n+        schema_to_update = self.get_schema_from_definitions(JsonRef(ref))\n+        if schema_to_update is None:\n+            raise RuntimeError(f'Cannot update undefined schema for $ref={ref}')\n+        return self.resolve_ref_schema(schema_to_update)",
      "comment": "Renamed and simplified. There's a function called this in `GenerateJsonSchemaHandler`, and ideally, we'd get rid of that eventually, so I think this helps draw some parallels to make that simplification easier in the future.",
      "comment_id": 1813083723,
      "user": "sydney-runkle",
      "created_at": "2024-10-23T15:52:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813083723"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "tests/test_json_schema.py",
      "line": 2630,
      "side": "LEFT",
      "diff_hunk": "@@ -2613,23 +2612,6 @@ class Model(TypedDict):\n     }\n \n \n-def test_typeddict_with_extra_behavior_allow():\n-    class Model:\n-        @classmethod\n-        def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n-            return core_schema.typed_dict_schema(\n-                {'a': core_schema.typed_dict_field(core_schema.str_schema())},\n-                extra_behavior='allow',\n-            )\n-\n-    assert TypeAdapter(Model).json_schema() == {\n-        'type': 'object',\n-        'properties': {'a': {'title': 'A', 'type': 'string'}},\n-        'required': ['a'],\n-        'additionalProperties': True,\n-    }",
      "comment": "So, I think we should only be pulling the `extra_behavior` from the config here. If folks disagree, I can pull from the schema as well, though not sure why we have this setting there - seems redundant.",
      "comment_id": 1813085109,
      "user": "sydney-runkle",
      "created_at": "2024-10-23T15:53:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813085109"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 100,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n-    \"\"\"\n-\n-    pydantic_js_functions: list[GetJsonSchemaFunction]\n-    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n-\n-    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will\n-    # prefer positional over keyword arguments for an 'arguments' schema.\n-    pydantic_js_prefer_positional_arguments: bool | None\n-    pydantic_js_input_core_schema: CoreSchema | None\n-\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n \n-class CoreMetadataHandler:\n-    \"\"\"Because the metadata field in pydantic_core is of type `Dict[str, Any]`, we can't assume much about its contents.\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n \n-    This class is used to interact with the metadata field on a CoreSchema object in a consistent way throughout pydantic.\n-\n-    TODO: We'd like to refactor the storage of json related metadata to be more explicit, and less functionally oriented.\n-    This should make its way into our v2.10 release. It's inevitable that we need to store some json schema related information\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n     on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n     issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n-    __slots__ = ('_schema',)\n-\n-    def __init__(self, schema: CoreSchemaOrField):\n-        self._schema = schema\n-\n-        metadata = schema.get('metadata')\n-        if metadata is None:\n-            schema['metadata'] = CoreMetadata()  # type: ignore\n-        elif not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-\n-    @property\n-    def metadata(self) -> CoreMetadata:\n-        \"\"\"Retrieves the metadata dict from the schema, initializing it to a dict if it is None\n-        and raises an error if it is not a dict.\n-        \"\"\"\n-        metadata = self._schema.get('metadata')\n-        if metadata is None:\n-            self._schema['metadata'] = metadata = CoreMetadata()  # type: ignore\n-        if not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-        return cast(CoreMetadata, metadata)\n-\n-\n-def build_metadata_dict(\n-    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way\n-    js_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_prefer_positional_arguments: bool | None = None,\n-    js_input_core_schema: CoreSchema | None = None,\n-) -> dict[str, Any]:\n-    \"\"\"Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent with the `CoreMetadataHandler` class.\"\"\"\n-    metadata = CoreMetadata(\n-        pydantic_js_functions=js_functions or [],\n-        pydantic_js_annotation_functions=js_annotation_functions or [],\n-        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,\n-        pydantic_js_input_core_schema=js_input_core_schema,\n-    )\n-    return {k: v for k, v in metadata.items() if v is not None}\n+    pydantic_js_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,\n+    pydantic_js_updates: JsonDict | None = None,\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n+) -> None:\n+    from ..json_schema import PydanticJsonSchemaWarning\n+\n+    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n+    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n+\n+    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n+    We do this here, instead of before / after each call to this function so that this typing hack\n+    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n+\n+    For parameter descriptions, see `CoreMetadata` above.\n+    \"\"\"\n+    core_metadata = cast(CoreMetadata, core_metadata)\n+\n+    if pydantic_js_functions:\n+        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n+\n+    if pydantic_js_annotation_functions:\n+        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n+\n+    if pydantic_js_prefer_positional_arguments:\n+        core_metadata['pydantic_js_prefer_positional_arguments'] = pydantic_js_prefer_positional_arguments\n+\n+    if pydantic_js_input_core_schema:\n+        core_metadata['pydantic_js_input_core_schema'] = pydantic_js_input_core_schema\n+\n+    if pydantic_js_updates:\n+        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n+            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n+        else:\n+            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n+\n+    if pydantic_js_extra is not None:\n+        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n+        if existing_pydantic_js_extra is None:\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+        if isinstance(existing_pydantic_js_extra, dict):\n+            if isinstance(pydantic_js_extra, dict):\n+                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n+            if isinstance(pydantic_js_extra, Callable):\n+                warn(\n+                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n+                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n+                    PydanticJsonSchemaWarning,\n+                )",
      "comment": "This should probably at least say that the callable is being ignored. (That's what I'm assuming is happening here.)",
      "comment_id": 1813661790,
      "user": "dmontagu",
      "created_at": "2024-10-23T21:32:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813661790"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/fields.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -451,11 +452,23 @@ def merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -> FieldInfo:\n \n             try:\n                 json_schema_extra = attributes_set.pop('json_schema_extra')\n-                existing_json_schema_extra = merged_field_info_kwargs.get('json_schema_extra', {})\n+                existing_json_schema_extra = merged_field_info_kwargs.get('json_schema_extra')\n \n-                if isinstance(existing_json_schema_extra, dict) and isinstance(json_schema_extra, dict):\n-                    merged_field_info_kwargs['json_schema_extra'] = {**existing_json_schema_extra, **json_schema_extra}\n-                else:\n+                if existing_json_schema_extra is None:\n+                    merged_field_info_kwargs['json_schema_extra'] = json_schema_extra\n+                if isinstance(existing_json_schema_extra, dict):\n+                    if isinstance(json_schema_extra, dict):\n+                        merged_field_info_kwargs['json_schema_extra'] = {\n+                            **existing_json_schema_extra,\n+                            **json_schema_extra,\n+                        }\n+                    if isinstance(json_schema_extra, Callable):\n+                        warn(\n+                            'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n+                            \"If you'd like support for this behavior, please open an issue on pydantic.\",\n+                            PydanticJsonSchemaWarning,\n+                        )",
      "comment": "Again, I think this warning should mention that the callable is being ignored.",
      "comment_id": 1813699619,
      "user": "dmontagu",
      "created_at": "2024-10-23T21:45:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1813699619"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/json_schema.py",
      "line": 1513,
      "side": "RIGHT",
      "diff_hunk": "@@ -1463,13 +1473,56 @@ def model_schema(self, schema: core_schema.ModelSchema) -> JsonSchemaValue:\n         # because it could lead to inconsistent refs handling, etc.\n         cls = cast('type[BaseModel]', schema['cls'])\n         config = cls.model_config\n-        title = config.get('title')\n \n         with self._config_wrapper_stack.push(config):\n             json_schema = self.generate_inner(schema['schema'])\n \n+        self._update_class_schema(json_schema, cls, config)\n+\n+        return json_schema\n+\n+    def _update_class_schema(self, json_schema: JsonSchemaValue, cls: type[Any], config: ConfigDict) -> None:\n+        \"\"\"Update json_schema with the following, extracted from `config` and `cls`:\n+\n+        * title\n+        * description\n+        * additional properties\n+        * json_schema_extra\n+        * deprecated\n+\n+        Done in place, hence there's no return value as the original json_schema is mutated.\n+        No ref resolving is involved here, as that's not appropriate for simple updates.\n+        \"\"\"\n+        from .main import BaseModel\n+        from .root_model import RootModel\n+\n+        if config_title := config.get('title'):\n+            json_schema.setdefault('title', config_title)\n+        elif model_title_generator := config.get('model_title_generator'):\n+            title = model_title_generator(cls)\n+            if not isinstance(title, str):\n+                raise TypeError(f'model_title_generator {model_title_generator} must return str, not {title.__class__}')\n+            json_schema.setdefault('title', title)\n+        if 'title' not in json_schema:\n+            json_schema['title'] = cls.__name__\n+\n+        # BaseModel and dataclasses; don't use cls.__doc__ as it will contain the verbose class signature by default\n+        docstring = None if cls is BaseModel or dataclasses.is_dataclass(cls) else cls.__doc__\n+\n+        if docstring and 'description' not in json_schema:\n+            json_schema['description'] = inspect.cleandoc(docstring)",
      "comment": "```suggestion\r\n        if docstring:\r\n            json_schema.setdefault('description', inspect.cleandoc(docstring))\r\n```",
      "comment_id": 1814919667,
      "user": "Viicos",
      "created_at": "2024-10-24T12:49:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1814919667"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/json_schema.py",
      "line": 1515,
      "side": "RIGHT",
      "diff_hunk": "@@ -1463,13 +1473,56 @@ def model_schema(self, schema: core_schema.ModelSchema) -> JsonSchemaValue:\n         # because it could lead to inconsistent refs handling, etc.\n         cls = cast('type[BaseModel]', schema['cls'])\n         config = cls.model_config\n-        title = config.get('title')\n \n         with self._config_wrapper_stack.push(config):\n             json_schema = self.generate_inner(schema['schema'])\n \n+        self._update_class_schema(json_schema, cls, config)\n+\n+        return json_schema\n+\n+    def _update_class_schema(self, json_schema: JsonSchemaValue, cls: type[Any], config: ConfigDict) -> None:\n+        \"\"\"Update json_schema with the following, extracted from `config` and `cls`:\n+\n+        * title\n+        * description\n+        * additional properties\n+        * json_schema_extra\n+        * deprecated\n+\n+        Done in place, hence there's no return value as the original json_schema is mutated.\n+        No ref resolving is involved here, as that's not appropriate for simple updates.\n+        \"\"\"\n+        from .main import BaseModel\n+        from .root_model import RootModel\n+\n+        if config_title := config.get('title'):\n+            json_schema.setdefault('title', config_title)\n+        elif model_title_generator := config.get('model_title_generator'):\n+            title = model_title_generator(cls)\n+            if not isinstance(title, str):\n+                raise TypeError(f'model_title_generator {model_title_generator} must return str, not {title.__class__}')\n+            json_schema.setdefault('title', title)\n+        if 'title' not in json_schema:\n+            json_schema['title'] = cls.__name__\n+\n+        # BaseModel and dataclasses; don't use cls.__doc__ as it will contain the verbose class signature by default\n+        docstring = None if cls is BaseModel or dataclasses.is_dataclass(cls) else cls.__doc__\n+\n+        if docstring and 'description' not in json_schema:\n+            json_schema['description'] = inspect.cleandoc(docstring)\n+        elif issubclass(cls, RootModel) and cls.__pydantic_fields__['root'].description:\n+            json_schema['description'] = cls.__pydantic_fields__['root'].description",
      "comment": "Is it intentional to override `json_schema['description']`, even if it already exists?",
      "comment_id": 1814921100,
      "user": "Viicos",
      "created_at": "2024-10-24T12:49:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1814921100"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n-    \"\"\"\n-\n-    pydantic_js_functions: list[GetJsonSchemaFunction]\n-    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n-\n-    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will\n-    # prefer positional over keyword arguments for an 'arguments' schema.\n-    pydantic_js_prefer_positional_arguments: bool | None\n-    pydantic_js_input_core_schema: CoreSchema | None\n-\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n \n-class CoreMetadataHandler:\n-    \"\"\"Because the metadata field in pydantic_core is of type `Dict[str, Any]`, we can't assume much about its contents.\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n \n-    This class is used to interact with the metadata field on a CoreSchema object in a consistent way throughout pydantic.\n-\n-    TODO: We'd like to refactor the storage of json related metadata to be more explicit, and less functionally oriented.\n-    This should make its way into our v2.10 release. It's inevitable that we need to store some json schema related information\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n     on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n     issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n-    __slots__ = ('_schema',)\n-\n-    def __init__(self, schema: CoreSchemaOrField):\n-        self._schema = schema\n-\n-        metadata = schema.get('metadata')\n-        if metadata is None:\n-            schema['metadata'] = CoreMetadata()  # type: ignore\n-        elif not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-\n-    @property\n-    def metadata(self) -> CoreMetadata:\n-        \"\"\"Retrieves the metadata dict from the schema, initializing it to a dict if it is None\n-        and raises an error if it is not a dict.\n-        \"\"\"\n-        metadata = self._schema.get('metadata')\n-        if metadata is None:\n-            self._schema['metadata'] = metadata = CoreMetadata()  # type: ignore\n-        if not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-        return cast(CoreMetadata, metadata)\n-\n-\n-def build_metadata_dict(\n-    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way\n-    js_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_prefer_positional_arguments: bool | None = None,\n-    js_input_core_schema: CoreSchema | None = None,\n-) -> dict[str, Any]:\n-    \"\"\"Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent with the `CoreMetadataHandler` class.\"\"\"\n-    metadata = CoreMetadata(\n-        pydantic_js_functions=js_functions or [],\n-        pydantic_js_annotation_functions=js_annotation_functions or [],\n-        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,\n-        pydantic_js_input_core_schema=js_input_core_schema,\n-    )\n-    return {k: v for k, v in metadata.items() if v is not None}\n+    pydantic_js_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,\n+    pydantic_js_updates: JsonDict | None = None,\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n+) -> None:\n+    from ..json_schema import PydanticJsonSchemaWarning\n+\n+    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n+    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n+\n+    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n+    We do this here, instead of before / after each call to this function so that this typing hack\n+    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n+\n+    For parameter descriptions, see `CoreMetadata` above.\n+    \"\"\"\n+    core_metadata = cast(CoreMetadata, core_metadata)\n+\n+    if pydantic_js_functions:\n+        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n+\n+    if pydantic_js_annotation_functions:\n+        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n+\n+    if pydantic_js_prefer_positional_arguments:\n+        core_metadata['pydantic_js_prefer_positional_arguments'] = pydantic_js_prefer_positional_arguments\n+\n+    if pydantic_js_input_core_schema:\n+        core_metadata['pydantic_js_input_core_schema'] = pydantic_js_input_core_schema\n+\n+    if pydantic_js_updates:\n+        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n+            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n+        else:\n+            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n+\n+    if pydantic_js_extra is not None:\n+        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n+        if existing_pydantic_js_extra is None:\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+        if isinstance(existing_pydantic_js_extra, dict):\n+            if isinstance(pydantic_js_extra, dict):\n+                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n+            if isinstance(pydantic_js_extra, Callable):\n+                warn(\n+                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n+                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n+                    PydanticJsonSchemaWarning,\n+                )\n+        if isinstance(existing_pydantic_js_extra, Callable):\n+            # if ever there's a case of a callable, we'll just keep the last json schema extra spec\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+\n+    core_metadata = cast(Dict[str, Any], core_metadata)",
      "comment": "```suggestion\r\n```\r\n\r\nThis `cast` call is useless, as we don't do anything with `core_metadata` after this call",
      "comment_id": 1814936597,
      "user": "Viicos",
      "created_at": "2024-10-24T12:58:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1814936597"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n-    \"\"\"\n-\n-    pydantic_js_functions: list[GetJsonSchemaFunction]\n-    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n-\n-    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will\n-    # prefer positional over keyword arguments for an 'arguments' schema.\n-    pydantic_js_prefer_positional_arguments: bool | None\n-    pydantic_js_input_core_schema: CoreSchema | None\n-\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n \n-class CoreMetadataHandler:\n-    \"\"\"Because the metadata field in pydantic_core is of type `Dict[str, Any]`, we can't assume much about its contents.\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n \n-    This class is used to interact with the metadata field on a CoreSchema object in a consistent way throughout pydantic.\n-\n-    TODO: We'd like to refactor the storage of json related metadata to be more explicit, and less functionally oriented.\n-    This should make its way into our v2.10 release. It's inevitable that we need to store some json schema related information\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n     on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n     issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n-    __slots__ = ('_schema',)\n-\n-    def __init__(self, schema: CoreSchemaOrField):\n-        self._schema = schema\n-\n-        metadata = schema.get('metadata')\n-        if metadata is None:\n-            schema['metadata'] = CoreMetadata()  # type: ignore\n-        elif not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-\n-    @property\n-    def metadata(self) -> CoreMetadata:\n-        \"\"\"Retrieves the metadata dict from the schema, initializing it to a dict if it is None\n-        and raises an error if it is not a dict.\n-        \"\"\"\n-        metadata = self._schema.get('metadata')\n-        if metadata is None:\n-            self._schema['metadata'] = metadata = CoreMetadata()  # type: ignore\n-        if not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-        return cast(CoreMetadata, metadata)\n-\n-\n-def build_metadata_dict(\n-    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way\n-    js_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_prefer_positional_arguments: bool | None = None,\n-    js_input_core_schema: CoreSchema | None = None,\n-) -> dict[str, Any]:\n-    \"\"\"Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent with the `CoreMetadataHandler` class.\"\"\"\n-    metadata = CoreMetadata(\n-        pydantic_js_functions=js_functions or [],\n-        pydantic_js_annotation_functions=js_annotation_functions or [],\n-        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,\n-        pydantic_js_input_core_schema=js_input_core_schema,\n-    )\n-    return {k: v for k, v in metadata.items() if v is not None}\n+    pydantic_js_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,\n+    pydantic_js_updates: JsonDict | None = None,\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n+) -> None:\n+    from ..json_schema import PydanticJsonSchemaWarning\n+\n+    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n+    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n+\n+    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n+    We do this here, instead of before / after each call to this function so that this typing hack\n+    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n+\n+    For parameter descriptions, see `CoreMetadata` above.\n+    \"\"\"\n+    core_metadata = cast(CoreMetadata, core_metadata)\n+\n+    if pydantic_js_functions:\n+        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n+\n+    if pydantic_js_annotation_functions:\n+        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n+\n+    if pydantic_js_prefer_positional_arguments:\n+        core_metadata['pydantic_js_prefer_positional_arguments'] = pydantic_js_prefer_positional_arguments\n+\n+    if pydantic_js_input_core_schema:\n+        core_metadata['pydantic_js_input_core_schema'] = pydantic_js_input_core_schema\n+\n+    if pydantic_js_updates:\n+        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n+            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n+        else:\n+            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n+\n+    if pydantic_js_extra is not None:\n+        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n+        if existing_pydantic_js_extra is None:\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+        if isinstance(existing_pydantic_js_extra, dict):\n+            if isinstance(pydantic_js_extra, dict):\n+                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n+            if isinstance(pydantic_js_extra, Callable):",
      "comment": "```suggestion\r\n            if callable(pydantic_js_extra):\r\n```",
      "comment_id": 1814937154,
      "user": "Viicos",
      "created_at": "2024-10-24T12:59:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1814937154"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n-    \"\"\"\n-\n-    pydantic_js_functions: list[GetJsonSchemaFunction]\n-    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n-\n-    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will\n-    # prefer positional over keyword arguments for an 'arguments' schema.\n-    pydantic_js_prefer_positional_arguments: bool | None\n-    pydantic_js_input_core_schema: CoreSchema | None\n-\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n \n-class CoreMetadataHandler:\n-    \"\"\"Because the metadata field in pydantic_core is of type `Dict[str, Any]`, we can't assume much about its contents.\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n \n-    This class is used to interact with the metadata field on a CoreSchema object in a consistent way throughout pydantic.\n-\n-    TODO: We'd like to refactor the storage of json related metadata to be more explicit, and less functionally oriented.\n-    This should make its way into our v2.10 release. It's inevitable that we need to store some json schema related information\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n     on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n     issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n-    __slots__ = ('_schema',)\n-\n-    def __init__(self, schema: CoreSchemaOrField):\n-        self._schema = schema\n-\n-        metadata = schema.get('metadata')\n-        if metadata is None:\n-            schema['metadata'] = CoreMetadata()  # type: ignore\n-        elif not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-\n-    @property\n-    def metadata(self) -> CoreMetadata:\n-        \"\"\"Retrieves the metadata dict from the schema, initializing it to a dict if it is None\n-        and raises an error if it is not a dict.\n-        \"\"\"\n-        metadata = self._schema.get('metadata')\n-        if metadata is None:\n-            self._schema['metadata'] = metadata = CoreMetadata()  # type: ignore\n-        if not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-        return cast(CoreMetadata, metadata)\n-\n-\n-def build_metadata_dict(\n-    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way\n-    js_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_prefer_positional_arguments: bool | None = None,\n-    js_input_core_schema: CoreSchema | None = None,\n-) -> dict[str, Any]:\n-    \"\"\"Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent with the `CoreMetadataHandler` class.\"\"\"\n-    metadata = CoreMetadata(\n-        pydantic_js_functions=js_functions or [],\n-        pydantic_js_annotation_functions=js_annotation_functions or [],\n-        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,\n-        pydantic_js_input_core_schema=js_input_core_schema,\n-    )\n-    return {k: v for k, v in metadata.items() if v is not None}\n+    pydantic_js_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,\n+    pydantic_js_updates: JsonDict | None = None,\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n+) -> None:\n+    from ..json_schema import PydanticJsonSchemaWarning\n+\n+    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n+    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n+\n+    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n+    We do this here, instead of before / after each call to this function so that this typing hack\n+    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n+\n+    For parameter descriptions, see `CoreMetadata` above.\n+    \"\"\"\n+    core_metadata = cast(CoreMetadata, core_metadata)\n+\n+    if pydantic_js_functions:\n+        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n+\n+    if pydantic_js_annotation_functions:\n+        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n+\n+    if pydantic_js_prefer_positional_arguments:\n+        core_metadata['pydantic_js_prefer_positional_arguments'] = pydantic_js_prefer_positional_arguments\n+\n+    if pydantic_js_input_core_schema:\n+        core_metadata['pydantic_js_input_core_schema'] = pydantic_js_input_core_schema\n+\n+    if pydantic_js_updates:\n+        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n+            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n+        else:\n+            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n+\n+    if pydantic_js_extra is not None:\n+        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n+        if existing_pydantic_js_extra is None:\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+        if isinstance(existing_pydantic_js_extra, dict):\n+            if isinstance(pydantic_js_extra, dict):\n+                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n+            if isinstance(pydantic_js_extra, Callable):\n+                warn(\n+                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n+                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n+                    PydanticJsonSchemaWarning,\n+                )\n+        if isinstance(existing_pydantic_js_extra, Callable):",
      "comment": "```suggestion\r\n        if callable(existing_pydantic_js_extra):\r\n```",
      "comment_id": 1814937491,
      "user": "Viicos",
      "created_at": "2024-10-24T12:59:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1814937491"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict",
      "comment": "We can use `typing` here, we only enforce `typing_extensions` for user code",
      "comment_id": 1815164907,
      "user": "Viicos",
      "created_at": "2024-10-24T14:53:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1815164907"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/fields.py",
      "line": 465,
      "side": "RIGHT",
      "diff_hunk": "@@ -451,11 +452,23 @@ def merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -> FieldInfo:\n \n             try:\n                 json_schema_extra = attributes_set.pop('json_schema_extra')\n-                existing_json_schema_extra = merged_field_info_kwargs.get('json_schema_extra', {})\n+                existing_json_schema_extra = merged_field_info_kwargs.get('json_schema_extra')\n \n-                if isinstance(existing_json_schema_extra, dict) and isinstance(json_schema_extra, dict):\n-                    merged_field_info_kwargs['json_schema_extra'] = {**existing_json_schema_extra, **json_schema_extra}\n-                else:\n+                if existing_json_schema_extra is None:\n+                    merged_field_info_kwargs['json_schema_extra'] = json_schema_extra\n+                if isinstance(existing_json_schema_extra, dict):\n+                    if isinstance(json_schema_extra, dict):\n+                        merged_field_info_kwargs['json_schema_extra'] = {\n+                            **existing_json_schema_extra,\n+                            **json_schema_extra,\n+                        }\n+                    if isinstance(json_schema_extra, Callable):",
      "comment": "```suggestion\r\n                    if callable(json_schema_extra):\r\n```",
      "comment_id": 1815170471,
      "user": "Viicos",
      "created_at": "2024-10-24T14:56:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1815170471"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "tests/test_json_schema.py",
      "line": 2630,
      "side": "LEFT",
      "diff_hunk": "@@ -2613,23 +2612,6 @@ class Model(TypedDict):\n     }\n \n \n-def test_typeddict_with_extra_behavior_allow():\n-    class Model:\n-        @classmethod\n-        def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n-            return core_schema.typed_dict_schema(\n-                {'a': core_schema.typed_dict_field(core_schema.str_schema())},\n-                extra_behavior='allow',\n-            )\n-\n-    assert TypeAdapter(Model).json_schema() == {\n-        'type': 'object',\n-        'properties': {'a': {'title': 'A', 'type': 'string'}},\n-        'required': ['a'],\n-        'additionalProperties': True,\n-    }",
      "comment": "extra items are going to be supported soon for typed dicts in Python. Is Pydantic support for it going to be easy to implement with these changes?",
      "comment_id": 1815193698,
      "user": "Viicos",
      "created_at": "2024-10-24T15:08:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1815193698"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/json_schema.py",
      "line": 1537,
      "side": "RIGHT",
      "diff_hunk": "@@ -1479,44 +1532,18 @@ def model_schema(self, schema: core_schema.ModelSchema) -> JsonSchemaValue:\n             if root_json_schema_extra:\n                 json_schema_extra = root_json_schema_extra\n \n-        json_schema = self._update_class_schema(json_schema, title, config.get('extra', None), cls, json_schema_extra)\n-\n-        return json_schema\n-\n-    def _update_class_schema(\n-        self,\n-        json_schema: JsonSchemaValue,\n-        title: str | None,\n-        extra: Literal['allow', 'ignore', 'forbid'] | None,\n-        cls: type[Any],\n-        json_schema_extra: JsonDict | JsonSchemaExtraCallable | None,\n-    ) -> JsonSchemaValue:\n-        if '$ref' in json_schema:\n-            schema_to_update = self.get_schema_from_definitions(JsonRef(json_schema['$ref'])) or json_schema\n-        else:\n-            schema_to_update = json_schema\n-\n-        if title is not None:\n-            # referenced_schema['title'] = title\n-            schema_to_update.setdefault('title', title)\n-\n-        if 'additionalProperties' not in schema_to_update:\n-            if extra == 'allow':\n-                schema_to_update['additionalProperties'] = True\n-            elif extra == 'forbid':\n-                schema_to_update['additionalProperties'] = False\n-\n         if isinstance(json_schema_extra, (staticmethod, classmethod)):\n             # In older versions of python, this is necessary to ensure staticmethod/classmethods are callable\n             json_schema_extra = json_schema_extra.__get__(cls)",
      "comment": "```suggestion\r\n            json_schema_extra = cast(JsonSchemaExtraCallable, json_schema_extra.__get__(cls))\r\n```\r\n\r\nFixes the `FIXME` comment below",
      "comment_id": 1815203113,
      "user": "Viicos",
      "created_at": "2024-10-24T15:12:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1815203113"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n-    \"\"\"\n-\n-    pydantic_js_functions: list[GetJsonSchemaFunction]\n-    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n-\n-    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will\n-    # prefer positional over keyword arguments for an 'arguments' schema.\n-    pydantic_js_prefer_positional_arguments: bool | None\n-    pydantic_js_input_core_schema: CoreSchema | None\n-\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n \n-class CoreMetadataHandler:\n-    \"\"\"Because the metadata field in pydantic_core is of type `Dict[str, Any]`, we can't assume much about its contents.\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n \n-    This class is used to interact with the metadata field on a CoreSchema object in a consistent way throughout pydantic.\n-\n-    TODO: We'd like to refactor the storage of json related metadata to be more explicit, and less functionally oriented.\n-    This should make its way into our v2.10 release. It's inevitable that we need to store some json schema related information\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n     on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n     issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n-    __slots__ = ('_schema',)\n-\n-    def __init__(self, schema: CoreSchemaOrField):\n-        self._schema = schema\n-\n-        metadata = schema.get('metadata')\n-        if metadata is None:\n-            schema['metadata'] = CoreMetadata()  # type: ignore\n-        elif not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-\n-    @property\n-    def metadata(self) -> CoreMetadata:\n-        \"\"\"Retrieves the metadata dict from the schema, initializing it to a dict if it is None\n-        and raises an error if it is not a dict.\n-        \"\"\"\n-        metadata = self._schema.get('metadata')\n-        if metadata is None:\n-            self._schema['metadata'] = metadata = CoreMetadata()  # type: ignore\n-        if not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-        return cast(CoreMetadata, metadata)\n-\n-\n-def build_metadata_dict(\n-    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way\n-    js_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_prefer_positional_arguments: bool | None = None,\n-    js_input_core_schema: CoreSchema | None = None,\n-) -> dict[str, Any]:\n-    \"\"\"Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent with the `CoreMetadataHandler` class.\"\"\"\n-    metadata = CoreMetadata(\n-        pydantic_js_functions=js_functions or [],\n-        pydantic_js_annotation_functions=js_annotation_functions or [],\n-        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,\n-        pydantic_js_input_core_schema=js_input_core_schema,\n-    )\n-    return {k: v for k, v in metadata.items() if v is not None}\n+    pydantic_js_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,\n+    pydantic_js_updates: JsonDict | None = None,\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n+) -> None:\n+    from ..json_schema import PydanticJsonSchemaWarning\n+\n+    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n+    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n+\n+    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n+    We do this here, instead of before / after each call to this function so that this typing hack\n+    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n+\n+    For parameter descriptions, see `CoreMetadata` above.\n+    \"\"\"\n+    core_metadata = cast(CoreMetadata, core_metadata)\n+\n+    if pydantic_js_functions:\n+        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n+\n+    if pydantic_js_annotation_functions:\n+        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n+\n+    if pydantic_js_prefer_positional_arguments:\n+        core_metadata['pydantic_js_prefer_positional_arguments'] = pydantic_js_prefer_positional_arguments\n+\n+    if pydantic_js_input_core_schema:\n+        core_metadata['pydantic_js_input_core_schema'] = pydantic_js_input_core_schema\n+\n+    if pydantic_js_updates:\n+        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n+            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n+        else:\n+            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n+\n+    if pydantic_js_extra is not None:\n+        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n+        if existing_pydantic_js_extra is None:\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+        if isinstance(existing_pydantic_js_extra, dict):\n+            if isinstance(pydantic_js_extra, dict):\n+                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n+            if isinstance(pydantic_js_extra, Callable):\n+                warn(\n+                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n+                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n+                    PydanticJsonSchemaWarning,\n+                )\n+        if isinstance(existing_pydantic_js_extra, Callable):\n+            # if ever there's a case of a callable, we'll just keep the last json schema extra spec\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+\n+    core_metadata = cast(Dict[str, Any], core_metadata)",
      "comment": "Actually, we do get some benefit here: without this, we get type errors one layer up if we don't cast before assigning `some_schema['metadata'] = core_metadata` because `metadata` is typed as `dict[str, Any]`",
      "comment_id": 1815280723,
      "user": "sydney-runkle",
      "created_at": "2024-10-24T15:50:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1815280723"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n-    \"\"\"\n-\n-    pydantic_js_functions: list[GetJsonSchemaFunction]\n-    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n-\n-    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will\n-    # prefer positional over keyword arguments for an 'arguments' schema.\n-    pydantic_js_prefer_positional_arguments: bool | None\n-    pydantic_js_input_core_schema: CoreSchema | None\n-\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n \n-class CoreMetadataHandler:\n-    \"\"\"Because the metadata field in pydantic_core is of type `Dict[str, Any]`, we can't assume much about its contents.\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n \n-    This class is used to interact with the metadata field on a CoreSchema object in a consistent way throughout pydantic.\n-\n-    TODO: We'd like to refactor the storage of json related metadata to be more explicit, and less functionally oriented.\n-    This should make its way into our v2.10 release. It's inevitable that we need to store some json schema related information\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n     on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n     issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n-    __slots__ = ('_schema',)\n-\n-    def __init__(self, schema: CoreSchemaOrField):\n-        self._schema = schema\n-\n-        metadata = schema.get('metadata')\n-        if metadata is None:\n-            schema['metadata'] = CoreMetadata()  # type: ignore\n-        elif not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-\n-    @property\n-    def metadata(self) -> CoreMetadata:\n-        \"\"\"Retrieves the metadata dict from the schema, initializing it to a dict if it is None\n-        and raises an error if it is not a dict.\n-        \"\"\"\n-        metadata = self._schema.get('metadata')\n-        if metadata is None:\n-            self._schema['metadata'] = metadata = CoreMetadata()  # type: ignore\n-        if not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-        return cast(CoreMetadata, metadata)\n-\n-\n-def build_metadata_dict(\n-    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way\n-    js_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_prefer_positional_arguments: bool | None = None,\n-    js_input_core_schema: CoreSchema | None = None,\n-) -> dict[str, Any]:\n-    \"\"\"Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent with the `CoreMetadataHandler` class.\"\"\"\n-    metadata = CoreMetadata(\n-        pydantic_js_functions=js_functions or [],\n-        pydantic_js_annotation_functions=js_annotation_functions or [],\n-        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,\n-        pydantic_js_input_core_schema=js_input_core_schema,\n-    )\n-    return {k: v for k, v in metadata.items() if v is not None}\n+    pydantic_js_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,\n+    pydantic_js_updates: JsonDict | None = None,\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n+) -> None:\n+    from ..json_schema import PydanticJsonSchemaWarning\n+\n+    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n+    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n+\n+    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n+    We do this here, instead of before / after each call to this function so that this typing hack\n+    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n+\n+    For parameter descriptions, see `CoreMetadata` above.\n+    \"\"\"\n+    core_metadata = cast(CoreMetadata, core_metadata)\n+\n+    if pydantic_js_functions:\n+        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n+\n+    if pydantic_js_annotation_functions:\n+        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n+\n+    if pydantic_js_prefer_positional_arguments:\n+        core_metadata['pydantic_js_prefer_positional_arguments'] = pydantic_js_prefer_positional_arguments\n+\n+    if pydantic_js_input_core_schema:\n+        core_metadata['pydantic_js_input_core_schema'] = pydantic_js_input_core_schema\n+\n+    if pydantic_js_updates:\n+        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n+            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n+        else:\n+            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n+\n+    if pydantic_js_extra is not None:\n+        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n+        if existing_pydantic_js_extra is None:\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+        if isinstance(existing_pydantic_js_extra, dict):\n+            if isinstance(pydantic_js_extra, dict):\n+                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n+            if isinstance(pydantic_js_extra, Callable):\n+                warn(\n+                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n+                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n+                    PydanticJsonSchemaWarning,\n+                )\n+        if isinstance(existing_pydantic_js_extra, Callable):\n+            # if ever there's a case of a callable, we'll just keep the last json schema extra spec\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+\n+    core_metadata = cast(Dict[str, Any], core_metadata)",
      "comment": "`cast` only has effect in the current scope:\r\n\r\nCode sample in [pyright playground](https://pyright-play.net/?enableExperimentalFeatures=true&code=LAKAZgTg9gtgBAFwJ4AcCWA7A5nNMVQQJwCCGSANHAMYCGAzglRAKYBuLtANgPrIotQoACYswcMAFcM1ABQIWjAFylyASjgBaAHxwAclAwsloOGcSLiAXhoMEs4WmoIA2owhV3AXSoLGaoRBzC0YXAHJaMK84GzCAIzDA4L9rW0YHJ1cySlUkHxCEAJBAlJVsmLgAbwBfQNYObj5UFnlLDTgAYlzQKRlW-1B6zl5%2BFpT2ruzQIA)\r\n\r\n```python\r\n\r\nfrom typing import Any, cast, reveal_type\r\n\r\ndef func(test: Any) -> None:\r\n    test = cast(dict[str, str], test)\r\n\r\n    test['a'] = 'b'\r\n\r\n    test = cast(dict[Any, Any], test)\r\n\r\n\r\ntest: Any = {}\r\n\r\nreveal_type(test)  # Any\r\nfunc(test)\r\nreveal_type(test)  # Any\r\n```\r\n\r\n",
      "comment_id": 1815558994,
      "user": "Viicos",
      "created_at": "2024-10-24T18:52:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1815558994"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n-    \"\"\"\n-\n-    pydantic_js_functions: list[GetJsonSchemaFunction]\n-    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n-\n-    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will\n-    # prefer positional over keyword arguments for an 'arguments' schema.\n-    pydantic_js_prefer_positional_arguments: bool | None\n-    pydantic_js_input_core_schema: CoreSchema | None\n-\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n \n-class CoreMetadataHandler:\n-    \"\"\"Because the metadata field in pydantic_core is of type `Dict[str, Any]`, we can't assume much about its contents.\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n \n-    This class is used to interact with the metadata field on a CoreSchema object in a consistent way throughout pydantic.\n-\n-    TODO: We'd like to refactor the storage of json related metadata to be more explicit, and less functionally oriented.\n-    This should make its way into our v2.10 release. It's inevitable that we need to store some json schema related information\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n     on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n     issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n-    __slots__ = ('_schema',)\n-\n-    def __init__(self, schema: CoreSchemaOrField):\n-        self._schema = schema\n-\n-        metadata = schema.get('metadata')\n-        if metadata is None:\n-            schema['metadata'] = CoreMetadata()  # type: ignore\n-        elif not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-\n-    @property\n-    def metadata(self) -> CoreMetadata:\n-        \"\"\"Retrieves the metadata dict from the schema, initializing it to a dict if it is None\n-        and raises an error if it is not a dict.\n-        \"\"\"\n-        metadata = self._schema.get('metadata')\n-        if metadata is None:\n-            self._schema['metadata'] = metadata = CoreMetadata()  # type: ignore\n-        if not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-        return cast(CoreMetadata, metadata)\n-\n-\n-def build_metadata_dict(\n-    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way\n-    js_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_prefer_positional_arguments: bool | None = None,\n-    js_input_core_schema: CoreSchema | None = None,\n-) -> dict[str, Any]:\n-    \"\"\"Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent with the `CoreMetadataHandler` class.\"\"\"\n-    metadata = CoreMetadata(\n-        pydantic_js_functions=js_functions or [],\n-        pydantic_js_annotation_functions=js_annotation_functions or [],\n-        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,\n-        pydantic_js_input_core_schema=js_input_core_schema,\n-    )\n-    return {k: v for k, v in metadata.items() if v is not None}\n+    pydantic_js_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,\n+    pydantic_js_updates: JsonDict | None = None,\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n+) -> None:\n+    from ..json_schema import PydanticJsonSchemaWarning\n+\n+    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n+    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n+\n+    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n+    We do this here, instead of before / after each call to this function so that this typing hack\n+    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n+\n+    For parameter descriptions, see `CoreMetadata` above.\n+    \"\"\"\n+    core_metadata = cast(CoreMetadata, core_metadata)\n+\n+    if pydantic_js_functions:\n+        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n+\n+    if pydantic_js_annotation_functions:\n+        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n+\n+    if pydantic_js_prefer_positional_arguments:\n+        core_metadata['pydantic_js_prefer_positional_arguments'] = pydantic_js_prefer_positional_arguments\n+\n+    if pydantic_js_input_core_schema:\n+        core_metadata['pydantic_js_input_core_schema'] = pydantic_js_input_core_schema\n+\n+    if pydantic_js_updates:\n+        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n+            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n+        else:\n+            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n+\n+    if pydantic_js_extra is not None:\n+        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n+        if existing_pydantic_js_extra is None:\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+        if isinstance(existing_pydantic_js_extra, dict):\n+            if isinstance(pydantic_js_extra, dict):\n+                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n+            if isinstance(pydantic_js_extra, Callable):\n+                warn(\n+                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n+                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n+                    PydanticJsonSchemaWarning,\n+                )\n+        if isinstance(existing_pydantic_js_extra, Callable):\n+            # if ever there's a case of a callable, we'll just keep the last json schema extra spec\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+\n+    core_metadata = cast(Dict[str, Any], core_metadata)",
      "comment": "Hmm, I'm seeing issues in my IDE when I remove the casting in that function (I guess, really the issue is, the type hint on return is `dict[str, Any]`, and if I don't cast the return value, then we see an issue.",
      "comment_id": 1817095848,
      "user": "sydney-runkle",
      "created_at": "2024-10-25T17:33:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1817095848"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n-    \"\"\"\n-\n-    pydantic_js_functions: list[GetJsonSchemaFunction]\n-    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n-\n-    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will\n-    # prefer positional over keyword arguments for an 'arguments' schema.\n-    pydantic_js_prefer_positional_arguments: bool | None\n-    pydantic_js_input_core_schema: CoreSchema | None\n-\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n \n-class CoreMetadataHandler:\n-    \"\"\"Because the metadata field in pydantic_core is of type `Dict[str, Any]`, we can't assume much about its contents.\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n \n-    This class is used to interact with the metadata field on a CoreSchema object in a consistent way throughout pydantic.\n-\n-    TODO: We'd like to refactor the storage of json related metadata to be more explicit, and less functionally oriented.\n-    This should make its way into our v2.10 release. It's inevitable that we need to store some json schema related information\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n     on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n     issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n-    __slots__ = ('_schema',)\n-\n-    def __init__(self, schema: CoreSchemaOrField):\n-        self._schema = schema\n-\n-        metadata = schema.get('metadata')\n-        if metadata is None:\n-            schema['metadata'] = CoreMetadata()  # type: ignore\n-        elif not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-\n-    @property\n-    def metadata(self) -> CoreMetadata:\n-        \"\"\"Retrieves the metadata dict from the schema, initializing it to a dict if it is None\n-        and raises an error if it is not a dict.\n-        \"\"\"\n-        metadata = self._schema.get('metadata')\n-        if metadata is None:\n-            self._schema['metadata'] = metadata = CoreMetadata()  # type: ignore\n-        if not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-        return cast(CoreMetadata, metadata)\n-\n-\n-def build_metadata_dict(\n-    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way\n-    js_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_prefer_positional_arguments: bool | None = None,\n-    js_input_core_schema: CoreSchema | None = None,\n-) -> dict[str, Any]:\n-    \"\"\"Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent with the `CoreMetadataHandler` class.\"\"\"\n-    metadata = CoreMetadata(\n-        pydantic_js_functions=js_functions or [],\n-        pydantic_js_annotation_functions=js_annotation_functions or [],\n-        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,\n-        pydantic_js_input_core_schema=js_input_core_schema,\n-    )\n-    return {k: v for k, v in metadata.items() if v is not None}\n+    pydantic_js_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,\n+    pydantic_js_updates: JsonDict | None = None,\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n+) -> None:\n+    from ..json_schema import PydanticJsonSchemaWarning\n+\n+    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n+    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n+\n+    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n+    We do this here, instead of before / after each call to this function so that this typing hack\n+    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n+\n+    For parameter descriptions, see `CoreMetadata` above.\n+    \"\"\"\n+    core_metadata = cast(CoreMetadata, core_metadata)\n+\n+    if pydantic_js_functions:\n+        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n+\n+    if pydantic_js_annotation_functions:\n+        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n+\n+    if pydantic_js_prefer_positional_arguments:\n+        core_metadata['pydantic_js_prefer_positional_arguments'] = pydantic_js_prefer_positional_arguments\n+\n+    if pydantic_js_input_core_schema:\n+        core_metadata['pydantic_js_input_core_schema'] = pydantic_js_input_core_schema\n+\n+    if pydantic_js_updates:\n+        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n+            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n+        else:\n+            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n+\n+    if pydantic_js_extra is not None:\n+        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n+        if existing_pydantic_js_extra is None:\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+        if isinstance(existing_pydantic_js_extra, dict):\n+            if isinstance(pydantic_js_extra, dict):\n+                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n+            if isinstance(pydantic_js_extra, Callable):\n+                warn(\n+                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n+                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n+                    PydanticJsonSchemaWarning,\n+                )\n+        if isinstance(existing_pydantic_js_extra, Callable):\n+            # if ever there's a case of a callable, we'll just keep the last json schema extra spec\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+\n+    core_metadata = cast(Dict[str, Any], core_metadata)",
      "comment": "Oh yes you're right, not sure how I overlooked that. Let's hop on a call to sort out the rest of the typing issues.",
      "comment_id": 1819162014,
      "user": "sydney-runkle",
      "created_at": "2024-10-28T14:21:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1819162014"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/json_schema.py",
      "line": 1537,
      "side": "RIGHT",
      "diff_hunk": "@@ -1479,44 +1532,18 @@ def model_schema(self, schema: core_schema.ModelSchema) -> JsonSchemaValue:\n             if root_json_schema_extra:\n                 json_schema_extra = root_json_schema_extra\n \n-        json_schema = self._update_class_schema(json_schema, title, config.get('extra', None), cls, json_schema_extra)\n-\n-        return json_schema\n-\n-    def _update_class_schema(\n-        self,\n-        json_schema: JsonSchemaValue,\n-        title: str | None,\n-        extra: Literal['allow', 'ignore', 'forbid'] | None,\n-        cls: type[Any],\n-        json_schema_extra: JsonDict | JsonSchemaExtraCallable | None,\n-    ) -> JsonSchemaValue:\n-        if '$ref' in json_schema:\n-            schema_to_update = self.get_schema_from_definitions(JsonRef(json_schema['$ref'])) or json_schema\n-        else:\n-            schema_to_update = json_schema\n-\n-        if title is not None:\n-            # referenced_schema['title'] = title\n-            schema_to_update.setdefault('title', title)\n-\n-        if 'additionalProperties' not in schema_to_update:\n-            if extra == 'allow':\n-                schema_to_update['additionalProperties'] = True\n-            elif extra == 'forbid':\n-                schema_to_update['additionalProperties'] = False\n-\n         if isinstance(json_schema_extra, (staticmethod, classmethod)):\n             # In older versions of python, this is necessary to ensure staticmethod/classmethods are callable\n             json_schema_extra = json_schema_extra.__get__(cls)",
      "comment": "Ha, `cast(Callable[..., None])` should work, let's not fight the type checker as we make the `inspect.signature` check ourselves",
      "comment_id": 1819185911,
      "user": "Viicos",
      "created_at": "2024-10-28T14:35:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1819185911"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/_internal/_core_metadata.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,84 +1,105 @@\n from __future__ import annotations as _annotations\n \n-import typing\n-from typing import Any, cast\n+from typing import TYPE_CHECKING, Any, Callable, Dict, cast\n+from warnings import warn\n \n-import typing_extensions\n+from typing_extensions import TypedDict\n \n-if typing.TYPE_CHECKING:\n+if TYPE_CHECKING:\n     from pydantic_core import CoreSchema\n \n+    from ..config import JsonDict, JsonSchemaExtraCallable\n     from ._schema_generation_shared import (\n-        CoreSchemaOrField,\n         GetJsonSchemaFunction,\n     )\n \n \n-class CoreMetadata(typing_extensions.TypedDict, total=False):\n+class CoreMetadata(TypedDict, total=False):\n     \"\"\"A `TypedDict` for holding the metadata dict of the schema.\n \n     Attributes:\n-        pydantic_js_functions: List of JSON schema functions.\n+        pydantic_js_functions: List of JSON schema functions that resolve refs during application.\n+        pydantic_js_annotation_functions: List of JSON schema functions that don't resolve refs during application.\n         pydantic_js_prefer_positional_arguments: Whether JSON schema generator will\n             prefer positional over keyword arguments for an 'arguments' schema.\n-    \"\"\"\n-\n-    pydantic_js_functions: list[GetJsonSchemaFunction]\n-    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n-\n-    # If `pydantic_js_prefer_positional_arguments` is True, the JSON schema generator will\n-    # prefer positional over keyword arguments for an 'arguments' schema.\n-    pydantic_js_prefer_positional_arguments: bool | None\n-    pydantic_js_input_core_schema: CoreSchema | None\n-\n+        pydantic_js_input_core_schema: Schema associated with the input value for the associated\n+            custom validation function. Only applies to before, plain, and wrap validators.\n+        pydantic_js_udpates: key / value pair updates to apply to the JSON schema for a type.\n+        pydantic_js_extra: WIP, either key/value pair updates to apply to the JSON schema, or a custom callable.\n \n-class CoreMetadataHandler:\n-    \"\"\"Because the metadata field in pydantic_core is of type `Dict[str, Any]`, we can't assume much about its contents.\n+    TODO: Perhaps we should move this structure to pydantic-core. At the moment, though,\n+    it's easier to iterate on if we leave it in pydantic until we feel there is a semi-stable API.\n \n-    This class is used to interact with the metadata field on a CoreSchema object in a consistent way throughout pydantic.\n-\n-    TODO: We'd like to refactor the storage of json related metadata to be more explicit, and less functionally oriented.\n-    This should make its way into our v2.10 release. It's inevitable that we need to store some json schema related information\n+    TODO: It's unfortunate how functionally oriented JSON schema generation is, especially that which occurs during\n+    the core schema generation process. It's inevitable that we need to store some json schema related information\n     on core schemas, given that we generate JSON schemas directly from core schemas. That being said, debugging related\n     issues is quite difficult when JSON schema information is disguised via dynamically defined functions.\n     \"\"\"\n \n-    __slots__ = ('_schema',)\n-\n-    def __init__(self, schema: CoreSchemaOrField):\n-        self._schema = schema\n-\n-        metadata = schema.get('metadata')\n-        if metadata is None:\n-            schema['metadata'] = CoreMetadata()  # type: ignore\n-        elif not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-\n-    @property\n-    def metadata(self) -> CoreMetadata:\n-        \"\"\"Retrieves the metadata dict from the schema, initializing it to a dict if it is None\n-        and raises an error if it is not a dict.\n-        \"\"\"\n-        metadata = self._schema.get('metadata')\n-        if metadata is None:\n-            self._schema['metadata'] = metadata = CoreMetadata()  # type: ignore\n-        if not isinstance(metadata, dict):\n-            raise TypeError(f'CoreSchema metadata should be a dict; got {metadata!r}.')\n-        return cast(CoreMetadata, metadata)\n-\n-\n-def build_metadata_dict(\n-    *,  # force keyword arguments to make it easier to modify this signature in a backwards-compatible way\n-    js_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n-    js_prefer_positional_arguments: bool | None = None,\n-    js_input_core_schema: CoreSchema | None = None,\n-) -> dict[str, Any]:\n-    \"\"\"Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent with the `CoreMetadataHandler` class.\"\"\"\n-    metadata = CoreMetadata(\n-        pydantic_js_functions=js_functions or [],\n-        pydantic_js_annotation_functions=js_annotation_functions or [],\n-        pydantic_js_prefer_positional_arguments=js_prefer_positional_arguments,\n-        pydantic_js_input_core_schema=js_input_core_schema,\n-    )\n-    return {k: v for k, v in metadata.items() if v is not None}\n+    pydantic_js_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction]\n+    pydantic_js_prefer_positional_arguments: bool\n+    pydantic_js_input_core_schema: CoreSchema\n+    pydantic_js_updates: JsonDict\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable\n+\n+\n+def update_core_metadata(\n+    core_metadata: Any,\n+    /,\n+    pydantic_js_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_annotation_functions: list[GetJsonSchemaFunction] | None = None,\n+    pydantic_js_prefer_positional_arguments: bool | None = None,\n+    pydantic_js_input_core_schema: CoreSchema | None = None,\n+    pydantic_js_updates: JsonDict | None = None,\n+    pydantic_js_extra: JsonDict | JsonSchemaExtraCallable | None = None,\n+) -> None:\n+    from ..json_schema import PydanticJsonSchemaWarning\n+\n+    \"\"\"Update CoreMetadata instance in place. When we make modifications in this function, they\n+    take effect on the `core_metadata` reference passed in as the first (and only) positional argument.\n+\n+    First, cast to `CoreMetadata`, then finish with a cast to `dict[str, Any]` for core schema compatibility.\n+    We do this here, instead of before / after each call to this function so that this typing hack\n+    can be easily removed if/when we move `CoreMetadata` to `pydantic-core`.\n+\n+    For parameter descriptions, see `CoreMetadata` above.\n+    \"\"\"\n+    core_metadata = cast(CoreMetadata, core_metadata)\n+\n+    if pydantic_js_functions:\n+        core_metadata.setdefault('pydantic_js_functions', []).extend(pydantic_js_functions)\n+\n+    if pydantic_js_annotation_functions:\n+        core_metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n+\n+    if pydantic_js_prefer_positional_arguments:\n+        core_metadata['pydantic_js_prefer_positional_arguments'] = pydantic_js_prefer_positional_arguments\n+\n+    if pydantic_js_input_core_schema:\n+        core_metadata['pydantic_js_input_core_schema'] = pydantic_js_input_core_schema\n+\n+    if pydantic_js_updates:\n+        if (existing_updates := core_metadata.get('pydantic_js_updates')) is not None:\n+            core_metadata['pydantic_js_updates'] = {**existing_updates, **pydantic_js_updates}\n+        else:\n+            core_metadata['pydantic_js_updates'] = pydantic_js_updates\n+\n+    if pydantic_js_extra is not None:\n+        existing_pydantic_js_extra = core_metadata.get('pydantic_js_extra')\n+        if existing_pydantic_js_extra is None:\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+        if isinstance(existing_pydantic_js_extra, dict):\n+            if isinstance(pydantic_js_extra, dict):\n+                core_metadata['pydantic_js_extra'] = {**existing_pydantic_js_extra, **pydantic_js_extra}\n+            if isinstance(pydantic_js_extra, Callable):\n+                warn(\n+                    'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n+                    \"If you'd like support for this behavior, please open an issue on pydantic.\",\n+                    PydanticJsonSchemaWarning,\n+                )\n+        if isinstance(existing_pydantic_js_extra, Callable):\n+            # if ever there's a case of a callable, we'll just keep the last json schema extra spec\n+            core_metadata['pydantic_js_extra'] = pydantic_js_extra\n+\n+    core_metadata = cast(Dict[str, Any], core_metadata)",
      "comment": "You're right here, not sure why I got confused. I've removed the last `cast`.",
      "comment_id": 1819198135,
      "user": "sydney-runkle",
      "created_at": "2024-10-28T14:42:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1819198135"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10675,
      "file_path": "pydantic/json_schema.py",
      "line": 1537,
      "side": "RIGHT",
      "diff_hunk": "@@ -1479,44 +1532,18 @@ def model_schema(self, schema: core_schema.ModelSchema) -> JsonSchemaValue:\n             if root_json_schema_extra:\n                 json_schema_extra = root_json_schema_extra\n \n-        json_schema = self._update_class_schema(json_schema, title, config.get('extra', None), cls, json_schema_extra)\n-\n-        return json_schema\n-\n-    def _update_class_schema(\n-        self,\n-        json_schema: JsonSchemaValue,\n-        title: str | None,\n-        extra: Literal['allow', 'ignore', 'forbid'] | None,\n-        cls: type[Any],\n-        json_schema_extra: JsonDict | JsonSchemaExtraCallable | None,\n-    ) -> JsonSchemaValue:\n-        if '$ref' in json_schema:\n-            schema_to_update = self.get_schema_from_definitions(JsonRef(json_schema['$ref'])) or json_schema\n-        else:\n-            schema_to_update = json_schema\n-\n-        if title is not None:\n-            # referenced_schema['title'] = title\n-            schema_to_update.setdefault('title', title)\n-\n-        if 'additionalProperties' not in schema_to_update:\n-            if extra == 'allow':\n-                schema_to_update['additionalProperties'] = True\n-            elif extra == 'forbid':\n-                schema_to_update['additionalProperties'] = False\n-\n         if isinstance(json_schema_extra, (staticmethod, classmethod)):\n             # In older versions of python, this is necessary to ensure staticmethod/classmethods are callable\n             json_schema_extra = json_schema_extra.__get__(cls)",
      "comment": "We've discussed - just going to keep the type ignores here.",
      "comment_id": 1819206113,
      "user": "sydney-runkle",
      "created_at": "2024-10-28T14:46:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/10675#discussion_r1819206113"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(",
      "comment": "I think you could simplify here:\r\n\r\n```suggestion\r\n        if schema['type'] == 'function-wrap':\r\n            # for function-wrap schemas, url constraints is applied to the inner schema\r\n            inner = schema['schema']\r\n\r\n            if annotated_type := inner['type'] in ('url', 'multi-host-url'):\r\n                schema = inner\r\n```",
      "comment_id": 1852275898,
      "user": "davidhewitt",
      "created_at": "2024-11-21T14:45:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852275898"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in self.defined_constraints.items():\n+                inner[constraint_key] = constraint_value\n+            schema['schema'] = inner\n+        else:\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(",
      "comment": "Potentially if we can't trivially identify the output, we should just slap on a `UrlConstraints` after validator and leave it to be a runtime (validation error) if the constraints can't be applied to a non-url value.",
      "comment_id": 1852294602,
      "user": "davidhewitt",
      "created_at": "2024-11-21T14:55:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852294602"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in self.defined_constraints.items():\n+                inner[constraint_key] = constraint_value\n+            schema['schema'] = inner\n+        else:\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(",
      "comment": "Hmm, that validator would be pretty complex, there's a lot involved in `UrlConstraints`...\r\n\r\nI don't disagree with the premise, but I don't think this is the place to implement such a change",
      "comment_id": 1852384396,
      "user": "sydney-runkle",
      "created_at": "2024-11-21T15:44:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852384396"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in self.defined_constraints.items():\n+                inner[constraint_key] = constraint_value\n+            schema['schema'] = inner",
      "comment": "This seems like a noop (inner is mutated but not recreated).\r\n\r\n```suggestion\r\n```",
      "comment_id": 1852398813,
      "user": "davidhewitt",
      "created_at": "2024-11-21T15:52:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852398813"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(",
      "comment": "Why not? It seems to me that 112-113 is repeated with 120-121 with the only difference being `inner` vs `schema`.",
      "comment_id": 1852399907,
      "user": "davidhewitt",
      "created_at": "2024-11-21T15:52:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852399907"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in self.defined_constraints.items():\n+                inner[constraint_key] = constraint_value\n+            schema['schema'] = inner\n+        else:\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(",
      "comment": "Agreed, let's leave an issue in core to expose `url_constraints_schema` and leave core to optimize such a schema if necessary?",
      "comment_id": 1852401118,
      "user": "davidhewitt",
      "created_at": "2024-11-21T15:53:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852401118"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(",
      "comment": "Because we still want to return `schema`, just with `inner` reassigned after modification. We still need the `function-wrap`",
      "comment_id": 1852412166,
      "user": "sydney-runkle",
      "created_at": "2024-11-21T15:59:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852412166"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in self.defined_constraints.items():\n+                inner[constraint_key] = constraint_value\n+            schema['schema'] = inner\n+        else:\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(",
      "comment": "Is there a `url_constraints_schema` in core? I don't think so?\r\n\r\nPerhaps this can just go along with https://github.com/pydantic/pydantic/issues/10783...",
      "comment_id": 1852414122,
      "user": "sydney-runkle",
      "created_at": "2024-11-21T16:00:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852414122"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in self.defined_constraints.items():\n+                inner[constraint_key] = constraint_value\n+            schema['schema'] = inner\n+        else:\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(",
      "comment": "There isn't one but I think it would make sense in a world where constraints are wrapping validators which core can occasionally optimize.",
      "comment_id": 1852419319,
      "user": "davidhewitt",
      "created_at": "2024-11-21T16:03:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852419319"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in self.defined_constraints.items():\n+                inner[constraint_key] = constraint_value\n+            schema['schema'] = inner\n+        else:\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(",
      "comment": "Ah yes, along the core optimizing constraint application line of thought",
      "comment_id": 1852421434,
      "user": "sydney-runkle",
      "created_at": "2024-11-21T16:05:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852421434"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10922,
      "file_path": "pydantic/networks.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,7 +96,31 @@ def __hash__(self) -> int:\n     @property\n     def defined_constraints(self) -> dict[str, Any]:\n         \"\"\"Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.\"\"\"\n-        return {field.name: getattr(self, field.name) for field in fields(self)}\n+        return {field.name: value for field in fields(self) if (value := getattr(self, field.name)) is not None}\n+\n+    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+        schema = handler(source)\n+\n+        if schema['type'] == 'function-wrap':\n+            # for function-wrap schemas, url constraints is applied to the inner schema\n+            inner = schema['schema']\n+\n+            if annotated_type := inner['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in self.defined_constraints.items():\n+                inner[constraint_key] = constraint_value\n+            schema['schema'] = inner\n+        else:\n+            if annotated_type := schema['type'] not in ('url', 'multi-host-url'):\n+                raise PydanticUserError(\n+                    f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\n+                )\n+            for constraint_key, constraint_value in self.defined_constraints.items():\n+                schema[constraint_key] = constraint_value\n+\n+        return schema",
      "comment": "```suggestion\r\n        # for function-wrap schemas, url constraints is applied to the inner schema\r\n        schema_to_mutate = schema['schema'] if schema['type'] == 'function-wrap' else schema\r\n\r\n        if annotated_type := schema_to_mutate['type'] not in ('url', 'multi-host-url'):\r\n            raise PydanticUserError(\r\n                f\"'UrlConstraints' cannot annotate '{annotated_type}'.\", code='invalid-annotated-type'\r\n            )\r\n        for constraint_key, constraint_value in self.defined_constraints.items():\r\n            schema_to_mutate[constraint_key] = constraint_value\r\n\r\n        return schema\r\n```\r\n\r\nmaybe?",
      "comment_id": 1852576621,
      "user": "Viicos",
      "created_at": "2024-11-21T17:30:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10922#discussion_r1852576621"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10929,
      "file_path": "tests/test_forward_ref.py",
      "line": 1308,
      "side": "LEFT",
      "diff_hunk": "@@ -1302,22 +1302,20 @@ def inner():\n         func_val(a=1)\n \n \n-@pytest.mark.xfail(\n-    reason='In `GenerateSchema`, only the current class module is taken into account. '\n-    'This is similar to `test_uses_the_correct_globals_to_resolve_model_forward_refs`.'\n-)",
      "comment": "Turns out this used to work. However, the mentioned `test_uses_the_correct_globals_to_resolve_model_forward_refs` test was also failing on 2.9",
      "comment_id": 1852552978,
      "user": "Viicos",
      "created_at": "2024-11-21T17:14:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/10929#discussion_r1852552978"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10929,
      "file_path": "tests/test_forward_ref.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1302,22 +1302,20 @@ def inner():\n         func_val(a=1)\n \n \n-@pytest.mark.xfail(\n-    reason='In `GenerateSchema`, only the current class module is taken into account. '\n-    'This is similar to `test_uses_the_correct_globals_to_resolve_model_forward_refs`.'\n-)\n def test_uses_the_correct_globals_to_resolve_forward_refs_on_serializers(create_module):\n+    # Note: unlike `test_uses_the_correct_globals_to_resolve_model_forward_refs`,\n+    # we use the globals of the underlying func to resolve the return type.\n     @create_module\n     def module_1():\n-        from pydantic import BaseModel, field_serializer  # or model_serializer\n+        from pydantic import BaseModel, field_serializer  # or model_serializer, computed_field",
      "comment": "```suggestion\r\n        from pydantic import BaseModel, field_serializer  # or model_serializer\r\n```",
      "comment_id": 1852553697,
      "user": "sydney-runkle",
      "created_at": "2024-11-21T17:14:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10929#discussion_r1852553697"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10929,
      "file_path": "tests/test_forward_ref.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1302,22 +1302,20 @@ def inner():\n         func_val(a=1)\n \n \n-@pytest.mark.xfail(\n-    reason='In `GenerateSchema`, only the current class module is taken into account. '\n-    'This is similar to `test_uses_the_correct_globals_to_resolve_model_forward_refs`.'\n-)\n def test_uses_the_correct_globals_to_resolve_forward_refs_on_serializers(create_module):\n+    # Note: unlike `test_uses_the_correct_globals_to_resolve_model_forward_refs`,\n+    # we use the globals of the underlying func to resolve the return type.\n     @create_module\n     def module_1():\n-        from pydantic import BaseModel, field_serializer  # or model_serializer\n+        from pydantic import BaseModel, field_serializer  # or model_serializer, computed_field",
      "comment": "The goal was to mentioned that this also applied to `computed_field`",
      "comment_id": 1852556025,
      "user": "Viicos",
      "created_at": "2024-11-21T17:16:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10929#discussion_r1852556025"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10929,
      "file_path": "tests/test_forward_ref.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1302,22 +1302,20 @@ def inner():\n         func_val(a=1)\n \n \n-@pytest.mark.xfail(\n-    reason='In `GenerateSchema`, only the current class module is taken into account. '\n-    'This is similar to `test_uses_the_correct_globals_to_resolve_model_forward_refs`.'\n-)\n def test_uses_the_correct_globals_to_resolve_forward_refs_on_serializers(create_module):\n+    # Note: unlike `test_uses_the_correct_globals_to_resolve_model_forward_refs`,\n+    # we use the globals of the underlying func to resolve the return type.\n     @create_module\n     def module_1():\n-        from pydantic import BaseModel, field_serializer  # or model_serializer\n+        from pydantic import BaseModel, field_serializer  # or model_serializer, computed_field",
      "comment": "It is commented out, just to mention that the same logic applies to the three decorators. We could add a test for each alternatively.",
      "comment_id": 1852579594,
      "user": "Viicos",
      "created_at": "2024-11-21T17:32:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10929#discussion_r1852579594"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10929,
      "file_path": "tests/test_forward_ref.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1302,22 +1302,20 @@ def inner():\n         func_val(a=1)\n \n \n-@pytest.mark.xfail(\n-    reason='In `GenerateSchema`, only the current class module is taken into account. '\n-    'This is similar to `test_uses_the_correct_globals_to_resolve_model_forward_refs`.'\n-)\n def test_uses_the_correct_globals_to_resolve_forward_refs_on_serializers(create_module):\n+    # Note: unlike `test_uses_the_correct_globals_to_resolve_model_forward_refs`,\n+    # we use the globals of the underlying func to resolve the return type.\n     @create_module\n     def module_1():\n-        from pydantic import BaseModel, field_serializer  # or model_serializer\n+        from pydantic import BaseModel, field_serializer  # or model_serializer, computed_field",
      "comment": "oh my goodness \ud83d\ude22 sorry I missed that \ud83e\udee8. Thanks! Let's merge :)",
      "comment_id": 1852583152,
      "user": "sydney-runkle",
      "created_at": "2024-11-21T17:34:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10929#discussion_r1852583152"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10928,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1414,
      "side": "RIGHT",
      "diff_hunk": "@@ -1411,6 +1411,8 @@ def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -> core_schema.Co\n                 )\n \n             try:\n+                # if (plain) dataclass doesn't have config, we use the parent's config, hence a default of `None`",
      "comment": "```suggestion\r\n                # if a typed dictionary class doesn't have config, we use the parent's config, hence a default of `None`\r\n```",
      "comment_id": 1852437750,
      "user": "Viicos",
      "created_at": "2024-11-21T16:13:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10928#discussion_r1852437750"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10928,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1743,
      "side": "RIGHT",
      "diff_hunk": "@@ -1738,7 +1740,9 @@ def _dataclass_schema(\n             if origin is not None:\n                 dataclass = origin\n \n-            config = getattr(dataclass, '__pydantic_config__', ConfigDict())\n+            # if (plain) dataclass doesn't have config, we use the parent's config, hence a default of `None`",
      "comment": "```suggestion\r\n            # if (plain) dataclass doesn't have config, we use the parent's config, hence a default of `None`\r\n            # (Pydantic dataclasses have an empty dict config by default).\r\n```",
      "comment_id": 1852452898,
      "user": "Viicos",
      "created_at": "2024-11-21T16:17:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10928#discussion_r1852452898"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10909,
      "file_path": "pydantic/fields.py",
      "line": 600,
      "side": "RIGHT",
      "diff_hunk": "@@ -594,9 +594,11 @@ def get_default(self, *, call_default_factory: bool = False, validated_data: dic\n         if self.default_factory is None:\n             return _utils.smart_deepcopy(self.default)\n         elif call_default_factory:\n-            if validated_data is None:\n-                raise ValueError(\"'validated_data' must be provided if 'call_default_factory' is True.\")\n             if _fields.takes_validated_data_argument(self.default_factory):\n+                if validated_data is None:\n+                    raise ValueError(\n+                        \"'validated_data' is missing but should be provided. This is a bug, please report this.\"",
      "comment": "```suggestion\r\n                       \"The default factory requires the 'validated_data' argument, which was not provided when calling 'get_default'.\"\r\n```\r\n\r\nI don't think mentioning \"this is a bug\" is correct, as users could really just call `get_default` in the wrong way.",
      "comment_id": 1852161064,
      "user": "Viicos",
      "created_at": "2024-11-21T13:56:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10909#discussion_r1852161064"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10893,
      "file_path": "pydantic/type_adapter.py",
      "line": 237,
      "side": "RIGHT",
      "diff_hunk": "@@ -227,6 +233,17 @@ def __init__(\n             force=False,\n         )\n \n+    def _fetch_parent_frame(self, depth: int) -> FrameType | None:\n+        frame = sys._getframe(depth)",
      "comment": "Why no more `parent_frame_namespace`? This call is ok bc I think it does the same thing, but was wondering why you stopped using the helper function.",
      "comment_id": 1851005223,
      "user": "sydney-runkle",
      "created_at": "2024-11-20T21:30:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/10893#discussion_r1851005223"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10893,
      "file_path": "pydantic/type_adapter.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -227,6 +233,17 @@ def __init__(\n             force=False,\n         )\n \n+    def _fetch_parent_frame(self, depth: int) -> FrameType | None:",
      "comment": "No need to have the depth arg here, you can just use `self._parent_depth`",
      "comment_id": 1851005496,
      "user": "sydney-runkle",
      "created_at": "2024-11-20T21:30:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10893#discussion_r1851005496"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10893,
      "file_path": "pydantic/type_adapter.py",
      "line": 237,
      "side": "RIGHT",
      "diff_hunk": "@@ -227,6 +233,17 @@ def __init__(\n             force=False,\n         )\n \n+    def _fetch_parent_frame(self, depth: int) -> FrameType | None:\n+        frame = sys._getframe(depth)",
      "comment": "Because `parent_frame_namespace` returns the locals directly, but I need the globals as well to check for the module of the frame. Previously, we did another call to `sys._getframe` to fetch the globals (resulting in the frame being fetched twice), but it ends up being cleaner fetching the relevant frame once, and pulling up `f_locals` and `f_globals` from it.",
      "comment_id": 1851581538,
      "user": "Viicos",
      "created_at": "2024-11-21T08:34:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10893#discussion_r1851581538"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 897,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +893,64 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (fast_memo_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                fast_memo_handler(self, value)",
      "comment": "I wouldn't expect to have a `slow_memo_handler`, given that the point of memoization is to make things fast. Maybe we could use `setattr_handler` instead?",
      "comment_id": 1847127547,
      "user": "sydney-runkle",
      "created_at": "2024-11-18T19:20:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1847127547"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 906,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +893,64 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (fast_memo_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                fast_memo_handler(self, value)\n+                return\n+\n+            if (fast_memo_handler := self._setattr_handler(name, value)) is not None:\n+                fast_memo_handler(self, value)  # call here to not memo on possibly unknown fields\n+                self.__pydantic_setattr_handlers__[name] = fast_memo_handler\n+\n+        def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, Any], None] | None:\n+            \"\"\"Returns a handler for setting an attribute on the model instance. This handler can be memoized to\n+            the class. Gives None when memoization is not safe, then the attribute is set directly.",
      "comment": "Can we use the classic one line summary, then a `Returns:` block below that?",
      "comment_id": 1847128206,
      "user": "sydney-runkle",
      "created_at": "2024-11-18T19:20:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1847128206"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 906,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +893,64 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (fast_memo_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                fast_memo_handler(self, value)\n+                return\n+\n+            if (fast_memo_handler := self._setattr_handler(name, value)) is not None:\n+                fast_memo_handler(self, value)  # call here to not memo on possibly unknown fields\n+                self.__pydantic_setattr_handlers__[name] = fast_memo_handler\n+\n+        def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, Any], None] | None:\n+            \"\"\"Returns a handler for setting an attribute on the model instance. This handler can be memoized to\n+            the class. Gives None when memoization is not safe, then the attribute is set directly.",
      "comment": "https://google.github.io/styleguide/pyguide.html#383-functions-and-methods",
      "comment_id": 1847128712,
      "user": "sydney-runkle",
      "created_at": "2024-11-18T19:21:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1847128712"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,6 +169,9 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n     This replaces `Model.__fields__` from Pydantic V1.\n     \"\"\"\n \n+    __pydantic_setattr_handlers__: ClassVar[Dict[str, Callable[[BaseModel, Any], None]]]  # noqa: UP006\n+    \"\"\"__setattr__ handlers. Used to speed up __setattr__.\"\"\"",
      "comment": "I think it's worth a bit more strength/detail in this comment, e.g.:\r\n```suggestion\r\n    \"\"\"__setattr__ handlers. Memoizing the setattr handlers leads to a dramatic performance improvement in `__setattr__`\"\"\"\r\n```\r\n(that suggestion might need reformatting.)",
      "comment_id": 1847168578,
      "user": "dmontagu",
      "created_at": "2024-11-18T19:54:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1847168578"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 897,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +893,64 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (fast_memo_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                fast_memo_handler(self, value)",
      "comment": "I think the word `fast` in the name of this variable is carrying some weight in terms of documenting what is going on here \u2014\u00a0it doesn't seem to be indicated explicitly that the reason for memoizing the attribute handler is purely for performance and isn't otherwise logically required. I mean, I know we have the docstring of `__pydantic_setattr_handlers__`, but that is far away from the implementing code and still doesn't make it clear that the current logic _only_ makes use of the memoization for performance reasons (and isn't otherwise dependent on the memoization), which may be useful context if we refactor this in the future.\r\n\r\nI don't really mind the word fast in the name, but I think either way we should add a comment here reiterating that the memoization is purely for performance reasons. And if we do, the word fast probably becomes less useful.",
      "comment_id": 1847174753,
      "user": "dmontagu",
      "created_at": "2024-11-18T19:57:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1847174753"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 897,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +893,64 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (fast_memo_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                fast_memo_handler(self, value)",
      "comment": "Done, simplified the name, it wasnt so pretty yet :) ",
      "comment_id": 1847190363,
      "user": "MarkusSintonen",
      "created_at": "2024-11-18T20:04:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1847190363"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,6 +169,9 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n     This replaces `Model.__fields__` from Pydantic V1.\n     \"\"\"\n \n+    __pydantic_setattr_handlers__: ClassVar[Dict[str, Callable[[BaseModel, Any], None]]]  # noqa: UP006\n+    \"\"\"__setattr__ handlers. Memoizing the setattr handlers leads to a dramatic performance improvement in `__setattr__`\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"`__setattr__` handlers. Memoizing the handlers leads to a dramatic performance improvement in `__setattr__`\"\"\"\r\n```",
      "comment_id": 1847215747,
      "user": "Viicos",
      "created_at": "2024-11-18T20:17:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1847215747"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 900,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +893,67 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                setattr_handler(self, value)\n+                return\n+\n+            if (setattr_handler := self._setattr_handler(name, value)) is not None:",
      "comment": "```suggestion\r\n            elif (setattr_handler := self._setattr_handler(name, value)) is not None:\r\n```",
      "comment_id": 1847216034,
      "user": "Viicos",
      "created_at": "2024-11-18T20:17:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1847216034"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,6 +81,20 @@\n _object_setattr = _model_construction.object_setattr\n \n \n+def _model_field_setattr_handler(model: BaseModel, name: str, val: Any) -> None:\n+    model.__dict__[name] = val\n+    model.__pydantic_fields_set__.add(name)\n+\n+\n+SIMPLE_SETATTR_HANDLERS: Mapping[str, Callable[[BaseModel, str, Any], None]] = {\n+    'model_field': _model_field_setattr_handler,\n+    'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # type: ignore\n+    'private': lambda model, name, val: model.__pydantic_private__.__setitem__(name, val),  # type: ignore",
      "comment": "```suggestion\r\n    'validate_assignment': lambda model, name, val: model.__pydantic_validator__.validate_assignment(model, name, val),  # pyright: ignore[reportAssignmentType]\r\n    'private': lambda model, name, val: model.__pydantic_private__.__setitem__(name, val),  # pyright: ignore[reportAssignmentType]\r\n```",
      "comment_id": 1848316231,
      "user": "Viicos",
      "created_at": "2024-11-19T12:58:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1848316231"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,6 +81,20 @@\n _object_setattr = _model_construction.object_setattr\n \n \n+def _model_field_setattr_handler(model: BaseModel, name: str, val: Any) -> None:\n+    model.__dict__[name] = val\n+    model.__pydantic_fields_set__.add(name)\n+\n+\n+SIMPLE_SETATTR_HANDLERS: Mapping[str, Callable[[BaseModel, str, Any], None]] = {",
      "comment": "```suggestion\r\n_SIMPLE_SETATTR_HANDLERS: Mapping[str, Callable[[BaseModel, str, Any], None]] = {\r\n```",
      "comment_id": 1848317608,
      "user": "Viicos",
      "created_at": "2024-11-19T12:59:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1848317608"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 921,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +907,62 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                setattr_handler(self, name, value)\n+            elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n+                setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n+                self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n+\n+        def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, Any, Any], None] | None:\n+            \"\"\"Get a handler for setting an attribute on the model instance.\n+\n+            Returns:\n+                A handler for setting an attribute on the model instance. Used for memoization of the handler.\n+                Gives None when memoization is not safe, then the attribute is set directly.",
      "comment": "```suggestion\r\n                Returns `None` when memoization is not safe, then the attribute is set directly.\r\n```",
      "comment_id": 1848320941,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T13:01:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1848320941"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 920,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +907,62 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                setattr_handler(self, name, value)\n+            elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n+                setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n+                self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n+\n+        def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, Any, Any], None] | None:\n+            \"\"\"Get a handler for setting an attribute on the model instance.\n+\n+            Returns:\n+                A handler for setting an attribute on the model instance. Used for memoization of the handler.",
      "comment": "Can you give a bit more context here for folks who might be diving into this code for the first time on memoization and why it's helpful? Feel free to put that in the main docstring description, thanks!",
      "comment_id": 1848321691,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T13:02:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1848321691"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 914,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +907,62 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                setattr_handler(self, name, value)\n+            elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n+                setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n+                self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access",
      "comment": "Maybe add a comment here that if `None` is returned, `_object_setattr` was used directly?",
      "comment_id": 1848325956,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T13:05:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1848325956"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 962,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +907,62 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                setattr_handler(self, name, value)\n+            elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n+                setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n+                self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n+\n+        def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, Any, Any], None] | None:\n+            \"\"\"Get a handler for setting an attribute on the model instance.\n+\n+            Returns:\n+                A handler for setting an attribute on the model instance. Used for memoization of the handler.\n+                Gives None when memoization is not safe, then the attribute is set directly.\n+            \"\"\"\n+            cls = self.__class__\n+            if name in cls.__class_vars__:\n                 raise AttributeError(\n-                    f'{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. '\n-                    f'If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.'\n+                    f'{name!r} is a ClassVar of `{cls.__name__}` and cannot be set on an instance. '\n+                    f'If you want to set a value on the class, use `{cls.__name__}.{name} = value`.'\n                 )\n             elif not _fields.is_valid_field_name(name):\n-                if self.__pydantic_private__ is None or name not in self.__private_attributes__:\n-                    _object_setattr(self, name, value)\n-                else:\n-                    attribute = self.__private_attributes__[name]\n+                if (attribute := cls.__private_attributes__.get(name)) is not None:\n                     if hasattr(attribute, '__set__'):\n-                        attribute.__set__(self, value)  # type: ignore\n+                        return lambda model, _name, val: attribute.__set__(model, val)\n                     else:\n-                        self.__pydantic_private__[name] = value\n-                return\n+                        return SIMPLE_SETATTR_HANDLERS['private']\n+                else:\n+                    _object_setattr(self, name, value)\n+                    return None  # Can not return memoized handler with possibly freeform attr names\n \n-            self._check_frozen(name, value)\n+            cls._check_frozen(name, value)\n \n-            attr = getattr(self.__class__, name, None)\n+            attr = getattr(cls, name, None)\n             # NOTE: We currently special case properties and `cached_property`, but we might need\n             # to generalize this to all data/non-data descriptors at some point. For non-data descriptors\n             # (such as `cached_property`), it isn't obvious though. `cached_property` caches the value\n             # to the instance's `__dict__`, but other non-data descriptors might do things differently.\n             if isinstance(attr, property):\n-                attr.__set__(self, value)\n+                return lambda model, _name, val: attr.__set__(model, val)\n             elif isinstance(attr, cached_property):\n-                self.__dict__[name] = value\n-            elif self.model_config.get('validate_assignment', None):\n-                self.__pydantic_validator__.validate_assignment(self, name, value)\n-            elif self.model_config.get('extra') != 'allow' and name not in self.__pydantic_fields__:\n-                # TODO - matching error\n-                raise ValueError(f'\"{self.__class__.__name__}\" object has no field \"{name}\"')\n-            elif self.model_config.get('extra') == 'allow' and name not in self.__pydantic_fields__:\n-                if self.model_extra and name in self.model_extra:\n-                    self.__pydantic_extra__[name] = value  # type: ignore\n+                return SIMPLE_SETATTR_HANDLERS['cached_property']\n+            elif cls.model_config.get('validate_assignment'):\n+                return SIMPLE_SETATTR_HANDLERS['validate_assignment']\n+            elif name not in cls.__pydantic_fields__:\n+                if cls.model_config.get('extra') != 'allow':\n+                    # TODO - matching error\n+                    raise ValueError(f'\"{cls.__name__}\" object has no field \"{name}\"')\n+                elif attr is None:\n+                    # attribute does not exist, so put it in extra\n+                    self.__pydantic_extra__[name] = value\n+                    return None  # Can not return memoized handler with possibly freeform attr names\n                 else:\n-                    try:\n-                        getattr(self, name)\n-                    except AttributeError:\n-                        # attribute does not already exist on instance, so put it in extra\n-                        self.__pydantic_extra__[name] = value  # type: ignore\n-                    else:\n-                        # attribute _does_ already exist on instance, and was not in extra, so update it\n-                        _object_setattr(self, name, value)\n+                    # attribute _does_ exist, and was not in extra, so update it\n+                    return SIMPLE_SETATTR_HANDLERS['extra_known']",
      "comment": "I'm a bit confused how we got this from the previous logic - don't we need to check `name in self.model_extra`?",
      "comment_id": 1848331176,
      "user": "sydney-runkle",
      "created_at": "2024-11-19T13:08:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1848331176"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10868,
      "file_path": "pydantic/main.py",
      "line": 962,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,53 +907,62 @@ def __getattr__(self, item: str) -> Any:\n                         raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n \n         def __setattr__(self, name: str, value: Any) -> None:\n-            if name in self.__class_vars__:\n+            if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n+                setattr_handler(self, name, value)\n+            elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n+                setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n+                self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n+\n+        def _setattr_handler(self, name: str, value: Any) -> Callable[[BaseModel, Any, Any], None] | None:\n+            \"\"\"Get a handler for setting an attribute on the model instance.\n+\n+            Returns:\n+                A handler for setting an attribute on the model instance. Used for memoization of the handler.\n+                Gives None when memoization is not safe, then the attribute is set directly.\n+            \"\"\"\n+            cls = self.__class__\n+            if name in cls.__class_vars__:\n                 raise AttributeError(\n-                    f'{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. '\n-                    f'If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.'\n+                    f'{name!r} is a ClassVar of `{cls.__name__}` and cannot be set on an instance. '\n+                    f'If you want to set a value on the class, use `{cls.__name__}.{name} = value`.'\n                 )\n             elif not _fields.is_valid_field_name(name):\n-                if self.__pydantic_private__ is None or name not in self.__private_attributes__:\n-                    _object_setattr(self, name, value)\n-                else:\n-                    attribute = self.__private_attributes__[name]\n+                if (attribute := cls.__private_attributes__.get(name)) is not None:\n                     if hasattr(attribute, '__set__'):\n-                        attribute.__set__(self, value)  # type: ignore\n+                        return lambda model, _name, val: attribute.__set__(model, val)\n                     else:\n-                        self.__pydantic_private__[name] = value\n-                return\n+                        return SIMPLE_SETATTR_HANDLERS['private']\n+                else:\n+                    _object_setattr(self, name, value)\n+                    return None  # Can not return memoized handler with possibly freeform attr names\n \n-            self._check_frozen(name, value)\n+            cls._check_frozen(name, value)\n \n-            attr = getattr(self.__class__, name, None)\n+            attr = getattr(cls, name, None)\n             # NOTE: We currently special case properties and `cached_property`, but we might need\n             # to generalize this to all data/non-data descriptors at some point. For non-data descriptors\n             # (such as `cached_property`), it isn't obvious though. `cached_property` caches the value\n             # to the instance's `__dict__`, but other non-data descriptors might do things differently.\n             if isinstance(attr, property):\n-                attr.__set__(self, value)\n+                return lambda model, _name, val: attr.__set__(model, val)\n             elif isinstance(attr, cached_property):\n-                self.__dict__[name] = value\n-            elif self.model_config.get('validate_assignment', None):\n-                self.__pydantic_validator__.validate_assignment(self, name, value)\n-            elif self.model_config.get('extra') != 'allow' and name not in self.__pydantic_fields__:\n-                # TODO - matching error\n-                raise ValueError(f'\"{self.__class__.__name__}\" object has no field \"{name}\"')\n-            elif self.model_config.get('extra') == 'allow' and name not in self.__pydantic_fields__:\n-                if self.model_extra and name in self.model_extra:\n-                    self.__pydantic_extra__[name] = value  # type: ignore\n+                return SIMPLE_SETATTR_HANDLERS['cached_property']\n+            elif cls.model_config.get('validate_assignment'):\n+                return SIMPLE_SETATTR_HANDLERS['validate_assignment']\n+            elif name not in cls.__pydantic_fields__:\n+                if cls.model_config.get('extra') != 'allow':\n+                    # TODO - matching error\n+                    raise ValueError(f'\"{cls.__name__}\" object has no field \"{name}\"')\n+                elif attr is None:\n+                    # attribute does not exist, so put it in extra\n+                    self.__pydantic_extra__[name] = value\n+                    return None  # Can not return memoized handler with possibly freeform attr names\n                 else:\n-                    try:\n-                        getattr(self, name)\n-                    except AttributeError:\n-                        # attribute does not already exist on instance, so put it in extra\n-                        self.__pydantic_extra__[name] = value  # type: ignore\n-                    else:\n-                        # attribute _does_ already exist on instance, and was not in extra, so update it\n-                        _object_setattr(self, name, value)\n+                    # attribute _does_ exist, and was not in extra, so update it\n+                    return SIMPLE_SETATTR_HANDLERS['extra_known']",
      "comment": "The check was redundant, as we know the extra attribute needs to go to the special `__pydantic_extra__` when model class does not define the attribute. There is no need to check `model_extra` (which just checks `__pydantic_extra__`)",
      "comment_id": 1848791785,
      "user": "MarkusSintonen",
      "created_at": "2024-11-19T17:39:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10868#discussion_r1848791785"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10856,
      "file_path": "pydantic/networks.py",
      "line": 494,
      "side": "LEFT",
      "diff_hunk": "@@ -487,13 +491,8 @@ class AnyHttpUrl(_BaseUrl):\n \n     _constraints = UrlConstraints(host_required=True, allowed_schemes=['http', 'https'])\n \n-    @property\n-    def host(self) -> str:\n-        \"\"\"The required URL host.\"\"\"\n-        return self._url.host  # type: ignore\n-",
      "comment": "We can remove the added `host` specs that overrode the `str | None` return type from `_BaseUrl`, as `AnyUrl` enforces `str`",
      "comment_id": 1844120688,
      "user": "sydney-runkle",
      "created_at": "2024-11-15T16:14:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/10856#discussion_r1844120688"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10856,
      "file_path": "pydantic/networks.py",
      "line": 614,
      "side": "RIGHT",
      "diff_hunk": "@@ -610,16 +599,21 @@ def host(self) -> str:\n         return self._url.host  # type: ignore\n \n \n-class FileUrl(_BaseUrl):\n+class FileUrl(AnyUrl):\n     \"\"\"A type that will accept any file URL.\n \n     * Host not required\n     \"\"\"\n \n     _constraints = UrlConstraints(allowed_schemes=['file'])\n \n+    @property\n+    def host(self) -> str | None:  # pyright: ignore[reportIncompatibleMethodOverride]\n+        \"\"\"The host part of the URL, or `None`.\"\"\"\n+        return self._url.host\n+",
      "comment": "Have to add this for the case where `host_required=Fals` because `AnyUrl` has `host` typed as `str`, so we indicate the optional nature here.",
      "comment_id": 1844121410,
      "user": "sydney-runkle",
      "created_at": "2024-11-15T16:14:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10856#discussion_r1844121410"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1899,
      "side": "RIGHT",
      "diff_hunk": "@@ -1891,20 +1891,21 @@ def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.\n \n         bound = typevar.__bound__\n         constraints = typevar.__constraints__\n+        typevar_default_value = getattr(typevar, '__default__', None)",
      "comment": "```suggestion\r\n        default = getattr(typevar, '__default__', None)\r\n```",
      "comment_id": 1842459140,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T15:50:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1842459140"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1912,
      "side": "RIGHT",
      "diff_hunk": "@@ -1891,20 +1891,21 @@ def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.\n \n         bound = typevar.__bound__\n         constraints = typevar.__constraints__\n+        typevar_default_value = getattr(typevar, '__default__', None)\n \n         try:\n             typevar_has_default = typevar.has_default()  # type: ignore\n         except AttributeError:\n             # could still have a default if it's an old version of typing_extensions.TypeVar\n-            typevar_has_default = getattr(typevar, '__default__', None) is not None\n+            typevar_has_default = typevar_default_value is not None\n \n-        if (bound is not None) + (len(constraints) != 0) + typevar_has_default > 1:\n+        if len(constraints) != 0 and (bound is not None or typevar_has_default):\n             raise NotImplementedError(\n-                'Pydantic does not support mixing more than one of TypeVar bounds, constraints and defaults'\n+                'Pydantic does not support mixing more than one of TypeVar constraints and default/bound'\n             )\n \n         if typevar_has_default:",
      "comment": "I don't think we've fully added support here - if both `bound` and `default` are specified (and different), we need to figure out how to generate the right schema...",
      "comment_id": 1842464524,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T15:53:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1842464524"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1905,
      "side": "RIGHT",
      "diff_hunk": "@@ -1891,20 +1891,21 @@ def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.\n \n         bound = typevar.__bound__\n         constraints = typevar.__constraints__\n+        typevar_default_value = getattr(typevar, '__default__', None)\n \n         try:\n             typevar_has_default = typevar.has_default()  # type: ignore\n         except AttributeError:\n             # could still have a default if it's an old version of typing_extensions.TypeVar\n-            typevar_has_default = getattr(typevar, '__default__', None) is not None\n+            typevar_has_default = typevar_default_value is not None",
      "comment": "We can probably remove the `typevar_has_default` logic here and just go with the above",
      "comment_id": 1842465365,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T15:54:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1842465365"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1899,
      "side": "RIGHT",
      "diff_hunk": "@@ -1891,20 +1891,21 @@ def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.\n \n         bound = typevar.__bound__\n         constraints = typevar.__constraints__\n+        typevar_default_value = getattr(typevar, '__default__', None)",
      "comment": "Is it possible `typevar.__default__` could be `None`? Do we need to use a different sentinel here?",
      "comment_id": 1842465836,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T15:54:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1842465836"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1899,
      "side": "RIGHT",
      "diff_hunk": "@@ -1891,20 +1891,21 @@ def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.\n \n         bound = typevar.__bound__\n         constraints = typevar.__constraints__\n+        typevar_default_value = getattr(typevar, '__default__', None)",
      "comment": "Yes, that's why `typing.NoDefault` was introduced. However, this is not an issue anymore with the implementation I suggested below",
      "comment_id": 1842549276,
      "user": "Viicos",
      "created_at": "2024-11-14T16:32:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1842549276"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "tests/test_generics.py",
      "line": 2849,
      "side": "RIGHT",
      "diff_hunk": "@@ -2836,14 +2836,93 @@ class MyErrorDetails(ErrorDetails):\n     }\n \n \n-def test_mix_default_and_constraints() -> None:\n-    T = TypingExtensionsTypeVar('T', str, int, default=str)\n+def test_serialize_typevars_default_and_bound_with_user_model() -> None:\n+    class MyErrorDetails(BaseModel):\n+        bar: str\n+\n+    class ExtendedMyErrorDetails(MyErrorDetails):\n+        foo: str\n+\n+    class MoreExtendedMyErrorDetails(ExtendedMyErrorDetails):\n+        suu: str\n \n-    msg = 'Pydantic does not support mixing more than one of TypeVar bounds, constraints and defaults'\n-    with pytest.raises(NotImplementedError, match=msg):\n+    type_var = TypingExtensionsTypeVar('type_var', bound=MyErrorDetails, default=ExtendedMyErrorDetails)",
      "comment": "```suggestion\r\n    T = TypingExtensionsTypeVar('T', bound=MyErrorDetails, default=ExtendedMyErrorDetails)\r\n```",
      "comment_id": 1843474054,
      "user": "Viicos",
      "created_at": "2024-11-15T09:34:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1843474054"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "tests/test_generics.py",
      "line": 2853,
      "side": "RIGHT",
      "diff_hunk": "@@ -2836,14 +2836,93 @@ class MyErrorDetails(ErrorDetails):\n     }\n \n \n-def test_mix_default_and_constraints() -> None:\n-    T = TypingExtensionsTypeVar('T', str, int, default=str)\n+def test_serialize_typevars_default_and_bound_with_user_model() -> None:\n+    class MyErrorDetails(BaseModel):\n+        bar: str\n+\n+    class ExtendedMyErrorDetails(MyErrorDetails):\n+        foo: str\n+\n+    class MoreExtendedMyErrorDetails(ExtendedMyErrorDetails):\n+        suu: str\n \n-    msg = 'Pydantic does not support mixing more than one of TypeVar bounds, constraints and defaults'\n-    with pytest.raises(NotImplementedError, match=msg):\n+    type_var = TypingExtensionsTypeVar('type_var', bound=MyErrorDetails, default=ExtendedMyErrorDetails)\n \n-        class _(BaseModel, Generic[T]):\n-            x: T\n+    class Error(BaseModel, Generic[type_var]):\n+        message: str\n+        details: type_var",
      "comment": "```suggestion\r\n    class Error(BaseModel, Generic[T]):\r\n        message: str\r\n        details: T\r\n```",
      "comment_id": 1843474416,
      "user": "Viicos",
      "created_at": "2024-11-15T09:34:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1843474416"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "tests/test_generics.py",
      "line": 2919,
      "side": "RIGHT",
      "diff_hunk": "@@ -2836,14 +2836,93 @@ class MyErrorDetails(ErrorDetails):\n     }\n \n \n-def test_mix_default_and_constraints() -> None:\n-    T = TypingExtensionsTypeVar('T', str, int, default=str)\n+def test_serialize_typevars_default_and_bound_with_user_model() -> None:\n+    class MyErrorDetails(BaseModel):\n+        bar: str\n+\n+    class ExtendedMyErrorDetails(MyErrorDetails):\n+        foo: str\n+\n+    class MoreExtendedMyErrorDetails(ExtendedMyErrorDetails):\n+        suu: str\n \n-    msg = 'Pydantic does not support mixing more than one of TypeVar bounds, constraints and defaults'\n-    with pytest.raises(NotImplementedError, match=msg):\n+    type_var = TypingExtensionsTypeVar('type_var', bound=MyErrorDetails, default=ExtendedMyErrorDetails)\n \n-        class _(BaseModel, Generic[T]):\n-            x: T\n+    class Error(BaseModel, Generic[type_var]):\n+        message: str\n+        details: type_var\n+\n+    # bound small parent model\n+    sample_error = Error[MyErrorDetails](\n+        message='We just had an error',\n+        details=MyErrorDetails(foo='var', bar='baz', suu='suu'),\n+    )\n+\n+    assert sample_error.details.model_dump() == {\n+        'bar': 'baz',\n+    }\n+    assert sample_error.model_dump() == {\n+        'message': 'We just had an error',\n+        'details': {\n+            'bar': 'baz',\n+        },\n+    }\n+\n+    # default middle child model\n+    sample_error = Error(\n+        message='We just had an error',\n+        details=MoreExtendedMyErrorDetails(foo='var', bar='baz', suu='suu'),\n+    )\n+\n+    assert sample_error.details.model_dump() == {\n+        'foo': 'var',\n+        'bar': 'baz',\n+        'suu': 'suu',\n+    }\n+    assert sample_error.model_dump() == {\n+        'message': 'We just had an error',\n+        'details': {'foo': 'var', 'bar': 'baz'},\n+    }\n+\n+    # bound big child model\n+    sample_error = Error[MoreExtendedMyErrorDetails](\n+        message='We just had an error',\n+        details=MoreExtendedMyErrorDetails(foo='var', bar='baz', suu='suu'),\n+    )\n+\n+    assert sample_error.details.model_dump() == {\n+        'foo': 'var',\n+        'bar': 'baz',\n+        'suu': 'suu',\n+    }\n+    assert sample_error.model_dump() == {\n+        'message': 'We just had an error',\n+        'details': {\n+            'foo': 'var',\n+            'bar': 'baz',\n+            'suu': 'suu',\n+        },\n+    }\n+\n+\n+def test_typevars_default_model_validation_error() -> None:\n+    class MyErrorDetails(BaseModel):\n+        bar: str\n+\n+    class ExtendedMyErrorDetails(MyErrorDetails):\n+        foo: str\n+\n+    type_var = TypingExtensionsTypeVar('type_var', bound=MyErrorDetails, default=ExtendedMyErrorDetails)\n+\n+    class Error(BaseModel, Generic[type_var]):\n+        message: str\n+        details: type_var",
      "comment": "```suggestion\r\n    T = TypingExtensionsTypeVar('T', bound=MyErrorDetails, default=ExtendedMyErrorDetails)\r\n\r\n    class Error(BaseModel, Generic[T]):\r\n        message: str\r\n        details: T\r\n```",
      "comment_id": 1843487277,
      "user": "Viicos",
      "created_at": "2024-11-15T09:41:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1843487277"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1902,
      "side": "RIGHT",
      "diff_hunk": "@@ -1892,34 +1892,27 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n         )\n \n     def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.CoreSchema:\n-        assert isinstance(typevar, typing.TypeVar)\n-\n-        bound = typevar.__bound__\n-        constraints = typevar.__constraints__\n-\n         try:\n-            typevar_has_default = typevar.has_default()  # type: ignore\n+            has_default = typevar.has_default()\n         except AttributeError:\n-            # could still have a default if it's an old version of typing_extensions.TypeVar\n-            typevar_has_default = getattr(typevar, '__default__', None) is not None\n+            # Happens if using `typing.TypeVar` on Python < 3.13\n+            pass\n+        else:\n+            if has_default:\n+                return self.generate_schema(getattr(typevar, '__default__', None))",
      "comment": "Why not:\r\n\r\n```py\r\nif (default := getattr(typevar, '__default__', typing.NoDefault)) is not typing.NoDefault:\r\n    return self.generate_schema(default)\r\n```\r\n\r\nwdyt @Viicos\r\n\r\nOtherwise, LGTM, thanks!",
      "comment_id": 1844258061,
      "user": "sydney-runkle",
      "created_at": "2024-11-15T17:56:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1844258061"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1902,
      "side": "RIGHT",
      "diff_hunk": "@@ -1892,34 +1892,27 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n         )\n \n     def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.CoreSchema:\n-        assert isinstance(typevar, typing.TypeVar)\n-\n-        bound = typevar.__bound__\n-        constraints = typevar.__constraints__\n-\n         try:\n-            typevar_has_default = typevar.has_default()  # type: ignore\n+            has_default = typevar.has_default()\n         except AttributeError:\n-            # could still have a default if it's an old version of typing_extensions.TypeVar\n-            typevar_has_default = getattr(typevar, '__default__', None) is not None\n+            # Happens if using `typing.TypeVar` on Python < 3.13\n+            pass\n+        else:\n+            if has_default:\n+                return self.generate_schema(getattr(typevar, '__default__', None))",
      "comment": "Because this would require checking for both `typing.NoDefault` and `typing_extensions.NoDefault` (as per https://github.com/pydantic/pydantic/pull/10725).\r\n\r\nThis adds a bit of redundancy but `has_default()` is implemented in C anyway so the performance cost is marginal.",
      "comment_id": 1844270900,
      "user": "Viicos",
      "created_at": "2024-11-15T18:06:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1844270900"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1902,
      "side": "RIGHT",
      "diff_hunk": "@@ -1892,34 +1892,27 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n         )\n \n     def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.CoreSchema:\n-        assert isinstance(typevar, typing.TypeVar)\n-\n-        bound = typevar.__bound__\n-        constraints = typevar.__constraints__\n-\n         try:\n-            typevar_has_default = typevar.has_default()  # type: ignore\n+            has_default = typevar.has_default()\n         except AttributeError:\n-            # could still have a default if it's an old version of typing_extensions.TypeVar\n-            typevar_has_default = getattr(typevar, '__default__', None) is not None\n+            # Happens if using `typing.TypeVar` on Python < 3.13\n+            pass\n+        else:\n+            if has_default:\n+                return self.generate_schema(getattr(typevar, '__default__', None))",
      "comment": "```suggestion\r\n                return self.generate_schema(typevar.__default__)\r\n```",
      "comment_id": 1844271589,
      "user": "Viicos",
      "created_at": "2024-11-15T18:07:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1844271589"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1902,
      "side": "RIGHT",
      "diff_hunk": "@@ -1892,34 +1892,27 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n         )\n \n     def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.CoreSchema:\n-        assert isinstance(typevar, typing.TypeVar)\n-\n-        bound = typevar.__bound__\n-        constraints = typevar.__constraints__\n-\n         try:\n-            typevar_has_default = typevar.has_default()  # type: ignore\n+            has_default = typevar.has_default()\n         except AttributeError:\n-            # could still have a default if it's an old version of typing_extensions.TypeVar\n-            typevar_has_default = getattr(typevar, '__default__', None) is not None\n+            # Happens if using `typing.TypeVar` on Python < 3.13\n+            pass\n+        else:\n+            if has_default:\n+                return self.generate_schema(getattr(typevar, '__default__', None))",
      "comment": "This will raise pyright error and we must do comment to ignore this. `getattr` approach looks cleaner in this way for me.\r\nWhat do you think?",
      "comment_id": 1844276382,
      "user": "FyZzyss",
      "created_at": "2024-11-15T18:11:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1844276382"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1905,
      "side": "RIGHT",
      "diff_hunk": "@@ -1892,34 +1892,27 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n         )\n \n     def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.CoreSchema:\n-        assert isinstance(typevar, typing.TypeVar)\n-\n-        bound = typevar.__bound__\n-        constraints = typevar.__constraints__\n-\n         try:\n-            typevar_has_default = typevar.has_default()  # type: ignore\n+            has_default = typevar.has_default()\n         except AttributeError:\n-            # could still have a default if it's an old version of typing_extensions.TypeVar\n-            typevar_has_default = getattr(typevar, '__default__', None) is not None\n+            # Happens if using `typing.TypeVar` on Python < 3.13\n+            pass\n+        else:\n+            if has_default:\n+                return self.generate_schema(typevar.__default__)\n \n-        if (bound is not None) + (len(constraints) != 0) + typevar_has_default > 1:\n-            raise NotImplementedError(\n-                'Pydantic does not support mixing more than one of TypeVar bounds, constraints and defaults'\n-            )\n+        if typevar.__constraints__:\n+            return self._union_schema(typing.Union[typevar.__constraints__])",
      "comment": "```suggestion\r\n        if (constraints := typevar.__constraints__):\r\n            return self._union_schema(typing.Union[constraints])\r\n```",
      "comment_id": 1845234695,
      "user": "sydney-runkle",
      "created_at": "2024-11-16T20:32:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1845234695"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10789,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1908,
      "side": "RIGHT",
      "diff_hunk": "@@ -1892,34 +1892,27 @@ def _call_schema(self, function: ValidateCallSupportedTypes) -> core_schema.Call\n         )\n \n     def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.CoreSchema:\n-        assert isinstance(typevar, typing.TypeVar)\n-\n-        bound = typevar.__bound__\n-        constraints = typevar.__constraints__\n-\n         try:\n-            typevar_has_default = typevar.has_default()  # type: ignore\n+            has_default = typevar.has_default()\n         except AttributeError:\n-            # could still have a default if it's an old version of typing_extensions.TypeVar\n-            typevar_has_default = getattr(typevar, '__default__', None) is not None\n+            # Happens if using `typing.TypeVar` on Python < 3.13\n+            pass\n+        else:\n+            if has_default:\n+                return self.generate_schema(typevar.__default__)\n \n-        if (bound is not None) + (len(constraints) != 0) + typevar_has_default > 1:\n-            raise NotImplementedError(\n-                'Pydantic does not support mixing more than one of TypeVar bounds, constraints and defaults'\n-            )\n+        if typevar.__constraints__:\n+            return self._union_schema(typing.Union[typevar.__constraints__])\n \n-        if typevar_has_default:\n-            return self.generate_schema(typevar.__default__)  # type: ignore\n-        elif constraints:\n-            return self._union_schema(typing.Union[constraints])  # type: ignore\n-        elif bound:\n-            schema = self.generate_schema(bound)\n+        if typevar.__bound__:\n+            schema = self.generate_schema(typevar.__bound__)",
      "comment": "```suggestion\r\n        if (bound := typevar.__bound__):\r\n            schema = self.generate_schema(bound)\r\n```",
      "comment_id": 1845234718,
      "user": "sydney-runkle",
      "created_at": "2024-11-16T20:33:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10789#discussion_r1845234718"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10763,
      "file_path": "tests/test_types.py",
      "line": 1810,
      "side": "RIGHT",
      "diff_hunk": "@@ -1806,9 +1806,18 @@ class MyModel(BaseModel):\n     'kwargs,type_,a',\n     [\n         ({'pattern': '^foo$'}, int, 1),\n-        ({'gt': 0}, conlist(int, min_length=4), [1, 2, 3, 4, 5]),\n-        ({'gt': 0}, conset(int, min_length=4), {1, 2, 3, 4, 5}),\n-        ({'gt': 0}, confrozenset(int, min_length=4), frozenset({1, 2, 3, 4, 5})),\n+        *[\n+            ({constraint_name: 0}, conlist(int, min_length=4), [1, 2, 3, 4, 5])",
      "comment": "What's the value in having the `conlist` and `min_length` here? Can we just do `list[int]`, `set[int]`, etc?",
      "comment_id": 1842442626,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T15:40:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/10763#discussion_r1842442626"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10763,
      "file_path": "tests/test_types.py",
      "line": 1841,
      "side": "RIGHT",
      "diff_hunk": "@@ -1822,11 +1831,35 @@ class Foo(BaseModel):\n         Foo(a=a)\n \n \n-def test_invalid_decimal_constraint():\n+@pytest.mark.parametrize(\n+    'kwargs',\n+    [\n+        {'max_length': 5},\n+        {'min_length': 5},\n+    ],\n+)\n+def test_invalid_decimal_constraint(kwargs):",
      "comment": "I think this could be consolidated into the test above...",
      "comment_id": 1842444199,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T15:41:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/10763#discussion_r1842444199"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10763,
      "file_path": "tests/test_validators.py",
      "line": 255,
      "side": "RIGHT",
      "diff_hunk": "@@ -251,6 +252,18 @@ class Model(BaseModel):\n     ]\n \n \n+@pytest.mark.parametrize('value', ['wrong_format'])",
      "comment": "We don't need to parametrize here, can just use the value \ud83d\udc4d ",
      "comment_id": 1842445253,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T15:41:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10763#discussion_r1842445253"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10763,
      "file_path": "tests/test_types.py",
      "line": 1857,
      "side": "RIGHT",
      "diff_hunk": "@@ -1822,11 +1831,35 @@ class Foo(BaseModel):\n         Foo(a=a)\n \n \n-def test_invalid_decimal_constraint():\n+@pytest.mark.parametrize(\n+    'kwargs',\n+    [\n+        {'max_length': 5},\n+        {'min_length': 5},\n+    ],\n+)\n+def test_invalid_decimal_constraint(kwargs):\n+    class Foo(BaseModel):\n+        a: Decimal = Field(title='A title', description='A description', **kwargs)\n+\n+    constraint_name = list(kwargs.keys())[0]\n+    with pytest.raises(TypeError, match=f\"Unable to apply constraint '{constraint_name}' to supplied value 1.0\"):\n+        Foo(a=Decimal('1.0'))\n+\n+\n+@pytest.mark.parametrize(\n+    'kwargs',\n+    [\n+        {'max_digits': 5},\n+        {'decimal_places': 5},\n+    ],\n+)\n+def test_decimal_type_error(kwargs):",
      "comment": "Same as above - let's consolidate into one test :)",
      "comment_id": 1842446626,
      "user": "sydney-runkle",
      "created_at": "2024-11-14T15:42:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/10763#discussion_r1842446626"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10763,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 392,
      "side": "RIGHT",
      "diff_hunk": "@@ -386,10 +387,11 @@ def max_digits_validator(x: Any, max_digits: Any) -> Any:\n \n \n def decimal_places_validator(x: Any, decimal_places: Any) -> Any:\n-    decimal_places_, _ = _extract_decimal_digits_info(x)\n-    normalized_decimal_places, _ = _extract_decimal_digits_info(x.normalize())\n-\n     try:\n+        if not isinstance(x, Decimal):\n+            raise TypeError(f'Expected Decimal, received {type(x).__name__}')",
      "comment": "I ended up checking the Decimal type here instead\r\nhttps://github.com/pydantic/pydantic/blob/f6919b5ded203cf390d3df7863cbbf1022c3b7cf/pydantic/_internal/_validators.py#L374",
      "comment_id": 1843181666,
      "user": "tkasuz",
      "created_at": "2024-11-15T04:42:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/10763#discussion_r1843181666"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10763,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 370,
      "side": "LEFT",
      "diff_hunk": "@@ -346,35 +346,38 @@ def _extract_decimal_digits_info(decimal: Decimal) -> tuple[int, int]:\n     Though this could be divided into two separate functions, the logic is easier to follow if we couple the computation\n     of the number of decimals and digits together.\n     \"\"\"\n-    decimal_tuple = decimal.as_tuple()\n-    if not isinstance(decimal_tuple.exponent, int):\n-        raise TypeError(f'Unable to extract decimal digits info from supplied value {decimal}')\n-    exponent = decimal_tuple.exponent\n-    num_digits = len(decimal_tuple.digits)\n-\n-    if exponent >= 0:\n-        # A positive exponent adds that many trailing zeros\n-        # Ex: digit_tuple=(1, 2, 3), exponent=2 -> 12300 -> 0 decimal places, 5 digits\n-        num_digits += exponent\n-        decimal_places = 0\n-    else:\n-        # If the absolute value of the negative exponent is larger than the\n-        # number of digits, then it's the same as the number of digits,\n-        # because it'll consume all the digits in digit_tuple and then\n-        # add abs(exponent) - len(digit_tuple) leading zeros after the decimal point.\n-        # Ex: digit_tuple=(1, 2, 3), exponent=-2 -> 1.23 -> 2 decimal places, 3 digits\n-        # Ex: digit_tuple=(1, 2, 3), exponent=-4 -> 0.0123 -> 4 decimal places, 4 digits\n-        decimal_places = abs(exponent)\n-        num_digits = max(num_digits, decimal_places)\n+    try:\n+        decimal_tuple = decimal.as_tuple()\n \n-    return decimal_places, num_digits",
      "comment": "Can we leave this as is? What `AttributeError` might occur here?",
      "comment_id": 1843950691,
      "user": "sydney-runkle",
      "created_at": "2024-11-15T14:54:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10763#discussion_r1843950691"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10763,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 370,
      "side": "LEFT",
      "diff_hunk": "@@ -346,35 +346,38 @@ def _extract_decimal_digits_info(decimal: Decimal) -> tuple[int, int]:\n     Though this could be divided into two separate functions, the logic is easier to follow if we couple the computation\n     of the number of decimals and digits together.\n     \"\"\"\n-    decimal_tuple = decimal.as_tuple()\n-    if not isinstance(decimal_tuple.exponent, int):\n-        raise TypeError(f'Unable to extract decimal digits info from supplied value {decimal}')\n-    exponent = decimal_tuple.exponent\n-    num_digits = len(decimal_tuple.digits)\n-\n-    if exponent >= 0:\n-        # A positive exponent adds that many trailing zeros\n-        # Ex: digit_tuple=(1, 2, 3), exponent=2 -> 12300 -> 0 decimal places, 5 digits\n-        num_digits += exponent\n-        decimal_places = 0\n-    else:\n-        # If the absolute value of the negative exponent is larger than the\n-        # number of digits, then it's the same as the number of digits,\n-        # because it'll consume all the digits in digit_tuple and then\n-        # add abs(exponent) - len(digit_tuple) leading zeros after the decimal point.\n-        # Ex: digit_tuple=(1, 2, 3), exponent=-2 -> 1.23 -> 2 decimal places, 3 digits\n-        # Ex: digit_tuple=(1, 2, 3), exponent=-4 -> 0.0123 -> 4 decimal places, 4 digits\n-        decimal_places = abs(exponent)\n-        num_digits = max(num_digits, decimal_places)\n+    try:\n+        decimal_tuple = decimal.as_tuple()\n \n-    return decimal_places, num_digits",
      "comment": "If the `decimal` argument is not a `Decimal` type, which is accepted as Any in the root function, an `AttributeError` might occur because the as_tuple method may not exist",
      "comment_id": 1844739933,
      "user": "tkasuz",
      "created_at": "2024-11-16T01:09:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10763#discussion_r1844739933"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10763,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 370,
      "side": "LEFT",
      "diff_hunk": "@@ -346,35 +346,38 @@ def _extract_decimal_digits_info(decimal: Decimal) -> tuple[int, int]:\n     Though this could be divided into two separate functions, the logic is easier to follow if we couple the computation\n     of the number of decimals and digits together.\n     \"\"\"\n-    decimal_tuple = decimal.as_tuple()\n-    if not isinstance(decimal_tuple.exponent, int):\n-        raise TypeError(f'Unable to extract decimal digits info from supplied value {decimal}')\n-    exponent = decimal_tuple.exponent\n-    num_digits = len(decimal_tuple.digits)\n-\n-    if exponent >= 0:\n-        # A positive exponent adds that many trailing zeros\n-        # Ex: digit_tuple=(1, 2, 3), exponent=2 -> 12300 -> 0 decimal places, 5 digits\n-        num_digits += exponent\n-        decimal_places = 0\n-    else:\n-        # If the absolute value of the negative exponent is larger than the\n-        # number of digits, then it's the same as the number of digits,\n-        # because it'll consume all the digits in digit_tuple and then\n-        # add abs(exponent) - len(digit_tuple) leading zeros after the decimal point.\n-        # Ex: digit_tuple=(1, 2, 3), exponent=-2 -> 1.23 -> 2 decimal places, 3 digits\n-        # Ex: digit_tuple=(1, 2, 3), exponent=-4 -> 0.0123 -> 4 decimal places, 4 digits\n-        decimal_places = abs(exponent)\n-        num_digits = max(num_digits, decimal_places)\n+    try:\n+        decimal_tuple = decimal.as_tuple()\n \n-    return decimal_places, num_digits",
      "comment": "Would it be better to change the argument type to `Any` and add another `assert` to check if the type is `Decimal`? \ud83e\udd14",
      "comment_id": 1844740265,
      "user": "tkasuz",
      "created_at": "2024-11-16T01:10:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10763#discussion_r1844740265"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1224,
      "side": "LEFT",
      "diff_hunk": "@@ -1215,11 +1215,15 @@ def _common_field_schema(  # C901\n     ) -> _CommonField:\n         # Update FieldInfo annotation if appropriate:\n         FieldInfo = import_cached_field_info()\n-        if has_instance_in_type(field_info.annotation, (ForwardRef, str)):",
      "comment": "The interesting part is that we remove the call to `has_instance_in_type` here.",
      "comment_id": 1829691749,
      "user": "Viicos",
      "created_at": "2024-11-05T16:49:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1829691749"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1229,
      "side": "RIGHT",
      "diff_hunk": "@@ -1215,11 +1215,15 @@ def _common_field_schema(  # C901\n     ) -> _CommonField:\n         # Update FieldInfo annotation if appropriate:\n         FieldInfo = import_cached_field_info()\n-        if has_instance_in_type(field_info.annotation, (ForwardRef, str)):\n-            # TODO Can we use field_info.apply_typevars_map here? Shouldn't we use lenient=False?\n-            evaluated = _typing_extra.eval_type(field_info.annotation, *self._types_namespace, lenient=True)\n+        if not field_info.evaluated:\n+            # TODO Can we use field_info.apply_typevars_map here?\n+            try:\n+                evaluated = _typing_extra.eval_type(field_info.annotation, *self._types_namespace)\n+            except NameError as e:\n+                raise PydanticUndefinedAnnotation.from_name_error(e) from e",
      "comment": "This pattern of reraising is quite common and could be made in a single function, but postponing as we might do more refactors on the class soon.",
      "comment_id": 1829693610,
      "user": "Viicos",
      "created_at": "2024-11-05T16:50:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1829693610"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1348,
      "side": "LEFT",
      "diff_hunk": "@@ -1338,12 +1342,13 @@ def _type_alias_type_schema(self, obj: TypeAliasType) -> CoreSchema:\n                 return maybe_schema\n \n             origin: TypeAliasType = get_origin(obj) or obj\n-\n-            annotation = origin.__value__",
      "comment": "Moved below, as accessing the `__value__` attribute will trigger the evaluation of the annotation, and thus this can raise a `NameError`. The `eval_type` call is still necessary though, as you can have explicit string references inside a a type alias type.",
      "comment_id": 1829695284,
      "user": "Viicos",
      "created_at": "2024-11-05T16:51:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1829695284"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -225,17 +225,54 @@ def parent_frame_namespace(*, parent_depth: int = 2, force: bool = False) -> dic\n     return frame.f_locals\n \n \n+def _type_convert(arg: Any) -> Any:\n+    \"\"\"Convert `None` to `NoneType` and strings to `ForwardRef` instances.\n+\n+    This is a backport of the private `typing._type_convert` function. When\n+    evaluating a type, `ForwardRef._evaluate` ends up being called, and is\n+    responsible for making this conversion. However, we still have to apply\n+    it for the first argument passed to our type evaluation functions, similarly\n+    to the `typing.get_type_hints` function.\n+    \"\"\"\n+    if arg is None:\n+        return NoneType\n+    if isinstance(arg, str):\n+        # Like `typing.get_type_hints`, assume the arg can be in any context,\n+        # hence the proper `is_argument` and `is_class` args:\n+        return _make_forward_ref(arg, is_argument=False, is_class=True)\n+    return arg\n+\n+\n+@overload",
      "comment": "I'm usually not a fan of having overloads with a different return value. It is a sign that this function should actually be split in two. I spent some (too much in fact) time figuring out a good API, but couldn't find a clean way to do so. Note that I split the eval_type function in two, as it led to a really ugly implementation.",
      "comment_id": 1829700329,
      "user": "Viicos",
      "created_at": "2024-11-05T16:55:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1829700329"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -225,17 +225,54 @@ def parent_frame_namespace(*, parent_depth: int = 2, force: bool = False) -> dic\n     return frame.f_locals\n \n \n+def _type_convert(arg: Any) -> Any:\n+    \"\"\"Convert `None` to `NoneType` and strings to `ForwardRef` instances.\n+\n+    This is a backport of the private `typing._type_convert` function. When\n+    evaluating a type, `ForwardRef._evaluate` ends up being called, and is\n+    responsible for making this conversion. However, we still have to apply\n+    it for the first argument passed to our type evaluation functions, similarly\n+    to the `typing.get_type_hints` function.\n+    \"\"\"\n+    if arg is None:\n+        return NoneType\n+    if isinstance(arg, str):\n+        # Like `typing.get_type_hints`, assume the arg can be in any context,\n+        # hence the proper `is_argument` and `is_class` args:\n+        return _make_forward_ref(arg, is_argument=False, is_class=True)\n+    return arg\n+\n+\n+@overload\n def get_cls_type_hints(\n-    obj: type[Any], *, ns_resolver: NsResolver | None = None, lenient: bool = False\n-) -> dict[str, Any]:\n+    obj: type[Any],\n+    *,\n+    ns_resolver: NsResolver | None = None,\n+    lenient: Literal[True],\n+) -> dict[str, tuple[Any, bool]]: ...\n+@overload\n+def get_cls_type_hints(\n+    obj: type[Any],\n+    *,\n+    ns_resolver: NsResolver | None = None,\n+    lenient: Literal[False] = ...,\n+) -> dict[str, Any]: ...\n+def get_cls_type_hints(\n+    obj: type[Any],\n+    *,\n+    ns_resolver: NsResolver | None = None,\n+    lenient: bool = False,",
      "comment": "Why not `Literal[False]` to be consistent with the above?",
      "comment_id": 1831894841,
      "user": "sydney-runkle",
      "created_at": "2024-11-07T00:31:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1831894841"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 460,
      "side": "RIGHT",
      "diff_hunk": "@@ -225,17 +225,54 @@ def parent_frame_namespace(*, parent_depth: int = 2, force: bool = False) -> dic\n     return frame.f_locals\n \n \n+def _type_convert(arg: Any) -> Any:\n+    \"\"\"Convert `None` to `NoneType` and strings to `ForwardRef` instances.\n+\n+    This is a backport of the private `typing._type_convert` function. When\n+    evaluating a type, `ForwardRef._evaluate` ends up being called, and is\n+    responsible for making this conversion. However, we still have to apply\n+    it for the first argument passed to our type evaluation functions, similarly\n+    to the `typing.get_type_hints` function.\n+    \"\"\"",
      "comment": "Thanks, this is much more helpful to have vs the old inlined logic \ud83d\udc4d.",
      "comment_id": 1831895573,
      "user": "sydney-runkle",
      "created_at": "2024-11-07T00:32:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1831895573"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -225,17 +225,54 @@ def parent_frame_namespace(*, parent_depth: int = 2, force: bool = False) -> dic\n     return frame.f_locals\n \n \n+def _type_convert(arg: Any) -> Any:\n+    \"\"\"Convert `None` to `NoneType` and strings to `ForwardRef` instances.\n+\n+    This is a backport of the private `typing._type_convert` function. When\n+    evaluating a type, `ForwardRef._evaluate` ends up being called, and is\n+    responsible for making this conversion. However, we still have to apply\n+    it for the first argument passed to our type evaluation functions, similarly\n+    to the `typing.get_type_hints` function.\n+    \"\"\"\n+    if arg is None:\n+        return NoneType\n+    if isinstance(arg, str):\n+        # Like `typing.get_type_hints`, assume the arg can be in any context,\n+        # hence the proper `is_argument` and `is_class` args:\n+        return _make_forward_ref(arg, is_argument=False, is_class=True)\n+    return arg\n+\n+\n+@overload",
      "comment": "Would this be easier if we just returned `dict[str, tuple[Any, bool]]` always, so when `lenient` is `False`, we just return `True` as the second part of the tuple?",
      "comment_id": 1831896455,
      "user": "sydney-runkle",
      "created_at": "2024-11-07T00:34:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1831896455"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 559,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,50 +282,66 @@ def get_cls_type_hints(\n         with ns_resolver.push(base):\n             globalns, localns = ns_resolver.types_namespace\n             for name, value in ann.items():\n-                hints[name] = eval_type(value, globalns, localns, lenient=lenient)\n+                if lenient:\n+                    hints[name] = try_eval_type(value, globalns, localns)\n+                else:\n+                    hints[name] = eval_type(value, globalns, localns)\n     return hints\n \n \n-def eval_type(\n+def try_eval_type(\n     value: Any,\n     globalns: GlobalsNamespace | None = None,\n     localns: MappingNamespace | None = None,\n-    *,\n-    lenient: bool = False,\n-) -> Any:\n-    \"\"\"Evaluate the annotation using the provided namespaces.\n+) -> tuple[Any, bool]:\n+    \"\"\"Try evaluating the annotation using the provided namespaces.\n \n     Args:\n         value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance\n             of `str`, it will be converted to a `ForwardRef`.\n         localns: The global namespace to use during annotation evaluation.\n         globalns: The local namespace to use during annotation evaluation.\n-        lenient: Whether to keep unresolvable annotations as is or re-raise the `NameError` exception. Default: re-raise.\n+\n+    Returns:\n+        A two-tuple containing the possibly evaluated type and a boolean indicating\n+            whether the evaluation succeeded or not.\n     \"\"\"\n-    if value is None:\n-        value = NoneType\n-    elif isinstance(value, str):\n-        value = _make_forward_ref(value, is_argument=False, is_class=True)\n+    value = _type_convert(value)\n \n     try:\n-        return eval_type_backport(value, globalns, localns)\n+        return eval_type_backport(value, globalns, localns), True\n     except NameError:\n-        if not lenient:\n-            raise\n-        # the point of this function is to be tolerant to this case\n-        return value\n+        return value, False\n+\n+\n+def eval_type(\n+    value: Any,\n+    globalns: GlobalsNamespace | None = None,\n+    localns: MappingNamespace | None = None,\n+) -> Any:\n+    \"\"\"Evaluate the annotation using the provided namespaces.\n+\n+    Args:\n+        value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance\n+            of `str`, it will be converted to a `ForwardRef`.\n+        localns: The global namespace to use during annotation evaluation.\n+        globalns: The local namespace to use during annotation evaluation.\n+    \"\"\"\n+    value = _type_convert(value)\n+    return eval_type_backport(value, globalns, localns)\n \n \n @deprecated(\n-    '`eval_type_lenient` is deprecated, use `eval_type` with `lenient=True` instead.',\n+    '`eval_type_lenient` is deprecated, use `try_eval_type` instead.',",
      "comment": "Hmm, this feels like an anti-pattern - if we already deprecated this, there's probably a reason why we didn't want to have two functions. Even if we disagree with this deprecation now, seems like a lot of churn to basically reintroduce the function and redirect for the deprecated case...\r\n\r\nI believe my suggestion above re always returning a second value, `evaluated`, even in the case of `eval_type` with `lenient=False` might help, and we can leave this be?",
      "comment_id": 1831897921,
      "user": "sydney-runkle",
      "created_at": "2024-11-07T00:36:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1831897921"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 559,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,50 +282,66 @@ def get_cls_type_hints(\n         with ns_resolver.push(base):\n             globalns, localns = ns_resolver.types_namespace\n             for name, value in ann.items():\n-                hints[name] = eval_type(value, globalns, localns, lenient=lenient)\n+                if lenient:\n+                    hints[name] = try_eval_type(value, globalns, localns)\n+                else:\n+                    hints[name] = eval_type(value, globalns, localns)\n     return hints\n \n \n-def eval_type(\n+def try_eval_type(\n     value: Any,\n     globalns: GlobalsNamespace | None = None,\n     localns: MappingNamespace | None = None,\n-    *,\n-    lenient: bool = False,\n-) -> Any:\n-    \"\"\"Evaluate the annotation using the provided namespaces.\n+) -> tuple[Any, bool]:\n+    \"\"\"Try evaluating the annotation using the provided namespaces.\n \n     Args:\n         value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance\n             of `str`, it will be converted to a `ForwardRef`.\n         localns: The global namespace to use during annotation evaluation.\n         globalns: The local namespace to use during annotation evaluation.\n-        lenient: Whether to keep unresolvable annotations as is or re-raise the `NameError` exception. Default: re-raise.\n+\n+    Returns:\n+        A two-tuple containing the possibly evaluated type and a boolean indicating\n+            whether the evaluation succeeded or not.\n     \"\"\"\n-    if value is None:\n-        value = NoneType\n-    elif isinstance(value, str):\n-        value = _make_forward_ref(value, is_argument=False, is_class=True)\n+    value = _type_convert(value)\n \n     try:\n-        return eval_type_backport(value, globalns, localns)\n+        return eval_type_backport(value, globalns, localns), True\n     except NameError:\n-        if not lenient:\n-            raise\n-        # the point of this function is to be tolerant to this case\n-        return value\n+        return value, False\n+\n+\n+def eval_type(\n+    value: Any,\n+    globalns: GlobalsNamespace | None = None,\n+    localns: MappingNamespace | None = None,\n+) -> Any:\n+    \"\"\"Evaluate the annotation using the provided namespaces.\n+\n+    Args:\n+        value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance\n+            of `str`, it will be converted to a `ForwardRef`.\n+        localns: The global namespace to use during annotation evaluation.\n+        globalns: The local namespace to use during annotation evaluation.\n+    \"\"\"\n+    value = _type_convert(value)\n+    return eval_type_backport(value, globalns, localns)\n \n \n @deprecated(\n-    '`eval_type_lenient` is deprecated, use `eval_type` with `lenient=True` instead.',\n+    '`eval_type_lenient` is deprecated, use `try_eval_type` instead.',",
      "comment": "A few more follow ups:\r\n1. This is a very internal function - can we just deprecate this?\r\n2. If we were to bring back a second function, to reduce churn, can we call it `eval_type_lenient`?",
      "comment_id": 1831898737,
      "user": "sydney-runkle",
      "created_at": "2024-11-07T00:38:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1831898737"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1221,
      "side": "RIGHT",
      "diff_hunk": "@@ -1215,11 +1215,15 @@ def _common_field_schema(  # C901\n     ) -> _CommonField:\n         # Update FieldInfo annotation if appropriate:\n         FieldInfo = import_cached_field_info()\n-        if has_instance_in_type(field_info.annotation, (ForwardRef, str)):\n-            # TODO Can we use field_info.apply_typevars_map here? Shouldn't we use lenient=False?\n-            evaluated = _typing_extra.eval_type(field_info.annotation, *self._types_namespace, lenient=True)\n+        if not field_info.evaluated:\n+            # TODO Can we use field_info.apply_typevars_map here?\n+            try:\n+                evaluated = _typing_extra.eval_type(field_info.annotation, *self._types_namespace)",
      "comment": "I'm guessing `evaluated` is an evaluated type here, which is a bit confusing, given that we use `evaluated` elsewhere as a bool to indicate successful / unsuccessful evaluation.\r\n\r\nPerhaps we could decouple these by naming one differently?",
      "comment_id": 1831899638,
      "user": "sydney-runkle",
      "created_at": "2024-11-07T00:40:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1831899638"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1348,
      "side": "LEFT",
      "diff_hunk": "@@ -1338,12 +1342,13 @@ def _type_alias_type_schema(self, obj: TypeAliasType) -> CoreSchema:\n                 return maybe_schema\n \n             origin: TypeAliasType = get_origin(obj) or obj\n-\n-            annotation = origin.__value__",
      "comment": "Maybe I'm misunderstanding - was this moved below? Or do we not need this specific line anymore?",
      "comment_id": 1831900398,
      "user": "sydney-runkle",
      "created_at": "2024-11-07T00:41:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1831900398"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1348,
      "side": "LEFT",
      "diff_hunk": "@@ -1338,12 +1342,13 @@ def _type_alias_type_schema(self, obj: TypeAliasType) -> CoreSchema:\n                 return maybe_schema\n \n             origin: TypeAliasType = get_origin(obj) or obj\n-\n-            annotation = origin.__value__",
      "comment": "Basically, here is what can happen with type aliases:\r\n\r\n```python\r\ntype A = Int\r\n\r\nannotation = origin.__value__\r\n# NameError, 'Int' is not defined\r\n\r\ntype B = 'Int'\r\nannotation = origin.__value__\r\nassert annotation == 'Int'\r\n\r\neval_type(B, ..., ...)\r\n# NameError, 'Int' is not defined\r\n```\r\n\r\nSo everything was moved in a single `try..except` block:\r\n\r\n```python\r\ntry:\r\n    annotation = _typing_extra.eval_type(origin.__value__, *self._types_namespace)\r\nexcept ...: ...\r\n```\r\n```",
      "comment_id": 1832944418,
      "user": "Viicos",
      "created_at": "2024-11-07T16:05:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1832944418"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -225,17 +225,54 @@ def parent_frame_namespace(*, parent_depth: int = 2, force: bool = False) -> dic\n     return frame.f_locals\n \n \n+def _type_convert(arg: Any) -> Any:\n+    \"\"\"Convert `None` to `NoneType` and strings to `ForwardRef` instances.\n+\n+    This is a backport of the private `typing._type_convert` function. When\n+    evaluating a type, `ForwardRef._evaluate` ends up being called, and is\n+    responsible for making this conversion. However, we still have to apply\n+    it for the first argument passed to our type evaluation functions, similarly\n+    to the `typing.get_type_hints` function.\n+    \"\"\"\n+    if arg is None:\n+        return NoneType\n+    if isinstance(arg, str):\n+        # Like `typing.get_type_hints`, assume the arg can be in any context,\n+        # hence the proper `is_argument` and `is_class` args:\n+        return _make_forward_ref(arg, is_argument=False, is_class=True)\n+    return arg\n+\n+\n+@overload",
      "comment": "I wanted to do this as well, but then we loose the `NameError` exceptions, which are converted to `PydanticUndefinedAnnotation` exceptions during schema building :/",
      "comment_id": 1832947088,
      "user": "Viicos",
      "created_at": "2024-11-07T16:07:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1832947088"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10769,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 559,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,50 +282,66 @@ def get_cls_type_hints(\n         with ns_resolver.push(base):\n             globalns, localns = ns_resolver.types_namespace\n             for name, value in ann.items():\n-                hints[name] = eval_type(value, globalns, localns, lenient=lenient)\n+                if lenient:\n+                    hints[name] = try_eval_type(value, globalns, localns)\n+                else:\n+                    hints[name] = eval_type(value, globalns, localns)\n     return hints\n \n \n-def eval_type(\n+def try_eval_type(\n     value: Any,\n     globalns: GlobalsNamespace | None = None,\n     localns: MappingNamespace | None = None,\n-    *,\n-    lenient: bool = False,\n-) -> Any:\n-    \"\"\"Evaluate the annotation using the provided namespaces.\n+) -> tuple[Any, bool]:\n+    \"\"\"Try evaluating the annotation using the provided namespaces.\n \n     Args:\n         value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance\n             of `str`, it will be converted to a `ForwardRef`.\n         localns: The global namespace to use during annotation evaluation.\n         globalns: The local namespace to use during annotation evaluation.\n-        lenient: Whether to keep unresolvable annotations as is or re-raise the `NameError` exception. Default: re-raise.\n+\n+    Returns:\n+        A two-tuple containing the possibly evaluated type and a boolean indicating\n+            whether the evaluation succeeded or not.\n     \"\"\"\n-    if value is None:\n-        value = NoneType\n-    elif isinstance(value, str):\n-        value = _make_forward_ref(value, is_argument=False, is_class=True)\n+    value = _type_convert(value)\n \n     try:\n-        return eval_type_backport(value, globalns, localns)\n+        return eval_type_backport(value, globalns, localns), True\n     except NameError:\n-        if not lenient:\n-            raise\n-        # the point of this function is to be tolerant to this case\n-        return value\n+        return value, False\n+\n+\n+def eval_type(\n+    value: Any,\n+    globalns: GlobalsNamespace | None = None,\n+    localns: MappingNamespace | None = None,\n+) -> Any:\n+    \"\"\"Evaluate the annotation using the provided namespaces.\n+\n+    Args:\n+        value: The value to evaluate. If `None`, it will be replaced by `type[None]`. If an instance\n+            of `str`, it will be converted to a `ForwardRef`.\n+        localns: The global namespace to use during annotation evaluation.\n+        globalns: The local namespace to use during annotation evaluation.\n+    \"\"\"\n+    value = _type_convert(value)\n+    return eval_type_backport(value, globalns, localns)\n \n \n @deprecated(\n-    '`eval_type_lenient` is deprecated, use `eval_type` with `lenient=True` instead.',\n+    '`eval_type_lenient` is deprecated, use `try_eval_type` instead.',",
      "comment": "I had to keep this function during the types namespaces refactor because fastapi makes use of it :face_with_diagonal_mouth:. I added the `deprecated` decorator so that type checking fails in the fastapi CI and they can use the correct function (or best, do not rely on our internals because I don't think the `_typing_extra` module is stable enough, we might apply other changes here in the future).\r\n\r\n> I believe my suggestion above re always returning a second value, `evaluated`, even in the case of `eval_type` with `lenient=False` might help, and we can leave this be?\r\n\r\nSame issue as https://github.com/pydantic/pydantic/pull/10769/files#r1832947088, we can't have a single function because we want to catch the `NameError` to reraise `PydanticUndefinedAnnotation`",
      "comment_id": 1832970597,
      "user": "Viicos",
      "created_at": "2024-11-07T16:18:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10769#discussion_r1832970597"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,8 +109,48 @@ def rebuild(self) -> ValSer | None:\n         return None\n \n \n+def set_type_adapter_mocks(adapter: TypeAdapter, type_repr: str) -> None:\n+    \"\"\"Set `core_schema`, `validator` and `serializer` to mock core types on a type adapter instance.\n+\n+    Args:\n+        adapter: The type adapter instance to set the mocks on\n+        type_repr: Name of the type used in the adapter, used in error messages\n+    \"\"\"\n+    undefined_type_error_message = (\n+        f'`TypeAdapter[{type_repr}]` is not fully defined; you should define `{type_repr}` and all referenced types,'\n+        f' then call `.rebuild()` on the instance.'\n+    )\n+\n+    def attempt_rebuild_fn(attr_fn: Callable[[TypeAdapter], T]) -> Callable[[], T | None]:\n+        def handler() -> T | None:\n+            if adapter.rebuild(_parent_namespace_depth=5) is not False:\n+                return attr_fn(adapter)\n+            else:\n+                return None\n+\n+        return handler\n+\n+    adapter.core_schema = MockCoreSchema(  # type: ignore[assignment]",
      "comment": "Could we make use of pyright specific ignore comments? (`#pyright: ignore[reportAssignmentType]`)",
      "comment_id": 1835779631,
      "user": "Viicos",
      "created_at": "2024-11-10T20:52:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1835779631"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 311,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,124 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals.copy()\n+        ns_resolver = _namespace_utils.NsResolver(\n+            namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns)\n+        )\n+        self._init_core_attrs(ns_resolver=ns_resolver, force=False)\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n \n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n \n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n \n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)\n+\n+        self._pydantic_complete = True\n+        return True\n+\n+    @property\n     def _defer_build(self) -> bool:\n-        config = self._config if self._config is not None else self._model_config()\n+        config = self._config if self._config is not None else self._model_config\n         if config:\n             return config.get('defer_build') is True\n         return False\n \n+    @property\n     def _model_config(self) -> ConfigDict | None:\n         type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated\n         if _utils.lenient_issubclass(type_, BaseModel):\n             return type_.model_config\n         return getattr(type_, '__pydantic_config__', None)\n \n-    @_frame_depth(1)\n+    def rebuild(\n+        self,\n+        *,\n+        force: bool = False,\n+        _parent_namespace_depth: int = 2,\n+        _types_namespace: dict[str, Any] | None = None,\n+    ) -> bool | None:\n+        \"\"\"Try to rebuild the pydantic-core schema for the adapter's type.\n+\n+        This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n+        the initial attempt to build the schema, and automatic rebuilding fails.\n+\n+        Args:\n+            force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.\n+            _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n+            _types_namespace: The types namespace, defaults to `None`.\n+\n+        Returns:\n+            Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n+            If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n+        \"\"\"\n+        if not force and self._pydantic_complete:",
      "comment": "Do you think we could make this public, as it is for models and dataclasses?",
      "comment_id": 1835779863,
      "user": "Viicos",
      "created_at": "2024-11-10T20:53:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1835779863"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,8 +109,48 @@ def rebuild(self) -> ValSer | None:\n         return None\n \n \n+def set_type_adapter_mocks(adapter: TypeAdapter, type_repr: str) -> None:\n+    \"\"\"Set `core_schema`, `validator` and `serializer` to mock core types on a type adapter instance.\n+\n+    Args:\n+        adapter: The type adapter instance to set the mocks on\n+        type_repr: Name of the type used in the adapter, used in error messages\n+    \"\"\"\n+    undefined_type_error_message = (\n+        f'`TypeAdapter[{type_repr}]` is not fully defined; you should define `{type_repr}` and all referenced types,'",
      "comment": "The `TypeAdapter[...]` form seems a bit weird, especially because `type_repr` seems to be `str(type)` when called from `TypeAdapter`. Probably fine as is, just wanted to note that this may lead to weird string representations (maybe `_display.display_as_type` could be used, although it is costly to compute).",
      "comment_id": 1837161007,
      "user": "Viicos",
      "created_at": "2024-11-11T20:32:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1837161007"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 223,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,124 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}",
      "comment": "Seems like the following test case fails:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/e9cde451034f4c9359a92ec7e4bddc0bfc0af0d1/tests/test_types_namedtuple.py#L199-L207\r\n\r\nBecause it can't find `T`, but surely this `localns` should include it, right?",
      "comment_id": 1837172777,
      "user": "Viicos",
      "created_at": "2024-11-11T20:43:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1837172777"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,129 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals.copy()",
      "comment": "`copy()` is a new one here comparing to the previous handler, is it needed now?",
      "comment_id": 1838383480,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T16:13:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838383480"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,129 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals.copy()",
      "comment": "There is also `sys._getframe` used above for `_module_name` thing handling. For that the \"depth\" is `1`, but I dont understand why. Could we just do the `sys._getframe(max(self._parent_depth - 1, 1))` once and do the `_module_name` things from that? Would be much more clear.",
      "comment_id": 1838389558,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T16:17:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838389558"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 245,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,129 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals.copy()\n+        ns_resolver = _namespace_utils.NsResolver(\n+            namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+            parent_namespace=localns,\n+        )\n+        self._init_core_attrs(ns_resolver=ns_resolver, force=False)\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n \n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n \n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))",
      "comment": "Not sure is there any gains but the type stringification could be also lazy as its only used for errors really \ud83e\udd14 So depends on how complex implementation there can be for the type stringifications",
      "comment_id": 1838395713,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T16:21:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838395713"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 246,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,129 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals.copy()\n+        ns_resolver = _namespace_utils.NsResolver(\n+            namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+            parent_namespace=localns,\n+        )\n+        self._init_core_attrs(ns_resolver=ns_resolver, force=False)\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n \n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n \n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False",
      "comment": "Well maybe not, as we dont use \"dunder like\" attrs here anyways in TypeAdapter",
      "comment_id": 1838401242,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T16:24:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838401242"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,130 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        ns_resolver = _namespace_utils.NsResolver(\n+            namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+            parent_namespace=localns,\n+        )\n+        self._init_core_attrs(ns_resolver=ns_resolver, force=False)\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n \n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n \n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n \n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)\n+\n+        self._pydantic_complete = True\n+        return True\n+\n+    @property\n     def _defer_build(self) -> bool:\n-        config = self._config if self._config is not None else self._model_config()\n+        config = self._config if self._config is not None else self._model_config\n         if config:\n             return config.get('defer_build') is True\n         return False\n \n+    @property\n     def _model_config(self) -> ConfigDict | None:\n         type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated\n         if _utils.lenient_issubclass(type_, BaseModel):\n             return type_.model_config\n         return getattr(type_, '__pydantic_config__', None)\n \n-    @_frame_depth(1)\n+    def rebuild(\n+        self,\n+        *,\n+        force: bool = False,\n+        _parent_namespace_depth: int = 2,\n+        _types_namespace: dict[str, Any] | None = None,\n+    ) -> bool | None:\n+        \"\"\"Try to rebuild the pydantic-core schema for the adapter's type.\n+\n+        This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n+        the initial attempt to build the schema, and automatic rebuilding fails.\n+\n+        Args:\n+            force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.\n+            _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n+            _types_namespace: The types namespace, defaults to `None`.\n+\n+        Returns:\n+            Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n+            If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n+        \"\"\"\n+        if not force and self._pydantic_complete:\n+            return None\n+        else:\n+            if '_core_schema' in self.__dict__:\n+                delattr(self, '_core_schema')  # delete cached value to ensure full rebuild happens",
      "comment": "Hmm is it correct as these were renamed?:\r\n```suggestion\r\n            if 'core_schema' in self.__dict__:\r\n                delattr(self, 'core_schema')  # delete cached value to ensure full rebuild happens\r\n```",
      "comment_id": 1838411087,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T16:28:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838411087"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,129 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals.copy()",
      "comment": "Eh, we don't copy the result of `parent_frame_namepsace` which returns `f_locals`, so I think removing this is fine.",
      "comment_id": 1838417060,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T16:31:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838417060"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 313,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,127 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n+\n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)\n+\n+        self._pydantic_complete = True\n+        return True\n \n+    @property\n     def _defer_build(self) -> bool:\n-        config = self._config if self._config is not None else self._model_config()\n+        config = self._config if self._config is not None else self._model_config\n         if config:\n             return config.get('defer_build') is True\n         return False\n \n+    @property\n     def _model_config(self) -> ConfigDict | None:\n         type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated\n         if _utils.lenient_issubclass(type_, BaseModel):\n             return type_.model_config\n         return getattr(type_, '__pydantic_config__', None)\n \n-    @_frame_depth(1)\n+    def rebuild(\n+        self,\n+        *,\n+        force: bool = False,\n+        _parent_namespace_depth: int = 2,\n+        _types_namespace: dict[str, Any] | None = None,\n+    ) -> bool | None:\n+        \"\"\"Try to rebuild the pydantic-core schema for the adapter's type.\n+\n+        This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n+        the initial attempt to build the schema, and automatic rebuilding fails.\n+\n+        Args:\n+            force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.\n+            _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n+            _types_namespace: The types namespace, defaults to `None`.\n+\n+        Returns:\n+            Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n+            If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n+        \"\"\"\n+        if not force and self._pydantic_complete:\n+            return None\n+        else:\n+            if '_core_schema' in self.__dict__:\n+                delattr(self, '_core_schema')  # delete cached value to ensure full rebuild happens",
      "comment": "Not sure I follow what is actually depending on the delattr \"cache deletion\" can you point what is it about?",
      "comment_id": 1838420444,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T16:33:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838420444"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 246,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,129 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals.copy()\n+        ns_resolver = _namespace_utils.NsResolver(\n+            namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+            parent_namespace=localns,\n+        )\n+        self._init_core_attrs(ns_resolver=ns_resolver, force=False)\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n \n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n \n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False",
      "comment": "I don't think so - we only set that on the type itself, and we don't need to mutate that for this case...",
      "comment_id": 1838420655,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T16:33:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838420655"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 311,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,127 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n+\n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)\n+\n+        self._pydantic_complete = True\n+        return True\n \n+    @property\n     def _defer_build(self) -> bool:\n-        config = self._config if self._config is not None else self._model_config()\n+        config = self._config if self._config is not None else self._model_config\n         if config:\n             return config.get('defer_build') is True\n         return False\n \n+    @property\n     def _model_config(self) -> ConfigDict | None:\n         type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated\n         if _utils.lenient_issubclass(type_, BaseModel):\n             return type_.model_config\n         return getattr(type_, '__pydantic_config__', None)\n \n-    @_frame_depth(1)\n+    def rebuild(\n+        self,\n+        *,\n+        force: bool = False,\n+        _parent_namespace_depth: int = 2,\n+        _types_namespace: dict[str, Any] | None = None,\n+    ) -> bool | None:\n+        \"\"\"Try to rebuild the pydantic-core schema for the adapter's type.\n+\n+        This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n+        the initial attempt to build the schema, and automatic rebuilding fails.\n+\n+        Args:\n+            force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.\n+            _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n+            _types_namespace: The types namespace, defaults to `None`.\n+\n+        Returns:\n+            Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n+            If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n+        \"\"\"\n+        if not force and self._pydantic_complete:\n+            return None\n+        else:",
      "comment": "nit; Really no need for the `else` as there is the `return None` right above",
      "comment_id": 1838423034,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T16:34:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838423034"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 557,
      "side": "RIGHT",
      "diff_hunk": "@@ -558,6 +554,9 @@ def json_schema(\n             The JSON schema for the model as a dictionary.\n         \"\"\"\n         schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):",
      "comment": "If the `core_schema` would have been a cached prop then we wouldnt need sprinkle these checks in the usage side",
      "comment_id": 1838426576,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T16:36:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838426576"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 246,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,129 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals.copy()\n+        ns_resolver = _namespace_utils.NsResolver(\n+            namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+            parent_namespace=localns,\n+        )\n+        self._init_core_attrs(ns_resolver=ns_resolver, force=False)\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n \n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n \n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False",
      "comment": "Well, I'm not sure actually, as we do pull from values like `__pydantic_core_schema__` off the type directly...",
      "comment_id": 1838428794,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T16:38:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838428794"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 313,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,127 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n+\n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)\n+\n+        self._pydantic_complete = True\n+        return True\n \n+    @property\n     def _defer_build(self) -> bool:\n-        config = self._config if self._config is not None else self._model_config()\n+        config = self._config if self._config is not None else self._model_config\n         if config:\n             return config.get('defer_build') is True\n         return False\n \n+    @property\n     def _model_config(self) -> ConfigDict | None:\n         type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated\n         if _utils.lenient_issubclass(type_, BaseModel):\n             return type_.model_config\n         return getattr(type_, '__pydantic_config__', None)\n \n-    @_frame_depth(1)\n+    def rebuild(\n+        self,\n+        *,\n+        force: bool = False,\n+        _parent_namespace_depth: int = 2,\n+        _types_namespace: dict[str, Any] | None = None,\n+    ) -> bool | None:\n+        \"\"\"Try to rebuild the pydantic-core schema for the adapter's type.\n+\n+        This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n+        the initial attempt to build the schema, and automatic rebuilding fails.\n+\n+        Args:\n+            force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.\n+            _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n+            _types_namespace: The types namespace, defaults to `None`.\n+\n+        Returns:\n+            Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n+            If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n+        \"\"\"\n+        if not force and self._pydantic_complete:\n+            return None\n+        else:\n+            if '_core_schema' in self.__dict__:\n+                delattr(self, '_core_schema')  # delete cached value to ensure full rebuild happens",
      "comment": "Good catch - we don't need this like we do for models that check the `__get_pydantic_core_schema__`. Removed.",
      "comment_id": 1838432065,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T16:40:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838432065"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 557,
      "side": "RIGHT",
      "diff_hunk": "@@ -558,6 +554,9 @@ def json_schema(\n             The JSON schema for the model as a dictionary.\n         \"\"\"\n         schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):",
      "comment": "This is true, but we wanted to model the pattern used for `BaseModel` as closely as possible:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/ff4a325cb1a1d4e00584366d086c652463c1ea35/pydantic/json_schema.py#L2348-L2359",
      "comment_id": 1838436631,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T16:42:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838436631"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 269,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,122 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n+\n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)",
      "comment": "Hmm does this do double building, it first calls `self.core_schema.rebuild()` and then in `_init_core_attrs` it again does `_get_schema` which builds also?",
      "comment_id": 1838568611,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T18:17:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838568611"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 557,
      "side": "RIGHT",
      "diff_hunk": "@@ -558,6 +554,9 @@ def json_schema(\n             The JSON schema for the model as a dictionary.\n         \"\"\"\n         schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):",
      "comment": "We dont need similar mock checks for others like `self.serializer` eg in `dump_json`?",
      "comment_id": 1838573226,
      "user": "MarkusSintonen",
      "created_at": "2024-11-12T18:21:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838573226"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,122 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n+\n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)\n \n+        self._pydantic_complete = True\n+        return True\n+\n+    @property\n     def _defer_build(self) -> bool:\n-        config = self._config if self._config is not None else self._model_config()\n+        config = self._config if self._config is not None else self._model_config\n         if config:\n             return config.get('defer_build') is True\n         return False\n \n+    @property\n     def _model_config(self) -> ConfigDict | None:\n         type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated\n         if _utils.lenient_issubclass(type_, BaseModel):\n             return type_.model_config\n         return getattr(type_, '__pydantic_config__', None)\n \n-    @_frame_depth(1)\n+    def rebuild(\n+        self,\n+        *,\n+        force: bool = False,\n+        _parent_namespace_depth: int = 2,",
      "comment": "Good question - it's used in `parent_frame_namespace`, so that's down 1 level, then we have to add 1 more to get out of `__init__`.\r\n\r\nSo, viewed another way:\r\n\r\ntop_level\r\n`__init__`\r\n`parent_frame_namespace`\r\n\r\nSo depth of 2 gets us to `top_level`",
      "comment_id": 1838608167,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T18:50:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838608167"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 557,
      "side": "RIGHT",
      "diff_hunk": "@@ -558,6 +554,9 @@ def json_schema(\n             The JSON schema for the model as a dictionary.\n         \"\"\"\n         schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):",
      "comment": "Good question, I don't think so, given that the `MockCoreSchema` logic supports rebuilds.\r\n\r\nThat makes me wonder if we actually need to be this complicated above, though.",
      "comment_id": 1838617716,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T18:58:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838617716"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 557,
      "side": "RIGHT",
      "diff_hunk": "@@ -558,6 +554,9 @@ def json_schema(\n             The JSON schema for the model as a dictionary.\n         \"\"\"\n         schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):",
      "comment": "Might be within the scope of another PR to simplify that across the board...",
      "comment_id": 1838618440,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T18:58:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838618440"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -130,18 +171,18 @@ def handler() -> T | None:\n \n         return handler\n \n-    cls.__pydantic_core_schema__ = MockCoreSchema(  # type: ignore[assignment]\n+    cls.__pydantic_core_schema__ = MockCoreSchema(  # type: ignore[reportAssignmentType]",
      "comment": "```suggestion\r\n    cls.__pydantic_core_schema__ = MockCoreSchema(  # pyright: ignore[reportAssignmentType]\r\n```\r\n\r\npyright only understands the error code that way (i.e. `#type: ignore[reportAssignmentType]` is equivalent to `# type: ignore` or `type: ignore[dummycode]`).",
      "comment_id": 1838618985,
      "user": "Viicos",
      "created_at": "2024-11-12T18:59:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838618985"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 557,
      "side": "RIGHT",
      "diff_hunk": "@@ -558,6 +554,9 @@ def json_schema(\n             The JSON schema for the model as a dictionary.\n         \"\"\"\n         schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):",
      "comment": "Ah yes, it's bc we're not calling `getattr` on `core_schema` like we would for `serializer`. That `getattr` is what triggers the rebuild.",
      "comment_id": 1838629505,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T19:09:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838629505"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 219,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,122 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals",
      "comment": "If we also use the `_parent_depth` attribute to fetch the global ns, we'll need to update the docstring for `_parent_depth` in `__init__`",
      "comment_id": 1838630047,
      "user": "Viicos",
      "created_at": "2024-11-12T19:09:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838630047"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 246,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,129 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n+\n         if module is None:\n             f = sys._getframe(1)\n             self._module_name = cast(str, f.f_globals.get('__name__', ''))\n         else:\n             self._module_name = module\n \n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.GlobalsNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals.copy()\n+        ns_resolver = _namespace_utils.NsResolver(\n+            namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+            parent_namespace=localns,\n+        )\n+        self._init_core_attrs(ns_resolver=ns_resolver, force=False)\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n \n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n \n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False",
      "comment": "We should probably make it public by naming it `pydantic_complete`",
      "comment_id": 1838631742,
      "user": "Viicos",
      "created_at": "2024-11-12T19:11:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838631742"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +156,174 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            including type aliases, where `__module__` (always `typing.py`) is not useful.\n+            So instead we look at the globals in our parent stack frame.\n+            \n+            It is expected that the `ns_resolver` passed to this function will have the correct\n+            namespace for the type we're adapting. See `TypeAdapter.__init__` and `TypeAdapter.rebuild`\n+            for various ways to construct this namespace.\n+\n+            This works for the case where this function is called in a module that\n+            has the target of forward references in its scope, but\n+            does not always work for more complex cases.\n+\n+            For example, take the following:\n+\n+            a.py\n+            ```python\n+            from typing import Dict, List\n+\n+            IntList = List[int]\n+            OuterDict = Dict[str, 'IntList']\n+            ```\n+\n+            b.py\n+            ```python test=\"skip\"\n+            from a import OuterDict\n+\n+            from pydantic import TypeAdapter\n+\n+            IntList = int  # replaces the symbol the forward reference is looking for\n+            v = TypeAdapter(OuterDict)\n+            v({'x': 1})  # should fail but doesn't\n+            ```\n+\n+            If `OuterDict` were a `BaseModel`, this would work because it would resolve\n+            the forward reference within the `a.py` namespace.\n+            But `TypeAdapter(OuterDict)` can't determine what module `OuterDict` came from.\n+\n+            In other words, the assumption that _all_ forward references exist in the\n+            module we are being called from is not technically always true.\n+            Although most of the time it is and it works fine for recursive models and such,\n+            `BaseModel`'s behavior isn't perfect either and _can_ break in similar ways,\n+            so there is no right or wrong between the two.\n+\n+            But at the very least this behavior is _subtly_ different from `BaseModel`'s.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            schema_generator = _generate_schema.GenerateSchema(config_wrapper, ns_resolver=ns_resolver)\n+            intermediate_core_schema = schema_generator.generate_schema(self._type)\n+            self.core_schema = schema_generator.clean_schema(intermediate_core_schema)",
      "comment": "Do we want to set mocks if we fail to generate the schema, similar to models?",
      "comment_id": 1838644025,
      "user": "Viicos",
      "created_at": "2024-11-12T19:22:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838644025"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 194,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +156,174 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            including type aliases, where `__module__` (always `typing.py`) is not useful.",
      "comment": "```suggestion\r\n            which may not be types and thus do not have a `__module__` available\r\n```\r\n\r\nmaybe? I think the most common example is `SomeType = list[...]`, and is more common that PEP 695 type aliases. I think it's best to emphasize on the fact that most objects passed to type adapters are _instances_ (e.g. `type A = int`, `A` is instance of a `TypeAliasType`).",
      "comment_id": 1838647449,
      "user": "Viicos",
      "created_at": "2024-11-12T19:25:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838647449"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,122 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n+\n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)\n \n+        self._pydantic_complete = True\n+        return True\n+\n+    @property\n     def _defer_build(self) -> bool:\n-        config = self._config if self._config is not None else self._model_config()\n+        config = self._config if self._config is not None else self._model_config\n         if config:\n             return config.get('defer_build') is True\n         return False\n \n+    @property\n     def _model_config(self) -> ConfigDict | None:\n         type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated\n         if _utils.lenient_issubclass(type_, BaseModel):\n             return type_.model_config\n         return getattr(type_, '__pydantic_config__', None)\n \n-    @_frame_depth(1)\n+    def rebuild(\n+        self,\n+        *,\n+        force: bool = False,\n+        _parent_namespace_depth: int = 2,",
      "comment": "Going to resolve for now, will add a docs note explaining this",
      "comment_id": 1838661793,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T19:38:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838661793"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,7 +116,9 @@ def __init__(\n         Args:\n             type: The type associated with the `TypeAdapter`.\n             config: Configuration for the `TypeAdapter`, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-            _parent_depth: depth at which to search the parent namespace to construct the local namespace.\n+            _parent_depth: Depth at which to search the for the parent namespace used for schema building.\n+                We also use this as a reference level to find the global namespace (_parent_depth - 1).\n+                Defaults to 2 because we expect to reference the frame that called the `TypeAdapter` constructor.",
      "comment": "I think it's worth considering - should we default to `1`, then add `1` when we call into `parent_frame_namespace`? That seems more intuitive to me from a user perspective. cc @Viicos.",
      "comment_id": 1838665456,
      "user": "sydney-runkle",
      "created_at": "2024-11-12T19:40:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1838665456"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,7 +116,9 @@ def __init__(\n         Args:\n             type: The type associated with the `TypeAdapter`.\n             config: Configuration for the `TypeAdapter`, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-            _parent_depth: depth at which to search the parent namespace to construct the local namespace.\n+            _parent_depth: Depth at which to search the for the parent namespace used for schema building.\n+                We also use this as a reference level to find the global namespace (_parent_depth - 1).\n+                Defaults to 2 because we expect to reference the frame that called the `TypeAdapter` constructor.",
      "comment": "Though I think this could be a valuable change, it is breaking, as folks are depending on the current behavior. This is `_` prefixed though, so we sort of have range to do this.",
      "comment_id": 1840269186,
      "user": "sydney-runkle",
      "created_at": "2024-11-13T13:24:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840269186"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 269,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,122 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n+\n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)",
      "comment": "So, this happens when we have a model that deferred (or failed) schema building.\r\n\r\nI think this logic needs to be more complex - should we reassign `__pydantic_core_schema__`? What about `__pydantic_validator__` and `__pydantic_serializer__`?",
      "comment_id": 1840292465,
      "user": "sydney-runkle",
      "created_at": "2024-11-13T13:35:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840292465"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 269,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,122 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n+\n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)",
      "comment": "I've updated this - we no longer do the recursive call :).",
      "comment_id": 1840357329,
      "user": "sydney-runkle",
      "created_at": "2024-11-13T14:09:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840357329"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,7 +116,9 @@ def __init__(\n         Args:\n             type: The type associated with the `TypeAdapter`.\n             config: Configuration for the `TypeAdapter`, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-            _parent_depth: depth at which to search the parent namespace to construct the local namespace.\n+            _parent_depth: Depth at which to search the for the parent namespace used for schema building.\n+                We also use this as a reference level to find the global namespace (_parent_depth - 1).\n+                Defaults to 2 because we expect to reference the frame that called the `TypeAdapter` constructor.",
      "comment": "It could make more sense but would be inconsistent with `model_rebuild` which suffers from the same issue :/",
      "comment_id": 1840379706,
      "user": "Viicos",
      "created_at": "2024-11-13T14:16:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840379706"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +159,203 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+        self.pydantic_complete: bool = False\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(\n+        self, ns_resolver: _namespace_utils.NsResolver, force: bool, raise_errors: bool = False\n+    ) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the construction of the core schema, validator, and serializer.\n+                If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+            raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Raises:\n+            PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n+                and `raise_errors=True`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+            This method is very similar to `_model_construction.complete_model_class`, used for finalizing `BaseModel` subclasses.\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            which may not be types and thus do not have a `__module__` available.\n+            So instead we look at the globals in our parent stack frame.\n+\n+            It is expected that the `ns_resolver` passed to this function will have the correct\n+            namespace for the type we're adapting. See `TypeAdapter.__init__` and `TypeAdapter.rebuild`\n+            for various ways to construct this namespace.\n+\n+            This works for the case where this function is called in a module that\n+            has the target of forward references in its scope, but\n+            does not always work for more complex cases.\n+\n+            For example, take the following:\n+\n+            a.py\n+            ```python\n+            from typing import Dict, List\n+\n+            IntList = List[int]\n+            OuterDict = Dict[str, 'IntList']\n+            ```\n+\n+            b.py\n+            ```python test=\"skip\"\n+            from a import OuterDict\n+\n+            from pydantic import TypeAdapter\n+\n+            IntList = int  # replaces the symbol the forward reference is looking for\n+            v = TypeAdapter(OuterDict)\n+            v({'x': 1})  # should fail but doesn't",
      "comment": "Were the examples etc here meant to be in public `__init__` side (which has the experimental-looking `_parent_depth` argument for doing the namespace things) for documenting the ForwardRefs quirks?",
      "comment_id": 1840554549,
      "user": "MarkusSintonen",
      "created_at": "2024-11-13T15:15:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840554549"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +159,203 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+        self.pydantic_complete: bool = False\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(\n+        self, ns_resolver: _namespace_utils.NsResolver, force: bool, raise_errors: bool = False\n+    ) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the construction of the core schema, validator, and serializer.\n+                If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+            raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Raises:\n+            PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n+                and `raise_errors=True`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+            This method is very similar to `_model_construction.complete_model_class`, used for finalizing `BaseModel` subclasses.\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            which may not be types and thus do not have a `__module__` available.\n+            So instead we look at the globals in our parent stack frame.\n+\n+            It is expected that the `ns_resolver` passed to this function will have the correct\n+            namespace for the type we're adapting. See `TypeAdapter.__init__` and `TypeAdapter.rebuild`\n+            for various ways to construct this namespace.\n+\n+            This works for the case where this function is called in a module that\n+            has the target of forward references in its scope, but\n+            does not always work for more complex cases.\n+\n+            For example, take the following:\n+\n+            a.py\n+            ```python\n+            from typing import Dict, List\n+\n+            IntList = List[int]\n+            OuterDict = Dict[str, 'IntList']\n+            ```\n+\n+            b.py\n+            ```python test=\"skip\"\n+            from a import OuterDict\n+\n+            from pydantic import TypeAdapter\n+\n+            IntList = int  # replaces the symbol the forward reference is looking for\n+            v = TypeAdapter(OuterDict)\n+            v({'x': 1})  # should fail but doesn't",
      "comment": "Yeah, that probably makes more sense, given that's where we do the namespace fetching anyways. Happy to move there.",
      "comment_id": 1840566221,
      "user": "sydney-runkle",
      "created_at": "2024-11-13T15:19:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840566221"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +159,203 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+        self.pydantic_complete: bool = False\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(\n+        self, ns_resolver: _namespace_utils.NsResolver, force: bool, raise_errors: bool = False\n+    ) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the construction of the core schema, validator, and serializer.\n+                If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+            raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Raises:\n+            PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n+                and `raise_errors=True`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+            This method is very similar to `_model_construction.complete_model_class`, used for finalizing `BaseModel` subclasses.\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            which may not be types and thus do not have a `__module__` available.\n+            So instead we look at the globals in our parent stack frame.\n+\n+            It is expected that the `ns_resolver` passed to this function will have the correct\n+            namespace for the type we're adapting. See `TypeAdapter.__init__` and `TypeAdapter.rebuild`\n+            for various ways to construct this namespace.\n+\n+            This works for the case where this function is called in a module that\n+            has the target of forward references in its scope, but\n+            does not always work for more complex cases.\n+\n+            For example, take the following:\n+\n+            a.py\n+            ```python\n+            from typing import Dict, List\n+\n+            IntList = List[int]\n+            OuterDict = Dict[str, 'IntList']\n+            ```\n+\n+            b.py\n+            ```python test=\"skip\"\n+            from a import OuterDict\n+\n+            from pydantic import TypeAdapter\n+\n+            IntList = int  # replaces the symbol the forward reference is looking for\n+            v = TypeAdapter(OuterDict)\n+            v({'x': 1})  # should fail but doesn't",
      "comment": "Might put this under a closed by default block as to not overwhelm users not using this complex functionality.",
      "comment_id": 1840567440,
      "user": "sydney-runkle",
      "created_at": "2024-11-13T15:19:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840567440"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +159,203 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+        self.pydantic_complete: bool = False\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(\n+        self, ns_resolver: _namespace_utils.NsResolver, force: bool, raise_errors: bool = False\n+    ) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the construction of the core schema, validator, and serializer.\n+                If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+            raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Raises:\n+            PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n+                and `raise_errors=True`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+            This method is very similar to `_model_construction.complete_model_class`, used for finalizing `BaseModel` subclasses.\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            which may not be types and thus do not have a `__module__` available.\n+            So instead we look at the globals in our parent stack frame.\n+\n+            It is expected that the `ns_resolver` passed to this function will have the correct\n+            namespace for the type we're adapting. See `TypeAdapter.__init__` and `TypeAdapter.rebuild`\n+            for various ways to construct this namespace.\n+\n+            This works for the case where this function is called in a module that\n+            has the target of forward references in its scope, but\n+            does not always work for more complex cases.\n+\n+            For example, take the following:\n+\n+            a.py\n+            ```python\n+            from typing import Dict, List\n+\n+            IntList = List[int]\n+            OuterDict = Dict[str, 'IntList']\n+            ```\n+\n+            b.py\n+            ```python test=\"skip\"\n+            from a import OuterDict\n+\n+            from pydantic import TypeAdapter\n+\n+            IntList = int  # replaces the symbol the forward reference is looking for\n+            v = TypeAdapter(OuterDict)\n+            v({'x': 1})  # should fail but doesn't",
      "comment": "> Might put this under a closed by default block as to not overwhelm users not using this complex functionality.\r\n\r\nYeah the ForwardRefs are such a can of worms... Not really necessarily relevant for the usual simple use-cases.",
      "comment_id": 1840577766,
      "user": "MarkusSintonen",
      "created_at": "2024-11-13T15:22:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840577766"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +159,203 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+        self.pydantic_complete: bool = False\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(\n+        self, ns_resolver: _namespace_utils.NsResolver, force: bool, raise_errors: bool = False\n+    ) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the construction of the core schema, validator, and serializer.\n+                If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+            raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Raises:\n+            PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n+                and `raise_errors=True`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+            This method is very similar to `_model_construction.complete_model_class`, used for finalizing `BaseModel` subclasses.\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            which may not be types and thus do not have a `__module__` available.\n+            So instead we look at the globals in our parent stack frame.\n+\n+            It is expected that the `ns_resolver` passed to this function will have the correct\n+            namespace for the type we're adapting. See `TypeAdapter.__init__` and `TypeAdapter.rebuild`\n+            for various ways to construct this namespace.\n+\n+            This works for the case where this function is called in a module that\n+            has the target of forward references in its scope, but\n+            does not always work for more complex cases.\n+\n+            For example, take the following:\n+\n+            a.py\n+            ```python\n+            from typing import Dict, List\n+\n+            IntList = List[int]\n+            OuterDict = Dict[str, 'IntList']\n+            ```\n+\n+            b.py\n+            ```python test=\"skip\"\n+            from a import OuterDict\n+\n+            from pydantic import TypeAdapter\n+\n+            IntList = int  # replaces the symbol the forward reference is looking for\n+            v = TypeAdapter(OuterDict)\n+            v({'x': 1})  # should fail but doesn't\n+            ```\n+\n+            If `OuterDict` were a `BaseModel`, this would work because it would resolve\n+            the forward reference within the `a.py` namespace.\n+            But `TypeAdapter(OuterDict)` can't determine what module `OuterDict` came from.\n+\n+            In other words, the assumption that _all_ forward references exist in the\n+            module we are being called from is not technically always true.\n+            Although most of the time it is and it works fine for recursive models and such,\n+            `BaseModel`'s behavior isn't perfect either and _can_ break in similar ways,\n+            so there is no right or wrong between the two.\n+\n+            But at the very least this behavior is _subtly_ different from `BaseModel`'s.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self.pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+\n+            # TODO: we don't go through the rebuild logic here directly because we don't want\n+            # to repeat all of the namespace fetching logic that we've already done\n+            # so we simply skip to the block below that does the actual schema generation\n+            if (\n+                isinstance(self.core_schema, _mock_val_ser.MockCoreSchema)\n+                or isinstance(self.validator, _mock_val_ser.MockValSer)\n+                or isinstance(self.serializer, _mock_val_ser.MockValSer)\n+            ):\n+                raise AttributeError()\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n+\n+            schema_generator = _generate_schema.GenerateSchema(config_wrapper, ns_resolver=ns_resolver)\n+\n+            try:\n+                core_schema = schema_generator.generate_schema(self._type)\n+            except PydanticUndefinedAnnotation:\n+                if raise_errors:\n+                    raise\n+                _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+                return False\n+\n+            try:\n+                self.core_schema = schema_generator.clean_schema(core_schema)\n+            except schema_generator.CollectedInvalid:\n+                _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+                return False",
      "comment": "I have seen the same try-catch-if-raise_error-mocking logic repeated in many places. Wondering could it be extracted to some common handling... Maybe later...",
      "comment_id": 1840587129,
      "user": "MarkusSintonen",
      "created_at": "2024-11-13T15:25:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840587129"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +159,203 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+        self.pydantic_complete: bool = False\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(\n+        self, ns_resolver: _namespace_utils.NsResolver, force: bool, raise_errors: bool = False\n+    ) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the construction of the core schema, validator, and serializer.\n+                If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+            raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Raises:\n+            PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n+                and `raise_errors=True`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+            This method is very similar to `_model_construction.complete_model_class`, used for finalizing `BaseModel` subclasses.\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            which may not be types and thus do not have a `__module__` available.\n+            So instead we look at the globals in our parent stack frame.\n+\n+            It is expected that the `ns_resolver` passed to this function will have the correct\n+            namespace for the type we're adapting. See `TypeAdapter.__init__` and `TypeAdapter.rebuild`\n+            for various ways to construct this namespace.\n+\n+            This works for the case where this function is called in a module that\n+            has the target of forward references in its scope, but\n+            does not always work for more complex cases.\n+\n+            For example, take the following:\n+\n+            a.py\n+            ```python\n+            from typing import Dict, List\n+\n+            IntList = List[int]\n+            OuterDict = Dict[str, 'IntList']\n+            ```\n+\n+            b.py\n+            ```python test=\"skip\"\n+            from a import OuterDict\n+\n+            from pydantic import TypeAdapter\n+\n+            IntList = int  # replaces the symbol the forward reference is looking for\n+            v = TypeAdapter(OuterDict)\n+            v({'x': 1})  # should fail but doesn't",
      "comment": "`rebuild` could be also one place to have this, or the class itself, dont know which is best...",
      "comment_id": 1840590030,
      "user": "MarkusSintonen",
      "created_at": "2024-11-13T15:26:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840590030"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 269,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +208,122 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(self, ns_resolver: _namespace_utils.NsResolver, force: bool) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the initialization of the core schema, validator, and serializer.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self._pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n             core_config = config_wrapper.core_config(None)\n \n-            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n-            self._validator = create_schema_validator(\n-                schema=self._core_schema,\n+            self.core_schema = _get_schema(self._type, config_wrapper, ns_resolver=ns_resolver)\n+            self.validator = create_schema_validator(\n+                schema=self.core_schema,\n                 schema_type=self._type,\n                 schema_type_module=self._module_name,\n                 schema_type_name=str(self._type),\n                 schema_kind='TypeAdapter',\n                 config=core_config,\n                 plugin_settings=config_wrapper.plugin_settings,\n             )\n-            self._serializer = SchemaSerializer(self._core_schema, core_config)\n-\n-        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._core_schema.rebuild()\n-            self._init_core_attrs(rebuild_mocks=False)\n-            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n-            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n-    def core_schema(self) -> CoreSchema:\n-        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n-        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n-        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n-        return self._core_schema\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n-        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))\n-        return self._validator\n-\n-    @cached_property\n-    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n-    def serializer(self) -> SchemaSerializer:\n-        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n-        if not isinstance(self._serializer, SchemaSerializer):\n-            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._serializer, SchemaSerializer)\n-        return self._serializer\n+            self.serializer = SchemaSerializer(self.core_schema, core_config)\n+\n+        # TODO: I think we should move this to the rebuild pattern?\n+        if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n+            self.core_schema = self.core_schema.rebuild()  # type: ignore[assignment]\n+            self._init_core_attrs(ns_resolver=ns_resolver, force=True)",
      "comment": "@sydney-runkle was there some test against the duplicated schema building issue? To test the the GenerateSchema is called only ones in this scenario, in case there was a bug here?",
      "comment_id": 1840597883,
      "user": "MarkusSintonen",
      "created_at": "2024-11-13T15:29:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840597883"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +159,203 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+        self.pydantic_complete: bool = False\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(\n+        self, ns_resolver: _namespace_utils.NsResolver, force: bool, raise_errors: bool = False\n+    ) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the construction of the core schema, validator, and serializer.\n+                If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+            raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Raises:\n+            PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n+                and `raise_errors=True`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+            This method is very similar to `_model_construction.complete_model_class`, used for finalizing `BaseModel` subclasses.\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            which may not be types and thus do not have a `__module__` available.\n+            So instead we look at the globals in our parent stack frame.\n+\n+            It is expected that the `ns_resolver` passed to this function will have the correct\n+            namespace for the type we're adapting. See `TypeAdapter.__init__` and `TypeAdapter.rebuild`\n+            for various ways to construct this namespace.\n+\n+            This works for the case where this function is called in a module that\n+            has the target of forward references in its scope, but\n+            does not always work for more complex cases.\n+\n+            For example, take the following:\n+\n+            a.py\n+            ```python\n+            from typing import Dict, List\n+\n+            IntList = List[int]\n+            OuterDict = Dict[str, 'IntList']\n+            ```\n+\n+            b.py\n+            ```python test=\"skip\"\n+            from a import OuterDict\n+\n+            from pydantic import TypeAdapter\n+\n+            IntList = int  # replaces the symbol the forward reference is looking for\n+            v = TypeAdapter(OuterDict)\n+            v({'x': 1})  # should fail but doesn't\n+            ```\n+\n+            If `OuterDict` were a `BaseModel`, this would work because it would resolve\n+            the forward reference within the `a.py` namespace.\n+            But `TypeAdapter(OuterDict)` can't determine what module `OuterDict` came from.\n+\n+            In other words, the assumption that _all_ forward references exist in the\n+            module we are being called from is not technically always true.\n+            Although most of the time it is and it works fine for recursive models and such,\n+            `BaseModel`'s behavior isn't perfect either and _can_ break in similar ways,\n+            so there is no right or wrong between the two.\n+\n+            But at the very least this behavior is _subtly_ different from `BaseModel`'s.\n+        \"\"\"\n+        if not force and self._defer_build:\n+            _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+            self.pydantic_complete = False\n+            return False\n+\n         try:\n-            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n-            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n-            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+            self.core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n+            self.validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n+            self.serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n+\n+            # TODO: we don't go through the rebuild logic here directly because we don't want\n+            # to repeat all of the namespace fetching logic that we've already done\n+            # so we simply skip to the block below that does the actual schema generation\n+            if (\n+                isinstance(self.core_schema, _mock_val_ser.MockCoreSchema)\n+                or isinstance(self.validator, _mock_val_ser.MockValSer)\n+                or isinstance(self.serializer, _mock_val_ser.MockValSer)\n+            ):\n+                raise AttributeError()\n         except AttributeError:\n             config_wrapper = _config.ConfigWrapper(self._config)\n+\n+            schema_generator = _generate_schema.GenerateSchema(config_wrapper, ns_resolver=ns_resolver)\n+\n+            try:\n+                core_schema = schema_generator.generate_schema(self._type)\n+            except PydanticUndefinedAnnotation:\n+                if raise_errors:\n+                    raise\n+                _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+                return False\n+\n+            try:\n+                self.core_schema = schema_generator.clean_schema(core_schema)\n+            except schema_generator.CollectedInvalid:\n+                _mock_val_ser.set_type_adapter_mocks(self, str(self._type))\n+                return False",
      "comment": "Maybe with https://github.com/pydantic/pydantic/commit/341a778521987f9a9bc91cf58c930e3c2fdb55e4, I can create an issue",
      "comment_id": 1840603484,
      "user": "sydney-runkle",
      "created_at": "2024-11-13T15:31:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840603484"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +159,203 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+        self.pydantic_complete: bool = False\n+\n+        localns: _namespace_utils.MappingNamespace = (\n+            _typing_extra.parent_frame_namespace(parent_depth=self._parent_depth) or {}\n+        )\n+        globalns: _namespace_utils.MappingNamespace = sys._getframe(max(self._parent_depth - 1, 1)).f_globals\n+        self._module_name = module or cast(str, globalns.get('__name__', ''))\n+        self._init_core_attrs(\n+            ns_resolver=_namespace_utils.NsResolver(\n+                namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n+                parent_namespace=localns,\n+            ),\n+            force=False,\n+        )\n+\n+    def _init_core_attrs(\n+        self, ns_resolver: _namespace_utils.NsResolver, force: bool, raise_errors: bool = False\n+    ) -> bool:\n+        \"\"\"Initialize the core schema, validator, and serializer for the type.\n+\n+        Args:\n+            ns_resolver: The namespace resolver to use when building the core schema for the adapted type.\n+            force: Whether to force the construction of the core schema, validator, and serializer.\n+                If `force` is set to `False` and `_defer_build` is `True`, the core schema, validator, and serializer will be set to mocks.\n+            raise_errors: Whether to raise errors if initializing any of the core attrs fails.\n+\n+        Returns:\n+            `True` if the core schema, validator, and serializer were successfully initialized, otherwise `False`.\n+\n+        Raises:\n+            PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n+                and `raise_errors=True`.\n+\n+        Notes on namespace management, and subtle differences from `BaseModel`:\n+            This method is very similar to `_model_construction.complete_model_class`, used for finalizing `BaseModel` subclasses.\n+\n+            `BaseModel` uses its own `__module__` to find out where it was defined\n+            and then looks for symbols to resolve forward references in those globals.\n+            On the other hand, `TypeAdapter` can be initialized with arbitrary objects,\n+            which may not be types and thus do not have a `__module__` available.\n+            So instead we look at the globals in our parent stack frame.\n+\n+            It is expected that the `ns_resolver` passed to this function will have the correct\n+            namespace for the type we're adapting. See `TypeAdapter.__init__` and `TypeAdapter.rebuild`\n+            for various ways to construct this namespace.\n+\n+            This works for the case where this function is called in a module that\n+            has the target of forward references in its scope, but\n+            does not always work for more complex cases.\n+\n+            For example, take the following:\n+\n+            a.py\n+            ```python\n+            from typing import Dict, List\n+\n+            IntList = List[int]\n+            OuterDict = Dict[str, 'IntList']\n+            ```\n+\n+            b.py\n+            ```python test=\"skip\"\n+            from a import OuterDict\n+\n+            from pydantic import TypeAdapter\n+\n+            IntList = int  # replaces the symbol the forward reference is looking for\n+            v = TypeAdapter(OuterDict)\n+            v({'x': 1})  # should fail but doesn't",
      "comment": "Maybe the class itself, honestly. Bc it applies to both `__init__` and `rebuild`",
      "comment_id": 1840608964,
      "user": "sydney-runkle",
      "created_at": "2024-11-13T15:32:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840608964"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,100 +212,153 @@ def __init__(\n         self._type = type\n         self._config = config\n         self._parent_depth = _parent_depth\n-        if module is None:\n-            f = sys._getframe(1)\n-            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n-        else:\n-            self._module_name = module\n-\n-        self._core_schema: CoreSchema | None = None\n-        self._validator: SchemaValidator | PluggableSchemaValidator | None = None\n-        self._serializer: SchemaSerializer | None = None\n-\n-        if not self._defer_build():\n-            # Immediately initialize the core schema, validator and serializer\n-            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n-                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n-                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n-                self._init_core_attrs(rebuild_mocks=False)\n-\n-    @contextmanager\n-    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n-        self._parent_depth += depth\n-        try:\n-            yield\n-        finally:\n-            self._parent_depth -= depth\n \n-    @_frame_depth(1)\n-    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n+        self.core_schema: CoreSchema\n+        self.validator: SchemaValidator | PluggableSchemaValidator\n+        self.serializer: SchemaSerializer\n+        self.pydantic_complete: bool = False\n+\n+        localns: _namespace_utils.MappingNamespace = (",
      "comment": "I don't think you need the explicit annotations for `localns` and `globalns`?",
      "comment_id": 1840667174,
      "user": "Viicos",
      "created_at": "2024-11-13T15:52:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840667174"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,8 +109,48 @@ def rebuild(self) -> ValSer | None:\n         return None\n \n \n+def set_type_adapter_mocks(adapter: TypeAdapter, type_repr: str) -> None:\n+    \"\"\"Set `core_schema`, `validator` and `serializer` to mock core types on a type adapter instance.\n+\n+    Args:\n+        adapter: The type adapter instance to set the mocks on\n+        type_repr: Name of the type used in the adapter, used in error messages\n+    \"\"\"\n+    undefined_type_error_message = (\n+        f'`TypeAdapter[{type_repr}]` is not fully defined; you should define `{type_repr}` and all referenced types,'",
      "comment": "you could probably rework the APIs a bit to make it possible to defer the cost of computing the error message if it's a concern. Like, make MockCoreSchema accept a callable for the error message rather than just a string",
      "comment_id": 1840753117,
      "user": "dmontagu",
      "created_at": "2024-11-13T16:27:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840753117"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -231,7 +231,12 @@ def __init__(\n     def types_namespace(self) -> NamespacesTuple:\n         \"\"\"The current global and local namespaces to be used for annotations evaluation.\"\"\"\n         if not self._types_stack:\n-            # TODO do we want to merge `self._parent_ns` here?\n+            # TODO: should we merge the parent namespace here?\n+            # if self._parent_ns is not None:\n+            #     # Hacky workarounds, see class docstring:\n+            #     # An optional parent namespace that will be added to the locals with the lowest priority\n+            #     locals_list: list[MappingNamespace] = [self._parent_ns, self._base_ns_tuple.locals]\n+            #     return NamespacesTuple(self._base_ns_tuple.globals, LazyLocalNamespace(*locals_list))",
      "comment": "Don't know where the comment originally came from, but I feel if we are going to add a bunch of content here, it's probably worth mentioning why it's even a question whether we should. Like, is there some scenario where it makes sense vs. doesn't? Do we even know? Lol.\r\n\r\nI also recognize I _may_ have been the one to write that comment originally; either way I certainly don't have the answers today.",
      "comment_id": 1840759275,
      "user": "dmontagu",
      "created_at": "2024-11-13T16:29:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840759275"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -231,7 +231,12 @@ def __init__(\n     def types_namespace(self) -> NamespacesTuple:\n         \"\"\"The current global and local namespaces to be used for annotations evaluation.\"\"\"\n         if not self._types_stack:\n-            # TODO do we want to merge `self._parent_ns` here?\n+            # TODO: should we merge the parent namespace here?\n+            # if self._parent_ns is not None:\n+            #     # Hacky workarounds, see class docstring:\n+            #     # An optional parent namespace that will be added to the locals with the lowest priority\n+            #     locals_list: list[MappingNamespace] = [self._parent_ns, self._base_ns_tuple.locals]\n+            #     return NamespacesTuple(self._base_ns_tuple.globals, LazyLocalNamespace(*locals_list))",
      "comment": "This part of the comment:\r\n\r\n```python\r\nlocals_list: list[MappingNamespace] = [self._parent_ns, self._base_ns_tuple.locals]\r\nreturn NamespacesTuple(self._base_ns_tuple.globals, LazyLocalNamespace(*locals_list))\r\n```\r\n\r\nis something we discussed with Sydney this week, but seems like another option was used.\r\n\r\n> Like, is there some scenario where it makes sense vs. doesn't?\r\n\r\nThe class docstring has examples and a better explanation as to why we do this merging",
      "comment_id": 1840787963,
      "user": "Viicos",
      "created_at": "2024-11-13T16:42:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840787963"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/type_adapter.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,6 +79,59 @@ class TypeAdapter(Generic[T]):\n         core_schema: The core schema for the type.\n         validator (SchemaValidator): The schema validator for the type.\n         serializer: The schema serializer for the type.\n+\n+    ??? info \"Namespace management nuances and implementation details\"\n+\n+        Here, we collect some notes on namespace management, and subtle differences from `BaseModel`:\n+\n+        This method is very similar to `_model_construction.complete_model_class`, used for finalizing `BaseModel` subclasses.",
      "comment": "As the docstring was moved, there's no longer a _method_ to refer to. As this will be in the public API docs, maybe it's also best to avoid mentioning a private function?",
      "comment_id": 1840791829,
      "user": "Viicos",
      "created_at": "2024-11-13T16:43:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840791829"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -231,7 +231,12 @@ def __init__(\n     def types_namespace(self) -> NamespacesTuple:\n         \"\"\"The current global and local namespaces to be used for annotations evaluation.\"\"\"\n         if not self._types_stack:\n-            # TODO do we want to merge `self._parent_ns` here?\n+            # TODO: should we merge the parent namespace here?\n+            # if self._parent_ns is not None:\n+            #     # Hacky workarounds, see class docstring:\n+            #     # An optional parent namespace that will be added to the locals with the lowest priority\n+            #     locals_list: list[MappingNamespace] = [self._parent_ns, self._base_ns_tuple.locals]\n+            #     return NamespacesTuple(self._base_ns_tuple.globals, LazyLocalNamespace(*locals_list))",
      "comment": "@Viicos, do you think the approach I've taken is ok, or would you prefer we merge in this location?",
      "comment_id": 1840826137,
      "user": "sydney-runkle",
      "created_at": "2024-11-13T16:56:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1840826137"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10537,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,8 +109,48 @@ def rebuild(self) -> ValSer | None:\n         return None\n \n \n+def set_type_adapter_mocks(adapter: TypeAdapter, type_repr: str) -> None:\n+    \"\"\"Set `core_schema`, `validator` and `serializer` to mock core types on a type adapter instance.\n+\n+    Args:\n+        adapter: The type adapter instance to set the mocks on\n+        type_repr: Name of the type used in the adapter, used in error messages\n+    \"\"\"\n+    undefined_type_error_message = (\n+        f'`TypeAdapter[{type_repr}]` is not fully defined; you should define `{type_repr}` and all referenced types,'",
      "comment": "Suggested the same in other [comment](https://github.com/pydantic/pydantic/pull/10537#discussion_r1838395713) about making the error message forming lazy. So it only happens on errors",
      "comment_id": 1841057809,
      "user": "MarkusSintonen",
      "created_at": "2024-11-13T19:36:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/10537#discussion_r1841057809"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10823,
      "file_path": "pydantic/_internal/_discriminated_union.py",
      "line": 164,
      "side": "RIGHT",
      "diff_hunk": "@@ -161,7 +161,7 @@ def __init__(self, discriminator: str, definitions: dict[str, core_schema.CoreSc\n         # in the output TaggedUnionSchema that will replace the union from the input schema\n         self._tagged_union_choices: dict[Hashable, core_schema.CoreSchema] = {}\n \n-        # `_used` is changed to True after applying the discriminator to prevent accidental re-use\n+        # `_used` is changed to True after applying the discriminator to prevent accidental reuse",
      "comment": "Lol not sure why we didn't think `reuse` was a word",
      "comment_id": 1839334424,
      "user": "sydney-runkle",
      "created_at": "2024-11-13T03:24:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10823#discussion_r1839334424"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10823,
      "file_path": "pydantic/_internal/_discriminated_union.py",
      "line": 164,
      "side": "RIGHT",
      "diff_hunk": "@@ -161,7 +161,7 @@ def __init__(self, discriminator: str, definitions: dict[str, core_schema.CoreSc\n         # in the output TaggedUnionSchema that will replace the union from the input schema\n         self._tagged_union_choices: dict[Hashable, core_schema.CoreSchema] = {}\n \n-        # `_used` is changed to True after applying the discriminator to prevent accidental re-use\n+        # `_used` is changed to True after applying the discriminator to prevent accidental reuse",
      "comment": "It's apparently common to use `re-use` as well, but let's comply with codespell here :)",
      "comment_id": 1839594268,
      "user": "Viicos",
      "created_at": "2024-11-13T06:54:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10823#discussion_r1839594268"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10818,
      "file_path": "pydantic/_internal/_utils.py",
      "line": 307,
      "side": "RIGHT",
      "diff_hunk": "@@ -298,18 +299,23 @@ def __repr_args__(self) -> _repr.ReprArgs:\n \n if typing.TYPE_CHECKING:\n \n-    def ClassAttribute(name: str, value: T) -> T: ...\n+    def LazyClassAttribute(name: str, value_fetcher: Callable[[], T]) -> T: ...\n \n else:\n \n-    class ClassAttribute:\n-        \"\"\"Hide class attribute from its instances.\"\"\"\n+    class LazyClassAttribute:\n+        \"\"\"A descriptor exposing an attribute only on class access.",
      "comment": "```suggestion\r\n        \"\"\"A descriptor exposing an attribute only accessible on a class (hidden from instances).\r\n```",
      "comment_id": 1837169068,
      "user": "sydney-runkle",
      "created_at": "2024-11-11T20:40:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/10818#discussion_r1837169068"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10818,
      "file_path": "pydantic/_internal/_utils.py",
      "line": 302,
      "side": "RIGHT",
      "diff_hunk": "@@ -298,18 +299,23 @@ def __repr_args__(self) -> _repr.ReprArgs:\n \n if typing.TYPE_CHECKING:\n \n-    def ClassAttribute(name: str, value: T) -> T: ...\n+    def LazyClassAttribute(name: str, value_fetcher: Callable[[], T]) -> T: ...",
      "comment": "```suggestion\r\n    def LazyClassAttribute(name: str, get_value: Callable[[], T]) -> T: ...\r\n```\r\n\r\nMaybe?",
      "comment_id": 1837169991,
      "user": "sydney-runkle",
      "created_at": "2024-11-11T20:41:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10818#discussion_r1837169991"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10815,
      "file_path": "tests/test_pickle.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,14 +3,20 @@\n import pickle\n from typing import Optional, Type\n \n-import cloudpickle\n import pytest\n \n import pydantic\n from pydantic import BaseModel, PositiveFloat, ValidationError\n from pydantic._internal._model_construction import _PydanticWeakRef\n from pydantic.config import ConfigDict\n \n+try:\n+    import cloudpickle\n+except ImportError:\n+    cloudpickle = None\n+\n+pytestmark = pytest.mark.skipif(cloudpickle is None, reason='cloudpickle is not installed')",
      "comment": "Not every test here requires `cloudpickle`, right?",
      "comment_id": 1836866710,
      "user": "sydney-runkle",
      "created_at": "2024-11-11T15:41:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10815#discussion_r1836866710"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10815,
      "file_path": "tests/test_pickle.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,14 +3,20 @@\n import pickle\n from typing import Optional, Type\n \n-import cloudpickle\n import pytest\n \n import pydantic\n from pydantic import BaseModel, PositiveFloat, ValidationError\n from pydantic._internal._model_construction import _PydanticWeakRef\n from pydantic.config import ConfigDict\n \n+try:\n+    import cloudpickle\n+except ImportError:\n+    cloudpickle = None\n+\n+pytestmark = pytest.mark.skipif(cloudpickle is None, reason='cloudpickle is not installed')",
      "comment": "I just assumed most do, I can go though one by one if it's necessary.",
      "comment_id": 1836890278,
      "user": "samuelcolvin",
      "created_at": "2024-11-11T15:59:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/10815#discussion_r1836890278"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10798,
      "file_path": "pydantic/networks.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -206,6 +206,9 @@ def __repr__(self) -> str:\n     def __deepcopy__(self, memo: dict) -> Self:\n         return self.__class__(self._url)\n \n+    def __eq__(self, other: Any) -> bool:\n+        return (self._url == other._url) and (self.__class__ == other.__class__)",
      "comment": "```suggestion\r\n        return self.__class__ is other.__class__ and self._url == other._url\r\n```",
      "comment_id": 1834903940,
      "user": "Viicos",
      "created_at": "2024-11-08T18:51:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10798#discussion_r1834903940"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10798,
      "file_path": "pydantic/networks.py",
      "line": 366,
      "side": "RIGHT",
      "diff_hunk": "@@ -359,6 +362,9 @@ def __repr__(self) -> str:\n     def __deepcopy__(self, memo: dict) -> Self:\n         return self.__class__(self._url)\n \n+    def __eq__(self, other: Any) -> bool:\n+        return (self._url == other._url) and (self.__class__ == other.__class__)",
      "comment": "```suggestion\r\n        return self.__class__ is other.__class__ and self._url == other._url\r\n```",
      "comment_id": 1834904078,
      "user": "Viicos",
      "created_at": "2024-11-08T18:51:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/10798#discussion_r1834904078"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10725,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,7 +33,7 @@\n     _make_forward_ref,\n     eval_type_backport,\n     is_annotated,\n-    is_classvar,\n+    is_classvar_annotation,",
      "comment": "Should we follow the same pattern here and just do `import _typing_extra` then call associated methods like `_typing_extra.XXX`?",
      "comment_id": 1825745805,
      "user": "sydney-runkle",
      "created_at": "2024-11-01T12:05:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/10725#discussion_r1825745805"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10725,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,192 +1,414 @@\n-\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module.\"\"\"\n+\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap Python's typing module.\"\"\"\n \n-from __future__ import annotations as _annotations\n+from __future__ import annotations\n \n-import dataclasses\n+import collections.abc\n import re\n import sys\n import types\n import typing\n import warnings\n-from collections.abc import Callable\n-from functools import partial\n-from types import GetSetDescriptorType\n-from typing import TYPE_CHECKING, Any, Final\n+from functools import lru_cache, partial\n+from typing import Any, Callable\n \n-from typing_extensions import Annotated, Literal, TypeAliasType, TypeGuard, Unpack, deprecated, get_args, get_origin\n+import typing_extensions\n+from typing_extensions import TypeIs, deprecated, get_args, get_origin\n \n from ._namespace_utils import GlobalsNamespace, MappingNamespace, NsResolver, get_module_ns_of\n \n-if TYPE_CHECKING:\n-    from ._dataclasses import StandardDataclass\n+if sys.version_info < (3, 10):\n+    NoneType = type(None)\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType as EllipsisType\n+    from types import NoneType as NoneType\n \n-try:\n-    from typing import _TypingBase  # type: ignore[attr-defined]\n-except ImportError:\n-    from typing import _Final as _TypingBase  # type: ignore[attr-defined]\n \n-typing_base = _TypingBase\n+# See https://typing-extensions.readthedocs.io/en/latest/#runtime-use-of-types:\n \n \n-if sys.version_info < (3, 9):\n-    # python < 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)\n-    TypingGenericAlias = ()\n-else:\n-    from typing import GenericAlias as TypingGenericAlias  # type: ignore\n+@lru_cache(maxsize=None)\n+def _get_typing_objects_by_name_of(name: str) -> tuple[Any, ...]:\n+    result = tuple(getattr(module, name) for module in (typing, typing_extensions) if hasattr(module, name))\n+    if not result:\n+        raise ValueError(f'Neither typing nor typing_extensions has an object called {name!r}')",
      "comment": "```suggestion\r\n        raise ValueError(f'Neither `typing` nor `typing_extensions` has an object called {name!r}')\r\n```",
      "comment_id": 1825749665,
      "user": "sydney-runkle",
      "created_at": "2024-11-01T12:09:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/10725#discussion_r1825749665"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10725,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,192 +1,414 @@\n-\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module.\"\"\"\n+\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap Python's typing module.\"\"\"\n \n-from __future__ import annotations as _annotations\n+from __future__ import annotations\n \n-import dataclasses\n+import collections.abc\n import re\n import sys\n import types\n import typing\n import warnings\n-from collections.abc import Callable\n-from functools import partial\n-from types import GetSetDescriptorType\n-from typing import TYPE_CHECKING, Any, Final\n+from functools import lru_cache, partial\n+from typing import Any, Callable\n \n-from typing_extensions import Annotated, Literal, TypeAliasType, TypeGuard, Unpack, deprecated, get_args, get_origin\n+import typing_extensions\n+from typing_extensions import TypeIs, deprecated, get_args, get_origin\n \n from ._namespace_utils import GlobalsNamespace, MappingNamespace, NsResolver, get_module_ns_of\n \n-if TYPE_CHECKING:\n-    from ._dataclasses import StandardDataclass\n+if sys.version_info < (3, 10):\n+    NoneType = type(None)\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType as EllipsisType\n+    from types import NoneType as NoneType\n \n-try:\n-    from typing import _TypingBase  # type: ignore[attr-defined]\n-except ImportError:\n-    from typing import _Final as _TypingBase  # type: ignore[attr-defined]\n \n-typing_base = _TypingBase\n+# See https://typing-extensions.readthedocs.io/en/latest/#runtime-use-of-types:\n \n \n-if sys.version_info < (3, 9):\n-    # python < 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)\n-    TypingGenericAlias = ()\n-else:\n-    from typing import GenericAlias as TypingGenericAlias  # type: ignore\n+@lru_cache(maxsize=None)\n+def _get_typing_objects_by_name_of(name: str) -> tuple[Any, ...]:\n+    result = tuple(getattr(module, name) for module in (typing, typing_extensions) if hasattr(module, name))\n+    if not result:\n+        raise ValueError(f'Neither typing nor typing_extensions has an object called {name!r}')\n+    return result\n \n \n-if sys.version_info < (3, 11):\n-    from typing_extensions import NotRequired, Required\n-else:\n-    from typing import NotRequired, Required  # noqa: F401\n+# As suggested by the `typing-extensions` documentation, we could apply caching to this method,\n+# but it doesn't seem to improve performance. This also requires `obj` to be hashable, which\n+# might not be always the case:\n+def _is_typing_name(obj: object, name: str) -> bool:\n+    # Using `any()` is slower:",
      "comment": "Can we add a docstring to this function and the one above? If you're switching contexts into the world of typing and types management, a little description here could really help.",
      "comment_id": 1825751124,
      "user": "sydney-runkle",
      "created_at": "2024-11-01T12:11:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10725#discussion_r1825751124"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10725,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,192 +1,414 @@\n-\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module.\"\"\"\n+\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap Python's typing module.\"\"\"\n \n-from __future__ import annotations as _annotations\n+from __future__ import annotations\n \n-import dataclasses\n+import collections.abc\n import re\n import sys\n import types\n import typing\n import warnings\n-from collections.abc import Callable\n-from functools import partial\n-from types import GetSetDescriptorType\n-from typing import TYPE_CHECKING, Any, Final\n+from functools import lru_cache, partial\n+from typing import Any, Callable\n \n-from typing_extensions import Annotated, Literal, TypeAliasType, TypeGuard, Unpack, deprecated, get_args, get_origin\n+import typing_extensions\n+from typing_extensions import TypeIs, deprecated, get_args, get_origin\n \n from ._namespace_utils import GlobalsNamespace, MappingNamespace, NsResolver, get_module_ns_of\n \n-if TYPE_CHECKING:\n-    from ._dataclasses import StandardDataclass\n+if sys.version_info < (3, 10):\n+    NoneType = type(None)\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType as EllipsisType\n+    from types import NoneType as NoneType\n \n-try:\n-    from typing import _TypingBase  # type: ignore[attr-defined]\n-except ImportError:\n-    from typing import _Final as _TypingBase  # type: ignore[attr-defined]\n \n-typing_base = _TypingBase\n+# See https://typing-extensions.readthedocs.io/en/latest/#runtime-use-of-types:\n \n \n-if sys.version_info < (3, 9):\n-    # python < 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)\n-    TypingGenericAlias = ()\n-else:\n-    from typing import GenericAlias as TypingGenericAlias  # type: ignore\n+@lru_cache(maxsize=None)\n+def _get_typing_objects_by_name_of(name: str) -> tuple[Any, ...]:\n+    result = tuple(getattr(module, name) for module in (typing, typing_extensions) if hasattr(module, name))\n+    if not result:\n+        raise ValueError(f'Neither typing nor typing_extensions has an object called {name!r}')\n+    return result\n \n \n-if sys.version_info < (3, 11):\n-    from typing_extensions import NotRequired, Required\n-else:\n-    from typing import NotRequired, Required  # noqa: F401\n+# As suggested by the `typing-extensions` documentation, we could apply caching to this method,\n+# but it doesn't seem to improve performance. This also requires `obj` to be hashable, which\n+# might not be always the case:\n+def _is_typing_name(obj: object, name: str) -> bool:\n+    # Using `any()` is slower:\n+    for thing in _get_typing_objects_by_name_of(name):\n+        if obj is thing:\n+            return True\n+    return False\n \n \n-if sys.version_info < (3, 10):\n+def is_any(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is the `Any` special form.\n \n-    def origin_is_union(tp: type[Any] | None) -> bool:\n-        return tp is typing.Union\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_any(Any)\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(tp, name='Any')\n \n-    WithArgsTypes = (TypingGenericAlias,)\n \n-else:\n+def is_union(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Union` special form.\n \n-    def origin_is_union(tp: type[Any] | None) -> bool:\n-        return tp is typing.Union or tp is types.UnionType\n+    ```python test=\"skip\" lint=\"skip\"",
      "comment": "I guess skipping testing and linting here is fine bc this is an internal module \ud83d\udc4d ",
      "comment_id": 1825751703,
      "user": "sydney-runkle",
      "created_at": "2024-11-01T12:12:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10725#discussion_r1825751703"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10725,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 205,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,192 +1,414 @@\n-\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module.\"\"\"\n+\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap Python's typing module.\"\"\"\n \n-from __future__ import annotations as _annotations\n+from __future__ import annotations\n \n-import dataclasses\n+import collections.abc\n import re\n import sys\n import types\n import typing\n import warnings\n-from collections.abc import Callable\n-from functools import partial\n-from types import GetSetDescriptorType\n-from typing import TYPE_CHECKING, Any, Final\n+from functools import lru_cache, partial\n+from typing import Any, Callable\n \n-from typing_extensions import Annotated, Literal, TypeAliasType, TypeGuard, Unpack, deprecated, get_args, get_origin\n+import typing_extensions\n+from typing_extensions import TypeIs, deprecated, get_args, get_origin\n \n from ._namespace_utils import GlobalsNamespace, MappingNamespace, NsResolver, get_module_ns_of\n \n-if TYPE_CHECKING:\n-    from ._dataclasses import StandardDataclass\n+if sys.version_info < (3, 10):\n+    NoneType = type(None)\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType as EllipsisType\n+    from types import NoneType as NoneType\n \n-try:\n-    from typing import _TypingBase  # type: ignore[attr-defined]\n-except ImportError:\n-    from typing import _Final as _TypingBase  # type: ignore[attr-defined]\n \n-typing_base = _TypingBase\n+# See https://typing-extensions.readthedocs.io/en/latest/#runtime-use-of-types:\n \n \n-if sys.version_info < (3, 9):\n-    # python < 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)\n-    TypingGenericAlias = ()\n-else:\n-    from typing import GenericAlias as TypingGenericAlias  # type: ignore\n+@lru_cache(maxsize=None)\n+def _get_typing_objects_by_name_of(name: str) -> tuple[Any, ...]:\n+    result = tuple(getattr(module, name) for module in (typing, typing_extensions) if hasattr(module, name))\n+    if not result:\n+        raise ValueError(f'Neither typing nor typing_extensions has an object called {name!r}')\n+    return result\n \n \n-if sys.version_info < (3, 11):\n-    from typing_extensions import NotRequired, Required\n-else:\n-    from typing import NotRequired, Required  # noqa: F401\n+# As suggested by the `typing-extensions` documentation, we could apply caching to this method,\n+# but it doesn't seem to improve performance. This also requires `obj` to be hashable, which\n+# might not be always the case:\n+def _is_typing_name(obj: object, name: str) -> bool:\n+    # Using `any()` is slower:\n+    for thing in _get_typing_objects_by_name_of(name):\n+        if obj is thing:\n+            return True\n+    return False\n \n \n-if sys.version_info < (3, 10):\n+def is_any(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is the `Any` special form.\n \n-    def origin_is_union(tp: type[Any] | None) -> bool:\n-        return tp is typing.Union\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_any(Any)\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(tp, name='Any')\n \n-    WithArgsTypes = (TypingGenericAlias,)\n \n-else:\n+def is_union(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Union` special form.\n \n-    def origin_is_union(tp: type[Any] | None) -> bool:\n-        return tp is typing.Union or tp is types.UnionType\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_union(Union[int, str])\n+    #> True\n+    is_union(int | str)\n+    #> False\n+    ```\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='Union')\n \n-    WithArgsTypes = typing._GenericAlias, types.GenericAlias, types.UnionType  # type: ignore[attr-defined]\n \n+def is_literal(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Literal` special form.\n \n-if sys.version_info < (3, 10):\n-    NoneType = type(None)\n-    EllipsisType = type(Ellipsis)\n-else:\n-    from types import NoneType as NoneType\n-\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_literal(Literal[42])\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='Literal')\n \n-LITERAL_TYPES: set[Any] = {Literal}\n-if hasattr(typing, 'Literal'):\n-    LITERAL_TYPES.add(typing.Literal)\n \n-UNPACK_TYPES: set[Any] = {Unpack}\n-if hasattr(typing, 'Unpack'):\n-    UNPACK_TYPES.add(typing.Unpack)  # pyright: ignore[reportAttributeAccessIssue]\n+# TODO remove and replace with `get_args` when we drop support for Python 3.8\n+# (see https://docs.python.org/3/whatsnew/3.9.html#id4).\n+def literal_values(tp: Any, /) -> list[Any]:\n+    \"\"\"Return the values contained in the provided `Literal` special form.\"\"\"\n+    if not is_literal(tp):\n+        return [tp]\n \n-# Check if `deprecated` is a type to prevent errors when using typing_extensions < 4.9.0\n-DEPRECATED_TYPES: tuple[Any, ...] = (deprecated,) if isinstance(deprecated, type) else ()\n-if hasattr(warnings, 'deprecated'):\n-    DEPRECATED_TYPES = (*DEPRECATED_TYPES, warnings.deprecated)  # type: ignore\n+    values = get_args(tp)\n+    return [x for value in values for x in literal_values(value)]\n \n-NONE_TYPES: tuple[Any, ...] = (None, NoneType, *(tp[None] for tp in LITERAL_TYPES))\n \n-# should check for both variant of types for typing_extensions > 4.12.2\n-# https://typing-extensions.readthedocs.io/en/latest/#runtime-use-of-types\n-TYPE_ALIAS_TYPES: tuple[type, ...] = (\n-    (TypeAliasType, typing.TypeAliasType) if hasattr(typing, 'TypeAliasType') else (TypeAliasType,)\n-)\n+def is_annotated(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Annotated` special form.\n \n+    ```python test=\"skip\" lint=\"skip\"\n+    is_annotated(Annotated[int, ...])\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='Annotated')\n \n-TypeVarType = Any  # since mypy doesn't allow the use of TypeVar as a type\n \n+def annotated_type(tp: Any, /) -> Any | None:\n+    \"\"\"Return the type of the `Annotated` special form, or `None`.\"\"\"\n+    return get_args(tp)[0] if is_annotated(tp) else None\n \n-def is_none_type(type_: Any) -> bool:\n-    return type_ in NONE_TYPES\n \n+def is_unpack(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Unpack` special form.\n \n-def is_callable_type(type_: type[Any]) -> bool:\n-    return type_ is Callable or get_origin(type_) is Callable\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_unpack(Unpack[Ts])\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='Unpack')\n \n \n-def is_literal_type(type_: type[Any]) -> bool:\n-    return Literal is not None and get_origin(type_) in LITERAL_TYPES\n+def unpack_type(tp: Any, /) -> Any | None:\n+    \"\"\"Return the type wrapped by the `Unpack` special form, or `None`.\"\"\"\n+    return get_args(tp)[0] if is_unpack(tp) else None\n \n \n-def is_deprecated_instance(instance: Any) -> TypeGuard[deprecated]:\n-    return isinstance(instance, DEPRECATED_TYPES)\n+def is_self(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is the `Self` special form.\n \n+    ```python test=\"skip\" lint=\"skip\"\n+    is_self(Self)\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(tp, name='Self')\n \n-def literal_values(type_: type[Any]) -> tuple[Any, ...]:\n-    return get_args(type_)\n \n+def is_new_type(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `NewType`.\n \n-# TODO remove when we drop support for Python 3.8\n-# (see https://docs.python.org/3/whatsnew/3.9.html#id4).\n-def all_literal_values(type_: type[Any]) -> list[Any]:\n-    \"\"\"This method is used to retrieve all Literal values as\n-    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)\n-    e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`.\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_new_type(NewType('MyInt', int))\n+    #> True\n+    ```\n     \"\"\"\n-    if not is_literal_type(type_):\n-        return [type_]\n+    if sys.version_info < (3, 10):\n+        # On Python < 3.10, `typing.NewType` is a function\n+        return hasattr(tp, '__supertype__')\n+    else:\n+        return _is_typing_name(type(tp), name='NewType')\n \n-    values = literal_values(type_)\n-    return [x for value in values for x in all_literal_values(value)]\n \n+def is_hashable(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is the `Hashable` class.\n \n-def is_annotated(ann_type: Any) -> bool:\n-    return get_origin(ann_type) is Annotated\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_hashable(Hashable)\n+    #> True\n+    ```\n+    \"\"\"\n+    # `get_origin` is documented as normalizing any typing-module aliases to `collections` classes,\n+    # hence the second check:\n+    return tp is collections.abc.Hashable or get_origin(tp) is collections.abc.Hashable\n+\n+\n+def is_callable(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Callable`, parametrized or not.\n+\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_callable(Callable[[int], str])\n+    #> True\n+    is_callable(typing.Callable)\n+    #> True\n+    is_callable(collections.abc.Callable)\n+    #> True\n+    ```\n+    \"\"\"\n+    # `get_origin` is documented as normalizing any typing-module aliases to `collections` classes,\n+    # hence the second check:\n+    return tp is collections.abc.Callable or get_origin(tp) is collections.abc.Callable\n \n \n-def annotated_type(type_: Any) -> Any | None:\n-    return get_args(type_)[0] if is_annotated(type_) else None\n+_PARAMSPEC_TYPES: tuple[type[typing_extensions.ParamSpec], ...] = (typing_extensions.ParamSpec,)\n+if sys.version_info >= (3, 10):\n+    _PARAMSPEC_TYPES = (*_PARAMSPEC_TYPES, typing.ParamSpec)  # pyright: ignore[reportAssignmentType]\n \n \n-def is_unpack(type_: Any) -> bool:\n-    return get_origin(type_) in UNPACK_TYPES\n+def is_paramspec(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `ParamSpec`.\n \n+    ```python test=\"skip\" lint=\"skip\"\n+    P = ParamSpec('P')\n+    is_paramspec(P)\n+    #> True\n+    ```\n+    \"\"\"\n+    return isinstance(tp, _PARAMSPEC_TYPES)\n \n-def unpack_type(type_: Any) -> Any | None:\n-    return get_args(type_)[0] if is_unpack(type_) else None\n \n+_TYPEALIASTYPES: tuple[type[typing_extensions.TypeAliasType], ...] = (typing_extensions.TypeAliasType,)\n+if sys.version_info >= (3, 12):\n+    _TYPEALIASTYPES = (*_TYPEALIASTYPES, typing.TypeAliasType)\n \n-def is_namedtuple(type_: type[Any]) -> bool:\n-    \"\"\"Check if a given class is a named tuple.\n-    It can be either a `typing.NamedTuple` or `collections.namedtuple`.\n-    \"\"\"\n-    from ._utils import lenient_issubclass\n \n-    return lenient_issubclass(type_, tuple) and hasattr(type_, '_fields')\n+def is_typealiastype(tp: Any, /) -> TypeIs[typing_extensions.TypeAliasType]:",
      "comment": "Same as above, would prefer `is_type_alias_type` given that it's pascal cased to imply 3 separate words",
      "comment_id": 1825752841,
      "user": "sydney-runkle",
      "created_at": "2024-11-01T12:13:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10725#discussion_r1825752841"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10725,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 397,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,192 +1,414 @@\n-\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module.\"\"\"\n+\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap Python's typing module.\"\"\"\n \n-from __future__ import annotations as _annotations\n+from __future__ import annotations\n \n-import dataclasses\n+import collections.abc\n import re\n import sys\n import types\n import typing\n import warnings\n-from collections.abc import Callable\n-from functools import partial\n-from types import GetSetDescriptorType\n-from typing import TYPE_CHECKING, Any, Final\n+from functools import lru_cache, partial\n+from typing import Any, Callable\n \n-from typing_extensions import Annotated, Literal, TypeAliasType, TypeGuard, Unpack, deprecated, get_args, get_origin\n+import typing_extensions\n+from typing_extensions import TypeIs, deprecated, get_args, get_origin\n \n from ._namespace_utils import GlobalsNamespace, MappingNamespace, NsResolver, get_module_ns_of\n \n-if TYPE_CHECKING:\n-    from ._dataclasses import StandardDataclass\n+if sys.version_info < (3, 10):\n+    NoneType = type(None)\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType as EllipsisType\n+    from types import NoneType as NoneType\n \n-try:\n-    from typing import _TypingBase  # type: ignore[attr-defined]\n-except ImportError:\n-    from typing import _Final as _TypingBase  # type: ignore[attr-defined]\n \n-typing_base = _TypingBase\n+# See https://typing-extensions.readthedocs.io/en/latest/#runtime-use-of-types:\n \n \n-if sys.version_info < (3, 9):\n-    # python < 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)\n-    TypingGenericAlias = ()\n-else:\n-    from typing import GenericAlias as TypingGenericAlias  # type: ignore\n+@lru_cache(maxsize=None)\n+def _get_typing_objects_by_name_of(name: str) -> tuple[Any, ...]:\n+    result = tuple(getattr(module, name) for module in (typing, typing_extensions) if hasattr(module, name))\n+    if not result:\n+        raise ValueError(f'Neither typing nor typing_extensions has an object called {name!r}')\n+    return result\n \n \n-if sys.version_info < (3, 11):\n-    from typing_extensions import NotRequired, Required\n-else:\n-    from typing import NotRequired, Required  # noqa: F401\n+# As suggested by the `typing-extensions` documentation, we could apply caching to this method,\n+# but it doesn't seem to improve performance. This also requires `obj` to be hashable, which\n+# might not be always the case:\n+def _is_typing_name(obj: object, name: str) -> bool:\n+    # Using `any()` is slower:\n+    for thing in _get_typing_objects_by_name_of(name):\n+        if obj is thing:\n+            return True\n+    return False\n \n \n-if sys.version_info < (3, 10):\n+def is_any(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is the `Any` special form.\n \n-    def origin_is_union(tp: type[Any] | None) -> bool:\n-        return tp is typing.Union\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_any(Any)\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(tp, name='Any')\n \n-    WithArgsTypes = (TypingGenericAlias,)\n \n-else:\n+def is_union(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Union` special form.\n \n-    def origin_is_union(tp: type[Any] | None) -> bool:\n-        return tp is typing.Union or tp is types.UnionType\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_union(Union[int, str])\n+    #> True\n+    is_union(int | str)\n+    #> False\n+    ```\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='Union')\n \n-    WithArgsTypes = typing._GenericAlias, types.GenericAlias, types.UnionType  # type: ignore[attr-defined]\n \n+def is_literal(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Literal` special form.\n \n-if sys.version_info < (3, 10):\n-    NoneType = type(None)\n-    EllipsisType = type(Ellipsis)\n-else:\n-    from types import NoneType as NoneType\n-\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_literal(Literal[42])\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='Literal')\n \n-LITERAL_TYPES: set[Any] = {Literal}\n-if hasattr(typing, 'Literal'):\n-    LITERAL_TYPES.add(typing.Literal)\n \n-UNPACK_TYPES: set[Any] = {Unpack}\n-if hasattr(typing, 'Unpack'):\n-    UNPACK_TYPES.add(typing.Unpack)  # pyright: ignore[reportAttributeAccessIssue]\n+# TODO remove and replace with `get_args` when we drop support for Python 3.8\n+# (see https://docs.python.org/3/whatsnew/3.9.html#id4).\n+def literal_values(tp: Any, /) -> list[Any]:\n+    \"\"\"Return the values contained in the provided `Literal` special form.\"\"\"\n+    if not is_literal(tp):\n+        return [tp]\n \n-# Check if `deprecated` is a type to prevent errors when using typing_extensions < 4.9.0\n-DEPRECATED_TYPES: tuple[Any, ...] = (deprecated,) if isinstance(deprecated, type) else ()\n-if hasattr(warnings, 'deprecated'):\n-    DEPRECATED_TYPES = (*DEPRECATED_TYPES, warnings.deprecated)  # type: ignore\n+    values = get_args(tp)\n+    return [x for value in values for x in literal_values(value)]\n \n-NONE_TYPES: tuple[Any, ...] = (None, NoneType, *(tp[None] for tp in LITERAL_TYPES))\n \n-# should check for both variant of types for typing_extensions > 4.12.2\n-# https://typing-extensions.readthedocs.io/en/latest/#runtime-use-of-types\n-TYPE_ALIAS_TYPES: tuple[type, ...] = (\n-    (TypeAliasType, typing.TypeAliasType) if hasattr(typing, 'TypeAliasType') else (TypeAliasType,)\n-)\n+def is_annotated(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Annotated` special form.\n \n+    ```python test=\"skip\" lint=\"skip\"\n+    is_annotated(Annotated[int, ...])\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='Annotated')\n \n-TypeVarType = Any  # since mypy doesn't allow the use of TypeVar as a type\n \n+def annotated_type(tp: Any, /) -> Any | None:\n+    \"\"\"Return the type of the `Annotated` special form, or `None`.\"\"\"\n+    return get_args(tp)[0] if is_annotated(tp) else None\n \n-def is_none_type(type_: Any) -> bool:\n-    return type_ in NONE_TYPES\n \n+def is_unpack(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Unpack` special form.\n \n-def is_callable_type(type_: type[Any]) -> bool:\n-    return type_ is Callable or get_origin(type_) is Callable\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_unpack(Unpack[Ts])\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='Unpack')\n \n \n-def is_literal_type(type_: type[Any]) -> bool:\n-    return Literal is not None and get_origin(type_) in LITERAL_TYPES\n+def unpack_type(tp: Any, /) -> Any | None:\n+    \"\"\"Return the type wrapped by the `Unpack` special form, or `None`.\"\"\"\n+    return get_args(tp)[0] if is_unpack(tp) else None\n \n \n-def is_deprecated_instance(instance: Any) -> TypeGuard[deprecated]:\n-    return isinstance(instance, DEPRECATED_TYPES)\n+def is_self(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is the `Self` special form.\n \n+    ```python test=\"skip\" lint=\"skip\"\n+    is_self(Self)\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(tp, name='Self')\n \n-def literal_values(type_: type[Any]) -> tuple[Any, ...]:\n-    return get_args(type_)\n \n+def is_new_type(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `NewType`.\n \n-# TODO remove when we drop support for Python 3.8\n-# (see https://docs.python.org/3/whatsnew/3.9.html#id4).\n-def all_literal_values(type_: type[Any]) -> list[Any]:\n-    \"\"\"This method is used to retrieve all Literal values as\n-    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)\n-    e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`.\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_new_type(NewType('MyInt', int))\n+    #> True\n+    ```\n     \"\"\"\n-    if not is_literal_type(type_):\n-        return [type_]\n+    if sys.version_info < (3, 10):\n+        # On Python < 3.10, `typing.NewType` is a function\n+        return hasattr(tp, '__supertype__')\n+    else:\n+        return _is_typing_name(type(tp), name='NewType')\n \n-    values = literal_values(type_)\n-    return [x for value in values for x in all_literal_values(value)]\n \n+def is_hashable(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is the `Hashable` class.\n \n-def is_annotated(ann_type: Any) -> bool:\n-    return get_origin(ann_type) is Annotated\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_hashable(Hashable)\n+    #> True\n+    ```\n+    \"\"\"\n+    # `get_origin` is documented as normalizing any typing-module aliases to `collections` classes,\n+    # hence the second check:\n+    return tp is collections.abc.Hashable or get_origin(tp) is collections.abc.Hashable\n+\n+\n+def is_callable(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Callable`, parametrized or not.\n+\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_callable(Callable[[int], str])\n+    #> True\n+    is_callable(typing.Callable)\n+    #> True\n+    is_callable(collections.abc.Callable)\n+    #> True\n+    ```\n+    \"\"\"\n+    # `get_origin` is documented as normalizing any typing-module aliases to `collections` classes,\n+    # hence the second check:\n+    return tp is collections.abc.Callable or get_origin(tp) is collections.abc.Callable\n \n \n-def annotated_type(type_: Any) -> Any | None:\n-    return get_args(type_)[0] if is_annotated(type_) else None\n+_PARAMSPEC_TYPES: tuple[type[typing_extensions.ParamSpec], ...] = (typing_extensions.ParamSpec,)\n+if sys.version_info >= (3, 10):\n+    _PARAMSPEC_TYPES = (*_PARAMSPEC_TYPES, typing.ParamSpec)  # pyright: ignore[reportAssignmentType]\n \n \n-def is_unpack(type_: Any) -> bool:\n-    return get_origin(type_) in UNPACK_TYPES\n+def is_paramspec(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `ParamSpec`.\n \n+    ```python test=\"skip\" lint=\"skip\"\n+    P = ParamSpec('P')\n+    is_paramspec(P)\n+    #> True\n+    ```\n+    \"\"\"\n+    return isinstance(tp, _PARAMSPEC_TYPES)\n \n-def unpack_type(type_: Any) -> Any | None:\n-    return get_args(type_)[0] if is_unpack(type_) else None\n \n+_TYPEALIASTYPES: tuple[type[typing_extensions.TypeAliasType], ...] = (typing_extensions.TypeAliasType,)\n+if sys.version_info >= (3, 12):\n+    _TYPEALIASTYPES = (*_TYPEALIASTYPES, typing.TypeAliasType)\n \n-def is_namedtuple(type_: type[Any]) -> bool:\n-    \"\"\"Check if a given class is a named tuple.\n-    It can be either a `typing.NamedTuple` or `collections.namedtuple`.\n-    \"\"\"\n-    from ._utils import lenient_issubclass\n \n-    return lenient_issubclass(type_, tuple) and hasattr(type_, '_fields')\n+def is_typealiastype(tp: Any, /) -> TypeIs[typing_extensions.TypeAliasType]:\n+    \"\"\"Return whether the provided argument is an instance of `TypeAliasType`.\n \n+    ```python test=\"skip\" lint=\"skip\"\n+    type Int = int\n+    is_typealiastype(Int)\n+    #> True\n+    Str = TypeAliasType('Str', str)\n+    is_typealiastype(Str)\n+    #> True\n+    ```\n+    \"\"\"\n+    return isinstance(tp, _TYPEALIASTYPES)\n \n-test_new_type = typing.NewType('test_new_type', str)\n \n+def is_classvar(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `ClassVar` special form, parametrized or not.\n \n-def is_new_type(type_: type[Any]) -> bool:\n-    \"\"\"Check whether type_ was created using typing.NewType.\n+    Note that in most cases, you will want to use the `is_classvar_annotation` function,\n+    which is used to check if an annotation (in the context of a Pydantic model or dataclass)\n+    should be treated as being a class variable.\n \n-    Can't use isinstance because it fails <3.10.\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_classvar(ClassVar[int])\n+    #> True\n+    is_classvar(ClassVar)\n+    #> True\n     \"\"\"\n-    return isinstance(type_, test_new_type.__class__) and hasattr(type_, '__supertype__')  # type: ignore[arg-type]\n+    # ClassVar is not necessarily parametrized:\n+    return _is_typing_name(tp, name='ClassVar') or _is_typing_name(get_origin(tp), name='ClassVar')\n \n \n-classvar_re = re.compile(r'(\\w+\\.)?ClassVar\\[')\n+_classvar_re = re.compile(r'((\\w+\\.)?Annotated\\[)?(\\w+\\.)?ClassVar\\[')\n \n \n-def _check_classvar(v: type[Any] | None) -> bool:\n-    return v is not None and v.__class__ is typing.ClassVar.__class__ and getattr(v, '_name', None) == 'ClassVar'\n+def is_classvar_annotation(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument represents a class variable annotation.\n \n+    Although not explicitly stated by the typing specification, `ClassVar` can be used\n+    inside `Annotated` and as such, this function checks for this specific scenario.\n \n-def is_classvar(ann_type: type[Any]) -> bool:\n-    if _check_classvar(ann_type) or _check_classvar(get_origin(ann_type)):\n+    Because this function is used to detect class variables before evaluating forward references\n+    (or because evaluation failed), we also implement a naive regex match implementation. This is\n+    required because class variables are inspected before fields are collected, so we try to be\n+    as accurate as possible.\n+    \"\"\"\n+    if is_classvar(tp) or (anntp := annotated_type(tp)) is not None and is_classvar(anntp):\n         return True\n \n-    # this is an ugly workaround for class vars that contain forward references and are therefore themselves\n-    # forward references, see #3679\n-    if ann_type.__class__ == typing.ForwardRef and classvar_re.match(ann_type.__forward_arg__):\n+    str_ann: str | None = None\n+    if isinstance(tp, typing.ForwardRef):\n+        str_ann = tp.__forward_arg__\n+    if isinstance(tp, str):\n+        str_ann = tp\n+\n+    if str_ann is not None and _classvar_re.match(str_ann):\n+        # stdlib dataclasses do something similar, although a bit more advanced\n+        # (see `dataclass._is_type`).\n         return True\n \n     return False\n \n \n-def _check_finalvar(v: type[Any] | None) -> bool:\n-    \"\"\"Check if a given type is a `typing.Final` type.\"\"\"\n-    if v is None:\n+# TODO implement `is_finalvar_annotation` as Final can be wrapped with other special forms:\n+def is_finalvar(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Final` special form, parametrized or not.\n+\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_finalvar(Final[int])\n+    #> True\n+    is_finalvar(Final)\n+    #> True\n+    \"\"\"\n+    # Final is not necessarily parametrized:\n+    return _is_typing_name(tp, name='Final') or _is_typing_name(get_origin(tp), name='Final')\n+\n+\n+def is_required(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `Required` special form.\n+\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_required(Required[int])\n+    #> True\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='Required')\n+\n+\n+def is_not_required(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a `NotRequired` special form.\n+\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_required(Required[int])\n+    #> True\n+    \"\"\"\n+    return _is_typing_name(get_origin(tp), name='NotRequired')\n+\n+\n+def is_no_return(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is the `NoReturn` special form.\n+\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_no_return(NoReturn)\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(tp, name='NoReturn')\n+\n+\n+def is_never(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is the `Never` special form.\n+\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_never(Never)\n+    #> True\n+    ```\n+    \"\"\"\n+    return _is_typing_name(tp, name='Never')\n+\n+\n+_DEPRECATED_TYPES: tuple[type[typing_extensions.deprecated], ...] = (typing_extensions.deprecated,)\n+if hasattr(warnings, 'deprecated'):\n+    _DEPRECATED_TYPES = (*_DEPRECATED_TYPES, warnings.deprecated)  # pyright: ignore[reportAttributeAccessIssue]\n+\n+\n+def is_deprecated_instance(obj: Any, /) -> TypeIs[deprecated]:\n+    \"\"\"Return whether the argument is an instance of the `warnings.deprecated` class or the `typing_extensions` backport.\"\"\"\n+    return isinstance(obj, _DEPRECATED_TYPES)\n+\n+\n+_NONE_TYPES: tuple[Any, ...] = (None, NoneType, typing.Literal[None], typing_extensions.Literal[None])\n+\n+\n+def is_none_type(tp: Any, /) -> bool:\n+    \"\"\"Return whether the argument represents the `None` type as part of an annotation.\n+\n+    ```python test=\"skip\" lint=\"skip\"\n+    is_none_type(None)\n+    #> True\n+    is_none_type(NoneType)\n+    #> True\n+    is_none_type(Literal[None])\n+    #> True\n+    is_none_type(type[None])\n+    #> False\n+    \"\"\"\n+    return tp in _NONE_TYPES\n+\n+\n+def is_namedtuple(tp: Any, /) -> bool:\n+    \"\"\"Return whether the provided argument is a named tuple class.\n+\n+    The class can be created using `typing.NamedTuple` or `collections.namedtuple`.\n+    Parametrized generic classes are *not* assumed to be named tuples.\n+    \"\"\"\n+    from ._utils import lenient_issubclass\n+\n+    return lenient_issubclass(tp, tuple) and hasattr(tp, '_fields')\n+\n+\n+if sys.version_info < (3, 9):\n+\n+    def is_zoneinfo_type(tp: Any, /) -> bool:\n+        \"\"\"Return whether the provided argument is the `zoneinfo.ZoneInfo` type.\"\"\"\n         return False\n \n-    return v.__class__ == Final.__class__ and (sys.version_info < (3, 8) or getattr(v, '_name', None) == 'Final')\n+else:\n+    from zoneinfo import ZoneInfo\n+\n+    def is_zoneinfo_type(tp: Any, /) -> TypeIs[type[ZoneInfo]]:\n+        \"\"\"Return whether the provided argument is the `zoneinfo.ZoneInfo` type.\"\"\"\n+        return tp is ZoneInfo\n+\n+\n+if sys.version_info < (3, 10):\n+\n+    def origin_is_union(tp: Any, /) -> bool:\n+        \"\"\"Return whether the provided argument is the `Union` special form.\"\"\"\n+        return _is_typing_name(tp, name='Union')\n+\n+    def is_generic_alias(type_: type[Any]) -> bool:\n+        return isinstance(type_, typing._GenericAlias)  # pyright: ignore[reportAttributeAccessIssue]\n+\n+else:\n+\n+    def origin_is_union(tp: Any, /) -> bool:\n+        \"\"\"Return whether the provided argument is the `Union` special form or the `UnionType`.\"\"\"\n+        return _is_typing_name(tp, name='Union') or tp is types.UnionType\n+\n+    def is_generic_alias(tp: Any, /) -> bool:\n+        return isinstance(tp, (types.GenericAlias, typing._GenericAlias))  # pyright: ignore[reportAttributeAccessIssue]\n+\n \n+# Ideally, we should avoid relying on the private `typing` constructs:",
      "comment": "Maybe add a TODO here so it's more evident that we need to come back to it \ud83d\udc4d ",
      "comment_id": 1825754336,
      "user": "sydney-runkle",
      "created_at": "2024-11-01T12:15:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/10725#discussion_r1825754336"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10725,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,7 +33,7 @@\n     _make_forward_ref,\n     eval_type_backport,\n     is_annotated,\n-    is_classvar,\n+    is_classvar_annotation,",
      "comment": "We would have to change all the `from ._x import ...` in this file to be consistent, so I left it as is",
      "comment_id": 1832977137,
      "user": "Viicos",
      "created_at": "2024-11-07T16:22:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10725#discussion_r1832977137"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10725,
      "file_path": "pydantic/_internal/_generics.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -184,7 +184,7 @@ def _get_caller_frame_info(depth: int = 2) -> tuple[str | None, bool]:\n DictValues: type[Any] = {}.values().__class__\n \n \n-def iter_contained_typevars(v: Any) -> Iterator[TypeVarType]:\n+def iter_contained_typevars(v: Any) -> Iterator[TypeVar]:",
      "comment": "`TypeVarType` was defined as an alias to `Any` as a workaround, because mypy could not understand something like this:\r\n\r\n```python\r\nTypeVarType: TypeAlias = TypeVar\r\n```\r\n\r\nBut for pyright (and maybe mypy as of today), it is perfectly fine to use `TypeVar` as type annotations, it behaves as any other type",
      "comment_id": 1832982587,
      "user": "Viicos",
      "created_at": "2024-11-07T16:25:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10725#discussion_r1832982587"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10727,
      "file_path": "tests/mypy/outputs/1.10.1/mypy-plugin_ini/pydantic_settings.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,7 +12,7 @@ class Settings(BaseSettings):\n s = Settings(foo='test', _case_sensitive=1, _env_prefix=2, _env_file=3)\n # MYPY: error: Argument \"_case_sensitive\" to \"Settings\" has incompatible type \"int\"; expected \"Optional[bool]\"  [arg-type]\n # MYPY: error: Argument \"_env_prefix\" to \"Settings\" has incompatible type \"int\"; expected \"Optional[str]\"  [arg-type]\n-# MYPY: error: Argument \"_env_file\" to \"Settings\" has incompatible type \"int\"; expected \"Optional[Union[Path, str, List[Union[Path, str]], Tuple[Union[Path, str], ...]]]\"  [arg-type]\n+# MYPY: error: Argument \"_env_file\" to \"Settings\" has incompatible type \"int\"; expected \"Optional[Union[Path, str, Sequence[Union[Path, str]]]]\"  [arg-type]",
      "comment": "Thanks for catching this - fixed in a PR on main, so you can probably rebase...",
      "comment_id": 1824366741,
      "user": "sydney-runkle",
      "created_at": "2024-10-31T12:29:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10727#discussion_r1824366741"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 430,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,7 +427,7 @@ class AnyUrl(_BaseUrl):\n     @property\n     def host(self) -> str:\n         \"\"\"The required URL host.\"\"\"\n-        ...\n+        return self._url.host  # type: ignore",
      "comment": "Maybe @Viicos has a better idea here - the point is, the base `Url` doesn't need a host, but this more specific implementation does, so here's how I'm keying in on the `host` as a `str`...",
      "comment_id": 1827966551,
      "user": "sydney-runkle",
      "created_at": "2024-11-04T15:53:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1827966551"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,7 +9,7 @@\n from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\n from typing import TYPE_CHECKING, Any, ClassVar\n \n-from pydantic_core import MultiHostUrl, PydanticCustomError, Url, core_schema\n+from pydantic_core import MultiHostHost, MultiHostUrl, PydanticCustomError, Url, core_schema",
      "comment": "Since this module is public, I think should do `Url as _CoreUrl`, same for `MultiHostUrl`.",
      "comment_id": 1829256912,
      "user": "samuelcolvin",
      "created_at": "2024-11-05T12:20:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829256912"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,17 +95,176 @@ def defined_constraints(self) -> dict[str, Any]:\n         return {field.name: getattr(self, field.name) for field in fields(self)}\n \n \n-# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n-# the complexity enough that it's not worth saving a few lines?\n+class _BaseUrl:\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: Url\n \n+    def __init__(self, url: str | Url) -> None:\n+        if isinstance(url, Url):",
      "comment": "this is wrong, constraints won't be maintained.\r\n\r\nI think you want:\r\n\r\n```py\r\nif isinstance(url, self.__class__):\r\n    self._url = url._url\r\nelif isinstance(url, (_BaseUrl, Url, _BaseMultiHostUrl, MultiHostUrl):\r\n    url = str(url)\r\n    ... do validation\r\nelse:\r\n    do valdiation\r\n```",
      "comment_id": 1829264586,
      "user": "samuelcolvin",
      "created_at": "2024-11-05T12:25:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829264586"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 208,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,17 +95,176 @@ def defined_constraints(self) -> dict[str, Any]:\n         return {field.name: getattr(self, field.name) for field in fields(self)}\n \n \n-# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n-# the complexity enough that it's not worth saving a few lines?\n+class _BaseUrl:\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: Url\n \n+    def __init__(self, url: str | Url) -> None:\n+        if isinstance(url, Url):\n+            self._url = url\n+        else:\n+            # TODO: this doesn't actually enforce constraints on subclasses, we should either:\n+            # Fully commit to validating on __init__ for Pydantic types\n+            # imo, we should not do this, the maintenance burden is VERY high here\n+            # OR, we should warn that validation does not occur on __init__ and standardize this across types\n+            assert isinstance(url, str)\n+            self._url = Url(url)\n \n-class _BaseUrl(Url):\n-    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    @property\n+    def scheme(self) -> str:\n+        \"\"\"The scheme part of the URL.\n+\n+        e.g. `https` in `https://user:pass@host:port/path?query#fragment`\n+        \"\"\"\n+        return self._url.scheme\n+\n+    @property\n+    def username(self) -> str | None:\n+        \"\"\"The username part of the URL, or `None`.\n+\n+        e.g. `user` in `https://user:pass@host:port/path?query#fragment`\n+        \"\"\"\n+        return self._url.username\n+\n+    @property\n+    def password(self) -> str | None:\n+        \"\"\"The password part of the URL, or `None`.\n+\n+        e.g. `pass` in `https://user:pass@host:port/path?query#fragment`\n+        \"\"\"\n+        return self._url.password\n+\n+    @property\n+    def host(self) -> str | None:\n+        \"\"\"The host part of the URL, or `None`.\n+\n+        If the URL must be punycode encoded, this is the encoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n+        `host` will be `xn--9aaa.com`\n+        \"\"\"\n+        return self._url.host\n+\n+    def unicode_host(self) -> str | None:\n+        \"\"\"The host part of the URL as a unicode string, or `None`.\n+\n+        e.g. `host` in `https://user:pass@host:port/path?query#fragment`\n+\n+        If the URL must be punycode encoded, this is the decoded host, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n+        `unicode_host()` will be `\u00a3\u00a3\u00a3.com`\n+        \"\"\"\n+        return self._url.unicode_host()\n+\n+    @property\n+    def port(self) -> int | None:\n+        \"\"\"The port part of the URL, or `None`.\n+\n+        e.g. `port` in `https://user:pass@host:port/path?query#fragment`\n+        \"\"\"\n+        return self._url.port\n+\n+    @property\n+    def path(self) -> str | None:\n+        \"\"\"The path part of the URL, or `None`.\n+\n+        e.g. `/path` in `https://user:pass@host:port/path?query#fragment`\n+        \"\"\"\n+        return self._url.path\n+\n+    @property\n+    def query(self) -> str | None:\n+        \"\"\"The query part of the URL, or `None`.\n+\n+        e.g. `query` in `https://user:pass@host:port/path?query#fragment`\n+        \"\"\"\n+        return self._url.query\n+\n+    def query_params(self) -> list[tuple[str, str]]:\n+        \"\"\"The query part of the URL as a list of key-value pairs.\n+\n+        e.g. `[('foo', 'bar')]` in `https://user:pass@host:port/path?foo=bar#fragment`\n+        \"\"\"\n+        return self._url.query_params()\n+\n+    @property\n+    def fragment(self) -> str | None:\n+        \"\"\"The fragment part of the URL, or `None`.\n+\n+        e.g. `fragment` in `https://user:pass@host:port/path?query#fragment`\n+        \"\"\"\n+        return self._url.fragment\n+\n+    def unicode_string(self) -> str:\n+        \"\"\"The URL as a unicode string, unlike `__str__()` this will not punycode encode the host.\n+\n+        If the URL must be punycode encoded, this is the decoded string, e.g if the input URL is `https://\u00a3\u00a3\u00a3.com`,\n+        `unicode_string()` will be `https://\u00a3\u00a3\u00a3.com`\n+        \"\"\"\n+        return self._url.unicode_string()\n+\n+    def __str__(self) -> str:\n+        \"\"\"The URL as a string, this will punycode encode the host if required.\"\"\"\n+        return str(self._url)\n+\n+    def __repr__(self) -> str:\n+        return f\"{self.__class__.__name__}('{str(self._url)}')\"",
      "comment": "```suggestion\r\n        return f\"{self.__class__.__name__}({str(self._url)!r})\"\r\n```\r\nsurely?",
      "comment_id": 1829265755,
      "user": "samuelcolvin",
      "created_at": "2024-11-05T12:26:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829265755"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,17 +95,176 @@ def defined_constraints(self) -> dict[str, Any]:\n         return {field.name: getattr(self, field.name) for field in fields(self)}\n \n \n-# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n-# the complexity enough that it's not worth saving a few lines?\n+class _BaseUrl:\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: Url\n \n+    def __init__(self, url: str | Url) -> None:\n+        if isinstance(url, Url):\n+            self._url = url\n+        else:\n+            # TODO: this doesn't actually enforce constraints on subclasses, we should either:\n+            # Fully commit to validating on __init__ for Pydantic types\n+            # imo, we should not do this, the maintenance burden is VERY high here\n+            # OR, we should warn that validation does not occur on __init__ and standardize this across types\n+            assert isinstance(url, str)",
      "comment": "I don't think we need this, if we do it should at least have a message with it.",
      "comment_id": 1829282871,
      "user": "samuelcolvin",
      "created_at": "2024-11-05T12:38:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829282871"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,17 +95,176 @@ def defined_constraints(self) -> dict[str, Any]:\n         return {field.name: getattr(self, field.name) for field in fields(self)}\n \n \n-# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n-# the complexity enough that it's not worth saving a few lines?\n+class _BaseUrl:\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: Url\n \n+    def __init__(self, url: str | Url) -> None:\n+        if isinstance(url, Url):",
      "comment": "I think the point is that this these types are already broken in the same way in the latest release, I was happy to see constraint validation fixed in a future follow up.",
      "comment_id": 1829382877,
      "user": "davidhewitt",
      "created_at": "2024-11-05T13:46:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829382877"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,17 +95,176 @@ def defined_constraints(self) -> dict[str, Any]:\n         return {field.name: getattr(self, field.name) for field in fields(self)}\n \n \n-# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n-# the complexity enough that it's not worth saving a few lines?\n+class _BaseUrl:\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: Url\n \n+    def __init__(self, url: str | Url) -> None:\n+        if isinstance(url, Url):",
      "comment": "I think it's not too hard to just get it right now.",
      "comment_id": 1829463623,
      "user": "samuelcolvin",
      "created_at": "2024-11-05T14:34:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829463623"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,17 +95,176 @@ def defined_constraints(self) -> dict[str, Any]:\n         return {field.name: getattr(self, field.name) for field in fields(self)}\n \n \n-# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n-# the complexity enough that it's not worth saving a few lines?\n+class _BaseUrl:\n+    _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: Url\n \n+    def __init__(self, url: str | Url) -> None:\n+        if isinstance(url, Url):",
      "comment": "Yeah. Happy to fix this now, but indeed, the previous approach was assuming we'd fix the init constraint behavior in a future PR.",
      "comment_id": 1829590045,
      "user": "sydney-runkle",
      "created_at": "2024-11-05T15:46:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829590045"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,13 +287,160 @@ def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaH\n             return schema\n \n \n-class _BaseMultiHostUrl(MultiHostUrl):\n+class _BaseMultiHostUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreMultiHostUrl\n+\n+    @cached_property\n+    def _validator(self) -> TypeAdapter:\n+        return TypeAdapter(self.__class__)",
      "comment": "It feels like it could be both simpler and more efficient if here this `TypeAdapter` just built the underlying rust `Url`, with appropriate constraints? Is there a reason why that might be problematic for subclasses? \ud83e\udd14 ",
      "comment_id": 1829698083,
      "user": "davidhewitt",
      "created_at": "2024-11-05T16:53:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829698083"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 437,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,13 +287,160 @@ def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaH\n             return schema\n \n \n-class _BaseMultiHostUrl(MultiHostUrl):\n+class _BaseMultiHostUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreMultiHostUrl\n+\n+    @cached_property\n+    def _validator(self) -> TypeAdapter:\n+        return TypeAdapter(self.__class__)\n+\n+    def __init__(self, url: str | _CoreMultiHostUrl) -> None:\n+        if isinstance(url, self.__class__):\n+            self._url = url._url\n+        elif isinstance(url, _CoreMultiHostUrl):\n+            self._url = self._validator.validate_python(str(url))\n+        else:\n+            self._url = self._validator.validate_python(url)\n+\n+    @property\n+    def scheme(self) -> str:\n+        \"\"\"The scheme part of the URL.\n+\n+        e.g. `https` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.scheme\n+\n+    @property\n+    def path(self) -> str | None:\n+        \"\"\"The path part of the URL, or `None`.\n+\n+        e.g. `/path` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.path\n+\n+    @property\n+    def query(self) -> str | None:\n+        \"\"\"The query part of the URL, or `None`.\n+\n+        e.g. `query` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query\n+\n+    def query_params(self) -> list[tuple[str, str]]:\n+        \"\"\"The query part of the URL as a list of key-value pairs.\n+\n+        e.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query_params()\n+\n+    @property\n+    def fragment(self) -> str | None:\n+        \"\"\"The fragment part of the URL, or `None`.\n+\n+        e.g. `fragment` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.fragment\n+\n+    def hosts(self) -> list[MultiHostHost]:\n+        '''The hosts of the `MultiHostUrl` as [`MultiHostHost`][pydantic_core.MultiHostHost] typed dicts.\n+\n+        ```py\n+        from pydantic_core import MultiHostUrl\n+\n+        mhu = MultiHostUrl('https://foo.com:123,foo:bar@bar.com/path')\n+        print(mhu.hosts())\n+        \"\"\"\n+        [\n+            {'username': None, 'password': None, 'host': 'foo.com', 'port': 123},\n+            {'username': 'foo', 'password': 'bar', 'host': 'bar.com', 'port': 443}\n+        ]\n+        ```\n+        Returns:\n+            A list of dicts, each representing a host.\n+        '''\n+        return self._url.hosts()\n+\n+    def unicode_string(self) -> str:\n+        \"\"\"The URL as a unicode string, unlike `__str__()` this will not punycode encode the hosts.\"\"\"\n+        return self._url.unicode_string()\n+\n+    def __str__(self) -> str:\n+        \"\"\"The URL as a string, this will punycode encode the host if required.\"\"\"\n+        return str(self._url)\n+\n+    def __repr__(self) -> str:\n+        return f'{self.__class__.__name__}({str(self._url)!r})'\n+\n+    def __deepcopy__(self, memo: dict) -> Self:\n+        return self.__class__(self._url)\n \n     @classmethod\n-    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def build(\n+        cls,\n+        *,\n+        scheme: str,\n+        hosts: list[MultiHostHost] | None = None,\n+        username: str | None = None,\n+        password: str | None = None,\n+        host: str | None = None,\n+        port: int | None = None,\n+        path: str | None = None,\n+        query: str | None = None,\n+        fragment: str | None = None,\n+    ) -> Self:\n+        \"\"\"Build a new `MultiHostUrl` instance from its component parts.\n+\n+        This method takes either `hosts` - a list of `MultiHostHost` typed dicts, or the individual components\n+        `username`, `password`, `host` and `port`.\n+\n+        Args:\n+            scheme: The scheme part of the URL.\n+            hosts: Multiple hosts to build the URL from.\n+            username: The username part of the URL.\n+            password: The password part of the URL.\n+            host: The host part of the URL.\n+            port: The port part of the URL.\n+            path: The path part of the URL.\n+            query: The query part of the URL, or omit for no query.\n+            fragment: The fragment part of the URL, or omit for no fragment.\n+\n+        Returns:\n+            An instance of `MultiHostUrl`\n+        \"\"\"\n+        return cls(\n+            _CoreMultiHostUrl.build(\n+                scheme=scheme,\n+                hosts=hosts,\n+                username=username,\n+                password=password,\n+                host=host,\n+                port=port,\n+                path=path,\n+                query=query,\n+                fragment=fragment,\n+            )\n+        )\n+\n+    @classmethod\n+    def __get_pydantic_core_schema__(\n+        cls, source: type[_BaseMultiHostUrl], handler: GetCoreSchemaHandler\n+    ) -> core_schema.CoreSchema:\n         if issubclass(cls, source):\n-            return core_schema.multi_host_url_schema(**cls._constraints.defined_constraints)\n+\n+            def wrap_val(value, handler):\n+                if isinstance(value, source):\n+                    return value\n+                core_url = handler(value)\n+                instance = source.__new__(source)\n+                instance._url = core_url\n+                return instance",
      "comment": "I think if the `TypeAdapter` above just built the Rust URL, this wrap validator could be a lot simpler (and more like the form we drafted yesterday).",
      "comment_id": 1829698945,
      "user": "davidhewitt",
      "created_at": "2024-11-05T16:54:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829698945"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,13 +287,160 @@ def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaH\n             return schema\n \n \n-class _BaseMultiHostUrl(MultiHostUrl):\n+class _BaseMultiHostUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreMultiHostUrl\n+\n+    @cached_property\n+    def _validator(self) -> TypeAdapter:\n+        return TypeAdapter(self.__class__)",
      "comment": "Hmm, I don't think there's an easy way to do this - you can't easily create a `TypeAdapter` with just a core schema. Even if we could hack that together, should we?",
      "comment_id": 1829716312,
      "user": "sydney-runkle",
      "created_at": "2024-11-05T17:04:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829716312"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,13 +287,160 @@ def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaH\n             return schema\n \n \n-class _BaseMultiHostUrl(MultiHostUrl):\n+class _BaseMultiHostUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreMultiHostUrl\n+\n+    @cached_property\n+    def _validator(self) -> TypeAdapter:\n+        return TypeAdapter(self.__class__)",
      "comment": "well we could use a `SchemaValidator` instead of a `TypeAdapter`?",
      "comment_id": 1829720770,
      "user": "samuelcolvin",
      "created_at": "2024-11-05T17:07:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829720770"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,13 +287,160 @@ def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaH\n             return schema\n \n \n-class _BaseMultiHostUrl(MultiHostUrl):\n+class _BaseMultiHostUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreMultiHostUrl\n+\n+    @cached_property\n+    def _validator(self) -> TypeAdapter:\n+        return TypeAdapter(self.__class__)",
      "comment": "Found a relatively simple way with `TypeAdapter`. That's easiest for now, as we already have the `isinstance` conditional in the wrap validator in the custom core schema.\r\n\r\nDown the line, maybe it does make sense to just use `SchemaValidator` inside these types to perform internal validation. I'm going to write up an issue with next steps based on the feedback here, and I'll include this \ud83d\udc4d ",
      "comment_id": 1829737406,
      "user": "sydney-runkle",
      "created_at": "2024-11-05T17:18:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829737406"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 437,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,13 +287,160 @@ def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaH\n             return schema\n \n \n-class _BaseMultiHostUrl(MultiHostUrl):\n+class _BaseMultiHostUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreMultiHostUrl\n+\n+    @cached_property\n+    def _validator(self) -> TypeAdapter:\n+        return TypeAdapter(self.__class__)\n+\n+    def __init__(self, url: str | _CoreMultiHostUrl) -> None:\n+        if isinstance(url, self.__class__):\n+            self._url = url._url\n+        elif isinstance(url, _CoreMultiHostUrl):\n+            self._url = self._validator.validate_python(str(url))\n+        else:\n+            self._url = self._validator.validate_python(url)\n+\n+    @property\n+    def scheme(self) -> str:\n+        \"\"\"The scheme part of the URL.\n+\n+        e.g. `https` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.scheme\n+\n+    @property\n+    def path(self) -> str | None:\n+        \"\"\"The path part of the URL, or `None`.\n+\n+        e.g. `/path` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.path\n+\n+    @property\n+    def query(self) -> str | None:\n+        \"\"\"The query part of the URL, or `None`.\n+\n+        e.g. `query` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query\n+\n+    def query_params(self) -> list[tuple[str, str]]:\n+        \"\"\"The query part of the URL as a list of key-value pairs.\n+\n+        e.g. `[('foo', 'bar')]` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.query_params()\n+\n+    @property\n+    def fragment(self) -> str | None:\n+        \"\"\"The fragment part of the URL, or `None`.\n+\n+        e.g. `fragment` in `https://foo.com,bar.com/path?query#fragment`\n+        \"\"\"\n+        return self._url.fragment\n+\n+    def hosts(self) -> list[MultiHostHost]:\n+        '''The hosts of the `MultiHostUrl` as [`MultiHostHost`][pydantic_core.MultiHostHost] typed dicts.\n+\n+        ```py\n+        from pydantic_core import MultiHostUrl\n+\n+        mhu = MultiHostUrl('https://foo.com:123,foo:bar@bar.com/path')\n+        print(mhu.hosts())\n+        \"\"\"\n+        [\n+            {'username': None, 'password': None, 'host': 'foo.com', 'port': 123},\n+            {'username': 'foo', 'password': 'bar', 'host': 'bar.com', 'port': 443}\n+        ]\n+        ```\n+        Returns:\n+            A list of dicts, each representing a host.\n+        '''\n+        return self._url.hosts()\n+\n+    def unicode_string(self) -> str:\n+        \"\"\"The URL as a unicode string, unlike `__str__()` this will not punycode encode the hosts.\"\"\"\n+        return self._url.unicode_string()\n+\n+    def __str__(self) -> str:\n+        \"\"\"The URL as a string, this will punycode encode the host if required.\"\"\"\n+        return str(self._url)\n+\n+    def __repr__(self) -> str:\n+        return f'{self.__class__.__name__}({str(self._url)!r})'\n+\n+    def __deepcopy__(self, memo: dict) -> Self:\n+        return self.__class__(self._url)\n \n     @classmethod\n-    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def build(\n+        cls,\n+        *,\n+        scheme: str,\n+        hosts: list[MultiHostHost] | None = None,\n+        username: str | None = None,\n+        password: str | None = None,\n+        host: str | None = None,\n+        port: int | None = None,\n+        path: str | None = None,\n+        query: str | None = None,\n+        fragment: str | None = None,\n+    ) -> Self:\n+        \"\"\"Build a new `MultiHostUrl` instance from its component parts.\n+\n+        This method takes either `hosts` - a list of `MultiHostHost` typed dicts, or the individual components\n+        `username`, `password`, `host` and `port`.\n+\n+        Args:\n+            scheme: The scheme part of the URL.\n+            hosts: Multiple hosts to build the URL from.\n+            username: The username part of the URL.\n+            password: The password part of the URL.\n+            host: The host part of the URL.\n+            port: The port part of the URL.\n+            path: The path part of the URL.\n+            query: The query part of the URL, or omit for no query.\n+            fragment: The fragment part of the URL, or omit for no fragment.\n+\n+        Returns:\n+            An instance of `MultiHostUrl`\n+        \"\"\"\n+        return cls(\n+            _CoreMultiHostUrl.build(\n+                scheme=scheme,\n+                hosts=hosts,\n+                username=username,\n+                password=password,\n+                host=host,\n+                port=port,\n+                path=path,\n+                query=query,\n+                fragment=fragment,\n+            )\n+        )\n+\n+    @classmethod\n+    def __get_pydantic_core_schema__(\n+        cls, source: type[_BaseMultiHostUrl], handler: GetCoreSchemaHandler\n+    ) -> core_schema.CoreSchema:\n         if issubclass(cls, source):\n-            return core_schema.multi_host_url_schema(**cls._constraints.defined_constraints)\n+\n+            def wrap_val(value, handler):\n+                if isinstance(value, source):\n+                    return value\n+                core_url = handler(value)\n+                instance = source.__new__(source)\n+                instance._url = core_url\n+                return instance",
      "comment": "See changes - I've sort of gone the other way here - wrap val is the same, but `__init__` is greatly simplified \ud83d\udc4d ",
      "comment_id": 1829737945,
      "user": "sydney-runkle",
      "created_at": "2024-11-05T17:18:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829737945"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,17 +99,178 @@ def defined_constraints(self) -> dict[str, Any]:\n         return {field.name: getattr(self, field.name) for field in fields(self)}\n \n \n-# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n-# the complexity enough that it's not worth saving a few lines?\n+@lru_cache\n+def _build_type_adapter(cls: type[_BaseUrl | _BaseMultiHostUrl]) -> TypeAdapter:\n+    return TypeAdapter(cls)\n \n \n-class _BaseUrl(Url):\n+class _BaseUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreUrl\n+\n+    def __init__(self, url: str | _CoreUrl) -> None:\n+        self._url = _build_type_adapter(self.__class__).validate_python(str(url))",
      "comment": "I thought we only wanted to use the very lax `str(url)` when we knew the thing was a subtype of `_CoreUrl` or `_BaseUrl`?",
      "comment_id": 1829745287,
      "user": "samuelcolvin",
      "created_at": "2024-11-05T17:24:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829745287"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,17 +99,178 @@ def defined_constraints(self) -> dict[str, Any]:\n         return {field.name: getattr(self, field.name) for field in fields(self)}\n \n \n-# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n-# the complexity enough that it's not worth saving a few lines?\n+@lru_cache\n+def _build_type_adapter(cls: type[_BaseUrl | _BaseMultiHostUrl]) -> TypeAdapter:\n+    return TypeAdapter(cls)\n \n \n-class _BaseUrl(Url):\n+class _BaseUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreUrl\n+\n+    def __init__(self, url: str | _CoreUrl) -> None:",
      "comment": "```suggestion\r\n    def __init__(self, url: str | _CoreUrl | _BaseUrl) -> None:\r\n```\r\n\r\n???",
      "comment_id": 1829745978,
      "user": "samuelcolvin",
      "created_at": "2024-11-05T17:24:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829745978"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10766,
      "file_path": "pydantic/networks.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,17 +99,178 @@ def defined_constraints(self) -> dict[str, Any]:\n         return {field.name: getattr(self, field.name) for field in fields(self)}\n \n \n-# TODO: there's a lot of repeated code in these two base classes - should we consolidate, or does that up\n-# the complexity enough that it's not worth saving a few lines?\n+@lru_cache\n+def _build_type_adapter(cls: type[_BaseUrl | _BaseMultiHostUrl]) -> TypeAdapter:\n+    return TypeAdapter(cls)\n \n \n-class _BaseUrl(Url):\n+class _BaseUrl:\n     _constraints: ClassVar[UrlConstraints] = UrlConstraints()\n+    _url: _CoreUrl\n+\n+    def __init__(self, url: str | _CoreUrl) -> None:\n+        self._url = _build_type_adapter(self.__class__).validate_python(str(url))",
      "comment": "Discussed offline, moving `str` coercion to wrap validator and simplifying `__init__` \ud83d\udc4d ",
      "comment_id": 1829768818,
      "user": "sydney-runkle",
      "created_at": "2024-11-05T17:41:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10766#discussion_r1829768818"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10677,
      "file_path": "tests/typechecking/decorators.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,7 +45,7 @@ def valid_staticmethod(value: Any) -> Any: ...\n \n \n class WrapModelValidator(BaseModel):\n-    @model_validator(mode='wrap')  # type: ignore[arg-type]  # pyright: ignore[reportArgumentType]\n+    @model_validator(mode='wrap')  # type: ignore[arg-type] # pyright: ignore[reportArgumentType]",
      "comment": "```suggestion\r\n    @model_validator(mode='wrap')  # type: ignore[arg-type]  # pyright: ignore[reportArgumentType]\r\n```",
      "comment_id": 1809454190,
      "user": "Viicos",
      "created_at": "2024-10-21T20:08:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10677#discussion_r1809454190"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10661,
      "file_path": "tests/test_discriminated_union.py",
      "line": 1982,
      "side": "RIGHT",
      "diff_hunk": "@@ -1973,13 +1973,13 @@ class LoopState(BaseModel):\n     class LeafState(BaseModel):\n         state_type: Literal['leaf']\n \n-    AnyState = Annotated[Union[NestedState, LoopState, LeafState], Field(..., discriminator='state_type')]\n+    AnyState = Annotated[Union[NestedState, LoopState, LeafState], Field(discriminator='state_type')]\n     adapter = TypeAdapter(AnyState)\n \n     assert adapter.core_schema['schema']['type'] == 'tagged-union'\n     for definition in adapter.core_schema['definitions']:\n         if definition['schema']['model_name'] in ['NestedState', 'LoopState']:\n-            assert definition['schema']['fields']['substate']['schema']['schema']['type'] == 'tagged-union'\n+            assert definition['schema']['fields']['substate']['schema']['type'] == 'tagged-union'",
      "comment": "As a consequence of the fixed bug: a slight change in schemas because `AnyState` is no longer considered to have a default value of `...`.",
      "comment_id": 1806858824,
      "user": "Viicos",
      "created_at": "2024-10-18T18:13:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10661#discussion_r1806858824"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10661,
      "file_path": "tests/test_discriminated_union.py",
      "line": 1982,
      "side": "RIGHT",
      "diff_hunk": "@@ -1973,13 +1973,13 @@ class LoopState(BaseModel):\n     class LeafState(BaseModel):\n         state_type: Literal['leaf']\n \n-    AnyState = Annotated[Union[NestedState, LoopState, LeafState], Field(..., discriminator='state_type')]\n+    AnyState = Annotated[Union[NestedState, LoopState, LeafState], Field(discriminator='state_type')]\n     adapter = TypeAdapter(AnyState)\n \n     assert adapter.core_schema['schema']['type'] == 'tagged-union'\n     for definition in adapter.core_schema['definitions']:\n         if definition['schema']['model_name'] in ['NestedState', 'LoopState']:\n-            assert definition['schema']['fields']['substate']['schema']['schema']['type'] == 'tagged-union'\n+            assert definition['schema']['fields']['substate']['schema']['type'] == 'tagged-union'",
      "comment": "Thanks for explaining. I'm surprised this changed the schema - I guess there was a `with_default` schema here previously?",
      "comment_id": 1806926375,
      "user": "sydney-runkle",
      "created_at": "2024-10-18T19:14:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10661#discussion_r1806926375"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10651,
      "file_path": "pydantic/fields.py",
      "line": 695,
      "side": "RIGHT",
      "diff_hunk": "@@ -689,22 +689,143 @@ class _EmptyKwargs(typing_extensions.TypedDict):\n }\n \n \n+_T = TypeVar('_T')\n+\n+\n+# NOTE: Actual return type is 'FieldInfo', but we want to help type checkers",
      "comment": "Maybe add a comment to each just so that it's clear, ex: `default set`, `default_factory set`, `no default set` or something along those lines",
      "comment_id": 1806460169,
      "user": "sydney-runkle",
      "created_at": "2024-10-18T13:03:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10651#discussion_r1806460169"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10651,
      "file_path": "pydantic/fields.py",
      "line": 695,
      "side": "RIGHT",
      "diff_hunk": "@@ -689,22 +689,143 @@ class _EmptyKwargs(typing_extensions.TypedDict):\n }\n \n \n+_T = TypeVar('_T')\n+\n+\n+# NOTE: Actual return type is 'FieldInfo', but we want to help type checkers",
      "comment": "Probably a stupid question - can we put these in an if type checking block for clarity?",
      "comment_id": 1806460699,
      "user": "sydney-runkle",
      "created_at": "2024-10-18T13:04:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10651#discussion_r1806460699"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10651,
      "file_path": "pydantic/fields.py",
      "line": 1084,
      "side": "RIGHT",
      "diff_hunk": "@@ -960,6 +1081,28 @@ def __eq__(self, other: Any) -> bool:\n         )\n \n \n+_T = TypeVar('_T')",
      "comment": "Ah did not notice they were defined in the same file",
      "comment_id": 1806471159,
      "user": "Viicos",
      "created_at": "2024-10-18T13:12:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10651#discussion_r1806471159"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10651,
      "file_path": "pydantic/fields.py",
      "line": 695,
      "side": "RIGHT",
      "diff_hunk": "@@ -689,22 +689,143 @@ class _EmptyKwargs(typing_extensions.TypedDict):\n }\n \n \n+_T = TypeVar('_T')\n+\n+\n+# NOTE: Actual return type is 'FieldInfo', but we want to help type checkers",
      "comment": "type checkers complain about the missing overload implementation iirc",
      "comment_id": 1806471915,
      "user": "Viicos",
      "created_at": "2024-10-18T13:12:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/10651#discussion_r1806471915"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 311,
      "side": "RIGHT",
      "diff_hunk": "@@ -308,7 +308,7 @@ def eval_type_backport(\n \n         # If it is a `TypeError` and value isn't a `ForwardRef`, it would have failed during annotation definition.\n         # Thus we assert here for type checking purposes:\n-        assert isinstance(value, typing.ForwardRef)\n+        assert isinstance(value, typing.ForwardRef), (value, e)",
      "comment": "```suggestion\r\n        assert isinstance(value, typing.ForwardRef)\r\n```\r\nI need to come back to this for https://github.com/pydantic/pydantic/issues/10565",
      "comment_id": 1800027801,
      "user": "Viicos",
      "created_at": "2024-10-14T20:20:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1800027801"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "tests/test_types_self.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -188,3 +188,46 @@ class A(BaseModel):\n             @validate_call\n             def foo(self: Self):\n                 pass\n+\n+\n+def test_type_of_self(Self):\n+    class A(BaseModel):\n+        self_type: Type[Self]\n+\n+        @computed_field\n+        def self_types1(self) -> List[Type[Self]]:\n+            return [type(self), self.self_type]\n+\n+        # make sure `eval_type` etc. works",
      "comment": "```suggestion\r\n        # make sure forward refs are supported:\r\n```",
      "comment_id": 1800049215,
      "user": "Viicos",
      "created_at": "2024-10-14T20:27:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1800049215"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1666,
      "side": "RIGHT",
      "diff_hunk": "@@ -1659,10 +1663,15 @@ def _union_is_subclass_schema(self, union_type: Any) -> core_schema.CoreSchema:\n     def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a Type, e.g. `Type[int]`.\"\"\"\n         type_param = self._get_first_arg_or_any(type_)\n+        type_param = _typing_extra.eval_type(type_param, *self._types_namespace)",
      "comment": "Is this one necessary? `_get_first_arg_or_any` already evaluates forward refs",
      "comment_id": 1800054999,
      "user": "Viicos",
      "created_at": "2024-10-14T20:29:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1800054999"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1666,
      "side": "RIGHT",
      "diff_hunk": "@@ -1659,10 +1663,15 @@ def _union_is_subclass_schema(self, union_type: Any) -> core_schema.CoreSchema:\n     def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a Type, e.g. `Type[int]`.\"\"\"\n         type_param = self._get_first_arg_or_any(type_)\n+        type_param = _typing_extra.eval_type(type_param, *self._types_namespace)",
      "comment": "This is for annotation like `type['int']`. While `_get_first_arg_or_any` resolves `ForwardRef`, it does not resolve str objects. So `type_param` received here will be `'int'`, at least in some Python version (<= 3.10).",
      "comment_id": 1800497356,
      "user": "kc0506",
      "created_at": "2024-10-15T05:53:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1800497356"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1666,
      "side": "RIGHT",
      "diff_hunk": "@@ -1659,10 +1663,15 @@ def _union_is_subclass_schema(self, union_type: Any) -> core_schema.CoreSchema:\n     def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a Type, e.g. `Type[int]`.\"\"\"\n         type_param = self._get_first_arg_or_any(type_)\n+        type_param = _typing_extra.eval_type(type_param, *self._types_namespace)",
      "comment": "I have the same question as @Viicos.\r\n\r\nShould we be using `GenerateSchema._type_alias_type_schema` anywhere below instead?",
      "comment_id": 1801431331,
      "user": "sydney-runkle",
      "created_at": "2024-10-15T15:27:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1801431331"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1666,
      "side": "RIGHT",
      "diff_hunk": "@@ -1659,10 +1663,15 @@ def _union_is_subclass_schema(self, union_type: Any) -> core_schema.CoreSchema:\n     def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a Type, e.g. `Type[int]`.\"\"\"\n         type_param = self._get_first_arg_or_any(type_)\n+        type_param = _typing_extra.eval_type(type_param, *self._types_namespace)",
      "comment": "The evaluation of forward refs is still a mess, but looking at the other places where `_get_first_arg_or_any` (and `_get_args_resolving_forward_refs`), this is the only place where the extra evaluation is needed. Let's go this way for now but this should be cleaned up at some point.",
      "comment_id": 1803038168,
      "user": "Viicos",
      "created_at": "2024-10-16T12:45:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1803038168"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1666,
      "side": "RIGHT",
      "diff_hunk": "@@ -1659,10 +1663,15 @@ def _union_is_subclass_schema(self, union_type: Any) -> core_schema.CoreSchema:\n     def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a Type, e.g. `Type[int]`.\"\"\"\n         type_param = self._get_first_arg_or_any(type_)\n+        type_param = _typing_extra.eval_type(type_param, *self._types_namespace)",
      "comment": "> Should we be using `GenerateSchema._type_alias_type_schema` anywhere below instead?\r\n\r\nI don't think `_type_alias_type_schema` is relevant here; we want to get the actual type here, instead of the schema generated from the type.\r\n",
      "comment_id": 1803237554,
      "user": "kc0506",
      "created_at": "2024-10-16T14:31:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1803237554"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 878,
      "side": "RIGHT",
      "diff_hunk": "@@ -858,27 +862,33 @@ def _resolve_forward_ref(self, obj: Any) -> Any:\n         return obj\n \n     @overload\n-    def _get_args_resolving_forward_refs(self, obj: Any, required: Literal[True]) -> tuple[Any, ...]: ...\n+    def _get_args_resolving_forward_refs(\n+        self, obj: Any, *, required: Literal[True], eval_str: bool = True\n+    ) -> tuple[Any, ...]: ...\n \n     @overload\n-    def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None: ...\n+    def _get_args_resolving_forward_refs(self, obj: Any, *, eval_str: bool = True) -> tuple[Any, ...] | None: ...\n \n-    def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n+    def _get_args_resolving_forward_refs(\n+        self, obj: Any, *, required: bool = False, eval_str: bool = True\n+    ) -> tuple[Any, ...] | None:\n         args = get_args(obj)\n         if args:\n+            if eval_str:\n+                args = [_typing_extra._make_forward_ref(a) if isinstance(a, str) else a for a in args]",
      "comment": "@sydney-runkle @Viicos How about this pattern? \r\n\r\nThe reason not to do this all the time is because we should treat `Annotated` differently (see below).",
      "comment_id": 1803241481,
      "user": "kc0506",
      "created_at": "2024-10-16T14:34:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1803241481"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 878,
      "side": "RIGHT",
      "diff_hunk": "@@ -858,27 +862,33 @@ def _resolve_forward_ref(self, obj: Any) -> Any:\n         return obj\n \n     @overload\n-    def _get_args_resolving_forward_refs(self, obj: Any, required: Literal[True]) -> tuple[Any, ...]: ...\n+    def _get_args_resolving_forward_refs(\n+        self, obj: Any, *, required: Literal[True], eval_str: bool = True\n+    ) -> tuple[Any, ...]: ...\n \n     @overload\n-    def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None: ...\n+    def _get_args_resolving_forward_refs(self, obj: Any, *, eval_str: bool = True) -> tuple[Any, ...] | None: ...\n \n-    def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n+    def _get_args_resolving_forward_refs(\n+        self, obj: Any, *, required: bool = False, eval_str: bool = True\n+    ) -> tuple[Any, ...] | None:\n         args = get_args(obj)\n         if args:\n+            if eval_str:\n+                args = [_typing_extra._make_forward_ref(a) if isinstance(a, str) else a for a in args]",
      "comment": "I'm not a fan of the added logic here. I think it's safe enough to do:\r\n\r\n```python\r\nargs = tuple([self._resolve_forward_ref(a) if isinstance(a, (ForwardRef, str)) else a for a in args])\r\n```\r\n\r\nThis will not behave as expected for `Literal` though, but probably we can add a `assert not is_literal_type(obj), 'obj must not be a Literal instance'` just so that we avoid mistakenly using this method.",
      "comment_id": 1803260296,
      "user": "Viicos",
      "created_at": "2024-10-16T14:44:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1803260296"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 878,
      "side": "RIGHT",
      "diff_hunk": "@@ -858,27 +862,33 @@ def _resolve_forward_ref(self, obj: Any) -> Any:\n         return obj\n \n     @overload\n-    def _get_args_resolving_forward_refs(self, obj: Any, required: Literal[True]) -> tuple[Any, ...]: ...\n+    def _get_args_resolving_forward_refs(\n+        self, obj: Any, *, required: Literal[True], eval_str: bool = True\n+    ) -> tuple[Any, ...]: ...\n \n     @overload\n-    def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None: ...\n+    def _get_args_resolving_forward_refs(self, obj: Any, *, eval_str: bool = True) -> tuple[Any, ...] | None: ...\n \n-    def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n+    def _get_args_resolving_forward_refs(\n+        self, obj: Any, *, required: bool = False, eval_str: bool = True\n+    ) -> tuple[Any, ...] | None:\n         args = get_args(obj)\n         if args:\n+            if eval_str:\n+                args = [_typing_extra._make_forward_ref(a) if isinstance(a, str) else a for a in args]",
      "comment": "Unfortunately `self._resolve_forward_ref` does not resolve `str` objects because under the hood it calls `_typing_extra.eval_type_backport` instead of `_typing_extra.eval_type`. I guess we have to use `_typing_extra._make_forward_ref` anyways.",
      "comment_id": 1803323175,
      "user": "kc0506",
      "created_at": "2024-10-16T15:16:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1803323175"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 877,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +870,11 @@ def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None:\n     def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n         args = get_args(obj)\n         if args:\n+            if not _typing_extra.is_literal_type(obj) and not _typing_extra.is_annotated(obj):\n+                # This is a rare case, but one example is `obj = list['int']` in Python 3.9-3.11\n+                # Other examples are `tuple['int'], type['int']`, etc.\n+                # These cases are due to inconsistency between for example `list` and `List` in these versions.\n+                args = [_typing_extra._make_forward_ref(a) if isinstance(a, str) else a for a in args]",
      "comment": "```suggestion\r\n            if isinstance(obj, GenericAlias):\r\n                # PEP 585 generic aliases don't convert args to ForwardRefs, unlike `typing.List/Dict` etc.\r\n                args = (_typing_extra._make_forward_ref(a) if isinstance(a, str) else a for a in args)\r\n```\r\n\r\nLet's use the same check as in https://github.com/python/cpython/pull/30900.",
      "comment_id": 1804446476,
      "user": "Viicos",
      "created_at": "2024-10-17T09:39:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1804446476"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 878,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +870,11 @@ def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None:\n     def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n         args = get_args(obj)\n         if args:\n+            if not _typing_extra.is_literal_type(obj) and not _typing_extra.is_annotated(obj):\n+                # This is a rare case, but one example is `obj = list['int']` in Python 3.9-3.11\n+                # Other examples are `tuple['int'], type['int']`, etc.\n+                # These cases are due to inconsistency between for example `list` and `List` in these versions.\n+                args = [_typing_extra._make_forward_ref(a) if isinstance(a, str) else a for a in args]\n             args = tuple([self._resolve_forward_ref(a) if isinstance(a, ForwardRef) else a for a in args])",
      "comment": "```suggestion\r\n            args = (self._resolve_forward_ref(a) if isinstance(a, ForwardRef) else a for a in args)\r\n```",
      "comment_id": 1804447206,
      "user": "Viicos",
      "created_at": "2024-10-17T09:39:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1804447206"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1666,
      "side": "RIGHT",
      "diff_hunk": "@@ -1659,10 +1663,15 @@ def _union_is_subclass_schema(self, union_type: Any) -> core_schema.CoreSchema:\n     def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a Type, e.g. `Type[int]`.\"\"\"\n         type_param = self._get_first_arg_or_any(type_)\n+        type_param = _typing_extra.eval_type(type_param, *self._types_namespace)",
      "comment": "With the changes in `_get_args_resolving_forward_refs`, this can be removed :+1: ",
      "comment_id": 1804448264,
      "user": "Viicos",
      "created_at": "2024-10-17T09:40:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1804448264"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10621,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 876,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,7 +870,10 @@ def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None:\n     def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n         args = get_args(obj)\n         if args:\n-            args = tuple([self._resolve_forward_ref(a) if isinstance(a, ForwardRef) else a for a in args])\n+            if isinstance(obj, GenericAlias):\n+                # PEP 585 generic aliases don't convert args to ForwardRefs, unlike `typing.List/Dict` etc.\n+                args = (_typing_extra._make_forward_ref(a) if isinstance(a, str) else a for a in args)\n+            args = (self._resolve_forward_ref(a) if isinstance(a, ForwardRef) else a for a in args)",
      "comment": "```suggestion\r\n                args = tuple(_typing_extra._make_forward_ref(a) if isinstance(a, str) else a for a in args)\r\n            args = tuple(self._resolve_forward_ref(a) if isinstance(a, ForwardRef) else a for a in args)\r\n```\r\nsorry",
      "comment_id": 1804501633,
      "user": "Viicos",
      "created_at": "2024-10-17T10:18:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10621#discussion_r1804501633"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10643,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1379,
      "side": "RIGHT",
      "diff_hunk": "@@ -1375,13 +1376,13 @@ def _union_schema(self, union_type: Any) -> core_schema.CoreSchema:\n \n     def _type_alias_type_schema(\n         self,\n-        obj: TypeAliasType,\n+        obj: TypeAliasType | GenericAlias,",
      "comment": "`GenericAlias` and `typing._GenericAlias` act as proxy objects in some way, I don't think we want to annotate `obj` like so here.",
      "comment_id": 1804457001,
      "user": "Viicos",
      "created_at": "2024-10-17T09:46:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10643#discussion_r1804457001"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10643,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1385,
      "side": "RIGHT",
      "diff_hunk": "@@ -1375,13 +1376,13 @@ def _union_schema(self, union_type: Any) -> core_schema.CoreSchema:\n \n     def _type_alias_type_schema(\n         self,\n-        obj: TypeAliasType,\n+        obj: TypeAliasType | GenericAlias,\n     ) -> CoreSchema:\n         with self.defs.get_schema_or_ref(obj) as (ref, maybe_schema):\n             if maybe_schema is not None:\n                 return maybe_schema\n \n-            origin = get_origin(obj) or obj\n+            origin: TypeAliasType = get_origin(obj) or cast(TypeAliasType, obj)",
      "comment": "Probably best to just do:\r\n\r\n```suggestion\r\n            origin: TypeAliasType = get_origin(obj) or obj\r\n```",
      "comment_id": 1804459890,
      "user": "Viicos",
      "created_at": "2024-10-17T09:48:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10643#discussion_r1804459890"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10643,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1042,
      "side": "RIGHT",
      "diff_hunk": "@@ -1039,7 +1038,9 @@ def _match_generic_type(self, obj: Any, origin: Any) -> CoreSchema:  # noqa: C90\n         if from_property is not None:\n             return from_property\n \n-        if _typing_extra.origin_is_union(origin):\n+        if isinstance(origin, TypeAliasType):\n+            return self._type_alias_type_schema(obj)",
      "comment": "I think without a special reason (e.g. `dataclass` above), these matching clauses should better be put together to make things clearer. Looks like when `origin` is of type `TypeAliasType`, `from_property` is always `None` (at least in the current tests), so moving it does not have any actual effect.",
      "comment_id": 1804489910,
      "user": "kc0506",
      "created_at": "2024-10-17T10:09:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10643#discussion_r1804489910"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10627,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 24,
      "side": "LEFT",
      "diff_hunk": "@@ -12,49 +14,83 @@\n from ._config import ConfigWrapper\n from ._namespace_utils import MappingNamespace, NsResolver, ns_for_function\n \n+# Note: This does not play very well with type checkers. For example,\n+# `a: LambdaType = lambda x: x` will raise a type error by Pyright.\n+ValidateCallSupportedTypes = Union[\n+    LambdaType,\n+    FunctionType,\n+    MethodType,\n+    BuiltinFunctionType,\n+    BuiltinMethodType,\n+    functools.partial,\n+]\n+\n+VALIDATE_CALL_SUPPORTED_TYPES = get_args(ValidateCallSupportedTypes)\n+\n+\n+def extract_function_name(func: ValidateCallSupportedTypes) -> str:\n+    \"\"\"Extract the name of a `ValidateCallSupportedTypes` object.\"\"\"\n+    return f'partial({func.func.__name__})' if isinstance(func, functools.partial) else func.__name__\n+\n+\n+def extract_function_qualname(func: ValidateCallSupportedTypes) -> str:\n+    \"\"\"Extract the qualname of a `ValidateCallSupportedTypes` object.\"\"\"\n+    return f'partial({func.func.__qualname__})' if isinstance(func, functools.partial) else func.__qualname__\n+\n+\n+def update_wrapper_attributes(wrapped: ValidateCallSupportedTypes, wrapper: Callable[..., Any]):\n+    \"\"\"Update the `wrapper` function with the attributes of the `wrapped` function. Return the updated function.\"\"\"\n+    if inspect.iscoroutinefunction(wrapped):\n+\n+        @functools.wraps(wrapped)\n+        async def wrapper_function(*args, **kwargs):  # type: ignore\n+            return await wrapper(*args, **kwargs)\n+    else:\n+\n+        @functools.wraps(wrapped)\n+        def wrapper_function(*args, **kwargs):\n+            return wrapper(*args, **kwargs)\n+\n+    # We need to manually update this because `partial` object has no `__name__` and `__qualname__`.\n+    wrapper_function.__name__ = extract_function_name(wrapped)\n+    wrapper_function.__qualname__ = extract_function_qualname(wrapped)\n+    wrapper_function.raw_function = wrapped  # type: ignore\n+\n+    return wrapper_function\n+\n \n class ValidateCallWrapper:\n     \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optionally the return value.\"\"\"\n \n-    __slots__ = (\n-        '__pydantic_validator__',\n-        '__name__',\n-        '__qualname__',\n-        '__annotations__',\n-        '__dict__',  # required for __module__",
      "comment": "Have we thought about the consequences of removing this?",
      "comment_id": 1801392632,
      "user": "sydney-runkle",
      "created_at": "2024-10-15T15:13:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10627#discussion_r1801392632"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10627,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,49 +14,83 @@\n from ._config import ConfigWrapper\n from ._namespace_utils import MappingNamespace, NsResolver, ns_for_function\n \n+# Note: This does not play very well with type checkers. For example,\n+# `a: LambdaType = lambda x: x` will raise a type error by Pyright.\n+ValidateCallSupportedTypes = Union[\n+    LambdaType,\n+    FunctionType,\n+    MethodType,\n+    BuiltinFunctionType,\n+    BuiltinMethodType,\n+    functools.partial,\n+]\n+\n+VALIDATE_CALL_SUPPORTED_TYPES = get_args(ValidateCallSupportedTypes)",
      "comment": "Is there really no better alternative here for a type hint?",
      "comment_id": 1801396602,
      "user": "sydney-runkle",
      "created_at": "2024-10-15T15:14:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10627#discussion_r1801396602"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10627,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,49 +14,83 @@\n from ._config import ConfigWrapper\n from ._namespace_utils import MappingNamespace, NsResolver, ns_for_function\n \n+# Note: This does not play very well with type checkers. For example,\n+# `a: LambdaType = lambda x: x` will raise a type error by Pyright.\n+ValidateCallSupportedTypes = Union[\n+    LambdaType,\n+    FunctionType,\n+    MethodType,\n+    BuiltinFunctionType,\n+    BuiltinMethodType,\n+    functools.partial,\n+]\n+\n+VALIDATE_CALL_SUPPORTED_TYPES = get_args(ValidateCallSupportedTypes)\n+\n+\n+def extract_function_name(func: ValidateCallSupportedTypes) -> str:\n+    \"\"\"Extract the name of a `ValidateCallSupportedTypes` object.\"\"\"\n+    return f'partial({func.func.__name__})' if isinstance(func, functools.partial) else func.__name__\n+\n+\n+def extract_function_qualname(func: ValidateCallSupportedTypes) -> str:\n+    \"\"\"Extract the qualname of a `ValidateCallSupportedTypes` object.\"\"\"\n+    return f'partial({func.func.__qualname__})' if isinstance(func, functools.partial) else func.__qualname__\n+\n+\n+def update_wrapper_attributes(wrapped: ValidateCallSupportedTypes, wrapper: Callable[..., Any]):\n+    \"\"\"Update the `wrapper` function with the attributes of the `wrapped` function. Return the updated function.\"\"\"\n+    if inspect.iscoroutinefunction(wrapped):\n+\n+        @functools.wraps(wrapped)\n+        async def wrapper_function(*args, **kwargs):  # type: ignore\n+            return await wrapper(*args, **kwargs)\n+    else:\n+\n+        @functools.wraps(wrapped)\n+        def wrapper_function(*args, **kwargs):\n+            return wrapper(*args, **kwargs)\n+\n+    # We need to manually update this because `partial` object has no `__name__` and `__qualname__`.\n+    wrapper_function.__name__ = extract_function_name(wrapped)\n+    wrapper_function.__qualname__ = extract_function_qualname(wrapped)\n+    wrapper_function.raw_function = wrapped  # type: ignore\n+\n+    return wrapper_function\n+\n \n class ValidateCallWrapper:\n     \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optionally the return value.\"\"\"\n \n-    __slots__ = (\n-        '__pydantic_validator__',\n-        '__name__',\n-        '__qualname__',\n-        '__annotations__',\n-        '__dict__',  # required for __module__\n-    )\n+    __slots__ = ('__pydantic_validator__', '__return_pydantic_validator__')\n \n     def __init__(\n         self,\n-        function: Callable[..., Any],\n+        function: ValidateCallSupportedTypes,\n         config: ConfigDict | None,\n         validate_return: bool,\n         parent_namespace: MappingNamespace | None,\n-    ):\n+    ) -> None:\n         if isinstance(function, partial):\n-            func = function.func\n-            schema_type = func\n-            self.__name__ = f'partial({func.__name__})'\n-            self.__qualname__ = f'partial({func.__qualname__})'\n-            self.__module__ = func.__module__\n+            schema_type = function.func\n+            module = function.func.__module__\n         else:\n             schema_type = function\n-            self.__name__ = function.__name__\n-            self.__qualname__ = function.__qualname__\n-            self.__module__ = function.__module__\n+            module = function.__module__\n+        qualname = core_config_title = extract_function_qualname(function)",
      "comment": "```suggestion\r\n        qualname = extract_function_qualname(function)\r\n```",
      "comment_id": 1801399283,
      "user": "sydney-runkle",
      "created_at": "2024-10-15T15:15:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10627#discussion_r1801399283"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10627,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,49 +14,83 @@\n from ._config import ConfigWrapper\n from ._namespace_utils import MappingNamespace, NsResolver, ns_for_function\n \n+# Note: This does not play very well with type checkers. For example,\n+# `a: LambdaType = lambda x: x` will raise a type error by Pyright.\n+ValidateCallSupportedTypes = Union[\n+    LambdaType,\n+    FunctionType,\n+    MethodType,\n+    BuiltinFunctionType,\n+    BuiltinMethodType,\n+    functools.partial,\n+]\n+\n+VALIDATE_CALL_SUPPORTED_TYPES = get_args(ValidateCallSupportedTypes)\n+\n+\n+def extract_function_name(func: ValidateCallSupportedTypes) -> str:\n+    \"\"\"Extract the name of a `ValidateCallSupportedTypes` object.\"\"\"\n+    return f'partial({func.func.__name__})' if isinstance(func, functools.partial) else func.__name__\n+\n+\n+def extract_function_qualname(func: ValidateCallSupportedTypes) -> str:\n+    \"\"\"Extract the qualname of a `ValidateCallSupportedTypes` object.\"\"\"\n+    return f'partial({func.func.__qualname__})' if isinstance(func, functools.partial) else func.__qualname__\n+\n+\n+def update_wrapper_attributes(wrapped: ValidateCallSupportedTypes, wrapper: Callable[..., Any]):\n+    \"\"\"Update the `wrapper` function with the attributes of the `wrapped` function. Return the updated function.\"\"\"\n+    if inspect.iscoroutinefunction(wrapped):\n+\n+        @functools.wraps(wrapped)\n+        async def wrapper_function(*args, **kwargs):  # type: ignore\n+            return await wrapper(*args, **kwargs)\n+    else:\n+\n+        @functools.wraps(wrapped)\n+        def wrapper_function(*args, **kwargs):\n+            return wrapper(*args, **kwargs)\n+\n+    # We need to manually update this because `partial` object has no `__name__` and `__qualname__`.\n+    wrapper_function.__name__ = extract_function_name(wrapped)\n+    wrapper_function.__qualname__ = extract_function_qualname(wrapped)\n+    wrapper_function.raw_function = wrapped  # type: ignore\n+\n+    return wrapper_function\n+\n \n class ValidateCallWrapper:\n     \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optionally the return value.\"\"\"\n \n-    __slots__ = (\n-        '__pydantic_validator__',\n-        '__name__',\n-        '__qualname__',\n-        '__annotations__',\n-        '__dict__',  # required for __module__\n-    )\n+    __slots__ = ('__pydantic_validator__', '__return_pydantic_validator__')\n \n     def __init__(\n         self,\n-        function: Callable[..., Any],\n+        function: ValidateCallSupportedTypes,\n         config: ConfigDict | None,\n         validate_return: bool,\n         parent_namespace: MappingNamespace | None,\n-    ):\n+    ) -> None:\n         if isinstance(function, partial):\n-            func = function.func\n-            schema_type = func\n-            self.__name__ = f'partial({func.__name__})'\n-            self.__qualname__ = f'partial({func.__qualname__})'\n-            self.__module__ = func.__module__\n+            schema_type = function.func\n+            module = function.func.__module__\n         else:\n             schema_type = function\n-            self.__name__ = function.__name__\n-            self.__qualname__ = function.__qualname__\n-            self.__module__ = function.__module__\n+            module = function.__module__\n+        qualname = core_config_title = extract_function_qualname(function)\n \n         ns_resolver = NsResolver(namespaces_tuple=ns_for_function(schema_type, parent_namespace=parent_namespace))\n \n         config_wrapper = ConfigWrapper(config)\n         gen_schema = _generate_schema.GenerateSchema(config_wrapper, ns_resolver)\n         schema = gen_schema.clean_schema(gen_schema.generate_schema(function))\n-        core_config = config_wrapper.core_config(self.__name__)\n+        core_config = config_wrapper.core_config(core_config_title)",
      "comment": "```suggestion\r\n        core_config = config_wrapper.core_config(title=qualname)\r\n```",
      "comment_id": 1801399662,
      "user": "sydney-runkle",
      "created_at": "2024-10-15T15:15:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/10627#discussion_r1801399662"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10627,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 24,
      "side": "LEFT",
      "diff_hunk": "@@ -12,49 +14,83 @@\n from ._config import ConfigWrapper\n from ._namespace_utils import MappingNamespace, NsResolver, ns_for_function\n \n+# Note: This does not play very well with type checkers. For example,\n+# `a: LambdaType = lambda x: x` will raise a type error by Pyright.\n+ValidateCallSupportedTypes = Union[\n+    LambdaType,\n+    FunctionType,\n+    MethodType,\n+    BuiltinFunctionType,\n+    BuiltinMethodType,\n+    functools.partial,\n+]\n+\n+VALIDATE_CALL_SUPPORTED_TYPES = get_args(ValidateCallSupportedTypes)\n+\n+\n+def extract_function_name(func: ValidateCallSupportedTypes) -> str:\n+    \"\"\"Extract the name of a `ValidateCallSupportedTypes` object.\"\"\"\n+    return f'partial({func.func.__name__})' if isinstance(func, functools.partial) else func.__name__\n+\n+\n+def extract_function_qualname(func: ValidateCallSupportedTypes) -> str:\n+    \"\"\"Extract the qualname of a `ValidateCallSupportedTypes` object.\"\"\"\n+    return f'partial({func.func.__qualname__})' if isinstance(func, functools.partial) else func.__qualname__\n+\n+\n+def update_wrapper_attributes(wrapped: ValidateCallSupportedTypes, wrapper: Callable[..., Any]):\n+    \"\"\"Update the `wrapper` function with the attributes of the `wrapped` function. Return the updated function.\"\"\"\n+    if inspect.iscoroutinefunction(wrapped):\n+\n+        @functools.wraps(wrapped)\n+        async def wrapper_function(*args, **kwargs):  # type: ignore\n+            return await wrapper(*args, **kwargs)\n+    else:\n+\n+        @functools.wraps(wrapped)\n+        def wrapper_function(*args, **kwargs):\n+            return wrapper(*args, **kwargs)\n+\n+    # We need to manually update this because `partial` object has no `__name__` and `__qualname__`.\n+    wrapper_function.__name__ = extract_function_name(wrapped)\n+    wrapper_function.__qualname__ = extract_function_qualname(wrapped)\n+    wrapper_function.raw_function = wrapped  # type: ignore\n+\n+    return wrapper_function\n+\n \n class ValidateCallWrapper:\n     \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optionally the return value.\"\"\"\n \n-    __slots__ = (\n-        '__pydantic_validator__',\n-        '__name__',\n-        '__qualname__',\n-        '__annotations__',\n-        '__dict__',  # required for __module__",
      "comment": "`__name__` was necessary for the core_config title thing but https://github.com/pydantic/pydantic/pull/10562 made it not necessary anymore. For the rest, I don't think it will change anything.",
      "comment_id": 1801487706,
      "user": "Viicos",
      "created_at": "2024-10-15T15:54:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/10627#discussion_r1801487706"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10627,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,49 +14,83 @@\n from ._config import ConfigWrapper\n from ._namespace_utils import MappingNamespace, NsResolver, ns_for_function\n \n+# Note: This does not play very well with type checkers. For example,\n+# `a: LambdaType = lambda x: x` will raise a type error by Pyright.\n+ValidateCallSupportedTypes = Union[\n+    LambdaType,\n+    FunctionType,\n+    MethodType,\n+    BuiltinFunctionType,\n+    BuiltinMethodType,\n+    functools.partial,\n+]\n+\n+VALIDATE_CALL_SUPPORTED_TYPES = get_args(ValidateCallSupportedTypes)",
      "comment": "We could remove the `ValidateCallSupportedTypes` type alias and just define `VALIDATE_CALL_SUPPORTED_TYPES`, and replace occurrences of the type alias with `Callable[..., Any]`. I agree `get_args` is not pretty but we use this trick in some places already :)",
      "comment_id": 1801490331,
      "user": "Viicos",
      "created_at": "2024-10-15T15:56:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10627#discussion_r1801490331"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10627,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,49 +14,83 @@\n from ._config import ConfigWrapper\n from ._namespace_utils import MappingNamespace, NsResolver, ns_for_function\n \n+# Note: This does not play very well with type checkers. For example,\n+# `a: LambdaType = lambda x: x` will raise a type error by Pyright.\n+ValidateCallSupportedTypes = Union[\n+    LambdaType,\n+    FunctionType,\n+    MethodType,\n+    BuiltinFunctionType,\n+    BuiltinMethodType,\n+    functools.partial,\n+]\n+\n+VALIDATE_CALL_SUPPORTED_TYPES = get_args(ValidateCallSupportedTypes)",
      "comment": "Alright, if we're using it already, that's fine. Thanks!",
      "comment_id": 1801498890,
      "user": "sydney-runkle",
      "created_at": "2024-10-15T16:02:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10627#discussion_r1801498890"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10620,
      "file_path": "tests/pyright/pipeline_api.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,14 +3,13 @@\n \n from pydantic.experimental.pipeline import validate_as\n \n-# this test works by adding type ignores and having pyright fail with\n-# an unused type ignore error if the type checking isn't working\n-Annotated[str, validate_as(int)]  # type: ignore\n-Annotated[str, validate_as(str).transform(lambda x: int(x))]  # type: ignore\n-Annotated[float, validate_as(float).gt(0)]  # should be able to compare float to int\n-Annotated[datetime.datetime, validate_as(datetime.datetime).datetime_tz_naive()]\n-Annotated[datetime.datetime, validate_as(str).datetime_tz_naive()]  # type: ignore\n-Annotated[\n+a1 = Annotated[str, validate_as(int)]  # pyright: ignore[reportInvalidTypeArguments]",
      "comment": "Had to assign to some variable to actually get the pyright error",
      "comment_id": 1799084144,
      "user": "Viicos",
      "created_at": "2024-10-14T09:36:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/10620#discussion_r1799084144"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 183,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,81 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in local namespace of `BaseModel`, we should use `Dict` for annotations.\n+    model_fields: ClassVar[Dict[str, FieldInfo]] = {}  # noqa: UP006\n+    \"\"\"\n+    Metadata about the fields defined on the model,\n+    mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n \n-        This replaces `Model.__fields__` from Pydantic V1.\n-        \"\"\"\n+    This replaces `Model.__fields__` from Pydantic V1.\n+    \"\"\"\n \n-        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n-        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n-\n-        __class_vars__: ClassVar[set[str]]\n-        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n-        __signature__: ClassVar[Signature]\n-\n-        __pydantic_complete__: ClassVar[bool]\n-        __pydantic_core_schema__: ClassVar[CoreSchema]\n-        __pydantic_custom_init__: ClassVar[bool]\n-        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n-        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n-        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n-        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n-        __pydantic_root_model__: ClassVar[bool]\n-        __pydantic_serializer__: ClassVar[SchemaSerializer]\n-        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n-\n-        # Instance attributes\n-        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n-        __pydantic_fields_set__: set[str] = _PrivateAttr()\n-        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n+    model_computed_fields: ClassVar[Dict[str, ComputedFieldInfo]] = {}  # noqa: UP006\n+    \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n \n-    else:\n-        # `model_fields` and `__pydantic_decorators__` must be set for\n-        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n-        model_fields = {}\n-        model_computed_fields = {}\n-\n-        __pydantic_decorators__ = _decorators.DecoratorInfos()\n-        __pydantic_parent_namespace__ = None\n-        # Prevent `BaseModel` from being instantiated directly:\n+    __pydantic_complete__: ClassVar[bool] = False\n+    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n+\n+    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n+    \"\"\"Metadata containing the decorators defined on the model.\n+    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n+\n+    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n+    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n+\n+    __pydantic_root_model__: ClassVar[bool] = False\n+    \"\"\"Whether the model is a `RootModel`.\"\"\"\n+\n+    __class_vars__: ClassVar[set[str]]\n+    \"\"\"The names of classvars defined on the model.\"\"\"\n+\n+    __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]  # noqa: UP006\n+    \"\"\"Metadata about the private attributes of the model.\"\"\"\n+\n+    __signature__: ClassVar[Signature]\n+    \"\"\"The signature for instantiating the model.\"\"\"\n+\n+    __pydantic_core_schema__: ClassVar[CoreSchema]\n+    \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n+\n+    __pydantic_custom_init__: ClassVar[bool]\n+    \"\"\"Whether the model has a custom `__init__` function.\"\"\"\n+\n+    __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n+    \"\"\"Metadata for generic models; contains data used for a similar purpose to\n+    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\"\"\"\n+\n+    __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n+    \"\"\"The name of the post-init method for the model, if defined.\"\"\"\n+\n+    __pydantic_serializer__: ClassVar[SchemaSerializer]\n+    \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n+\n+    __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n+    \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n+\n+    __pydantic_extra__: dict[str, Any] | None = _model_construction.NonInitField()\n+    \"\"\"An instance attribute with the values of extra fields from validation when\n+    `model_config['extra'] == 'allow'`.\"\"\"\n+\n+    __pydantic_fields_set__: set[str] = _model_construction.NonInitField()\n+    \"\"\"An instance attribute with the names of fields explicitly set.\"\"\"\n+\n+    __pydantic_private__: dict[str, Any] | None = _model_construction.NonInitField()\n+    \"\"\"Instance attribute with the values of private attributes set on the model instance.\"\"\"\n+\n+    if not TYPE_CHECKING:\n+        # Prevent `BaseModel` from being instantiated directly\n+        # (defined in the else block for clarity and to avoid type checking errors):",
      "comment": "```suggestion\r\n        # (defined in an `if not TYPE_CHECKING` block for clarity and to avoid type checking errors):\r\n```",
      "comment_id": 1714303542,
      "user": "Viicos",
      "created_at": "2024-08-12T20:00:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714303542"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -60,7 +60,21 @@ def __setitem__(self, k: str, v: object) -> None:\n         return super().__setitem__(k, v)\n \n \n-@dataclass_transform(kw_only_default=True, field_specifiers=(PydanticModelField, PydanticModelPrivateAttr))\n+def NonInitField(\n+    default: Any = PydanticUndefined,\n+    *,\n+    default_factory: typing.Callable[[], Any] | None = None,\n+    init: Literal[False] = False,\n+) -> Any:\n+    \"\"\"Only for typing purpose. Used as default value of `__pydantic_fields_set__`,\n+    `__pydantic_extra__`, `__pydantic_private__`, so they could be ignored when\n+    synthesizing the `__init__` signature.\n+    \"\"\"",
      "comment": "Great idea. Makes things more explicit than `_PrivateAttr`. Maybe we could rename it `NoInitField`?",
      "comment_id": 1714305316,
      "user": "Viicos",
      "created_at": "2024-08-12T20:02:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714305316"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,13 +211,17 @@ def get_cls_types_namespace(cls: type[Any], parent_namespace: dict[str, Any] | N\n     return ns\n \n \n-def get_cls_type_hints_lenient(obj: Any, globalns: dict[str, Any] | None = None) -> dict[str, Any]:\n+def get_cls_type_hints_lenient(\n+    obj: Any, globalns: dict[str, Any] | None = None, mro: Iterable[type] | None = None",
      "comment": "```suggestion\r\n    obj: Any, globalns: dict[str, Any] | None = None, mro: Iterable[type[Any]] | None = None\r\n```\r\n\r\nnitpick",
      "comment_id": 1714306062,
      "user": "Viicos",
      "created_at": "2024-08-12T20:02:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714306062"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,81 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in local namespace of `BaseModel`, we should use `Dict` for annotations.",
      "comment": "```suggestion\r\n    # Because `dict` is in the local namespace of the `BaseModel` class, we use `Dict` for annotations.\r\n    # TODO v3 fallback to `dict` when the deprecated `dict` method gets removed.\r\n```\r\n\r\nnitpick.",
      "comment_id": 1714307214,
      "user": "Viicos",
      "created_at": "2024-08-12T20:04:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714307214"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 68,
      "side": "RIGHT",
      "diff_hunk": "@@ -60,7 +60,19 @@ def __setitem__(self, k: str, v: object) -> None:\n         return super().__setitem__(k, v)\n \n \n-@dataclass_transform(kw_only_default=True, field_specifiers=(PydanticModelField, PydanticModelPrivateAttr))\n+def NoInitField(\n+    default: Any = PydanticUndefined,\n+    *,\n+    default_factory: typing.Callable[[], Any] | None = None,\n+    init: Literal[False] = False,\n+) -> Any:",
      "comment": "```suggestion\r\ndef NoInitField(\r\n    *,\r\n    init: Literal[False] = False,\r\n) -> Any:\r\n```\r\n\r\nI don't think it matters to have the default arguments, as the field will be excluded from the `__init__` signature anyway.",
      "comment_id": 1714768358,
      "user": "Viicos",
      "created_at": "2024-08-13T06:58:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714768358"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -228,7 +240,10 @@ def wrapped_model_post_init(self: BaseModel, context: Any, /) -> None:\n             super(cls, cls).__pydantic_init_subclass__(**kwargs)  # type: ignore[misc]\n             return cls\n         else:\n-            # this is the BaseModel class itself being created, no logic required\n+            # These are instance variables, but have been assigned value to trick type checker.",
      "comment": "```suggestion\r\n            # These are instance variables, but have been assigned to `NoInitField` to trick the type checker.\r\n```",
      "comment_id": 1714809873,
      "user": "Viicos",
      "created_at": "2024-08-13T07:30:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714809873"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -60,7 +60,19 @@ def __setitem__(self, k: str, v: object) -> None:\n         return super().__setitem__(k, v)\n \n \n-@dataclass_transform(kw_only_default=True, field_specifiers=(PydanticModelField, PydanticModelPrivateAttr))\n+def NoInitField(\n+    default: Any = PydanticUndefined,\n+    *,\n+    default_factory: typing.Callable[[], Any] | None = None,\n+    init: Literal[False] = False,\n+) -> Any:\n+    \"\"\"Only for typing purpose. Used as default value of `__pydantic_fields_set__`,",
      "comment": "```suggestion\r\n    \"\"\"Only for typing purposes. Used as default value of `__pydantic_fields_set__`,\r\n```",
      "comment_id": 1714810295,
      "user": "Viicos",
      "created_at": "2024-08-13T07:30:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714810295"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,82 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in the local namespace of the `BaseModel` class, we use `Dict` for annotations.\n+    # TODO v3 fallback to `dict` when the deprecated `dict` method gets removed.\n+    model_fields: ClassVar[Dict[str, FieldInfo]] = {}  # noqa: UP006\n+    \"\"\"\n+    Metadata about the fields defined on the model,\n+    mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n \n-        This replaces `Model.__fields__` from Pydantic V1.\n-        \"\"\"\n+    This replaces `Model.__fields__` from Pydantic V1.\n+    \"\"\"\n \n-        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n-        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n-\n-        __class_vars__: ClassVar[set[str]]\n-        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n-        __signature__: ClassVar[Signature]\n-\n-        __pydantic_complete__: ClassVar[bool]\n-        __pydantic_core_schema__: ClassVar[CoreSchema]\n-        __pydantic_custom_init__: ClassVar[bool]\n-        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n-        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n-        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n-        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n-        __pydantic_root_model__: ClassVar[bool]\n-        __pydantic_serializer__: ClassVar[SchemaSerializer]\n-        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n-\n-        # Instance attributes\n-        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n-        __pydantic_fields_set__: set[str] = _PrivateAttr()\n-        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n+    model_computed_fields: ClassVar[Dict[str, ComputedFieldInfo]] = {}  # noqa: UP006\n+    \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n \n-    else:\n-        # `model_fields` and `__pydantic_decorators__` must be set for\n-        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n-        model_fields = {}\n-        model_computed_fields = {}\n-\n-        __pydantic_decorators__ = _decorators.DecoratorInfos()\n-        __pydantic_parent_namespace__ = None\n-        # Prevent `BaseModel` from being instantiated directly:\n+    __pydantic_complete__: ClassVar[bool] = False\n+    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n+\n+    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n+    \"\"\"Metadata containing the decorators defined on the model.\n+    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n+\n+    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n+    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n+\n+    __pydantic_root_model__: ClassVar[bool] = False\n+    \"\"\"Whether the model is a `RootModel`.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\"\"\"\r\n```",
      "comment_id": 1714812412,
      "user": "Viicos",
      "created_at": "2024-08-13T07:32:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714812412"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 145,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,82 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in the local namespace of the `BaseModel` class, we use `Dict` for annotations.\n+    # TODO v3 fallback to `dict` when the deprecated `dict` method gets removed.\n+    model_fields: ClassVar[Dict[str, FieldInfo]] = {}  # noqa: UP006\n+    \"\"\"\n+    Metadata about the fields defined on the model,\n+    mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n \n-        This replaces `Model.__fields__` from Pydantic V1.\n-        \"\"\"\n+    This replaces `Model.__fields__` from Pydantic V1.\n+    \"\"\"\n \n-        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n-        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n-\n-        __class_vars__: ClassVar[set[str]]\n-        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n-        __signature__: ClassVar[Signature]\n-\n-        __pydantic_complete__: ClassVar[bool]\n-        __pydantic_core_schema__: ClassVar[CoreSchema]\n-        __pydantic_custom_init__: ClassVar[bool]\n-        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n-        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n-        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n-        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n-        __pydantic_root_model__: ClassVar[bool]\n-        __pydantic_serializer__: ClassVar[SchemaSerializer]\n-        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n-\n-        # Instance attributes\n-        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n-        __pydantic_fields_set__: set[str] = _PrivateAttr()\n-        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n+    model_computed_fields: ClassVar[Dict[str, ComputedFieldInfo]] = {}  # noqa: UP006\n+    \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n \n-    else:\n-        # `model_fields` and `__pydantic_decorators__` must be set for\n-        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n-        model_fields = {}\n-        model_computed_fields = {}\n-\n-        __pydantic_decorators__ = _decorators.DecoratorInfos()\n-        __pydantic_parent_namespace__ = None\n-        # Prevent `BaseModel` from being instantiated directly:\n+    __pydantic_complete__: ClassVar[bool] = False\n+    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n+\n+    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n+    \"\"\"Metadata containing the decorators defined on the model.\n+    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n+\n+    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n+    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n+\n+    __pydantic_root_model__: ClassVar[bool] = False\n+    \"\"\"Whether the model is a `RootModel`.\"\"\"\n+\n+    __class_vars__: ClassVar[set[str]]\n+    \"\"\"The names of classvars defined on the model.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"The names of the class variables defined on the model.\"\"\"\r\n```",
      "comment_id": 1714812721,
      "user": "Viicos",
      "created_at": "2024-08-13T07:32:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714812721"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,82 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in the local namespace of the `BaseModel` class, we use `Dict` for annotations.\n+    # TODO v3 fallback to `dict` when the deprecated `dict` method gets removed.\n+    model_fields: ClassVar[Dict[str, FieldInfo]] = {}  # noqa: UP006\n+    \"\"\"\n+    Metadata about the fields defined on the model,\n+    mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n \n-        This replaces `Model.__fields__` from Pydantic V1.\n-        \"\"\"\n+    This replaces `Model.__fields__` from Pydantic V1.\n+    \"\"\"\n \n-        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n-        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n-\n-        __class_vars__: ClassVar[set[str]]\n-        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n-        __signature__: ClassVar[Signature]\n-\n-        __pydantic_complete__: ClassVar[bool]\n-        __pydantic_core_schema__: ClassVar[CoreSchema]\n-        __pydantic_custom_init__: ClassVar[bool]\n-        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n-        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n-        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n-        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n-        __pydantic_root_model__: ClassVar[bool]\n-        __pydantic_serializer__: ClassVar[SchemaSerializer]\n-        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n-\n-        # Instance attributes\n-        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n-        __pydantic_fields_set__: set[str] = _PrivateAttr()\n-        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n+    model_computed_fields: ClassVar[Dict[str, ComputedFieldInfo]] = {}  # noqa: UP006\n+    \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n \n-    else:\n-        # `model_fields` and `__pydantic_decorators__` must be set for\n-        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n-        model_fields = {}\n-        model_computed_fields = {}\n-\n-        __pydantic_decorators__ = _decorators.DecoratorInfos()\n-        __pydantic_parent_namespace__ = None\n-        # Prevent `BaseModel` from being instantiated directly:\n+    __pydantic_complete__: ClassVar[bool] = False\n+    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n+\n+    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n+    \"\"\"Metadata containing the decorators defined on the model.\n+    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n+\n+    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n+    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n+\n+    __pydantic_root_model__: ClassVar[bool] = False\n+    \"\"\"Whether the model is a `RootModel`.\"\"\"\n+\n+    __class_vars__: ClassVar[set[str]]\n+    \"\"\"The names of classvars defined on the model.\"\"\"\n+\n+    __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]  # noqa: UP006\n+    \"\"\"Metadata about the private attributes of the model.\"\"\"\n+\n+    __signature__: ClassVar[Signature]\n+    \"\"\"The signature for instantiating the model.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\"\"\"\r\n```",
      "comment_id": 1714817076,
      "user": "Viicos",
      "created_at": "2024-08-13T07:35:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714817076"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,82 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in the local namespace of the `BaseModel` class, we use `Dict` for annotations.\n+    # TODO v3 fallback to `dict` when the deprecated `dict` method gets removed.\n+    model_fields: ClassVar[Dict[str, FieldInfo]] = {}  # noqa: UP006\n+    \"\"\"\n+    Metadata about the fields defined on the model,\n+    mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n \n-        This replaces `Model.__fields__` from Pydantic V1.\n-        \"\"\"\n+    This replaces `Model.__fields__` from Pydantic V1.\n+    \"\"\"\n \n-        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n-        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n-\n-        __class_vars__: ClassVar[set[str]]\n-        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n-        __signature__: ClassVar[Signature]\n-\n-        __pydantic_complete__: ClassVar[bool]\n-        __pydantic_core_schema__: ClassVar[CoreSchema]\n-        __pydantic_custom_init__: ClassVar[bool]\n-        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n-        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n-        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n-        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n-        __pydantic_root_model__: ClassVar[bool]\n-        __pydantic_serializer__: ClassVar[SchemaSerializer]\n-        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n-\n-        # Instance attributes\n-        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n-        __pydantic_fields_set__: set[str] = _PrivateAttr()\n-        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n+    model_computed_fields: ClassVar[Dict[str, ComputedFieldInfo]] = {}  # noqa: UP006\n+    \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n \n-    else:\n-        # `model_fields` and `__pydantic_decorators__` must be set for\n-        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n-        model_fields = {}\n-        model_computed_fields = {}\n-\n-        __pydantic_decorators__ = _decorators.DecoratorInfos()\n-        __pydantic_parent_namespace__ = None\n-        # Prevent `BaseModel` from being instantiated directly:\n+    __pydantic_complete__: ClassVar[bool] = False\n+    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n+\n+    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n+    \"\"\"Metadata containing the decorators defined on the model.\n+    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n+\n+    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n+    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n+\n+    __pydantic_root_model__: ClassVar[bool] = False\n+    \"\"\"Whether the model is a `RootModel`.\"\"\"\n+\n+    __class_vars__: ClassVar[set[str]]\n+    \"\"\"The names of classvars defined on the model.\"\"\"\n+\n+    __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]  # noqa: UP006\n+    \"\"\"Metadata about the private attributes of the model.\"\"\"\n+\n+    __signature__: ClassVar[Signature]\n+    \"\"\"The signature for instantiating the model.\"\"\"\n+\n+    __pydantic_core_schema__: ClassVar[CoreSchema]\n+    \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"The core schema of the model.\"\"\"\r\n```",
      "comment_id": 1714817815,
      "user": "Viicos",
      "created_at": "2024-08-13T07:36:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714817815"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,82 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in the local namespace of the `BaseModel` class, we use `Dict` for annotations.\n+    # TODO v3 fallback to `dict` when the deprecated `dict` method gets removed.\n+    model_fields: ClassVar[Dict[str, FieldInfo]] = {}  # noqa: UP006\n+    \"\"\"\n+    Metadata about the fields defined on the model,\n+    mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n \n-        This replaces `Model.__fields__` from Pydantic V1.\n-        \"\"\"\n+    This replaces `Model.__fields__` from Pydantic V1.\n+    \"\"\"\n \n-        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n-        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n-\n-        __class_vars__: ClassVar[set[str]]\n-        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n-        __signature__: ClassVar[Signature]\n-\n-        __pydantic_complete__: ClassVar[bool]\n-        __pydantic_core_schema__: ClassVar[CoreSchema]\n-        __pydantic_custom_init__: ClassVar[bool]\n-        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n-        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n-        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n-        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n-        __pydantic_root_model__: ClassVar[bool]\n-        __pydantic_serializer__: ClassVar[SchemaSerializer]\n-        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n-\n-        # Instance attributes\n-        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n-        __pydantic_fields_set__: set[str] = _PrivateAttr()\n-        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n+    model_computed_fields: ClassVar[Dict[str, ComputedFieldInfo]] = {}  # noqa: UP006\n+    \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n \n-    else:\n-        # `model_fields` and `__pydantic_decorators__` must be set for\n-        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n-        model_fields = {}\n-        model_computed_fields = {}\n-\n-        __pydantic_decorators__ = _decorators.DecoratorInfos()\n-        __pydantic_parent_namespace__ = None\n-        # Prevent `BaseModel` from being instantiated directly:\n+    __pydantic_complete__: ClassVar[bool] = False\n+    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n+\n+    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n+    \"\"\"Metadata containing the decorators defined on the model.\n+    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n+\n+    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n+    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n+\n+    __pydantic_root_model__: ClassVar[bool] = False\n+    \"\"\"Whether the model is a `RootModel`.\"\"\"\n+\n+    __class_vars__: ClassVar[set[str]]\n+    \"\"\"The names of classvars defined on the model.\"\"\"\n+\n+    __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]  # noqa: UP006\n+    \"\"\"Metadata about the private attributes of the model.\"\"\"\n+\n+    __signature__: ClassVar[Signature]\n+    \"\"\"The signature for instantiating the model.\"\"\"\n+\n+    __pydantic_core_schema__: ClassVar[CoreSchema]\n+    \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n+\n+    __pydantic_custom_init__: ClassVar[bool]\n+    \"\"\"Whether the model has a custom `__init__` function.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"Whether the model has a custom `__init__` method.\"\"\"\r\n```",
      "comment_id": 1714820633,
      "user": "Viicos",
      "created_at": "2024-08-13T07:38:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714820633"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,82 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in the local namespace of the `BaseModel` class, we use `Dict` for annotations.\n+    # TODO v3 fallback to `dict` when the deprecated `dict` method gets removed.\n+    model_fields: ClassVar[Dict[str, FieldInfo]] = {}  # noqa: UP006\n+    \"\"\"\n+    Metadata about the fields defined on the model,\n+    mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n \n-        This replaces `Model.__fields__` from Pydantic V1.\n-        \"\"\"\n+    This replaces `Model.__fields__` from Pydantic V1.\n+    \"\"\"\n \n-        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n-        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n-\n-        __class_vars__: ClassVar[set[str]]\n-        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n-        __signature__: ClassVar[Signature]\n-\n-        __pydantic_complete__: ClassVar[bool]\n-        __pydantic_core_schema__: ClassVar[CoreSchema]\n-        __pydantic_custom_init__: ClassVar[bool]\n-        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n-        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n-        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n-        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n-        __pydantic_root_model__: ClassVar[bool]\n-        __pydantic_serializer__: ClassVar[SchemaSerializer]\n-        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n-\n-        # Instance attributes\n-        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n-        __pydantic_fields_set__: set[str] = _PrivateAttr()\n-        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n+    model_computed_fields: ClassVar[Dict[str, ComputedFieldInfo]] = {}  # noqa: UP006\n+    \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n \n-    else:\n-        # `model_fields` and `__pydantic_decorators__` must be set for\n-        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n-        model_fields = {}\n-        model_computed_fields = {}\n-\n-        __pydantic_decorators__ = _decorators.DecoratorInfos()\n-        __pydantic_parent_namespace__ = None\n-        # Prevent `BaseModel` from being instantiated directly:\n+    __pydantic_complete__: ClassVar[bool] = False\n+    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n+\n+    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n+    \"\"\"Metadata containing the decorators defined on the model.\n+    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n+\n+    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n+    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n+\n+    __pydantic_root_model__: ClassVar[bool] = False\n+    \"\"\"Whether the model is a `RootModel`.\"\"\"\n+\n+    __class_vars__: ClassVar[set[str]]\n+    \"\"\"The names of classvars defined on the model.\"\"\"\n+\n+    __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]  # noqa: UP006\n+    \"\"\"Metadata about the private attributes of the model.\"\"\"\n+\n+    __signature__: ClassVar[Signature]\n+    \"\"\"The signature for instantiating the model.\"\"\"\n+\n+    __pydantic_core_schema__: ClassVar[CoreSchema]\n+    \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n+\n+    __pydantic_custom_init__: ClassVar[bool]\n+    \"\"\"Whether the model has a custom `__init__` function.\"\"\"\n+\n+    __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n+    \"\"\"Metadata for generic models; contains data used for a similar purpose to\n+    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\"\"\"\n+\n+    __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n+    \"\"\"The name of the post-init method for the model, if defined.\"\"\"\n+\n+    __pydantic_serializer__: ClassVar[SchemaSerializer]\n+    \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\"\"\"\r\n```",
      "comment_id": 1714821434,
      "user": "Viicos",
      "created_at": "2024-08-13T07:38:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714821434"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,82 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in the local namespace of the `BaseModel` class, we use `Dict` for annotations.\n+    # TODO v3 fallback to `dict` when the deprecated `dict` method gets removed.\n+    model_fields: ClassVar[Dict[str, FieldInfo]] = {}  # noqa: UP006\n+    \"\"\"\n+    Metadata about the fields defined on the model,\n+    mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n \n-        This replaces `Model.__fields__` from Pydantic V1.\n-        \"\"\"\n+    This replaces `Model.__fields__` from Pydantic V1.\n+    \"\"\"\n \n-        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n-        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n-\n-        __class_vars__: ClassVar[set[str]]\n-        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n-        __signature__: ClassVar[Signature]\n-\n-        __pydantic_complete__: ClassVar[bool]\n-        __pydantic_core_schema__: ClassVar[CoreSchema]\n-        __pydantic_custom_init__: ClassVar[bool]\n-        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n-        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n-        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n-        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n-        __pydantic_root_model__: ClassVar[bool]\n-        __pydantic_serializer__: ClassVar[SchemaSerializer]\n-        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n-\n-        # Instance attributes\n-        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n-        __pydantic_fields_set__: set[str] = _PrivateAttr()\n-        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n+    model_computed_fields: ClassVar[Dict[str, ComputedFieldInfo]] = {}  # noqa: UP006\n+    \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n \n-    else:\n-        # `model_fields` and `__pydantic_decorators__` must be set for\n-        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n-        model_fields = {}\n-        model_computed_fields = {}\n-\n-        __pydantic_decorators__ = _decorators.DecoratorInfos()\n-        __pydantic_parent_namespace__ = None\n-        # Prevent `BaseModel` from being instantiated directly:\n+    __pydantic_complete__: ClassVar[bool] = False\n+    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n+\n+    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n+    \"\"\"Metadata containing the decorators defined on the model.\n+    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n+\n+    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n+    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n+\n+    __pydantic_root_model__: ClassVar[bool] = False\n+    \"\"\"Whether the model is a `RootModel`.\"\"\"\n+\n+    __class_vars__: ClassVar[set[str]]\n+    \"\"\"The names of classvars defined on the model.\"\"\"\n+\n+    __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]  # noqa: UP006\n+    \"\"\"Metadata about the private attributes of the model.\"\"\"\n+\n+    __signature__: ClassVar[Signature]\n+    \"\"\"The signature for instantiating the model.\"\"\"\n+\n+    __pydantic_core_schema__: ClassVar[CoreSchema]\n+    \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n+\n+    __pydantic_custom_init__: ClassVar[bool]\n+    \"\"\"Whether the model has a custom `__init__` function.\"\"\"\n+\n+    __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n+    \"\"\"Metadata for generic models; contains data used for a similar purpose to\n+    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\"\"\"\n+\n+    __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n+    \"\"\"The name of the post-init method for the model, if defined.\"\"\"\n+\n+    __pydantic_serializer__: ClassVar[SchemaSerializer]\n+    \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n+\n+    __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n+    \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"The `pydantic-core` `SchemaValidator` used to validate instances of the model.\"\"\"\r\n```",
      "comment_id": 1714821698,
      "user": "Viicos",
      "created_at": "2024-08-13T07:39:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714821698"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10110,
      "file_path": "pydantic/main.py",
      "line": 180,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,58 +106,82 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):\n         __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n     \"\"\"\n \n-    if TYPE_CHECKING:\n-        # Here we provide annotations for the attributes of BaseModel.\n-        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n-        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n-        # of `BaseModel` here:\n+    # Class attributes:\n+    # `model_fields` and `__pydantic_decorators__` must be set for\n+    # `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n \n-        # Class attributes\n-        model_config: ClassVar[ConfigDict]\n-        \"\"\"\n-        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n-        \"\"\"\n+    model_config: ClassVar[ConfigDict] = ConfigDict()\n+    \"\"\"\n+    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n+    \"\"\"\n \n-        model_fields: ClassVar[dict[str, FieldInfo]]\n-        \"\"\"\n-        Metadata about the fields defined on the model,\n-        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n+    # Because `dict` is in the local namespace of the `BaseModel` class, we use `Dict` for annotations.\n+    # TODO v3 fallback to `dict` when the deprecated `dict` method gets removed.\n+    model_fields: ClassVar[Dict[str, FieldInfo]] = {}  # noqa: UP006\n+    \"\"\"\n+    Metadata about the fields defined on the model,\n+    mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n \n-        This replaces `Model.__fields__` from Pydantic V1.\n-        \"\"\"\n+    This replaces `Model.__fields__` from Pydantic V1.\n+    \"\"\"\n \n-        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n-        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n-\n-        __class_vars__: ClassVar[set[str]]\n-        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n-        __signature__: ClassVar[Signature]\n-\n-        __pydantic_complete__: ClassVar[bool]\n-        __pydantic_core_schema__: ClassVar[CoreSchema]\n-        __pydantic_custom_init__: ClassVar[bool]\n-        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n-        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n-        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n-        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n-        __pydantic_root_model__: ClassVar[bool]\n-        __pydantic_serializer__: ClassVar[SchemaSerializer]\n-        __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n-\n-        # Instance attributes\n-        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n-        __pydantic_fields_set__: set[str] = _PrivateAttr()\n-        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n+    model_computed_fields: ClassVar[Dict[str, ComputedFieldInfo]] = {}  # noqa: UP006\n+    \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n \n-    else:\n-        # `model_fields` and `__pydantic_decorators__` must be set for\n-        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n-        model_fields = {}\n-        model_computed_fields = {}\n-\n-        __pydantic_decorators__ = _decorators.DecoratorInfos()\n-        __pydantic_parent_namespace__ = None\n-        # Prevent `BaseModel` from being instantiated directly:\n+    __pydantic_complete__: ClassVar[bool] = False\n+    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n+\n+    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n+    \"\"\"Metadata containing the decorators defined on the model.\n+    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n+\n+    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n+    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n+\n+    __pydantic_root_model__: ClassVar[bool] = False\n+    \"\"\"Whether the model is a `RootModel`.\"\"\"\n+\n+    __class_vars__: ClassVar[set[str]]\n+    \"\"\"The names of classvars defined on the model.\"\"\"\n+\n+    __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]  # noqa: UP006\n+    \"\"\"Metadata about the private attributes of the model.\"\"\"\n+\n+    __signature__: ClassVar[Signature]\n+    \"\"\"The signature for instantiating the model.\"\"\"\n+\n+    __pydantic_core_schema__: ClassVar[CoreSchema]\n+    \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n+\n+    __pydantic_custom_init__: ClassVar[bool]\n+    \"\"\"Whether the model has a custom `__init__` function.\"\"\"\n+\n+    __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n+    \"\"\"Metadata for generic models; contains data used for a similar purpose to\n+    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\"\"\"\n+\n+    __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n+    \"\"\"The name of the post-init method for the model, if defined.\"\"\"\n+\n+    __pydantic_serializer__: ClassVar[SchemaSerializer]\n+    \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n+\n+    __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n+    \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n+\n+    __pydantic_extra__: dict[str, Any] | None = _model_construction.NoInitField(init=False)\n+    \"\"\"An instance attribute with the values of extra fields from validation when\n+    `model_config['extra'] == 'allow'`.\"\"\"\n+\n+    __pydantic_fields_set__: set[str] = _model_construction.NoInitField(init=False)\n+    \"\"\"An instance attribute with the names of fields explicitly set.\"\"\"\n+\n+    __pydantic_private__: dict[str, Any] | None = _model_construction.NoInitField(init=False)\n+    \"\"\"Instance attribute with the values of private attributes set on the model instance.\"\"\"",
      "comment": "I think we don't need to explicitly state they are instance variables, it is inferred by the fact that we don't use a `ClassVar` here:\r\n\r\n```suggestion\r\n    __pydantic_extra__: dict[str, Any] | None = _model_construction.NoInitField(init=False)\r\n    \"\"\"A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra] is set to `'allow'`.\"\"\"\r\n\r\n    __pydantic_fields_set__: set[str] = _model_construction.NoInitField(init=False)\r\n    \"\"\"The names of fields explicitly set during instantiation.\"\"\"\r\n\r\n    __pydantic_private__: dict[str, Any] | None = _model_construction.NoInitField(init=False)\r\n    \"\"\"Values of private attributes set on the model instance.\"\"\"\r\n```",
      "comment_id": 1714825788,
      "user": "Viicos",
      "created_at": "2024-08-13T07:42:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10110#discussion_r1714825788"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10380,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,7 +46,7 @@ def __init__(\n         # TODO: this is a bit of a hack, we should probably have a better way to handle this\n         # specifically, we shouldn't be pumping the namespace full of type_params\n         # when we take namespace and type_params arguments in eval_type_backport\n-        type_params = getattr(schema_type, '__type_params__', ())\n+        type_params = (namespace or {}).get('__type_params__', ()) + getattr(schema_type, '__type_params__', ())",
      "comment": "Seems reasonable enough to me for now, given the big TODO above. ",
      "comment_id": 1757045821,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T14:57:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10380#discussion_r1757045821"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10380,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,7 +46,7 @@ def __init__(\n         # TODO: this is a bit of a hack, we should probably have a better way to handle this\n         # specifically, we shouldn't be pumping the namespace full of type_params\n         # when we take namespace and type_params arguments in eval_type_backport\n-        type_params = getattr(schema_type, '__type_params__', ())\n+        type_params = (namespace or {}).get('__type_params__', ()) + getattr(schema_type, '__type_params__', ())",
      "comment": "I'll note, `GenerateSchema` takes a `typevars_map`. Obviously this isn't yet a map, though.",
      "comment_id": 1757046979,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T14:57:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10380#discussion_r1757046979"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10380,
      "file_path": "tests/test_validate_call.py",
      "line": 853,
      "side": "RIGHT",
      "diff_hunk": "@@ -848,6 +848,82 @@ def find_max_validate_return[T](args: Iterable[T]) -> T:\n             find_max(1)\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_pep695_with_class():\n+    \"\"\"Primarily to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"",
      "comment": "Can you elaborate here, re `NameError` associated with the type var?",
      "comment_id": 1757049132,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T14:59:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/10380#discussion_r1757049132"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10380,
      "file_path": "tests/test_validate_call.py",
      "line": 882,
      "side": "RIGHT",
      "diff_hunk": "@@ -848,6 +848,82 @@ def find_max_validate_return[T](args: Iterable[T]) -> T:\n             find_max(1)\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_pep695_with_class():\n+    \"\"\"Primarily to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n+\n+    for import_annotations in ('from __future__ import annotations', ''):\n+        globs = {}\n+        exec(\n+            f\"\"\"\n+{import_annotations}\n+from pydantic import validate_call\n+\n+class A[T]:\n+    @validate_call(validate_return=True)\n+    def f(self, a: T) -> T:\n+        return str(a)\n+\n+    \"\"\",\n+            globs,\n+        )\n+\n+        A = globs['A']\n+        a = A[int]()\n+        # these two are undesired behavior, but it's what happens now\n+        assert a.f(1) == '1'\n+        assert a.f('1') == '1'\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_pep695_with_nested_scopes():\n+    \"\"\"Nested scopes generally cannot be caught by `parent_frame_namespace`,\n+    so currently this test is expected to fail.\n+    \"\"\"",
      "comment": "Re lack of support here - should we add a `_parent_depth` argument to `validate_call` like we have for `TypeAdapter`? That would add support for this case, I believe.\r\n\r\nShouldn't be addressed in this PR, but just a thought.",
      "comment_id": 1757051194,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T15:00:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10380#discussion_r1757051194"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10380,
      "file_path": "tests/test_validate_call.py",
      "line": 875,
      "side": "RIGHT",
      "diff_hunk": "@@ -848,6 +848,82 @@ def find_max_validate_return[T](args: Iterable[T]) -> T:\n             find_max(1)\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_pep695_with_class():\n+    \"\"\"Primarily to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n+\n+    for import_annotations in ('from __future__ import annotations', ''):\n+        globs = {}\n+        exec(\n+            f\"\"\"\n+{import_annotations}\n+from pydantic import validate_call\n+\n+class A[T]:\n+    @validate_call(validate_return=True)\n+    def f(self, a: T) -> T:\n+        return str(a)\n+\n+    \"\"\",\n+            globs,\n+        )\n+\n+        A = globs['A']\n+        a = A[int]()\n+        # these two are undesired behavior, but it's what happens now\n+        assert a.f(1) == '1'\n+        assert a.f('1') == '1'",
      "comment": "Because with the `validare_return` flag, the returned value should be converted back to `int`. This is equivalent to \r\n```py\r\n@validate_call(validate_return=True)\r\ndef f(x: int)->int:\r\n    return str(x)\r\n\r\nprint(type(f(1)))  # int\r\n```",
      "comment_id": 1757117437,
      "user": "kc0506",
      "created_at": "2024-09-12T15:32:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10380#discussion_r1757117437"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10380,
      "file_path": "tests/test_validate_call.py",
      "line": 882,
      "side": "RIGHT",
      "diff_hunk": "@@ -848,6 +848,82 @@ def find_max_validate_return[T](args: Iterable[T]) -> T:\n             find_max(1)\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_pep695_with_class():\n+    \"\"\"Primarily to ensure that the syntax is accepted and doesn't raise a NameError.\"\"\"\n+\n+    for import_annotations in ('from __future__ import annotations', ''):\n+        globs = {}\n+        exec(\n+            f\"\"\"\n+{import_annotations}\n+from pydantic import validate_call\n+\n+class A[T]:\n+    @validate_call(validate_return=True)\n+    def f(self, a: T) -> T:\n+        return str(a)\n+\n+    \"\"\",\n+            globs,\n+        )\n+\n+        A = globs['A']\n+        a = A[int]()\n+        # these two are undesired behavior, but it's what happens now\n+        assert a.f(1) == '1'\n+        assert a.f('1') == '1'\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_pep695_with_nested_scopes():\n+    \"\"\"Nested scopes generally cannot be caught by `parent_frame_namespace`,\n+    so currently this test is expected to fail.\n+    \"\"\"",
      "comment": "I haven't really seen that module before. I will take a look, thx!",
      "comment_id": 1757122771,
      "user": "kc0506",
      "created_at": "2024-09-12T15:35:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10380#discussion_r1757122771"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10100,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 272,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,6 +243,61 @@ def __getattr__(self, item: str) -> Any:\n                 return private_attributes[item]\n             raise AttributeError(item)\n \n+        def mro(cls):\n+            original_mro = super().mro()\n+\n+            if cls.__bases__ == (object,):\n+                return original_mro\n+\n+            generic_metadata = cls.__dict__.get('__pydantic_generic_metadata__', None)\n+            if not generic_metadata:\n+                return original_mro\n+\n+            origin, args = (\n+                generic_metadata['origin'],\n+                generic_metadata['args'],\n+            )\n+            if not origin:\n+                return original_mro\n+\n+            target_params: tuple[TypeVar] = origin.__pydantic_generic_metadata__['parameters']\n+            param_dict = dict(zip(target_params, args))\n+\n+            # This is necessary otherwise in some case TypeVar may be same:\n+            #\n+            # class A(BaseModel, Generic[T]): ...\n+            # class B(A[int], Generic[T]): ...\n+            # class C(B[str], Generic[T]): ...\n+            #\n+            key = '__pydantic_inserted_mro_origins__'",
      "comment": "This `__pydantic_inserted_mro_origins__` should be added as an annotated attribute on the `BaseModel` class if we are going to use it like this. I think it would also be reasonable to add it as a field in the `__pydantic_generic_metadata__` if that makes sense, but if we are using a new attribute in `BaseModel` it should be added near this area: https://github.com/pydantic/pydantic/blob/ae7770375837020fca5c182acddae8ac66302452/pydantic/main.py#L141",
      "comment_id": 1721798498,
      "user": "dmontagu",
      "created_at": "2024-08-19T13:33:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10100#discussion_r1721798498"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10612,
      "file_path": "tests/mypy/test_mypy.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,52 +48,44 @@\n os.chdir(Path(__file__).parent.parent.parent)\n \n \n-@dataclasses.dataclass\n-class MypyCasesBuilder:\n-    configs: Union[str, List[str]]\n-    modules: Union[str, List[str]]\n-    marks: Any = None\n-\n-    def build(self) -> List[Union[Tuple[str, str], Any]]:\n-        \"\"\"\n-        Produces the cartesian product of the configs and modules, optionally with marks.\n-        \"\"\"\n-        if isinstance(self.configs, str):\n-            self.configs = [self.configs]\n-        if isinstance(self.modules, str):\n-            self.modules = [self.modules]\n-        built_cases = []\n-        for config in self.configs:\n-            for module in self.modules:\n-                built_cases.append((config, module))\n-        if self.marks is not None:\n-            built_cases = [pytest.param(config, module, marks=self.marks) for config, module in built_cases]\n-        return built_cases\n-\n-\n-cases = (\n+# Type hint taken from the signature of `pytest.param`:\n+Marks: TypeAlias = MarkDecorator | Collection[MarkDecorator | Mark]\n+\n+\n+def build_cases(",
      "comment": "Replaces `MypyCasesBuilder` (no need for a class here) and also enforce providing `list[str]` for the arguments, which simplifies the body to a single list comprehension.",
      "comment_id": 1797736005,
      "user": "Viicos",
      "created_at": "2024-10-12T17:25:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10612#discussion_r1797736005"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10612,
      "file_path": "pydantic/version.py",
      "line": 66,
      "side": "LEFT",
      "diff_hunk": "@@ -63,16 +63,16 @@ def version_info() -> str:\n     return '\\n'.join('{:>30} {}'.format(k + ':', str(v).replace('\\n', ' ')) for k, v in info.items())\n \n \n-def parse_mypy_version(version: str) -> tuple[int, ...]:",
      "comment": "Ahhh ok I see I guess it was actually sort of reasonable re new needed ignore comment",
      "comment_id": 1798331906,
      "user": "sydney-runkle",
      "created_at": "2024-10-13T13:18:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10612#discussion_r1798331906"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10612,
      "file_path": "tests/mypy/test_mypy.py",
      "line": 270,
      "side": "RIGHT",
      "diff_hunk": "@@ -237,50 +250,29 @@ def test_bad_toml_config() -> None:\n     assert str(e.value) == 'Configuration value must be a boolean for key: init_forbid_extra'\n \n \n-def get_expected_return_code(source_code: str) -> int:\n-    if re.findall(r'^\\s*# MYPY:', source_code, flags=re.MULTILINE):\n-        return 1\n-    return 0\n-\n-\n @pytest.mark.parametrize('module', ['dataclass_no_any', 'plugin_success', 'plugin_success_baseConfig'])\n @pytest.mark.filterwarnings('ignore:.*is deprecated.*:DeprecationWarning')\n @pytest.mark.filterwarnings('ignore:.*are deprecated.*:DeprecationWarning')\n def test_success_cases_run(module: str) -> None:\n     \"\"\"\n     Ensure the \"success\" files can actually be executed\n     \"\"\"\n-    importlib.import_module(f'tests.mypy.modules.{module}')\n-\n-\n-def test_explicit_reexports():\n-    from pydantic import __all__ as root_all\n-    from pydantic.deprecated.tools import __all__ as tools\n-    from pydantic.main import __all__ as main\n-    from pydantic.networks import __all__ as networks\n-    from pydantic.types import __all__ as types\n-\n-    for name, export_all in [('main', main), ('network', networks), ('tools', tools), ('types', types)]:\n-        for export in export_all:\n-            assert export in root_all, f'{export} is in {name}.__all__ but missing from re-export in __init__.py'\n-\n-\n-def test_explicit_reexports_exist():\n-    import pydantic\n-\n-    for name in pydantic.__all__:\n-        assert hasattr(pydantic, name), f'{name} is in pydantic.__all__ but missing from pydantic'\n+    module_name = f'tests.mypy.modules.{module}'\n+    try:\n+        importlib.import_module(module_name)\n+    except Exception:\n+        pytest.fail(reason=f'Unable to execute module {module_name}')\n \n \n @pytest.mark.parametrize(\n-    'v_str,v_tuple',\n+    ['v_str', 'v_tuple'],\n     [\n         ('0', (0,)),",
      "comment": "Why do we need to test this one? If we don't, we can change the hint below as suggested.",
      "comment_id": 1798338759,
      "user": "sydney-runkle",
      "created_at": "2024-10-13T13:29:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10612#discussion_r1798338759"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10612,
      "file_path": "tests/mypy/test_mypy.py",
      "line": 275,
      "side": "RIGHT",
      "diff_hunk": "@@ -237,50 +250,29 @@ def test_bad_toml_config() -> None:\n     assert str(e.value) == 'Configuration value must be a boolean for key: init_forbid_extra'\n \n \n-def get_expected_return_code(source_code: str) -> int:\n-    if re.findall(r'^\\s*# MYPY:', source_code, flags=re.MULTILINE):\n-        return 1\n-    return 0\n-\n-\n @pytest.mark.parametrize('module', ['dataclass_no_any', 'plugin_success', 'plugin_success_baseConfig'])\n @pytest.mark.filterwarnings('ignore:.*is deprecated.*:DeprecationWarning')\n @pytest.mark.filterwarnings('ignore:.*are deprecated.*:DeprecationWarning')\n def test_success_cases_run(module: str) -> None:\n     \"\"\"\n     Ensure the \"success\" files can actually be executed\n     \"\"\"\n-    importlib.import_module(f'tests.mypy.modules.{module}')\n-\n-\n-def test_explicit_reexports():\n-    from pydantic import __all__ as root_all\n-    from pydantic.deprecated.tools import __all__ as tools\n-    from pydantic.main import __all__ as main\n-    from pydantic.networks import __all__ as networks\n-    from pydantic.types import __all__ as types\n-\n-    for name, export_all in [('main', main), ('network', networks), ('tools', tools), ('types', types)]:\n-        for export in export_all:\n-            assert export in root_all, f'{export} is in {name}.__all__ but missing from re-export in __init__.py'\n-\n-\n-def test_explicit_reexports_exist():\n-    import pydantic\n-\n-    for name in pydantic.__all__:\n-        assert hasattr(pydantic, name), f'{name} is in pydantic.__all__ but missing from pydantic'\n+    module_name = f'tests.mypy.modules.{module}'\n+    try:\n+        importlib.import_module(module_name)\n+    except Exception:\n+        pytest.fail(reason=f'Unable to execute module {module_name}')\n \n \n @pytest.mark.parametrize(\n-    'v_str,v_tuple',\n+    ['v_str', 'v_tuple'],\n     [\n         ('0', (0,)),\n-        ('0.930', (0, 930)),\n-        ('0.940+dev.04cac4b5d911c4f9529e6ce86a27b44f28846f5d.dirty', (0, 940)),\n+        ('1.11.0', (1, 11, 0)),\n+        ('1.11.0+dev.d6d9d8cd4f27c52edac1f537e236ec48a01e54cb.dirty', (1, 11, 0)),\n     ],\n )\n-def test_parse_mypy_version(v_str, v_tuple):\n+def test_parse_mypy_version(v_str: str, v_tuple: tuple[int, ...]) -> None:",
      "comment": "```suggestion\r\ndef test_parse_mypy_version(v_str: str, v_tuple: tuple[int, int, int]) -> None:\r\n```",
      "comment_id": 1798338832,
      "user": "sydney-runkle",
      "created_at": "2024-10-13T13:30:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/10612#discussion_r1798338832"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10602,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 407,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,3 +307,115 @@ class PydanticTypeModel(DeferredModel):\n         field: field_type\n \n     benchmark(rebuild_model, PydanticTypeModel)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_simple_recursive_model_schema_generation(benchmark):\n+    class Foo(DeferredModel):\n+        a: int = 123\n+        sibling: 'Foo' = None\n+\n+    benchmark(rebuild_model, Foo)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_generic_recursive_model_schema_generation(benchmark):\n+    T = TypeVar('T')\n+\n+    class GenericFoo(DeferredModel, Generic[T]):\n+        value: T\n+        sibling: Optional['GenericFoo[T]'] = None\n+\n+    benchmark(rebuild_model, GenericFoo[int])\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_nested_recursive_model_schema_generation(benchmark):\n+    class Node(DeferredModel):\n+        value: int\n+        left: Optional['Node'] = None\n+        right: Optional['Node'] = None\n+\n+    class Tree(DeferredModel):\n+        root: Node\n+        metadata: Dict[str, 'Tree'] = Field(default_factory=dict)\n+\n+    benchmark(rebuild_model, Tree)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_nested_recursive_generic_model_schema_generation(benchmark):\n+    T = TypeVar('T')\n+\n+    class GenericNode(DeferredModel, Generic[T]):\n+        value: T\n+        left: Optional['GenericNode[T]'] = None\n+        right: Optional['GenericNode[T]'] = None\n+\n+    class GenericTree(DeferredModel, Generic[T]):\n+        root: GenericNode[T]\n+        metadata: Dict[str, 'GenericTree[T]'] = Field(default_factory=dict)\n+\n+    benchmark(rebuild_model, GenericTree[int])\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_recursive_discriminated_union_with_base_model(benchmark) -> None:\n+    class Foo(DeferredModel):\n+        type: Literal['foo']\n+        x: 'Foobar'\n+\n+    class Bar(DeferredModel):\n+        type: Literal['bar']\n+\n+    class Foobar(DeferredModel):\n+        value: Union[Foo, Bar] = Field(discriminator='type')\n+\n+    benchmark(rebuild_model, Foobar)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_recursive_discriminated_union_with_typed_dict(benchmark) -> None:\n+    class Foo(TypedDict):\n+        type: Literal['foo']\n+        x: 'Foobar'\n+\n+    class Bar(TypedDict):\n+        type: Literal['bar']\n+\n+    class Foobar(DeferredModel):\n+        value: Union[Foo, Bar] = Field(discriminator='type')\n+\n+    benchmark(rebuild_model, Foobar)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_recursive_discriminated_union_with_pydantic_dataclass(benchmark) -> None:\n+    @dataclass\n+    class Foo:\n+        type: Literal['foo']\n+        x: 'Foobar'\n+\n+    @dataclass\n+    class Bar:\n+        type: Literal['bar']\n+\n+    @dataclass(frozen=True, kw_only=True, config={'defer_build': True})\n+    class Foobar:\n+        value: Union[Foo, Bar] = Field(discriminator='type')\n+\n+    benchmark(lambda: rebuild_dataclass(Foobar, force=True, _types_namespace={}))",
      "comment": "I think we can remove these ones, I don't expect any schema generation changes with Pydantic models",
      "comment_id": 1796787084,
      "user": "Viicos",
      "created_at": "2024-10-11T10:53:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10602#discussion_r1796787084"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10602,
      "file_path": "tests/benchmarks/shared.py",
      "line": 241,
      "side": "RIGHT",
      "diff_hunk": "@@ -231,3 +231,11 @@ class Foo:\n     FutureDate,\n     PastDatetime,\n ]\n+\n+\n+class DeferredModel(BaseModel):\n+    model_config = {'defer_build': True}\n+\n+\n+def rebuild_model(model: Type[BaseModel]) -> None:\n+    model.model_rebuild(force=True, _types_namespace={})",
      "comment": "This is fine bc it's working now, but if we do more complex model rebuilding, we might need to remove this types namespace specification.",
      "comment_id": 1798357654,
      "user": "sydney-runkle",
      "created_at": "2024-10-13T14:02:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10602#discussion_r1798357654"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10584,
      "file_path": "pydantic/types.py",
      "line": 2596,
      "side": "RIGHT",
      "diff_hunk": "@@ -2580,7 +2593,7 @@ def decode_str(self, data: bytes, _: core_schema.ValidationInfo) -> str:\n         Returns:\n             The decoded data.\n         \"\"\"\n-        return data.decode()\n+        return self.encoder.decode(data.encode()).decode()",
      "comment": "So that I understand the intent here - we validate a `str`, then `encode` -> `bytes`, `decode` with our `encoder`, then `decode` back to a `str`? \ud83e\udd2e ",
      "comment_id": 1794159903,
      "user": "sydney-runkle",
      "created_at": "2024-10-09T20:04:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10584#discussion_r1794159903"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10584,
      "file_path": "pydantic/types.py",
      "line": 2596,
      "side": "RIGHT",
      "diff_hunk": "@@ -2580,7 +2593,7 @@ def decode_str(self, data: bytes, _: core_schema.ValidationInfo) -> str:\n         Returns:\n             The decoded data.\n         \"\"\"\n-        return data.decode()\n+        return self.encoder.decode(data.encode()).decode()",
      "comment": "yeah, since the encoder operates on bytes I think you need to do this if you want to apply it to strings",
      "comment_id": 1797039471,
      "user": "dmontagu",
      "created_at": "2024-10-11T14:26:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/10584#discussion_r1797039471"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10601,
      "file_path": "pydantic/networks.py",
      "line": 725,
      "side": "RIGHT",
      "diff_hunk": "@@ -722,7 +722,7 @@ def _build_pretty_email_regex() -> re.Pattern[str]:\n     name_chars = r'[\\w!#$%&\\'*+\\-/=?^_`{|}~]'\n     unquoted_name_group = rf'((?:{name_chars}+\\s+)*{name_chars}+)'\n     quoted_name_group = r'\"((?:[^\"]|\\\")+)\"'\n-    email_group = r'<\\s*(.+)\\s*>'\n+    email_group = r'<\\s*(.+)>'",
      "comment": "```suggestion\r\n    email_group = r'<(.+)>'\r\n```\r\n\r\nThe `.strip()` call also removes leading whitespaces.",
      "comment_id": 1796805051,
      "user": "Viicos",
      "created_at": "2024-10-11T11:11:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10601#discussion_r1796805051"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]",
      "comment": "Nice - `TypeAlias`es are a great idea here, as the typing around evals is a bit confusing if you don't do a deep dive.",
      "comment_id": 1786399984,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:03:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786399984"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).",
      "comment": "```suggestion\r\nor the [`f_locals`][frame.f_locals] attribute of a frame object, when assessing the namespace of a function).\r\n```\r\n\r\nDoesn't have to be exactly this, but let's mention the context of a function here.",
      "comment_id": 1786402594,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:05:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786402594"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.",
      "comment": "```suggestion\r\n    Caution: this function does not return a copy of the module namespace, so the result should not be mutated.\r\n```",
      "comment_id": 1786405666,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:07:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786405666"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)",
      "comment": "Should `parent_namespace` take priority here? Seems like it would given that we append it to the list?",
      "comment_id": 1786409041,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:09:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786409041"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)\n+\n+    global_ns = get_module_ns_of(obj)\n+\n+    if isinstance(obj, type):\n+        locals_list.extend(\n+            [\n+                vars(obj),  # i.e. `obj.__dict__`\n+                {obj.__name__: obj},",
      "comment": "Nice, I like that we're not mutating the result directly here. Great cleanup.",
      "comment_id": 1786409688,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:10:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786409688"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:",
      "comment": "So given that this is so similar to the below `NsResolver.types_namespace` logic in some ways, I wonder if it makes sense to:\r\n\r\n* Extrapolate the shared logic for building a local namespace associated with a `type`\r\n* Add a new function that supports the `function` branch here\r\n* Use the shared logic in both places (as in, in `ns_from` as well as `NsResolver.types_namespace`), and also the logic for functions here\r\n\r\nThis idea may be an oversight, though. I see that we add the `parent_namespace` before in this function, and the `override_ns` afterwards in the `NsResolver` context, so perhaps consolidating isn't the right approach here.\r\n\r\nI will say that I think the current logic is clean and well documented, so I'm not opposed to keeping this as is, just wanted us to think about the potential benefits of another structure.",
      "comment_id": 1786416377,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:14:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786416377"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)\n+\n+    global_ns = get_module_ns_of(obj)\n+\n+    if isinstance(obj, type):\n+        locals_list.extend(\n+            [\n+                vars(obj),  # i.e. `obj.__dict__`\n+                {obj.__name__: obj},\n+            ]\n+        )\n+    else:\n+        # For functions, get the `__type_params__` attribute introduced by PEP 695.\n+        # Note that the typing `_eval_type` function expects type params to be\n+        # passed as a separate argument. However, internally, `_eval_type` calls\n+        # `ForwardRef._evaluate` which will merge type params with the localns,\n+        # essentially mimicing what we do here.\n+        type_params: tuple[TypeVar, ...] = ()\n+        if parent_namespace is not None:\n+            # We also fetch type params from the parent namespace. If present, it probably\n+            # means the function was defined in a class. This is to support the following:\n+            # https://github.com/python/cpython/issues/124089.\n+            type_params += parent_namespace.get('__type_params__', ())\n+        type_params += getattr(obj, '__type_params__', ())\n+        locals_list.append({t.__name__: t for t in type_params})\n+\n+    return NamespacesTuple(global_ns, LazyLocalNamespace(*locals_list))\n+\n+\n+class NsResolver:\n+    \"\"\"A class holding the logic to resolve namespaces for annotations evaluation in the context\n+    of core schema generation.\n+\n+    This class handles the namespace logic when evaluating annotations that failed to\n+    resolve during the initial inspection/building of the Pydantic model, dataclass, etc.\n+\n+    It holds a stack of classes that are being inspected during the core schema building,\n+    and the `types_namespace` property exposes the globals and locals to be used for\n+    type annotation evaluation. Additionally -- if no class is present in the stack -- a\n+    fallback globals and locals can be provided with the `namespaces_tuple` argument.\n+\n+    This is only meant to be used alongside with the `GenerateSchema` class.\n+\n+    Args:\n+        namespaces_tuple: The default globals and locals to used if no class is present\n+            on the stack. This can be useful when using the `GenerateSchema` class\n+            with `TypeAdapter`, where the \"type\" being analyzed is a simple annotation.\n+        fallback_namespace: A namespace to use as a last resort if a name wasn't found\n+            in the locals nor the globals. This is mainly used when rebuilding a core\n+            schema for a Pydantic model or dataclass, where the parent namespace is used.\n+        override_namespace: A namespace to use first when resolving forward annotations.\n+            This is mainly used when rebuilding a core schema for a Pydantic model or\n+            dataclass, where an explicit namespace can be provided to resolve annotations\n+            that failed to resolve during the initial schema building.",
      "comment": "Worth saying again - this documentation is \ud83c\udf1f awesome. So helpful to have all of the complexities and edge cases explained here.",
      "comment_id": 1786426037,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:21:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786426037"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 260,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)\n+\n+    global_ns = get_module_ns_of(obj)\n+\n+    if isinstance(obj, type):\n+        locals_list.extend(\n+            [\n+                vars(obj),  # i.e. `obj.__dict__`\n+                {obj.__name__: obj},\n+            ]\n+        )\n+    else:\n+        # For functions, get the `__type_params__` attribute introduced by PEP 695.\n+        # Note that the typing `_eval_type` function expects type params to be\n+        # passed as a separate argument. However, internally, `_eval_type` calls\n+        # `ForwardRef._evaluate` which will merge type params with the localns,\n+        # essentially mimicing what we do here.\n+        type_params: tuple[TypeVar, ...] = ()\n+        if parent_namespace is not None:\n+            # We also fetch type params from the parent namespace. If present, it probably\n+            # means the function was defined in a class. This is to support the following:\n+            # https://github.com/python/cpython/issues/124089.\n+            type_params += parent_namespace.get('__type_params__', ())\n+        type_params += getattr(obj, '__type_params__', ())\n+        locals_list.append({t.__name__: t for t in type_params})\n+\n+    return NamespacesTuple(global_ns, LazyLocalNamespace(*locals_list))\n+\n+\n+class NsResolver:\n+    \"\"\"A class holding the logic to resolve namespaces for annotations evaluation in the context\n+    of core schema generation.\n+\n+    This class handles the namespace logic when evaluating annotations that failed to\n+    resolve during the initial inspection/building of the Pydantic model, dataclass, etc.\n+\n+    It holds a stack of classes that are being inspected during the core schema building,\n+    and the `types_namespace` property exposes the globals and locals to be used for\n+    type annotation evaluation. Additionally -- if no class is present in the stack -- a\n+    fallback globals and locals can be provided with the `namespaces_tuple` argument.\n+\n+    This is only meant to be used alongside with the `GenerateSchema` class.\n+\n+    Args:\n+        namespaces_tuple: The default globals and locals to used if no class is present\n+            on the stack. This can be useful when using the `GenerateSchema` class\n+            with `TypeAdapter`, where the \"type\" being analyzed is a simple annotation.\n+        fallback_namespace: A namespace to use as a last resort if a name wasn't found\n+            in the locals nor the globals. This is mainly used when rebuilding a core\n+            schema for a Pydantic model or dataclass, where the parent namespace is used.\n+        override_namespace: A namespace to use first when resolving forward annotations.\n+            This is mainly used when rebuilding a core schema for a Pydantic model or\n+            dataclass, where an explicit namespace can be provided to resolve annotations\n+            that failed to resolve during the initial schema building.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns_resolver = NsResolver(\n+            namespaces_tuple=NamespacesTuple({'my_global': 1}, {}),\n+            fallback_namespace={'fallback': 2, 'my_global': 3},\n+        )\n+\n+        ns_resolver.types_namespace\n+        #> NamespacesTuple({'my_global': 1}, {})\n+\n+\n+        class MyType:\n+            some_local = 4\n+\n+\n+        with ns_resolver.push(MyType):\n+            ns_resolver.types_namespace\n+            #> NamespacesTuple({'my_global': 1, 'fallback': 2}, {'some_local': 4})\n+        ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        namespaces_tuple: NamespacesTuple | None = None,\n+        fallback_namespace: MappingNamespace | None = None,\n+        override_namespace: MappingNamespace | None = None,\n+    ) -> None:\n+        self._base_ns_tuple = namespaces_tuple or NamespacesTuple({}, {})\n+        self._fallback_ns = fallback_namespace\n+        self._override_ns = override_namespace\n+        self._types_stack: list[type[Any]] = []\n+\n+    @cached_property\n+    def types_namespace(self) -> NamespacesTuple:\n+        \"\"\"The current global and local namespaces to be used for annotations evaluation.\"\"\"\n+        if not self._types_stack:\n+            # TODO do we want to merge fallback and override ns here?\n+            return self._base_ns_tuple\n+\n+        typ = self._types_stack[-1]\n+\n+        globalns = get_module_ns_of(typ)\n+        # TODO check len(self._types_stack) == 1? As we specified,\n+        # fallback_namespace should only be used for the class being rebuilt.\n+        # However, it might be good to keep this for now to avoid having too\n+        # many breaking changes.\n+        if self._fallback_ns is not None:\n+            globalns = {**self._fallback_ns, **globalns}\n+\n+        locals_list: list[MappingNamespace] = [vars(typ), {typ.__name__: typ}]\n+        if self._override_ns is not None:\n+            locals_list.append(self._override_ns)\n+\n+        return NamespacesTuple(globalns, LazyLocalNamespace(*locals_list))\n+\n+    @contextmanager\n+    def push(self, typ: type[Any], /) -> Generator[None]:\n+        \"\"\"Push a type to the stack.\"\"\"\n+        self._types_stack.append(typ)\n+        # Reset the cached property:\n+        self.__dict__.pop('types_namespace', None)",
      "comment": "Is it even worth having this cached then? Are there cases where we'd access it lots of times over before pushing a new type?",
      "comment_id": 1786427762,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:22:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786427762"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "tests/test_forward_ref.py",
      "line": 1178,
      "side": "RIGHT",
      "diff_hunk": "@@ -1130,3 +1130,183 @@ class Foo(BaseModel):\n     ]\n \n     assert extras_schema == {'type': 'int'}\n+\n+\n+@pytest.mark.xfail('get_cls_type_hints_lenient does not fetch the module ns for each base')\n+def test_tmp_1(create_module):\n+    @create_module\n+    def module_1():\n+        from pydantic import BaseModel\n+\n+        class Bar(BaseModel):\n+            f: 'A'\n+\n+        A = int\n+\n+    module_2 = create_module(\n+        f\"\"\"\n+from {module_1.__name__} import Bar\n+\n+A = str\n+\n+class Foo(Bar):\n+    pass\n+        \"\"\"\n+    )\n+\n+    assert module_2.Foo.model_fields['f'].annotation is int\n+\n+\n+@pytest.mark.xfail(reason='We should keep a reference to the parent frame, not f_locals')\n+def test_tmp_2():\n+    def func():\n+        class Model(BaseModel):\n+            a: 'A'\n+\n+        class A(BaseModel):\n+            pass\n+\n+        return Model\n+\n+    Model = func()\n+\n+    Model.model_rebuild()\n+\n+\n+@pytest.mark.xfail(reason='TypesNamespaceStack wrongfully merges tail')\n+def test_tmp_3(create_module):\n+    @create_module",
      "comment": "Great to have these problems documented with xfail tests.\r\n\r\nThis, imo, is the highest priority for something we want to fix.\r\n\r\nI know you wrote up a gist talking about some of these issues - could we add an update discussing the things that are still lingering TODOs after this PR is merged?",
      "comment_id": 1786433846,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:26:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786433846"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 256,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,22 +243,27 @@ def merge_cls_and_parent_ns(cls: type[Any], parent_namespace: dict[str, Any] | N\n     return ns\n \n \n-def get_cls_type_hints_lenient(obj: Any, globalns: dict[str, Any] | None = None) -> dict[str, Any]:\n+def get_cls_type_hints_lenient(obj: Any, parent_namespace: MappingNamespace | None = None) -> dict[str, Any]:\n     \"\"\"Collect annotations from a class, including those from parent classes.\n \n     Unlike `typing.get_type_hints`, this function will not error if a forward reference is not resolvable.\n     \"\"\"\n     hints = {}\n     for base in reversed(obj.__mro__):\n         ann = base.__dict__.get('__annotations__')\n-        localns = dict(vars(base))\n+        # TODO: to be more correct, we might want to only pass `parent_namespace`\n+        # when `base is obj`, because the other bases might be defined in a different\n+        # context (i.e. not in the same frame):",
      "comment": "If we make this change now, do any additional tests break? I'd be keen to make this change, and let's add a comment above with an explanation as well \ud83d\udc4d ",
      "comment_id": 1786437356,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:29:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786437356"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 15,
      "side": "LEFT",
      "diff_hunk": "@@ -12,7 +12,7 @@\n import sys\n import typing\n import warnings\n-from contextlib import ExitStack, contextmanager",
      "comment": "Same with `TypesNamespaceStack` below - nice work \u2705 ",
      "comment_id": 1786444960,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:33:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786444960"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 676,
      "side": "RIGHT",
      "diff_hunk": "@@ -696,7 +673,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                                     _typing_extra._make_forward_ref(\n                                         extras_annotation, is_argument=False, is_class=True\n                                     ),\n-                                    self._types_namespace,\n+                                    *self._types_namespace,",
      "comment": "Maybe we could explicitly have `globalns=self._types_namespace.globalns, localns=self._types_namespace.localns` just for clarity here",
      "comment_id": 1786447605,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:34:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786447605"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1249,
      "side": "RIGHT",
      "diff_hunk": "@@ -1267,15 +1244,11 @@ def _common_field_schema(  # C901\n     ) -> _CommonField:\n         # Update FieldInfo annotation if appropriate:\n         FieldInfo = import_cached_field_info()\n-\n         if has_instance_in_type(field_info.annotation, (ForwardRef, str)):\n-            types_namespace = self._types_namespace\n-            if self._typevars_map:\n-                types_namespace = (types_namespace or {}).copy()\n-                # Ensure that typevars get mapped to their concrete types:\n-                types_namespace.update({k.__name__: v for k, v in self._typevars_map.items()})\n \n-            evaluated = _typing_extra.eval_type_lenient(field_info.annotation, types_namespace)\n+            # Can we use field_info.apply_typevars_map here? Shouldn't we error if we encounter name errors here?",
      "comment": "```suggestion\r\n            # TODO: Can we use field_info.apply_typevars_map here? Shouldn't we error if we encounter name errors here?\r\n```",
      "comment_id": 1786449006,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:35:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786449006"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1525,
      "side": "RIGHT",
      "diff_hunk": "@@ -1548,8 +1521,8 @@ def _namedtuple_schema(self, namedtuple_cls: Any, origin: Any) -> core_schema.Co\n             if origin is not None:\n                 namedtuple_cls = origin\n \n-            with self._types_namespace_stack.push(namedtuple_cls):\n-                annotations: dict[str, Any] = get_cls_type_hints_lenient(namedtuple_cls, self._types_namespace)\n+            with self._ns_resolver.push(namedtuple_cls):\n+                annotations: dict[str, Any] = get_cls_type_hints_lenient(namedtuple_cls)",
      "comment": "Why no more args here from `self._types_namespace` (and same for above)?",
      "comment_id": 1786450889,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:37:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786450889"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 676,
      "side": "RIGHT",
      "diff_hunk": "@@ -696,7 +673,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                                     _typing_extra._make_forward_ref(\n                                         extras_annotation, is_argument=False, is_class=True\n                                     ),\n-                                    self._types_namespace,\n+                                    *self._types_namespace,",
      "comment": "There are a few other instances of this below - same suggestion applies \ud83d\udc4d ",
      "comment_id": 1786453073,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:38:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786453073"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/main.py",
      "line": 585,
      "side": "LEFT",
      "diff_hunk": "@@ -564,38 +565,32 @@ def model_rebuild(\n         \"\"\"\n         if not force and cls.__pydantic_complete__:\n             return None\n-        else:\n-            if '__pydantic_core_schema__' in cls.__dict__:\n-                delattr(cls, '__pydantic_core_schema__')  # delete cached value to ensure full rebuild happens\n-            if _types_namespace is not None:\n-                types_namespace: dict[str, Any] | None = _types_namespace.copy()\n-            else:\n-                if _parent_namespace_depth > 0:\n-                    frame_parent_ns = (\n-                        _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n-                    )\n-                    cls_parent_ns = (\n-                        _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n-                    )\n-                    types_namespace = {**cls_parent_ns, **frame_parent_ns}\n-                    cls.__pydantic_parent_namespace__ = _model_construction.build_lenient_weakvaluedict(types_namespace)\n-                else:\n-                    types_namespace = _model_construction.unpack_lenient_weakvaluedict(\n-                        cls.__pydantic_parent_namespace__\n-                    )",
      "comment": "I'm a bit worried about the removal of this logic - perhaps I've missed it elsewhere, but where are we handling the potential unpacking of the cached namespace on the model?",
      "comment_id": 1786460975,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:44:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786460975"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_dataclasses.py",
      "line": 139,
      "side": "LEFT",
      "diff_hunk": "@@ -135,16 +146,13 @@ def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -\n             'Support for `__post_init_post_parse__` has been dropped, the method will not be called', DeprecationWarning\n         )\n \n-    if types_namespace is None:\n-        types_namespace = _typing_extra.merge_cls_and_parent_ns(cls)",
      "comment": "Seems like this was poorly designed (by me, I think). I agree with the removal of this, but are we compensating accordingly - as in, not dropping any of this information? Seems like the `parent_namespace` isn't added to the `ns_resolver` as the `fallback_namespace` at all?",
      "comment_id": 1786468015,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:49:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786468015"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_dataclasses.py",
      "line": 139,
      "side": "LEFT",
      "diff_hunk": "@@ -135,16 +146,13 @@ def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -\n             'Support for `__post_init_post_parse__` has been dropped, the method will not be called', DeprecationWarning\n         )\n \n-    if types_namespace is None:\n-        types_namespace = _typing_extra.merge_cls_and_parent_ns(cls)",
      "comment": "Maybe this is fine bc it was only needed for the `set_dataclass_fields`...",
      "comment_id": 1786470678,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:51:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786470678"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 54,
      "side": "LEFT",
      "diff_hunk": "@@ -42,18 +43,10 @@ def __init__(\n             self.__qualname__ = function.__qualname__\n             self.__module__ = function.__module__\n \n-        global_ns = _typing_extra.get_module_ns_of(function)\n-        # TODO: this is a bit of a hack, we should probably have a better way to handle this\n-        # specifically, we shouldn't be pumping the namespace full of type_params\n-        # when we take namespace and type_params arguments in eval_type_backport\n-        type_params = (namespace or {}).get('__type_params__', ()) + getattr(schema_type, '__type_params__', ())\n-        namespace = {\n-            **{param.__name__: param for param in type_params},\n-            **(global_ns or {}),\n-            **(namespace or {}),\n-        }",
      "comment": "Another thing I'm perhaps missing - where did we move the more intuitive `__type_params__` parsing logic to?\r\n\r\nThis simplification looks great, assuming all is handled correctly on the type params front.",
      "comment_id": 1786473269,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:53:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786473269"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/type_adapter.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -87,9 +88,12 @@ def _get_schema(type_: Any, config_wrapper: _config.ConfigWrapper, parent_depth:\n     But at the very least this behavior is _subtly_ different from `BaseModel`'s.\n     \"\"\"\n     local_ns = _typing_extra.parent_frame_namespace(parent_depth=parent_depth)\n-    global_ns = sys._getframe(max(parent_depth - 1, 1)).f_globals.copy()\n-    global_ns.update(local_ns or {})\n-    gen = _generate_schema.GenerateSchema(config_wrapper, types_namespace=global_ns, typevars_map={})\n+    global_ns = sys._getframe(max(parent_depth - 1, 1)).f_globals",
      "comment": "Small nit - our `eval` functions take `globalns` and `localns` as arguments. Throughout our namespace management, perhaps we should standardize to these rather than `globalns`?",
      "comment_id": 1786476138,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:55:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786476138"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/dataclasses.py",
      "line": 275,
      "side": "RIGHT",
      "diff_hunk": "@@ -269,7 +270,9 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         cls.__module__ = original_cls.__module__\n         cls.__qualname__ = original_cls.__qualname__\n         cls.__pydantic_complete__ = False  # `complete_dataclass` will set it to `True` if successful.\n-        _pydantic_dataclasses.complete_dataclass(cls, config_wrapper, raise_errors=False, types_namespace=None)\n+        # TODO parent_namespace is currently None, but we could do the same thing as Pydantic models,\n+        # even if we don't save it under an attribute for reuse:\n+        _pydantic_dataclasses.complete_dataclass(cls, config_wrapper, raise_errors=False, parent_namespace=None)",
      "comment": "Maybe elaborate a tiny bit here - \"do the same thing\" as in, cache a localns to support model rebuilds down the line, if I'm understanding correctly?",
      "comment_id": 1786478641,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:57:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786478641"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/dataclasses.py",
      "line": 336,
      "side": "LEFT",
      "diff_hunk": "@@ -319,33 +322,34 @@ def rebuild_dataclass(\n     \"\"\"\n     if not force and cls.__pydantic_complete__:\n         return None\n-    else:\n-        if '__pydantic_core_schema__' in cls.__dict__:\n-            delattr(cls, '__pydantic_core_schema__')  # delete cached value to ensure full rebuild happens\n-        if _types_namespace is not None:\n-            types_namespace: dict[str, Any] | None = _types_namespace.copy()\n-        else:\n-            if _parent_namespace_depth > 0:\n-                frame_parent_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth) or {}\n-                # Note: we may need to add something similar to cls.__pydantic_parent_namespace__ from BaseModel\n-                #   here when implementing handling of recursive generics. See BaseModel.model_rebuild for reference.\n-                types_namespace = frame_parent_ns\n-            else:\n-                types_namespace = {}\n-\n-            types_namespace = _typing_extra.merge_cls_and_parent_ns(cls, types_namespace)",
      "comment": "So I'm less worried about this transformation (compared to the `model_rebuild`) because we don't yet support the `__pydantic_parent_namespace__` stuff.",
      "comment_id": 1786480461,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T15:59:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786480461"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]",
      "comment": "Do not hesitate if you have better ideas regarding naming. I first went with `GlobalsNamespace` and `LocalsNamespace`, but the latter was changed to `MappingNamespace` as I needed a type annotation for the fallback namespace, which can be the module globals as well (and this works because a module's `__dict__` is `dict[str, Any]`, assignable to `Mapping[str, Any]`).",
      "comment_id": 1786651878,
      "user": "Viicos",
      "created_at": "2024-10-03T18:03:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786651878"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:",
      "comment": "I went with `data` to be in line with stdlib's [`UserDict`](https://docs.python.org/3/library/collections.html#collections.UserDict), but I'm ok to change. `LazyLocalNamespace` is kind of an implementation detail anyway, I even thought about making this a private attribute.",
      "comment_id": 1786657972,
      "user": "Viicos",
      "created_at": "2024-10-03T18:09:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786657972"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)",
      "comment": "`LazyLocalNamespace` takes a list of namespaces in ascending order of priority, but it can be confusing. I think I'm going to change the order here.",
      "comment_id": 1786659398,
      "user": "Viicos",
      "created_at": "2024-10-03T18:10:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786659398"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:",
      "comment": "Yeah I've tried having the logic shared between those two but seems like there are two many edge cases. However, I think we can share the logic to build a local namespace for a given `type`. ",
      "comment_id": 1786662042,
      "user": "Viicos",
      "created_at": "2024-10-03T18:13:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786662042"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 260,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)\n+\n+    global_ns = get_module_ns_of(obj)\n+\n+    if isinstance(obj, type):\n+        locals_list.extend(\n+            [\n+                vars(obj),  # i.e. `obj.__dict__`\n+                {obj.__name__: obj},\n+            ]\n+        )\n+    else:\n+        # For functions, get the `__type_params__` attribute introduced by PEP 695.\n+        # Note that the typing `_eval_type` function expects type params to be\n+        # passed as a separate argument. However, internally, `_eval_type` calls\n+        # `ForwardRef._evaluate` which will merge type params with the localns,\n+        # essentially mimicing what we do here.\n+        type_params: tuple[TypeVar, ...] = ()\n+        if parent_namespace is not None:\n+            # We also fetch type params from the parent namespace. If present, it probably\n+            # means the function was defined in a class. This is to support the following:\n+            # https://github.com/python/cpython/issues/124089.\n+            type_params += parent_namespace.get('__type_params__', ())\n+        type_params += getattr(obj, '__type_params__', ())\n+        locals_list.append({t.__name__: t for t in type_params})\n+\n+    return NamespacesTuple(global_ns, LazyLocalNamespace(*locals_list))\n+\n+\n+class NsResolver:\n+    \"\"\"A class holding the logic to resolve namespaces for annotations evaluation in the context\n+    of core schema generation.\n+\n+    This class handles the namespace logic when evaluating annotations that failed to\n+    resolve during the initial inspection/building of the Pydantic model, dataclass, etc.\n+\n+    It holds a stack of classes that are being inspected during the core schema building,\n+    and the `types_namespace` property exposes the globals and locals to be used for\n+    type annotation evaluation. Additionally -- if no class is present in the stack -- a\n+    fallback globals and locals can be provided with the `namespaces_tuple` argument.\n+\n+    This is only meant to be used alongside with the `GenerateSchema` class.\n+\n+    Args:\n+        namespaces_tuple: The default globals and locals to used if no class is present\n+            on the stack. This can be useful when using the `GenerateSchema` class\n+            with `TypeAdapter`, where the \"type\" being analyzed is a simple annotation.\n+        fallback_namespace: A namespace to use as a last resort if a name wasn't found\n+            in the locals nor the globals. This is mainly used when rebuilding a core\n+            schema for a Pydantic model or dataclass, where the parent namespace is used.\n+        override_namespace: A namespace to use first when resolving forward annotations.\n+            This is mainly used when rebuilding a core schema for a Pydantic model or\n+            dataclass, where an explicit namespace can be provided to resolve annotations\n+            that failed to resolve during the initial schema building.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns_resolver = NsResolver(\n+            namespaces_tuple=NamespacesTuple({'my_global': 1}, {}),\n+            fallback_namespace={'fallback': 2, 'my_global': 3},\n+        )\n+\n+        ns_resolver.types_namespace\n+        #> NamespacesTuple({'my_global': 1}, {})\n+\n+\n+        class MyType:\n+            some_local = 4\n+\n+\n+        with ns_resolver.push(MyType):\n+            ns_resolver.types_namespace\n+            #> NamespacesTuple({'my_global': 1, 'fallback': 2}, {'some_local': 4})\n+        ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        namespaces_tuple: NamespacesTuple | None = None,\n+        fallback_namespace: MappingNamespace | None = None,\n+        override_namespace: MappingNamespace | None = None,\n+    ) -> None:\n+        self._base_ns_tuple = namespaces_tuple or NamespacesTuple({}, {})\n+        self._fallback_ns = fallback_namespace\n+        self._override_ns = override_namespace\n+        self._types_stack: list[type[Any]] = []\n+\n+    @cached_property\n+    def types_namespace(self) -> NamespacesTuple:\n+        \"\"\"The current global and local namespaces to be used for annotations evaluation.\"\"\"\n+        if not self._types_stack:\n+            # TODO do we want to merge fallback and override ns here?\n+            return self._base_ns_tuple\n+\n+        typ = self._types_stack[-1]\n+\n+        globalns = get_module_ns_of(typ)\n+        # TODO check len(self._types_stack) == 1? As we specified,\n+        # fallback_namespace should only be used for the class being rebuilt.\n+        # However, it might be good to keep this for now to avoid having too\n+        # many breaking changes.\n+        if self._fallback_ns is not None:\n+            globalns = {**self._fallback_ns, **globalns}\n+\n+        locals_list: list[MappingNamespace] = [vars(typ), {typ.__name__: typ}]\n+        if self._override_ns is not None:\n+            locals_list.append(self._override_ns)\n+\n+        return NamespacesTuple(globalns, LazyLocalNamespace(*locals_list))\n+\n+    @contextmanager\n+    def push(self, typ: type[Any], /) -> Generator[None]:\n+        \"\"\"Push a type to the stack.\"\"\"\n+        self._types_stack.append(typ)\n+        # Reset the cached property:\n+        self.__dict__.pop('types_namespace', None)",
      "comment": "You could have something like:\r\n\r\n```python\r\nfrom dataclasses import dataclass\r\n\r\n@dataclass\r\nclass A:\r\n    a: 'F1'\r\n    b: 'F2'\r\n\r\nclass Model(BaseModel):\r\n    a: A\r\n\r\n# Model is still incomplete because of unresolved annotations\r\n\r\nF1 = int\r\nf2 = str\r\n\r\nModel.model_rebuild()\r\n# re-evaluating `A.a` will access the `types_namespace` property, compute it,\r\n# re-evaluating `A.b` will access the `types_namespace` property, using the cached value\r\n```",
      "comment_id": 1786669495,
      "user": "Viicos",
      "created_at": "2024-10-03T18:20:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786669495"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 260,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)\n+\n+    global_ns = get_module_ns_of(obj)\n+\n+    if isinstance(obj, type):\n+        locals_list.extend(\n+            [\n+                vars(obj),  # i.e. `obj.__dict__`\n+                {obj.__name__: obj},\n+            ]\n+        )\n+    else:\n+        # For functions, get the `__type_params__` attribute introduced by PEP 695.\n+        # Note that the typing `_eval_type` function expects type params to be\n+        # passed as a separate argument. However, internally, `_eval_type` calls\n+        # `ForwardRef._evaluate` which will merge type params with the localns,\n+        # essentially mimicing what we do here.\n+        type_params: tuple[TypeVar, ...] = ()\n+        if parent_namespace is not None:\n+            # We also fetch type params from the parent namespace. If present, it probably\n+            # means the function was defined in a class. This is to support the following:\n+            # https://github.com/python/cpython/issues/124089.\n+            type_params += parent_namespace.get('__type_params__', ())\n+        type_params += getattr(obj, '__type_params__', ())\n+        locals_list.append({t.__name__: t for t in type_params})\n+\n+    return NamespacesTuple(global_ns, LazyLocalNamespace(*locals_list))\n+\n+\n+class NsResolver:\n+    \"\"\"A class holding the logic to resolve namespaces for annotations evaluation in the context\n+    of core schema generation.\n+\n+    This class handles the namespace logic when evaluating annotations that failed to\n+    resolve during the initial inspection/building of the Pydantic model, dataclass, etc.\n+\n+    It holds a stack of classes that are being inspected during the core schema building,\n+    and the `types_namespace` property exposes the globals and locals to be used for\n+    type annotation evaluation. Additionally -- if no class is present in the stack -- a\n+    fallback globals and locals can be provided with the `namespaces_tuple` argument.\n+\n+    This is only meant to be used alongside with the `GenerateSchema` class.\n+\n+    Args:\n+        namespaces_tuple: The default globals and locals to used if no class is present\n+            on the stack. This can be useful when using the `GenerateSchema` class\n+            with `TypeAdapter`, where the \"type\" being analyzed is a simple annotation.\n+        fallback_namespace: A namespace to use as a last resort if a name wasn't found\n+            in the locals nor the globals. This is mainly used when rebuilding a core\n+            schema for a Pydantic model or dataclass, where the parent namespace is used.\n+        override_namespace: A namespace to use first when resolving forward annotations.\n+            This is mainly used when rebuilding a core schema for a Pydantic model or\n+            dataclass, where an explicit namespace can be provided to resolve annotations\n+            that failed to resolve during the initial schema building.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns_resolver = NsResolver(\n+            namespaces_tuple=NamespacesTuple({'my_global': 1}, {}),\n+            fallback_namespace={'fallback': 2, 'my_global': 3},\n+        )\n+\n+        ns_resolver.types_namespace\n+        #> NamespacesTuple({'my_global': 1}, {})\n+\n+\n+        class MyType:\n+            some_local = 4\n+\n+\n+        with ns_resolver.push(MyType):\n+            ns_resolver.types_namespace\n+            #> NamespacesTuple({'my_global': 1, 'fallback': 2}, {'some_local': 4})\n+        ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        namespaces_tuple: NamespacesTuple | None = None,\n+        fallback_namespace: MappingNamespace | None = None,\n+        override_namespace: MappingNamespace | None = None,\n+    ) -> None:\n+        self._base_ns_tuple = namespaces_tuple or NamespacesTuple({}, {})\n+        self._fallback_ns = fallback_namespace\n+        self._override_ns = override_namespace\n+        self._types_stack: list[type[Any]] = []\n+\n+    @cached_property\n+    def types_namespace(self) -> NamespacesTuple:\n+        \"\"\"The current global and local namespaces to be used for annotations evaluation.\"\"\"\n+        if not self._types_stack:\n+            # TODO do we want to merge fallback and override ns here?\n+            return self._base_ns_tuple\n+\n+        typ = self._types_stack[-1]\n+\n+        globalns = get_module_ns_of(typ)\n+        # TODO check len(self._types_stack) == 1? As we specified,\n+        # fallback_namespace should only be used for the class being rebuilt.\n+        # However, it might be good to keep this for now to avoid having too\n+        # many breaking changes.\n+        if self._fallback_ns is not None:\n+            globalns = {**self._fallback_ns, **globalns}\n+\n+        locals_list: list[MappingNamespace] = [vars(typ), {typ.__name__: typ}]\n+        if self._override_ns is not None:\n+            locals_list.append(self._override_ns)\n+\n+        return NamespacesTuple(globalns, LazyLocalNamespace(*locals_list))\n+\n+    @contextmanager\n+    def push(self, typ: type[Any], /) -> Generator[None]:\n+        \"\"\"Push a type to the stack.\"\"\"\n+        self._types_stack.append(typ)\n+        # Reset the cached property:\n+        self.__dict__.pop('types_namespace', None)",
      "comment": "It doesn't add that much performance benefit, but still good to have considering the cache invalidation logic is pretty simple",
      "comment_id": 1786669822,
      "user": "Viicos",
      "created_at": "2024-10-03T18:20:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786669822"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "tests/test_forward_ref.py",
      "line": 1178,
      "side": "RIGHT",
      "diff_hunk": "@@ -1130,3 +1130,183 @@ class Foo(BaseModel):\n     ]\n \n     assert extras_schema == {'type': 'int'}\n+\n+\n+@pytest.mark.xfail('get_cls_type_hints_lenient does not fetch the module ns for each base')\n+def test_tmp_1(create_module):\n+    @create_module\n+    def module_1():\n+        from pydantic import BaseModel\n+\n+        class Bar(BaseModel):\n+            f: 'A'\n+\n+        A = int\n+\n+    module_2 = create_module(\n+        f\"\"\"\n+from {module_1.__name__} import Bar\n+\n+A = str\n+\n+class Foo(Bar):\n+    pass\n+        \"\"\"\n+    )\n+\n+    assert module_2.Foo.model_fields['f'].annotation is int\n+\n+\n+@pytest.mark.xfail(reason='We should keep a reference to the parent frame, not f_locals')\n+def test_tmp_2():\n+    def func():\n+        class Model(BaseModel):\n+            a: 'A'\n+\n+        class A(BaseModel):\n+            pass\n+\n+        return Model\n+\n+    Model = func()\n+\n+    Model.model_rebuild()\n+\n+\n+@pytest.mark.xfail(reason='TypesNamespaceStack wrongfully merges tail')\n+def test_tmp_3(create_module):\n+    @create_module",
      "comment": "`test_tmp_3` is fixed thanks to this PR :) \r\n\r\nI can do that once this is merged and we know exactly which of these tests are not failing anymore",
      "comment_id": 1786671630,
      "user": "Viicos",
      "created_at": "2024-10-03T18:22:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786671630"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1249,
      "side": "RIGHT",
      "diff_hunk": "@@ -1267,15 +1244,11 @@ def _common_field_schema(  # C901\n     ) -> _CommonField:\n         # Update FieldInfo annotation if appropriate:\n         FieldInfo = import_cached_field_info()\n-\n         if has_instance_in_type(field_info.annotation, (ForwardRef, str)):\n-            types_namespace = self._types_namespace\n-            if self._typevars_map:\n-                types_namespace = (types_namespace or {}).copy()\n-                # Ensure that typevars get mapped to their concrete types:\n-                types_namespace.update({k.__name__: v for k, v in self._typevars_map.items()})\n \n-            evaluated = _typing_extra.eval_type_lenient(field_info.annotation, types_namespace)\n+            # Can we use field_info.apply_typevars_map here? Shouldn't we error if we encounter name errors here?",
      "comment": "Same as https://github.com/pydantic/pydantic/pull/10530#discussion_r1786437356, I'll also check at the end if we can fix this todo",
      "comment_id": 1786673693,
      "user": "Viicos",
      "created_at": "2024-10-03T18:24:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786673693"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1525,
      "side": "RIGHT",
      "diff_hunk": "@@ -1548,8 +1521,8 @@ def _namedtuple_schema(self, namedtuple_cls: Any, origin: Any) -> core_schema.Co\n             if origin is not None:\n                 namedtuple_cls = origin\n \n-            with self._types_namespace_stack.push(namedtuple_cls):\n-                annotations: dict[str, Any] = get_cls_type_hints_lenient(namedtuple_cls, self._types_namespace)\n+            with self._ns_resolver.push(namedtuple_cls):\n+                annotations: dict[str, Any] = get_cls_type_hints_lenient(namedtuple_cls)",
      "comment": "`get_cls_type_hints_lenient` takes care of building the globals and locals for every base and it now only takes a `parent_namespace` argument (usually the locals of a function where the class was defined).\r\n\r\nIn other words, the namespace logic is self contained. We still push to the ns resolver because `get_cls_type_hints_lenient` is lenient, and every field annotation that failed to resolve is going to go through `self._resolve_forward_ref` at some point, where the `self._types_namespace` argument is used this time (and may contain the fallback/override namespace).",
      "comment_id": 1786678283,
      "user": "Viicos",
      "created_at": "2024-10-03T18:28:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786678283"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace",
      "comment": "Why this isnt always `LazyLocalNamespace`? Is something actually allowed to initialize this with any kind of Mapping? There is some empties somewhere in the PR but it could be also then just empty LazyLocalNamespace",
      "comment_id": 1786698890,
      "user": "MarkusSintonen",
      "created_at": "2024-10-03T18:45:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786698890"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property",
      "comment": "Hows the perf looking with this in ForwardRefs cases like in the mega kube file thing when using future annotations? So how this works by flatting the dicts vs just iterating them, perf wise? I guess the `def data` is really never active when ForwardRefs are not being used by user, right?",
      "comment_id": 1786703975,
      "user": "MarkusSintonen",
      "created_at": "2024-10-03T18:50:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786703975"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)",
      "comment": "Honestly I think the order is fine, it's more efficient to push to the end of a list and pop from there, and this is more in line with how you'd update a dict with a new dict \ud83e\udd37\u200d\u2640\ufe0f ",
      "comment_id": 1786781488,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T20:02:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786781488"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 260,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)\n+\n+    global_ns = get_module_ns_of(obj)\n+\n+    if isinstance(obj, type):\n+        locals_list.extend(\n+            [\n+                vars(obj),  # i.e. `obj.__dict__`\n+                {obj.__name__: obj},\n+            ]\n+        )\n+    else:\n+        # For functions, get the `__type_params__` attribute introduced by PEP 695.\n+        # Note that the typing `_eval_type` function expects type params to be\n+        # passed as a separate argument. However, internally, `_eval_type` calls\n+        # `ForwardRef._evaluate` which will merge type params with the localns,\n+        # essentially mimicing what we do here.\n+        type_params: tuple[TypeVar, ...] = ()\n+        if parent_namespace is not None:\n+            # We also fetch type params from the parent namespace. If present, it probably\n+            # means the function was defined in a class. This is to support the following:\n+            # https://github.com/python/cpython/issues/124089.\n+            type_params += parent_namespace.get('__type_params__', ())\n+        type_params += getattr(obj, '__type_params__', ())\n+        locals_list.append({t.__name__: t for t in type_params})\n+\n+    return NamespacesTuple(global_ns, LazyLocalNamespace(*locals_list))\n+\n+\n+class NsResolver:\n+    \"\"\"A class holding the logic to resolve namespaces for annotations evaluation in the context\n+    of core schema generation.\n+\n+    This class handles the namespace logic when evaluating annotations that failed to\n+    resolve during the initial inspection/building of the Pydantic model, dataclass, etc.\n+\n+    It holds a stack of classes that are being inspected during the core schema building,\n+    and the `types_namespace` property exposes the globals and locals to be used for\n+    type annotation evaluation. Additionally -- if no class is present in the stack -- a\n+    fallback globals and locals can be provided with the `namespaces_tuple` argument.\n+\n+    This is only meant to be used alongside with the `GenerateSchema` class.\n+\n+    Args:\n+        namespaces_tuple: The default globals and locals to used if no class is present\n+            on the stack. This can be useful when using the `GenerateSchema` class\n+            with `TypeAdapter`, where the \"type\" being analyzed is a simple annotation.\n+        fallback_namespace: A namespace to use as a last resort if a name wasn't found\n+            in the locals nor the globals. This is mainly used when rebuilding a core\n+            schema for a Pydantic model or dataclass, where the parent namespace is used.\n+        override_namespace: A namespace to use first when resolving forward annotations.\n+            This is mainly used when rebuilding a core schema for a Pydantic model or\n+            dataclass, where an explicit namespace can be provided to resolve annotations\n+            that failed to resolve during the initial schema building.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns_resolver = NsResolver(\n+            namespaces_tuple=NamespacesTuple({'my_global': 1}, {}),\n+            fallback_namespace={'fallback': 2, 'my_global': 3},\n+        )\n+\n+        ns_resolver.types_namespace\n+        #> NamespacesTuple({'my_global': 1}, {})\n+\n+\n+        class MyType:\n+            some_local = 4\n+\n+\n+        with ns_resolver.push(MyType):\n+            ns_resolver.types_namespace\n+            #> NamespacesTuple({'my_global': 1, 'fallback': 2}, {'some_local': 4})\n+        ```\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        namespaces_tuple: NamespacesTuple | None = None,\n+        fallback_namespace: MappingNamespace | None = None,\n+        override_namespace: MappingNamespace | None = None,\n+    ) -> None:\n+        self._base_ns_tuple = namespaces_tuple or NamespacesTuple({}, {})\n+        self._fallback_ns = fallback_namespace\n+        self._override_ns = override_namespace\n+        self._types_stack: list[type[Any]] = []\n+\n+    @cached_property\n+    def types_namespace(self) -> NamespacesTuple:\n+        \"\"\"The current global and local namespaces to be used for annotations evaluation.\"\"\"\n+        if not self._types_stack:\n+            # TODO do we want to merge fallback and override ns here?\n+            return self._base_ns_tuple\n+\n+        typ = self._types_stack[-1]\n+\n+        globalns = get_module_ns_of(typ)\n+        # TODO check len(self._types_stack) == 1? As we specified,\n+        # fallback_namespace should only be used for the class being rebuilt.\n+        # However, it might be good to keep this for now to avoid having too\n+        # many breaking changes.\n+        if self._fallback_ns is not None:\n+            globalns = {**self._fallback_ns, **globalns}\n+\n+        locals_list: list[MappingNamespace] = [vars(typ), {typ.__name__: typ}]\n+        if self._override_ns is not None:\n+            locals_list.append(self._override_ns)\n+\n+        return NamespacesTuple(globalns, LazyLocalNamespace(*locals_list))\n+\n+    @contextmanager\n+    def push(self, typ: type[Any], /) -> Generator[None]:\n+        \"\"\"Push a type to the stack.\"\"\"\n+        self._types_stack.append(typ)\n+        # Reset the cached property:\n+        self.__dict__.pop('types_namespace', None)",
      "comment": "Makes sense, thanks for the example. Marking as resolved \ud83d\udc4d ",
      "comment_id": 1786782174,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T20:03:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1786782174"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+# This function is quite similar to the `NsResolver.types_namespace` property, but it also\n+# handles functions, while `NsResolver` only deals with type objects. This function should\n+# thus only be used when you want to resolve annotations for an object when *not* in a\n+# core schema generation context:\n+def ns_from(obj: Any, parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided object.\n+\n+    The global namespace will be the `__dict__` attribute of the module the object was defined in. The\n+    local namespace will be constructed depending on the object type:\n+    - if it is a type object, use the object's `__dict__` attribute and add the object itself to the locals.\n+    - if it is a function, add the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)",
      "comment": "I'll leave this unresolved for now and come back to it just before merging",
      "comment_id": 1787802231,
      "user": "Viicos",
      "created_at": "2024-10-04T14:23:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1787802231"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,7 +222,7 @@ def collect_model_fields(  # noqa: C901\n \n     if typevars_map:\n         for field in fields.values():\n-            field.apply_typevars_map(typevars_map, types_namespace)\n+            field.apply_typevars_map(typevars_map, {})",
      "comment": "The `apply_typevars_map` signature was changed from:\r\n\r\n`(typevars_map, types_namespace) -> None`\r\n\r\nto\r\n\r\n`(typevars_map, globalns = None, localns= None) -> None`.\r\n\r\nThe function does two things:\r\n- call `eval_type_lenient` (using the ns arguments)\r\n- call `_generics.replace_type` (using the `typevars_map` argument).\r\n\r\nIn this case, the call to `eval_type_lenient` is useless because annotations were evaluated already before in this context. In other words, we could very much replace this by a simple `_generics.replace_type` call. I was even thinking about removing this `apply_typevars_map` method, or at least give more flexibility on whether we want to evaluate annotations or not.\r\n\r\nBut anyway, I just realized I made the ns arguments optional, so I'm just going to remove the useless `{}` argument here.",
      "comment_id": 1787813110,
      "user": "Viicos",
      "created_at": "2024-10-04T14:31:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1787813110"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_dataclasses.py",
      "line": 139,
      "side": "LEFT",
      "diff_hunk": "@@ -135,16 +146,13 @@ def __init__(__dataclass_self__: PydanticDataclass, *args: Any, **kwargs: Any) -\n             'Support for `__post_init_post_parse__` has been dropped, the method will not be called', DeprecationWarning\n         )\n \n-    if types_namespace is None:\n-        types_namespace = _typing_extra.merge_cls_and_parent_ns(cls)",
      "comment": "I'm not too happy with having both the `ns_resolver` and `parent_namespace` argument in this `complete_dataclass` function. `parent_namespace` is only relevant when doing the initial dataclass build (similarly to Pydantic models -- though currently it isn't provided; see the TODO @ `pydantic/dataclasses.py:L273`).\r\n\r\n`ns_resolver` is only relevant when calling `rebuild_dataclass` (it will include a fallback and override namespace). But unlike Pydantic models, a dataclass rebuild will also trigger a `collect_dataclass_fields`. iirc we talked about this inconsistency on Slack, I'm postponing it as it can be decoupled from this PR.\r\n\r\nSo to sum things up:\r\n- initial build: only the parent ns is at play\r\n- dc rebuild: only the ns_resolver is at play.",
      "comment_id": 1787827721,
      "user": "Viicos",
      "created_at": "2024-10-04T14:42:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1787827721"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 54,
      "side": "LEFT",
      "diff_hunk": "@@ -42,18 +43,10 @@ def __init__(\n             self.__qualname__ = function.__qualname__\n             self.__module__ = function.__module__\n \n-        global_ns = _typing_extra.get_module_ns_of(function)\n-        # TODO: this is a bit of a hack, we should probably have a better way to handle this\n-        # specifically, we shouldn't be pumping the namespace full of type_params\n-        # when we take namespace and type_params arguments in eval_type_backport\n-        type_params = (namespace or {}).get('__type_params__', ()) + getattr(schema_type, '__type_params__', ())\n-        namespace = {\n-            **{param.__name__: param for param in type_params},\n-            **(global_ns or {}),\n-            **(namespace or {}),\n-        }",
      "comment": "Everything was moved in the `ns_from` function :+1: ",
      "comment_id": 1787829225,
      "user": "Viicos",
      "created_at": "2024-10-04T14:43:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1787829225"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace",
      "comment": "I wanted to have `LazyLocalNamespace` as an implementation detail, as this gives us more flexibility, especially if in the future we expose the `GenerateSchema` class to Pydantic users (the `types_namespace` property exposes `NamespaceTuple`).",
      "comment_id": 1787837507,
      "user": "Viicos",
      "created_at": "2024-10-04T14:49:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1787837507"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property",
      "comment": "> I guess the `def data` is really never active when ForwardRefs are not being used by user, right?\r\n\r\nCorrect.\r\n\r\nRunning memray on the k8s file, I get:\r\n- ~3 GiB total allocations on main\r\n- ~1.5GiB total allocations here\r\n- ~1.9GiB total allocations here, with the future import.\r\n\r\n > So how this works by flatting the dicts vs just iterating them, perf wise?\r\n\r\nConsidering most of the local namespaces are really small (compared to globals), If I remember correctly the difference is marginal, at least by experimenting quickly with `timeit` and some dummy examples.",
      "comment_id": 1787849589,
      "user": "Viicos",
      "created_at": "2024-10-04T14:58:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1787849589"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1462,
      "side": "RIGHT",
      "diff_hunk": "@@ -1458,7 +1458,12 @@ def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -> core_schema.Co\n                 else:\n                     field_docstrings = None\n \n-                for field_name, annotation in get_cls_type_hints_lenient(typed_dict_cls).items():\n+                try:\n+                    annotations = get_cls_type_hints(typed_dict_cls, ns_resolver=self._ns_resolver, lenient=False)",
      "comment": "Note here that we use `lenient=False`, because if we fail to resolve them here, there's no reason to continue (same for named tuples)",
      "comment_id": 1792079846,
      "user": "Viicos",
      "created_at": "2024-10-08T15:18:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792079846"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]",
      "comment": "Happy with these as is for now - they're internal structures, so we can always bikeshed later. Resolving :).",
      "comment_id": 1792170071,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:18:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792170071"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,237 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property",
      "comment": "This is great, I'm super glad to see we've reduced the duplicate allocations in context management that we were dealing with before this PR.",
      "comment_id": 1792172433,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:20:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792172433"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 68,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,265 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Callable, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object, when dealing with types\n+defined inside functions).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so the result\n+    should not be mutated. The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.",
      "comment": "I wanted to document here that I'm in favor of this ascending order of priority, makes it feel like a stack \ud83d\udc4d ",
      "comment_id": 1792174625,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:22:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792174625"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,265 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Callable, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object, when dealing with types\n+defined inside functions).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so the result\n+    should not be mutated. The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+def ns_for_function(obj: Callable[..., Any], parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided function.\n+\n+    The global namespace will be the `__dict__` attribute of the module the function was defined in.\n+    The local namespace will contain the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+            If the passed function is a method, the `parent_namespace` will be the namespace of the class\n+            the method is defined in. Thus, we also fetch type `__type_params__` from there (i.e. the\n+            class-scoped type variables).\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)\n+\n+    # Get the `__type_params__` attribute introduced by PEP 695.\n+    # Note that the `typing._eval_type` function expects type params to be\n+    # passed as a separate argument. However, internally, `_eval_type` calls\n+    # `ForwardRef._evaluate` which will merge type params with the localns,\n+    # essentially mimicing what we do here.\n+    type_params: tuple[TypeVar, ...] = ()\n+    if parent_namespace is not None:\n+        # We also fetch type params from the parent namespace. If present, it probably\n+        # means the function was defined in a class. This is to support the following:\n+        # https://github.com/python/cpython/issues/124089.\n+        type_params += parent_namespace.get('__type_params__', ())\n+\n+    locals_list.append({t.__name__: t for t in type_params})\n+\n+    # What about short-cirtuiting to `obj.__globals__`?\n+    globalns = get_module_ns_of(obj)\n+\n+    return NamespacesTuple(globalns, LazyLocalNamespace(*locals_list))\n+\n+\n+class NsResolver:\n+    \"\"\"A class responsible for the namespaces resolving logic for annotations evaluation.\n+\n+    This class handles the namespace logic when evaluating annotations mainly for class objects.\n+\n+    It holds a stack of classes that are being inspected during the core schema building,\n+    and the `types_namespace` property exposes the globals and locals to be used for\n+    type annotation evaluation. Additionally -- if no class is present in the stack -- a\n+    fallback globals and locals can be provided using the `namespaces_tuple` argument\n+    (this is useful when generating a schema for a simple annotation, e.g. when using\n+    `TypeAdapter`).\n+\n+    The namespace creation logic is unfortunately flawed in some cases, for backwards\n+    compatibility reasons and to better support valid edge cases. See the description\n+    for the `parent_namespace` argument and the example for more details.\n+\n+    Args:\n+        namespaces_tuple: The default globals and locals to used if no class is present",
      "comment": "```suggestion\r\n        namespaces_tuple: The default globals and locals to use if no class is present\r\n```",
      "comment_id": 1792178342,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:24:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792178342"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 140,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,265 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator, Mapping\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Callable, Iterator, NamedTuple, TypeAlias, TypeVar\n+\n+GlobalsNamespace: TypeAlias = dict[str, Any]\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object, when dealing with types\n+defined inside functions).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so the result\n+    should not be mutated. The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}\n+\n+    def __len__(self) -> int:\n+        return len(self.data)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self.data[key]\n+\n+    def __contains__(self, key: object) -> bool:\n+        return key in self.data\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return iter(self.data)\n+\n+\n+def ns_for_function(obj: Callable[..., Any], parent_namespace: MappingNamespace | None = None) -> NamespacesTuple:\n+    \"\"\"Return the global and local namespaces to be used when evaluating annotations for the provided function.\n+\n+    The global namespace will be the `__dict__` attribute of the module the function was defined in.\n+    The local namespace will contain the `__type_params__` introduced by PEP 695.\n+\n+    Args:\n+        obj: The object to use when building namespaces.\n+        parent_namespace: Optional namespace to be added with the lowest priority in the local namespace.\n+            If the passed function is a method, the `parent_namespace` will be the namespace of the class\n+            the method is defined in. Thus, we also fetch type `__type_params__` from there (i.e. the\n+            class-scoped type variables).\n+    \"\"\"\n+    locals_list: list[MappingNamespace] = []\n+    if parent_namespace is not None:\n+        locals_list.append(parent_namespace)\n+\n+    # Get the `__type_params__` attribute introduced by PEP 695.\n+    # Note that the `typing._eval_type` function expects type params to be\n+    # passed as a separate argument. However, internally, `_eval_type` calls\n+    # `ForwardRef._evaluate` which will merge type params with the localns,\n+    # essentially mimicing what we do here.\n+    type_params: tuple[TypeVar, ...] = ()\n+    if parent_namespace is not None:\n+        # We also fetch type params from the parent namespace. If present, it probably\n+        # means the function was defined in a class. This is to support the following:\n+        # https://github.com/python/cpython/issues/124089.\n+        type_params += parent_namespace.get('__type_params__', ())\n+\n+    locals_list.append({t.__name__: t for t in type_params})\n+\n+    # What about short-cirtuiting to `obj.__globals__`?\n+    globalns = get_module_ns_of(obj)\n+\n+    return NamespacesTuple(globalns, LazyLocalNamespace(*locals_list))\n+\n+\n+class NsResolver:\n+    \"\"\"A class responsible for the namespaces resolving logic for annotations evaluation.\n+\n+    This class handles the namespace logic when evaluating annotations mainly for class objects.",
      "comment": "I'm happy that we're now using this across more than just the `_generate_schema.py` file - seems like it makes things more consistent across the board.",
      "comment_id": 1792183773,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:29:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792183773"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -288,50 +289,67 @@ def collect_dataclass_fields(\n     FieldInfo_ = import_cached_field_info()\n \n     fields: dict[str, FieldInfo] = {}\n-    dataclass_fields: dict[str, dataclasses.Field] = cls.__dataclass_fields__\n-    cls_localns = dict(vars(cls))  # this matches get_cls_type_hints_lenient, but all tests pass with `= None` instead\n+    ns_resolver = ns_resolver or NsResolver()\n \n-    source_module = sys.modules.get(cls.__module__)\n-    if source_module is not None:\n-        types_namespace = {**source_module.__dict__, **(types_namespace or {})}\n-\n-    for ann_name, dataclass_field in dataclass_fields.items():\n-        ann_type = _typing_extra.eval_type_lenient(dataclass_field.type, types_namespace, cls_localns)\n-        if is_classvar(ann_type):\n+    # The logic here is similar to `_typing_extra.get_cls_type_hints`,\n+    # although we do it manually as stdlib dataclasses already have annotations\n+    # collected in each class:\n+    for base in reversed(cls.__mro__):\n+        if not _typing_extra.is_dataclass(base):\n             continue\n \n-        if (\n-            not dataclass_field.init\n-            and dataclass_field.default == dataclasses.MISSING\n-            and dataclass_field.default_factory == dataclasses.MISSING\n-        ):\n-            # TODO: We should probably do something with this so that validate_assignment behaves properly\n-            #   Issue: https://github.com/pydantic/pydantic/issues/5470\n-            continue\n+        dataclass_fields = cls.__dataclass_fields__",
      "comment": "This can be moved out of the loop (I think you did that in a PR recently)",
      "comment_id": 1792191210,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:34:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792191210"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 299,
      "side": "RIGHT",
      "diff_hunk": "@@ -288,50 +289,67 @@ def collect_dataclass_fields(\n     FieldInfo_ = import_cached_field_info()\n \n     fields: dict[str, FieldInfo] = {}\n-    dataclass_fields: dict[str, dataclasses.Field] = cls.__dataclass_fields__\n-    cls_localns = dict(vars(cls))  # this matches get_cls_type_hints_lenient, but all tests pass with `= None` instead\n+    ns_resolver = ns_resolver or NsResolver()\n \n-    source_module = sys.modules.get(cls.__module__)\n-    if source_module is not None:\n-        types_namespace = {**source_module.__dict__, **(types_namespace or {})}\n-\n-    for ann_name, dataclass_field in dataclass_fields.items():\n-        ann_type = _typing_extra.eval_type_lenient(dataclass_field.type, types_namespace, cls_localns)\n-        if is_classvar(ann_type):\n+    # The logic here is similar to `_typing_extra.get_cls_type_hints`,\n+    # although we do it manually as stdlib dataclasses already have annotations\n+    # collected in each class:\n+    for base in reversed(cls.__mro__):\n+        if not _typing_extra.is_dataclass(base):\n             continue",
      "comment": "Nice to see this stuff moved here instead of `_generate_schema.py`",
      "comment_id": 1792192320,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:35:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792192320"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 676,
      "side": "RIGHT",
      "diff_hunk": "@@ -696,7 +673,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                                     _typing_extra._make_forward_ref(\n                                         extras_annotation, is_argument=False, is_class=True\n                                     ),\n-                                    self._types_namespace,\n+                                    *self._types_namespace,",
      "comment": "@Viicos, wanted to follow up about this before we merge",
      "comment_id": 1792193240,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:36:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792193240"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/main.py",
      "line": 585,
      "side": "LEFT",
      "diff_hunk": "@@ -564,38 +565,32 @@ def model_rebuild(\n         \"\"\"\n         if not force and cls.__pydantic_complete__:\n             return None\n-        else:\n-            if '__pydantic_core_schema__' in cls.__dict__:\n-                delattr(cls, '__pydantic_core_schema__')  # delete cached value to ensure full rebuild happens\n-            if _types_namespace is not None:\n-                types_namespace: dict[str, Any] | None = _types_namespace.copy()\n-            else:\n-                if _parent_namespace_depth > 0:\n-                    frame_parent_ns = (\n-                        _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n-                    )\n-                    cls_parent_ns = (\n-                        _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n-                    )\n-                    types_namespace = {**cls_parent_ns, **frame_parent_ns}\n-                    cls.__pydantic_parent_namespace__ = _model_construction.build_lenient_weakvaluedict(types_namespace)\n-                else:\n-                    types_namespace = _model_construction.unpack_lenient_weakvaluedict(\n-                        cls.__pydantic_parent_namespace__\n-                    )",
      "comment": "No longer worried about this, thanks for resolving this issue.",
      "comment_id": 1792200337,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:41:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792200337"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/main.py",
      "line": 793,
      "side": "RIGHT",
      "diff_hunk": "@@ -794,7 +790,7 @@ def __class_getitem__(\n                 # Attempt to rebuild the origin in case new types have been defined\n                 try:\n                     # depth 3 gets you above this __class_getitem__ call\n-                    origin.model_rebuild(_parent_namespace_depth=3)\n+                    origin.model_rebuild(_parent_namespace_depth=0)",
      "comment": "Why the depth change here? We should change the comment...",
      "comment_id": 1792200844,
      "user": "sydney-runkle",
      "created_at": "2024-10-08T16:42:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792200844"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/main.py",
      "line": 793,
      "side": "RIGHT",
      "diff_hunk": "@@ -794,7 +790,7 @@ def __class_getitem__(\n                 # Attempt to rebuild the origin in case new types have been defined\n                 try:\n                     # depth 3 gets you above this __class_getitem__ call\n-                    origin.model_rebuild(_parent_namespace_depth=3)\n+                    origin.model_rebuild(_parent_namespace_depth=0)",
      "comment": "Ah yes forgot to explain this. When you do the following:\r\n\r\n```python\r\nclass Model(BaseModel, Generic[T]):\r\n    a: 'Forward'\r\n\r\nForward = int\r\n\r\nModelInt = Model[int]\r\n```\r\n\r\nDoing `Model[int]` will trigger this `origin.model_rebuild` call (because `'Forward'` failed to resolve initially). While it may make sense to fetch the parent namespace here, it doesn't in this case:\r\n\r\n```python\r\nclass OtherModel(BaseModel):\r\n    m: 'Model[int]'\r\n```\r\n\r\nBecause when the annotation for `m` is going to be evaluated, we will call `eval('Model[int]', some_globals, some_lazy_local_ns_instance)`. A new frame will be created, with `f_locals = some_lazy_local_ns_instance`. `Model[int]` will trigger the `origin.model_rebuild` call, and fetching the parent namespace will resolve to `some_lazy_local_ns_instance`: highly unexpected!\r\n\r\nThis caused a bug with one test case:\r\n\r\n```python\r\nfrom typing import Generic, TypeVar, Union\r\n\r\nfrom pydantic import BaseModel\r\n\r\nT1 = TypeVar('T1')\r\nT2 = TypeVar('T2')\r\nT3 = TypeVar('T3')\r\n\r\nclass A1(BaseModel, Generic[T1]):\r\n    a1: 'A2[T1]'\r\n\r\nclass A2(BaseModel, Generic[T2]):\r\n    a2: 'A3[T2]'\r\n\r\nclass A3(BaseModel, Generic[T3]):\r\n    a3: Union['A1[T3]', T3]\r\n```\r\n\r\nBecause we now pass the `ns_resolver` to `get_cls_type_hints` in `collect_model_fields` (TODO, should we? Let me investigate), and because this `ns_resolver` will add `{A3.__name__: A3}` to the locals for every type: when collecting fields for `A3`, we rebuild `A1` (because `'A1[T3]'` is evaluated), which rebuilds `A2`, which rebuilds `A3` (but fields for `A3` were not even collected yet! Resulting in an attribute error because it tries to access `A3.__pydantic_fields__` somewhere).\r\n\r\nThis needs further investigation. ",
      "comment_id": 1792408491,
      "user": "Viicos",
      "created_at": "2024-10-08T19:36:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792408491"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 676,
      "side": "RIGHT",
      "diff_hunk": "@@ -696,7 +673,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                                     _typing_extra._make_forward_ref(\n                                         extras_annotation, is_argument=False, is_class=True\n                                     ),\n-                                    self._types_namespace,\n+                                    *self._types_namespace,",
      "comment": "I kind of liked the unpacking form, that's the primary reason I've used a namedtuple here (see the `NamespaceTuple` docstring) but ok to make the change",
      "comment_id": 1792413024,
      "user": "Viicos",
      "created_at": "2024-10-08T19:41:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792413024"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 676,
      "side": "RIGHT",
      "diff_hunk": "@@ -696,7 +673,7 @@ def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n                                     _typing_extra._make_forward_ref(\n                                         extras_annotation, is_argument=False, is_class=True\n                                     ),\n-                                    self._types_namespace,\n+                                    *self._types_namespace,",
      "comment": "> I kind of liked the unpacking form, that's the primary reason I've used a namedtuple here (see the NamespaceTuple docstring) but ok to make the change\r\n\r\nOk, let's stick with what you have then! It's clear enough - thanks for following up.",
      "comment_id": 1792676813,
      "user": "sydney-runkle",
      "created_at": "2024-10-09T01:34:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1792676813"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,266 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Callable, Iterator, Mapping, NamedTuple, TypeVar\n+\n+from typing_extensions import TypeAlias, TypeAliasType\n+\n+GlobalsNamespace: TypeAlias = 'dict[str, Any]'\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object, when dealing with types\n+defined inside functions).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so the result\n+    should not be mutated. The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}",
      "comment": "Any reason not to use `collections.ChainMap` here instead of looping over all the items in all the dicts? ",
      "comment_id": 1795441549,
      "user": "dmontagu",
      "created_at": "2024-10-10T13:33:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1795441549"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/type_adapter.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -87,9 +87,12 @@ def _get_schema(type_: Any, config_wrapper: _config.ConfigWrapper, parent_depth:\n     But at the very least this behavior is _subtly_ different from `BaseModel`'s.\n     \"\"\"\n     local_ns = _typing_extra.parent_frame_namespace(parent_depth=parent_depth)\n-    global_ns = sys._getframe(max(parent_depth - 1, 1)).f_globals.copy()\n-    global_ns.update(local_ns or {})\n-    gen = _generate_schema.GenerateSchema(config_wrapper, types_namespace=global_ns, typevars_map={})\n+    globalns = sys._getframe(max(parent_depth - 1, 1)).f_globals",
      "comment": "Can we change `local_ns` in the previous line to be `localns` or `parent_namespace`. Minor I know, lol, but it's bothering me that we have an underscore in `local_ns` and not in `globalns` right next to each other.",
      "comment_id": 1795448984,
      "user": "dmontagu",
      "created_at": "2024-10-10T13:36:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1795448984"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/main.py",
      "line": 583,
      "side": "RIGHT",
      "diff_hunk": "@@ -564,37 +566,32 @@ def model_rebuild(\n         \"\"\"\n         if not force and cls.__pydantic_complete__:\n             return None\n+\n+        if '__pydantic_core_schema__' in cls.__dict__:\n+            delattr(cls, '__pydantic_core_schema__')  # delete cached value to ensure full rebuild happens\n+\n+        if _types_namespace is not None:\n+            rebuild_ns = _types_namespace\n+        elif _parent_namespace_depth > 0:\n+            rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n         else:\n-            if '__pydantic_core_schema__' in cls.__dict__:\n-                delattr(cls, '__pydantic_core_schema__')  # delete cached value to ensure full rebuild happens\n-            if _types_namespace is not None:\n-                types_namespace: dict[str, Any] | None = _types_namespace.copy()\n-            else:\n-                if _parent_namespace_depth > 0:\n-                    frame_parent_ns = (\n-                        _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n-                    )\n-                    cls_parent_ns = (\n-                        _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n-                    )\n-                    types_namespace = {**cls_parent_ns, **frame_parent_ns}\n-                    cls.__pydantic_parent_namespace__ = _model_construction.build_lenient_weakvaluedict(types_namespace)\n-                else:\n-                    types_namespace = _model_construction.unpack_lenient_weakvaluedict(\n-                        cls.__pydantic_parent_namespace__\n-                    )\n-\n-                types_namespace = _typing_extra.merge_cls_and_parent_ns(cls, types_namespace)\n-\n-            # manually override defer_build so complete_model_class doesn't skip building the model again\n-            config = {**cls.model_config, 'defer_build': False}\n-            return _model_construction.complete_model_class(\n-                cls,\n-                cls.__name__,\n-                _config.ConfigWrapper(config, check=False),\n-                raise_errors=raise_errors,\n-                types_namespace=types_namespace,\n-            )\n+            rebuild_ns = {}\n+\n+        parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n+\n+        ns_resolver = _namespace_utils.NsResolver(\n+            parent_namespace={**rebuild_ns, **parent_ns},",
      "comment": "Another place collections.ChainMap could maybe be used, maybe not necessary",
      "comment_id": 1795451788,
      "user": "dmontagu",
      "created_at": "2024-10-10T13:38:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1795451788"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/type_adapter.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -87,9 +87,12 @@ def _get_schema(type_: Any, config_wrapper: _config.ConfigWrapper, parent_depth:\n     But at the very least this behavior is _subtly_ different from `BaseModel`'s.\n     \"\"\"\n     local_ns = _typing_extra.parent_frame_namespace(parent_depth=parent_depth)\n-    global_ns = sys._getframe(max(parent_depth - 1, 1)).f_globals.copy()\n-    global_ns.update(local_ns or {})\n-    gen = _generate_schema.GenerateSchema(config_wrapper, types_namespace=global_ns, typevars_map={})\n+    globalns = sys._getframe(max(parent_depth - 1, 1)).f_globals",
      "comment": "Sydney actually already requested this but I only applied it to `globalns` :facepalm: ",
      "comment_id": 1795931588,
      "user": "Viicos",
      "created_at": "2024-10-10T18:43:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1795931588"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10530,
      "file_path": "pydantic/_internal/_namespace_utils.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,266 @@\n+from __future__ import annotations\n+\n+import sys\n+from collections.abc import Generator\n+from contextlib import contextmanager\n+from functools import cached_property\n+from typing import Any, Callable, Iterator, Mapping, NamedTuple, TypeVar\n+\n+from typing_extensions import TypeAlias, TypeAliasType\n+\n+GlobalsNamespace: TypeAlias = 'dict[str, Any]'\n+\"\"\"A global namespace.\n+\n+In most cases, this is a reference to the `__dict__` attribute of a module.\n+This namespace type is expected as the `globals` argument during annotations evaluation.\n+\"\"\"\n+\n+MappingNamespace: TypeAlias = Mapping[str, Any]\n+\"\"\"Any kind of namespace.\n+\n+In most cases, this is a local namespace (e.g. the `__dict__` attribute of a class,\n+the [`f_locals`][frame.f_locals] attribute of a frame object, when dealing with types\n+defined inside functions).\n+This namespace type is expected as the `locals` argument during annotations evaluation.\n+\"\"\"\n+\n+\n+class NamespacesTuple(NamedTuple):\n+    \"\"\"A tuple of globals and locals to be used during annotations evaluation.\n+\n+    This datastructure is defined as a named tuple so that it can easily be unpacked:\n+\n+    ```python lint=\"skip\" test=\"skip\"\n+    def eval_type(typ: type[Any], ns: NamespacesTuple) -> None:\n+        return eval(typ, *ns)\n+    ```\n+    \"\"\"\n+\n+    globals: GlobalsNamespace\n+    \"\"\"The namespace to be used as the `globals` argument during annotations evaluation.\"\"\"\n+\n+    locals: MappingNamespace\n+    \"\"\"The namespace to be used as the `locals` argument during annotations evaluation.\"\"\"\n+\n+\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so the result\n+    should not be mutated. The burden of enforcing this is on the caller.\n+    \"\"\"\n+    module_name = getattr(obj, '__module__', None)\n+    if module_name:\n+        try:\n+            return sys.modules[module_name].__dict__\n+        except KeyError:\n+            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n+            return {}\n+    return {}\n+\n+\n+class LazyLocalNamespace(Mapping[str, Any]):\n+    \"\"\"A lazily evaluated mapping, to be used as the `locals` argument during annotations evaluation.\n+\n+    While the [`eval`][eval] function expects a mapping as the `locals` argument, it only\n+    performs `__getitem__` calls. The [`Mapping`][collections.abc.Mapping] abstract base class\n+    is fully implemented only for type checking purposes.\n+\n+    Args:\n+        *namespaces: The namespaces to consider, in ascending order of priority.\n+\n+    Example:\n+        ```python lint=\"skip\" test=\"skip\"\n+        ns = LazyLocalNamespace({'a': 1, 'b': 2}, {'a': 3})\n+        ns['a']\n+        #> 3\n+        ns['b']\n+        #> 2\n+        ```\n+    \"\"\"\n+\n+    def __init__(self, *namespaces: MappingNamespace) -> None:\n+        self._namespaces = namespaces\n+\n+    @cached_property\n+    def data(self) -> Mapping[str, Any]:\n+        return {k: v for ns in self._namespaces for k, v in ns.items()}",
      "comment": "I thought about using chain maps but couldn't remember all the reasons I did not. Looking into it, we could also\r\nditch `LazyLocalNamespace` and use a chain map instead, but `ChainMap` is a mutable mapping, and ideally we'd like to enforce immutability (at least from at the type checker level). I added a comment about this.\r\n\r\nRegarding whether `data` should return a chain map instead, we discussed about it in [this comment](https://github.com/pydantic/pydantic/pull/10530#discussion_r1786703975).",
      "comment_id": 1795945673,
      "user": "Viicos",
      "created_at": "2024-10-10T18:56:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10530#discussion_r1795945673"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10597,
      "file_path": "pydantic/functional_validators.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -163,25 +163,45 @@ class PlainValidator:\n \n     A metadata class that indicates that a validation should be applied **instead** of the inner validation logic.\n \n+    !!! note:\n+        Before v2.9, `PlainValidator` wasn't always compatible with JSON Schema generation for `mode='validation'`.\n+        You can now use the `json_schema_input_type` argument to specify the input type of the function\n+        to be used in the JSON schema when `mode='validation'` (the default). See the example below for more details.\n+\n+        If you'd like the JSON Schema type for an annotated field to be populated automatically,\n+        you might consider using `WrapValidator` instead.",
      "comment": "Maybe we shouldn't recommend a specific validator type. before and wrap validators both populate the JSON Schema from the annotated type, but the usage of one of the user will depend on the user",
      "comment_id": 1795911493,
      "user": "Viicos",
      "created_at": "2024-10-10T18:28:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10597#discussion_r1795911493"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10595,
      "file_path": "pydantic/json_schema.py",
      "line": 578,
      "side": "RIGHT",
      "diff_hunk": "@@ -556,6 +556,38 @@ def new_handler_func(\n             json_schema = populate_defs(schema, json_schema)\n         return json_schema\n \n+    def sort(self, value: JsonSchemaValue, parent_key: str | None = None) -> JsonSchemaValue:\n+        \"\"\"Override this method to customize the sorting of the JSON schema (e.g., don't sort at all, sort all keys unconditionally, etc.)\n+\n+        By default, alphabetically sort the keys in the JSON schema, skipping the 'properties' and 'default' keys to preserve field definition order.\n+        This sort is recursive, so it will sort all nested dictionaries as well.\n+        \"\"\"\n+        sorted_dict: dict[str, JsonSchemaValue] = {}\n+        keys = value.keys()\n+        if (parent_key != 'properties') and (parent_key != 'default'):\n+            keys = sorted(keys)\n+        for key in keys:\n+            sorted_dict[key] = self._sort_recursive(value[key], parent_key=key)\n+        return sorted_dict\n+\n+    def _sort_recursive(self, value: Any, parent_key: str | None = None) -> Any:\n+        \"\"\"Recursively sort a JSON schema value.\"\"\"\n+        if isinstance(value, dict):\n+            sorted_dict: dict[str, JsonSchemaValue] = {}\n+            keys = value.keys()\n+            if (parent_key != 'properties') and (parent_key != 'default'):",
      "comment": "```suggestion\r\n            if parent_key not in ('properties', 'default'):\r\n```\r\n\r\nEasier to extend in the future",
      "comment_id": 1795639362,
      "user": "Viicos",
      "created_at": "2024-10-10T15:04:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/10595#discussion_r1795639362"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10595,
      "file_path": "pydantic/json_schema.py",
      "line": 567,
      "side": "RIGHT",
      "diff_hunk": "@@ -556,6 +556,38 @@ def new_handler_func(\n             json_schema = populate_defs(schema, json_schema)\n         return json_schema\n \n+    def sort(self, value: JsonSchemaValue, parent_key: str | None = None) -> JsonSchemaValue:\n+        \"\"\"Override this method to customize the sorting of the JSON schema (e.g., don't sort at all, sort all keys unconditionally, etc.)\n+\n+        By default, alphabetically sort the keys in the JSON schema, skipping the 'properties' and 'default' keys to preserve field definition order.\n+        This sort is recursive, so it will sort all nested dictionaries as well.\n+        \"\"\"\n+        sorted_dict: dict[str, JsonSchemaValue] = {}\n+        keys = value.keys()\n+        if (parent_key != 'properties') and (parent_key != 'default'):",
      "comment": "```suggestion\r\n        if parent_key not in ('properties', 'default'):\r\n```\r\n\r\nsame as below",
      "comment_id": 1795640027,
      "user": "Viicos",
      "created_at": "2024-10-10T15:05:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10595#discussion_r1795640027"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10562,
      "file_path": "pydantic/_internal/_config.py",
      "line": 158,
      "side": "RIGHT",
      "diff_hunk": "@@ -154,7 +154,7 @@ def __getattr__(self, name: str) -> Any:\n                 except KeyError:\n                     raise AttributeError(f'Config has no attribute {name!r}') from None\n \n-    def core_config(self, obj: Any) -> core_schema.CoreConfig:\n+    def core_config(self, title: str | None) -> core_schema.CoreConfig:\n         \"\"\"Create a pydantic-core config, `obj` is just used to populate `title` if not set in config.",
      "comment": "Could you please update these docs? Also, we'll want to reflect the fact that the `title` from `config` takes prio.",
      "comment_id": 1790465044,
      "user": "sydney-runkle",
      "created_at": "2024-10-07T15:40:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10562#discussion_r1790465044"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10440,
      "file_path": "pydantic/json_schema.py",
      "line": 469,
      "side": "LEFT",
      "diff_hunk": "@@ -466,7 +466,6 @@ def populate_defs(core_schema: CoreSchema, json_schema: JsonSchemaValue) -> Json\n                 core_ref = CoreRef(core_schema['ref'])  # type: ignore[typeddict-item]\n                 defs_ref, ref_json_schema = self.get_cache_defs_ref_schema(core_ref)\n                 json_ref = JsonRef(ref_json_schema['$ref'])\n-                self.json_to_defs_refs[json_ref] = defs_ref",
      "comment": "This is done in the `self.get_cache_defs_ref_schema(core_ref)` call, so no reason to do that here.",
      "comment_id": 1786775209,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T19:56:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10440#discussion_r1786775209"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10440,
      "file_path": "pydantic/json_schema.py",
      "line": 1203,
      "side": "RIGHT",
      "diff_hunk": "@@ -1201,9 +1200,7 @@ def _extract_discriminator(\n                     continue  # this means that the \"alias\" does not represent a field\n                 alias_is_present_on_all_choices = True\n                 for choice in one_of_choices:\n-                    while '$ref' in choice:\n-                        assert isinstance(choice['$ref'], str)\n-                        choice = self.get_schema_from_definitions(JsonRef(choice['$ref'])) or {}\n+                    choice = self.resolve_schema_to_update(choice)",
      "comment": "This function handles the above removed logic more gracefully, with an intuitive error.",
      "comment_id": 1786775570,
      "user": "sydney-runkle",
      "created_at": "2024-10-03T19:56:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10440#discussion_r1786775570"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 961,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,7 +958,8 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n         \"\"\"\n         json_schema: JsonSchemaValue = {'type': 'object'}\n \n-        keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\n+        ks = schema['keys_schema'] if 'keys_schema' in schema else None",
      "comment": "```suggestion\r\n        keys_core_schema = schema.get('keys_schema')\r\n```",
      "comment_id": 1775335287,
      "user": "sydney-runkle",
      "created_at": "2024-09-25T14:24:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1775335287"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 977,
      "side": "RIGHT",
      "diff_hunk": "@@ -969,6 +970,11 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n             else:\n                 json_schema['patternProperties'] = {keys_pattern: values_schema}\n \n+        if ks is not None:\n+            keys_type = ks.get('type', None)\n+            if keys_type == 'enum':\n+                keys_members = ks.get('members', [])\n+                json_schema['propertyNames'] = {'enum': keys_members}",
      "comment": "I think we can add support for any key schema out of the box\r\n\r\n```suggestion\r\n        # Add `keys_schema.pop('title', None)` next to `values_schema.pop('title', None)` above and update comment\r\n        if keys_schema.get('type') == 'string' and len(keys_schema) > 1:  # len check means there are additional constraints to the key schema\r\n            json_schema['propertyNames'] = keys_schema\r\n```\r\n\r\n?",
      "comment_id": 1775446269,
      "user": "Viicos",
      "created_at": "2024-09-25T15:23:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1775446269"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 977,
      "side": "RIGHT",
      "diff_hunk": "@@ -969,6 +970,11 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n             else:\n                 json_schema['patternProperties'] = {keys_pattern: values_schema}\n \n+        if ks is not None:\n+            keys_type = ks.get('type', None)\n+            if keys_type == 'enum':\n+                keys_members = ks.get('members', [])\n+                json_schema['propertyNames'] = {'enum': keys_members}",
      "comment": "Thanks for the review and the suggestion :) Just for better understanding from my side:\r\nkeys_schema could be a ref only, which means that I would need to resolve that before I can do any checks on that, right?\r\nWould it then be best to add the ref to propertyNames schema, or the resolved one? I'll go with the resolved for now but am open for your inputs :)",
      "comment_id": 1775735466,
      "user": "FlorianSW",
      "created_at": "2024-09-25T18:06:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1775735466"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 977,
      "side": "RIGHT",
      "diff_hunk": "@@ -969,6 +970,11 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n             else:\n                 json_schema['patternProperties'] = {keys_pattern: values_schema}\n \n+        if ks is not None:\n+            keys_type = ks.get('type', None)\n+            if keys_type == 'enum':\n+                keys_members = ks.get('members', [])\n+                json_schema['propertyNames'] = {'enum': keys_members}",
      "comment": "While doing it, this will also add a propertyNames schema to an existing test case. This should be expected behaviour, as python's Path in json schema of pydantic has the ' format' 'path' schema.\r\n\r\nI just have to add this to the existing test case, and I'm not sure how such changes to existing behaviour is handled in pydantic tbh :)",
      "comment_id": 1775737055,
      "user": "FlorianSW",
      "created_at": "2024-09-25T18:07:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1775737055"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 968,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,17 +958,26 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n         \"\"\"\n         json_schema: JsonSchemaValue = {'type': 'object'}\n \n-        keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\n+        keys_core_schema = schema.get('keys_schema')\n+        keys_schema = self.resolve_schema_to_update(\n+            self.generate_inner(keys_core_schema).copy() if keys_core_schema is not None else {}\n+        )\n         keys_pattern = keys_schema.pop('pattern', None)\n \n         values_schema = self.generate_inner(schema['values_schema']).copy() if 'values_schema' in schema else {}\n-        values_schema.pop('title', None)  # don't give a title to the additionalProperties\n+        # don't give a title to additionalProperties and patternProperties",
      "comment": "```suggestion\r\n        # don't give a title to additionalProperties, patternProperties and propertyNames\r\n```",
      "comment_id": 1777102387,
      "user": "Viicos",
      "created_at": "2024-09-26T13:40:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1777102387"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 977,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,17 +958,26 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n         \"\"\"\n         json_schema: JsonSchemaValue = {'type': 'object'}\n \n-        keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\n+        keys_core_schema = schema.get('keys_schema')\n+        keys_schema = self.resolve_schema_to_update(\n+            self.generate_inner(keys_core_schema).copy() if keys_core_schema is not None else {}\n+        )\n         keys_pattern = keys_schema.pop('pattern', None)\n \n         values_schema = self.generate_inner(schema['values_schema']).copy() if 'values_schema' in schema else {}\n-        values_schema.pop('title', None)  # don't give a title to the additionalProperties\n+        # don't give a title to additionalProperties and patternProperties\n+        values_schema.pop('title', None)\n+        keys_schema.pop('title', None)\n         if values_schema or keys_pattern is not None:  # don't add additionalProperties if it's empty\n             if keys_pattern is None:\n                 json_schema['additionalProperties'] = values_schema\n             else:\n                 json_schema['patternProperties'] = {keys_pattern: values_schema}\n \n+        if keys_schema.get('type') == 'string' and len(keys_schema) > 1:",
      "comment": "```suggestion\r\n        # The len check indicates that constraints are probably present:\r\n        if keys_schema.get('type') == 'string' and len(keys_schema) > 1:\r\n```",
      "comment_id": 1777139182,
      "user": "Viicos",
      "created_at": "2024-09-26T14:00:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1777139182"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 977,
      "side": "RIGHT",
      "diff_hunk": "@@ -969,6 +970,11 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n             else:\n                 json_schema['patternProperties'] = {keys_pattern: values_schema}\n \n+        if ks is not None:\n+            keys_type = ks.get('type', None)\n+            if keys_type == 'enum':\n+                keys_members = ks.get('members', [])\n+                json_schema['propertyNames'] = {'enum': keys_members}",
      "comment": "Hum right, although I'm not sure schemas of type `'string'` can be made references? cc @sydney-runkle ",
      "comment_id": 1777176619,
      "user": "Viicos",
      "created_at": "2024-09-26T14:21:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1777176619"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 977,
      "side": "RIGHT",
      "diff_hunk": "@@ -969,6 +970,11 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n             else:\n                 json_schema['patternProperties'] = {keys_pattern: values_schema}\n \n+        if ks is not None:\n+            keys_type = ks.get('type', None)\n+            if keys_type == 'enum':\n+                keys_members = ks.get('members', [])\n+                json_schema['propertyNames'] = {'enum': keys_members}",
      "comment": "> While doing it, this will also add a propertyNames schema to an existing test case. This should be expected behaviour, as python's Path in json schema of pydantic has the ' format' 'path' schema.\r\n\r\nAgreed, this change looks correct to me. I second @Viicos' request for that additional test case with constrained dict keys.\r\n\r\n> Would it then be best to add the ref to propertyNames schema, or the resolved one? I'll go with the resolved for now but am open for your inputs :)\r\n\r\nRe refs - I think the current behavior makes sense. I haven't seen strings as references in JSON schemas yet. Maybe @adriangb has?",
      "comment_id": 1777258849,
      "user": "sydney-runkle",
      "created_at": "2024-09-26T14:56:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1777258849"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 977,
      "side": "RIGHT",
      "diff_hunk": "@@ -969,6 +970,11 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n             else:\n                 json_schema['patternProperties'] = {keys_pattern: values_schema}\n \n+        if ks is not None:\n+            keys_type = ks.get('type', None)\n+            if keys_type == 'enum':\n+                keys_members = ks.get('members', [])\n+                json_schema['propertyNames'] = {'enum': keys_members}",
      "comment": "> Would it then be best to add the ref to propertyNames schema, or the resolved one?\r\n\r\nLooked closer at this - I think we can avoid the ref resolution. Can change if it comes up for a specific use case.",
      "comment_id": 1779211437,
      "user": "sydney-runkle",
      "created_at": "2024-09-27T21:52:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1779211437"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 964,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,17 +958,27 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n         \"\"\"\n         json_schema: JsonSchemaValue = {'type': 'object'}\n \n-        keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\n+        keys_core_schema = schema.get('keys_schema')\n+        keys_schema = self.resolve_schema_to_update(\n+            self.generate_inner(keys_core_schema).copy() if keys_core_schema is not None else {}\n+        )",
      "comment": "```suggestion\r\n        self.generate_inner(keys_core_schema).copy() if keys_core_schema is not None else {}\r\n```",
      "comment_id": 1779212633,
      "user": "sydney-runkle",
      "created_at": "2024-09-27T21:53:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1779212633"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10478,
      "file_path": "pydantic/json_schema.py",
      "line": 962,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,17 +958,25 @@ def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n         \"\"\"\n         json_schema: JsonSchemaValue = {'type': 'object'}\n \n-        keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\n+        keys_core_schema = schema.get('keys_schema')\n+        self.generate_inner(keys_core_schema).copy() if keys_core_schema is not None else {}",
      "comment": "```suggestion\r\n        keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\r\n```\r\n\r\nWalking back my original suggestion, just because we don't need to use the `keys_core_schema` anywhere",
      "comment_id": 1779216591,
      "user": "sydney-runkle",
      "created_at": "2024-09-27T21:55:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/10478#discussion_r1779216591"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10441,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -138,6 +156,16 @@ def wrapped_model_post_init(self: BaseModel, context: Any, /) -> None:\n \n             cls: type[BaseModel] = super().__new__(mcs, cls_name, bases, namespace, **kwargs)  # type: ignore\n \n+            # check that this isn't RootModel\n+            if '__pydantic_root_model__' not in namespace:\n+                for method_name in pydantic_methods:\n+                    if method_name in namespace:\n+                        warnings.warn(\n+                            f'`{method_name}` is a pydantic method. Overriding this method in `{cls.__name__}` may lead to unexpected behavior.',\n+                            category=UserWarning,\n+                            stacklevel=2,\n+                        )",
      "comment": "I'm not sure having this warning is a good idea. Overriding methods from parent classes is a common practice, especially because we recommended users in the past to do so if they want to modify some default values of arguments.\r\n\r\nMy understanding was that we were going to warn only if methods are overridden by fields/vice-versa?",
      "comment_id": 1765555768,
      "user": "Viicos",
      "created_at": "2024-09-18T18:56:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10441#discussion_r1765555768"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10441,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -138,6 +156,16 @@ def wrapped_model_post_init(self: BaseModel, context: Any, /) -> None:\n \n             cls: type[BaseModel] = super().__new__(mcs, cls_name, bases, namespace, **kwargs)  # type: ignore\n \n+            # check that this isn't RootModel\n+            if '__pydantic_root_model__' not in namespace:\n+                for method_name in pydantic_methods:\n+                    if method_name in namespace:\n+                        warnings.warn(\n+                            f'`{method_name}` is a pydantic method. Overriding this method in `{cls.__name__}` may lead to unexpected behavior.',\n+                            category=UserWarning,\n+                            stacklevel=2,\n+                        )",
      "comment": "I'd be keen to skip warnings entirely, other than for the protected namespace.",
      "comment_id": 1765561839,
      "user": "sydney-runkle",
      "created_at": "2024-09-18T19:02:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10441#discussion_r1765561839"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10441,
      "file_path": "pydantic/_internal/_config.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -255,7 +255,7 @@ def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):\n     ser_json_inf_nan='null',\n     validate_default=False,\n     validate_return=False,\n-    protected_namespaces=('model_',),\n+    protected_namespaces=('model_validate_', 'model_dump_'),",
      "comment": "humm, what about `\r\n```suggestion\r\n    protected_namespaces=('model_validate', 'model_dump'),\r\n```\r\n\r\nso the warning still occur for `model_validate()` and `model_dum()` themselves with no more changes?\r\n\r\nif someone adds a field `model_validated` I feel like it's correct that we warn them.",
      "comment_id": 1770578206,
      "user": "samuelcolvin",
      "created_at": "2024-09-22T15:25:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10441#discussion_r1770578206"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10441,
      "file_path": "pydantic/config.py",
      "line": 613,
      "side": "RIGHT",
      "diff_hunk": "@@ -610,10 +610,14 @@ class Transaction(BaseModel):\n     protected_namespaces: tuple[str, ...]\n     \"\"\"\n     A `tuple` of strings that prevent model to have field which conflict with them.\n-    Defaults to `('model_', )`).\n+    Defaults to `('model_validate_', 'model_dump_')`).",
      "comment": "```suggestion\r\n    Defaults to `('model_validate', 'model_dump')`).\r\n```",
      "comment_id": 1773809396,
      "user": "sydney-runkle",
      "created_at": "2024-09-24T18:10:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10441#discussion_r1773809396"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10441,
      "file_path": "pydantic/_internal/_config.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -255,7 +255,7 @@ def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):\n     ser_json_inf_nan='null',\n     validate_default=False,\n     validate_return=False,\n-    protected_namespaces=('model_',),\n+    protected_namespaces=('model_validate', 'model_dump'),",
      "comment": "Would it make sense to also add `model_fields` here and all of the existing pydantic `model_` fields that would Raise a real conflict error prior to this change? An example of a collision here that could be confusing is:\r\n\r\n```py\r\n    class SomePydanticParentModel(BaseModel):\r\n        model_fields: dict = {\"bar\": \"baz\"}\r\n        model_config = ConfigDict(protected_namespaces=())\r\n\r\n    class SomePydanticChildModel(SomePydanticParentModel):\r\n        pass\r\n\r\n    parent_instance = SomePydanticParentModel()\r\n    # Passes, looks like model_fields is fine to use\r\n    assert parent_instance.model_fields == {\"bar\": \"baz\"}\r\n\r\n    child_instance = SomePydanticChildModel()\r\n    # Fails, and is somewhat surprising / confusing that the child doesn't inherit the field\r\n    # correctly from the parent \r\n    assert child_instance.model_fields == {\"bar\": \"baz\"}\r\n```",
      "comment_id": 1775350459,
      "user": "elidlocke",
      "created_at": "2024-09-25T14:32:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10441#discussion_r1775350459"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10441,
      "file_path": "pydantic/_internal/_config.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -255,7 +255,7 @@ def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):\n     ser_json_inf_nan='null',\n     validate_default=False,\n     validate_return=False,\n-    protected_namespaces=('model_',),\n+    protected_namespaces=('model_validate', 'model_dump'),",
      "comment": "Good question. I've addressed this concern via https://github.com/pydantic/pydantic/pull/10493 - `model_fields` and `model_computed_fields` now follow a pattern such that they can be overridden without internals breaking down.\r\n\r\nWe should get a warning when a field name shadows an attribute in the parent, like:\r\n\r\n```py\r\nfrom pydantic import BaseModel\r\n\r\nclass User(BaseModel):\r\n    id: int\r\n    name: str\r\n    model_fields: list[str]\r\n\r\nuser = User(id=1, name='John Doe', model_fields=['id', 'name'])\r\n\"\"\"\r\n/Users/programming/pydantic_work/pydantic/pydantic/_internal/_fields.py:190: UserWarning: Field name \"model_fields\" in \"User\" shadows an attribute in parent \"BaseModel\"\r\n  warnings.warn(\r\n\"\"\"\r\n```\r\n\r\nThus, I think we don't explicitly need to add these to the protected namespace block.",
      "comment_id": 1784593415,
      "user": "sydney-runkle",
      "created_at": "2024-10-02T14:04:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10441#discussion_r1784593415"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10441,
      "file_path": "pydantic/_internal/_config.py",
      "line": 276,
      "side": "RIGHT",
      "diff_hunk": "@@ -273,7 +273,7 @@ def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):\n     ser_json_inf_nan='null',\n     validate_default=False,\n     validate_return=False,\n-    protected_namespaces=('model_',),\n+    protected_namespaces=('model_validate', 'model_dump'),",
      "comment": "Following up here - we decided we didn't need to add `model_construct` - that's not a namespace we anticipate expanding in the same way we do for `model_dump_` etc, you can imagine `python`, `json`, `some_other_format`.",
      "comment_id": 1785029220,
      "user": "sydney-runkle",
      "created_at": "2024-10-02T18:17:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/10441#discussion_r1785029220"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10522,
      "file_path": "pydantic/_internal/_config.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,7 +77,7 @@ class ConfigWrapper:\n     # whether to validate default values during validation, default False\n     validate_default: bool\n     validate_return: bool\n-    protected_namespaces: tuple[str, ...]\n+    protected_namespaces: tuple[str | Pattern[str], ...]",
      "comment": "As we use future annotations, we can import `Pattern` from `re` instead",
      "comment_id": 1783315229,
      "user": "Viicos",
      "created_at": "2024-10-01T18:26:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10522#discussion_r1783315229"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10522,
      "file_path": "pydantic/config.py",
      "line": 675,
      "side": "RIGHT",
      "diff_hunk": "@@ -643,29 +645,38 @@ class Model(BaseModel):\n \n     You can customize this behavior using the `protected_namespaces` setting:\n \n-    ```py\n+    ```py test=\"skip\"\n+    import re\n     import warnings\n \n     from pydantic import BaseModel, ConfigDict\n \n-    warnings.filterwarnings('error')  # Raise warnings as errors\n-\n-    try:\n+    with warnings.catch_warnings(record=True) as caught_warnings:\n+        warnings.simplefilter('always')  # Catch all warnings\n \n         class Model(BaseModel):\n-            model_prefixed_field: str\n+            safe_field: str\n             also_protect_field: str\n+            protect_this: str\n \n             model_config = ConfigDict(\n-                protected_namespaces=('protect_me_', 'also_protect_')\n+                protected_namespaces=(\n+                    'protect_me_',\n+                    'also_protect_',\n+                    re.compile('^protect_this$'),\n+                )\n             )\n \n-    except UserWarning as e:\n-        print(e)\n+    for warning in caught_warnings:\n+        print(f'{warning.message}\\n')\n         '''\n         Field \"also_protect_field\" in Model has conflict with protected namespace \"also_protect_\".\n \n-        You may be able to resolve this warning by setting `model_config['protected_namespaces'] = ('protect_me_',)`.\n+        You may be able to resolve this warning by setting `model_config['protected_namespaces'] = ('protect_me_', '^protect_this$')`.",
      "comment": "```suggestion\r\n        You may be able to resolve this warning by setting `model_config['protected_namespaces'] = ('protect_me_', re.compile('^protect_this$'))`.\r\n```",
      "comment_id": 1783316095,
      "user": "Viicos",
      "created_at": "2024-10-01T18:27:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10522#discussion_r1783316095"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10522,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -121,8 +121,15 @@ def collect_model_fields(  # noqa: C901\n             # Note: we may need to change this logic if/when we introduce a `BareModel` class with no\n             # protected namespaces (where `model_config` might be allowed as a field name)\n             continue\n+\n         for protected_namespace in config_wrapper.protected_namespaces:\n-            if ann_name.startswith(protected_namespace):\n+            ns_violation: bool = False\n+            if isinstance(protected_namespace, Pattern):\n+                ns_violation = protected_namespace.match(ann_name) is not None",
      "comment": "Is `match` better than `fullmatch` here? I think `match` might be equally capable and more practical (don't need to include `.*` on the end to serve as a prefix match I guess), just want to make sure you've thought about it and decided to go with `match`.",
      "comment_id": 1783499676,
      "user": "dmontagu",
      "created_at": "2024-10-01T20:33:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/10522#discussion_r1783499676"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10522,
      "file_path": "pydantic/_internal/_config.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,7 +77,7 @@ class ConfigWrapper:\n     # whether to validate default values during validation, default False\n     validate_default: bool\n     validate_return: bool\n-    protected_namespaces: tuple[str, ...]\n+    protected_namespaces: tuple[str | Pattern[str], ...]",
      "comment": "Are we already importing `re` elsewhere, and/or is it fast to import? I'm concerned that importing `re` may add to startup time, but 1, we might be using it elsewhere, and 2, even if not I'm not quite sure how the isinstance check against `typing.Pattern` would work if it wasn't somehow importing `re` somewhere",
      "comment_id": 1783501118,
      "user": "dmontagu",
      "created_at": "2024-10-01T20:35:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10522#discussion_r1783501118"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10522,
      "file_path": "pydantic/_internal/_config.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,7 +77,7 @@ class ConfigWrapper:\n     # whether to validate default values during validation, default False\n     validate_default: bool\n     validate_return: bool\n-    protected_namespaces: tuple[str, ...]\n+    protected_namespaces: tuple[str | Pattern[str], ...]",
      "comment": "Nevermind, we definitely import `re` in lots of internals so that's a non-issue",
      "comment_id": 1783502210,
      "user": "dmontagu",
      "created_at": "2024-10-01T20:36:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10522#discussion_r1783502210"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10522,
      "file_path": "tests/mypy/modules/dataclass_no_any.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,3 +1,4 @@\n+from pydantic import ConfigDict",
      "comment": "```suggestion\r\n```\r\nIs that necessary any more? It looks unused now",
      "comment_id": 1783502793,
      "user": "dmontagu",
      "created_at": "2024-10-01T20:36:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10522#discussion_r1783502793"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10522,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -121,8 +121,15 @@ def collect_model_fields(  # noqa: C901\n             # Note: we may need to change this logic if/when we introduce a `BareModel` class with no\n             # protected namespaces (where `model_config` might be allowed as a field name)\n             continue\n+\n         for protected_namespace in config_wrapper.protected_namespaces:\n-            if ann_name.startswith(protected_namespace):\n+            ns_violation: bool = False\n+            if isinstance(protected_namespace, Pattern):\n+                ns_violation = protected_namespace.match(ann_name) is not None",
      "comment": "Good question - I think `match` is more practical, as you can use special characters (ex: `^<pattern>$`) to basically ensure `fullmatch` behavior, whereas `fullmatch` does that by default and thus offers less customizability \ud83d\udc4d ",
      "comment_id": 1784519779,
      "user": "sydney-runkle",
      "created_at": "2024-10-02T13:20:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10522#discussion_r1784519779"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10522,
      "file_path": "pydantic/_internal/_config.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,7 +77,7 @@ class ConfigWrapper:\n     # whether to validate default values during validation, default False\n     validate_default: bool\n     validate_return: bool\n-    protected_namespaces: tuple[str, ...]\n+    protected_namespaces: tuple[str | Pattern[str], ...]",
      "comment": "Nice, I didn't realize we had future annotations here. Changed!",
      "comment_id": 1784528764,
      "user": "sydney-runkle",
      "created_at": "2024-10-02T13:26:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/10522#discussion_r1784528764"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_config.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -75,6 +75,7 @@ class ConfigWrapper:\n     protected_namespaces: tuple[str, ...]\n     hide_input_in_errors: bool\n     defer_build: bool\n+    defer_build_mode: Literal['only_model', 'always']",
      "comment": "Could we call this `experimental_defer_build_mode` or `beta_defer_build_mode`? That way users are aware that there might be breaking changes in minor releases for this feature \ud83d\udc4d ",
      "comment_id": 1530459524,
      "user": "sydney-runkle",
      "created_at": "2024-03-19T14:14:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530459524"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 724,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,30 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`defer_build_mode`][pydantic.config.ConfigDict.defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes instead of construction being deferred.\n+        You also need to use [`defer_build_mode='always'`][pydantic.config.ConfigDict.defer_build_mode] with\n+        FastAPI models.",
      "comment": "I think the mention of FastAPI is helpful here, but we should probably explain that this is because of FastAPI's use of `TypeAdapter`s",
      "comment_id": 1530461295,
      "user": "sydney-runkle",
      "created_at": "2024-03-19T14:15:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530461295"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 735,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,30 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`defer_build_mode`][pydantic.config.ConfigDict.defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes instead of construction being deferred.\n+        You also need to use [`defer_build_mode='always'`][pydantic.config.ConfigDict.defer_build_mode] with\n+        FastAPI models.\n+    \"\"\"\n+\n+    defer_build_mode: Literal['only_model', 'always']\n+    \"\"\"\n+    Controls when [`defer_build`][pydantic.config.ConfigDict.defer_build] is applicable. Defaults to `'only_model'`.\n+\n+    Due to backwards compatibility reasons [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] does not by default\n+    respect `defer_build`. Meaning when `defer_build` is `True` and `defer_build_mode` is the default `'only_model'`\n+    then `TypeAdapter` immediately constructs validator and serializer instead of postponing it until the first model\n+    validation. Set this to `'always'` to make `TypeAdapter` respect the `defer_build` so it postpones validator and\n+    serializer construction until the first validation.",
      "comment": "Could we add a note in this part of the docs about the experimental nature, warning about potentially breaking changes?",
      "comment_id": 1530461962,
      "user": "sydney-runkle",
      "created_at": "2024-03-19T14:15:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530461962"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 735,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,30 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`defer_build_mode`][pydantic.config.ConfigDict.defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes instead of construction being deferred.\n+        You also need to use [`defer_build_mode='always'`][pydantic.config.ConfigDict.defer_build_mode] with\n+        FastAPI models.\n+    \"\"\"\n+\n+    defer_build_mode: Literal['only_model', 'always']\n+    \"\"\"\n+    Controls when [`defer_build`][pydantic.config.ConfigDict.defer_build] is applicable. Defaults to `'only_model'`.\n+\n+    Due to backwards compatibility reasons [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] does not by default\n+    respect `defer_build`. Meaning when `defer_build` is `True` and `defer_build_mode` is the default `'only_model'`\n+    then `TypeAdapter` immediately constructs validator and serializer instead of postponing it until the first model\n+    validation. Set this to `'always'` to make `TypeAdapter` respect the `defer_build` so it postpones validator and\n+    serializer construction until the first validation.",
      "comment": "Maybe something similar to https://docs.pydantic.dev/latest/api/type_adapter/ the `_parent_depth` note in the API docs...",
      "comment_id": 1530463035,
      "user": "sydney-runkle",
      "created_at": "2024-03-19T14:16:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530463035"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "tests/test_type_adapter.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,13 +2,14 @@\n import sys\n from dataclasses import dataclass\n from datetime import date, datetime\n-from typing import Any, Dict, ForwardRef, Generic, List, NamedTuple, Tuple, TypeVar, Union\n+from typing import Any, Dict, ForwardRef, Generic, List, NamedTuple, Optional, Tuple, TypeVar, Union\n \n import pytest\n from pydantic_core import ValidationError\n-from typing_extensions import Annotated, TypeAlias, TypedDict\n+from typing_extensions import Annotated, Literal, TypeAlias, TypedDict\n \n-from pydantic import BaseModel, TypeAdapter, ValidationInfo, field_validator\n+import pydantic",
      "comment": "Let's just import pydantic's `dataclass` directly instead of doing this catchall import",
      "comment_id": 1530464765,
      "user": "sydney-runkle",
      "created_at": "2024-03-19T14:17:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530464765"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 727,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,30 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`defer_build_mode`][pydantic.config.ConfigDict.defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes instead of construction being deferred.\n+        You also need to use [`defer_build_mode='always'`][pydantic.config.ConfigDict.defer_build_mode] with\n+        FastAPI models.\n+    \"\"\"\n+\n+    defer_build_mode: Literal['only_model', 'always']",
      "comment": "Hmm, I wonder if there's a more intuitive second option that we could use that explicitly mentions type adapters...",
      "comment_id": 1530471750,
      "user": "sydney-runkle",
      "created_at": "2024-03-19T14:20:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530471750"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "tests/test_type_adapter.py",
      "line": 382,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,3 +372,52 @@ def test_eval_type_backport():\n     assert exc_info.value.errors(include_url=False) == [\n         {'type': 'list_type', 'loc': (), 'msg': 'Input should be a valid list', 'input': 'not a list'}\n     ]\n+\n+\n+@pytest.mark.parametrize('defer_build', [False, True])\n+@pytest.mark.parametrize('defer_build_mode', ['only_model', 'always'])\n+@pytest.mark.parametrize('is_annotated', [False, True])  # FastAPI heavily uses Annotated\n+def test_respects_defer_build(\n+    defer_build: bool, defer_build_mode: Literal['only_model', 'always'], is_annotated: bool\n+) -> None:",
      "comment": "Test looks good overall, thanks for parametrizing to keep things concise!",
      "comment_id": 1530472779,
      "user": "sydney-runkle",
      "created_at": "2024-03-19T14:21:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530472779"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -118,6 +118,12 @@ class TypeAdapter(Generic[T]):\n \n     **Note:** `TypeAdapter` instances are not types, and cannot be used as type annotations for fields.\n \n+    **Note:** By default, `TypeAdapter` does not respect the\n+    [`defer_build=True`][pydantic.config.ConfigDict.defer_build] setting in the\n+    [`model_config`][pydantic.BaseModel.model_config] or in the `TypeAdapter` constructor `config`. You need to also\n+    explicitly set [`defer_build_mode=\"always\"`][pydantic.config.ConfigDict.defer_build_mode] of the config to defer\n+    the model validator and serializer construction. This is required due to backwards compatibility reasons.",
      "comment": "Maybe something a bit more positive like: `Thus, this feature is opt-in to ensure backwards compatibility`",
      "comment_id": 1530475437,
      "user": "sydney-runkle",
      "created_at": "2024-03-19T14:22:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530475437"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_config.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -75,6 +75,7 @@ class ConfigWrapper:\n     protected_namespaces: tuple[str, ...]\n     hide_input_in_errors: bool\n     defer_build: bool\n+    defer_build_mode: Literal['only_model', 'always']",
      "comment": "I see there is another experimental feature in TypeAdapter, the `_parent_depth`. Should this be also underscore prefixed as `_defer_build_mode`?",
      "comment_id": 1530910427,
      "user": "MarkusSintonen",
      "created_at": "2024-03-19T18:41:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530910427"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 727,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,30 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`defer_build_mode`][pydantic.config.ConfigDict.defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes instead of construction being deferred.\n+        You also need to use [`defer_build_mode='always'`][pydantic.config.ConfigDict.defer_build_mode] with\n+        FastAPI models.\n+    \"\"\"\n+\n+    defer_build_mode: Literal['only_model', 'always']",
      "comment": "Another option would be to make it a `tuple[Literal['model', 'type_adapter'], ...]` instead of it being `Literal['model', 'model_and_type_adapter']` \ud83e\udd14 ",
      "comment_id": 1530936605,
      "user": "MarkusSintonen",
      "created_at": "2024-03-19T19:01:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530936605"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 727,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,30 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`defer_build_mode`][pydantic.config.ConfigDict.defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes instead of construction being deferred.\n+        You also need to use [`defer_build_mode='always'`][pydantic.config.ConfigDict.defer_build_mode] with\n+        FastAPI models.\n+    \"\"\"\n+\n+    defer_build_mode: Literal['only_model', 'always']",
      "comment": "Or `set[Literal['model', 'type_adapter']]`\r\n\r\nWDYT?",
      "comment_id": 1530940526,
      "user": "MarkusSintonen",
      "created_at": "2024-03-19T19:04:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530940526"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_config.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -75,6 +75,7 @@ class ConfigWrapper:\n     protected_namespaces: tuple[str, ...]\n     hide_input_in_errors: bool\n     defer_build: bool\n+    defer_build_mode: Literal['only_model', 'always']",
      "comment": "I now pushed `_defer_build_mode` similar to `_parent_depth` experimental TypeAdapter parameter",
      "comment_id": 1530956530,
      "user": "MarkusSintonen",
      "created_at": "2024-03-19T19:18:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530956530"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 727,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,30 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`defer_build_mode`][pydantic.config.ConfigDict.defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes instead of construction being deferred.\n+        You also need to use [`defer_build_mode='always'`][pydantic.config.ConfigDict.defer_build_mode] with\n+        FastAPI models.\n+    \"\"\"\n+\n+    defer_build_mode: Literal['only_model', 'always']",
      "comment": "I now went with `tuple[Literal['model', 'type_adapter'], ...]`",
      "comment_id": 1530981522,
      "user": "MarkusSintonen",
      "created_at": "2024-03-19T19:41:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1530981522"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 727,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,30 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`defer_build_mode`][pydantic.config.ConfigDict.defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes instead of construction being deferred.\n+        You also need to use [`defer_build_mode='always'`][pydantic.config.ConfigDict.defer_build_mode] with\n+        FastAPI models.\n+    \"\"\"\n+\n+    defer_build_mode: Literal['only_model', 'always']",
      "comment": "The caveat with this is that user could remove the `model` from tuple \ud83d\ude05 So either we somewhere validate that `model` must be present or support skipping defer building of model in that case \ud83d\ude05 Another option is to instead have `_defer_build_additional: tuple['type_adapter'] | None` ",
      "comment_id": 1531521564,
      "user": "MarkusSintonen",
      "created_at": "2024-03-20T05:19:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1531521564"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 724,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,34 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`_defer_build_mode`][pydantic.config.ConfigDict._defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes. You also need to define\n+        [`_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict._defer_build_mode] with FastAPI\n+        models. This parameter is required for the deferred building due to FastAPI relying on `TypeAdapter`s.",
      "comment": "```suggestion\r\n        `defer_build` does not work by default with FastAPI Pydantic models. By default, the validator and serializer\r\n        for said models is constructed immediately for FastAPI routes. You also need to define\r\n        [`_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict._defer_build_mode] with FastAPI\r\n        models in order for `defer_build=True` to take effect. This additional (experimental) parameter is required for the deferred building due to FastAPI relying on `TypeAdapter`s.\r\n```",
      "comment_id": 1533135911,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:42:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533135911"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 724,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,34 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`_defer_build_mode`][pydantic.config.ConfigDict._defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes. You also need to define\n+        [`_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict._defer_build_mode] with FastAPI\n+        models. This parameter is required for the deferred building due to FastAPI relying on `TypeAdapter`s.",
      "comment": "Doesn't have to be exactly these changes, but maybe something along those lines?",
      "comment_id": 1533136448,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:42:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533136448"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 728,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,34 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`_defer_build_mode`][pydantic.config.ConfigDict._defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes. You also need to define\n+        [`_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict._defer_build_mode] with FastAPI\n+        models. This parameter is required for the deferred building due to FastAPI relying on `TypeAdapter`s.\n+    \"\"\"\n+\n+    _defer_build_mode: tuple[Literal['model', 'type_adapter'], ...]",
      "comment": "I like this change! Definitely feels more intuitive :). Thanks!",
      "comment_id": 1533137233,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:42:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533137233"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 733,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,34 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`_defer_build_mode`][pydantic.config.ConfigDict._defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes. You also need to define\n+        [`_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict._defer_build_mode] with FastAPI\n+        models. This parameter is required for the deferred building due to FastAPI relying on `TypeAdapter`s.\n+    \"\"\"\n+\n+    _defer_build_mode: tuple[Literal['model', 'type_adapter'], ...]\n+    \"\"\"\n+    Controls when [`defer_build`][pydantic.config.ConfigDict.defer_build] is applicable. Defaults to `('model',)`.\n+\n+    Due to backwards compatibility reasons [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] does not by default\n+    respect `defer_build`. Meaning when `defer_build` is `True` and `_defer_build_mode` is the default `('model',)`\n+    then `TypeAdapter` immediately constructs validator and serializer instead of postponing it until the first model",
      "comment": "```suggestion\r\n    then `TypeAdapter` immediately constructs its validator and serializer instead of postponing said construction until the first model\r\n```",
      "comment_id": 1533137643,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:43:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533137643"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 735,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,34 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`_defer_build_mode`][pydantic.config.ConfigDict._defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes. You also need to define\n+        [`_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict._defer_build_mode] with FastAPI\n+        models. This parameter is required for the deferred building due to FastAPI relying on `TypeAdapter`s.\n+    \"\"\"\n+\n+    _defer_build_mode: tuple[Literal['model', 'type_adapter'], ...]\n+    \"\"\"\n+    Controls when [`defer_build`][pydantic.config.ConfigDict.defer_build] is applicable. Defaults to `('model',)`.\n+\n+    Due to backwards compatibility reasons [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] does not by default\n+    respect `defer_build`. Meaning when `defer_build` is `True` and `_defer_build_mode` is the default `('model',)`\n+    then `TypeAdapter` immediately constructs validator and serializer instead of postponing it until the first model\n+    validation. Set this to `('model', 'type_adapter')` to make `TypeAdapter` respect the `defer_build` so it postpones\n+    validator and serializer construction until the first validation.",
      "comment": "What about `first serialization`? Ex, if you used `defer_build=True` and `_defer_build_mode=('model', 'type_adapter')`, but then used the `TypeAdapter` for the first time to `dump_json` or something like that.\r\n\r\nWe should probably write a test to confirm that this works, and then also update the docs accordingly!",
      "comment_id": 1533138331,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:44:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533138331"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 739,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,34 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`_defer_build_mode`][pydantic.config.ConfigDict._defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes. You also need to define\n+        [`_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict._defer_build_mode] with FastAPI\n+        models. This parameter is required for the deferred building due to FastAPI relying on `TypeAdapter`s.\n+    \"\"\"\n+\n+    _defer_build_mode: tuple[Literal['model', 'type_adapter'], ...]\n+    \"\"\"\n+    Controls when [`defer_build`][pydantic.config.ConfigDict.defer_build] is applicable. Defaults to `('model',)`.\n+\n+    Due to backwards compatibility reasons [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] does not by default\n+    respect `defer_build`. Meaning when `defer_build` is `True` and `_defer_build_mode` is the default `('model',)`\n+    then `TypeAdapter` immediately constructs validator and serializer instead of postponing it until the first model\n+    validation. Set this to `('model', 'type_adapter')` to make `TypeAdapter` respect the `defer_build` so it postpones\n+    validator and serializer construction until the first validation.\n+\n+    !!! note\n+        The `_defer_build_mode` parameter is named with an underscore to suggest this is an experimental feature. It may\n+        be removed or changed in the future.",
      "comment": "Nice. One small nit, maybe add that it might be removed / changed in the future, which could include minor releases (we usually try not to implement breaking changes at all, but especially not in minor releases)",
      "comment_id": 1533138760,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:45:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533138760"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "tests/test_type_adapter.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,3 +372,54 @@ def test_eval_type_backport():\n     assert exc_info.value.errors(include_url=False) == [\n         {'type': 'list_type', 'loc': (), 'msg': 'Input should be a valid list', 'input': 'not a list'}\n     ]\n+\n+\n+@pytest.mark.parametrize('defer_build', [False, True])\n+@pytest.mark.parametrize('defer_build_mode', [('model',), ('type_adapter',), ('model', 'type_adapter')])\n+@pytest.mark.parametrize('is_annotated', [False, True])  # FastAPI heavily uses Annotated\n+def test_respects_defer_build(\n+    defer_build: bool, defer_build_mode: Tuple[Literal['model', 'type_adapter']], is_annotated: bool\n+) -> None:\n+    class Model(BaseModel, defer_build=defer_build, _defer_build_mode=defer_build_mode):\n+        x: int\n+\n+    class SubModel(Model):\n+        y: Optional[int] = None\n+\n+    @pydantic_dataclass(config=ConfigDict(defer_build=defer_build, _defer_build_mode=defer_build_mode))\n+    class DataClassModel:\n+        x: int\n+\n+    @pydantic_dataclass\n+    class SubDataClassModel(DataClassModel):\n+        y: Optional[int] = None\n+\n+    class TypedDictModel(TypedDict):\n+        __pydantic_config__ = ConfigDict(defer_build=defer_build, _defer_build_mode=defer_build_mode)  # type: ignore\n+        x: int\n+\n+    models: list[tuple[type, Optional[ConfigDict]]] = [\n+        (Model, None),\n+        (SubModel, None),\n+        (create_model('DynamicModel', __base__=Model), None),\n+        (create_model('DynamicSubModel', __base__=SubModel), None),\n+        (DataClassModel, None),\n+        (SubDataClassModel, None),\n+        (TypedDictModel, None),\n+        (Dict[str, int], ConfigDict(defer_build=defer_build, _defer_build_mode=defer_build_mode)),\n+    ]\n+\n+    for model, adapter_config in models:\n+        tested_model = Annotated[model, Field(title='abc')] if is_annotated else model\n+\n+        ta = TypeAdapter(tested_model, config=adapter_config)\n+        if defer_build and 'type_adapter' in defer_build_mode:\n+            assert not ta._schema_initialized, f'{tested_model} should be built deferred'\n+        else:\n+            assert ta._schema_initialized\n+\n+        validated = ta.validate_python({'x': 1})  # Sanity check it works",
      "comment": "As mentioned, could we add a sanity check that the defer build works as well in the case where serialization is the first method called on a `TypeAdapter`?",
      "comment_id": 1533140375,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:48:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533140375"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,35 +211,75 @@ def __init__(\n                 code='type-adapter-config-unused',\n             )\n \n-        config_wrapper = _config.ConfigWrapper(config)\n-\n-        core_schema: CoreSchema\n+        self._type = type\n+        self._config_wrapper = _config.ConfigWrapper(config)\n+        self._parent_depth = _parent_depth\n+        if module is None:\n+            f = sys._getframe(1)\n+            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n+        else:\n+            self._module_name = module\n+\n+        self._schema_initialized = False\n+        if not self._defer_build(type, config):\n+            # Immediately initialize the core schema, validator and serializer\n+            _, _, _ = (self.core_schema, self.validator, self.serializer)\n+\n+    @cached_property\n+    def core_schema(self) -> CoreSchema:\n+        \"\"\"Core schema\"\"\"\n         try:\n-            core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\n+            return _getattr_no_parents(self._type, '__pydantic_core_schema__')\n         except AttributeError:\n-            core_schema = _get_schema(type, config_wrapper, parent_depth=_parent_depth + 1)\n+            return _get_schema(self._type, self._config_wrapper, parent_depth=self._parent_depth + 3)\n+        finally:\n+            self._schema_initialized = True\n \n-        core_config = config_wrapper.core_config(None)\n-        validator: SchemaValidator\n+    @cached_property\n+    def validator(self) -> SchemaValidator:\n+        \"\"\"Validator\"\"\"",
      "comment": "Let's use slightly more descriptive comments here, just to be consistent with the more verbose comments in modules like `main.py`: https://github.com/pydantic/pydantic/blob/a3b7214a1d6ac8e32c29e9d4436ea6a9e253ead7/pydantic/main.py#L85-L86",
      "comment_id": 1533144364,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:56:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533144364"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 297,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,35 +211,75 @@ def __init__(\n                 code='type-adapter-config-unused',\n             )\n \n-        config_wrapper = _config.ConfigWrapper(config)\n-\n-        core_schema: CoreSchema\n+        self._type = type\n+        self._config_wrapper = _config.ConfigWrapper(config)\n+        self._parent_depth = _parent_depth\n+        if module is None:\n+            f = sys._getframe(1)\n+            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n+        else:\n+            self._module_name = module\n+\n+        self._schema_initialized = False\n+        if not self._defer_build(type, config):\n+            # Immediately initialize the core schema, validator and serializer\n+            _, _, _ = (self.core_schema, self.validator, self.serializer)\n+\n+    @cached_property\n+    def core_schema(self) -> CoreSchema:\n+        \"\"\"Core schema\"\"\"\n         try:\n-            core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\n+            return _getattr_no_parents(self._type, '__pydantic_core_schema__')\n         except AttributeError:\n-            core_schema = _get_schema(type, config_wrapper, parent_depth=_parent_depth + 1)\n+            return _get_schema(self._type, self._config_wrapper, parent_depth=self._parent_depth + 3)\n+        finally:\n+            self._schema_initialized = True\n \n-        core_config = config_wrapper.core_config(None)\n-        validator: SchemaValidator\n+    @cached_property\n+    def validator(self) -> SchemaValidator:\n+        \"\"\"Validator\"\"\"\n         try:\n-            validator = _getattr_no_parents(type, '__pydantic_validator__')\n+            return _getattr_no_parents(self._type, '__pydantic_validator__')\n         except AttributeError:\n-            if module is None:\n-                f = sys._getframe(1)\n-                module = cast(str, f.f_globals.get('__name__', ''))\n-            validator = create_schema_validator(\n-                core_schema, type, module, str(type), 'TypeAdapter', core_config, config_wrapper.plugin_settings\n-            )  # type: ignore\n-\n-        serializer: SchemaSerializer\n+            return create_schema_validator(\n+                schema=self.core_schema,\n+                schema_type=self._type,\n+                schema_type_module=self._module_name,\n+                schema_type_name=str(self._type),\n+                schema_kind='TypeAdapter',\n+                config=self._core_config,\n+                plugin_settings=self._config_wrapper.plugin_settings,\n+            )\n+\n+    @cached_property\n+    def serializer(self) -> SchemaSerializer:\n+        \"\"\"Serializer\"\"\"\n         try:\n-            serializer = _getattr_no_parents(type, '__pydantic_serializer__')\n+            return _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n-            serializer = SchemaSerializer(core_schema, core_config)\n+            return SchemaSerializer(self.core_schema, self._core_config)\n+\n+    @classmethod\n+    def _defer_build(cls, type_: Any, type_adapter_config: ConfigDict | None) -> bool:\n+        config = type_adapter_config if type_adapter_config is not None else cls._model_config(type_)\n+        return cls._is_defer_build_config(config) if config is not None else False\n+\n+    @classmethod\n+    def _model_config(cls, type_: Any) -> ConfigDict | None:\n+        src_type: Any = (\n+            get_args(type_)[0] if _typing_extra.is_annotated(type_) else type_  # FastAPI heavily uses Annotated\n+        )\n+        if _utils.lenient_issubclass(src_type, BaseModel):\n+            return src_type.model_config\n+        return getattr(src_type, '__pydantic_config__', None)\n+\n+    @classmethod\n+    def _is_defer_build_config(cls, config: ConfigDict) -> bool:\n+        return config.get('defer_build', False) is True and 'type_adapter' in config.get('_defer_build_mode', tuple())",
      "comment": "This is simple enough that I think we could just include this logic in the `_defer_build` method (or at least make it a static method)",
      "comment_id": 1533145092,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:58:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533145092"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 274,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,35 +211,75 @@ def __init__(\n                 code='type-adapter-config-unused',\n             )\n \n-        config_wrapper = _config.ConfigWrapper(config)\n-\n-        core_schema: CoreSchema\n+        self._type = type\n+        self._config_wrapper = _config.ConfigWrapper(config)\n+        self._parent_depth = _parent_depth\n+        if module is None:\n+            f = sys._getframe(1)\n+            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n+        else:\n+            self._module_name = module\n+\n+        self._schema_initialized = False\n+        if not self._defer_build(type, config):\n+            # Immediately initialize the core schema, validator and serializer\n+            _, _, _ = (self.core_schema, self.validator, self.serializer)\n+\n+    @cached_property\n+    def core_schema(self) -> CoreSchema:\n+        \"\"\"Core schema\"\"\"\n         try:\n-            core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\n+            return _getattr_no_parents(self._type, '__pydantic_core_schema__')\n         except AttributeError:\n-            core_schema = _get_schema(type, config_wrapper, parent_depth=_parent_depth + 1)\n+            return _get_schema(self._type, self._config_wrapper, parent_depth=self._parent_depth + 3)\n+        finally:\n+            self._schema_initialized = True\n \n-        core_config = config_wrapper.core_config(None)\n-        validator: SchemaValidator\n+    @cached_property\n+    def validator(self) -> SchemaValidator:\n+        \"\"\"Validator\"\"\"\n         try:\n-            validator = _getattr_no_parents(type, '__pydantic_validator__')\n+            return _getattr_no_parents(self._type, '__pydantic_validator__')\n         except AttributeError:\n-            if module is None:\n-                f = sys._getframe(1)\n-                module = cast(str, f.f_globals.get('__name__', ''))\n-            validator = create_schema_validator(\n-                core_schema, type, module, str(type), 'TypeAdapter', core_config, config_wrapper.plugin_settings\n-            )  # type: ignore\n-\n-        serializer: SchemaSerializer\n+            return create_schema_validator(\n+                schema=self.core_schema,\n+                schema_type=self._type,\n+                schema_type_module=self._module_name,\n+                schema_type_name=str(self._type),\n+                schema_kind='TypeAdapter',\n+                config=self._core_config,\n+                plugin_settings=self._config_wrapper.plugin_settings,\n+            )\n+\n+    @cached_property\n+    def serializer(self) -> SchemaSerializer:\n+        \"\"\"Serializer\"\"\"\n         try:\n-            serializer = _getattr_no_parents(type, '__pydantic_serializer__')\n+            return _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n-            serializer = SchemaSerializer(core_schema, core_config)\n+            return SchemaSerializer(self.core_schema, self._core_config)\n+\n+    @classmethod\n+    def _defer_build(cls, type_: Any, type_adapter_config: ConfigDict | None) -> bool:\n+        config = type_adapter_config if type_adapter_config is not None else cls._model_config(type_)\n+        return cls._is_defer_build_config(config) if config is not None else False\n+\n+    @classmethod\n+    def _model_config(cls, type_: Any) -> ConfigDict | None:\n+        src_type: Any = (\n+            get_args(type_)[0] if _typing_extra.is_annotated(type_) else type_  # FastAPI heavily uses Annotated\n+        )\n+        if _utils.lenient_issubclass(src_type, BaseModel):\n+            return src_type.model_config\n+        return getattr(src_type, '__pydantic_config__', None)",
      "comment": "Same as below, I don't think a `staticmethod` would suffice",
      "comment_id": 1533146011,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T01:59:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533146011"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 263,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,35 +211,75 @@ def __init__(\n                 code='type-adapter-config-unused',\n             )\n \n-        config_wrapper = _config.ConfigWrapper(config)\n-\n-        core_schema: CoreSchema\n+        self._type = type\n+        self._config_wrapper = _config.ConfigWrapper(config)\n+        self._parent_depth = _parent_depth\n+        if module is None:\n+            f = sys._getframe(1)\n+            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n+        else:\n+            self._module_name = module\n+\n+        self._schema_initialized = False\n+        if not self._defer_build(type, config):\n+            # Immediately initialize the core schema, validator and serializer\n+            _, _, _ = (self.core_schema, self.validator, self.serializer)\n+\n+    @cached_property\n+    def core_schema(self) -> CoreSchema:\n+        \"\"\"Core schema\"\"\"\n         try:\n-            core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\n+            return _getattr_no_parents(self._type, '__pydantic_core_schema__')\n         except AttributeError:\n-            core_schema = _get_schema(type, config_wrapper, parent_depth=_parent_depth + 1)\n+            return _get_schema(self._type, self._config_wrapper, parent_depth=self._parent_depth + 3)\n+        finally:\n+            self._schema_initialized = True\n \n-        core_config = config_wrapper.core_config(None)\n-        validator: SchemaValidator\n+    @cached_property\n+    def validator(self) -> SchemaValidator:\n+        \"\"\"Validator\"\"\"\n         try:\n-            validator = _getattr_no_parents(type, '__pydantic_validator__')\n+            return _getattr_no_parents(self._type, '__pydantic_validator__')\n         except AttributeError:\n-            if module is None:\n-                f = sys._getframe(1)\n-                module = cast(str, f.f_globals.get('__name__', ''))\n-            validator = create_schema_validator(\n-                core_schema, type, module, str(type), 'TypeAdapter', core_config, config_wrapper.plugin_settings\n-            )  # type: ignore\n-\n-        serializer: SchemaSerializer\n+            return create_schema_validator(\n+                schema=self.core_schema,\n+                schema_type=self._type,\n+                schema_type_module=self._module_name,\n+                schema_type_name=str(self._type),\n+                schema_kind='TypeAdapter',\n+                config=self._core_config,\n+                plugin_settings=self._config_wrapper.plugin_settings,\n+            )\n+\n+    @cached_property\n+    def serializer(self) -> SchemaSerializer:\n+        \"\"\"Serializer\"\"\"\n         try:\n-            serializer = _getattr_no_parents(type, '__pydantic_serializer__')\n+            return _getattr_no_parents(self._type, '__pydantic_serializer__')\n         except AttributeError:\n-            serializer = SchemaSerializer(core_schema, core_config)\n+            return SchemaSerializer(self.core_schema, self._core_config)\n+\n+    @classmethod\n+    def _defer_build(cls, type_: Any, type_adapter_config: ConfigDict | None) -> bool:",
      "comment": "Why not use `self._type` and self._config_wrapper`?",
      "comment_id": 1533146186,
      "user": "sydney-runkle",
      "created_at": "2024-03-21T02:00:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533146186"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,35 +211,75 @@ def __init__(\n                 code='type-adapter-config-unused',\n             )\n \n-        config_wrapper = _config.ConfigWrapper(config)\n-\n-        core_schema: CoreSchema\n+        self._type = type\n+        self._config_wrapper = _config.ConfigWrapper(config)\n+        self._parent_depth = _parent_depth\n+        if module is None:\n+            f = sys._getframe(1)\n+            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n+        else:\n+            self._module_name = module\n+\n+        self._schema_initialized = False\n+        if not self._defer_build(type, config):\n+            # Immediately initialize the core schema, validator and serializer\n+            _, _, _ = (self.core_schema, self.validator, self.serializer)\n+\n+    @cached_property\n+    def core_schema(self) -> CoreSchema:\n+        \"\"\"Core schema\"\"\"\n         try:\n-            core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\n+            return _getattr_no_parents(self._type, '__pydantic_core_schema__')\n         except AttributeError:\n-            core_schema = _get_schema(type, config_wrapper, parent_depth=_parent_depth + 1)\n+            return _get_schema(self._type, self._config_wrapper, parent_depth=self._parent_depth + 3)",
      "comment": "`_parent_depth` needs to point to the caller module. So now its 2 more levels (from `@cached_property` + `core_schema`).\r\n\r\nThere is a test that checks its correctly defined.\r\n\r\nAlso now I noticed there was an issue with the `_parent_depth` and defer building which is now fixed in latest changes. Also added a test against it.\r\n\r\nAlso the forward ref resolving via `_parent_depth` wont necessarily work with deferred building, depending on where the user calls the TypeAdapter interfaces. (Same limitation probably applied to normal deferred models also)",
      "comment_id": 1533958203,
      "user": "MarkusSintonen",
      "created_at": "2024-03-21T13:53:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533958203"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "tests/test_type_adapter.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,3 +372,54 @@ def test_eval_type_backport():\n     assert exc_info.value.errors(include_url=False) == [\n         {'type': 'list_type', 'loc': (), 'msg': 'Input should be a valid list', 'input': 'not a list'}\n     ]\n+\n+\n+@pytest.mark.parametrize('defer_build', [False, True])\n+@pytest.mark.parametrize('defer_build_mode', [('model',), ('type_adapter',), ('model', 'type_adapter')])\n+@pytest.mark.parametrize('is_annotated', [False, True])  # FastAPI heavily uses Annotated\n+def test_respects_defer_build(\n+    defer_build: bool, defer_build_mode: Tuple[Literal['model', 'type_adapter']], is_annotated: bool\n+) -> None:\n+    class Model(BaseModel, defer_build=defer_build, _defer_build_mode=defer_build_mode):\n+        x: int\n+\n+    class SubModel(Model):\n+        y: Optional[int] = None\n+\n+    @pydantic_dataclass(config=ConfigDict(defer_build=defer_build, _defer_build_mode=defer_build_mode))\n+    class DataClassModel:\n+        x: int\n+\n+    @pydantic_dataclass\n+    class SubDataClassModel(DataClassModel):\n+        y: Optional[int] = None\n+\n+    class TypedDictModel(TypedDict):\n+        __pydantic_config__ = ConfigDict(defer_build=defer_build, _defer_build_mode=defer_build_mode)  # type: ignore\n+        x: int\n+\n+    models: list[tuple[type, Optional[ConfigDict]]] = [\n+        (Model, None),\n+        (SubModel, None),\n+        (create_model('DynamicModel', __base__=Model), None),\n+        (create_model('DynamicSubModel', __base__=SubModel), None),\n+        (DataClassModel, None),\n+        (SubDataClassModel, None),\n+        (TypedDictModel, None),\n+        (Dict[str, int], ConfigDict(defer_build=defer_build, _defer_build_mode=defer_build_mode)),\n+    ]\n+\n+    for model, adapter_config in models:\n+        tested_model = Annotated[model, Field(title='abc')] if is_annotated else model\n+\n+        ta = TypeAdapter(tested_model, config=adapter_config)\n+        if defer_build and 'type_adapter' in defer_build_mode:\n+            assert not ta._schema_initialized, f'{tested_model} should be built deferred'\n+        else:\n+            assert ta._schema_initialized\n+\n+        validated = ta.validate_python({'x': 1})  # Sanity check it works",
      "comment": "Done, added tests for serialization/validation also",
      "comment_id": 1533979449,
      "user": "MarkusSintonen",
      "created_at": "2024-03-21T14:05:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533979449"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 728,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,34 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`_defer_build_mode`][pydantic.config.ConfigDict._defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes. You also need to define\n+        [`_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict._defer_build_mode] with FastAPI\n+        models. This parameter is required for the deferred building due to FastAPI relying on `TypeAdapter`s.\n+    \"\"\"\n+\n+    _defer_build_mode: tuple[Literal['model', 'type_adapter'], ...]",
      "comment": "We probably need to somewhere validate that user can not give just `_defer_build_mode: ('type_adapter',)` as that wont have any effect. Well its experimental... :D ",
      "comment_id": 1533982411,
      "user": "MarkusSintonen",
      "created_at": "2024-03-21T14:06:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1533982411"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/config.py",
      "line": 728,
      "side": "RIGHT",
      "diff_hunk": "@@ -709,11 +709,34 @@ class Model(BaseModel):\n \n     defer_build: bool\n     \"\"\"\n-    Whether to defer model validator and serializer construction until the first model validation.\n+    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n \n     This can be useful to avoid the overhead of building models which are only\n     used nested within other models, or when you want to manually define type namespace via\n-    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild]. Defaults to False.\n+    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n+\n+    See also [`_defer_build_mode`][pydantic.config.ConfigDict._defer_build_mode].\n+\n+    !!! note\n+        `defer_build` does not work by default with FastAPI Pydantic models. Meaning the validator and serializer\n+        is constructed immediately when the model is used in FastAPI routes. You also need to define\n+        [`_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict._defer_build_mode] with FastAPI\n+        models. This parameter is required for the deferred building due to FastAPI relying on `TypeAdapter`s.\n+    \"\"\"\n+\n+    _defer_build_mode: tuple[Literal['model', 'type_adapter'], ...]",
      "comment": "Just added the simple check for `model`-case also as there is just the single place needing it (and added the tests)",
      "comment_id": 1534617090,
      "user": "MarkusSintonen",
      "created_at": "2024-03-21T20:13:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1534617090"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "tests/test_config.py",
      "line": 763,
      "side": "RIGHT",
      "diff_hunk": "@@ -701,54 +703,132 @@ def test_json_encoders_type_adapter() -> None:\n     assert json.loads(ta.dump_json(1)) == '2'\n \n \n-def test_config_model_defer_build():\n-    class MyModel(BaseModel, defer_build=True):\n+@pytest.mark.parametrize('defer_build_mode', [None, tuple(), ('model',), ('type_adapter',), ('model', 'type_adapter')])\n+def test_config_model_defer_build(\n+    defer_build_mode: Optional[Tuple[Literal['model', 'type_adapter'], ...]], generate_schema_calls: CallCounter\n+):\n+    config = ConfigDict(defer_build=True)\n+    if defer_build_mode is not None:\n+        config['_defer_build_mode'] = defer_build_mode\n+\n+    class MyModel(BaseModel):\n+        model_config = config\n         x: int\n \n-    assert isinstance(MyModel.__pydantic_validator__, MockValSer)\n-    assert isinstance(MyModel.__pydantic_serializer__, MockValSer)\n+    if defer_build_mode is None or 'model' in defer_build_mode:\n+        assert isinstance(MyModel.__pydantic_validator__, MockValSer)\n+        assert isinstance(MyModel.__pydantic_serializer__, MockValSer)\n+        assert generate_schema_calls.count == 0, 'Should respect _defer_build_mode'\n+    else:\n+        assert isinstance(MyModel.__pydantic_validator__, SchemaValidator)\n+        assert isinstance(MyModel.__pydantic_serializer__, SchemaSerializer)\n+        assert generate_schema_calls.count == 1, 'Should respect _defer_build_mode'\n \n     m = MyModel(x=1)\n     assert m.x == 1\n+    assert m.model_dump()['x'] == 1\n+    assert m.model_validate({'x': 2}).x == 2\n+    assert m.model_json_schema()['type'] == 'object'\n \n     assert isinstance(MyModel.__pydantic_validator__, SchemaValidator)\n     assert isinstance(MyModel.__pydantic_serializer__, SchemaSerializer)\n+    assert generate_schema_calls.count == 1, 'Should not build duplicated core schemas'\n \n \n-def test_config_type_adapter_defer_build():\n-    class MyModel(BaseModel, defer_build=True):\n+@pytest.mark.parametrize('defer_build_mode', [None, tuple(), ('model',), ('type_adapter',), ('model', 'type_adapter')])\n+def test_config_model_type_adapter_defer_build(\n+    defer_build_mode: Optional[Tuple[Literal['model', 'type_adapter'], ...]], generate_schema_calls: CallCounter\n+):\n+    config = ConfigDict(defer_build=True)\n+    if defer_build_mode is not None:\n+        config['_defer_build_mode'] = defer_build_mode\n+\n+    class MyModel(BaseModel):\n+        model_config = config\n         x: int\n \n+    is_deferred = defer_build_mode is None or 'model' in defer_build_mode\n+    assert generate_schema_calls.count == (0 if is_deferred else 1)\n+    generate_schema_calls.reset()\n+\n     ta = TypeAdapter(MyModel)\n \n-    assert isinstance(ta.validator, MockValSer)\n-    assert isinstance(ta.serializer, MockValSer)\n+    assert generate_schema_calls.count == 0, 'Should use model generated schema'\n \n-    m = ta.validate_python({'x': 1})\n-    assert m.x == 1\n-    m2 = ta.validate_python({'x': 2})\n-    assert m2.x == 2\n+    assert ta.validate_python({'x': 1}).x == 1\n+    assert ta.validate_python({'x': 2}).x == 2\n+    assert ta.dump_python(MyModel.model_construct(x=1))['x'] == 1\n+    assert ta.json_schema()['type'] == 'object'\n \n-    # in the future, can reassign said validators to the TypeAdapter\n-    assert isinstance(MyModel.__pydantic_validator__, SchemaValidator)\n-    assert isinstance(MyModel.__pydantic_serializer__, SchemaSerializer)\n+    assert generate_schema_calls.count == (1 if is_deferred else 0), 'Should not build duplicate core schemas'",
      "comment": "@sydney-runkle was this a \"bug\" as previously (also in `main`) this assertion would have failed? It showed how `TypeAdapter` actually built core schema duplicated. First one was built via `TypeAdapter.__init__` and second one via `TypeAdapter.validator` using `MockValSer` of the model. The first core schema was never even used... So this happened when the model used `defer_build=True`.\r\n\r\nI now fixed (attempt) it with plenty more tests added against duplications. There it uses `MockCoreSchema` similar to `MockValSer` to use the postponed building via the model.\r\n\r\nThe issue might caused even worse performance when using `defer_build` as it actually causes even more work to happen. So the heavy core schemas being built 2x with `defer_build` in `TypeAdapter`.",
      "comment_id": 1536899076,
      "user": "MarkusSintonen",
      "created_at": "2024-03-24T19:45:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1536899076"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "tests/test_config.py",
      "line": 763,
      "side": "RIGHT",
      "diff_hunk": "@@ -701,54 +703,132 @@ def test_json_encoders_type_adapter() -> None:\n     assert json.loads(ta.dump_json(1)) == '2'\n \n \n-def test_config_model_defer_build():\n-    class MyModel(BaseModel, defer_build=True):\n+@pytest.mark.parametrize('defer_build_mode', [None, tuple(), ('model',), ('type_adapter',), ('model', 'type_adapter')])\n+def test_config_model_defer_build(\n+    defer_build_mode: Optional[Tuple[Literal['model', 'type_adapter'], ...]], generate_schema_calls: CallCounter\n+):\n+    config = ConfigDict(defer_build=True)\n+    if defer_build_mode is not None:\n+        config['_defer_build_mode'] = defer_build_mode\n+\n+    class MyModel(BaseModel):\n+        model_config = config\n         x: int\n \n-    assert isinstance(MyModel.__pydantic_validator__, MockValSer)\n-    assert isinstance(MyModel.__pydantic_serializer__, MockValSer)\n+    if defer_build_mode is None or 'model' in defer_build_mode:\n+        assert isinstance(MyModel.__pydantic_validator__, MockValSer)\n+        assert isinstance(MyModel.__pydantic_serializer__, MockValSer)\n+        assert generate_schema_calls.count == 0, 'Should respect _defer_build_mode'\n+    else:\n+        assert isinstance(MyModel.__pydantic_validator__, SchemaValidator)\n+        assert isinstance(MyModel.__pydantic_serializer__, SchemaSerializer)\n+        assert generate_schema_calls.count == 1, 'Should respect _defer_build_mode'\n \n     m = MyModel(x=1)\n     assert m.x == 1\n+    assert m.model_dump()['x'] == 1\n+    assert m.model_validate({'x': 2}).x == 2\n+    assert m.model_json_schema()['type'] == 'object'\n \n     assert isinstance(MyModel.__pydantic_validator__, SchemaValidator)\n     assert isinstance(MyModel.__pydantic_serializer__, SchemaSerializer)\n+    assert generate_schema_calls.count == 1, 'Should not build duplicated core schemas'\n \n \n-def test_config_type_adapter_defer_build():\n-    class MyModel(BaseModel, defer_build=True):\n+@pytest.mark.parametrize('defer_build_mode', [None, tuple(), ('model',), ('type_adapter',), ('model', 'type_adapter')])\n+def test_config_model_type_adapter_defer_build(\n+    defer_build_mode: Optional[Tuple[Literal['model', 'type_adapter'], ...]], generate_schema_calls: CallCounter\n+):\n+    config = ConfigDict(defer_build=True)\n+    if defer_build_mode is not None:\n+        config['_defer_build_mode'] = defer_build_mode\n+\n+    class MyModel(BaseModel):\n+        model_config = config\n         x: int\n \n+    is_deferred = defer_build_mode is None or 'model' in defer_build_mode\n+    assert generate_schema_calls.count == (0 if is_deferred else 1)\n+    generate_schema_calls.reset()\n+\n     ta = TypeAdapter(MyModel)\n \n-    assert isinstance(ta.validator, MockValSer)\n-    assert isinstance(ta.serializer, MockValSer)\n+    assert generate_schema_calls.count == 0, 'Should use model generated schema'\n \n-    m = ta.validate_python({'x': 1})\n-    assert m.x == 1\n-    m2 = ta.validate_python({'x': 2})\n-    assert m2.x == 2\n+    assert ta.validate_python({'x': 1}).x == 1\n+    assert ta.validate_python({'x': 2}).x == 2\n+    assert ta.dump_python(MyModel.model_construct(x=1))['x'] == 1\n+    assert ta.json_schema()['type'] == 'object'\n \n-    # in the future, can reassign said validators to the TypeAdapter\n-    assert isinstance(MyModel.__pydantic_validator__, SchemaValidator)\n-    assert isinstance(MyModel.__pydantic_serializer__, SchemaSerializer)\n+    assert generate_schema_calls.count == (1 if is_deferred else 0), 'Should not build duplicate core schemas'",
      "comment": "@MarkusSintonen,\r\n\r\nAh, interesting. That definitely seems odd. Will review your new changes today :).",
      "comment_id": 1537947588,
      "user": "sydney-runkle",
      "created_at": "2024-03-25T17:18:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1537947588"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +44,7 @@\n from ..json_schema import JsonSchemaValue\n from ..version import version_short\n from ..warnings import PydanticDeprecatedSince20\n-from . import _core_utils, _decorators, _discriminated_union, _known_annotated_metadata, _typing_extra\n+from . import _core_utils, _decorators, _discriminated_union, _known_annotated_metadata, _mock_val_ser, _typing_extra",
      "comment": "Let's just import `MockCoreSchema` from `_mock_val_ser`",
      "comment_id": 1548408619,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T18:52:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548408619"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 653,
      "side": "RIGHT",
      "diff_hunk": "@@ -646,9 +646,11 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n                     source, CallbackGetCoreSchemaHandler(self._generate_schema_inner, self, ref_mode=ref_mode)\n                 )\n         # fmt: off\n-        elif (existing_schema := getattr(obj, '__pydantic_core_schema__', None)) is not None and existing_schema.get(\n-            'cls', None\n-        ) == obj:\n+        elif (\n+            (existing_schema := getattr(obj, '__pydantic_core_schema__', None)) is not None\n+            and not isinstance(existing_schema, _mock_val_ser.MockCoreSchema)\n+            and existing_schema.get('cls', None) == obj\n+        ):",
      "comment": "Thanks for catching this case, I know we added it recently with the schema gen modification.",
      "comment_id": 1548411859,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T18:54:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548411859"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 136,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,6 +122,18 @@ def set_model_mocks(cls: type[BaseModel], cls_name: str, undefined_name: str = '\n         f' then call `{cls_name}.model_rebuild()`.'\n     )\n \n+    def attempt_rebuild_core_schema() -> CoreSchema | None:\n+        if cls.model_rebuild(raise_errors=False, _parent_namespace_depth=5) is not False:\n+            return cls.__pydantic_core_schema__\n+        else:\n+            return None\n+\n+    cls.__pydantic_core_schema__ = MockCoreSchema(  # type: ignore[assignment]\n+        undefined_type_error_message,\n+        code='class-not-fully-defined',\n+        attempt_rebuild=attempt_rebuild_core_schema,\n+    )\n+",
      "comment": "This block + the following 2 are quite similar - can we reduce the repeated code here?",
      "comment_id": 1548416946,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T18:55:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548416946"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 241,
      "side": "LEFT",
      "diff_hunk": "@@ -231,14 +231,6 @@ def __getattr__(self, item: str) -> Any:\n             private_attributes = self.__dict__.get('__private_attributes__')\n             if private_attributes and item in private_attributes:\n                 return private_attributes[item]\n-            if item == '__pydantic_core_schema__':\n-                # This means the class didn't get a schema generated for it, likely because there was an undefined reference\n-                maybe_mock_validator = getattr(self, '__pydantic_validator__', None)\n-                if isinstance(maybe_mock_validator, MockValSer):\n-                    rebuilt_validator = maybe_mock_validator.rebuild()\n-                    if rebuilt_validator is not None:\n-                        # In this case, a validator was built, and so `__pydantic_core_schema__` should now be set\n-                        return getattr(self, '__pydantic_core_schema__')",
      "comment": "Can this really be removed entirely? Maybe I'm missing something about how the logic you've added removes this requirement...",
      "comment_id": 1548427441,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T19:01:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548427441"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,6 +39,7 @@\n from .plugin._schema_validator import create_schema_validator\n \n T = TypeVar('T')\n+R = TypeVar('R')",
      "comment": "Why `R`, out of curiosity? Is this convention for the 2nd type var? I'd assume we'd use `S` or something adjacent to `T`, haha.",
      "comment_id": 1548436217,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T19:05:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548436217"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,15 +115,33 @@ def _getattr_no_parents(obj: Any, attribute: str) -> Any:\n         raise AttributeError(attribute)\n \n \n+def _annotated_type(type_: Any) -> Any | None:\n+    return get_args(type_)[0] if _typing_extra.is_annotated(type_) else None\n+\n+",
      "comment": "I'd assume we have this helper somewhere else that you could use, maybe I'm wrong",
      "comment_id": 1548436959,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T19:05:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548436959"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,15 +115,33 @@ def _getattr_no_parents(obj: Any, attribute: str) -> Any:\n         raise AttributeError(attribute)\n \n \n+def _annotated_type(type_: Any) -> Any | None:\n+    return get_args(type_)[0] if _typing_extra.is_annotated(type_) else None\n+\n+",
      "comment": "Generally a cleaner approach than what we had though, so feel free to just resolve this as is.",
      "comment_id": 1548440462,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T19:06:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548440462"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "tests/test_type_adapter.py",
      "line": 526,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,3 +473,108 @@ def test_eval_type_backport():\n     assert exc_info.value.errors(include_url=False) == [\n         {'type': 'list_type', 'loc': (), 'msg': 'Input should be a valid list', 'input': 'not a list'}\n     ]\n+\n+\n+def defer_build_test_models(config: ConfigDict) -> List[Any]:\n+    class Model(BaseModel):\n+        model_config = config\n+        x: int\n+\n+    class SubModel(Model):\n+        y: Optional[int] = None\n+\n+    @pydantic_dataclass(config=config)\n+    class DataClassModel:\n+        x: int\n+\n+    @pydantic_dataclass\n+    class SubDataClassModel(DataClassModel):\n+        y: Optional[int] = None\n+\n+    class TypedDictModel(TypedDict):\n+        __pydantic_config__ = config  # type: ignore\n+        x: int\n+\n+    models = [\n+        Model,\n+        SubModel,\n+        create_model('DynamicModel', __base__=Model),\n+        create_model('DynamicSubModel', __base__=SubModel),\n+        DataClassModel,\n+        SubDataClassModel,\n+        TypedDictModel,\n+        Dict[str, int],\n+    ]\n+    return [\n+        *models,\n+        # FastAPI heavily uses Annotated so test that as well\n+        *[Annotated[model, Field(title='abc')] for model in models],\n+    ]\n+\n+\n+CONFIGS = [\n+    ConfigDict(defer_build=False, _defer_build_mode=('model',)),\n+    ConfigDict(defer_build=False, _defer_build_mode=DEFER_ENABLE_MODE),\n+    ConfigDict(defer_build=True, _defer_build_mode=('model',)),\n+    ConfigDict(defer_build=True, _defer_build_mode=DEFER_ENABLE_MODE),\n+]\n+MODELS_CONFIGS: List[Tuple[Any, ConfigDict]] = [\n+    (model, config) for config in CONFIGS for model in defer_build_test_models(config)\n+]\n+\n+\n+@pytest.mark.parametrize('model, config', MODELS_CONFIGS)",
      "comment": "Could we further consolidate these last 3 tests based on their similarities (especially the first half of the logic)?",
      "comment_id": 1548468737,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T19:18:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548468737"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,16 +2,32 @@\n from __future__ import annotations as _annotations\n \n import sys\n+from contextlib import contextmanager\n from dataclasses import is_dataclass\n-from typing import TYPE_CHECKING, Any, Dict, Generic, Iterable, Set, TypeVar, Union, cast, final, overload\n+from functools import cached_property, wraps\n+from typing import (\n+    TYPE_CHECKING,\n+    Any,\n+    Callable,\n+    Dict,\n+    Generic,\n+    Iterable,\n+    Iterator,\n+    Set,\n+    TypeVar,\n+    Union,\n+    cast,\n+    final,\n+    overload,\n+)\n \n from pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator, Some\n from typing_extensions import Literal, get_args, is_typeddict\n \n from pydantic.errors import PydanticUserError\n from pydantic.main import BaseModel\n \n-from ._internal import _config, _generate_schema, _typing_extra\n+from ._internal import _config, _generate_schema, _mock_val_ser, _typing_extra, _utils",
      "comment": "Same thing, let's just import the relevant classes from `_mock_val_ser`",
      "comment_id": 1548471278,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T19:19:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548471278"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,15 +115,33 @@ def _getattr_no_parents(obj: Any, attribute: str) -> Any:\n         raise AttributeError(attribute)\n \n \n+def _annotated_type(type_: Any) -> Any | None:\n+    return get_args(type_)[0] if _typing_extra.is_annotated(type_) else None\n+\n+\n def _type_has_config(type_: Any) -> bool:\n     \"\"\"Returns whether the type has config.\"\"\"\n+    type_ = _annotated_type(type_) or type_\n     try:\n         return issubclass(type_, BaseModel) or is_dataclass(type_) or is_typeddict(type_)\n     except TypeError:\n         # type is not a class\n         return False\n \n \n+def _frame_depth(depth: int) -> Callable[[Callable[..., R]], Callable[..., R]]:\n+    def wrapper(func: Callable[..., R]) -> Callable[..., R]:\n+        @wraps(func)\n+        def wrapped(self: TypeAdapter, *args: Any, **kwargs: Any) -> R:\n+            # depth + 1 for the wrapper function\n+            with self._with_frame_depth(depth + 1):\n+                return func(self, *args, **kwargs)\n+\n+        return wrapped\n+\n+    return wrapper\n+\n+",
      "comment": "I think maybe it'd help to have a bit more documentation for this function and the frame depth function attached to the `TypeAdapter` class - it'd help me in my review as well!",
      "comment_id": 1548474245,
      "user": "sydney-runkle",
      "created_at": "2024-04-02T19:20:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548474245"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 241,
      "side": "LEFT",
      "diff_hunk": "@@ -231,14 +231,6 @@ def __getattr__(self, item: str) -> Any:\n             private_attributes = self.__dict__.get('__private_attributes__')\n             if private_attributes and item in private_attributes:\n                 return private_attributes[item]\n-            if item == '__pydantic_core_schema__':\n-                # This means the class didn't get a schema generated for it, likely because there was an undefined reference\n-                maybe_mock_validator = getattr(self, '__pydantic_validator__', None)\n-                if isinstance(maybe_mock_validator, MockValSer):\n-                    rebuilt_validator = maybe_mock_validator.rebuild()\n-                    if rebuilt_validator is not None:\n-                        # In this case, a validator was built, and so `__pydantic_core_schema__` should now be set\n-                        return getattr(self, '__pydantic_core_schema__')",
      "comment": "I believe this is because of line 131 in `set_model_mocks` from `_mock_val_ser.py`, which sets it unconditionally, so you should never hit this now",
      "comment_id": 1548677087,
      "user": "dmontagu",
      "created_at": "2024-04-02T22:11:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548677087"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 241,
      "side": "LEFT",
      "diff_hunk": "@@ -231,14 +231,6 @@ def __getattr__(self, item: str) -> Any:\n             private_attributes = self.__dict__.get('__private_attributes__')\n             if private_attributes and item in private_attributes:\n                 return private_attributes[item]\n-            if item == '__pydantic_core_schema__':\n-                # This means the class didn't get a schema generated for it, likely because there was an undefined reference\n-                maybe_mock_validator = getattr(self, '__pydantic_validator__', None)\n-                if isinstance(maybe_mock_validator, MockValSer):\n-                    rebuilt_validator = maybe_mock_validator.rebuild()\n-                    if rebuilt_validator is not None:\n-                        # In this case, a validator was built, and so `__pydantic_core_schema__` should now be set\n-                        return getattr(self, '__pydantic_core_schema__')",
      "comment": "Well, I guess it comes down to whether there is any way that the MockValSer can be set _without_ using the defer_build stuff. If it can be set without the defer build then yeah it seems suspicious to delete this.",
      "comment_id": 1548679239,
      "user": "dmontagu",
      "created_at": "2024-04-02T22:13:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548679239"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "tests/test_main.py",
      "line": 3005,
      "side": "RIGHT",
      "diff_hunk": "@@ -2986,17 +2988,27 @@ class Bar:\n     assert ta.validate_python(bar) is bar\n \n \n-def test_deferred_core_schema() -> None:\n-    class Foo(BaseModel):\n-        x: 'Bar'\n+@pytest.mark.parametrize('is_dataclass', [False, True])\n+def test_deferred_core_schema(is_dataclass: bool) -> None:\n+    if is_dataclass:\n+\n+        @pydantic_dataclass\n+        class Foo:\n+            x: 'Bar'\n+    else:\n+\n+        class Foo(BaseModel):\n+            x: 'Bar'\n \n+    assert isinstance(Foo.__pydantic_core_schema__, MockCoreSchema)\n     with pytest.raises(PydanticUserError, match='`Foo` is not fully defined'):\n-        Foo.__pydantic_core_schema__\n+        Foo.__pydantic_core_schema__['type']",
      "comment": "I think you have to access something _on_ the schema to get it to produce the error now, not just attempting to access the schema itself. The error is produced in the `MockCoreSchema.__getitem__`, rather than in `Foo.__getattr__`",
      "comment_id": 1548684745,
      "user": "dmontagu",
      "created_at": "2024-04-02T22:18:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1548684745"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,6 +39,7 @@\n from .plugin._schema_validator import create_schema_validator\n \n T = TypeVar('T')\n+R = TypeVar('R')",
      "comment": "Took `R` as in Return type. This kind of `R` is also used in `plugin/_schema_validation.py` for a Callable return type",
      "comment_id": 1549790473,
      "user": "MarkusSintonen",
      "created_at": "2024-04-03T13:47:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1549790473"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,6 +15,59 @@\n ValSer = TypeVar('ValSer', SchemaValidator, SchemaSerializer)\n \n \n+class MockCoreSchema(Mapping[str, Any]):\n+    \"\"\"Mocker for `pydantic_core.CoreSchema` which optionally attempts to\n+    rebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.\n+    \"\"\"\n+\n+    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n+\n+    def __init__(\n+        self,\n+        error_message: str,\n+        *,\n+        code: PydanticErrorCodes,\n+        attempt_rebuild: Callable[[], CoreSchema | None] | None = None,\n+    ) -> None:\n+        self._error_message = error_message\n+        self._code: PydanticErrorCodes = code\n+        self._attempt_rebuild = attempt_rebuild\n+        self._built_memo: CoreSchema | None = None\n+\n+    def __contains__(self, key: Any) -> bool:\n+        return self._get_built().__contains__(key)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self._get_built().__getitem__(key)\n+\n+    def __len__(self) -> int:\n+        return self._get_built().__len__()\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return self._get_built().__iter__()\n+\n+    def _get_built(self) -> CoreSchema:\n+        if self._built_memo is not None:\n+            return self._built_memo\n+\n+        if self._attempt_rebuild:\n+            schema = self._attempt_rebuild()\n+            if schema is not None:\n+                self._built_memo = schema\n+                return schema\n+        raise PydanticUserError(self._error_message, code=self._code)",
      "comment": "What do you mean by necessary? For abstract `Mapping` the `__getitem__ / __len__  / __iter__` are required\r\n\r\nIll remove the `__contains__` as it doesnt need overriding.",
      "comment_id": 1549795991,
      "user": "MarkusSintonen",
      "created_at": "2024-04-03T13:50:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1549795991"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 241,
      "side": "LEFT",
      "diff_hunk": "@@ -231,14 +231,6 @@ def __getattr__(self, item: str) -> Any:\n             private_attributes = self.__dict__.get('__private_attributes__')\n             if private_attributes and item in private_attributes:\n                 return private_attributes[item]\n-            if item == '__pydantic_core_schema__':\n-                # This means the class didn't get a schema generated for it, likely because there was an undefined reference\n-                maybe_mock_validator = getattr(self, '__pydantic_validator__', None)\n-                if isinstance(maybe_mock_validator, MockValSer):\n-                    rebuilt_validator = maybe_mock_validator.rebuild()\n-                    if rebuilt_validator is not None:\n-                        # In this case, a validator was built, and so `__pydantic_core_schema__` should now be set\n-                        return getattr(self, '__pydantic_core_schema__')",
      "comment": "> Can this really be removed entirely\r\n\r\nYes this was now dead code as the `__pydantic_core_schema__` is handled similarly as the other `MockValSer`s. So avoiding also the issues with the duplicated schema building.",
      "comment_id": 1549798625,
      "user": "MarkusSintonen",
      "created_at": "2024-04-03T13:52:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1549798625"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "tests/test_main.py",
      "line": 3005,
      "side": "RIGHT",
      "diff_hunk": "@@ -2986,17 +2988,27 @@ class Bar:\n     assert ta.validate_python(bar) is bar\n \n \n-def test_deferred_core_schema() -> None:\n-    class Foo(BaseModel):\n-        x: 'Bar'\n+@pytest.mark.parametrize('is_dataclass', [False, True])\n+def test_deferred_core_schema(is_dataclass: bool) -> None:\n+    if is_dataclass:\n+\n+        @pydantic_dataclass\n+        class Foo:\n+            x: 'Bar'\n+    else:\n+\n+        class Foo(BaseModel):\n+            x: 'Bar'\n \n+    assert isinstance(Foo.__pydantic_core_schema__, MockCoreSchema)\n     with pytest.raises(PydanticUserError, match='`Foo` is not fully defined'):\n-        Foo.__pydantic_core_schema__\n+        Foo.__pydantic_core_schema__['type']",
      "comment": "Yep exactly. It works similarly as other `MockValSer`s where the model building happens on the attribute accessing",
      "comment_id": 1549806521,
      "user": "MarkusSintonen",
      "created_at": "2024-04-03T13:56:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1549806521"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,16 +2,32 @@\n from __future__ import annotations as _annotations\n \n import sys\n+from contextlib import contextmanager\n from dataclasses import is_dataclass\n-from typing import TYPE_CHECKING, Any, Dict, Generic, Iterable, Set, TypeVar, Union, cast, final, overload\n+from functools import cached_property, wraps\n+from typing import (\n+    TYPE_CHECKING,\n+    Any,\n+    Callable,\n+    Dict,\n+    Generic,\n+    Iterable,\n+    Iterator,\n+    Set,\n+    TypeVar,\n+    Union,\n+    cast,\n+    final,\n+    overload,\n+)\n \n from pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator, Some\n from typing_extensions import Literal, get_args, is_typeddict\n \n from pydantic.errors import PydanticUserError\n from pydantic.main import BaseModel\n \n-from ._internal import _config, _generate_schema, _typing_extra\n+from ._internal import _config, _generate_schema, _mock_val_ser, _typing_extra, _utils",
      "comment": "Elsewhere all the `MockValSer`s are coming via `_mock_val_ser.MockValSer` in public modules. So I think this is to avoid exporting out the internal class we should not expose. Went with same way here",
      "comment_id": 1549821512,
      "user": "MarkusSintonen",
      "created_at": "2024-04-03T14:04:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1549821512"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,6 +15,59 @@\n ValSer = TypeVar('ValSer', SchemaValidator, SchemaSerializer)\n \n \n+class MockCoreSchema(Mapping[str, Any]):\n+    \"\"\"Mocker for `pydantic_core.CoreSchema` which optionally attempts to\n+    rebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.\n+    \"\"\"\n+\n+    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n+\n+    def __init__(\n+        self,\n+        error_message: str,\n+        *,\n+        code: PydanticErrorCodes,\n+        attempt_rebuild: Callable[[], CoreSchema | None] | None = None,\n+    ) -> None:\n+        self._error_message = error_message\n+        self._code: PydanticErrorCodes = code\n+        self._attempt_rebuild = attempt_rebuild\n+        self._built_memo: CoreSchema | None = None\n+\n+    def __contains__(self, key: Any) -> bool:\n+        return self._get_built().__contains__(key)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self._get_built().__getitem__(key)\n+\n+    def __len__(self) -> int:\n+        return self._get_built().__len__()\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return self._get_built().__iter__()\n+\n+    def _get_built(self) -> CoreSchema:\n+        if self._built_memo is not None:\n+            return self._built_memo\n+\n+        if self._attempt_rebuild:\n+            schema = self._attempt_rebuild()\n+            if schema is not None:\n+                self._built_memo = schema\n+                return schema\n+        raise PydanticUserError(self._error_message, code=self._code)",
      "comment": "Done, removed the unneeded `__contains__` override",
      "comment_id": 1549866581,
      "user": "MarkusSintonen",
      "created_at": "2024-04-03T14:27:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1549866581"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,15 +115,33 @@ def _getattr_no_parents(obj: Any, attribute: str) -> Any:\n         raise AttributeError(attribute)\n \n \n+def _annotated_type(type_: Any) -> Any | None:\n+    return get_args(type_)[0] if _typing_extra.is_annotated(type_) else None\n+\n+\n def _type_has_config(type_: Any) -> bool:\n     \"\"\"Returns whether the type has config.\"\"\"\n+    type_ = _annotated_type(type_) or type_\n     try:\n         return issubclass(type_, BaseModel) or is_dataclass(type_) or is_typeddict(type_)\n     except TypeError:\n         # type is not a class\n         return False\n \n \n+def _frame_depth(depth: int) -> Callable[[Callable[..., R]], Callable[..., R]]:\n+    def wrapper(func: Callable[..., R]) -> Callable[..., R]:\n+        @wraps(func)\n+        def wrapped(self: TypeAdapter, *args: Any, **kwargs: Any) -> R:\n+            # depth + 1 for the wrapper function\n+            with self._with_frame_depth(depth + 1):\n+                return func(self, *args, **kwargs)\n+\n+        return wrapped\n+\n+    return wrapper\n+\n+",
      "comment": "Done, added some comment to this.\r\n\r\nFYI Im wondering is there a better way than the `_parent_depth` handling. What about requiring user to define a callback function that would resolve the forward refs from locals/globals? So replacing `_parent_depth` with something like `resolve_namespace: Callable[[], dict[str, Any]]` where the `str` is the name of the type. Then it wouldnt be as fragile as the parent depth handling which could be still there but callable being preferred. Probably such resolver would need to come via Config instead than from the constructor arg directly.\r\n\r\nThis is ofcourse out of scope of this PR.",
      "comment_id": 1549876942,
      "user": "MarkusSintonen",
      "created_at": "2024-04-03T14:33:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1549876942"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,36 +240,105 @@ def __init__(\n                 code='type-adapter-config-unused',\n             )\n \n-        config_wrapper = _config.ConfigWrapper(config)\n-\n-        core_schema: CoreSchema\n+        self._type = type\n+        self._config = config\n+        self._parent_depth = _parent_depth\n+        if module is None:\n+            f = sys._getframe(1)\n+            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n+        else:\n+            self._module_name = module\n+\n+        self._core_schema: CoreSchema | None = None\n+        self._validator: SchemaValidator | None = None\n+        self._serializer: SchemaSerializer | None = None\n+\n+        if not self._defer_build():\n+            # Immediately initialize the core schema, validator and serializer\n+            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n+                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n+                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n+                self._init_core_attrs(rebuild_mocks=False)",
      "comment": "This is a bit fuzzy to me still. Core schema and friends are **not** initialized immediately (`rebuild_mocks=False`) when `_type` is subclass of `BaseModel` even though `_defer_build_mode` does not include `type_adapter`. This is how it also behaved previously and we probably can not really change it (can not do `rebuild_mocks=True` here). Previously it built the core schema right away but it was never used for validation/serialization.\r\n\r\nStill the case where it is very inconsistent is when `BaseModel` is inside `Annotated[BaseModel, Field]`. I feel like this is a bit strange behavior even in current state of PR. So the `Annotated` wrapping case suddenly requires including the `type_adapter` to `_defer_build_mode` even though it includes `model`. The behavior is quite a beast to document properly (as its slight weird). It also means the only reasoning for having the new `_defer_build_mode` is for the Annotated-BaseModel type which feels slightly off. Because any other case has previously required passing the Config explicitly to the `TypeAdapter.__init__` with possible defer built enabled. \r\n\r\nI would say most clear way would be to just drop the `_defer_build_mode` and have just the existing boolean, which feels much simpler. As the only real reason for having it now is for the `Annotated` case. But then again there were some concerns with this. Although I'm not 100% convinced they are actually concerns for Annotated BaseModel usage cases unless I'm missing something. Because also previously the model was defer built via TypeAdapter but not Annotated one for some reason. Ie what is special about Annotated-BaseModel?\r\n\r\n\r\n",
      "comment_id": 1550936680,
      "user": "MarkusSintonen",
      "created_at": "2024-04-04T05:20:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1550936680"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,6 +13,57 @@\n \n \n ValSer = TypeVar('ValSer', SchemaValidator, SchemaSerializer)\n+T = TypeVar('T')\n+\n+\n+class MockCoreSchema(Mapping[str, Any]):\n+    \"\"\"Mocker for `pydantic_core.CoreSchema` which optionally attempts to\n+    rebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.\n+    \"\"\"\n+\n+    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n+\n+    def __init__(\n+        self,\n+        error_message: str,\n+        *,\n+        code: PydanticErrorCodes,\n+        attempt_rebuild: Callable[[], CoreSchema | None] | None = None,\n+    ) -> None:\n+        self._error_message = error_message\n+        self._code: PydanticErrorCodes = code\n+        self._attempt_rebuild = attempt_rebuild\n+        self._built_memo: CoreSchema | None = None",
      "comment": "I used `_built_memo` memoizer here to avoid cases where user could capture the internal mocker class and then use it. That would again and again go through the model rebuilder which has deeply the core schema etc memoized after its built. Should the existing `MockValSer` for consistency also have its memoizer so it wont accidentally go again and again through the wrapped class deep memoizer?",
      "comment_id": 1550942540,
      "user": "MarkusSintonen",
      "created_at": "2024-04-04T05:30:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1550942540"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,6 +15,59 @@\n ValSer = TypeVar('ValSer', SchemaValidator, SchemaSerializer)\n \n \n+class MockCoreSchema(Mapping[str, Any]):\n+    \"\"\"Mocker for `pydantic_core.CoreSchema` which optionally attempts to\n+    rebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.\n+    \"\"\"\n+\n+    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n+\n+    def __init__(\n+        self,\n+        error_message: str,\n+        *,\n+        code: PydanticErrorCodes,\n+        attempt_rebuild: Callable[[], CoreSchema | None] | None = None,\n+    ) -> None:\n+        self._error_message = error_message\n+        self._code: PydanticErrorCodes = code\n+        self._attempt_rebuild = attempt_rebuild\n+        self._built_memo: CoreSchema | None = None\n+\n+    def __contains__(self, key: Any) -> bool:\n+        return self._get_built().__contains__(key)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self._get_built().__getitem__(key)\n+\n+    def __len__(self) -> int:\n+        return self._get_built().__len__()\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return self._get_built().__iter__()\n+\n+    def _get_built(self) -> CoreSchema:\n+        if self._built_memo is not None:\n+            return self._built_memo\n+\n+        if self._attempt_rebuild:\n+            schema = self._attempt_rebuild()\n+            if schema is not None:\n+                self._built_memo = schema\n+                return schema\n+        raise PydanticUserError(self._error_message, code=self._code)",
      "comment": "I guess I mean they aren't implemented for `MockValSer`, right? So why have them here?",
      "comment_id": 1551967419,
      "user": "sydney-runkle",
      "created_at": "2024-04-04T15:50:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1551967419"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,36 +240,105 @@ def __init__(\n                 code='type-adapter-config-unused',\n             )\n \n-        config_wrapper = _config.ConfigWrapper(config)\n-\n-        core_schema: CoreSchema\n+        self._type = type\n+        self._config = config\n+        self._parent_depth = _parent_depth\n+        if module is None:\n+            f = sys._getframe(1)\n+            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n+        else:\n+            self._module_name = module\n+\n+        self._core_schema: CoreSchema | None = None\n+        self._validator: SchemaValidator | None = None\n+        self._serializer: SchemaSerializer | None = None\n+\n+        if not self._defer_build():\n+            # Immediately initialize the core schema, validator and serializer\n+            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n+                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n+                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n+                self._init_core_attrs(rebuild_mocks=False)",
      "comment": "I don't follow, but I don't think it's a huge deal if the handling of `Annotated[BaseModel, Field]` is less performant. If it's _invalid_ then I guess that's more of a concern.\r\n\r\nI don't really understand the alternative you are proposing (i.e., dropping the `_defer_build_mode`), what is the consequence? If it's not hard to make that change on a separate branch that I could compare against this that would probably help a lot. Also, related, I think I don't really mind too much if it's not documented clearly why things work the way they do as long as changes result in failing tests, if necessary to write things in a weird way then ideally there would be a test included specifically for the sake of documenting why things seem to be written in that weird way, and the test could reference the code or vice versa.",
      "comment_id": 1552026503,
      "user": "dmontagu",
      "created_at": "2024-04-04T16:18:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1552026503"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,15 +115,33 @@ def _getattr_no_parents(obj: Any, attribute: str) -> Any:\n         raise AttributeError(attribute)\n \n \n+def _annotated_type(type_: Any) -> Any | None:\n+    return get_args(type_)[0] if _typing_extra.is_annotated(type_) else None\n+\n+\n def _type_has_config(type_: Any) -> bool:\n     \"\"\"Returns whether the type has config.\"\"\"\n+    type_ = _annotated_type(type_) or type_\n     try:\n         return issubclass(type_, BaseModel) or is_dataclass(type_) or is_typeddict(type_)\n     except TypeError:\n         # type is not a class\n         return False\n \n \n+def _frame_depth(depth: int) -> Callable[[Callable[..., R]], Callable[..., R]]:\n+    def wrapper(func: Callable[..., R]) -> Callable[..., R]:\n+        @wraps(func)\n+        def wrapped(self: TypeAdapter, *args: Any, **kwargs: Any) -> R:\n+            # depth + 1 for the wrapper function\n+            with self._with_frame_depth(depth + 1):\n+                return func(self, *args, **kwargs)\n+\n+        return wrapped\n+\n+    return wrapper\n+\n+",
      "comment": "I definitely wish we had a better way for users to specify/pass the namespace, but the reason for the parent depth thing was so that it would generally behave correctly without any extra work. At this point, I think it's probably not possible to get rid of `_parent_depth` unless we find a way to keep all existing code that currently relies on that from breaking. In v3 I think we could make a change to this if we felt it simplified things significantly or otherwise had (even indirect) import-time performance benefits",
      "comment_id": 1552030600,
      "user": "dmontagu",
      "created_at": "2024-04-04T16:21:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1552030600"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/_internal/_mock_val_ser.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,6 +15,59 @@\n ValSer = TypeVar('ValSer', SchemaValidator, SchemaSerializer)\n \n \n+class MockCoreSchema(Mapping[str, Any]):\n+    \"\"\"Mocker for `pydantic_core.CoreSchema` which optionally attempts to\n+    rebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.\n+    \"\"\"\n+\n+    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n+\n+    def __init__(\n+        self,\n+        error_message: str,\n+        *,\n+        code: PydanticErrorCodes,\n+        attempt_rebuild: Callable[[], CoreSchema | None] | None = None,\n+    ) -> None:\n+        self._error_message = error_message\n+        self._code: PydanticErrorCodes = code\n+        self._attempt_rebuild = attempt_rebuild\n+        self._built_memo: CoreSchema | None = None\n+\n+    def __contains__(self, key: Any) -> bool:\n+        return self._get_built().__contains__(key)\n+\n+    def __getitem__(self, key: str) -> Any:\n+        return self._get_built().__getitem__(key)\n+\n+    def __len__(self) -> int:\n+        return self._get_built().__len__()\n+\n+    def __iter__(self) -> Iterator[str]:\n+        return self._get_built().__iter__()\n+\n+    def _get_built(self) -> CoreSchema:\n+        if self._built_memo is not None:\n+            return self._built_memo\n+\n+        if self._attempt_rebuild:\n+            schema = self._attempt_rebuild()\n+            if schema is not None:\n+                self._built_memo = schema\n+                return schema\n+        raise PydanticUserError(self._error_message, code=self._code)",
      "comment": "CoreSchema is a dict but eg SchemaValidator is an ordinary class",
      "comment_id": 1552059156,
      "user": "MarkusSintonen",
      "created_at": "2024-04-04T16:42:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1552059156"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,15 +115,33 @@ def _getattr_no_parents(obj: Any, attribute: str) -> Any:\n         raise AttributeError(attribute)\n \n \n+def _annotated_type(type_: Any) -> Any | None:\n+    return get_args(type_)[0] if _typing_extra.is_annotated(type_) else None\n+\n+\n def _type_has_config(type_: Any) -> bool:\n     \"\"\"Returns whether the type has config.\"\"\"\n+    type_ = _annotated_type(type_) or type_\n     try:\n         return issubclass(type_, BaseModel) or is_dataclass(type_) or is_typeddict(type_)\n     except TypeError:\n         # type is not a class\n         return False\n \n \n+def _frame_depth(depth: int) -> Callable[[Callable[..., R]], Callable[..., R]]:\n+    def wrapper(func: Callable[..., R]) -> Callable[..., R]:\n+        @wraps(func)\n+        def wrapped(self: TypeAdapter, *args: Any, **kwargs: Any) -> R:\n+            # depth + 1 for the wrapper function\n+            with self._with_frame_depth(depth + 1):\n+                return func(self, *args, **kwargs)\n+\n+        return wrapped\n+\n+    return wrapper\n+\n+",
      "comment": "Yeah no way to get rid of parent depth handling but some better (optional) way could be offered via configs to resolve the names. As working of the parent depth handling highly depends on the context on how model happens to be used",
      "comment_id": 1552063424,
      "user": "MarkusSintonen",
      "created_at": "2024-04-04T16:45:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1552063424"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,36 +240,105 @@ def __init__(\n                 code='type-adapter-config-unused',\n             )\n \n-        config_wrapper = _config.ConfigWrapper(config)\n-\n-        core_schema: CoreSchema\n+        self._type = type\n+        self._config = config\n+        self._parent_depth = _parent_depth\n+        if module is None:\n+            f = sys._getframe(1)\n+            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n+        else:\n+            self._module_name = module\n+\n+        self._core_schema: CoreSchema | None = None\n+        self._validator: SchemaValidator | None = None\n+        self._serializer: SchemaSerializer | None = None\n+\n+        if not self._defer_build():\n+            # Immediately initialize the core schema, validator and serializer\n+            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n+                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n+                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n+                self._init_core_attrs(rebuild_mocks=False)",
      "comment": "> but I don't think it's a huge deal if the handling of `Annotated[BaseModel, Field]` is less performant\r\n\r\nThe `Annotated` inconsistency here is actually the root of the issue \ud83d\ude04 As this kind of pattern is heavily used by eg FastAPI with TypeAdapters. All of the Pydantic models there go through this `TypeAdapter(Annotated[BaseModel, Field])`. So the `defer_builld=True` param hasnt worked at all in that context. (Causing the mentioned performance issues eg with auto scalers)\r\n\r\n>  If it's invalid then I guess that's more of a concern\r\n\r\nMore about backward compatibility (but not in FastAPI context) if someone happens to rely on the fact that case like `TypeAdapter(Annotated[BaseModel, Field])` gets immediately built eventhough BaseModel used `defer_build=True`. It feels again kinda deep internal detail how it happened to work previously.\r\nI dont think there are any other concerns than the `Annotated` case. Because every other case follows more explicit pattern like `TypeAdapter(Dict[str, Any], config={\"defer_build\": True))` (which didnt either work previously)\r\n\r\n> (i.e., dropping the _defer_build_mode), what is the consequence?\r\n\r\nConsequence is that the `TypeAdapter` starts to \"respect\" the `defer_build=True` without further action from the user. Ie the lazy building behaviour matches that of `BaseModel` in `Annotated`/\"plain-type\" case. Currently `_defer_build_mode` feels like only useful for enabling the `Annotated` case to be deferred built without the risk of someone happening to rely on the internal detail on how previously worked.\r\n\r\nThis is how it would look without the additional config parameter: https://github.com/MarkusSintonen/pydantic/compare/type-adapter-defer-build...MarkusSintonen:pydantic:type-adapter-defer-build-actually?expand=1",
      "comment_id": 1552155563,
      "user": "MarkusSintonen",
      "created_at": "2024-04-04T17:46:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1552155563"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8939,
      "file_path": "pydantic/type_adapter.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,36 +240,105 @@ def __init__(\n                 code='type-adapter-config-unused',\n             )\n \n-        config_wrapper = _config.ConfigWrapper(config)\n-\n-        core_schema: CoreSchema\n+        self._type = type\n+        self._config = config\n+        self._parent_depth = _parent_depth\n+        if module is None:\n+            f = sys._getframe(1)\n+            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n+        else:\n+            self._module_name = module\n+\n+        self._core_schema: CoreSchema | None = None\n+        self._validator: SchemaValidator | None = None\n+        self._serializer: SchemaSerializer | None = None\n+\n+        if not self._defer_build():\n+            # Immediately initialize the core schema, validator and serializer\n+            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n+                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n+                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n+                self._init_core_attrs(rebuild_mocks=False)",
      "comment": "I believe this comment can be resolved, given that we dropped the `_defer_build_mode` setting :)",
      "comment_id": 1781612198,
      "user": "sydney-runkle",
      "created_at": "2024-09-30T19:01:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/8939#discussion_r1781612198"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 360,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,25 +331,78 @@ def max_length_validator(x: Any, max_length: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'max_length' to supplied value {x}\")\n \n \n-_CONSTRAINT_TO_VALIDATOR_LOOKUP: dict[str, Callable] = {\n+def _extract_decimal_digits_info(decimal: Decimal, normalized: bool) -> tuple[int, int]:\n+    \"\"\"Modeled after the `pydanitc-core` implementation of this function.\n+\n+    See https://github.com/pydantic/pydantic-core/blob/f389728432949ecceddecb1f59bb503b0998e9aa/src/validators/decimal.rs#L85.\n+    Though this could be divided into two separate functions, the logic is easier to follow if we couple the computation\n+    of the number of decimals and digits together.\n+    \"\"\"\n+    normalized_decimal = decimal.normalize() if normalized else decimal\n+    _, digit_tuple, exponent = normalized_decimal.as_tuple()\n+\n+    exponent = int(exponent)\n+    digits = len(digit_tuple)\n+\n+    if exponent >= 0:\n+        # // A positive exponent adds that many trailing zeros.\n+        digits += exponent\n+        decimals = 0\n+    else:\n+        #  If the absolute value of the negative exponent is larger than the\n+        #  number of digits, then it's the same as the number of digits,\n+        #  because it'll consume all the digits in digit_tuple and then\n+        #  add abs(exponent) - len(digit_tuple) leading zeros after the\n+        #  decimal point.\n+        decimals = abs(exponent)\n+        digits = max(digits, decimals)\n+\n+    return decimals, digits",
      "comment": "I generally agree with this change but am a bit scared by this logic. @alexmojaki would you mind double checking?",
      "comment_id": 1778849731,
      "user": "adriangb",
      "created_at": "2024-09-27T16:01:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778849731"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 360,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,25 +331,78 @@ def max_length_validator(x: Any, max_length: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'max_length' to supplied value {x}\")\n \n \n-_CONSTRAINT_TO_VALIDATOR_LOOKUP: dict[str, Callable] = {\n+def _extract_decimal_digits_info(decimal: Decimal, normalized: bool) -> tuple[int, int]:\n+    \"\"\"Modeled after the `pydanitc-core` implementation of this function.\n+\n+    See https://github.com/pydantic/pydantic-core/blob/f389728432949ecceddecb1f59bb503b0998e9aa/src/validators/decimal.rs#L85.\n+    Though this could be divided into two separate functions, the logic is easier to follow if we couple the computation\n+    of the number of decimals and digits together.\n+    \"\"\"\n+    normalized_decimal = decimal.normalize() if normalized else decimal\n+    _, digit_tuple, exponent = normalized_decimal.as_tuple()\n+\n+    exponent = int(exponent)\n+    digits = len(digit_tuple)\n+\n+    if exponent >= 0:\n+        # // A positive exponent adds that many trailing zeros.\n+        digits += exponent\n+        decimals = 0\n+    else:\n+        #  If the absolute value of the negative exponent is larger than the\n+        #  number of digits, then it's the same as the number of digits,\n+        #  because it'll consume all the digits in digit_tuple and then\n+        #  add abs(exponent) - len(digit_tuple) leading zeros after the\n+        #  decimal point.\n+        decimals = abs(exponent)\n+        digits = max(digits, decimals)\n+\n+    return decimals, digits",
      "comment": "Also intimidated by this pattern - see the `pydantic-core` ref above that does basically the exact same thing. Thanks for the review :)",
      "comment_id": 1778852682,
      "user": "sydney-runkle",
      "created_at": "2024-09-27T16:03:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778852682"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 360,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,25 +331,78 @@ def max_length_validator(x: Any, max_length: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'max_length' to supplied value {x}\")\n \n \n-_CONSTRAINT_TO_VALIDATOR_LOOKUP: dict[str, Callable] = {\n+def _extract_decimal_digits_info(decimal: Decimal, normalized: bool) -> tuple[int, int]:\n+    \"\"\"Modeled after the `pydanitc-core` implementation of this function.\n+\n+    See https://github.com/pydantic/pydantic-core/blob/f389728432949ecceddecb1f59bb503b0998e9aa/src/validators/decimal.rs#L85.\n+    Though this could be divided into two separate functions, the logic is easier to follow if we couple the computation\n+    of the number of decimals and digits together.\n+    \"\"\"\n+    normalized_decimal = decimal.normalize() if normalized else decimal\n+    _, digit_tuple, exponent = normalized_decimal.as_tuple()\n+\n+    exponent = int(exponent)\n+    digits = len(digit_tuple)\n+\n+    if exponent >= 0:\n+        # // A positive exponent adds that many trailing zeros.\n+        digits += exponent\n+        decimals = 0\n+    else:\n+        #  If the absolute value of the negative exponent is larger than the\n+        #  number of digits, then it's the same as the number of digits,\n+        #  because it'll consume all the digits in digit_tuple and then\n+        #  add abs(exponent) - len(digit_tuple) leading zeros after the\n+        #  decimal point.\n+        decimals = abs(exponent)\n+        digits = max(digits, decimals)\n+\n+    return decimals, digits",
      "comment": "I've rewritten the docstring and added some explicit tests here to help.",
      "comment_id": 1778906784,
      "user": "sydney-runkle",
      "created_at": "2024-09-27T16:54:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778906784"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 339,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,25 +331,95 @@ def max_length_validator(x: Any, max_length: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'max_length' to supplied value {x}\")\n \n \n-_CONSTRAINT_TO_VALIDATOR_LOOKUP: dict[str, Callable] = {\n+def _extract_decimal_digits_info(decimal: Decimal, normalized: bool) -> tuple[int, int]:\n+    \"\"\"Compute the total number of digits and decimal places for a given [`Decimal`][decimal.Decimal] instance.\n+\n+    This function handles both normalized and non-normalized Decimal instances.\n+    Example: Decimal('1.230'), normalize=False -> 3 decimal places, 4 digits\n+    Example: decimal=Decimal('0.00123'), normalize=True -> 5 decimal places, 3 digits",
      "comment": "These examples don't help explain the difference between normalize=True vs False.",
      "comment_id": 1778912115,
      "user": "alexmojaki",
      "created_at": "2024-09-27T17:00:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778912115"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 355,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,25 +331,90 @@ def max_length_validator(x: Any, max_length: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'max_length' to supplied value {x}\")\n \n \n-_CONSTRAINT_TO_VALIDATOR_LOOKUP: dict[str, Callable] = {\n+def _extract_decimal_digits_info(decimal: Decimal) -> tuple[int, int]:\n+    \"\"\"Compute the total number of digits and decimal places for a given [`Decimal`][decimal.Decimal] instance.\n+\n+    This function handles both normalized and non-normalized Decimal instances.\n+    Example: Decimal('1.230'), normalize=False -> 4 digits, 3 decimal places\n+\n+    Args:\n+        decimal (Decimal): The decimal number to analyze.\n+\n+    Returns:\n+        tuple[int, int]: A tuple containing the number of decimal places and total digits.\n+\n+    Modeled after the `pydanitc-core` implementation of this function.\n+    See https://github.com/pydantic/pydantic-core/blob/f389728432949ecceddecb1f59bb503b0998e9aa/src/validators/decimal.rs#L85.\n+\n+    Though this could be divided into two separate functions, the logic is easier to follow if we couple the computation\n+    of the number of decimals and digits together.\n+    \"\"\"\n+    _, digit_tuple, exponent = decimal.as_tuple()\n+\n+    exponent = int(exponent)\n+    digits = len(digit_tuple)",
      "comment": "```suggestion\r\n    decimal_tuple = decimal.as_tuple()\r\n    exponent = decimal_tuple.exponent\r\n    num_digits = len(decimal_tuple.digits)\r\n```\r\n\r\nIt's just nicer IMO to not use tuple unpacking when names are available. Also renamed `digits` to `num_digits` to clearly distinguish from `decimal_tuple.digits`.\r\n\r\nI removed the `int()` because it seemed redundant, isn't exponent always an int?",
      "comment_id": 1778937810,
      "user": "alexmojaki",
      "created_at": "2024-09-27T17:26:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778937810"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 346,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,25 +331,90 @@ def max_length_validator(x: Any, max_length: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'max_length' to supplied value {x}\")\n \n \n-_CONSTRAINT_TO_VALIDATOR_LOOKUP: dict[str, Callable] = {\n+def _extract_decimal_digits_info(decimal: Decimal) -> tuple[int, int]:\n+    \"\"\"Compute the total number of digits and decimal places for a given [`Decimal`][decimal.Decimal] instance.\n+\n+    This function handles both normalized and non-normalized Decimal instances.\n+    Example: Decimal('1.230'), normalize=False -> 4 digits, 3 decimal places\n+\n+    Args:\n+        decimal (Decimal): The decimal number to analyze.\n+\n+    Returns:\n+        tuple[int, int]: A tuple containing the number of decimal places and total digits.\n+\n+    Modeled after the `pydanitc-core` implementation of this function.",
      "comment": "```suggestion\r\n    Modeled after the `pydantic-core` implementation of this function.\r\n```\r\n\r\nthough i'm not sure this is worth keeping",
      "comment_id": 1778938294,
      "user": "alexmojaki",
      "created_at": "2024-09-27T17:27:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778938294"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 338,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,25 +331,90 @@ def max_length_validator(x: Any, max_length: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'max_length' to supplied value {x}\")\n \n \n-_CONSTRAINT_TO_VALIDATOR_LOOKUP: dict[str, Callable] = {\n+def _extract_decimal_digits_info(decimal: Decimal) -> tuple[int, int]:\n+    \"\"\"Compute the total number of digits and decimal places for a given [`Decimal`][decimal.Decimal] instance.\n+\n+    This function handles both normalized and non-normalized Decimal instances.\n+    Example: Decimal('1.230'), normalize=False -> 4 digits, 3 decimal places",
      "comment": "```suggestion\r\n    Example: Decimal('1.230') -> 4 digits, 3 decimal places\r\n```",
      "comment_id": 1778938490,
      "user": "alexmojaki",
      "created_at": "2024-09-27T17:27:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778938490"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "tests/test_internal.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,3 +209,22 @@ def test_schema_is_valid():\n         collect_invalid_schemas(cs.nullable_schema(cs.int_schema(metadata={HAS_INVALID_SCHEMAS_METADATA_KEY: True})))\n         is True\n     )\n+\n+\n+@pytest.mark.parametrize(\n+    'decimal,normalize,decimal_places,digits',\n+    [\n+        (Decimal('0.0'), False, 1, 1),\n+        (Decimal('0.0'), True, 0, 1),\n+        (Decimal('0.000'), False, 3, 3),\n+        (Decimal('0.000'), True, 0, 1),\n+        (Decimal('0.0001'), False, 4, 4),\n+        (Decimal('0.0001'), True, 4, 4),\n+        (Decimal('123.123'), False, 3, 6),\n+        (Decimal('123.123'), True, 3, 6),\n+        (Decimal('123.1230'), False, 4, 7),\n+        (Decimal('123.1230'), True, 3, 6),",
      "comment": "```suggestion\r\n        (Decimal('123.1230'), 4, 7),\r\n        (Decimal('123.123'), 3, 6),\r\n```\r\n\r\nand so on for the other cases looks easier to read",
      "comment_id": 1778942405,
      "user": "alexmojaki",
      "created_at": "2024-09-27T17:31:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778942405"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,25 +331,90 @@ def max_length_validator(x: Any, max_length: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'max_length' to supplied value {x}\")\n \n \n-_CONSTRAINT_TO_VALIDATOR_LOOKUP: dict[str, Callable] = {\n+def _extract_decimal_digits_info(decimal: Decimal) -> tuple[int, int]:\n+    \"\"\"Compute the total number of digits and decimal places for a given [`Decimal`][decimal.Decimal] instance.\n+\n+    This function handles both normalized and non-normalized Decimal instances.\n+    Example: Decimal('1.230'), normalize=False -> 4 digits, 3 decimal places\n+\n+    Args:\n+        decimal (Decimal): The decimal number to analyze.\n+\n+    Returns:\n+        tuple[int, int]: A tuple containing the number of decimal places and total digits.\n+\n+    Modeled after the `pydanitc-core` implementation of this function.\n+    See https://github.com/pydantic/pydantic-core/blob/f389728432949ecceddecb1f59bb503b0998e9aa/src/validators/decimal.rs#L85.\n+\n+    Though this could be divided into two separate functions, the logic is easier to follow if we couple the computation\n+    of the number of decimals and digits together.\n+    \"\"\"\n+    _, digit_tuple, exponent = decimal.as_tuple()\n+\n+    exponent = int(exponent)\n+    digits = len(digit_tuple)\n+\n+    if exponent >= 0:\n+        # A positive exponent adds that many trailing zeros\n+        # Ex: digit_tuple=(1, 2, 3), exponent=2 -> 12300 -> 0 decimal places, 5 digits\n+        digits += exponent\n+        decimal_places = 0\n+    else:\n+        # If the absolute value of the negative exponent is larger than the\n+        # number of digits, then it's the same as the number of digits,\n+        # because it'll consume all the digits in digit_tuple and then\n+        # add abs(exponent) - len(digit_tuple) leading zeros after the decimal point.\n+        # Ex: digit_tuple=(1, 2, 3), exponent=-2 -> 1.23 -> 2 decimal places, 3 digits\n+        # Ex: digit_tuple=(1, 2, 3), exponent=-4 -> 0.0123 -> 4 decimal places, 4 digits",
      "comment": "`0.0123` kinda seems like it should be 5 digits? I suppose it's too late to change that?",
      "comment_id": 1778943162,
      "user": "alexmojaki",
      "created_at": "2024-09-27T17:32:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778943162"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10506,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 355,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,25 +331,90 @@ def max_length_validator(x: Any, max_length: Any) -> Any:\n         raise TypeError(f\"Unable to apply constraint 'max_length' to supplied value {x}\")\n \n \n-_CONSTRAINT_TO_VALIDATOR_LOOKUP: dict[str, Callable] = {\n+def _extract_decimal_digits_info(decimal: Decimal) -> tuple[int, int]:\n+    \"\"\"Compute the total number of digits and decimal places for a given [`Decimal`][decimal.Decimal] instance.\n+\n+    This function handles both normalized and non-normalized Decimal instances.\n+    Example: Decimal('1.230'), normalize=False -> 4 digits, 3 decimal places\n+\n+    Args:\n+        decimal (Decimal): The decimal number to analyze.\n+\n+    Returns:\n+        tuple[int, int]: A tuple containing the number of decimal places and total digits.\n+\n+    Modeled after the `pydanitc-core` implementation of this function.\n+    See https://github.com/pydantic/pydantic-core/blob/f389728432949ecceddecb1f59bb503b0998e9aa/src/validators/decimal.rs#L85.\n+\n+    Though this could be divided into two separate functions, the logic is easier to follow if we couple the computation\n+    of the number of decimals and digits together.\n+    \"\"\"\n+    _, digit_tuple, exponent = decimal.as_tuple()\n+\n+    exponent = int(exponent)\n+    digits = len(digit_tuple)",
      "comment": "It's not always an `int`, sometimes a `Literal`, so will keep that \ud83d\udc4d ",
      "comment_id": 1778950924,
      "user": "sydney-runkle",
      "created_at": "2024-09-27T17:40:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10506#discussion_r1778950924"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10518,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 816,
      "side": "RIGHT",
      "diff_hunk": "@@ -813,9 +813,12 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n                 source, CallbackGetCoreSchemaHandler(self._generate_schema_inner, self, ref_mode=ref_mode)\n             )\n         elif (\n-            (existing_schema := getattr(obj, '__pydantic_core_schema__', None)) is not None\n+            hasattr(obj, '__dict__')",
      "comment": "We could also check for `__slots__` but there's no such type with a `__pydantic_core_schema__` property as of today, so I'm keeping things simple here by only checking for `__dict__`",
      "comment_id": 1781302367,
      "user": "Viicos",
      "created_at": "2024-09-30T14:57:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10518#discussion_r1781302367"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10490,
      "file_path": "pydantic/_internal/_validators.py",
      "line": 260,
      "side": "RIGHT",
      "diff_hunk": "@@ -253,57 +252,92 @@ def forbid_inf_nan_check(x: Any) -> Any:\n     return x\n \n \n-_InputType = typing.TypeVar('_InputType')\n+def _safe_repr(v: Any) -> int | float | str:\n+    \"\"\"The context argument for `PydanticKnownError` requires a number or str type, so we do a simple repr() coercion for types like timedelta.\n \n+    See tests/test_types.py::test_annotated_metadata_any_order for some context.\n+    \"\"\"\n+    if isinstance(v, (int, float)):",
      "comment": "```suggestion\r\n    if isinstance(v, (int, float, str)):\r\n```\r\n\r\n?",
      "comment_id": 1775837758,
      "user": "adriangb",
      "created_at": "2024-09-25T19:11:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/10490#discussion_r1775837758"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10378,
      "file_path": "pydantic/types.py",
      "line": 1242,
      "side": "RIGHT",
      "diff_hunk": "@@ -1238,7 +1239,7 @@ class Model(BaseModel):\n \n @_dataclasses.dataclass\n class PathType:\n-    path_type: Literal['file', 'dir', 'new']\n+    path_type: Literal['file', 'dir', 'new', 'socket']",
      "comment": "```suggestion\r\n    if sys.platform != \"win32\":\r\n        path_type: Literal['file', 'dir', 'new', 'socket']\r\n    else:\r\n        path_type: Literal['file', 'dir', 'new']\r\n```",
      "comment_id": 1756676644,
      "user": "Viicos",
      "created_at": "2024-09-12T11:31:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10378#discussion_r1756676644"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10378,
      "file_path": "pydantic/types.py",
      "line": 1258,
      "side": "RIGHT",
      "diff_hunk": "@@ -1253,6 +1254,7 @@ def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandle\n             'file': cast(core_schema.WithInfoValidatorFunction, self.validate_file),\n             'dir': cast(core_schema.WithInfoValidatorFunction, self.validate_directory),\n             'new': cast(core_schema.WithInfoValidatorFunction, self.validate_new),\n+            'socket': cast(core_schema.WithInfoValidatorFunction, self.validate_socket),\n         }",
      "comment": "```suggestion\r\n        }\r\n        if sys.platform != 'win32':\r\n            function_lookup['socket'] = cast(core_schema.WithInfoValidatorFunction, self.validate_socket)\r\n```",
      "comment_id": 1756679083,
      "user": "Viicos",
      "created_at": "2024-09-12T11:32:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10378#discussion_r1756679083"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10378,
      "file_path": "pydantic/types.py",
      "line": 1242,
      "side": "RIGHT",
      "diff_hunk": "@@ -1238,7 +1239,7 @@ class Model(BaseModel):\n \n @_dataclasses.dataclass\n class PathType:\n-    path_type: Literal['file', 'dir', 'new']\n+    path_type: Literal['file', 'dir', 'new', 'socket']",
      "comment": "i am suprised that conditional attributes on dataclasses are a thing",
      "comment_id": 1757798882,
      "user": "theunkn0wn1",
      "created_at": "2024-09-13T00:37:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10378#discussion_r1757798882"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10378,
      "file_path": "pydantic/types.py",
      "line": 1242,
      "side": "RIGHT",
      "diff_hunk": "@@ -1238,7 +1239,7 @@ class Model(BaseModel):\n \n @_dataclasses.dataclass\n class PathType:\n-    path_type: Literal['file', 'dir', 'new']\n+    path_type: Literal['file', 'dir', 'new', 'socket']",
      "comment": "But anyway, turns out you can also have sockets on Windows, so let's not add any conditions.",
      "comment_id": 1758257259,
      "user": "Viicos",
      "created_at": "2024-09-13T06:30:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/10378#discussion_r1758257259"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10378,
      "file_path": "pydantic/types.py",
      "line": 1242,
      "side": "RIGHT",
      "diff_hunk": "@@ -1238,7 +1239,7 @@ class Model(BaseModel):\n \n @_dataclasses.dataclass\n class PathType:\n-    path_type: Literal['file', 'dir', 'new']\n+    path_type: Literal['file', 'dir', 'new', 'socket']",
      "comment": "Interesting, ok. Closing these conversations then.",
      "comment_id": 1759417287,
      "user": "theunkn0wn1",
      "created_at": "2024-09-13T19:54:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10378#discussion_r1759417287"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10456,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,6 +102,15 @@ def collect_model_fields(  # noqa: C901\n     BaseModel = import_cached_base_model()\n     FieldInfo_ = import_cached_field_info()\n \n+    dataclass_fields = {\n+        field.name for base in bases for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n+    }",
      "comment": "I believe this represents a bit of a logical change.\r\n\r\nPreviously, we only collected the dc fields for each and every base individually, now we aggregate them all into one dict. Might there be unintended consequences here?",
      "comment_id": 1771331647,
      "user": "sydney-runkle",
      "created_at": "2024-09-23T12:42:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10456#discussion_r1771331647"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10456,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,6 +102,15 @@ def collect_model_fields(  # noqa: C901\n     BaseModel = import_cached_base_model()\n     FieldInfo_ = import_cached_field_info()\n \n+    dataclass_fields = {\n+        field.name for base in bases for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n+    }",
      "comment": "Hum maybe we could be even smarter:\r\n\r\n```python\r\nfor base in bases:\r\n    if hasattr(base, ann_name):\r\n        ...\r\n        if dataclasses.is_dataclass(base):\r\n            continue",
      "comment_id": 1771360099,
      "user": "Viicos",
      "created_at": "2024-09-23T12:58:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10456#discussion_r1771360099"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10456,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,6 +102,15 @@ def collect_model_fields(  # noqa: C901\n     BaseModel = import_cached_base_model()\n     FieldInfo_ = import_cached_field_info()\n \n+    dataclass_fields = {\n+        field.name for base in bases for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n+    }",
      "comment": "It might be that it's functionally different but I doubt it. Reverted because this was just logic cleaning (performance is marginal) and let's make sure it doesn't break anything",
      "comment_id": 1771397089,
      "user": "Viicos",
      "created_at": "2024-09-23T13:12:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10456#discussion_r1771397089"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10456,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,7 +158,9 @@ def collect_model_fields(  # noqa: C901\n         generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')\n         for base in bases:\n             dataclass_fields = {\n-                field.name for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n+                field.name\n+                for base in bases",
      "comment": "Not quite reverted here - probably want to remove the nested comprehension",
      "comment_id": 1771559049,
      "user": "sydney-runkle",
      "created_at": "2024-09-23T14:24:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10456#discussion_r1771559049"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10456,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,6 +102,11 @@ def collect_model_fields(  # noqa: C901\n     BaseModel = import_cached_base_model()\n     FieldInfo_ = import_cached_field_info()\n \n+    parent_fields_lookup: dict[str, FieldInfo] = {}\n+    for base in reversed(bases):\n+        if model_fields := getattr(base, 'model_fields', None):\n+            parent_fields_lookup.update(model_fields)\n+",
      "comment": "Last q - any reason to have this up here instead of down below, where the previous logic was?",
      "comment_id": 1771574889,
      "user": "sydney-runkle",
      "created_at": "2024-09-23T14:32:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10456#discussion_r1771574889"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10456,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,6 +102,11 @@ def collect_model_fields(  # noqa: C901\n     BaseModel = import_cached_base_model()\n     FieldInfo_ = import_cached_field_info()\n \n+    parent_fields_lookup: dict[str, FieldInfo] = {}\n+    for base in reversed(bases):\n+        if model_fields := getattr(base, 'model_fields', None):\n+            parent_fields_lookup.update(model_fields)\n+",
      "comment": "We don't \"have to\", but it is equivalent and avoids doing it for every annotation (hard to see because the for loop is large, but it was previously done in the `for ann_name, ann_type in type_hints.items():` loop).",
      "comment_id": 1771577149,
      "user": "Viicos",
      "created_at": "2024-09-23T14:33:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10456#discussion_r1771577149"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10456,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,6 +102,11 @@ def collect_model_fields(  # noqa: C901\n     BaseModel = import_cached_base_model()\n     FieldInfo_ = import_cached_field_info()\n \n+    parent_fields_lookup: dict[str, FieldInfo] = {}\n+    for base in reversed(bases):\n+        if model_fields := getattr(base, 'model_fields', None):\n+            parent_fields_lookup.update(model_fields)\n+",
      "comment": "Ahh great, loop is so large I didn't get that far up haha. Just went to the bases loop.",
      "comment_id": 1771584420,
      "user": "sydney-runkle",
      "created_at": "2024-09-23T14:37:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/10456#discussion_r1771584420"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 257,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):",
      "comment": "```suggestion\r\n    class Model(DeferredModel):\r\n```",
      "comment_id": 1766643746,
      "user": "Viicos",
      "created_at": "2024-09-19T11:10:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1766643746"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 281,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(BaseModel):",
      "comment": "```suggestion\r\n    class ThanksgivingDinner(DeferredModel):\r\n```",
      "comment_id": 1766646069,
      "user": "Viicos",
      "created_at": "2024-09-19T11:12:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1766646069"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(BaseModel):\n+        dessert: Annotated[\n+            Union[\n+                Annotated[ApplePie, Tag('apple')],\n+                Annotated[PumpkinPie, Tag('pumpkin')],\n+            ],\n+            Discriminator(get_discriminator_value),\n+        ]\n+\n+    benchmark(rebuild_model, ThanksgivingDinner)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_nested_schema_generation(benchmark):",
      "comment": "I don't think it really matters to have this benchmark. The goal of having benchmarks with discriminators was to cover most of the `Discriminator._convert_schema` code path, and more importantly the `apply_discriminators` cleaning step.\r\n\r\nHere, having a nested union doesn't really relate to it, and is probably duplicating benchmarks of \"normal\" unions.",
      "comment_id": 1766653473,
      "user": "Viicos",
      "created_at": "2024-09-19T11:18:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1766653473"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 332,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(BaseModel):\n+        dessert: Annotated[\n+            Union[\n+                Annotated[ApplePie, Tag('apple')],\n+                Annotated[PumpkinPie, Tag('pumpkin')],\n+            ],\n+            Discriminator(get_discriminator_value),\n+        ]\n+\n+    benchmark(rebuild_model, ThanksgivingDinner)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_nested_schema_generation(benchmark):\n+    class BlackCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['black']\n+        black_name: str\n+\n+    class WhiteCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['white']\n+        white_name: str\n+\n+    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        name: str\n+\n+    class Model(DeferredModel):\n+        pet: Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_left_to_right_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[str, int] = Field(union_mode='left_to_right')\n+\n+    benchmark(rebuild_model, User)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_smart_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[int, str, UUID]\n+        name: str\n+\n+    benchmark(rebuild_model, User)",
      "comment": "These two can be removed, `union_mode` is only relevant during model validation, not schema building.",
      "comment_id": 1766655122,
      "user": "Viicos",
      "created_at": "2024-09-19T11:20:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1766655122"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(BaseModel):\n+        dessert: Annotated[\n+            Union[\n+                Annotated[ApplePie, Tag('apple')],\n+                Annotated[PumpkinPie, Tag('pumpkin')],\n+            ],\n+            Discriminator(get_discriminator_value),\n+        ]\n+\n+    benchmark(rebuild_model, ThanksgivingDinner)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_nested_schema_generation(benchmark):\n+    class BlackCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['black']\n+        black_name: str\n+\n+    class WhiteCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['white']\n+        white_name: str\n+\n+    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        name: str\n+\n+    class Model(DeferredModel):\n+        pet: Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_left_to_right_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[str, int] = Field(union_mode='left_to_right')\n+\n+    benchmark(rebuild_model, User)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_smart_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[int, str, UUID]\n+        name: str\n+\n+    benchmark(rebuild_model, User)\n+\n+\n+@pytest.mark.parametrize('field_type', StdLibTypes)\n+@pytest.mark.benchmark(group='stdlib_schema_generation')\n+def test_stdlib_type_schema_generation(benchmark, field_type):\n+    class StdlibTypeModel(DeferredModel):\n+        field: field_type\n+\n+    benchmark(rebuild_model, StdlibTypeModel)",
      "comment": "For this one, I'm not sure if we want to keep it as is :thinking: `StdLibTypes`  of ~60 types, which means 60 separate tests. This is going to clutter the codspeed output :face_with_diagonal_mouth: ",
      "comment_id": 1766657918,
      "user": "Viicos",
      "created_at": "2024-09-19T11:22:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1766657918"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(BaseModel):\n+        dessert: Annotated[\n+            Union[\n+                Annotated[ApplePie, Tag('apple')],\n+                Annotated[PumpkinPie, Tag('pumpkin')],\n+            ],\n+            Discriminator(get_discriminator_value),\n+        ]\n+\n+    benchmark(rebuild_model, ThanksgivingDinner)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_nested_schema_generation(benchmark):\n+    class BlackCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['black']\n+        black_name: str\n+\n+    class WhiteCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['white']\n+        white_name: str\n+\n+    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        name: str\n+\n+    class Model(DeferredModel):\n+        pet: Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_left_to_right_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[str, int] = Field(union_mode='left_to_right')\n+\n+    benchmark(rebuild_model, User)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_smart_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[int, str, UUID]\n+        name: str\n+\n+    benchmark(rebuild_model, User)\n+\n+\n+@pytest.mark.parametrize('field_type', StdLibTypes)\n+@pytest.mark.benchmark(group='stdlib_schema_generation')\n+def test_stdlib_type_schema_generation(benchmark, field_type):\n+    class StdlibTypeModel(DeferredModel):\n+        field: field_type\n+\n+    benchmark(rebuild_model, StdlibTypeModel)",
      "comment": "Ah true. I wonder if there's a way to group tests via codspeed so that it doesn't clutter them - would love to have some tests for std types so that we can gauge changes in performance for lots of different schema builds.",
      "comment_id": 1766829232,
      "user": "sydney-runkle",
      "created_at": "2024-09-19T13:24:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1766829232"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 281,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(BaseModel):",
      "comment": "Thanks for the feedback on these 2! I will be fixing it ASAP.",
      "comment_id": 1768013872,
      "user": "AdolfoVillalobos",
      "created_at": "2024-09-20T05:45:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1768013872"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(BaseModel):\n+        dessert: Annotated[\n+            Union[\n+                Annotated[ApplePie, Tag('apple')],\n+                Annotated[PumpkinPie, Tag('pumpkin')],\n+            ],\n+            Discriminator(get_discriminator_value),\n+        ]\n+\n+    benchmark(rebuild_model, ThanksgivingDinner)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_nested_schema_generation(benchmark):",
      "comment": "Thanks for the insight. I'm always happy to learn a bit more about pydantic's internals. AI will remove them shortly",
      "comment_id": 1768014236,
      "user": "AdolfoVillalobos",
      "created_at": "2024-09-20T05:46:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1768014236"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(BaseModel):\n+        dessert: Annotated[\n+            Union[\n+                Annotated[ApplePie, Tag('apple')],\n+                Annotated[PumpkinPie, Tag('pumpkin')],\n+            ],\n+            Discriminator(get_discriminator_value),\n+        ]\n+\n+    benchmark(rebuild_model, ThanksgivingDinner)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_nested_schema_generation(benchmark):\n+    class BlackCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['black']\n+        black_name: str\n+\n+    class WhiteCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['white']\n+        white_name: str\n+\n+    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        name: str\n+\n+    class Model(DeferredModel):\n+        pet: Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_left_to_right_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[str, int] = Field(union_mode='left_to_right')\n+\n+    benchmark(rebuild_model, User)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_smart_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[int, str, UUID]\n+        name: str\n+\n+    benchmark(rebuild_model, User)\n+\n+\n+@pytest.mark.parametrize('field_type', StdLibTypes)\n+@pytest.mark.benchmark(group='stdlib_schema_generation')\n+def test_stdlib_type_schema_generation(benchmark, field_type):\n+    class StdlibTypeModel(DeferredModel):\n+        field: field_type\n+\n+    benchmark(rebuild_model, StdlibTypeModel)",
      "comment": "Hi! I agree @Viicos . I researched Codspeed's API and found no trivial way of grouping the outputs. \r\n\r\nA solution might be to create categories/clusters of stlib types that are \"similar\" by some criteria and reduce the number of total benchmarks from 60+ to 3 to 5 benchmarks, each encapsulating a particular group.\r\n\r\nAn example of grouping would be:\r\n```python\r\n# ... existing code ...\r\n\r\nStdLibTypes = [\r\n    # Group 1: Basic Types\r\n    [str, int, float, complex, bool, bytes],\r\n\r\n    # Group 2: Date and Time\r\n    [date, datetime, time, timedelta],\r\n\r\n    # Group 3: Collections and Containers\r\n    [deque, Deque[str], Deque[int], Deque[float], Deque[bytes],\r\n     list, List[int], List[str], List[bytes], List[float],\r\n     dict, Dict[str, float], Dict[str, bytes], Dict[str, int], Dict[str, str],\r\n     tuple, Tuple[int, str, float],\r\n     set, Set[int], Set[str],\r\n     frozenset, FrozenSet[int], FrozenSet[str]],\r\n\r\n    # Group 4: Special Types and Enums\r\n    [Decimal, Color, ToolEnum, IPv4Address, IPv6Address, IPv4Interface, IPv6Interface,\r\n     IPv4Network, IPv6Network, Path, Pattern, UUID, uuid4, uuid5, Point, User],\r\n\r\n    # Group 5: Advanced Typing\r\n    [Optional[int], Optional[str], Optional[float], Optional[bytes], Optional[bool],\r\n     Sequence[int], Sequence[str], Sequence[bytes], Sequence[float],\r\n     Iterable[int], Iterable[str], Iterable[bytes], Iterable[float],\r\n     Callable[[int], int], Callable[[str], str],\r\n     Literal['apple', 'pumpkin'], Type[Foo], Any]\r\n]\r\n\r\n# ... \r\n```\r\n\r\nI also agree with @sydney-runkle about having a more granular view of the performance, depending on which types are involved. Maybe someone could point to a better way to organize the groups to account for this need.  \r\n\r\n",
      "comment_id": 1768022049,
      "user": "AdolfoVillalobos",
      "created_at": "2024-09-20T05:54:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1768022049"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +238,104 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(BaseModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(BaseModel):\n+        dessert: Annotated[\n+            Union[\n+                Annotated[ApplePie, Tag('apple')],\n+                Annotated[PumpkinPie, Tag('pumpkin')],\n+            ],\n+            Discriminator(get_discriminator_value),\n+        ]\n+\n+    benchmark(rebuild_model, ThanksgivingDinner)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_nested_schema_generation(benchmark):\n+    class BlackCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['black']\n+        black_name: str\n+\n+    class WhiteCat(BaseModel):\n+        pet_type: Literal['cat']\n+        color: Literal['white']\n+        white_name: str\n+\n+    Cat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        name: str\n+\n+    class Model(DeferredModel):\n+        pet: Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_left_to_right_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[str, int] = Field(union_mode='left_to_right')\n+\n+    benchmark(rebuild_model, User)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_untagged_union_smart_mode_schema_generation(benchmark):\n+    class User(DeferredModel):\n+        id: Union[int, str, UUID]\n+        name: str\n+\n+    benchmark(rebuild_model, User)\n+\n+\n+@pytest.mark.parametrize('field_type', StdLibTypes)\n+@pytest.mark.benchmark(group='stdlib_schema_generation')\n+def test_stdlib_type_schema_generation(benchmark, field_type):\n+    class StdlibTypeModel(DeferredModel):\n+        field: field_type\n+\n+    benchmark(rebuild_model, StdlibTypeModel)",
      "comment": "@Viicos and I had a chat - let's skip this benchmark for now (leave it in the code, just use a decorator to skip) - I think the granularity here is important - we can enable on branches that it makes sense to test on!",
      "comment_id": 1768545984,
      "user": "sydney-runkle",
      "created_at": "2024-09-20T12:33:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1768545984"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10362,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 294,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +237,62 @@ def serialize_model(self) -> Any:\n             return self.field\n \n     benchmark(rebuild_model, ModelWithValidator)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_str_discriminator_schema_generation(benchmark):\n+    class Cat(BaseModel):\n+        pet_type: Literal['cat']\n+        meows: int\n+\n+    class Dog(BaseModel):\n+        pet_type: Literal['dog']\n+        barks: float\n+\n+    class Lizard(BaseModel):\n+        pet_type: Literal['reptile', 'lizard']\n+        scales: bool\n+\n+    class Model(DeferredModel):\n+        pet: Union[Cat, Dog, Lizard] = Field(..., discriminator='pet_type')\n+        n: int\n+\n+    benchmark(rebuild_model, Model)\n+\n+\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_tagged_union_with_callable_discriminator_schema_generation(benchmark):\n+    class Pie(BaseModel):\n+        time_to_cook: int\n+        num_ingredients: int\n+\n+    class ApplePie(Pie):\n+        fruit: Literal['apple'] = 'apple'\n+\n+    class PumpkinPie(Pie):\n+        filling: Literal['pumpkin'] = 'pumpkin'\n+\n+    def get_discriminator_value(v: Any) -> str:\n+        if isinstance(v, dict):\n+            return v.get('fruit', v.get('filling'))\n+        return getattr(v, 'fruit', getattr(v, 'filling', None))\n+\n+    class ThanksgivingDinner(DeferredModel):\n+        dessert: Annotated[\n+            Union[\n+                Annotated[ApplePie, Tag('apple')],\n+                Annotated[PumpkinPie, Tag('pumpkin')],\n+            ],\n+            Discriminator(get_discriminator_value),\n+        ]\n+\n+    benchmark(rebuild_model, ThanksgivingDinner)\n+\n+\n+@pytest.mark.parametrize('field_type', StdLibTypes)\n+@pytest.mark.benchmark(group='stdlib_schema_generation')\n+def test_stdlib_type_schema_generation(benchmark, field_type):",
      "comment": "```suggestion\r\n@pytest.mark.skip('Clutters codspeed CI, but should be enabled on branches where we modify schema building.')\r\ndef test_stdlib_type_schema_generation(benchmark, field_type):\r\n```",
      "comment_id": 1768549685,
      "user": "sydney-runkle",
      "created_at": "2024-09-20T12:37:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/10362#discussion_r1768549685"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10439,
      "file_path": "pydantic/functional_validators.py",
      "line": 136,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,13 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaH\n             if self.json_schema_input_type is PydanticUndefined\n             else handler.generate_schema(self.json_schema_input_type)\n         )\n+        # Try to resolve the original schema if required, because schema cleaning\n+        # won't inline references in metadata:\n+        if input_schema is not None:\n+            try:\n+                input_schema = handler.resolve_ref_schema(input_schema)\n+            except LookupError:\n+                pass",
      "comment": "Somewhat redundant with the `WrapValidator`, but this code is rather easy to understand as is, and I'd prefer to not add complexity by abstracting this away somewhere else \ud83d\udc4d ",
      "comment_id": 1765057005,
      "user": "sydney-runkle",
      "created_at": "2024-09-18T13:26:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10439#discussion_r1765057005"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10439,
      "file_path": "pydantic/functional_validators.py",
      "line": 136,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,13 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaH\n             if self.json_schema_input_type is PydanticUndefined\n             else handler.generate_schema(self.json_schema_input_type)\n         )\n+        # Try to resolve the original schema if required, because schema cleaning\n+        # won't inline references in metadata:\n+        if input_schema is not None:\n+            try:\n+                input_schema = handler.resolve_ref_schema(input_schema)\n+            except LookupError:\n+                pass",
      "comment": "Yes overall most of the logic for the validators are duplicated, but it's indeed great to have this duplication for clarity.",
      "comment_id": 1765392317,
      "user": "Viicos",
      "created_at": "2024-09-18T16:41:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/10439#discussion_r1765392317"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10316,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 191,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,163 +178,44 @@ class Product(BaseModel):\n                 model_fields[f'field_{j}'] = (field_type, ...)\n \n         model_name = f'Model_{i}'\n-        model = create_model(model_name, **model_fields)\n-        globals()[model_name] = model\n-\n-\n-@pytest.mark.parametrize('validator_mode', ['before', 'after', 'plain'])\n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_field_validator_via_decorator(benchmark, validator_mode) -> None:\n-    def schema_gen() -> None:\n-        class ModelWithFieldValidator(BaseModel):\n-            field: Any\n-\n-            @field_validator('field', mode=validator_mode)\n-            @classmethod\n-            def validate_field(cls, v: Any):\n-                return v\n-\n-    benchmark(schema_gen)\n-\n-\n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_wrap_field_validator_via_decorator(benchmark) -> None:\n-    def schema_gen() -> None:\n-        class ModelWithWrapFieldValidator(BaseModel):\n-            field: Any\n-\n-            @field_validator('field', mode='wrap')\n-            @classmethod\n-            def validate_field(cls, v: Any, handler: ValidatorFunctionWrapHandler) -> Any:\n-                return handler(v)\n-\n-    benchmark(schema_gen)\n-\n-\n-@pytest.mark.parametrize('validator_constructor', [BeforeValidator, AfterValidator, PlainValidator])\n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_field_validator_via_annotation(benchmark, validator_constructor) -> None:\n-    def validate_field(v: Any) -> Any:\n-        return v\n-\n-    def schema_gen(validation_func) -> None:\n-        class ModelWithFieldValidator(BaseModel):\n-            field: Annotated[Any, validator_constructor(validation_func)]\n-\n-    benchmark(schema_gen, validate_field)\n-\n-\n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_wrap_field_validator_via_annotation(benchmark) -> None:\n-    def validate_field(v: Any, handler: ValidatorFunctionWrapHandler) -> Any:\n-        return handler(v)\n-\n-    def schema_gen(validator_func: Callable) -> None:\n-        class ModelWithWrapFieldValidator(BaseModel):\n-            field: Annotated[Any, WrapValidator(validator_func)]\n-\n-    benchmark(schema_gen, validate_field)\n-\n+        models.append(create_model(model_name, __config__={'defer_build': True}, **model_fields))\n \n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_model_validator_before(benchmark):\n-    def schema_gen() -> None:\n-        class ModelWithBeforeValidator(BaseModel):\n-            field: Any\n-\n-            @model_validator(mode='before')\n-            @classmethod\n-            def validate_model_before(cls, data: Any) -> Any:\n-                return data\n+    def rebuild_models(models: List[Type[BaseModel]]) -> None:\n+        for model in models:\n+            rebuild_model(model)\n \n-    benchmark(schema_gen)\n+    benchmark(rebuild_models, models)\n \n \n @pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_model_validator_after(benchmark) -> None:\n-    def schema_gen() -> None:\n-        class ModelWithAfterValidator(BaseModel):\n-            field: Any\n-\n-            @model_validator(mode='after')\n-            def validate_model_after(self: 'ModelWithAfterValidator') -> 'ModelWithAfterValidator':\n-                return self\n+def test_field_validators_serializers(benchmark) -> None:",
      "comment": "I condensed everything in one benchmark because:\r\n- We don't expect decorators vs Annotated metadata classes to make a difference, converting from the decorator to the `*Validator/*Serializer` class probably takes a few ns at most.\r\n- We don't expect any changes in performance between modes, so there's no need to make them separate benchmarks\r\n\r\n(code coverage is still untouched with these changes)",
      "comment_id": 1747082450,
      "user": "Viicos",
      "created_at": "2024-09-06T12:56:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10316#discussion_r1747082450"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10316,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 191,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,163 +178,44 @@ class Product(BaseModel):\n                 model_fields[f'field_{j}'] = (field_type, ...)\n \n         model_name = f'Model_{i}'\n-        model = create_model(model_name, **model_fields)\n-        globals()[model_name] = model\n-\n-\n-@pytest.mark.parametrize('validator_mode', ['before', 'after', 'plain'])\n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_field_validator_via_decorator(benchmark, validator_mode) -> None:\n-    def schema_gen() -> None:\n-        class ModelWithFieldValidator(BaseModel):\n-            field: Any\n-\n-            @field_validator('field', mode=validator_mode)\n-            @classmethod\n-            def validate_field(cls, v: Any):\n-                return v\n-\n-    benchmark(schema_gen)\n-\n-\n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_wrap_field_validator_via_decorator(benchmark) -> None:\n-    def schema_gen() -> None:\n-        class ModelWithWrapFieldValidator(BaseModel):\n-            field: Any\n-\n-            @field_validator('field', mode='wrap')\n-            @classmethod\n-            def validate_field(cls, v: Any, handler: ValidatorFunctionWrapHandler) -> Any:\n-                return handler(v)\n-\n-    benchmark(schema_gen)\n-\n-\n-@pytest.mark.parametrize('validator_constructor', [BeforeValidator, AfterValidator, PlainValidator])\n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_field_validator_via_annotation(benchmark, validator_constructor) -> None:\n-    def validate_field(v: Any) -> Any:\n-        return v\n-\n-    def schema_gen(validation_func) -> None:\n-        class ModelWithFieldValidator(BaseModel):\n-            field: Annotated[Any, validator_constructor(validation_func)]\n-\n-    benchmark(schema_gen, validate_field)\n-\n-\n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_wrap_field_validator_via_annotation(benchmark) -> None:\n-    def validate_field(v: Any, handler: ValidatorFunctionWrapHandler) -> Any:\n-        return handler(v)\n-\n-    def schema_gen(validator_func: Callable) -> None:\n-        class ModelWithWrapFieldValidator(BaseModel):\n-            field: Annotated[Any, WrapValidator(validator_func)]\n-\n-    benchmark(schema_gen, validate_field)\n-\n+        models.append(create_model(model_name, __config__={'defer_build': True}, **model_fields))\n \n-@pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_model_validator_before(benchmark):\n-    def schema_gen() -> None:\n-        class ModelWithBeforeValidator(BaseModel):\n-            field: Any\n-\n-            @model_validator(mode='before')\n-            @classmethod\n-            def validate_model_before(cls, data: Any) -> Any:\n-                return data\n+    def rebuild_models(models: List[Type[BaseModel]]) -> None:\n+        for model in models:\n+            rebuild_model(model)\n \n-    benchmark(schema_gen)\n+    benchmark(rebuild_models, models)\n \n \n @pytest.mark.benchmark(group='model_schema_generation')\n-def test_custom_model_validator_after(benchmark) -> None:\n-    def schema_gen() -> None:\n-        class ModelWithAfterValidator(BaseModel):\n-            field: Any\n-\n-            @model_validator(mode='after')\n-            def validate_model_after(self: 'ModelWithAfterValidator') -> 'ModelWithAfterValidator':\n-                return self\n+def test_field_validators_serializers(benchmark) -> None:",
      "comment": "Seems reasonable, and I suppose if there is a change in this benchmark, it's pretty obvious where to look for changes.",
      "comment_id": 1765168636,
      "user": "sydney-runkle",
      "created_at": "2024-09-18T14:28:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/10316#discussion_r1765168636"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10431,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 826,
      "side": "RIGHT",
      "diff_hunk": "@@ -821,10 +821,18 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n         ):\n             schema = existing_schema\n         elif (validators := getattr(obj, '__get_validators__', None)) is not None:\n-            warn(\n-                '`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.',\n-                PydanticDeprecatedSince20,\n-            )\n+            from pydantic.v1 import BaseModel as BaseModelV1\n+\n+            if issubclass(obj, BaseModelV1):",
      "comment": "```suggestion\r\n            if inspect.isclass(obj) and issubclass(obj, BaseModelV1):\r\n```\r\nBecause `issubclass` raises a `TypeError` if `obj` is not a class. But I'm wondering if it's possible for `obj` to have `__get_validators__` and not being a class in this context, so probably not necessary to add the `isclass` check.",
      "comment_id": 1763678637,
      "user": "Viicos",
      "created_at": "2024-09-17T18:10:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10431#discussion_r1763678637"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10431,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 830,
      "side": "RIGHT",
      "diff_hunk": "@@ -821,10 +821,18 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n         ):\n             schema = existing_schema\n         elif (validators := getattr(obj, '__get_validators__', None)) is not None:\n-            warn(\n-                '`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.',\n-                PydanticDeprecatedSince20,\n-            )\n+            from pydantic.v1 import BaseModel as BaseModelV1\n+\n+            if issubclass(obj, BaseModelV1):\n+                warn(\n+                    f'Nesting V1 models inside V2 models is not supported. Please upgrade `{obj.__name__}` to V2.',\n+                    UserWarning,\n+                )",
      "comment": "This will warn when doing the following:\r\n\r\n```python\r\nfrom pydantic import TypeAdapter\r\nfrom pydantic.v1 import BaseModel as BaseModelV1\r\n\r\nTypeAdapter(BaseModelV1)\r\n```\r\n\r\nSo maybe there's a way to check for the current model stack before warning?",
      "comment_id": 1763679630,
      "user": "Viicos",
      "created_at": "2024-09-17T18:11:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10431#discussion_r1763679630"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10431,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 826,
      "side": "RIGHT",
      "diff_hunk": "@@ -821,10 +821,18 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n         ):\n             schema = existing_schema\n         elif (validators := getattr(obj, '__get_validators__', None)) is not None:\n-            warn(\n-                '`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.',\n-                PydanticDeprecatedSince20,\n-            )\n+            from pydantic.v1 import BaseModel as BaseModelV1\n+\n+            if issubclass(obj, BaseModelV1):",
      "comment": "Will leave it out for now, and can add this back if there's an issue \ud83d\udc4d ",
      "comment_id": 1765037097,
      "user": "sydney-runkle",
      "created_at": "2024-09-18T13:15:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/10431#discussion_r1765037097"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10431,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 830,
      "side": "RIGHT",
      "diff_hunk": "@@ -821,10 +821,18 @@ def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.C\n         ):\n             schema = existing_schema\n         elif (validators := getattr(obj, '__get_validators__', None)) is not None:\n-            warn(\n-                '`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.',\n-                PydanticDeprecatedSince20,\n-            )\n+            from pydantic.v1 import BaseModel as BaseModelV1\n+\n+            if issubclass(obj, BaseModelV1):\n+                warn(\n+                    f'Nesting V1 models inside V2 models is not supported. Please upgrade `{obj.__name__}` to V2.',\n+                    UserWarning,\n+                )",
      "comment": "Hmm, we don't support `TypeAdapter` with v1 models anyways... so maybe I should just make the warning more broad?",
      "comment_id": 1765050193,
      "user": "sydney-runkle",
      "created_at": "2024-09-18T13:22:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10431#discussion_r1765050193"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10313,
      "file_path": "pydantic/dataclasses.py",
      "line": 334,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,11 +321,17 @@ def rebuild_dataclass(\n                 types_namespace = {}\n \n             types_namespace = _typing_extra.merge_cls_and_parent_ns(cls, types_namespace)\n+\n         return _pydantic_dataclasses.complete_dataclass(\n             cls,\n             _config.ConfigWrapper(cls.__pydantic_config__, check=False),\n             raise_errors=raise_errors,\n             types_namespace=types_namespace,\n+            # We could provide a different config instead (with `'defer_build'` set to `True`)\n+            # but this doesn't play well in some cases as unlike Pydantic models, Pydantic dataclasses\n+            # can have the config coming from the `config` argument or from the `__pydantic_config__`\n+            # property. So we use an explicit argument:\n+            _force_build=True,",
      "comment": "For Pydantic models, we pass `{**config, \"defer_build\": False}` as the config, but for dataclasses this doesn't work well with this kind of scenario:\r\n\r\n```python\r\n@pydantic.dataclasses.dataclass(config=ConfigDict())\r\nclass Model:\r\n    x: str\r\n    __pydantic_config__ = ConfigDict(str_to_lower=True)\r\n```\r\n\r\nHence the unfortunate new parameter.",
      "comment_id": 1745765424,
      "user": "Viicos",
      "created_at": "2024-09-05T15:28:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10313#discussion_r1745765424"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10313,
      "file_path": "pydantic/dataclasses.py",
      "line": 334,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,11 +321,17 @@ def rebuild_dataclass(\n                 types_namespace = {}\n \n             types_namespace = _typing_extra.merge_cls_and_parent_ns(cls, types_namespace)\n+\n         return _pydantic_dataclasses.complete_dataclass(\n             cls,\n             _config.ConfigWrapper(cls.__pydantic_config__, check=False),\n             raise_errors=raise_errors,\n             types_namespace=types_namespace,\n+            # We could provide a different config instead (with `'defer_build'` set to `True`)\n+            # but this doesn't play well in some cases as unlike Pydantic models, Pydantic dataclasses\n+            # can have the config coming from the `config` argument or from the `__pydantic_config__`\n+            # property. So we use an explicit argument:\n+            _force_build=True,",
      "comment": "Hmm, I'd prefer we either disallow configs in both locations, or merge them with priority towards one.\r\n\r\nThat way, we could have one unified config for the model that we can patch with the `defer_build` when necessary.",
      "comment_id": 1746196047,
      "user": "sydney-runkle",
      "created_at": "2024-09-05T21:50:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10313#discussion_r1746196047"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10313,
      "file_path": "pydantic/dataclasses.py",
      "line": 334,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,11 +321,17 @@ def rebuild_dataclass(\n                 types_namespace = {}\n \n             types_namespace = _typing_extra.merge_cls_and_parent_ns(cls, types_namespace)\n+\n         return _pydantic_dataclasses.complete_dataclass(\n             cls,\n             _config.ConfigWrapper(cls.__pydantic_config__, check=False),\n             raise_errors=raise_errors,\n             types_namespace=types_namespace,\n+            # We could provide a different config instead (with `'defer_build'` set to `True`)\n+            # but this doesn't play well in some cases as unlike Pydantic models, Pydantic dataclasses\n+            # can have the config coming from the `config` argument or from the `__pydantic_config__`\n+            # property. So we use an explicit argument:\n+            _force_build=True,",
      "comment": "Should be able to move forward now that we've merged https://github.com/pydantic/pydantic/pull/10406",
      "comment_id": 1759713332,
      "user": "sydney-runkle",
      "created_at": "2024-09-14T10:31:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/10313#discussion_r1759713332"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10432,
      "file_path": "pydantic/validators.py",
      "line": 767,
      "side": "RIGHT",
      "diff_hunk": "@@ -762,4 +763,6 @@ def find_validators(  # noqa: C901 (ignore complexity)\n     if config.arbitrary_types_allowed:\n         yield make_arbitrary_type_validator(type_)\n     else:\n+        if hasattr(type_, '__pydantic_core_schema__'):\n+            warn('Mixing V1 and V2 models is not supported. `{type_}` is a V2 model.', UserWarning)",
      "comment": "```suggestion\r\n            warn(f'Mixing V1 and V2 models is not supported. `{type_.__name__}` is a V2 model.', UserWarning)\r\n```",
      "comment_id": 1763688799,
      "user": "Viicos",
      "created_at": "2024-09-17T18:15:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10432#discussion_r1763688799"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10427,
      "file_path": "pydantic/functional_validators.py",
      "line": 200,
      "side": "RIGHT",
      "diff_hunk": "@@ -190,10 +190,15 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaH\n \n         try:\n             schema = handler(source_type)\n-            serialization = core_schema.wrap_serializer_function_ser_schema(\n-                function=lambda v, h: h(v),\n-                schema=schema,\n-                return_schema=schema,\n+            # TODO if `schema['serialization']` is one of `'include-exclude-dict/sequence',\n+            # schema validation will fail. That's why we use 'type ignore' comments below.\n+            serialization = schema.get(\n+                'serialization',\n+                core_schema.wrap_serializer_function_ser_schema(\n+                    function=lambda v, h: h(v),\n+                    schema=schema,\n+                    return_schema=schema,",
      "comment": "Do we not need to do `handler.generate_schema(source_type)` here?",
      "comment_id": 1763209730,
      "user": "sydney-runkle",
      "created_at": "2024-09-17T13:02:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/10427#discussion_r1763209730"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10427,
      "file_path": "pydantic/functional_validators.py",
      "line": 200,
      "side": "RIGHT",
      "diff_hunk": "@@ -190,10 +190,15 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaH\n \n         try:\n             schema = handler(source_type)\n-            serialization = core_schema.wrap_serializer_function_ser_schema(\n-                function=lambda v, h: h(v),\n-                schema=schema,\n-                return_schema=schema,\n+            # TODO if `schema['serialization']` is one of `'include-exclude-dict/sequence',\n+            # schema validation will fail. That's why we use 'type ignore' comments below.\n+            serialization = schema.get(\n+                'serialization',\n+                core_schema.wrap_serializer_function_ser_schema(\n+                    function=lambda v, h: h(v),\n+                    schema=schema,\n+                    return_schema=schema,",
      "comment": "Hum I don't think it will change anything in this case as `schema` is guaranteed to not have any serialization key here, but I'll change to align with how it is done in `Plain/WrapSerializer`.",
      "comment_id": 1763313128,
      "user": "Viicos",
      "created_at": "2024-09-17T14:03:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/10427#discussion_r1763313128"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10417,
      "file_path": "tests/test_json_schema.py",
      "line": 6564,
      "side": "RIGHT",
      "diff_hunk": "@@ -6554,3 +6554,20 @@ class Model(BaseModel):\n         some_field: str = Field(alias='_some_field')\n \n     assert Model.model_json_schema()['properties']['_some_field']['title'] == 'Some Field'\n+\n+\n+@pytest.mark.skip_json_schema_validation(reason='Custom ref used.')\n+def test_arbitrary_ref_in_json_schema() -> None:\n+    \"\"\"See https://github.com/pydantic/pydantic/issues/9981.\"\"\"\n+\n+    class Test(BaseModel):\n+        x: dict = Field(examples={'$ref': '#/components/schemas/Pet'})",
      "comment": "```suggestion\r\n        x: dict = Field(examples=[{'$ref': '#/components/schemas/Pet'}])\r\n```\r\n\r\nEven though the test works because `skip_json_schema_validation` is used, still good to have valid JSON Schemas generated.",
      "comment_id": 1761998460,
      "user": "Viicos",
      "created_at": "2024-09-16T21:41:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/10417#discussion_r1761998460"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10417,
      "file_path": "tests/test_json_schema.py",
      "line": 6564,
      "side": "RIGHT",
      "diff_hunk": "@@ -6554,3 +6554,20 @@ class Model(BaseModel):\n         some_field: str = Field(alias='_some_field')\n \n     assert Model.model_json_schema()['properties']['_some_field']['title'] == 'Some Field'\n+\n+\n+@pytest.mark.skip_json_schema_validation(reason='Custom ref used.')\n+def test_arbitrary_ref_in_json_schema() -> None:\n+    \"\"\"See https://github.com/pydantic/pydantic/issues/9981.\"\"\"\n+\n+    class Test(BaseModel):\n+        x: dict = Field(examples={'$ref': '#/components/schemas/Pet'})",
      "comment": "Or maybe using a dict as an example was a requirement to have the added logic in `get_json_ref_counts` covered by this test?",
      "comment_id": 1761999026,
      "user": "Viicos",
      "created_at": "2024-09-16T21:41:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10417#discussion_r1761999026"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10417,
      "file_path": "tests/test_json_schema.py",
      "line": 6564,
      "side": "RIGHT",
      "diff_hunk": "@@ -6554,3 +6554,20 @@ class Model(BaseModel):\n         some_field: str = Field(alias='_some_field')\n \n     assert Model.model_json_schema()['properties']['_some_field']['title'] == 'Some Field'\n+\n+\n+@pytest.mark.skip_json_schema_validation(reason='Custom ref used.')\n+def test_arbitrary_ref_in_json_schema() -> None:\n+    \"\"\"See https://github.com/pydantic/pydantic/issues/9981.\"\"\"\n+\n+    class Test(BaseModel):\n+        x: dict = Field(examples={'$ref': '#/components/schemas/Pet'})",
      "comment": "Good call - I've switched to a list, and removed the xfail. This still works, as we unpack a `list` of things in `get_json_ref_counts` and iterate over those :)",
      "comment_id": 1762024928,
      "user": "sydney-runkle",
      "created_at": "2024-09-16T22:13:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10417#discussion_r1762024928"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10408,
      "file_path": "tests/test_types_zoneinfo.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,3 +51,8 @@ def test_zoneinfo_json_schema():\n         'properties': {'tz': {'type': 'string', 'format': 'zoneinfo', 'title': 'Tz'}},\n         'required': ['tz'],\n     }\n+\n+\n+def test_zoneinfo_union() -> None:\n+    ta = TypeAdapter(Union[zoneinfo.ZoneInfo, timezone], config=ConfigDict(arbitrary_types_allowed=True))",
      "comment": "What's the reason to have `arbitrary_types_allowed` here?",
      "comment_id": 1759206859,
      "user": "Viicos",
      "created_at": "2024-09-13T17:06:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10408#discussion_r1759206859"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10406,
      "file_path": "pydantic/dataclasses.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,6 +201,17 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n \n         original_cls = cls\n \n+        # we warn on conflicting config specifications, but only if the class doesn't have a dataclass base\n+        # because a dataclass base might provide a __pydantic_config__ attribute that we don't want to warn about\n+        has_dataclass_base = cls.__bases__ != (object,)\n+        if config and (getattr(cls, '__pydantic_config__', None) and not has_dataclass_base):\n+            warn(\n+                f'`config` is set via both the `dataclass` decorator and `__pydantic_config__` for dataclass {cls.__name__}. '\n+                f'This is not supported. The `config` specification from `dataclass` decorator will take priority.',",
      "comment": "```suggestion\r\n                f'The `config` specification from `dataclass` decorator will take priority.',\r\n```\r\nI'd say theoretically it is supported, just that one takes the priority over the other. wdyt? ",
      "comment_id": 1759120269,
      "user": "Viicos",
      "created_at": "2024-09-13T16:02:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10406#discussion_r1759120269"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10406,
      "file_path": "pydantic/dataclasses.py",
      "line": 206,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,6 +201,17 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n \n         original_cls = cls\n \n+        # we warn on conflicting config specifications, but only if the class doesn't have a dataclass base\n+        # because a dataclass base might provide a __pydantic_config__ attribute that we don't want to warn about\n+        has_dataclass_base = cls.__bases__ != (object,)",
      "comment": "```suggestion\r\n        has_dataclass_base = any(is_dataclass(base) for base in cls.__bases__)\r\n```\r\n",
      "comment_id": 1759130920,
      "user": "Viicos",
      "created_at": "2024-09-13T16:10:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10406#discussion_r1759130920"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10406,
      "file_path": "pydantic/dataclasses.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,6 +201,17 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n \n         original_cls = cls\n \n+        # we warn on conflicting config specifications, but only if the class doesn't have a dataclass base\n+        # because a dataclass base might provide a __pydantic_config__ attribute that we don't want to warn about\n+        has_dataclass_base = cls.__bases__ != (object,)\n+        if config and (getattr(cls, '__pydantic_config__', None) and not has_dataclass_base):",
      "comment": "```suggestion\r\n        if not has_dataclass_base and config is not None and hasattr(cls, '__pydantic_config__'):\r\n```",
      "comment_id": 1759132218,
      "user": "Viicos",
      "created_at": "2024-09-13T16:11:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/10406#discussion_r1759132218"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10390,
      "file_path": "tests/test_serialize.py",
      "line": 1085,
      "side": "RIGHT",
      "diff_hunk": "@@ -1073,22 +1072,21 @@ def quadruple_x_plus_one(self) -> Annotated[int, PlainSerializer(lambda v: v + 1\n     }\n \n \n-def test_computed_field_custom_serializer_bad_signature():\n-    error_msg = 'field_serializer on computed_field does not use info signature'\n-\n-    with pytest.raises(PydanticUserError, match=error_msg):\n+def test_computed_field_custom_serializer_signature_with_info():\n+    class Model(BaseModel):\n+        x: int\n \n-        class Model(BaseModel):\n-            x: int\n+        @computed_field\n+        @property\n+        def two_x(self) -> int:\n+            return self.x * 2\n \n-            @computed_field\n-            @property\n-            def two_x(self) -> int:\n-                return self.x * 2\n+        @field_serializer('two_x')\n+        def ser_two_x_bad_signature(self, v, _info):",
      "comment": "Should probably rename this - doesn't have a bad signature now.",
      "comment_id": 1756957115,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T14:12:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10390#discussion_r1756957115"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10390,
      "file_path": "tests/test_serialize.py",
      "line": 1085,
      "side": "RIGHT",
      "diff_hunk": "@@ -1073,22 +1072,21 @@ def quadruple_x_plus_one(self) -> Annotated[int, PlainSerializer(lambda v: v + 1\n     }\n \n \n-def test_computed_field_custom_serializer_bad_signature():\n-    error_msg = 'field_serializer on computed_field does not use info signature'\n-\n-    with pytest.raises(PydanticUserError, match=error_msg):\n+def test_computed_field_custom_serializer_signature_with_info():\n+    class Model(BaseModel):\n+        x: int\n \n-        class Model(BaseModel):\n-            x: int\n+        @computed_field\n+        @property\n+        def two_x(self) -> int:\n+            return self.x * 2\n \n-            @computed_field\n-            @property\n-            def two_x(self) -> int:\n-                return self.x * 2\n+        @field_serializer('two_x')\n+        def ser_two_x_bad_signature(self, v, _info):",
      "comment": "Can probably delete this test honestly - not sure of the value here anymore, especially given the other test added above.",
      "comment_id": 1756957978,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T14:12:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10390#discussion_r1756957978"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10390,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1975,
      "side": "RIGHT",
      "diff_hunk": "@@ -1972,7 +1972,6 @@ def _computed_field_schema(\n         return_type_schema = self._apply_field_serializers(\n             return_type_schema,\n             filter_field_decorator_info_by_field(field_serializers.values(), d.cls_var_name),\n-            computed_field=True,\n         )",
      "comment": "I believe you can remove the `computed_field` argument from the `_apply_field_serializers` function as well.\r\n\r\nhttps://github.com/pydantic/pydantic/blob/a6dc87285f93f90c2d5c298ee7c52f5d7e878194/pydantic/_internal/_generate_schema.py#L2196C9-L2201",
      "comment_id": 1758886279,
      "user": "sydney-runkle",
      "created_at": "2024-09-13T13:36:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10390#discussion_r1758886279"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10390,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1975,
      "side": "RIGHT",
      "diff_hunk": "@@ -1972,7 +1972,6 @@ def _computed_field_schema(\n         return_type_schema = self._apply_field_serializers(\n             return_type_schema,\n             filter_field_decorator_info_by_field(field_serializers.values(), d.cls_var_name),\n-            computed_field=True,\n         )",
      "comment": "https://github.com/pydantic/pydantic/pull/10390/files#diff-2ebfa892ec1d09440eefd4b22f488ec38c1cde365394e5a4cea6edb484827ba5R2198-R2199\r\n@sydney-runkle I've already removed it in this commit.",
      "comment_id": 1758973559,
      "user": "nix010",
      "created_at": "2024-09-13T14:27:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/10390#discussion_r1758973559"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10374,
      "file_path": "pydantic/validate_call_decorator.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -59,9 +60,17 @@ def validate(function: AnyCallableT) -> AnyCallableT:\n         def wrapper_function(*args, **kwargs):\n             return validate_call_wrapper(*args, **kwargs)\n \n+        @functools.wraps(function)\n+        async def async_wrapper_function(*args, **kwargs):\n+            return await validate_call_wrapper(*args, **kwargs)\n+\n         wrapper_function.raw_function = function  # type: ignore\n+        async_wrapper_function.raw_function = function  # type: ignore\n \n-        return wrapper_function  # type: ignore\n+        if inspect.iscoroutinefunction(function):\n+            return async_wrapper_function  # type: ignore\n+        else:\n+            return wrapper_function  # type: ignore",
      "comment": "Let's add the function definitions (`wrapper_function` and `async_wrapper_function`) to the relevant parts of this conditional. Can also move the `.raw_function` assignments there as well.",
      "comment_id": 1754528183,
      "user": "sydney-runkle",
      "created_at": "2024-09-11T13:25:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10374#discussion_r1754528183"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10374,
      "file_path": "tests/test_validate_call.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -292,6 +292,9 @@ async def run():\n         v = await foo(1, 2)\n         assert v == 'a=1 b=2'\n \n+    # insert_assert(inspect.iscoroutinefunction(foo)==True)\n+    assert inspect.iscoroutinefunction(foo)",
      "comment": "```suggestion\r\n    # insert_assert(inspect.iscoroutinefunction(foo) is True)\r\n    assert inspect.iscoroutinefunction(foo) is True\r\n```",
      "comment_id": 1756987669,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T14:28:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10374#discussion_r1756987669"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10374,
      "file_path": "pydantic/validate_call_decorator.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,13 +56,24 @@ def validate(function: AnyCallableT) -> AnyCallableT:\n \n         validate_call_wrapper = _validate_call.ValidateCallWrapper(function, config, validate_return, local_ns)\n \n-        @functools.wraps(function)\n-        def wrapper_function(*args, **kwargs):\n-            return validate_call_wrapper(*args, **kwargs)\n+        if inspect.iscoroutinefunction(function):\n \n-        wrapper_function.raw_function = function  # type: ignore\n+            @functools.wraps(function)\n+            async def async_wrapper_function(*args, **kwargs):\n+                return await validate_call_wrapper(*args, **kwargs)\n \n-        return wrapper_function  # type: ignore\n+            async_wrapper_function.raw_function = function  # type: ignore\n+\n+            return async_wrapper_function  # type: ignore\n+        else:\n+\n+            @functools.wraps(function)\n+            def wrapper_function(*args, **kwargs):\n+                return validate_call_wrapper(*args, **kwargs)\n+\n+            wrapper_function.raw_function = function  # type: ignore\n+\n+            return wrapper_function  # type: ignore",
      "comment": "Maybe instead, further reducing repetition:\r\n\r\n```py\r\nif inspect.iscoroutinefunction(function):\r\n\r\n    @functools.wraps(function)\r\n    async def wrapper_function(*args, **kwargs):\r\n        return await validate_call_wrapper(*args, **kwargs)\r\nelse:\r\n\r\n    @functools.wraps(function)\r\n    def wrapper_function(*args, **kwargs):\r\n        return validate_call_wrapper(*args, **kwargs)\r\n\r\nwrapper_function.raw_function = function  # type: ignore\r\nreturn wrapper_function  # type: ignore\r\n```\r\n\r\nOther than that, LGTM, thanks!",
      "comment_id": 1757005623,
      "user": "sydney-runkle",
      "created_at": "2024-09-12T14:38:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10374#discussion_r1757005623"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10113,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,8 +181,8 @@ def parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:\n     other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.\n     \"\"\"\n     frame = sys._getframe(parent_depth)\n-    # if f_back is None, it's the global module namespace and we don't need to include it here\n-    if frame.f_back is None:\n+    # if the class is defined at the top module level, we don't need to add namespace information\n+    if frame.f_back is None or getframeinfo(frame).function == '<module>':",
      "comment": "I believe I am missing something: if `frame.f_back` is `None`, doesn't that mean we are already know the `frame`'s \"function\" is the module already?\r\n\r\nI've tried defining the following::\r\n\r\n```python\r\nclass ModuleModel(BaseModel):\r\n    pass\r\n\r\ndef func():\r\n    class FuncModel(BaseModel):\r\n        pass\r\n\r\nfunc()\r\n```\r\n\r\nFor `ModuleModel`, both `frame.f_back is None` and `getframeinfo(frame).function == '<module>'` evaluate to `True`.\r\n\r\nFor `FuncModel`, they both evaluate to `False`.",
      "comment_id": 1714981531,
      "user": "Viicos",
      "created_at": "2024-08-13T09:33:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/10113#discussion_r1714981531"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10113,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,8 +181,8 @@ def parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:\n     other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.\n     \"\"\"\n     frame = sys._getframe(parent_depth)\n-    # if f_back is None, it's the global module namespace and we don't need to include it here\n-    if frame.f_back is None:\n+    # if the class is defined at the top module level, we don't need to add namespace information\n+    if frame.f_back is None or getframeinfo(frame).function == '<module>':",
      "comment": "You're right, the trouble comes when you're in another module and importing `ModuleModel`, then `frame.f_back` is not `None`, but `getframeinfo(frame).function == '<module>'` evaluates to `True`, and so it's ok to skip this namespace collection because we can access `ModuleModel`'s `__module__` and associated namespace.",
      "comment_id": 1715222339,
      "user": "sydney-runkle",
      "created_at": "2024-08-13T12:38:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/10113#discussion_r1715222339"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10113,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,8 +181,8 @@ def parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:\n     other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.\n     \"\"\"\n     frame = sys._getframe(parent_depth)\n-    # if f_back is None, it's the global module namespace and we don't need to include it here\n-    if frame.f_back is None:\n+    # if the class is defined at the top module level, we don't need to add namespace information\n+    if frame.f_back is None or getframeinfo(frame).function == '<module>':",
      "comment": "```suggestion\r\n    if frame.f_back is None or frame.f_code.co_name == '<module>':\r\n```\r\nif that works?",
      "comment_id": 1715648194,
      "user": "dmontagu",
      "created_at": "2024-08-13T17:10:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/10113#discussion_r1715648194"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10113,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,8 +181,8 @@ def parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:\n     other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.\n     \"\"\"\n     frame = sys._getframe(parent_depth)\n-    # if f_back is None, it's the global module namespace and we don't need to include it here\n-    if frame.f_back is None:\n+    # if the class is defined at the top module level, we don't need to add namespace information\n+    if frame.f_back is None or frame.f_code.co_name == '<module>':",
      "comment": "Btw, won't surprise me if we need to use a getattr here because some implementation of python has `f_code is None` or something, that feels like the kind of thing that might happen. But I don't know if those would have a pydantic-core release that worked with them",
      "comment_id": 1715657917,
      "user": "dmontagu",
      "created_at": "2024-08-13T17:19:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10113#discussion_r1715657917"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10113,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,8 +181,8 @@ def parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:\n     other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.\n     \"\"\"\n     frame = sys._getframe(parent_depth)\n-    # if f_back is None, it's the global module namespace and we don't need to include it here\n-    if frame.f_back is None:\n+    # if the class is defined at the top module level, we don't need to add namespace information\n+    if frame.f_back is None or frame.f_code.co_name == '<module>':",
      "comment": "Seems to be ok for the moment, but will keep an eye out for this as a potential source of bugs in the future!",
      "comment_id": 1715682771,
      "user": "sydney-runkle",
      "created_at": "2024-08-13T17:36:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10113#discussion_r1715682771"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10113,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,8 +181,8 @@ def parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:\n     other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.\n     \"\"\"\n     frame = sys._getframe(parent_depth)\n-    # if f_back is None, it's the global module namespace and we don't need to include it here\n-    if frame.f_back is None:\n+    # if the class is defined at the top module level, we don't need to add namespace information\n+    if frame.f_back is None or frame.f_code.co_name == '<module>':",
      "comment": "ye, I thought the exact same thing as @dmontagu.\r\n\r\nTypeshed [suggests](https://github.com/python/typeshed/blob/89bb3c148cc72884092eb1da51f34eb6f671f58b/stdlib/types.pyi#L522C25-L522C33) that both `.f_code` and `.co_name` should always exist.",
      "comment_id": 1715743997,
      "user": "samuelcolvin",
      "created_at": "2024-08-13T18:28:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10113#discussion_r1715743997"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10113,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,8 +181,8 @@ def parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:\n     other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.\n     \"\"\"\n     frame = sys._getframe(parent_depth)\n-    # if f_back is None, it's the global module namespace and we don't need to include it here\n-    if frame.f_back is None:\n+    # if the class is defined at the top module level, we don't need to add namespace information\n+    if frame.f_back is None or frame.f_code.co_name == '<module>':",
      "comment": "`inspect.getframeinfo` (which was used before in this PR) also assumes `frame.f_code.co_name` is defined.",
      "comment_id": 1715759793,
      "user": "Viicos",
      "created_at": "2024-08-13T18:41:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10113#discussion_r1715759793"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10339,
      "file_path": "pydantic/main.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,6 +65,11 @@\n \n __all__ = 'BaseModel', 'create_model'\n \n+# Keep these type aliases available at runtime:\n+TupleGenerator: TypeAlias = Generator[Tuple[str, Any], None, None]\n+# Keep this type alias in sync with the stub definition in `pydantic-core`:\n+IncEx: TypeAlias = 'set[int] | set[str] | dict[int, IncEx | bool] | dict[str, IncEx | bool]'",
      "comment": "I removed the `| None` and added it in the relevant method signatures, as it makes more sense imo to keep the type alias scoped to what it represents, and then have consumers of this type alias make it optional or not.",
      "comment_id": 1747110821,
      "user": "Viicos",
      "created_at": "2024-09-06T13:15:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/10339#discussion_r1747110821"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10318,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 560,
      "side": "RIGHT",
      "diff_hunk": "@@ -542,6 +543,26 @@ def ser_ip(ip: Any) -> str:\n             ),\n         )\n \n+    def _fraction_schema(self) -> CoreSchema:\n+        \"\"\"Support for [`fractions.Fraction`][fractions.Fraction].\"\"\"\n+        from ._validators import fraction_validator\n+\n+        # TODO: note, this is a fairly common pattern, re lax / strict for attempted type coercion,\n+        # can we use a helper function to reduce boilerplate?\n+        return core_schema.lax_or_strict_schema(\n+            lax_schema=core_schema.no_info_plain_validator_function(fraction_validator),\n+            strict_schema=core_schema.json_or_python_schema(\n+                json_schema=core_schema.no_info_plain_validator_function(fraction_validator),\n+                python_schema=core_schema.is_instance_schema(Fraction),\n+            ),\n+            # use str serialization to guarantee round trip behavior\n+            serialization=core_schema.to_string_ser_schema(when_used='always'),\n+            # TODO: figure out if this is actually how to represent fractions in JSON schema",
      "comment": "```suggestion\r\n```\r\nI think this is okay, I believe we already do things that aren't a part of the spec",
      "comment_id": 1745985284,
      "user": "dmontagu",
      "created_at": "2024-09-05T18:25:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10318#discussion_r1745985284"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "tests/test_generics.py",
      "line": 1274,
      "side": "RIGHT",
      "diff_hunk": "@@ -1238,8 +1242,8 @@ class Model(BaseModel, Generic[T, KT, VT]):\n     assert type(m.mapping_field) is dict  # this is determined in CustomMapping.__get_pydantic_core_schema__\n     assert type(m.ordered_dict_field) is CustomOrderedDict\n     assert type(m.set_field) is CustomSet\n-    assert type(m.tuple_field) is tuple\n-    assert type(m.long_tuple_field) is tuple\n+    assert type(m.tuple_field) is CustomTuple\n+    assert type(m.long_tuple_field) is CustomLongTuple",
      "comment": "Several bugs / inconsistencies are getting fixed by this PR",
      "comment_id": 1269567456,
      "user": "adriangb",
      "created_at": "2023-07-20T14:42:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1269567456"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -210,31 +219,171 @@ def modify_model_json_schema(\n     return json_schema\n \n \n+class ConfigWrapperStack:\n+    \"\"\"A stack of `ConfigWrapper` instances.\"\"\"\n+\n+    def __init__(self, config_wrapper: ConfigWrapper):\n+        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]\n+\n+    @property\n+    def tail(self) -> ConfigWrapper:\n+        return self._config_wrapper_stack[-1]\n+\n+    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None) -> ContextManager[None]:\n+        if config_wrapper is None:\n+            return nullcontext()\n+\n+        if not isinstance(config_wrapper, ConfigWrapper):\n+            config_wrapper = ConfigWrapper(config_wrapper, check=False)\n+\n+        @contextmanager\n+        def _context_manager() -> Iterator[None]:\n+            self._config_wrapper_stack.append(config_wrapper)\n+            try:\n+                yield\n+            finally:\n+                self._config_wrapper_stack.pop()\n+\n+        return _context_manager()\n+\n+\n+JsonEncoders = Dict[Type[Any], Callable[[Any], Any]]\n+\n+\n+def _add_custom_serialization_from_json_encoders(\n+    json_encoders: JsonEncoders | None, obj: Any, schema: CoreSchema\n+) -> None:\n+    if json_encoders is None:\n+        return\n+    # Check the class type and its superclasses for a matching encoder\n+    for base in (obj, obj.__class__.__mro__[:-1]):\n+        try:\n+            encoder = json_encoders[base]\n+        except KeyError:\n+            continue\n+\n+        serialization = schema.get('serialization') or core_schema.plain_serializer_function_ser_schema(encoder)\n+        # TODO: in theory we should check that the schema accepts a serialization key\n+        schema['serialization'] = serialization  # type: ignore\n+\n+\n class GenerateSchema:\n     \"\"\"Generate core schema for a Pydantic model, dataclass and types like `str`, `datatime`, ... .\"\"\"\n \n-    __slots__ = '_config_wrapper_stack', 'types_namespace', 'typevars_map', 'recursion_cache', 'definitions', 'defs'\n-\n     def __init__(\n         self,\n         config_wrapper: ConfigWrapper,\n         types_namespace: dict[str, Any] | None,\n         typevars_map: dict[Any, Any] | None = None,\n     ):\n         # we need a stack for recursing into child models\n-        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]\n-        self.types_namespace = types_namespace\n-        self.typevars_map = typevars_map\n-\n+        self._config_wrapper_stack = ConfigWrapperStack(config_wrapper)\n+        self._types_namespace = types_namespace\n+        self._typevars_map = typevars_map\n         self.defs = _Definitions()\n \n+    @classmethod\n+    def __from_parent(\n+        cls,\n+        config_wrapper_stack: ConfigWrapperStack,\n+        types_namespace: dict[str, Any] | None,\n+        typevars_map: dict[Any, Any] | None,\n+        defs: _Definitions,\n+    ) -> GenerateSchema:\n+        obj = cls.__new__(cls)\n+        obj._config_wrapper_stack = config_wrapper_stack\n+        obj._types_namespace = types_namespace\n+        obj._typevars_map = typevars_map\n+        obj.defs = defs\n+        return obj\n+\n     @property\n-    def config_wrapper(self) -> ConfigWrapper:\n-        return self._config_wrapper_stack[-1]\n+    def _config_wrapper(self) -> ConfigWrapper:\n+        return self._config_wrapper_stack.tail\n+\n+    @property\n+    def _json_encoders(self) -> JsonEncoders | None:\n+        return self._config_wrapper.json_encoders\n+\n+    @property\n+    def _current_generate_schema(self) -> GenerateSchema:\n+        cls = self._config_wrapper.schema_generator or GenerateSchema\n+        return cls.__from_parent(\n+            self._config_wrapper_stack,\n+            self._types_namespace,\n+            self._typevars_map,\n+            self.defs,\n+        )\n \n     @property\n-    def arbitrary_types(self) -> bool:\n-        return self.config_wrapper.arbitrary_types_allowed\n+    def _arbitrary_types(self) -> bool:\n+        return self._config_wrapper.arbitrary_types_allowed\n+\n+    def literal_schema(self, values: list[Any]) -> CoreSchema:",
      "comment": "please add docstrings for all these, ideally linking to the `core_schema` methods.",
      "comment_id": 1270719093,
      "user": "samuelcolvin",
      "created_at": "2023-07-21T14:07:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270719093"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 767,
      "side": "RIGHT",
      "diff_hunk": "@@ -587,13 +764,17 @@ def _generate_schema(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n             source_type, annotations = res\n             return self._apply_annotations(source_type, annotations)\n \n-        origin = get_origin(obj)\n+        origin = get_origin(obj) or getattr(obj, '__origin__', None)",
      "comment": "do we need the `getattr(obj, '__origin__', None)`? Surely `get_origin` should do that.",
      "comment_id": 1270787827,
      "user": "samuelcolvin",
      "created_at": "2023-07-21T15:07:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270787827"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 715,
      "side": "RIGHT",
      "diff_hunk": "@@ -531,19 +680,47 @@ def _generate_schema(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n         if isinstance(obj, PydanticRecursiveRef):\n             return core_schema.definition_reference_schema(schema_ref=obj.type_ref)\n \n-        try:\n-            if obj in {bool, int, float, str, bytes, list, set, frozenset, dict}:\n-                # Note: obj may fail to be hashable if it has an unhashable annotation\n-                return {'type': obj.__name__}\n-            elif obj is tuple:\n-                return {'type': 'tuple-variable'}\n-        except TypeError:  # obj not hashable; can happen due to unhashable annotations\n-            pass\n-\n-        if obj is Any or obj is object:\n-            return core_schema.any_schema()\n+        return self.match_type(obj)\n+\n+    def match_type(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n+        \"\"\"Main mapping of types to schemas.\n+\n+        The general structure is a series of if statements starting with the simple cases\n+        (non-generic primitive types) and then handling generics and other more complex cases.\n+\n+        Each case either generates a schema directly, calls into a public user-overridable method\n+        (like `GenerateSchema.tuple_variable_schema`) or calls into a private method that handles some\n+        boilerplate before calling into the user-facing method (e.g. `GenerateSchema._tuple_schema`).\n+\n+        The idea is that we'll evolve this into adding more and more user facing methods over time\n+        as they get requested and we figure out what the right API for them is.\n+        \"\"\"\n+        if obj is str:\n+            return self.str_schema()\n+        elif obj is bytes:\n+            return self.bytes_schema()\n+        elif obj is int:\n+            return self.int_schema()\n+        elif obj is float:\n+            return self.float_schema()\n+        elif obj is bool:\n+            return self.bool_schema()\n+        elif obj is Any or obj is object:\n+            return self.any_schema()\n         elif obj is None or obj is _typing_extra.NoneType:\n-            return core_schema.none_schema()\n+            return self.none_schema()\n+        elif obj in TUPLE_TYPES:\n+            return self._tuple_schema(obj)\n+        elif obj in LIST_TYPES:\n+            return self.list_schema(self._get_first_arg_or_any(obj))",
      "comment": "is there a world where the developer needs access to `obj` since `LIST_TYPES` contains multiple types?\r\n\r\nHard to change these signatures afterwards, hence might be good to add it as an argument now?",
      "comment_id": 1270792282,
      "user": "samuelcolvin",
      "created_at": "2023-07-21T15:11:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270792282"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 491,
      "side": "RIGHT",
      "diff_hunk": "@@ -317,6 +466,8 @@ def _generate_schema_for_type(\n             if metadata_schema:\n                 self._add_js_function(metadata_schema, metadata_js_function)\n \n+        _add_custom_serialization_from_json_encoders(self._json_encoders, obj, schema)",
      "comment": "Should this line go above the `metadata_js_function` stuff immediately prior? It seems if this line is going to modify the serialization, it would make sense to generate the JSON schema after that modification to `schema` has been performed.",
      "comment_id": 1270793212,
      "user": "dmontagu",
      "created_at": "2023-07-21T15:12:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270793212"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 803,
      "side": "RIGHT",
      "diff_hunk": "@@ -610,50 +791,30 @@ def _generate_schema(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n \n         if _typing_extra.origin_is_union(origin):\n             return self._union_schema(obj)\n-        elif issubclass(origin, typing.Tuple):  # type: ignore[arg-type]\n+        elif origin in TUPLE_TYPES:\n             return self._tuple_schema(obj)\n+        elif origin in LIST_TYPES:\n+            return self.list_schema(self._get_first_arg_or_any(obj))\n+        elif origin in SET_TYPES:\n+            return self.set_schema(self._get_first_arg_or_any(obj))\n+        elif origin in FROZEN_SET_TYPES:\n+            return self.frozenset_schema(self._get_first_arg_or_any(obj))\n+        elif origin in DICT_TYPES:\n+            return self.dict_schema(*(self._get_args_resolving_forward_refs(obj) or (Any, Any)))",
      "comment": "looks like this logic is copied, should we move it to a new function?",
      "comment_id": 1270793514,
      "user": "samuelcolvin",
      "created_at": "2023-07-21T15:12:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270793514"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 259,
      "side": "RIGHT",
      "diff_hunk": "@@ -210,31 +219,171 @@ def modify_model_json_schema(\n     return json_schema\n \n \n+class ConfigWrapperStack:\n+    \"\"\"A stack of `ConfigWrapper` instances.\"\"\"\n+\n+    def __init__(self, config_wrapper: ConfigWrapper):\n+        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]\n+\n+    @property\n+    def tail(self) -> ConfigWrapper:\n+        return self._config_wrapper_stack[-1]\n+\n+    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None) -> ContextManager[None]:\n+        if config_wrapper is None:\n+            return nullcontext()\n+\n+        if not isinstance(config_wrapper, ConfigWrapper):\n+            config_wrapper = ConfigWrapper(config_wrapper, check=False)\n+\n+        @contextmanager\n+        def _context_manager() -> Iterator[None]:\n+            self._config_wrapper_stack.append(config_wrapper)\n+            try:\n+                yield\n+            finally:\n+                self._config_wrapper_stack.pop()\n+\n+        return _context_manager()\n+\n+\n+JsonEncoders = Dict[Type[Any], Callable[[Any], Any]]\n+\n+\n+def _add_custom_serialization_from_json_encoders(\n+    json_encoders: JsonEncoders | None, obj: Any, schema: CoreSchema\n+) -> None:\n+    if json_encoders is None:\n+        return\n+    # Check the class type and its superclasses for a matching encoder\n+    for base in (obj, obj.__class__.__mro__[:-1]):",
      "comment": "Is the `:-1` here just to prevent `object` from being a base that gets checked? Any reason not to allow people to have an encoder for `object`? Lol.",
      "comment_id": 1270795065,
      "user": "dmontagu",
      "created_at": "2023-07-21T15:14:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270795065"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -210,31 +219,171 @@ def modify_model_json_schema(\n     return json_schema\n \n \n+class ConfigWrapperStack:\n+    \"\"\"A stack of `ConfigWrapper` instances.\"\"\"\n+\n+    def __init__(self, config_wrapper: ConfigWrapper):\n+        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]\n+\n+    @property\n+    def tail(self) -> ConfigWrapper:\n+        return self._config_wrapper_stack[-1]\n+\n+    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None) -> ContextManager[None]:\n+        if config_wrapper is None:\n+            return nullcontext()\n+\n+        if not isinstance(config_wrapper, ConfigWrapper):\n+            config_wrapper = ConfigWrapper(config_wrapper, check=False)\n+\n+        @contextmanager\n+        def _context_manager() -> Iterator[None]:\n+            self._config_wrapper_stack.append(config_wrapper)\n+            try:\n+                yield\n+            finally:\n+                self._config_wrapper_stack.pop()\n+\n+        return _context_manager()\n+\n+\n+JsonEncoders = Dict[Type[Any], Callable[[Any], Any]]\n+\n+\n+def _add_custom_serialization_from_json_encoders(",
      "comment": "Does it make sense for this to be a method of `GenerateSchema`? I'm okay either way.",
      "comment_id": 1270796597,
      "user": "dmontagu",
      "created_at": "2023-07-21T15:15:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270796597"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "tests/test_config.py",
      "line": 649,
      "side": "RIGHT",
      "diff_hunk": "@@ -633,3 +641,26 @@ class Child(Parent):\n         model_config: ConfigDict = {'str_to_lower': True}\n \n     assert Child.model_config == {'extra': 'allow', 'str_to_lower': True}\n+\n+\n+def test_json_encoders_model() -> None:",
      "comment": "should we hunt the v1 docs and copy tests that used `json_encoders`? I feel like we had a lot and they probably covered a lot of weird behaviour.",
      "comment_id": 1270796947,
      "user": "samuelcolvin",
      "created_at": "2023-07-21T15:15:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270796947"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -210,31 +219,171 @@ def modify_model_json_schema(\n     return json_schema\n \n \n+class ConfigWrapperStack:\n+    \"\"\"A stack of `ConfigWrapper` instances.\"\"\"\n+\n+    def __init__(self, config_wrapper: ConfigWrapper):\n+        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]\n+\n+    @property\n+    def tail(self) -> ConfigWrapper:\n+        return self._config_wrapper_stack[-1]\n+\n+    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None) -> ContextManager[None]:\n+        if config_wrapper is None:\n+            return nullcontext()\n+\n+        if not isinstance(config_wrapper, ConfigWrapper):\n+            config_wrapper = ConfigWrapper(config_wrapper, check=False)\n+\n+        @contextmanager\n+        def _context_manager() -> Iterator[None]:\n+            self._config_wrapper_stack.append(config_wrapper)\n+            try:\n+                yield\n+            finally:\n+                self._config_wrapper_stack.pop()\n+\n+        return _context_manager()\n+\n+\n+JsonEncoders = Dict[Type[Any], Callable[[Any], Any]]\n+\n+\n+def _add_custom_serialization_from_json_encoders(",
      "comment": "Don\u2019t think it matters too much happy to change it",
      "comment_id": 1270799937,
      "user": "adriangb",
      "created_at": "2023-07-21T15:18:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270799937"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "tests/test_types_typeddict.py",
      "line": 872,
      "side": "RIGHT",
      "diff_hunk": "@@ -855,3 +864,17 @@ class Model(TypedDict):\n     ta = TypeAdapter(Model)\n \n     assert ta.validate_python({'x': 'ABC'}) == {'x': 'abc'}\n+\n+\n+def test_schema_generator() -> None:\n+    class LaxStrGenerator(GenerateSchema):\n+        def str_schema(self) -> CoreSchema:\n+            return core_schema.no_info_plain_validator_function(str)",
      "comment": "Not sure if this specifically is intended to be the solution for people who want to override the string validation, but if it is, we should make sure the JSON schema generation works. Right now, you get:\r\n\r\n```\r\n>>> ta.json_schema()\r\npydantic.errors.PydanticInvalidForJsonSchema: Cannot generate a JsonSchema for core_schema.PlainValidatorFunctionSchema ({'type': 'no-info', 'function': <class 'str'>})\r\n```\r\n",
      "comment_id": 1270830749,
      "user": "dmontagu",
      "created_at": "2023-07-21T15:48:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270830749"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 797,
      "side": "RIGHT",
      "diff_hunk": "@@ -610,50 +791,30 @@ def _generate_schema(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n \n         if _typing_extra.origin_is_union(origin):\n             return self._union_schema(obj)\n-        elif issubclass(origin, typing.Tuple):  # type: ignore[arg-type]\n+        elif origin in TUPLE_TYPES:",
      "comment": "now that we are doing so much less `issubclass` and so much more `origin in ...`, it might make sense to refactor this into a single dict lookup rather than a bunch of if-elses. Doesn't need to happen in this PR, but I wanted to point it out",
      "comment_id": 1270835150,
      "user": "dmontagu",
      "created_at": "2023-07-21T15:52:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270835150"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 691,
      "side": "RIGHT",
      "diff_hunk": "@@ -531,19 +680,47 @@ def _generate_schema(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n         if isinstance(obj, PydanticRecursiveRef):\n             return core_schema.definition_reference_schema(schema_ref=obj.type_ref)\n \n-        try:\n-            if obj in {bool, int, float, str, bytes, list, set, frozenset, dict}:\n-                # Note: obj may fail to be hashable if it has an unhashable annotation\n-                return {'type': obj.__name__}\n-            elif obj is tuple:\n-                return {'type': 'tuple-variable'}\n-        except TypeError:  # obj not hashable; can happen due to unhashable annotations\n-            pass\n-\n-        if obj is Any or obj is object:\n-            return core_schema.any_schema()\n+        return self.match_type(obj)\n+\n+    def match_type(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901",
      "comment": "is this method intended to be public? I know it says we'll evolve this below, but it might make sense to say something to the effect of \"if you override this, know that it may be updated in future versions\" or similar",
      "comment_id": 1270836934,
      "user": "dmontagu",
      "created_at": "2023-07-21T15:54:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1270836934"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 491,
      "side": "RIGHT",
      "diff_hunk": "@@ -317,6 +466,8 @@ def _generate_schema_for_type(\n             if metadata_schema:\n                 self._add_js_function(metadata_schema, metadata_js_function)\n \n+        _add_custom_serialization_from_json_encoders(self._json_encoders, obj, schema)",
      "comment": "Does it matter? We're editing the CoreSchema here directly while the js func won't get executed until later. Or maybe I'm misunderstanding. Is there a test case we can add?",
      "comment_id": 1271291783,
      "user": "adriangb",
      "created_at": "2023-07-22T12:37:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1271291783"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 767,
      "side": "RIGHT",
      "diff_hunk": "@@ -587,13 +764,17 @@ def _generate_schema(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n             source_type, annotations = res\n             return self._apply_annotations(source_type, annotations)\n \n-        origin = get_origin(obj)\n+        origin = get_origin(obj) or getattr(obj, '__origin__', None)",
      "comment": "I remember needing it for some case but no tests fail and I forgot what it was so removing it.",
      "comment_id": 1271291968,
      "user": "adriangb",
      "created_at": "2023-07-22T12:39:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1271291968"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,6 +97,13 @@\n GetCoreSchemaFunction = Callable[[Any, ModifyCoreSchemaWrapHandler], core_schema.CoreSchema]\n \n \n+TUPLE_TYPES: list[type] = [tuple, typing.Tuple]\n+LIST_TYPES: list[type] = [list, typing.List, collections.abc.MutableSequence]\n+SET_TYPES: list[type] = [set, typing.Set, collections.abc.MutableSet]\n+FROZEN_SET_TYPES: list[type] = [frozenset, typing.FrozenSet, collections.abc.Set]\n+DICT_TYPES: list[type] = [dict, typing.Dict, collections.abc.MutableMapping, collections.abc.Mapping]",
      "comment": "Looks like we can, but that's not always the case. Types don't promise to be hashable and since it's an O(1) lookup either way I tend to go for a list/tuple for these sorts of things.",
      "comment_id": 1271292265,
      "user": "adriangb",
      "created_at": "2023-07-22T12:42:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1271292265"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 715,
      "side": "RIGHT",
      "diff_hunk": "@@ -531,19 +680,47 @@ def _generate_schema(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n         if isinstance(obj, PydanticRecursiveRef):\n             return core_schema.definition_reference_schema(schema_ref=obj.type_ref)\n \n-        try:\n-            if obj in {bool, int, float, str, bytes, list, set, frozenset, dict}:\n-                # Note: obj may fail to be hashable if it has an unhashable annotation\n-                return {'type': obj.__name__}\n-            elif obj is tuple:\n-                return {'type': 'tuple-variable'}\n-        except TypeError:  # obj not hashable; can happen due to unhashable annotations\n-            pass\n-\n-        if obj is Any or obj is object:\n-            return core_schema.any_schema()\n+        return self.match_type(obj)\n+\n+    def match_type(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n+        \"\"\"Main mapping of types to schemas.\n+\n+        The general structure is a series of if statements starting with the simple cases\n+        (non-generic primitive types) and then handling generics and other more complex cases.\n+\n+        Each case either generates a schema directly, calls into a public user-overridable method\n+        (like `GenerateSchema.tuple_variable_schema`) or calls into a private method that handles some\n+        boilerplate before calling into the user-facing method (e.g. `GenerateSchema._tuple_schema`).\n+\n+        The idea is that we'll evolve this into adding more and more user facing methods over time\n+        as they get requested and we figure out what the right API for them is.\n+        \"\"\"\n+        if obj is str:\n+            return self.str_schema()\n+        elif obj is bytes:\n+            return self.bytes_schema()\n+        elif obj is int:\n+            return self.int_schema()\n+        elif obj is float:\n+            return self.float_schema()\n+        elif obj is bool:\n+            return self.bool_schema()\n+        elif obj is Any or obj is object:\n+            return self.any_schema()\n         elif obj is None or obj is _typing_extra.NoneType:\n-            return core_schema.none_schema()\n+            return self.none_schema()\n+        elif obj in TUPLE_TYPES:\n+            return self._tuple_schema(obj)\n+        elif obj in LIST_TYPES:\n+            return self.list_schema(self._get_first_arg_or_any(obj))",
      "comment": "Yeah I think that's a good call. Better to have it and not use it.",
      "comment_id": 1271292276,
      "user": "adriangb",
      "created_at": "2023-07-22T12:42:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1271292276"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 729,
      "side": "RIGHT",
      "diff_hunk": "@@ -531,19 +680,47 @@ def _generate_schema(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n         if isinstance(obj, PydanticRecursiveRef):\n             return core_schema.definition_reference_schema(schema_ref=obj.type_ref)\n \n-        try:\n-            if obj in {bool, int, float, str, bytes, list, set, frozenset, dict}:\n-                # Note: obj may fail to be hashable if it has an unhashable annotation\n-                return {'type': obj.__name__}\n-            elif obj is tuple:\n-                return {'type': 'tuple-variable'}\n-        except TypeError:  # obj not hashable; can happen due to unhashable annotations\n-            pass\n-\n-        if obj is Any or obj is object:\n-            return core_schema.any_schema()\n+        return self.match_type(obj)\n+\n+    def match_type(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n+        \"\"\"Main mapping of types to schemas.\n+\n+        The general structure is a series of if statements starting with the simple cases\n+        (non-generic primitive types) and then handling generics and other more complex cases.\n+\n+        Each case either generates a schema directly, calls into a public user-overridable method\n+        (like `GenerateSchema.tuple_variable_schema`) or calls into a private method that handles some\n+        boilerplate before calling into the user-facing method (e.g. `GenerateSchema._tuple_schema`).\n+\n+        The idea is that we'll evolve this into adding more and more user facing methods over time\n+        as they get requested and we figure out what the right API for them is.\n+        \"\"\"\n+        if obj is str:\n+            return self.str_schema()\n+        elif obj is bytes:\n+            return self.bytes_schema()\n+        elif obj is int:\n+            return self.int_schema()\n+        elif obj is float:\n+            return self.float_schema()\n+        elif obj is bool:\n+            return self.bool_schema()\n+        elif obj is Any or obj is object:\n+            return self.any_schema()\n         elif obj is None or obj is _typing_extra.NoneType:\n-            return core_schema.none_schema()\n+            return self.none_schema()\n+        elif obj in TUPLE_TYPES:\n+            return self._tuple_schema(obj)\n+        elif obj in LIST_TYPES:\n+            return self.list_schema(self._get_first_arg_or_any(obj))\n+        elif obj in SET_TYPES:\n+            return self.set_schema(self._get_first_arg_or_any(obj))\n+        elif obj in FROZEN_SET_TYPES:\n+            return self.frozenset_schema(self._get_first_arg_or_any(obj))\n+        elif obj in DICT_TYPES:\n+            return self.dict_schema(*(self._get_args_resolving_forward_refs(obj) or (Any, Any)))\n+        elif isinstance(obj, TypeAliasType):\n+            return self._type_alias_type_schema(obj)",
      "comment": "I'm somewhat arbitrarily deciding what to make public or not. I picked the ones that I felt were important, simple or proved that something works (e.g. lists). No reason to make everything public now, let's do it a bit at a time as we understand the use cases.",
      "comment_id": 1271292374,
      "user": "adriangb",
      "created_at": "2023-07-22T12:44:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1271292374"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "tests/test_types_typeddict.py",
      "line": 872,
      "side": "RIGHT",
      "diff_hunk": "@@ -855,3 +864,17 @@ class Model(TypedDict):\n     ta = TypeAdapter(Model)\n \n     assert ta.validate_python({'x': 'ABC'}) == {'x': 'abc'}\n+\n+\n+def test_schema_generator() -> None:\n+    class LaxStrGenerator(GenerateSchema):\n+        def str_schema(self) -> CoreSchema:\n+            return core_schema.no_info_plain_validator_function(str)",
      "comment": "That'd be up to them to return a CoreSchema that can generate a JSON schema. I'm not sure there's much we can do.",
      "comment_id": 1271293969,
      "user": "adriangb",
      "created_at": "2023-07-22T13:01:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1271293969"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6737,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,6 +97,13 @@\n GetCoreSchemaFunction = Callable[[Any, ModifyCoreSchemaWrapHandler], core_schema.CoreSchema]\n \n \n+TUPLE_TYPES: list[type] = [tuple, typing.Tuple]\n+LIST_TYPES: list[type] = [list, typing.List, collections.abc.MutableSequence]\n+SET_TYPES: list[type] = [set, typing.Set, collections.abc.MutableSet]\n+FROZEN_SET_TYPES: list[type] = [frozenset, typing.FrozenSet, collections.abc.Set]\n+DICT_TYPES: list[type] = [dict, typing.Dict, collections.abc.MutableMapping, collections.abc.Mapping]",
      "comment": "Case in point: https://github.com/pydantic/pydantic/actions/runs/5630806077/job/15257133423?pr=6737#step:8:174\r\n\r\nReverting, sorry Samuel.",
      "comment_id": 1271313153,
      "user": "adriangb",
      "created_at": "2023-07-22T16:01:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/6737#discussion_r1271313153"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10290,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 282,
      "side": "RIGHT",
      "diff_hunk": "@@ -262,3 +267,54 @@ def validate_model_wrap(cls, values: Any, handler: ModelWrapValidatorHandler[Sel\n                 return handler(values)\n \n     benchmark(schema_gen)\n+\n+\n+@pytest.mark.parametrize('mode', ['plain', 'wrap'])\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_custom_field_serializer(benchmark, mode) -> None:\n+    def schema_gen() -> None:\n+        class ModelWithFieldSerializer(BaseModel):\n+            field1: int\n+\n+            @field_serializer('field1', mode=mode)\n+            def serialize_field(cls, v: int) -> str:\n+                return str(v)\n+\n+    benchmark(schema_gen)",
      "comment": "I think we need to separate the tests for `plain` and `wrap` serializers - they have different signatures (ex - see the different signatures for the corresponding validators). This looks like a great test for the `plain` serializer, though.",
      "comment_id": 1743396872,
      "user": "sydney-runkle",
      "created_at": "2024-09-04T09:33:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10290#discussion_r1743396872"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10290,
      "file_path": "tests/benchmarks/test_model_schema_generation.py",
      "line": 282,
      "side": "RIGHT",
      "diff_hunk": "@@ -262,3 +267,54 @@ def validate_model_wrap(cls, values: Any, handler: ModelWrapValidatorHandler[Sel\n                 return handler(values)\n \n     benchmark(schema_gen)\n+\n+\n+@pytest.mark.parametrize('mode', ['plain', 'wrap'])\n+@pytest.mark.benchmark(group='model_schema_generation')\n+def test_custom_field_serializer(benchmark, mode) -> None:\n+    def schema_gen() -> None:\n+        class ModelWithFieldSerializer(BaseModel):\n+            field1: int\n+\n+            @field_serializer('field1', mode=mode)\n+            def serialize_field(cls, v: int) -> str:\n+                return str(v)\n+\n+    benchmark(schema_gen)",
      "comment": "You are right! I forgot about the signature difference. I believe it should be correct now.\r\n",
      "comment_id": 1744685303,
      "user": "AdolfoVillalobos",
      "created_at": "2024-09-05T01:23:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10290#discussion_r1744685303"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10301,
      "file_path": "pydantic/json_schema.py",
      "line": 1881,
      "side": "RIGHT",
      "diff_hunk": "@@ -1877,8 +1877,8 @@ def complex_schema(self, schema: core_schema.ComplexSchema) -> JsonSchemaValue:\n \n         JSON has no standard way to represent complex numbers. Complex number is not a numeric\n         type. Here we represent complex number as strings following the rule defined by Python.\n-        For instance, '1+2j' is an accepted complex string. Details can be found at\n-        https://docs.python.org/3/library/functions.html#complex\n+        For instance, '1+2j' is an accepted complex string. Details can be found in\n+        [Python's `complex` documentation](https://docs.python.org/3/library/functions.html#complex).",
      "comment": "```suggestion\r\n        For instance, '1+2j' is an accepted complex string. Details can be found in\r\n        [Python's `complex` documentation][complex].\r\n```\r\nI'd rather use crossrefs. Although it does look a bit unclear where it comes from. Sphinx [allows explicit targets](https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html#role-external) but mkdocstrings is still quite limited here :face_with_diagonal_mouth: ",
      "comment_id": 1743622143,
      "user": "Viicos",
      "created_at": "2024-09-04T11:46:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10301#discussion_r1743622143"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10268,
      "file_path": "pydantic/_internal/_dataclasses.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,7 +115,7 @@ def complete_dataclass(\n         )\n \n     if types_namespace is None:\n-        types_namespace = _typing_extra.get_cls_types_namespace(cls)\n+        types_namespace = _typing_extra.merge_cls_and_parent_ns(cls)",
      "comment": "So we could change this to ` _typing_extra.get_module_ns_of(cls).copy()`, but I think we should instead refactor how we handle namespaces for dataclasses in general to be more consistent with that of models.\r\n\r\nSee https://github.com/pydantic/pydantic/blob/e13b15edbe6cf90c603fbda1246b9156764c810f/pydantic/dataclasses.py#L318-L321",
      "comment_id": 1736459539,
      "user": "sydney-runkle",
      "created_at": "2024-08-29T15:17:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/10268#discussion_r1736459539"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10268,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,24 +203,25 @@ def parent_frame_namespace(*, parent_depth: int = 2, force: bool = False) -> dic\n     return frame.f_locals\n \n \n-def add_module_globals(obj: Any, globalns: dict[str, Any] | None = None) -> dict[str, Any]:\n+def get_module_ns_of(obj: Any) -> dict[str, Any]:\n+    \"\"\"Get the namespace of the module where the object is defined.\n+\n+    Caution: this function does not return a copy of the module namespace, so it should not be mutated.\n+    The burden of enforcing this is on the caller.\n+    \"\"\"\n     module_name = getattr(obj, '__module__', None)\n     if module_name:\n         try:\n-            module_globalns = sys.modules[module_name].__dict__\n+            return sys.modules[module_name].__dict__\n         except KeyError:\n             # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n-            ns = {}\n-        else:\n-            ns = {**module_globalns, **globalns} if globalns else module_globalns.copy()\n-    else:\n-        ns = globalns or {}\n-\n-    return ns\n+            return {}\n+    return {}\n \n \n-def get_cls_types_namespace(cls: type[Any], parent_namespace: dict[str, Any] | None = None) -> dict[str, Any]:\n-    ns = add_module_globals(cls, parent_namespace)\n+def merge_cls_and_parent_ns(cls: type[Any], parent_namespace: dict[str, Any] | None = None) -> dict[str, Any]:\n+    ns = get_module_ns_of(cls).copy()\n+    ns.update(parent_namespace or {})",
      "comment": "I would do\r\n\r\n```suggestion\r\n    if parent_namespace is not None:\r\n        ns.update(parent_namespace)\r\n```\r\n\r\nMore stylistic than anything else, although this improves performance by a factor of 10 when `parent_namespace` is `None` (probably not relevant, but still good to have :) ).",
      "comment_id": 1738649844,
      "user": "Viicos",
      "created_at": "2024-08-30T13:18:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10268#discussion_r1738649844"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10264,
      "file_path": "tests/test_validators.py",
      "line": 2924,
      "side": "RIGHT",
      "diff_hunk": "@@ -2918,7 +2918,7 @@ class Child(BaseModel):\n \n         @model_validator(mode='after')  # type: ignore\n         def validate_model(self) -> 'Child':\n-            return Child.model_construct(name='different!')\n+            return Child.model_construct(name='name')\n \n     with pytest.warns(UserWarning, match='A custom validator is returning a value other than `self`'):\n-        Child(name='foo')\n+        Child(name='name')",
      "comment": "I'd rather leave these as different to illustrate the odd behavior...",
      "comment_id": 1736061701,
      "user": "sydney-runkle",
      "created_at": "2024-08-29T11:52:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10264#discussion_r1736061701"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10264,
      "file_path": "tests/test_validators.py",
      "line": 2924,
      "side": "RIGHT",
      "diff_hunk": "@@ -2918,7 +2918,7 @@ class Child(BaseModel):\n \n         @model_validator(mode='after')  # type: ignore\n         def validate_model(self) -> 'Child':\n-            return Child.model_construct(name='different!')\n+            return Child.model_construct(name='name')\n \n     with pytest.warns(UserWarning, match='A custom validator is returning a value other than `self`'):\n-        Child(name='foo')\n+        Child(name='name')",
      "comment": "To make it more clear, we could add an assert and a comment at the end (like self overrides, blah blah blah)",
      "comment_id": 1736133193,
      "user": "sydney-runkle",
      "created_at": "2024-08-29T12:43:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/10264#discussion_r1736133193"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10231,
      "file_path": "pydantic/main.py",
      "line": 252,
      "side": "RIGHT",
      "diff_hunk": "@@ -247,7 +247,9 @@ def model_construct(cls, _fields_set: set[str] | None = None, **values: Any) ->\n             an error if extra values are passed, but they will be ignored.\n \n         Args:\n-            _fields_set: The set of field names accepted for the Model instance.\n+            _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n+                this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n+                Otherwise, the field names in the provided values will be used.",
      "comment": "```suggestion\r\n                Otherwise, the field names from the provided `values` will be used.\r\n```",
      "comment_id": 1731504496,
      "user": "sydney-runkle",
      "created_at": "2024-08-26T16:36:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10231#discussion_r1731504496"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10244,
      "file_path": "tests/test_edge_cases.py",
      "line": 500,
      "side": "RIGHT",
      "diff_hunk": "@@ -497,7 +497,7 @@ class Model(BaseModel):\n \n def test_list_unions():\n     class Model(BaseModel):\n-        v: List[Union[int, str]] = ...\n+        v: List[Union[int, int]] = ...",
      "comment": "I would keep the union of int and str, and try to do an unordered list comparison (a la https://docs.python.org/3.5/library/unittest.html#unittest.TestCase.assertCountEqual but for pytest, don't know if it exists)",
      "comment_id": 1733045216,
      "user": "Viicos",
      "created_at": "2024-08-27T15:04:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10244#discussion_r1733045216"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10244,
      "file_path": "tests/test_edge_cases.py",
      "line": 500,
      "side": "RIGHT",
      "diff_hunk": "@@ -497,7 +497,7 @@ class Model(BaseModel):\n \n def test_list_unions():\n     class Model(BaseModel):\n-        v: List[Union[int, str]] = ...\n+        v: List[Union[int, int]] = ...",
      "comment": "Oops yes this annotation modification was a mistake.",
      "comment_id": 1733102171,
      "user": "sydney-runkle",
      "created_at": "2024-08-27T15:31:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10244#discussion_r1733102171"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10242,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 247,
      "side": "RIGHT",
      "diff_hunk": "@@ -243,7 +243,8 @@ def wrapped_model_post_init(self: BaseModel, context: Any, /) -> None:\n         else:\n             # These are instance variables, but have been assigned to `NoInitField` to trick the type checker.\n             for instance_slot in '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__':\n-                del namespace[instance_slot]\n+                if instance_slot in namespace:  # Safe check in case the metaclass is used other than in `BaseModel`:\n+                    del namespace[instance_slot]",
      "comment": "Surely, `nameapace.pop(instance_slot, None)` is better - only one lookup of the dict.",
      "comment_id": 1732412416,
      "user": "samuelcolvin",
      "created_at": "2024-08-27T08:48:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10242#discussion_r1732412416"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10210,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,6 +312,40 @@ def val_func(v: Any) -> Any:\n                 return v\n \n             schema = cs.no_info_after_validator_function(val_func, schema)\n+        elif isinstance(annotation, at.Not):\n+            if hasattr(annotation.func, '__qualname__'):\n+                func_name = annotation.func.__qualname__\n+\n+                def val_func(v: Any) -> Any:\n+                    if annotation.func(v):  # noqa: B023\n+                        raise PydanticCustomError(\n+                            'not_operation_failed',\n+                            f'Not of {func_name} failed',  # type: ignore  # noqa: B023\n+                        )\n+\n+                    return v\n+\n+                schema = cs.no_info_after_validator_function(val_func, schema)\n+            elif hasattr(annotation.func, '__class__'):\n+                class_name = annotation.func.__class__.__qualname__\n+\n+                if (annotation_type := type(annotation.func)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+                    constraint = at_to_constraint_map[annotation_type]\n+\n+                    def val_func(v: Any) -> Any:\n+                        try:\n+                            if get_constraint_validator(constraint)(v, getattr(annotation.func, constraint)) is v:  # noqa: B023\n+                                raise PydanticCustomError(\n+                                    'not_operation_failed',\n+                                    f'Not of {class_name} failed',  # type: ignore  # noqa: B023\n+                                )\n+                        except PydanticKnownError:\n+                            pass\n+\n+                        return v\n+\n+                    schema = cs.no_info_after_validator_function(val_func, schema)",
      "comment": "```suggestion\r\n```\r\n\r\nI don't think we need this logic...",
      "comment_id": 1727506553,
      "user": "sydney-runkle",
      "created_at": "2024-08-22T17:00:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/10210#discussion_r1727506553"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10210,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 328,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,6 +312,40 @@ def val_func(v: Any) -> Any:\n                 return v\n \n             schema = cs.no_info_after_validator_function(val_func, schema)\n+        elif isinstance(annotation, at.Not):\n+            if hasattr(annotation.func, '__qualname__'):\n+                func_name = annotation.func.__qualname__\n+\n+                def val_func(v: Any) -> Any:\n+                    if annotation.func(v):  # noqa: B023\n+                        raise PydanticCustomError(\n+                            'not_operation_failed',\n+                            f'Not of {func_name} failed',  # type: ignore  # noqa: B023\n+                        )\n+\n+                    return v\n+\n+                schema = cs.no_info_after_validator_function(val_func, schema)",
      "comment": "Other than the `not` in the `val_func`, this is basically identical to the `Predicate` logic - can we consolidate this logic?",
      "comment_id": 1727507818,
      "user": "sydney-runkle",
      "created_at": "2024-08-22T17:00:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10210#discussion_r1727507818"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10210,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,6 +312,40 @@ def val_func(v: Any) -> Any:\n                 return v\n \n             schema = cs.no_info_after_validator_function(val_func, schema)\n+        elif isinstance(annotation, at.Not):\n+            if hasattr(annotation.func, '__qualname__'):\n+                func_name = annotation.func.__qualname__\n+\n+                def val_func(v: Any) -> Any:\n+                    if annotation.func(v):  # noqa: B023\n+                        raise PydanticCustomError(\n+                            'not_operation_failed',\n+                            f'Not of {func_name} failed',  # type: ignore  # noqa: B023\n+                        )\n+\n+                    return v\n+\n+                schema = cs.no_info_after_validator_function(val_func, schema)\n+            elif hasattr(annotation.func, '__class__'):\n+                class_name = annotation.func.__class__.__qualname__\n+\n+                if (annotation_type := type(annotation.func)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+                    constraint = at_to_constraint_map[annotation_type]\n+\n+                    def val_func(v: Any) -> Any:\n+                        try:\n+                            if get_constraint_validator(constraint)(v, getattr(annotation.func, constraint)) is v:  # noqa: B023\n+                                raise PydanticCustomError(\n+                                    'not_operation_failed',\n+                                    f'Not of {class_name} failed',  # type: ignore  # noqa: B023\n+                                )\n+                        except PydanticKnownError:\n+                            pass\n+\n+                        return v\n+\n+                    schema = cs.no_info_after_validator_function(val_func, schema)",
      "comment": "@sydney-runkle \r\nplease correct me If I am wrong, but removing this logic will not support:\r\n`annotated_types.Not(annotated_types.MultipleOf(2))`  or any other annotated types like Ge, Le, etc.. with Not",
      "comment_id": 1727527571,
      "user": "aditkumar72",
      "created_at": "2024-08-22T17:14:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10210#discussion_r1727527571"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10210,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,6 +312,40 @@ def val_func(v: Any) -> Any:\n                 return v\n \n             schema = cs.no_info_after_validator_function(val_func, schema)\n+        elif isinstance(annotation, at.Not):\n+            if hasattr(annotation.func, '__qualname__'):\n+                func_name = annotation.func.__qualname__\n+\n+                def val_func(v: Any) -> Any:\n+                    if annotation.func(v):  # noqa: B023\n+                        raise PydanticCustomError(\n+                            'not_operation_failed',\n+                            f'Not of {func_name} failed',  # type: ignore  # noqa: B023\n+                        )\n+\n+                    return v\n+\n+                schema = cs.no_info_after_validator_function(val_func, schema)\n+            elif hasattr(annotation.func, '__class__'):\n+                class_name = annotation.func.__class__.__qualname__\n+\n+                if (annotation_type := type(annotation.func)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+                    constraint = at_to_constraint_map[annotation_type]\n+\n+                    def val_func(v: Any) -> Any:\n+                        try:\n+                            if get_constraint_validator(constraint)(v, getattr(annotation.func, constraint)) is v:  # noqa: B023\n+                                raise PydanticCustomError(\n+                                    'not_operation_failed',\n+                                    f'Not of {class_name} failed',  # type: ignore  # noqa: B023\n+                                )\n+                        except PydanticKnownError:\n+                            pass\n+\n+                        return v\n+\n+                    schema = cs.no_info_after_validator_function(val_func, schema)",
      "comment": "@aditkumar72, that's true, but the signature of `Not` indicates that it takes: `func: Callable[[Any], bool]`, so I don't feel like we should support types like `at.Not(Gt(2))` because that's not type safe:\r\n\r\n```\r\nArgument of type \"Gt\" cannot be assigned to parameter \"func\" of type \"(Any) -> bool\" in function \"__init__\"\r\n  Type \"Gt\" is incompatible with type \"(Any) -> bool\"\r\n```",
      "comment_id": 1727583455,
      "user": "sydney-runkle",
      "created_at": "2024-08-22T17:55:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10210#discussion_r1727583455"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10210,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,6 +312,40 @@ def val_func(v: Any) -> Any:\n                 return v\n \n             schema = cs.no_info_after_validator_function(val_func, schema)\n+        elif isinstance(annotation, at.Not):\n+            if hasattr(annotation.func, '__qualname__'):\n+                func_name = annotation.func.__qualname__\n+\n+                def val_func(v: Any) -> Any:\n+                    if annotation.func(v):  # noqa: B023\n+                        raise PydanticCustomError(\n+                            'not_operation_failed',\n+                            f'Not of {func_name} failed',  # type: ignore  # noqa: B023\n+                        )\n+\n+                    return v\n+\n+                schema = cs.no_info_after_validator_function(val_func, schema)\n+            elif hasattr(annotation.func, '__class__'):\n+                class_name = annotation.func.__class__.__qualname__\n+\n+                if (annotation_type := type(annotation.func)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+                    constraint = at_to_constraint_map[annotation_type]\n+\n+                    def val_func(v: Any) -> Any:\n+                        try:\n+                            if get_constraint_validator(constraint)(v, getattr(annotation.func, constraint)) is v:  # noqa: B023\n+                                raise PydanticCustomError(\n+                                    'not_operation_failed',\n+                                    f'Not of {class_name} failed',  # type: ignore  # noqa: B023\n+                                )\n+                        except PydanticKnownError:\n+                            pass\n+\n+                        return v\n+\n+                    schema = cs.no_info_after_validator_function(val_func, schema)",
      "comment": "So I'm inclined to just support callables, as the signature indicates - feel free to modify the tests accordingly.",
      "comment_id": 1727583986,
      "user": "sydney-runkle",
      "created_at": "2024-08-22T17:55:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10210#discussion_r1727583986"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10210,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,6 +312,40 @@ def val_func(v: Any) -> Any:\n                 return v\n \n             schema = cs.no_info_after_validator_function(val_func, schema)\n+        elif isinstance(annotation, at.Not):\n+            if hasattr(annotation.func, '__qualname__'):\n+                func_name = annotation.func.__qualname__\n+\n+                def val_func(v: Any) -> Any:\n+                    if annotation.func(v):  # noqa: B023\n+                        raise PydanticCustomError(\n+                            'not_operation_failed',\n+                            f'Not of {func_name} failed',  # type: ignore  # noqa: B023\n+                        )\n+\n+                    return v\n+\n+                schema = cs.no_info_after_validator_function(val_func, schema)\n+            elif hasattr(annotation.func, '__class__'):\n+                class_name = annotation.func.__class__.__qualname__\n+\n+                if (annotation_type := type(annotation.func)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+                    constraint = at_to_constraint_map[annotation_type]\n+\n+                    def val_func(v: Any) -> Any:\n+                        try:\n+                            if get_constraint_validator(constraint)(v, getattr(annotation.func, constraint)) is v:  # noqa: B023\n+                                raise PydanticCustomError(\n+                                    'not_operation_failed',\n+                                    f'Not of {class_name} failed',  # type: ignore  # noqa: B023\n+                                )\n+                        except PydanticKnownError:\n+                            pass\n+\n+                        return v\n+\n+                    schema = cs.no_info_after_validator_function(val_func, schema)",
      "comment": "I realize this is contradictory to the initial feature request - I'd suggest that folks can design a custom `Not` type if they'd like to go that route.",
      "comment_id": 1727592587,
      "user": "sydney-runkle",
      "created_at": "2024-08-22T18:00:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/10210#discussion_r1727592587"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10210,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,6 +312,40 @@ def val_func(v: Any) -> Any:\n                 return v\n \n             schema = cs.no_info_after_validator_function(val_func, schema)\n+        elif isinstance(annotation, at.Not):\n+            if hasattr(annotation.func, '__qualname__'):\n+                func_name = annotation.func.__qualname__\n+\n+                def val_func(v: Any) -> Any:\n+                    if annotation.func(v):  # noqa: B023\n+                        raise PydanticCustomError(\n+                            'not_operation_failed',\n+                            f'Not of {func_name} failed',  # type: ignore  # noqa: B023\n+                        )\n+\n+                    return v\n+\n+                schema = cs.no_info_after_validator_function(val_func, schema)\n+            elif hasattr(annotation.func, '__class__'):\n+                class_name = annotation.func.__class__.__qualname__\n+\n+                if (annotation_type := type(annotation.func)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+                    constraint = at_to_constraint_map[annotation_type]\n+\n+                    def val_func(v: Any) -> Any:\n+                        try:\n+                            if get_constraint_validator(constraint)(v, getattr(annotation.func, constraint)) is v:  # noqa: B023\n+                                raise PydanticCustomError(\n+                                    'not_operation_failed',\n+                                    f'Not of {class_name} failed',  # type: ignore  # noqa: B023\n+                                )\n+                        except PydanticKnownError:\n+                            pass\n+\n+                        return v\n+\n+                    schema = cs.no_info_after_validator_function(val_func, schema)",
      "comment": "I wonder if things could be adapted on the `annotated-types` side. `Not(<constraint>)` looks like a useful pattern",
      "comment_id": 1727753685,
      "user": "Viicos",
      "created_at": "2024-08-22T20:12:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/10210#discussion_r1727753685"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10210,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,6 +312,40 @@ def val_func(v: Any) -> Any:\n                 return v\n \n             schema = cs.no_info_after_validator_function(val_func, schema)\n+        elif isinstance(annotation, at.Not):\n+            if hasattr(annotation.func, '__qualname__'):\n+                func_name = annotation.func.__qualname__\n+\n+                def val_func(v: Any) -> Any:\n+                    if annotation.func(v):  # noqa: B023\n+                        raise PydanticCustomError(\n+                            'not_operation_failed',\n+                            f'Not of {func_name} failed',  # type: ignore  # noqa: B023\n+                        )\n+\n+                    return v\n+\n+                schema = cs.no_info_after_validator_function(val_func, schema)\n+            elif hasattr(annotation.func, '__class__'):\n+                class_name = annotation.func.__class__.__qualname__\n+\n+                if (annotation_type := type(annotation.func)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+                    constraint = at_to_constraint_map[annotation_type]\n+\n+                    def val_func(v: Any) -> Any:\n+                        try:\n+                            if get_constraint_validator(constraint)(v, getattr(annotation.func, constraint)) is v:  # noqa: B023\n+                                raise PydanticCustomError(\n+                                    'not_operation_failed',\n+                                    f'Not of {class_name} failed',  # type: ignore  # noqa: B023\n+                                )\n+                        except PydanticKnownError:\n+                            pass\n+\n+                        return v\n+\n+                    schema = cs.no_info_after_validator_function(val_func, schema)",
      "comment": "I sketched out an idea in https://github.com/annotated-types/annotated-types/pull/74#pullrequestreview-2102931534 but nobody's volunteered to implement it yet \ud83d\ude42 ",
      "comment_id": 1728044105,
      "user": "Zac-HD",
      "created_at": "2024-08-22T23:35:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10210#discussion_r1728044105"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10210,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,6 +312,40 @@ def val_func(v: Any) -> Any:\n                 return v\n \n             schema = cs.no_info_after_validator_function(val_func, schema)\n+        elif isinstance(annotation, at.Not):\n+            if hasattr(annotation.func, '__qualname__'):\n+                func_name = annotation.func.__qualname__\n+\n+                def val_func(v: Any) -> Any:\n+                    if annotation.func(v):  # noqa: B023\n+                        raise PydanticCustomError(\n+                            'not_operation_failed',\n+                            f'Not of {func_name} failed',  # type: ignore  # noqa: B023\n+                        )\n+\n+                    return v\n+\n+                schema = cs.no_info_after_validator_function(val_func, schema)\n+            elif hasattr(annotation.func, '__class__'):\n+                class_name = annotation.func.__class__.__qualname__\n+\n+                if (annotation_type := type(annotation.func)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+                    constraint = at_to_constraint_map[annotation_type]\n+\n+                    def val_func(v: Any) -> Any:\n+                        try:\n+                            if get_constraint_validator(constraint)(v, getattr(annotation.func, constraint)) is v:  # noqa: B023\n+                                raise PydanticCustomError(\n+                                    'not_operation_failed',\n+                                    f'Not of {class_name} failed',  # type: ignore  # noqa: B023\n+                                )\n+                        except PydanticKnownError:\n+                            pass\n+\n+                        return v\n+\n+                    schema = cs.no_info_after_validator_function(val_func, schema)",
      "comment": "@aditkumar72 let's implement support in pydantic given the existing api for Not, then we can expand it down the line.",
      "comment_id": 1729130115,
      "user": "sydney-runkle",
      "created_at": "2024-08-23T15:09:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10210#discussion_r1729130115"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,16 +114,25 @@ class Model(BaseModel):\n     \"\"\"\n \n     func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n+    input_type: Any = PydanticUndefined\n \n-    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n         schema = handler(source_type)\n+        input_schema = None if self.input_type is PydanticUndefined else handler.generate_schema(self.input_type)\n+        metadata = {'input_schema': input_schema}",
      "comment": "I'm using the `metadata` field to hold this information, instead of creating a new attribute in the relevant core schemas. That is because `input_schema` is only relevant for JSON Schema generation (unlike serializers where `return_schema` is actually used by `pydantic-core`).",
      "comment_id": 1712164434,
      "user": "Viicos",
      "created_at": "2024-08-09T20:34:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1712164434"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,16 +114,25 @@ class Model(BaseModel):\n     \"\"\"\n \n     func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n+    input_type: Any = PydanticUndefined\n \n-    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n         schema = handler(source_type)\n+        input_schema = None if self.input_type is PydanticUndefined else handler.generate_schema(self.input_type)\n+        metadata = {'input_schema': input_schema}",
      "comment": "TODO I need to make proper use of the metadata field here (see `CoreMetadata` typed dict).",
      "comment_id": 1713648528,
      "user": "Viicos",
      "created_at": "2024-08-12T12:18:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1713648528"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,16 +114,25 @@ class Model(BaseModel):\n     \"\"\"\n \n     func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n+    input_type: Any = PydanticUndefined\n \n-    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n         schema = handler(source_type)\n+        input_schema = None if self.input_type is PydanticUndefined else handler.generate_schema(self.input_type)\n+        metadata = {'input_schema': input_schema}",
      "comment": "Looking at `build_metadata_dict`, it looks like having extra metadata fields (that can be specified through the `initial_metadata` argument) is a supported pattern. So in fact I believe having this `input_schema` value added is fine?",
      "comment_id": 1717119953,
      "user": "Viicos",
      "created_at": "2024-08-14T15:12:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1717119953"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,19 +186,36 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchema\n \n         try:\n             schema = handler(source_type)\n-            serialization = core_schema.wrap_serializer_function_ser_schema(function=lambda v, h: h(v), schema=schema)\n+            serialization = core_schema.wrap_serializer_function_ser_schema(\n+                function=lambda v, h: h(v),\n+                schema=schema,\n+                return_schema=schema,\n+            )",
      "comment": "Note: the added `return_schema` allows for the following to not crash (it did before):\r\n\r\n```python\r\nfrom typing import Annotated\r\n\r\nfrom pydantic import PlainValidator, BaseModel\r\n\r\n\r\nclass MyModel(BaseModel):\r\n    a: Annotated[int, PlainValidator(lambda x: x)]\r\n\r\n\r\nprint(MyModel.model_json_schema(mode='serialization'))\r\n```",
      "comment_id": 1718425894,
      "user": "Viicos",
      "created_at": "2024-08-15T13:44:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1718425894"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "tests/pyright/decorators.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -88,6 +90,58 @@ def valid_method_no_info(self) -> Self: ...\n     def valid_method_info(self, info: ValidationInfo) -> Self: ...\n \n \n+class BeforeFieldValidator(BaseModel):\n+    \"\"\"Same tests should apply to `mode='plain'`.\"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    def no_classmethod(self, value: Any) -> Any:\n+        \"\"\"TODO this shouldn't be valid, the decorator should only work on classmethods.\n+\n+        We might want to do the same type checking as wrap model validators.\n+        \"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    @classmethod\n+    def valid_classmethod(cls, value: Any) -> Any: ...\n+\n+    @field_validator('foo', mode='before')  # pyright: ignore[reportArgumentType]\n+    @classmethod\n+    def invalid_with_info(cls, value: Any, info: int) -> Any: ...\n+\n+    @field_validator('foo', mode='before', input_type=int)  # `input_type` allowed here.\n+    @classmethod\n+    def valid_with_info(cls, value: Any, info: ValidationInfo) -> Any: ...",
      "comment": "I recall we chatted about this recently on a call, but so that we have it documented on this PR:\r\n\r\nWhy can't we use the following for this case, and infer the input type from the method signature?\r\n\r\n```py\r\n@field_validator('foo', mode='before') \r\n    @classmethod\r\n    def valid_with_info(cls, value: int, info: ValidationInfo) -> Any: ...\r\n```",
      "comment_id": 1719882954,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T13:57:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1719882954"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "tests/test_json_schema.py",
      "line": 6523,
      "side": "RIGHT",
      "diff_hunk": "@@ -6354,3 +6357,29 @@ class Foo(BaseModel):\n def test_min_and_max_in_schema() -> None:\n     TSeq = TypeAdapter(Annotated[Sequence[int], Field(min_length=2, max_length=5)])\n     assert TSeq.json_schema() == {'items': {'type': 'integer'}, 'maxItems': 5, 'minItems': 2, 'type': 'array'}\n+\n+\n+def test_field_validator_input_type() -> None:\n+    class Model(BaseModel):\n+        a: Annotated[int, BeforeValidator(lambda v: v, input_type=Union[int, str])]\n+        b: Annotated[int, WrapValidator(lambda v, h: h(v), input_type=Union[int, str])]\n+        c: Annotated[int, PlainValidator(lambda v: v, input_type=Union[int, str])]\n+        d: int\n+\n+        @field_validator('d', mode='before', input_type=Union[int, str])\n+        @classmethod\n+        def validate_d(cls, value: Any) -> int: ...",
      "comment": "Test looks great. One follow up question - can we also add a test for `mode='wrap'` here?",
      "comment_id": 1719884999,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T13:58:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1719884999"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "tests/pyright/decorators.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -88,6 +90,58 @@ def valid_method_no_info(self) -> Self: ...\n     def valid_method_info(self, info: ValidationInfo) -> Self: ...\n \n \n+class BeforeFieldValidator(BaseModel):\n+    \"\"\"Same tests should apply to `mode='plain'`.\"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    def no_classmethod(self, value: Any) -> Any:\n+        \"\"\"TODO this shouldn't be valid, the decorator should only work on classmethods.\n+\n+        We might want to do the same type checking as wrap model validators.\n+        \"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    @classmethod\n+    def valid_classmethod(cls, value: Any) -> Any: ...\n+\n+    @field_validator('foo', mode='before')  # pyright: ignore[reportArgumentType]\n+    @classmethod\n+    def invalid_with_info(cls, value: Any, info: int) -> Any: ...\n+\n+    @field_validator('foo', mode='before', input_type=int)  # `input_type` allowed here.\n+    @classmethod\n+    def valid_with_info(cls, value: Any, info: ValidationInfo) -> Any: ...",
      "comment": "You mention in the PR description:\r\n\r\n> want to enforce the validator functions to check for any type (by using typing.Any)\r\n\r\nCould you elaborate on this?",
      "comment_id": 1719889316,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T14:02:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1719889316"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 375,
      "side": "RIGHT",
      "diff_hunk": "@@ -266,28 +329,39 @@ def __call__(\n     )\n     _V2WrapValidatorType = TypeVar('_V2WrapValidatorType', bound=Union[_V2WrapValidator, _PartialClsOrStaticMethod])\n \n+FieldValidatorModes: TypeAlias = Literal['before', 'after', 'wrap', 'plain']\n+\n \n @overload\n def field_validator(\n     field: str,\n     /,\n     *fields: str,\n-    mode: Literal['before', 'after', 'plain'] = ...,\n+    mode: Literal['wrap'],\n     check_fields: bool | None = ...,\n-) -> Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]: ...\n+    input_type: Any = ...,\n+) -> Callable[[_V2WrapValidatorType], _V2WrapValidatorType]: ...\n \n \n @overload\n def field_validator(\n     field: str,\n     /,\n     *fields: str,\n-    mode: Literal['wrap'],\n+    mode: Literal['before', 'plain'],\n     check_fields: bool | None = ...,\n-) -> Callable[[_V2WrapValidatorType], _V2WrapValidatorType]: ...\n+    input_type: Any = ...,\n+) -> Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]: ...\n \n \n-FieldValidatorModes: TypeAlias = Literal['before', 'after', 'wrap', 'plain']\n+@overload\n+def field_validator(\n+    field: str,\n+    /,\n+    *fields: str,\n+    mode: Literal['after'] = ...,\n+    check_fields: bool | None = ...,\n+) -> Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]: ...\n \n \n def field_validator(",
      "comment": "Changes to this function look great, nice work with the consistent changes to the overloads.",
      "comment_id": 1719903504,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T14:14:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1719903504"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1287,13 +1291,20 @@ def set_discriminator(schema: CoreSchema) -> CoreSchema:\n             schema = self._apply_discriminator_to_union(schema, field_info.discriminator)\n             return schema\n \n+        # Convert `@field_validator` decorators to `Before/After/Plain/WrapValidator` instances:\n+        validators_from_decorators = []\n+        for decorator in filter_field_decorator_info_by_field(decorators.field_validators.values(), name):\n+            validators_from_decorators.append(_mode_to_validator[decorator.info.mode]._from_decorator(decorator))\n+\n         with self.field_name_stack.push(name):\n             if field_info.discriminator is not None:\n-                schema = self._apply_annotations(source_type, annotations, transform_inner_schema=set_discriminator)\n+                schema = self._apply_annotations(\n+                    source_type, annotations + validators_from_decorators, transform_inner_schema=set_discriminator\n+                )\n             else:\n                 schema = self._apply_annotations(\n                     source_type,\n-                    annotations,\n+                    annotations + validators_from_decorators,\n                 )",
      "comment": "Hmm, if I recall, `_apply_annotations` is one of the functions we need to take a closer look at re performance. Looks like this is adding an additional burden to that function, which I'd prefer not to do.\r\n\r\nThat being said, I don't see any performance effects in `codspeed`, so maybe it's totally fine...",
      "comment_id": 1719924652,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T14:30:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1719924652"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "tests/pyright/decorators.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -88,6 +90,58 @@ def valid_method_no_info(self) -> Self: ...\n     def valid_method_info(self, info: ValidationInfo) -> Self: ...\n \n \n+class BeforeFieldValidator(BaseModel):\n+    \"\"\"Same tests should apply to `mode='plain'`.\"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    def no_classmethod(self, value: Any) -> Any:\n+        \"\"\"TODO this shouldn't be valid, the decorator should only work on classmethods.\n+\n+        We might want to do the same type checking as wrap model validators.\n+        \"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    @classmethod\n+    def valid_classmethod(cls, value: Any) -> Any: ...\n+\n+    @field_validator('foo', mode='before')  # pyright: ignore[reportArgumentType]\n+    @classmethod\n+    def invalid_with_info(cls, value: Any, info: int) -> Any: ...\n+\n+    @field_validator('foo', mode='before', input_type=int)  # `input_type` allowed here.\n+    @classmethod\n+    def valid_with_info(cls, value: Any, info: ValidationInfo) -> Any: ...",
      "comment": "Because in reality any value can be passed in, so the type hint won't reflect the actual possible values. I prefer to enforce that users use `Any` for the `value` type annotation, so that they make sure to actually check the allowed values. If we were to encourage users to annotate `value` to the allowed types:\r\n\r\n```python\r\n@field_validator('foo', mode='before') \r\n    @classmethod\r\n    def valid_with_info(cls, value: int, info: ValidationInfo) -> Any: ...\r\n```\r\n\r\nUsers will likely forget to do the proper runtime checks on `value` and assume it is already an `int`. This is even more likely if they do something like:\r\n\r\n```python\r\n@field_validator('foo', mode='before') \r\n    @classmethod\r\n    def valid_with_info(cls, value: int, info: ValidationInfo) -> Any:\r\n        if not isinstance(value, int):  # This should be done by users\r\n            raise ValidationError(...)  # Type checker error, marked as unreachable code\r\n```",
      "comment_id": 1719979051,
      "user": "Viicos",
      "created_at": "2024-08-16T15:11:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1719979051"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1287,13 +1291,20 @@ def set_discriminator(schema: CoreSchema) -> CoreSchema:\n             schema = self._apply_discriminator_to_union(schema, field_info.discriminator)\n             return schema\n \n+        # Convert `@field_validator` decorators to `Before/After/Plain/WrapValidator` instances:\n+        validators_from_decorators = []\n+        for decorator in filter_field_decorator_info_by_field(decorators.field_validators.values(), name):\n+            validators_from_decorators.append(_mode_to_validator[decorator.info.mode]._from_decorator(decorator))\n+\n         with self.field_name_stack.push(name):\n             if field_info.discriminator is not None:\n-                schema = self._apply_annotations(source_type, annotations, transform_inner_schema=set_discriminator)\n+                schema = self._apply_annotations(\n+                    source_type, annotations + validators_from_decorators, transform_inner_schema=set_discriminator\n+                )\n             else:\n                 schema = self._apply_annotations(\n                     source_type,\n-                    annotations,\n+                    annotations + validators_from_decorators,\n                 )",
      "comment": "> That being said, I don't see any performance effects in `codspeed`, so maybe it's totally fine...\r\n\r\nWould be great to review those benchmarks as it seems to not be affected by previous changes as well.\r\n\r\nI don't think the performance hit will be noticeable, 99% of cases this only adds one annotation ",
      "comment_id": 1719982614,
      "user": "Viicos",
      "created_at": "2024-08-16T15:14:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1719982614"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,19 +186,36 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchema\n \n         try:\n             schema = handler(source_type)\n-            serialization = core_schema.wrap_serializer_function_ser_schema(function=lambda v, h: h(v), schema=schema)\n+            serialization = core_schema.wrap_serializer_function_ser_schema(\n+                function=lambda v, h: h(v),\n+                schema=schema,\n+                return_schema=schema,\n+            )",
      "comment": "Can we do this in a different PR, just to make the diff smaller / more streamlined here?",
      "comment_id": 1719994354,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T15:24:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1719994354"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1310,
      "side": "RIGHT",
      "diff_hunk": "@@ -1287,13 +1291,20 @@ def set_discriminator(schema: CoreSchema) -> CoreSchema:\n             schema = self._apply_discriminator_to_union(schema, field_info.discriminator)\n             return schema\n \n+        # Convert `@field_validator` decorators to `Before/After/Plain/WrapValidator` instances:\n+        validators_from_decorators = []\n+        for decorator in filter_field_decorator_info_by_field(decorators.field_validators.values(), name):\n+            validators_from_decorators.append(_mode_to_validator[decorator.info.mode]._from_decorator(decorator))\n+\n         with self.field_name_stack.push(name):\n             if field_info.discriminator is not None:\n-                schema = self._apply_annotations(source_type, annotations, transform_inner_schema=set_discriminator)\n+                schema = self._apply_annotations(\n+                    source_type, annotations + validators_from_decorators, transform_inner_schema=set_discriminator\n+                )\n             else:\n                 schema = self._apply_annotations(\n                     source_type,\n-                    annotations,\n+                    annotations + validators_from_decorators,\n                 )",
      "comment": "Yeah, seems negligible, I'll mark this as resolved.",
      "comment_id": 1719994843,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T15:25:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1719994843"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,13 +56,17 @@ class FieldValidatorDecoratorInfo:\n         fields: A tuple of field names the validator should be called on.\n         mode: The proposed validator mode.\n         check_fields: Whether to check that the fields actually exist on the model.\n+        input_type: The input type of the function. This is only used to generate\n+            the appropriate JSON Schema (in validation mode) and can only specified\n+            when `mode` is either `'before'`, `'plain'` or `'wrap'`.",
      "comment": "If this only affects the JSON schema and not any actual validation, I think the name of this argument should reflect that. Otherwise I think you might expect/have a hard time remembering if it validates the value into an int first.\r\n\r\nI understand the point of this is to handle non-after modes, so it makes sense for it to not add any validation, but I think you have to think about it a bit hard to remember this. If the argument was just `json_schema_input_type` it's very clear what it means.",
      "comment_id": 1720049357,
      "user": "dmontagu",
      "created_at": "2024-08-16T16:15:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1720049357"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,16 +114,25 @@ class Model(BaseModel):\n     \"\"\"\n \n     func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n+    input_type: Any = PydanticUndefined\n \n-    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n         schema = handler(source_type)\n+        input_schema = None if self.input_type is PydanticUndefined else handler.generate_schema(self.input_type)\n+        metadata = {'input_schema': input_schema}",
      "comment": "I think it would be better to not sprinkle a magic string `'input_schema'` around like this if at all possible, as it just makes it harder to keep track of all the different semantically-important keys in the `metadata`. In contrast with adding a key to `build_metadata_dict` and using that function. But I don't feel _super_ strongly about this, if others (in particular, @sydney-runkle) prefer this approach",
      "comment_id": 1720051568,
      "user": "dmontagu",
      "created_at": "2024-08-16T16:18:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1720051568"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,16 +114,25 @@ class Model(BaseModel):\n     \"\"\"\n \n     func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n+    input_type: Any = PydanticUndefined\n \n-    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n         schema = handler(source_type)\n+        input_schema = None if self.input_type is PydanticUndefined else handler.generate_schema(self.input_type)\n+        metadata = {'input_schema': input_schema}",
      "comment": "I agree with @dmontagu, I would strongly prefer to avoid both of the above - I'd rather not add a new key, and I'd also like to avoid injecting magic strings into `metadata`. See my suggestion [here](https://github.com/pydantic/pydantic/pull/10094#issuecomment-2293653992) for a potential alternative approach.",
      "comment_id": 1720054156,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T16:20:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1720054156"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "tests/pyright/decorators.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -88,6 +90,58 @@ def valid_method_no_info(self) -> Self: ...\n     def valid_method_info(self, info: ValidationInfo) -> Self: ...\n \n \n+class BeforeFieldValidator(BaseModel):\n+    \"\"\"Same tests should apply to `mode='plain'`.\"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    def no_classmethod(self, value: Any) -> Any:\n+        \"\"\"TODO this shouldn't be valid, the decorator should only work on classmethods.\n+\n+        We might want to do the same type checking as wrap model validators.\n+        \"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    @classmethod\n+    def valid_classmethod(cls, value: Any) -> Any: ...\n+\n+    @field_validator('foo', mode='before')  # pyright: ignore[reportArgumentType]\n+    @classmethod\n+    def invalid_with_info(cls, value: Any, info: int) -> Any: ...\n+\n+    @field_validator('foo', mode='before', input_type=int)  # `input_type` allowed here.\n+    @classmethod\n+    def valid_with_info(cls, value: Any, info: ValidationInfo) -> Any: ...",
      "comment": "I agree with @Viicos here, it's dangerous to annotate the `value` field with any type hint besides `Any`/`object` (and technically `object` is the safer thing to use as the type hint for this, and then do `isinstance` checks to narrow it), as it will mean that the type checker will assume that you can't get arbitrary stuff in the before validator, but you can.\r\n\r\nIn particular, I don't want to encourage users to try to annotate with anything besides that as a way to reduce the amount of code they write, as it will lead to problems. The JSON schema is useful for conveying what users _should_ be sending, but shouldn't be in tension/conflict with actual correctness-oriented type checking.\r\n\r\n(Relevant mypy issue mentioning stating explicitly that `object` is the type to use when you want the type checker to make no assumptions about the input value, and also not treat it as `Any`: https://github.com/python/mypy/issues/3712)",
      "comment_id": 1720055028,
      "user": "dmontagu",
      "created_at": "2024-08-16T16:21:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1720055028"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,13 +56,17 @@ class FieldValidatorDecoratorInfo:\n         fields: A tuple of field names the validator should be called on.\n         mode: The proposed validator mode.\n         check_fields: Whether to check that the fields actually exist on the model.\n+        input_type: The input type of the function. This is only used to generate\n+            the appropriate JSON Schema (in validation mode) and can only specified\n+            when `mode` is either `'before'`, `'plain'` or `'wrap'`.",
      "comment": "In all fairness, this is a good argument against my idea to add support for this to the core schema. We can chat about this in more detail on our next catchup \ud83d\udc4d ",
      "comment_id": 1720059895,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T16:25:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1720059895"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "tests/pyright/decorators.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -88,6 +90,58 @@ def valid_method_no_info(self) -> Self: ...\n     def valid_method_info(self, info: ValidationInfo) -> Self: ...\n \n \n+class BeforeFieldValidator(BaseModel):\n+    \"\"\"Same tests should apply to `mode='plain'`.\"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    def no_classmethod(self, value: Any) -> Any:\n+        \"\"\"TODO this shouldn't be valid, the decorator should only work on classmethods.\n+\n+        We might want to do the same type checking as wrap model validators.\n+        \"\"\"\n+\n+    @field_validator('foo', mode='before')\n+    @classmethod\n+    def valid_classmethod(cls, value: Any) -> Any: ...\n+\n+    @field_validator('foo', mode='before')  # pyright: ignore[reportArgumentType]\n+    @classmethod\n+    def invalid_with_info(cls, value: Any, info: int) -> Any: ...\n+\n+    @field_validator('foo', mode='before', json_schema_input_type=int)  # `input_type` allowed here.",
      "comment": "Let's modify the comment to `json_schema_input_type` allowed here, and add the same one for the below `WrapFieldValidator` case",
      "comment_id": 1723999197,
      "user": "sydney-runkle",
      "created_at": "2024-08-20T21:31:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1723999197"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,16 +114,25 @@ class Model(BaseModel):\n     \"\"\"\n \n     func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n+    input_type: Any = PydanticUndefined\n \n-    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n         schema = handler(source_type)\n+        input_schema = None if self.input_type is PydanticUndefined else handler.generate_schema(self.input_type)\n+        metadata = {'input_schema': input_schema}",
      "comment": "Ok, so following up on this - given that we are using the metadata to store this information, I'd rather that we sort of \"officially\" support it by adding this field to `CoreMetadata` and the `build_metadata_dict` constructor.",
      "comment_id": 1724002136,
      "user": "sydney-runkle",
      "created_at": "2024-08-20T21:34:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1724002136"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,16 +114,25 @@ class Model(BaseModel):\n     \"\"\"\n \n     func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n+    input_type: Any = PydanticUndefined\n \n-    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n         schema = handler(source_type)\n+        input_schema = None if self.input_type is PydanticUndefined else handler.generate_schema(self.input_type)\n+        metadata = {'input_schema': input_schema}",
      "comment": "It might be a bit slower / more verbose than actually needed, but I think it'll make a refactor down the line easier if we remain consistent with how we handle json schema metadata in this PR.",
      "comment_id": 1724002661,
      "user": "sydney-runkle",
      "created_at": "2024-08-20T21:35:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1724002661"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,15 +198,32 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchema\n         except PydanticSchemaGenerationError:\n             serialization = None\n \n+        input_schema = (\n+            None",
      "comment": "Regarding your question from above:\r\n\r\n>  Decide if we want to default to Any for input_type (so that the JSON Schema for a model with a PlainValidator works out of the box).\r\n\r\nI'd opt for yes - we basically infer this under the hood, so I'd opt into exposing this in JSON schema as well.",
      "comment_id": 1724003423,
      "user": "sydney-runkle",
      "created_at": "2024-08-20T21:36:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1724003423"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,6 +79,10 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchema\n             func = cast(core_schema.NoInfoValidatorFunction, self.func)\n             return core_schema.no_info_after_validator_function(func, schema=schema)\n \n+    @classmethod\n+    def _from_decorator(cls, decorator: _decorators.Decorator[_decorators.FieldValidatorDecoratorInfo]) -> Self:\n+        return cls(func=decorator.func)\n+",
      "comment": "@adriangb, what do you think about this `_from_decorator` pattern? Sort of replaces the old pattern of `apply_validators` using` _VALIDATOR_F_MATCH`. I didn't help to write that section of the codebase, so wanted to get feedback from someone who might have some more thoughts / context.",
      "comment_id": 1724007736,
      "user": "sydney-runkle",
      "created_at": "2024-08-20T21:42:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1724007736"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/json_schema.py",
      "line": 988,
      "side": "RIGHT",
      "diff_hunk": "@@ -995,7 +981,10 @@ def function_before_schema(self, schema: core_schema.BeforeValidatorFunctionSche\n         Returns:\n             The generated JSON schema.\n         \"\"\"\n-        return self._function_schema(schema)\n+        if self._mode == 'validation' and (input_schema := schema.get('metadata', {}).get('input_schema')):\n+            return self.generate_inner(input_schema)\n+\n+        return self.generate_inner(schema['schema'])",
      "comment": "We'll want to use the `CoreMetadataHandler` thing here once we make the switch to support `json_schema_input_type` there -- perhaps we also want to name the attribute with `json` in the name for consistency + clarity",
      "comment_id": 1724008640,
      "user": "sydney-runkle",
      "created_at": "2024-08-20T21:43:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1724008640"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1304,
      "side": "RIGHT",
      "diff_hunk": "@@ -1289,13 +1293,20 @@ def set_discriminator(schema: CoreSchema) -> CoreSchema:\n             schema = self._apply_discriminator_to_union(schema, field_info.discriminator)\n             return schema\n \n+        # Convert `@field_validator` decorators to `Before/After/Plain/WrapValidator` instances:\n+        validators_from_decorators = []\n+        for decorator in filter_field_decorator_info_by_field(decorators.field_validators.values(), name):\n+            validators_from_decorators.append(_mode_to_validator[decorator.info.mode]._from_decorator(decorator))\n+\n         with self.field_name_stack.push(name):\n             if field_info.discriminator is not None:\n-                schema = self._apply_annotations(source_type, annotations, transform_inner_schema=set_discriminator)\n+                schema = self._apply_annotations(\n+                    source_type, annotations + validators_from_decorators, transform_inner_schema=set_discriminator",
      "comment": "This is an interesting pattern - I'm assuming, based on passing tests, that this preserves annotation order as expected.",
      "comment_id": 1724009391,
      "user": "sydney-runkle",
      "created_at": "2024-08-20T21:44:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1724009391"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,6 +79,10 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchema\n             func = cast(core_schema.NoInfoValidatorFunction, self.func)\n             return core_schema.no_info_after_validator_function(func, schema=schema)\n \n+    @classmethod\n+    def _from_decorator(cls, decorator: _decorators.Decorator[_decorators.FieldValidatorDecoratorInfo]) -> Self:\n+        return cls(func=decorator.func)\n+",
      "comment": "(I'll note that this removes the need for `_VALIDATOR_F_MATCH` and `apply_validators`. They are kept for deprecated decorator code but will be removed in v3).",
      "comment_id": 1724505864,
      "user": "Viicos",
      "created_at": "2024-08-21T06:59:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1724505864"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1304,
      "side": "RIGHT",
      "diff_hunk": "@@ -1289,13 +1293,20 @@ def set_discriminator(schema: CoreSchema) -> CoreSchema:\n             schema = self._apply_discriminator_to_union(schema, field_info.discriminator)\n             return schema\n \n+        # Convert `@field_validator` decorators to `Before/After/Plain/WrapValidator` instances:\n+        validators_from_decorators = []\n+        for decorator in filter_field_decorator_info_by_field(decorators.field_validators.values(), name):\n+            validators_from_decorators.append(_mode_to_validator[decorator.info.mode]._from_decorator(decorator))\n+\n         with self.field_name_stack.push(name):\n             if field_info.discriminator is not None:\n-                schema = self._apply_annotations(source_type, annotations, transform_inner_schema=set_discriminator)\n+                schema = self._apply_annotations(\n+                    source_type, annotations + validators_from_decorators, transform_inner_schema=set_discriminator",
      "comment": "Indeed it does. Previously, annotations where applied and then the validators from decorators. Same happens now, as `_apply_annotations` will apply the `annotations` argument from \"left to right\".",
      "comment_id": 1724507889,
      "user": "Viicos",
      "created_at": "2024-08-21T07:00:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1724507889"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 2317,
      "side": "RIGHT",
      "diff_hunk": "@@ -2304,6 +2312,8 @@ def _apply_model_serializers(\n }\n \n \n+# TODO V3: this function is only used for deprecated decorators. It should\n+# be removed once we drop support for those.",
      "comment": "Looks like this is also used in some other places in the file - just wanted to make sure you were aware of that...",
      "comment_id": 1726137249,
      "user": "sydney-runkle",
      "created_at": "2024-08-22T01:50:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1726137249"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,15 +198,32 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchema\n         except PydanticSchemaGenerationError:\n             serialization = None\n \n+        input_schema = (\n+            None",
      "comment": "Made `Any` the default only for `PlainValidator`. For the others, the current behavior is to generate a JSON Schema for the type annotation (i.e. in related tests, `int`). Overriding this with `Any` would be a breaking change. I updated the tests if you want to see how it behaves.",
      "comment_id": 1726530768,
      "user": "Viicos",
      "created_at": "2024-08-22T07:47:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1726530768"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10094,
      "file_path": "pydantic/functional_validators.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,6 +79,10 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchema\n             func = cast(core_schema.NoInfoValidatorFunction, self.func)\n             return core_schema.no_info_after_validator_function(func, schema=schema)\n \n+    @classmethod\n+    def _from_decorator(cls, decorator: _decorators.Decorator[_decorators.FieldValidatorDecoratorInfo]) -> Self:\n+        return cls(func=decorator.func)\n+",
      "comment": "No worries. I'm satisfied with this pattern, let's move forward here \ud83d\udc4d ",
      "comment_id": 1727027500,
      "user": "sydney-runkle",
      "created_at": "2024-08-22T13:09:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10094#discussion_r1727027500"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10203,
      "file_path": "docs/plugins/main.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,24 +7,32 @@\n import textwrap\n from pathlib import Path\n from textwrap import indent\n+from typing import TYPE_CHECKING\n \n import autoflake\n import pyupgrade._main as pyupgrade_main  # type: ignore\n+import requests\n import tomli\n import yaml\n from jinja2 import Template  # type: ignore\n from mkdocs.config import Config\n from mkdocs.structure.files import Files\n from mkdocs.structure.pages import Page\n \n-from .conversion_table import conversion_table\n-\n logger = logging.getLogger('mkdocs.plugin')\n THIS_DIR = Path(__file__).parent\n DOCS_DIR = THIS_DIR.parent\n PROJECT_ROOT = DOCS_DIR.parent\n \n \n+if TYPE_CHECKING:\n+    from .conversion_table import conversion_table\n+else:\n+    from conversion_table import conversion_table",
      "comment": "Not ideal. MkDocs does some `sys.path` magic so the absolute import works but type checkers don't understand it.",
      "comment_id": 1725383097,
      "user": "Viicos",
      "created_at": "2024-08-21T16:25:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10203#discussion_r1725383097"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10203,
      "file_path": "docs/plugins/main.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,6 +59,8 @@ def on_page_markdown(markdown: str, page: Page, config: Config, files: Files) ->\n         return md\n     if md := render_why(markdown, page):\n         return md\n+    if md := render_pydantic_settings(markdown, page):\n+        return md",
      "comment": "Ideally we should move away from these pattern: it isn't really elegant and we could move to the [Blocks API](https://facelessuser.github.io/pymdown-extensions/extensions/blocks/) at some point. It seems to provide similar functionality as Sphinx directives which are essential imo",
      "comment_id": 1725385233,
      "user": "Viicos",
      "created_at": "2024-08-21T16:27:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/10203#discussion_r1725385233"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10203,
      "file_path": "docs/plugins/main.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,21 +10,32 @@\n \n import autoflake\n import pyupgrade._main as pyupgrade_main  # type: ignore\n+import requests\n import tomli\n import yaml\n from jinja2 import Template  # type: ignore\n from mkdocs.config import Config\n from mkdocs.structure.files import Files\n from mkdocs.structure.pages import Page\n \n-from .conversion_table import conversion_table\n-\n logger = logging.getLogger('mkdocs.plugin')\n THIS_DIR = Path(__file__).parent\n DOCS_DIR = THIS_DIR.parent\n PROJECT_ROOT = DOCS_DIR.parent\n \n \n+try:\n+    from .conversion_table import conversion_table\n+except ImportError:\n+    # Due to how MkDocs requires this file to be specified (as a path and not a\n+    # dot-separated module name), relative imports don't work:\n+    # MkDocs is adding the dir. of this file to `sys.path` and uses\n+    # `importlib.spec_from_file_location` and `module_from_spec`, which isn't ideal.\n+    from conversion_table import conversion_table",
      "comment": "If they had used `importlib.import_module`, things would have been easier I think.",
      "comment_id": 1725416004,
      "user": "Viicos",
      "created_at": "2024-08-21T16:51:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/10203#discussion_r1725416004"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10181,
      "file_path": "pydantic/json_schema.py",
      "line": 2457,
      "side": "RIGHT",
      "diff_hunk": "@@ -2427,9 +2445,34 @@ def __get_pydantic_json_schema__(\n         json_schema = handler(core_schema)\n         if mode != handler.mode:\n             return json_schema\n-        examples = json_schema.get('examples', {})\n-        examples.update(to_jsonable_python(self.examples))\n-        json_schema['examples'] = examples\n+        examples = json_schema.get('examples')\n+        if examples is None:\n+            json_schema['examples'] = to_jsonable_python(self.examples)\n+        if isinstance(examples, dict):\n+            if isinstance(self.examples, list):\n+                warnings.warn(\n+                    'Updating existing JSON Schema examples of type dict with examples of type list. '\n+                    'Only the existing examples values will be retained.',\n+                    UserWarning,\n+                )",
      "comment": "Let's warn here (and on the next one) that `dict` is deprecated as well - I realize this will be raised in a separate warning, but I think it makes sense to reiterate in this one.",
      "comment_id": 1722285494,
      "user": "sydney-runkle",
      "created_at": "2024-08-19T20:00:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10181#discussion_r1722285494"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10167,
      "file_path": "tests/test_internal.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -220,11 +220,27 @@ def test_walk_core_schema_copies_ser_schema() -> None:\n     resulting in the mutation of the original `__pydantic_core_schema__` dict of a model.\n     \"\"\"\n \n+    class MyPlainValidator:\n+        \"\"\"A new change to `PlainValidator` made it so that the issue\n+        does not reproduce anymore. This class replicates the old behavior.\n+        \"\"\"",
      "comment": "Hmm, so do we need to test this anymore, if it's fixed?",
      "comment_id": 1721688805,
      "user": "sydney-runkle",
      "created_at": "2024-08-19T12:09:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/10167#discussion_r1721688805"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10167,
      "file_path": "tests/test_internal.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -220,11 +220,27 @@ def test_walk_core_schema_copies_ser_schema() -> None:\n     resulting in the mutation of the original `__pydantic_core_schema__` dict of a model.\n     \"\"\"\n \n+    class MyPlainValidator:\n+        \"\"\"A new change to `PlainValidator` made it so that the issue\n+        does not reproduce anymore. This class replicates the old behavior.\n+        \"\"\"",
      "comment": "It might be that in another scenario where `return_schema` isn't specified in the wrap serializer schema, the issue still happens. A more robust test would be to assert that generated core schemas for already existing models in a module doesn't change whenever you define a new one. Not sure how easy it is to implement though.",
      "comment_id": 1721696481,
      "user": "Viicos",
      "created_at": "2024-08-19T12:15:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10167#discussion_r1721696481"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10167,
      "file_path": "tests/test_internal.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -220,11 +220,27 @@ def test_walk_core_schema_copies_ser_schema() -> None:\n     resulting in the mutation of the original `__pydantic_core_schema__` dict of a model.\n     \"\"\"\n \n+    class MyPlainValidator:\n+        \"\"\"A new change to `PlainValidator` made it so that the issue\n+        does not reproduce anymore. This class replicates the old behavior.\n+        \"\"\"",
      "comment": "Ah yeah, good point. Perhaps then we could remove this test and attempt to add a test for that instead.",
      "comment_id": 1721707022,
      "user": "sydney-runkle",
      "created_at": "2024-08-19T12:24:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/10167#discussion_r1721707022"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9654,
      "file_path": "pydantic/json_schema.py",
      "line": 1859,
      "side": "RIGHT",
      "diff_hunk": "@@ -1847,6 +1847,17 @@ def ser_schema(\n             return self.generate_inner(schema['schema'])\n         return None\n \n+    def complex_schema(self, schema: core_schema.ComplexSchema) -> JsonSchemaValue:\n+        \"\"\"Generates a JSON schema that matches a complex number.\n+\n+        Args:\n+            schema: The core schema.\n+\n+        Returns:\n+            The generated JSON schema.\n+        \"\"\"\n+        return {'type': 'complex'}",
      "comment": "As a reference going forward: https://json-schema.org/understanding-json-schema/reference/numeric",
      "comment_id": 1638650828,
      "user": "sydney-runkle",
      "created_at": "2024-06-13T17:38:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/9654#discussion_r1638650828"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9654,
      "file_path": "tests/test_types.py",
      "line": 6690,
      "side": "RIGHT",
      "diff_hunk": "@@ -6685,3 +6685,49 @@ class Foo(BaseModel):\n     # validation error raised bc foo field uses strict mode\n     with pytest.raises(ValidationError):\n         Foo(foo='1')\n+\n+\n+def test_complex_field():",
      "comment": "Tests look good so far, though I think you're right, we'll want to support the string `1+2j` format :)",
      "comment_id": 1638651572,
      "user": "sydney-runkle",
      "created_at": "2024-06-13T17:39:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/9654#discussion_r1638651572"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9654,
      "file_path": "tests/mypy/outputs/1.0.1/mypy-plugin_ini/plugin_strict_fields.py",
      "line": 1,
      "side": "LEFT",
      "diff_hunk": "@@ -1,56 +1,56 @@\n-from pydantic import BaseModel, Field\r",
      "comment": "I'm not sure what is actually changed in this file. Everything looks identical. It was \"updated\" after I ran `make test-mypy-update-all`.",
      "comment_id": 1719059214,
      "user": "changhc",
      "created_at": "2024-08-15T22:07:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/9654#discussion_r1719059214"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9863,
      "file_path": "pydantic/json_schema.py",
      "line": 2051,
      "side": "RIGHT",
      "diff_hunk": "@@ -2042,10 +2042,16 @@ def handle_ref_overrides(self, json_schema: JsonSchemaValue) -> JsonSchemaValue:\n         return json_schema\n \n     def get_schema_from_definitions(self, json_ref: JsonRef) -> JsonSchemaValue | None:\n-        def_ref = self.json_to_defs_refs[json_ref]\n-        if def_ref in self._core_defs_invalid_for_json_schema:\n-            raise self._core_defs_invalid_for_json_schema[def_ref]\n-        return self.definitions.get(def_ref, None)\n+        try:\n+            def_ref = self.json_to_defs_refs[json_ref]\n+            if def_ref in self._core_defs_invalid_for_json_schema:\n+                raise self._core_defs_invalid_for_json_schema[def_ref]\n+            return self.definitions.get(def_ref, None)\n+        except KeyError as e:\n+            if json_ref.startswith('http://') or json_ref.startswith('https://'):",
      "comment": "```suggestion\r\n            if json_ref.startswith(('http://', 'https://')):\r\n```",
      "comment_id": 1683269741,
      "user": "sydney-runkle",
      "created_at": "2024-07-18T17:56:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/9863#discussion_r1683269741"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9863,
      "file_path": "pydantic/json_schema.py",
      "line": 2170,
      "side": "RIGHT",
      "diff_hunk": "@@ -2155,10 +2161,14 @@ def _add_json_refs(schema: Any) -> None:\n                     json_refs[json_ref] += 1\n                     if already_visited:\n                         return  # prevent recursion on a definition that was already visited\n-                    defs_ref = self.json_to_defs_refs[json_ref]\n-                    if defs_ref in self._core_defs_invalid_for_json_schema:\n-                        raise self._core_defs_invalid_for_json_schema[defs_ref]\n-                    _add_json_refs(self.definitions[defs_ref])\n+                    try:\n+                        defs_ref = self.json_to_defs_refs[json_ref]\n+                        if defs_ref in self._core_defs_invalid_for_json_schema:\n+                            raise self._core_defs_invalid_for_json_schema[defs_ref]\n+                        _add_json_refs(self.definitions[defs_ref])\n+                    except KeyError as e:\n+                        if not (json_ref.startswith('http://') or json_ref.startswith('https://')):",
      "comment": "```suggestion\r\n                        if not json_ref.startswith(('http://', 'https://')):\r\n```",
      "comment_id": 1683271848,
      "user": "sydney-runkle",
      "created_at": "2024-07-18T17:58:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/9863#discussion_r1683271848"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9863,
      "file_path": "pydantic/json_schema.py",
      "line": 2235,
      "side": "RIGHT",
      "diff_hunk": "@@ -2215,11 +2225,15 @@ def _garbage_collect_definitions(self, schema: JsonSchemaValue) -> None:\n         unvisited_json_refs = _get_all_json_refs(schema)\n         while unvisited_json_refs:\n             next_json_ref = unvisited_json_refs.pop()\n-            next_defs_ref = self.json_to_defs_refs[next_json_ref]\n-            if next_defs_ref in visited_defs_refs:\n-                continue\n-            visited_defs_refs.add(next_defs_ref)\n-            unvisited_json_refs.update(_get_all_json_refs(self.definitions[next_defs_ref]))\n+            try:\n+                next_defs_ref = self.json_to_defs_refs[next_json_ref]\n+                if next_defs_ref in visited_defs_refs:\n+                    continue\n+                visited_defs_refs.add(next_defs_ref)\n+                unvisited_json_refs.update(_get_all_json_refs(self.definitions[next_defs_ref]))\n+            except KeyError as e:\n+                if not (next_json_ref.startswith('http://') or next_json_ref.startswith('https://')):",
      "comment": "```suggestion\r\n                if not next_json_ref.startswith(('http://', 'https://')):\r\n```",
      "comment_id": 1683272308,
      "user": "sydney-runkle",
      "created_at": "2024-07-18T17:59:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/9863#discussion_r1683272308"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9863,
      "file_path": "pydantic/json_schema.py",
      "line": 2054,
      "side": "RIGHT",
      "diff_hunk": "@@ -2042,10 +2042,16 @@ def handle_ref_overrides(self, json_schema: JsonSchemaValue) -> JsonSchemaValue:\n         return json_schema\n \n     def get_schema_from_definitions(self, json_ref: JsonRef) -> JsonSchemaValue | None:\n-        def_ref = self.json_to_defs_refs[json_ref]\n-        if def_ref in self._core_defs_invalid_for_json_schema:\n-            raise self._core_defs_invalid_for_json_schema[def_ref]\n-        return self.definitions.get(def_ref, None)\n+        try:\n+            def_ref = self.json_to_defs_refs[json_ref]\n+            if def_ref in self._core_defs_invalid_for_json_schema:\n+                raise self._core_defs_invalid_for_json_schema[def_ref]\n+            return self.definitions.get(def_ref, None)\n+        except KeyError as e:\n+            if json_ref.startswith(('http://', 'https://')):\n+                return None\n+            else:\n+                raise e",
      "comment": "Would recommend this just be `raise` as that's the builtin syntax for reraising an existing exception with its stack intact.\r\n\r\nSame for the two below instances as well.",
      "comment_id": 1688690024,
      "user": "reversefold",
      "created_at": "2024-07-23T20:40:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/9863#discussion_r1688690024"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9863,
      "file_path": "tests/test_json_schema.py",
      "line": 1655,
      "side": "RIGHT",
      "diff_hunk": "@@ -1641,6 +1641,25 @@ class Baz(BaseModel):\n         models_json_schema([(Bar, 'validation'), (Baz, 'validation')], ref_template='/schemas/{bad_name}.json#/')\n \n \n+def test_external_ref():\n+    \"\"\"https://github.com/pydantic/pydantic/issues/9783\"\"\"\n+\n+    class Model(BaseModel):\n+        json_schema: typing.Annotated[\n+            dict,\n+            WithJsonSchema({'$ref': 'https://json-schema.org/draft/2020-12/schema'}),\n+        ]\n+\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'json_schema': {'allOf': [{'$ref': 'https://json-schema.org/draft/2020-12/schema'}], 'title': 'Json Schema'}",
      "comment": "Hmm, if it's an external ref, I wonder if we want to keep the other schema info?",
      "comment_id": 1689762817,
      "user": "sydney-runkle",
      "created_at": "2024-07-24T13:05:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/9863#discussion_r1689762817"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9863,
      "file_path": "tests/test_json_schema.py",
      "line": 1655,
      "side": "RIGHT",
      "diff_hunk": "@@ -1641,6 +1641,25 @@ class Baz(BaseModel):\n         models_json_schema([(Bar, 'validation'), (Baz, 'validation')], ref_template='/schemas/{bad_name}.json#/')\n \n \n+def test_external_ref():\n+    \"\"\"https://github.com/pydantic/pydantic/issues/9783\"\"\"\n+\n+    class Model(BaseModel):\n+        json_schema: typing.Annotated[\n+            dict,\n+            WithJsonSchema({'$ref': 'https://json-schema.org/draft/2020-12/schema'}),\n+        ]\n+\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'json_schema': {'allOf': [{'$ref': 'https://json-schema.org/draft/2020-12/schema'}], 'title': 'Json Schema'}",
      "comment": "I'm wondering why there's an `allOf` rule here since there's only one entry. In general shouldn't `WithJsonSchema` just be replacing the JSON Schema for that attribute? Is it this way because it's trying to keep the `title` attribute?",
      "comment_id": 1690572299,
      "user": "reversefold",
      "created_at": "2024-07-24T23:17:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/9863#discussion_r1690572299"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9863,
      "file_path": "tests/test_json_schema.py",
      "line": 1655,
      "side": "RIGHT",
      "diff_hunk": "@@ -1641,6 +1641,25 @@ class Baz(BaseModel):\n         models_json_schema([(Bar, 'validation'), (Baz, 'validation')], ref_template='/schemas/{bad_name}.json#/')\n \n \n+def test_external_ref():\n+    \"\"\"https://github.com/pydantic/pydantic/issues/9783\"\"\"\n+\n+    class Model(BaseModel):\n+        json_schema: typing.Annotated[\n+            dict,\n+            WithJsonSchema({'$ref': 'https://json-schema.org/draft/2020-12/schema'}),\n+        ]\n+\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'json_schema': {'allOf': [{'$ref': 'https://json-schema.org/draft/2020-12/schema'}], 'title': 'Json Schema'}",
      "comment": "See https://github.com/pydantic/pydantic/pull/10029, that should fix this (I think)",
      "comment_id": 1701871841,
      "user": "sydney-runkle",
      "created_at": "2024-08-02T13:45:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/9863#discussion_r1701871841"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9863,
      "file_path": "tests/test_json_schema.py",
      "line": 1655,
      "side": "RIGHT",
      "diff_hunk": "@@ -1641,6 +1641,25 @@ class Baz(BaseModel):\n         models_json_schema([(Bar, 'validation'), (Baz, 'validation')], ref_template='/schemas/{bad_name}.json#/')\n \n \n+def test_external_ref():\n+    \"\"\"https://github.com/pydantic/pydantic/issues/9783\"\"\"\n+\n+    class Model(BaseModel):\n+        json_schema: typing.Annotated[\n+            dict,\n+            WithJsonSchema({'$ref': 'https://json-schema.org/draft/2020-12/schema'}),\n+        ]\n+\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'json_schema': {'allOf': [{'$ref': 'https://json-schema.org/draft/2020-12/schema'}], 'title': 'Json Schema'}",
      "comment": "> Hmm, if it's an external ref, I wonder if we want to keep the other schema info?\r\n\r\nI think this is actually a consequence of the `WithJsonSchema` annotation, so isn't a problem sourced from this PR.",
      "comment_id": 1720024748,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T15:51:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/9863#discussion_r1720024748"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10158,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 254,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,7 +239,25 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n \n         #  else, apply a function after validator to the schema to enforce the corresponding constraint\n         if constraint in chain_schema_constraints:\n-            chain_schema_steps.append(cs.str_schema(**{constraint: value}))\n+\n+            def _apply_constraint_with_incompatibility_info(\n+                value: Any, handler: cs.ValidatorFunctionWrapHandler\n+            ) -> Any:\n+                try:\n+                    x = handler(value)\n+                except ValidationError as ve:\n+                    if 'type' in ve.errors()[0]['type']:\n+                        raise TypeError(\n+                            f\"Unable to apply constraint '{constraint}' to supplied value {value} for schema of type '{schema_type}'\"  # noqa: B023\n+                        )\n+                    raise ve\n+                return x",
      "comment": "Maybe add an example here in a comment? It's not clear to me what the goal is just looking at hte code",
      "comment_id": 1720006143,
      "user": "adriangb",
      "created_at": "2024-08-16T15:34:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/10158#discussion_r1720006143"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10157,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -417,6 +425,12 @@ def inspect_namespace(  # noqa C901\n             and ann_type not in all_ignored_types\n             and getattr(ann_type, '__module__', None) != 'functools'\n         ):\n+            if isinstance(ann_type, str):\n+                # Walking up the frames to get the module namespace where the model is defined\n+                # (as the model class wasn't created yet, we unfortunately can't use `cls.__module__`):\n+                module = inspect.getmodule(sys._getframe(2))\n+                if module is not None:\n+                    ann_type = eval_type_backport(ForwardRef(ann_type), globalns=module.__dict__)",
      "comment": "It will fail indeed. Not having access to the current model class makes things annoying as stated in my comment. Not sure if we can address this issue? As I said in the original issue, the `Annotated` pattern isn't recommended anyway.",
      "comment_id": 1719820922,
      "user": "Viicos",
      "created_at": "2024-08-16T13:10:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10157#discussion_r1719820922"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10157,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -417,6 +425,12 @@ def inspect_namespace(  # noqa C901\n             and ann_type not in all_ignored_types\n             and getattr(ann_type, '__module__', None) != 'functools'\n         ):\n+            if isinstance(ann_type, str):\n+                # Walking up the frames to get the module namespace where the model is defined\n+                # (as the model class wasn't created yet, we unfortunately can't use `cls.__module__`):\n+                module = inspect.getmodule(sys._getframe(2))\n+                if module is not None:\n+                    ann_type = eval_type_backport(ForwardRef(ann_type), globalns=module.__dict__)",
      "comment": "I think we should consider many of the questions we've been thinking about for our other recent namespace management changes - how are things different if we rebuild or import a model in a new file?",
      "comment_id": 1719821720,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T13:11:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10157#discussion_r1719821720"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10157,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -417,6 +425,12 @@ def inspect_namespace(  # noqa C901\n             and ann_type not in all_ignored_types\n             and getattr(ann_type, '__module__', None) != 'functools'\n         ):\n+            if isinstance(ann_type, str):\n+                # Walking up the frames to get the module namespace where the model is defined\n+                # (as the model class wasn't created yet, we unfortunately can't use `cls.__module__`):\n+                module = inspect.getmodule(sys._getframe(2))\n+                if module is not None:\n+                    ann_type = eval_type_backport(ForwardRef(ann_type), globalns=module.__dict__)",
      "comment": "Should we be filtering the namespace with our new logic in `_typing_extra.py`?",
      "comment_id": 1719822007,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T13:11:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/10157#discussion_r1719822007"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10157,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -430,6 +438,12 @@ def inspect_namespace(  # noqa C901\n             and ann_type not in all_ignored_types\n             and getattr(ann_type, '__module__', None) != 'functools'\n         ):\n+            if isinstance(ann_type, str):\n+                # Walking up the frames to get the module namespace where the model is defined\n+                # (as the model class wasn't created yet, we unfortunately can't use `cls.__module__`):\n+                module = inspect.getmodule(sys._getframe(2))\n+                if module is not None:\n+                    ann_type = eval_type_backport(ForwardRef(ann_type), globalns=module.__dict__)",
      "comment": "```suggestion\r\n                frame = sys._getframe(2)\r\n                if frame is not None:\r\n                    ann_type = eval_type_backport(ForwardRef(ann_type), globalns=frame.f_globals, localns=frame.f_locals)\r\n```",
      "comment_id": 1719863467,
      "user": "alexmojaki",
      "created_at": "2024-08-16T13:42:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/10157#discussion_r1719863467"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10157,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -430,6 +438,12 @@ def inspect_namespace(  # noqa C901\n             and ann_type not in all_ignored_types\n             and getattr(ann_type, '__module__', None) != 'functools'\n         ):\n+            if isinstance(ann_type, str):\n+                # Walking up the frames to get the module namespace where the model is defined\n+                # (as the model class wasn't created yet, we unfortunately can't use `cls.__module__`):\n+                module = inspect.getmodule(sys._getframe(2))\n+                if module is not None:\n+                    ann_type = eval_type_backport(ForwardRef(ann_type), globalns=module.__dict__)",
      "comment": "Agreed with a movement towards this approach, but should we just use https://github.com/pydantic/pydantic/blob/72124848b53bfc648af2d3f28ba54ff392c623ec/pydantic/_internal/_typing_extra.py#L188?\r\n\r\nIf we go with that, then you can ignore all of my above comments, bc I think this would address them.",
      "comment_id": 1719867049,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T13:44:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10157#discussion_r1719867049"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10157,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -417,6 +425,12 @@ def inspect_namespace(  # noqa C901\n             and ann_type not in all_ignored_types\n             and getattr(ann_type, '__module__', None) != 'functools'\n         ):\n+            if isinstance(ann_type, str):\n+                # Walking up the frames to get the module namespace where the model is defined\n+                # (as the model class wasn't created yet, we unfortunately can't use `cls.__module__`):\n+                module = inspect.getmodule(sys._getframe(2))\n+                if module is not None:\n+                    ann_type = eval_type_backport(ForwardRef(ann_type), globalns=module.__dict__)",
      "comment": "> how are things different if we rebuild or import a model in a new file?\r\n\r\nIn these cases we have access to the class' module, so it helps as we can easily combine the module namespace and parent namespace (if necessary).\r\n\r\nI'll note that because the way `inspect.getmodule` works, the following is ok:\r\n\r\n```python\r\nfrom typing import Annotated\r\n\r\nfrom pydantic import BaseModel, PrivateAttr\r\n\r\ndef func():\r\n    class Model(BaseModel):\r\n        _foo: 'Annotated[int, PrivateAttr()]'\r\n\r\nfunc()\r\n```\r\n\r\n(however, it does not if `PrivateAttr` and/or `Annotated` is imported inside `func`).\r\n\r\n---\r\n\r\nWe can consider many scenarios where even our current annotation evaluation for normal fields (i.e. after `cls` is created in the metaclass, where all the logic to get the parent ns and merge it with the module ns is done) does not work as expected:\r\n\r\n```python\r\nfrom __future__ import annotations\r\n\r\nfrom pydantic import BaseModel\r\n\r\n\r\ndef test():\r\n    from typing import Annotated\r\n\r\n    def inner():\r\n\r\n        from pydantic import Field\r\n\r\n        class Model(BaseModel):\r\n            a: Annotated[int, Field(default=1)]\r\n\r\n        return Model\r\n\r\n    Model = inner()\r\n\r\ntest()\r\n```\r\n\r\nTrying to support these cases would probably complicate things (and also maybe increase memory/cpu usage). I'm also wondering how much of these use cases can be covered by PEP 649.",
      "comment_id": 1719879954,
      "user": "Viicos",
      "created_at": "2024-08-16T13:55:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/10157#discussion_r1719879954"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10157,
      "file_path": "pydantic/_internal/_model_construction.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -430,6 +438,12 @@ def inspect_namespace(  # noqa C901\n             and ann_type not in all_ignored_types\n             and getattr(ann_type, '__module__', None) != 'functools'\n         ):\n+            if isinstance(ann_type, str):\n+                # Walking up the frames to get the module namespace where the model is defined\n+                # (as the model class wasn't created yet, we unfortunately can't use `cls.__module__`):\n+                module = inspect.getmodule(sys._getframe(2))\n+                if module is not None:\n+                    ann_type = eval_type_backport(ForwardRef(ann_type), globalns=module.__dict__)",
      "comment": "`parent_frame_namespace` only considers locals so I went with the `frame` locals and globals",
      "comment_id": 1719889068,
      "user": "Viicos",
      "created_at": "2024-08-16T14:02:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10157#discussion_r1719889068"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10155,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -212,6 +212,7 @@ def _handle_other_schemas(self, schema: core_schema.CoreSchema, f: Walk) -> core\n     def _handle_ser_schemas(self, ser_schema: core_schema.SerSchema, f: Walk) -> core_schema.SerSchema:\n         schema: core_schema.CoreSchema | None = ser_schema.get('schema', None)\n         if schema is not None:\n+            ser_schema = ser_schema.copy()",
      "comment": "```suggestion\r\n            ser_schema = smart_deepcopy(ser_schema)\r\n```\r\n\r\nCan we match the approach used in this PR? https://github.com/pydantic/pydantic/pull/9980",
      "comment_id": 1719773634,
      "user": "sydney-runkle",
      "created_at": "2024-08-16T12:22:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10155#discussion_r1719773634"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10155,
      "file_path": "pydantic/_internal/_core_utils.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -212,6 +212,7 @@ def _handle_other_schemas(self, schema: core_schema.CoreSchema, f: Walk) -> core\n     def _handle_ser_schemas(self, ser_schema: core_schema.SerSchema, f: Walk) -> core_schema.SerSchema:\n         schema: core_schema.CoreSchema | None = ser_schema.get('schema', None)\n         if schema is not None:\n+            ser_schema = ser_schema.copy()",
      "comment": "I would rather stick with `.copy` here, as it is for the rest of the `_WalkSchema` implementation. `deepcopy` on a dict is slower and does not have any impact here, as `.copy` will create a shallow copy and this is enough (as we are only changing a top level key here, in this case the `'schema'` key).",
      "comment_id": 1719817556,
      "user": "Viicos",
      "created_at": "2024-08-16T13:07:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/10155#discussion_r1719817556"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10084,
      "file_path": "docs/plugins/griffe_doclinks.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,15 +79,7 @@ def update_docstring(obj: GriffeObject) -> str:\n     )\n \n \n-def update_docstrings_recursively(obj: GriffeObject) -> None:\n-    if obj.docstring:\n-        obj.docstring.value = update_docstring(obj)\n-    for member in obj.members.values():\n-        if not member.is_alias:\n-            update_docstrings_recursively(member)\n-\n-\n-class Extension(VisitorExtension):\n-    def visit_module(self, node: ast.AST) -> None:\n-        module = self.visitor.current.module\n-        update_docstrings_recursively(module)\n+class UpdateDocstringsExtension(Extension):\n+    def on_instance(self, *, node: ast.AST | ObjectNode, obj: GriffeObject) -> None:",
      "comment": "Sorry, upcoming v1 will pass an additional `agent` argument, and parent signatures also declare `**kwargs` so that downstream subclasses declare it too. It means you can remove unused params since they'll be swallowed by kwargs :)\n\nI'll let you check the changelog. I can also send PRs to update everything for upcoming v1! Just tell me ^^",
      "comment_id": 1718894422,
      "user": "pawamoy",
      "created_at": "2024-08-15T19:30:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/10084#discussion_r1718894422"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10084,
      "file_path": "docs/plugins/griffe_doclinks.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,15 +79,7 @@ def update_docstring(obj: GriffeObject) -> str:\n     )\n \n \n-def update_docstrings_recursively(obj: GriffeObject) -> None:\n-    if obj.docstring:\n-        obj.docstring.value = update_docstring(obj)\n-    for member in obj.members.values():\n-        if not member.is_alias:\n-            update_docstrings_recursively(member)\n-\n-\n-class Extension(VisitorExtension):\n-    def visit_module(self, node: ast.AST) -> None:\n-        module = self.visitor.current.module\n-        update_docstrings_recursively(module)\n+class UpdateDocstringsExtension(Extension):\n+    def on_instance(self, *, node: ast.AST | ObjectNode, obj: GriffeObject) -> None:",
      "comment": "Thanks for letting us know. We have our dependencies pinned anyway so it won't break anything until we manually update. I'll make sure to check the changelog and update our extension accordingly!\r\n\r\nAu plaisir",
      "comment_id": 1718923587,
      "user": "Viicos",
      "created_at": "2024-08-15T20:00:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10084#discussion_r1718923587"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10132,
      "file_path": "pydantic/json_schema.py",
      "line": 500,
      "side": "RIGHT",
      "diff_hunk": "@@ -492,6 +492,12 @@ def handler_func(schema_or_field: CoreSchemaOrField) -> JsonSchemaValue:\n             if self.mode == 'serialization' and 'serialization' in schema_or_field:\n                 ser_schema = schema_or_field['serialization']  # type: ignore\n                 json_schema = self.ser_schema(ser_schema)\n+                if (\n+                    json_schema is not None\n+                    and ser_schema.get('when_used') in ('unless-none', 'json-unless-none')\n+                    and schema_or_field['type'] == 'nullable'\n+                ):\n+                    json_schema = self.get_flattened_anyof([{'type': 'null'}, json_schema])",
      "comment": "I'm not too happy with how this is done. Ideally, `self.nullable_schema` should be used but it will use `schema['schema']` to generate the inner schema:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/a42fb6776ca46e3a3099f868f66ba6635a5e1d5a/pydantic/json_schema.py#L1084-L1094\r\n\r\nWhile we need `schema['serialization']` to be used instead.",
      "comment_id": 1717206193,
      "user": "Viicos",
      "created_at": "2024-08-14T16:05:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/10132#discussion_r1717206193"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10132,
      "file_path": "pydantic/json_schema.py",
      "line": 500,
      "side": "RIGHT",
      "diff_hunk": "@@ -492,6 +492,12 @@ def handler_func(schema_or_field: CoreSchemaOrField) -> JsonSchemaValue:\n             if self.mode == 'serialization' and 'serialization' in schema_or_field:\n                 ser_schema = schema_or_field['serialization']  # type: ignore\n                 json_schema = self.ser_schema(ser_schema)\n+                if (\n+                    json_schema is not None\n+                    and ser_schema.get('when_used') in ('unless-none', 'json-unless-none')\n+                    and schema_or_field['type'] == 'nullable'\n+                ):\n+                    json_schema = self.get_flattened_anyof([{'type': 'null'}, json_schema])",
      "comment": "Should we model the below more closely?\r\n\r\n```py\r\nif (\r\n    self.mode == 'serialization' \r\n    and 'serialization' in schema_or_field\r\n    and (ser_schema := schema_or_field['serialization']\r\n    and (json_schema := self.ser_schema(ser_schema))\r\n    and ser_schema.get('when_used') in ('unless-none', 'json-unless-none')\r\n    and schema_or_field['type'] == 'nullable'\r\n):\r\n    json_schema = self.get_flattened_anyof([{'type': 'null'}, json_schema])\r\n```\r\n\r\nOr something like that",
      "comment_id": 1717422685,
      "user": "sydney-runkle",
      "created_at": "2024-08-14T19:03:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/10132#discussion_r1717422685"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10132,
      "file_path": "pydantic/json_schema.py",
      "line": 500,
      "side": "RIGHT",
      "diff_hunk": "@@ -492,6 +492,12 @@ def handler_func(schema_or_field: CoreSchemaOrField) -> JsonSchemaValue:\n             if self.mode == 'serialization' and 'serialization' in schema_or_field:\n                 ser_schema = schema_or_field['serialization']  # type: ignore\n                 json_schema = self.ser_schema(ser_schema)\n+                if (\n+                    json_schema is not None\n+                    and ser_schema.get('when_used') in ('unless-none', 'json-unless-none')\n+                    and schema_or_field['type'] == 'nullable'\n+                ):\n+                    json_schema = self.get_flattened_anyof([{'type': 'null'}, json_schema])",
      "comment": "I understand your concern, but I agree, I think this is a fine patch for now. Maybe add a comment explaining the pattern here - we have so many conditionals, it's a bit hard to understand all together \ud83d\udc4d ",
      "comment_id": 1717427467,
      "user": "sydney-runkle",
      "created_at": "2024-08-14T19:07:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/10132#discussion_r1717427467"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10132,
      "file_path": "pydantic/json_schema.py",
      "line": 500,
      "side": "RIGHT",
      "diff_hunk": "@@ -492,6 +492,12 @@ def handler_func(schema_or_field: CoreSchemaOrField) -> JsonSchemaValue:\n             if self.mode == 'serialization' and 'serialization' in schema_or_field:\n                 ser_schema = schema_or_field['serialization']  # type: ignore\n                 json_schema = self.ser_schema(ser_schema)\n+                if (\n+                    json_schema is not None\n+                    and ser_schema.get('when_used') in ('unless-none', 'json-unless-none')\n+                    and schema_or_field['type'] == 'nullable'\n+                ):\n+                    json_schema = self.get_flattened_anyof([{'type': 'null'}, json_schema])",
      "comment": "> Should we model the below more closely?\r\n\r\nI think I prefer the two conditionals, as it shows the logic more clearly imo:\r\n\r\n- if we are in serialization mode and a serialization schema is available:\r\n  - shortcut JSON Schema generation and use `ser_schema`\r\n  - special case `nullable` schema depending on the value of `when_used`",
      "comment_id": 1718100213,
      "user": "Viicos",
      "created_at": "2024-08-15T08:08:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10132#discussion_r1718100213"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10136,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,9 +167,22 @@ def is_finalvar(ann_type: Any) -> bool:\n     return _check_finalvar(ann_type) or _check_finalvar(get_origin(ann_type))\n \n \n+_DEFAULT_GLOBALS = [\n+    '__name__',\n+    '__doc__',\n+    '__package__',\n+    '__loader__',\n+    '__spec__',\n+    '__annotations__',\n+    '__builtins__',\n+    '__file__',\n+    '__cached__',\n+]\n+\n+\n def _remove_default_globals_from_ns(namespace: dict[str, Any]) -> dict[str, Any]:\n     \"\"\"Remove default globals like __name__, __doc__, etc that aren't needed for type evaluation.\"\"\"\n-    return {k: v for k, v in namespace.items() if not k.startswith(('__', '@'))}\n+    return {k: v for k, v in namespace.items() if not k.startswith('@') and k not in _DEFAULT_GLOBALS}",
      "comment": "I'm wondering, `@` was taken from pytest-examples but is it really possible to have something starting with that in the namespace? `@.*` isn't a valid identifier",
      "comment_id": 1717417711,
      "user": "Viicos",
      "created_at": "2024-08-14T18:58:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/10136#discussion_r1717417711"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10136,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,9 +167,22 @@ def is_finalvar(ann_type: Any) -> bool:\n     return _check_finalvar(ann_type) or _check_finalvar(get_origin(ann_type))\n \n \n+_DEFAULT_GLOBALS = [\n+    '__name__',\n+    '__doc__',\n+    '__package__',\n+    '__loader__',\n+    '__spec__',\n+    '__annotations__',\n+    '__builtins__',\n+    '__file__',\n+    '__cached__',\n+]\n+\n+\n def _remove_default_globals_from_ns(namespace: dict[str, Any]) -> dict[str, Any]:\n     \"\"\"Remove default globals like __name__, __doc__, etc that aren't needed for type evaluation.\"\"\"\n-    return {k: v for k, v in namespace.items() if not k.startswith(('__', '@'))}\n+    return {k: v for k, v in namespace.items() if not k.startswith('@') and k not in _DEFAULT_GLOBALS}",
      "comment": "Good question, yeah, I saw lots of vars starting with `@` in the module namespace when I was running `pytest`, but perhaps that's not important for real applications. I guess I'm inclined to keep it bc it seems like the performance drawback is negligible, and it ensures the namespace is pretty clean.",
      "comment_id": 1717431341,
      "user": "sydney-runkle",
      "created_at": "2024-08-14T19:10:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/10136#discussion_r1717431341"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10137,
      "file_path": "tests/test_types.py",
      "line": 6845,
      "side": "RIGHT",
      "diff_hunk": "@@ -6834,3 +6834,12 @@ def test_ser_ip_with_unexpected_value() -> None:\n \n     with pytest.raises(UserWarning, match='serialized value may not be as expected.'):\n         assert ta.dump_python(123)\n+\n+\n+@pytest.mark.xfail(reason='For some reason fails with pytest, but works fine in the interpreter')\n+def test_import_string_sys_stdout() -> None:\n+    class ImportThings(BaseModel):\n+        obj: ImportString\n+\n+    import_things = ImportThings(obj='sys.stdout')\n+    assert import_things.model_dump_json() == '{\"obj\":\"sys.stdout\"}'",
      "comment": "Would it be possible to have the test next to the other `ImportString` related ones?",
      "comment_id": 1717424349,
      "user": "Viicos",
      "created_at": "2024-08-14T19:05:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10137#discussion_r1717424349"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10137,
      "file_path": "pydantic/types.py",
      "line": 1017,
      "side": "RIGHT",
      "diff_hunk": "@@ -1013,6 +1013,15 @@ def _serialize(v: Any) -> str:\n                 return v.__name__\n             elif hasattr(v, '__module__') and hasattr(v, '__name__'):\n                 return f'{v.__module__}.{v.__name__}'\n+            # Handle special cases for sys.XXX streams\n+            # if we see more of these, we should consider a more general solution",
      "comment": "I think in general serializing the imported object to a string is a hard (even impossible without special casing as it is done here) problem, so I'm fine with the proposed solution. ",
      "comment_id": 1717429585,
      "user": "Viicos",
      "created_at": "2024-08-14T19:09:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10137#discussion_r1717429585"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10121,
      "file_path": "tests/test_json_schema.py",
      "line": 6273,
      "side": "RIGHT",
      "diff_hunk": "@@ -6257,6 +6257,22 @@ class Model(BaseModel):\n     }\n \n \n+def test_plain_serializer_does_not_apply_json_unless_none() -> None:\n+    \"\"\"Test plain serializers aren't used to compute the JSON Schema default if mode is 'json-unless-none'\n+    and default value is `None`.\"\"\"\n+\n+    class Model(BaseModel):\n+        custom_decimal: Annotated[\n+            Decimal | None, PlainSerializer(lambda x: float(x), when_used='json-unless-none', return_type=float)\n+        ] = None\n+\n+    assert Model.model_json_schema(mode='serialization') == {\n+        'properties': {'custom_decimal': {'default': None, 'title': 'Custom Decimal', 'type': 'number'}},\n+        'title': 'Model',\n+        'type': 'object',\n+    }",
      "comment": "This revealed another issue with the JSON Schema: `type` should be `'anyOf': [{'type': 'number'}, {'type': 'null'}]}`.\r\n\r\nWhen the JSON Schema for our field is created, `schema` is of type `default`, and `schema['schema']` is of type `nullable`:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/0c97049bd40ac95cce7bbebad8369b9426af4b09/pydantic/json_schema.py#L1022-L1031\r\n\r\nHowever, `self.generate_inner(schema['schema']`) will not go through `nullable_schema` as we would expect. As there's a `serialization` key, `ser_schema` is being used:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/0c97049bd40ac95cce7bbebad8369b9426af4b09/pydantic/json_schema.py#L492-L494\r\n\r\nThis makes sense, however, the issue is `ser_schema` kind of assumes `when_used` is `always`. I'll see if I can fix this in a follow up PR.",
      "comment_id": 1715043570,
      "user": "Viicos",
      "created_at": "2024-08-13T10:15:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10121#discussion_r1715043570"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10121,
      "file_path": "pydantic/json_schema.py",
      "line": 1053,
      "side": "RIGHT",
      "diff_hunk": "@@ -1043,17 +1043,17 @@ def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaVal\n         #     return json_schema\n \n         # we reflect the application of custom plain, no-info serializers to defaults for\n-        # json schemas viewed in serialization mode\n+        # JSON Schemas viewed in serialization mode:\n         # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208\n-        # TODO: improve type safety here\n-        if self.mode == 'serialization':\n-            if (\n-                (ser_schema := schema['schema'].get('serialization', {}))\n-                and (ser_func := ser_schema.get('function'))\n-                and ser_schema.get('type') == 'function-plain'  # type: ignore\n-                and ser_schema.get('info_arg') is False  # type: ignore\n-            ):\n-                default = ser_func(default)  # type: ignore\n+        if (\n+            self.mode == 'serialization'\n+            and (ser_schema := schema['schema'].get('serialization'))\n+            and (ser_func := ser_schema.get('function'))\n+            and ser_schema.get('type') == 'function-plain'\n+            and not ser_schema.get('info_arg')",
      "comment": "Switching from `and ser_schema.get('info_arg') is False` releaved an issue in the tests, that I fixed in https://github.com/pydantic/pydantic/pull/10121/commits/0eed38407f2b05b6022df2dca838831f3d4047f5.",
      "comment_id": 1715132595,
      "user": "Viicos",
      "created_at": "2024-08-13T11:26:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10121#discussion_r1715132595"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10121,
      "file_path": "pydantic/json_schema.py",
      "line": 1069,
      "side": "RIGHT",
      "diff_hunk": "@@ -1043,17 +1043,30 @@ def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaVal\n         #     return json_schema\n \n         # we reflect the application of custom plain, no-info serializers to defaults for\n-        # json schemas viewed in serialization mode\n+        # JSON Schemas viewed in serialization mode:\n         # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208\n-        # TODO: improve type safety here\n-        if self.mode == 'serialization':\n-            if (\n-                (ser_schema := schema['schema'].get('serialization', {}))\n-                and (ser_func := ser_schema.get('function'))\n-                and ser_schema.get('type') == 'function-plain'  # type: ignore\n-                and ser_schema.get('info_arg') is False  # type: ignore\n-            ):\n+        if (\n+            self.mode == 'serialization'\n+            and (ser_schema := schema['schema'].get('serialization'))\n+            and (ser_func := ser_schema.get('function'))\n+            and ser_schema.get('type') == 'function-plain'\n+            and not ser_schema.get('info_arg')\n+            and not (default is None and ser_schema.get('when_used') == 'json-unless-none')\n+        ):\n+            try:\n                 default = ser_func(default)  # type: ignore\n+            except Exception:\n+                # It might be that the provided default needs to be validated first\n+                # (assuming `validate_default` is enabled). However, we can't perform\n+                # such validation during JSON Schema generation so we don't support\n+                # this pattern for now.\n+                # (One example is when using `foo: ByteSize = '1MB'`, which validates and\n+                # serializes as an int. In this case, `ser_func` is `int` and `int('1MB')` fails).\n+                self.emit_warning(\n+                    'non-serializable-default',\n+                    f'Unable to serialize value {default!r} with the plain serializer; excluding default from JSON schema',\n+                )\n+                return json_schema",
      "comment": "Could we do something like this?\r\n\r\nhttps://github.com/pydantic/pydantic/blob/0c97049bd40ac95cce7bbebad8369b9426af4b09/pydantic/json_schema.py#L2017-L2044\r\n\r\nI feel like we shouldn't be skipping that logic here, we could maybe call that function?",
      "comment_id": 1715482568,
      "user": "sydney-runkle",
      "created_at": "2024-08-13T15:16:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/10121#discussion_r1715482568"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10121,
      "file_path": "pydantic/json_schema.py",
      "line": 1069,
      "side": "RIGHT",
      "diff_hunk": "@@ -1043,17 +1043,30 @@ def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaVal\n         #     return json_schema\n \n         # we reflect the application of custom plain, no-info serializers to defaults for\n-        # json schemas viewed in serialization mode\n+        # JSON Schemas viewed in serialization mode:\n         # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208\n-        # TODO: improve type safety here\n-        if self.mode == 'serialization':\n-            if (\n-                (ser_schema := schema['schema'].get('serialization', {}))\n-                and (ser_func := ser_schema.get('function'))\n-                and ser_schema.get('type') == 'function-plain'  # type: ignore\n-                and ser_schema.get('info_arg') is False  # type: ignore\n-            ):\n+        if (\n+            self.mode == 'serialization'\n+            and (ser_schema := schema['schema'].get('serialization'))\n+            and (ser_func := ser_schema.get('function'))\n+            and ser_schema.get('type') == 'function-plain'\n+            and not ser_schema.get('info_arg')\n+            and not (default is None and ser_schema.get('when_used') == 'json-unless-none')\n+        ):\n+            try:\n                 default = ser_func(default)  # type: ignore\n+            except Exception:\n+                # It might be that the provided default needs to be validated first\n+                # (assuming `validate_default` is enabled). However, we can't perform\n+                # such validation during JSON Schema generation so we don't support\n+                # this pattern for now.\n+                # (One example is when using `foo: ByteSize = '1MB'`, which validates and\n+                # serializes as an int. In this case, `ser_func` is `int` and `int('1MB')` fails).\n+                self.emit_warning(\n+                    'non-serializable-default',\n+                    f'Unable to serialize value {default!r} with the plain serializer; excluding default from JSON schema',\n+                )\n+                return json_schema",
      "comment": "I don't think it makes sense to do so, or we may end up with a wrong default value in the JSON Schema (in the related test fixed, `'1MB'` was set as the default value in the JSON Schema, but this isn't true as the default is `1000000`). In my opinion, it's better to have no value than a wrong one.\r\n\r\nHowever, we emit a warning here, so I'm ok to call `encode_default`.",
      "comment_id": 1715711152,
      "user": "Viicos",
      "created_at": "2024-08-13T18:00:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/10121#discussion_r1715711152"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10121,
      "file_path": "pydantic/json_schema.py",
      "line": 1069,
      "side": "RIGHT",
      "diff_hunk": "@@ -1043,17 +1043,30 @@ def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaVal\n         #     return json_schema\n \n         # we reflect the application of custom plain, no-info serializers to defaults for\n-        # json schemas viewed in serialization mode\n+        # JSON Schemas viewed in serialization mode:\n         # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208\n-        # TODO: improve type safety here\n-        if self.mode == 'serialization':\n-            if (\n-                (ser_schema := schema['schema'].get('serialization', {}))\n-                and (ser_func := ser_schema.get('function'))\n-                and ser_schema.get('type') == 'function-plain'  # type: ignore\n-                and ser_schema.get('info_arg') is False  # type: ignore\n-            ):\n+        if (\n+            self.mode == 'serialization'\n+            and (ser_schema := schema['schema'].get('serialization'))\n+            and (ser_func := ser_schema.get('function'))\n+            and ser_schema.get('type') == 'function-plain'\n+            and not ser_schema.get('info_arg')\n+            and not (default is None and ser_schema.get('when_used') == 'json-unless-none')\n+        ):\n+            try:\n                 default = ser_func(default)  # type: ignore\n+            except Exception:\n+                # It might be that the provided default needs to be validated first\n+                # (assuming `validate_default` is enabled). However, we can't perform\n+                # such validation during JSON Schema generation so we don't support\n+                # this pattern for now.\n+                # (One example is when using `foo: ByteSize = '1MB'`, which validates and\n+                # serializes as an int. In this case, `ser_func` is `int` and `int('1MB')` fails).\n+                self.emit_warning(\n+                    'non-serializable-default',\n+                    f'Unable to serialize value {default!r} with the plain serializer; excluding default from JSON schema',\n+                )\n+                return json_schema",
      "comment": "That's fair - I wonder if we could use a similar pattern though + attempt to validate the default + include that in the JSON schema. Feels messy to do validation here, I admit.\r\n\r\nI'm not opposed to the warning you have in place, I think that's good!",
      "comment_id": 1715720063,
      "user": "sydney-runkle",
      "created_at": "2024-08-13T18:08:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10121#discussion_r1715720063"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10121,
      "file_path": "pydantic/json_schema.py",
      "line": 1069,
      "side": "RIGHT",
      "diff_hunk": "@@ -1043,17 +1043,30 @@ def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaVal\n         #     return json_schema\n \n         # we reflect the application of custom plain, no-info serializers to defaults for\n-        # json schemas viewed in serialization mode\n+        # JSON Schemas viewed in serialization mode:\n         # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208\n-        # TODO: improve type safety here\n-        if self.mode == 'serialization':\n-            if (\n-                (ser_schema := schema['schema'].get('serialization', {}))\n-                and (ser_func := ser_schema.get('function'))\n-                and ser_schema.get('type') == 'function-plain'  # type: ignore\n-                and ser_schema.get('info_arg') is False  # type: ignore\n-            ):\n+        if (\n+            self.mode == 'serialization'\n+            and (ser_schema := schema['schema'].get('serialization'))\n+            and (ser_func := ser_schema.get('function'))\n+            and ser_schema.get('type') == 'function-plain'\n+            and not ser_schema.get('info_arg')\n+            and not (default is None and ser_schema.get('when_used') == 'json-unless-none')\n+        ):\n+            try:\n                 default = ser_func(default)  # type: ignore\n+            except Exception:\n+                # It might be that the provided default needs to be validated first\n+                # (assuming `validate_default` is enabled). However, we can't perform\n+                # such validation during JSON Schema generation so we don't support\n+                # this pattern for now.\n+                # (One example is when using `foo: ByteSize = '1MB'`, which validates and\n+                # serializes as an int. In this case, `ser_func` is `int` and `int('1MB')` fails).\n+                self.emit_warning(\n+                    'non-serializable-default',\n+                    f'Unable to serialize value {default!r} with the plain serializer; excluding default from JSON schema',\n+                )\n+                return json_schema",
      "comment": "> That's fair - I wonder if we could use a similar pattern though + attempt to validate the default + include that in the JSON schema. Feels messy to do validation here, I admit.\r\n\r\nI think we can do this in a separate PR, if someone asks for it. I'm not keen to go ahead and do this now.\r\n\r\nChange looks good to me, thanks for including the helpful warning.",
      "comment_id": 1717110040,
      "user": "sydney-runkle",
      "created_at": "2024-08-14T15:05:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10121#discussion_r1717110040"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10121,
      "file_path": "pydantic/json_schema.py",
      "line": 1067,
      "side": "RIGHT",
      "diff_hunk": "@@ -1043,17 +1043,30 @@ def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaVal\n         #     return json_schema\n \n         # we reflect the application of custom plain, no-info serializers to defaults for\n-        # json schemas viewed in serialization mode\n+        # JSON Schemas viewed in serialization mode:\n         # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208\n-        # TODO: improve type safety here\n-        if self.mode == 'serialization':\n-            if (\n-                (ser_schema := schema['schema'].get('serialization', {}))\n-                and (ser_func := ser_schema.get('function'))\n-                and ser_schema.get('type') == 'function-plain'  # type: ignore\n-                and ser_schema.get('info_arg') is False  # type: ignore\n-            ):\n+        if (\n+            self.mode == 'serialization'\n+            and (ser_schema := schema['schema'].get('serialization'))\n+            and (ser_func := ser_schema.get('function'))\n+            and ser_schema.get('type') == 'function-plain'\n+            and not ser_schema.get('info_arg')\n+            and not (default is None and ser_schema.get('when_used') == 'json-unless-none')\n+        ):\n+            try:\n                 default = ser_func(default)  # type: ignore\n+            except Exception:\n+                # It might be that the provided default needs to be validated (read: parsed) first\n+                # (assuming `validate_default` is enabled). However, we can't perform\n+                # such validation during JSON Schema generation so we don't support\n+                # this pattern for now.\n+                # (One example is when using `foo: ByteSize = '1MB'`, which validates and\n+                # serializes as an int. In this case, `ser_func` is `int` and `int('1MB')` fails).\n+                self.emit_warning(\n+                    'non-serializable-default',\n+                    f'Unable to serialize value {default!r} with the plain serializer; excluding default from JSON schema',",
      "comment": "One nit, this isn't  always a user defined plain serializer, which might be confusing. We could change the wording of this a bit, but I'm not super worried about it, so will go ahead and merge this.",
      "comment_id": 1717113157,
      "user": "sydney-runkle",
      "created_at": "2024-08-14T15:08:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10121#discussion_r1717113157"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10126,
      "file_path": "pydantic/dataclasses.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,9 +233,10 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             if config_wrapper.frozen:\n                 # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n                 warn(\n-                    f\"`frozen` is set via both the 'dataclass' decorator and `config` for dataclass {cls.__name__}.\"\n+                    f'`frozen` is set via both the `dataclass` decorator and `config` for dataclass {cls.__name__}.'\n                     'This is not recommended. The `frozen` specification on `dataclass` will take priority.',\n-                    UserWarning,\n+                    category=UserWarning,\n+                    stacklevel=3,",
      "comment": "```suggestion\r\n                    stacklevel=2,\r\n```\r\n\r\nTurns out I was wrong, `stacklevel=2` is the right one to have the warning emitted at the correct place :sweat_smile: ",
      "comment_id": 1715716282,
      "user": "Viicos",
      "created_at": "2024-08-13T18:04:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10126#discussion_r1715716282"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10126,
      "file_path": "pydantic/dataclasses.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,9 +233,10 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n             if config_wrapper.frozen:\n                 # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n                 warn(\n-                    f\"`frozen` is set via both the 'dataclass' decorator and `config` for dataclass {cls.__name__}.\"\n+                    f'`frozen` is set via both the `dataclass` decorator and `config` for dataclass {cls.__name__}.'",
      "comment": "```suggestion\r\n                    f'`frozen` is set via both the `dataclass` decorator and `config` for dataclass {cls.__name__!r}.'\r\n```\r\nnitpick, this adds single quotes around the name",
      "comment_id": 1715716692,
      "user": "Viicos",
      "created_at": "2024-08-13T18:05:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10126#discussion_r1715716692"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/config.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,6 +133,8 @@ class User(BaseModel):\n     Whether models are faux-immutable, i.e. whether `__setattr__` is allowed, and also generates\n     a `__hash__()` method for the model. This makes instances of the model potentially hashable if all the\n     attributes are hashable. Defaults to `False`.\n+    It's not recommended to define both `frozen` in the `dataclass` decorator and `ConfigDict`.\n+    If both are defined, the setting from the dataclass decorator will take priority.",
      "comment": "I would move this in the `dataclass` decorator docstring, `ConfigDict` shouldn't know about Pydantic dataclasses imo",
      "comment_id": 1709157573,
      "user": "Viicos",
      "created_at": "2024-08-08T10:21:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1709157573"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/config.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,6 +133,8 @@ class User(BaseModel):\n     Whether models are faux-immutable, i.e. whether `__setattr__` is allowed, and also generates\n     a `__hash__()` method for the model. This makes instances of the model potentially hashable if all the\n     attributes are hashable. Defaults to `False`.\n+    It's not recommended to define both `frozen` in the `dataclass` decorator and `ConfigDict`.\n+    If both are defined, the setting from the dataclass decorator will take priority.",
      "comment": "The current `dataclass` docstring is:\r\n\r\n```\r\nfrozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its\r\n    attributes to be modified after it has been initialized.\r\n```\r\n\r\nwhich I would rephrase as:\r\n\r\n```\r\nfrozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its\r\n    attributes to be modified after it has been initialized. If not set, the value from the provided `config` argument will be used (and will default to `False` otherwise).\r\n```\r\n",
      "comment_id": 1709163993,
      "user": "Viicos",
      "created_at": "2024-08-08T10:24:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1709163993"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,6 +231,12 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         if frozen is not None:\n             frozen_ = frozen\n         else:\n+            # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n+            if config_wrapper.frozen:\n+                warn(\n+                    \"Both 'dataclass' decorator and 'config.frozen' are defined. 'config.frozen' take priority.\",\n+                    UserWarning,\n+                )",
      "comment": "This is not the case with your current implementation. In the `else` branch, `frozen` is guaranteed to be `None` (i.e. not defined), so they can't both be defined.\r\n\r\nImo we shouldn't raise any warning here, as long as we document the behavior.",
      "comment_id": 1709167049,
      "user": "Viicos",
      "created_at": "2024-08-08T10:26:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1709167049"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,6 +231,12 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         if frozen is not None:\n             frozen_ = frozen\n         else:\n+            # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n+            if config_wrapper.frozen:\n+                warn(\n+                    \"Both 'dataclass' decorator and 'config.frozen' are defined. 'config.frozen' take priority.\",\n+                    UserWarning,\n+                )",
      "comment": "I'm inclined to raise a warning here - makes it more likely that folks can figure out the issue on their own + don't open an issue with a question.\r\n\r\nAgreed with @Viicos though, this isn't logically in the right place given the warning.",
      "comment_id": 1709223621,
      "user": "sydney-runkle",
      "created_at": "2024-08-08T10:59:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1709223621"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,6 +231,12 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         if frozen is not None:\n             frozen_ = frozen\n         else:\n+            # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n+            if config_wrapper.frozen:\n+                warn(\n+                    \"Both 'dataclass' decorator and 'config.frozen' are defined. 'config.frozen' take priority.\",\n+                    UserWarning,\n+                )",
      "comment": "To be tested, but let's use `stacklevel=3` here, so that the warning is emitted at the right place (it should emit at the decorator usage)",
      "comment_id": 1709297098,
      "user": "Viicos",
      "created_at": "2024-08-08T11:41:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1709297098"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,6 +231,12 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         if frozen is not None:\n             frozen_ = frozen\n         else:\n+            # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n+            if config_wrapper.frozen:\n+                warn(\n+                    \"Both 'dataclass' decorator and 'config.frozen' are defined. 'config.frozen' take priority.\",\n+                    UserWarning,\n+                )",
      "comment": "> Agreed with @Viicos though, this isn't logically in the right place given the warning.\r\n\r\nI understand that the warning is displayed if config_wrapper.frozen is True, regardless of the value of frozen.\r\nIs my understanding correct?",
      "comment_id": 1712659955,
      "user": "mochi22",
      "created_at": "2024-08-10T15:03:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1712659955"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,6 +231,12 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         if frozen is not None:\n             frozen_ = frozen\n         else:\n+            # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n+            if config_wrapper.frozen:\n+                warn(\n+                    \"Both 'dataclass' decorator and 'config.frozen' are defined. 'config.frozen' take priority.\",\n+                    UserWarning,\n+                )",
      "comment": "We should only display the warning if `frozen` is set in the dataclass constructor, and it's set in `config`.",
      "comment_id": 1712742696,
      "user": "sydney-runkle",
      "created_at": "2024-08-10T21:31:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1712742696"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 241,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,6 +233,13 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         else:\n             frozen_ = config_wrapper.frozen or False\n \n+        # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n+        if frozen is not None and config_wrapper.frozen == True:\n+            warn(\n+                \"Both 'dataclass' decorator and 'config.frozen' are defined. 'config.frozen' take priority.\",\n+                UserWarning,\n+            )",
      "comment": "```suggestion\r\nif frozen is not None:\r\n    frozen_ = frozen\r\n    if config_wrapper.frozen:\r\n        # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\r\n        warn(...)\r\nelse:\r\n    frozen_ = config_wrapper.frozen or False\r\n```\r\n\r\nMaybe?",
      "comment_id": 1712950194,
      "user": "Viicos",
      "created_at": "2024-08-11T09:46:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1712950194"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 238,
      "side": "RIGHT",
      "diff_hunk": "@@ -229,6 +230,12 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         # Respect frozen setting from dataclass constructor and fallback to config setting if not provided\n         if frozen is not None:\n             frozen_ = frozen\n+            if config_wrapper.frozen:\n+                # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n+                warn(\n+                    \"Both 'dataclass' decorator and 'config.frozen' are defined. 'config.frozen' take priority.\",\n+                    UserWarning,\n+                )",
      "comment": "```suggestion\r\n                warn(\r\n                    f\"`frozen` is set via both the 'dataclass' decorator and `config` for dataclass {cls.__name__}.\"\r\n                    \"This is not recommended. The `frozen` specification on `dataclass` will take priority.\",\r\n                    UserWarning,\r\n                )\r\n```",
      "comment_id": 1713844649,
      "user": "sydney-runkle",
      "created_at": "2024-08-12T14:05:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1713844649"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,7 +125,7 @@ def dataclass(\n         order: Determines if comparison magic methods should be generated, such as `__lt__`, but not `__eq__`.\n         unsafe_hash: Determines if a `__hash__` method should be included in the class, as in `dataclasses.dataclass`.\n         frozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its\n-            attributes to be modified after it has been initialized.\n+            attributes to be modified after it has been initialized. If not set, the value from the provided `config` argument will be used (and will default to `False` otherwise).",
      "comment": "It's the other way around - the `dataclass` argument takes priority...",
      "comment_id": 1713844973,
      "user": "sydney-runkle",
      "created_at": "2024-08-12T14:05:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1713844973"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,7 +125,7 @@ def dataclass(\n         order: Determines if comparison magic methods should be generated, such as `__lt__`, but not `__eq__`.\n         unsafe_hash: Determines if a `__hash__` method should be included in the class, as in `dataclasses.dataclass`.\n         frozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its\n-            attributes to be modified after it has been initialized.\n+            attributes to be modified after it has been initialized. If not set, the value from the provided `config` argument will be used (and will default to `False` otherwise).",
      "comment": "It seems the points you mentioned have already been added",
      "comment_id": 1713887452,
      "user": "mochi22",
      "created_at": "2024-08-12T14:27:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1713887452"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10082,
      "file_path": "pydantic/dataclasses.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,7 +125,7 @@ def dataclass(\n         order: Determines if comparison magic methods should be generated, such as `__lt__`, but not `__eq__`.\n         unsafe_hash: Determines if a `__hash__` method should be included in the class, as in `dataclasses.dataclass`.\n         frozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its\n-            attributes to be modified after it has been initialized.\n+            attributes to be modified after it has been initialized. If not set, the value from the provided `config` argument will be used (and will default to `False` otherwise).",
      "comment": "Not sure what you mean - this comment is still incorrect...",
      "comment_id": 1713916253,
      "user": "sydney-runkle",
      "created_at": "2024-08-12T14:41:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/10082#discussion_r1713916253"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "tests/pyright/with_config_decorator.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,17 @@\n+from typing import TypedDict\n+\n+from typing_extensions import assert_type\n+\n+from pydantic import ConfigDict, with_config\n+\n+\n+@with_config(ConfigDict(str_to_lower=True))",
      "comment": "Nice - cool to see this connecting to some of your previous work \ud83d\ude80 ",
      "comment_id": 1712486421,
      "user": "sydney-runkle",
      "created_at": "2024-08-10T02:16:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712486421"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "tests/pyright/type_adapter.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,25 @@\n+from typing import Annotated\n+\n+from typing_extensions import assert_type\n+\n+from pydantic import TypeAdapter\n+\n+ta1 = TypeAdapter(int)\n+assert_type(ta1, TypeAdapter[int])\n+\n+assert_type(ta1.validate_python('1'), int)\n+ta1.dump_python(1)\n+ta1.dump_python('1')  # pyright: ignore[reportArgumentType]\n+ta1.dump_json(1)\n+ta1.dump_json('1')  # pyright: ignore[reportArgumentType]\n+\n+# The following use cases require PEP 747: TypeExpr:",
      "comment": "Nice. Will be great to have this as a reference to update when that PEP is formally adopted \ud83d\udc4d ",
      "comment_id": 1712486846,
      "user": "sydney-runkle",
      "created_at": "2024-08-10T02:17:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712486846"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_validators.py",
      "line": 505,
      "side": "RIGHT",
      "diff_hunk": "@@ -502,7 +502,7 @@ def __call__(  # noqa: D102\n \"\"\"A `@model_validator` decorated function signature. This is used when `mode='after'`.\"\"\"\n \n _AnyModelWrapValidator = Union[ModelWrapValidator[_ModelType], ModelWrapValidatorWithoutInfo[_ModelType]]\n-_AnyModeBeforeValidator = Union[\n+_AnyModelBeforeValidator = Union[",
      "comment": "Good catch - this is confusing bc we do use `mode` as well haha, but `model` is definitely right here.",
      "comment_id": 1712487542,
      "user": "sydney-runkle",
      "created_at": "2024-08-10T02:18:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712487542"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_serializers.py",
      "line": 183,
      "side": "RIGHT",
      "diff_hunk": "@@ -177,55 +177,52 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaH\n \n \n if TYPE_CHECKING:\n-    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any]]\n-    _PlainSerializationFunction = Union[_core_schema.SerializerFunction, _PartialClsOrStaticMethod]\n-    _WrapSerializationFunction = Union[_core_schema.WrapSerializerFunction, _PartialClsOrStaticMethod]\n-    _PlainSerializeMethodType = TypeVar('_PlainSerializeMethodType', bound=_PlainSerializationFunction)\n-    _WrapSerializeMethodType = TypeVar('_WrapSerializeMethodType', bound=_WrapSerializationFunction)\n+    _Partial: TypeAlias = 'partial[Any] | partialmethod[Any]'\n \n+    AnyFieldPlainSerializer: TypeAlias = 'core_schema.SerializerFunction | _Partial'\n+    \"\"\"A field serializer method or function in `plain` mode.\"\"\"",
      "comment": "I really like these changes overall, but I'm a bit hesitant regarding the use of `Any` here as a prefix for these types. Perhaps this might get confusing with the type `Any`... let's brainstorm some alternatives - I don't think `Either` is good...",
      "comment_id": 1712491796,
      "user": "sydney-runkle",
      "created_at": "2024-08-10T02:25:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712491796"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_serializers.py",
      "line": 297,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,35 +279,67 @@ def dec(\n             when_used=when_used,\n             check_fields=check_fields,\n         )\n-        return _decorators.PydanticDescriptorProxy(f, dec_info)\n+        return _decorators.PydanticDescriptorProxy(f, dec_info)  # pyright: ignore[reportArgumentType]\n \n-    return dec\n+    return dec  # pyright: ignore[reportReturnType]\n \n \n-FuncType = TypeVar('FuncType', bound=Callable[..., Any])\n+if TYPE_CHECKING:\n+    # The first argument in the following callables represent the `self` type:\n+\n+    ModelPlainSerializer: TypeAlias = Callable[[Any, SerializationInfo], Any]\n+    \"\"\"A model serializer method with the `info` argument, in `plain` mode.\"\"\"\n+\n+    ModelPlainSerializerWithoutInfo: TypeAlias = Callable[[Any], Any]\n+    \"\"\"A model serializer method without the `info` argument, in `plain` mode.\"\"\"\n+\n+    AnyModelPlainSerializer: TypeAlias = 'ModelPlainSerializer | ModelPlainSerializerWithoutInfo'\n+    \"\"\"A model serializer method in `plain` mode.\"\"\"",
      "comment": "Re my comment above discussing the use of `Any`, what about:\r\n\r\n`ModelPlainSerializerWithInfo`, `ModelPlainSerializerWithoutInfo`, `ModelPlainSerializer`? And a similar pattern above?",
      "comment_id": 1712492756,
      "user": "sydney-runkle",
      "created_at": "2024-08-10T02:27:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712492756"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_serializers.py",
      "line": 284,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,35 +279,67 @@ def dec(\n             when_used=when_used,\n             check_fields=check_fields,\n         )\n-        return _decorators.PydanticDescriptorProxy(f, dec_info)\n+        return _decorators.PydanticDescriptorProxy(f, dec_info)  # pyright: ignore[reportArgumentType]\n \n-    return dec\n+    return dec  # pyright: ignore[reportReturnType]",
      "comment": "Part of the reason I'm wondering if we lost some specificity here...",
      "comment_id": 1712493469,
      "user": "sydney-runkle",
      "created_at": "2024-08-10T02:28:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712493469"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_serializers.py",
      "line": 327,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,35 +279,67 @@ def dec(\n             when_used=when_used,\n             check_fields=check_fields,\n         )\n-        return _decorators.PydanticDescriptorProxy(f, dec_info)\n+        return _decorators.PydanticDescriptorProxy(f, dec_info)  # pyright: ignore[reportArgumentType]\n \n-    return dec\n+    return dec  # pyright: ignore[reportReturnType]\n \n \n-FuncType = TypeVar('FuncType', bound=Callable[..., Any])\n+if TYPE_CHECKING:\n+    # The first argument in the following callables represent the `self` type:\n+\n+    ModelPlainSerializer: TypeAlias = Callable[[Any, SerializationInfo], Any]\n+    \"\"\"A model serializer method with the `info` argument, in `plain` mode.\"\"\"\n+\n+    ModelPlainSerializerWithoutInfo: TypeAlias = Callable[[Any], Any]\n+    \"\"\"A model serializer method without the `info` argument, in `plain` mode.\"\"\"\n+\n+    AnyModelPlainSerializer: TypeAlias = 'ModelPlainSerializer | ModelPlainSerializerWithoutInfo'\n+    \"\"\"A model serializer method in `plain` mode.\"\"\"\n+\n+    ModelWrapSerializer: TypeAlias = Callable[[Any, SerializerFunctionWrapHandler, SerializationInfo], Any]\n+    \"\"\"A model serializer method with the `info` argument, in `wrap` mode.\"\"\"\n+\n+    ModelWrapSerializerWithoutInfo: TypeAlias = Callable[[Any, SerializerFunctionWrapHandler], Any]\n+    \"\"\"A model serializer method without the `info` argument, in `wrap` mode.\"\"\"\n+\n+    AnyModelWrapSerializer: TypeAlias = 'ModelWrapSerializer | ModelWrapSerializerWithoutInfo'\n+    \"\"\"A model serializer method in `wrap` mode.\"\"\"\n+\n+    _AnyModelPlainSerializerT = TypeVar('_AnyModelPlainSerializerT', bound=AnyModelPlainSerializer)\n+    _AnyModelWrapSerializerT = TypeVar('_AnyModelWrapSerializerT', bound=AnyModelWrapSerializer)\n \n \n @overload\n-def model_serializer(__f: FuncType) -> FuncType: ...\n+def model_serializer(f: _AnyModelPlainSerializerT, /) -> _AnyModelPlainSerializerT: ...\n+\n+\n+@overload\n+def model_serializer(\n+    *, mode: Literal['wrap'], when_used: WhenUsed = 'always', return_type: Any = ...\n+) -> Callable[[_AnyModelWrapSerializerT], _AnyModelWrapSerializerT]: ...\n \n \n @overload\n def model_serializer(\n     *,\n-    mode: Literal['plain', 'wrap'] = ...,\n-    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always',\n+    mode: Literal['plain'] = ...,\n+    when_used: WhenUsed = 'always',\n     return_type: Any = ...,",
      "comment": "Definitely a nit pick, but can we use the same format as above (one line for args)",
      "comment_id": 1712494250,
      "user": "sydney-runkle",
      "created_at": "2024-08-10T02:29:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712494250"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_serializers.py",
      "line": 395,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,14 +392,14 @@ def serialize_model(self):\n         The decorator function.\n     \"\"\"\n \n-    def dec(f: Callable[..., Any]) -> _decorators.PydanticDescriptorProxy[Any]:\n+    def dec(f: AnyModelPlainSerializer | AnyModelWrapSerializer) -> _decorators.PydanticDescriptorProxy[Any]:",
      "comment": "\ud83d\udc40  \r\n```py\r\nModelSerializer: TypeAlias = 'AnyModelPlainSerializer | AnyModelWrapSerializer'\r\n```",
      "comment_id": 1712495150,
      "user": "sydney-runkle",
      "created_at": "2024-08-10T02:30:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712495150"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_serializers.py",
      "line": 297,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,35 +279,67 @@ def dec(\n             when_used=when_used,\n             check_fields=check_fields,\n         )\n-        return _decorators.PydanticDescriptorProxy(f, dec_info)\n+        return _decorators.PydanticDescriptorProxy(f, dec_info)  # pyright: ignore[reportArgumentType]\n \n-    return dec\n+    return dec  # pyright: ignore[reportReturnType]\n \n \n-FuncType = TypeVar('FuncType', bound=Callable[..., Any])\n+if TYPE_CHECKING:\n+    # The first argument in the following callables represent the `self` type:\n+\n+    ModelPlainSerializer: TypeAlias = Callable[[Any, SerializationInfo], Any]\n+    \"\"\"A model serializer method with the `info` argument, in `plain` mode.\"\"\"\n+\n+    ModelPlainSerializerWithoutInfo: TypeAlias = Callable[[Any], Any]\n+    \"\"\"A model serializer method without the `info` argument, in `plain` mode.\"\"\"\n+\n+    AnyModelPlainSerializer: TypeAlias = 'ModelPlainSerializer | ModelPlainSerializerWithoutInfo'\n+    \"\"\"A model serializer method in `plain` mode.\"\"\"",
      "comment": "Yep `ModelPlainSerializer` looks good, I'll use this pattern for the other changes as well.",
      "comment_id": 1712946514,
      "user": "Viicos",
      "created_at": "2024-08-11T09:24:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712946514"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_serializers.py",
      "line": 195,
      "side": "LEFT",
      "diff_hunk": "@@ -177,55 +177,52 @@ def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaH\n \n \n if TYPE_CHECKING:\n-    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any]]\n-    _PlainSerializationFunction = Union[_core_schema.SerializerFunction, _PartialClsOrStaticMethod]\n-    _WrapSerializationFunction = Union[_core_schema.WrapSerializerFunction, _PartialClsOrStaticMethod]\n-    _PlainSerializeMethodType = TypeVar('_PlainSerializeMethodType', bound=_PlainSerializationFunction)\n-    _WrapSerializeMethodType = TypeVar('_WrapSerializeMethodType', bound=_WrapSerializationFunction)\n+    _Partial: TypeAlias = 'partial[Any] | partialmethod[Any]'\n \n+    AnyFieldPlainSerializer: TypeAlias = 'core_schema.SerializerFunction | _Partial'\n+    \"\"\"A field serializer method or function in `plain` mode.\"\"\"\n \n-@overload\n-def field_serializer(\n-    field: str,\n-    /,\n-    *fields: str,\n-    return_type: Any = ...,\n-    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = ...,\n-    check_fields: bool | None = ...,\n-) -> Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]: ...",
      "comment": "This overload was used to account for the following usage:\r\n\r\n```python\r\nfrom pydantic import BaseModel, field_serializer\r\n\r\n\r\nclass Model(BaseModel):\r\n    a: int\r\n\r\n    @field_serializer('a')\r\n    ...\r\n```\r\n\r\nthat is, when `mode` wasn't specified (and would default to `'plain'`). But this isn't necessary with the updated overload I added:\r\n\r\n```python\r\n@overload\r\ndef field_serializer(\r\n    field: str,\r\n    /,\r\n    *fields: str,\r\n    mode: Literal['plain'] = ...,\r\n    return_type: Any = ...,\r\n    when_used: WhenUsed = ...,\r\n    check_fields: bool | None = ...,\r\n) -> Callable[[_AnyFieldPlainSerializerT], _AnyFieldPlainSerializerT]: ...\r\n```\r\n\r\nAs type checkers will use this overload when using both `@field_serializer('a')` _and_ `@field_serializer('a', mode='plain')` -- thanks to `mode` being specified as \"optional\" (with a `...` default value).",
      "comment_id": 1712947335,
      "user": "Viicos",
      "created_at": "2024-08-11T09:28:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712947335"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_serializers.py",
      "line": 276,
      "side": "LEFT",
      "diff_hunk": "@@ -273,7 +270,7 @@ def serialize_courses_in_order(self, courses: Set[str]):\n     \"\"\"\n \n     def dec(\n-        f: Callable[..., Any] | staticmethod[Any, Any] | classmethod[Any, Any, Any],",
      "comment": "When type checking the body of `field_serializer`, type checkers will use the signature of that function (they won't use the overloaded signatures).\r\n\r\nPrevious to my changes, the return type was too broad (`Callable[[Any], Any]`). the argument type `Any` would match the type hint of `f` here, and the return type `Any` would also match `PydanticDescriptorProxy[Any]`.\r\n\r\nNothing we can really do here as we lie about the return type because we don't want to expose the `PydanticDescriptorProxy` class.",
      "comment_id": 1712948091,
      "user": "Viicos",
      "created_at": "2024-08-11T09:33:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712948091"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10092,
      "file_path": "pydantic/functional_serializers.py",
      "line": 327,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,35 +279,67 @@ def dec(\n             when_used=when_used,\n             check_fields=check_fields,\n         )\n-        return _decorators.PydanticDescriptorProxy(f, dec_info)\n+        return _decorators.PydanticDescriptorProxy(f, dec_info)  # pyright: ignore[reportArgumentType]\n \n-    return dec\n+    return dec  # pyright: ignore[reportReturnType]\n \n \n-FuncType = TypeVar('FuncType', bound=Callable[..., Any])\n+if TYPE_CHECKING:\n+    # The first argument in the following callables represent the `self` type:\n+\n+    ModelPlainSerializer: TypeAlias = Callable[[Any, SerializationInfo], Any]\n+    \"\"\"A model serializer method with the `info` argument, in `plain` mode.\"\"\"\n+\n+    ModelPlainSerializerWithoutInfo: TypeAlias = Callable[[Any], Any]\n+    \"\"\"A model serializer method without the `info` argument, in `plain` mode.\"\"\"\n+\n+    AnyModelPlainSerializer: TypeAlias = 'ModelPlainSerializer | ModelPlainSerializerWithoutInfo'\n+    \"\"\"A model serializer method in `plain` mode.\"\"\"\n+\n+    ModelWrapSerializer: TypeAlias = Callable[[Any, SerializerFunctionWrapHandler, SerializationInfo], Any]\n+    \"\"\"A model serializer method with the `info` argument, in `wrap` mode.\"\"\"\n+\n+    ModelWrapSerializerWithoutInfo: TypeAlias = Callable[[Any, SerializerFunctionWrapHandler], Any]\n+    \"\"\"A model serializer method without the `info` argument, in `wrap` mode.\"\"\"\n+\n+    AnyModelWrapSerializer: TypeAlias = 'ModelWrapSerializer | ModelWrapSerializerWithoutInfo'\n+    \"\"\"A model serializer method in `wrap` mode.\"\"\"\n+\n+    _AnyModelPlainSerializerT = TypeVar('_AnyModelPlainSerializerT', bound=AnyModelPlainSerializer)\n+    _AnyModelWrapSerializerT = TypeVar('_AnyModelWrapSerializerT', bound=AnyModelWrapSerializer)\n \n \n @overload\n-def model_serializer(__f: FuncType) -> FuncType: ...\n+def model_serializer(f: _AnyModelPlainSerializerT, /) -> _AnyModelPlainSerializerT: ...\n+\n+\n+@overload\n+def model_serializer(\n+    *, mode: Literal['wrap'], when_used: WhenUsed = 'always', return_type: Any = ...\n+) -> Callable[[_AnyModelWrapSerializerT], _AnyModelWrapSerializerT]: ...\n \n \n @overload\n def model_serializer(\n     *,\n-    mode: Literal['plain', 'wrap'] = ...,\n-    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always',\n+    mode: Literal['plain'] = ...,\n+    when_used: WhenUsed = 'always',\n     return_type: Any = ...,",
      "comment": "This was formatted by Ruff (probably because this one is longer: `mode: Literal['plain'] = ...` vs `mode: Literal['wrap']`).",
      "comment_id": 1712948247,
      "user": "Viicos",
      "created_at": "2024-08-11T09:34:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/10092#discussion_r1712948247"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 8710,
      "file_path": "pydantic/functional_validators.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,8 +153,14 @@ class Model(BaseModel):\n     func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n \n     def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n-        schema = handler(source_type)\n-        serialization = core_schema.wrap_serializer_function_ser_schema(function=lambda v, h: h(v), schema=schema)\n+        from pydantic import PydanticSchemaGenerationError",
      "comment": "```suggestion\r\n        # Note that for some valid uses of PlainValidator, it is not possible to generate a core schema for the\r\n        # source_type, so calling `handler(source_type)` will error, which prevents us from generating a proper\r\n        # serialization schema. To work around this for use cases that will not involve serialization, we simply\r\n        # catch any PydanticSchemaGenerationError that may be raised while attempting to build the serialization schema\r\n        # and abort any attempts to handle special serialization.\r\n        from pydantic import PydanticSchemaGenerationError\r\n```",
      "comment_id": 1476505530,
      "user": "dmontagu",
      "created_at": "2024-02-02T18:19:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/8710#discussion_r1476505530"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10064,
      "file_path": "pydantic/config.py",
      "line": 1025,
      "side": "RIGHT",
      "diff_hunk": "@@ -1014,6 +1014,17 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    experimental_fast_build: bool\n+    \"\"\"Build models faster by skipping the logic associated with storing the parent namespace on the model.\n+\n+    Defaults to `False` to maintain backwards compatibility.\n+\n+    !!! warning\n+        If this setting is set to `True`, model schemas for generic typed dicts and named tuples might be incorrect.\n+        There may also be other edge cases where the model schema is incorrect. That being said, this setting has the potential\n+        to speed up schema builds by a factor of 10x in cases with hundreds or thousands of complex models.",
      "comment": "I'd suggest anyone having issues reports this. \r\n\r\nThe ideal case is that this change or it's spiritual successor can become the default - I think we should say that explicitly. ",
      "comment_id": 1705875297,
      "user": "samuelcolvin",
      "created_at": "2024-08-06T17:15:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/10064#discussion_r1705875297"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10064,
      "file_path": "pydantic/config.py",
      "line": 1025,
      "side": "RIGHT",
      "diff_hunk": "@@ -1014,6 +1014,23 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    experimental_fast_build: bool\n+    \"\"\"Build model schemas faster by skipping the logic associated with storing the parent namespace on the model.\n+\n+    Defaults to `False` to maintain backwards compatibility, for now. The ideal case is that this change or it's successor\n+    can become the default. Thus, if you experience issues with this setting that have not already been documented,\n+    please open an issue on GitHub.\n+\n+    !!! warning\n+        If this setting is set to `True`, model schemas for models that involve edge case uses of namespaces, such as",
      "comment": "Could we add unit tests showing which cases have issues when `experimental_fast_build=True`? So asserting the exception where they are given in the problem cases. Then its easier to understand what is the impact of using it. Docs could link to the unit test file showing the issues even.",
      "comment_id": 1705890715,
      "user": "MarkusSintonen",
      "created_at": "2024-08-06T17:30:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/10064#discussion_r1705890715"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10064,
      "file_path": "pydantic/config.py",
      "line": 1025,
      "side": "RIGHT",
      "diff_hunk": "@@ -1014,6 +1014,23 @@ class Model(BaseModel):\n         as the performance difference is minimal if repeated strings are rare.\n     \"\"\"\n \n+    experimental_fast_build: bool\n+    \"\"\"Build model schemas faster by skipping the logic associated with storing the parent namespace on the model.\n+\n+    Defaults to `False` to maintain backwards compatibility, for now. The ideal case is that this change or it's successor\n+    can become the default. Thus, if you experience issues with this setting that have not already been documented,\n+    please open an issue on GitHub.\n+\n+    !!! warning\n+        If this setting is set to `True`, model schemas for models that involve edge case uses of namespaces, such as",
      "comment": "Also would be nice to run some tests with `experimental_fast_build=True` where its expected to work.",
      "comment_id": 1705893780,
      "user": "MarkusSintonen",
      "created_at": "2024-08-06T17:33:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/10064#discussion_r1705893780"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10064,
      "file_path": "tests/test_fast_build.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,216 @@\n+\"\"\"Tests for our experimental.\"\"\"",
      "comment": "```suggestion\r\n\"\"\"Tests for our experimental fast build flag.\"\"\"\r\n```",
      "comment_id": 1706891068,
      "user": "Viicos",
      "created_at": "2024-08-07T12:11:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10064#discussion_r1706891068"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9770,
      "file_path": "tests/test_json.py",
      "line": 507,
      "side": "RIGHT",
      "diff_hunk": "@@ -500,3 +501,45 @@ class A(BaseModel):\n     m = A(a=MyEnum.A, b=[1, 2, 3], c=Decimal('0'))\n     assert m.model_dump_json() == '{\"a\":\"A\",\"b\":\"list!\",\"c\":\"decimal!\"}'\n     assert m.model_dump() == {'a': MyEnum.A, 'b': [1, 2, 3], 'c': Decimal('0')}\n+\n+\n+# Expect failure until pydantic-core is upgraded to include pydantic/pydantic-core#1308.\n+@pytest.mark.xfail",
      "comment": "```suggestion\r\n@pytest.mark.xfail(reason='<something about pydantic-core upgrade>')\r\n```",
      "comment_id": 1659084875,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T17:26:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/9770#discussion_r1659084875"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 282,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,19 +265,23 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        if isinstance(value, typing.ForwardRef):\n+            if is_backport_fixable_error(e):\n+                try:\n+                    from eval_type_backport import eval_type_backport\n+                except ImportError:\n+                    raise TypeError(\n+                        f'You have a type annotation {value.__forward_arg__!r} '\n+                        f'which makes use of newer typing features than are supported in your version of Python. '\n+                        f'To handle this error, you should either remove the use of new syntax '\n+                        f'or install the `eval_type_backport` package.'\n+                    ) from e\n+\n+                return eval_type_backport(value, globalns, localns, try_default=False)\n+\n+            raise TypeError(f'Unable to evaluate type annotation {value.__forward_arg__!r}.') from e",
      "comment": "I'm trying to think of any `TypeError`s that could arise here:\r\n- The ones related to new typing syntax is handled above (meaning https://github.com/pydantic/pydantic/issues/8307 can be closed)\r\n- The original error reported in the issue (making use of generics on a non subscriptable class)\r\n- Any others? If not, we could add a hint to this error message?:\r\n\r\n```suggestion\r\n            raise TypeError(f'Unable to evaluate type annotation {value.__forward_arg__!r}. Perhaps the type being used isn't subscriptable?') from e\r\n```",
      "comment_id": 1701664286,
      "user": "Viicos",
      "created_at": "2024-08-02T10:31:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701664286"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,19 +265,23 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        if isinstance(value, typing.ForwardRef):",
      "comment": "I feel like we haven't exactly preserved the logical flow here - don't we need a `is_backport_fixable_error(e))` check in the case where we jump straight to `raise e`?",
      "comment_id": 1701848333,
      "user": "sydney-runkle",
      "created_at": "2024-08-02T13:26:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701848333"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 282,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,19 +265,23 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        if isinstance(value, typing.ForwardRef):\n+            if is_backport_fixable_error(e):\n+                try:\n+                    from eval_type_backport import eval_type_backport\n+                except ImportError:\n+                    raise TypeError(\n+                        f'You have a type annotation {value.__forward_arg__!r} '\n+                        f'which makes use of newer typing features than are supported in your version of Python. '\n+                        f'To handle this error, you should either remove the use of new syntax '\n+                        f'or install the `eval_type_backport` package.'\n+                    ) from e\n+\n+                return eval_type_backport(value, globalns, localns, try_default=False)\n+\n+            raise TypeError(f'Unable to evaluate type annotation {value.__forward_arg__!r}.') from e",
      "comment": "Nice, we might be able to say this fixes https://github.com/pydantic/pydantic/issues/8307 as well. Let's add this note for now - if someone reports a case where it doesn't make sense, we can further refine from there \ud83d\udc4d ",
      "comment_id": 1701851095,
      "user": "sydney-runkle",
      "created_at": "2024-08-02T13:28:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701851095"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,19 +265,23 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        if isinstance(value, typing.ForwardRef):",
      "comment": "The check is present on line 269, however the `TypeError` message seems to have changed in Python 3.11:\r\n\r\nPython 3.10: `TypeError: 'type' object is not subscriptable`\r\n\r\nPython 3.11+: `TypeError: type 'CustomType' is not subscriptable`\r\n\r\nand `is_backport_fixable_error` matches the first error message. This makes things even harder to manage unfortunately :/",
      "comment_id": 1701872984,
      "user": "Viicos",
      "created_at": "2024-08-02T13:46:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701872984"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,19 +265,23 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        if isinstance(value, typing.ForwardRef):",
      "comment": "In other words, there's no way to distinguish between a `TypeError` when a builtin/stdlib class is used (e.g. `list[int]`, `collections.abc.Sequence[str]`) and other classes that are truly non subscriptable",
      "comment_id": 1701874304,
      "user": "Viicos",
      "created_at": "2024-08-02T13:47:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701874304"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,19 +265,23 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        if isinstance(value, typing.ForwardRef):",
      "comment": "Ah gotcha. I'm ok with this approach then, but let's see what @alexmojaki thinks, as he's pretty well versed in the `eval_type_backport` space.",
      "comment_id": 1701888470,
      "user": "sydney-runkle",
      "created_at": "2024-08-02T13:58:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701888470"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,19 +265,23 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        if isinstance(value, typing.ForwardRef):",
      "comment": "I've pushed some changes which I think is the best we can do",
      "comment_id": 1701907655,
      "user": "Viicos",
      "created_at": "2024-08-02T14:13:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701907655"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 277,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,27 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n-\n-\n-def is_backport_fixable_error(e: TypeError) -> bool:\n-    msg = str(e)\n-    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n+        if isinstance(value, typing.ForwardRef):\n+            try:\n+                from eval_type_backport import eval_type_backport\n+            except ImportError:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. '\n+                    'If you are making use of the new typing syntax (unions using `|` or builtins subscripting), '\n+                    'you should either replace the use of new syntax with the existing `typing` constructs '\n+                    'or install the `eval_type_backport` package. Otherwise, it might be '\n+                    \"that the type being used isn't subscriptable.\"",
      "comment": "Let's incorporate some of this old wording about Python versions:\r\n\r\n```\r\nraise TypeError(\r\n                f'which makes use of newer typing features than are supported in your version of Python. '\r\n            )\r\n```\r\n\r\nOtherwise, this looks good to me. Let's also fix the failing tests bc of the error wording mismatch \ud83d\udc4d ",
      "comment_id": 1701928409,
      "user": "sydney-runkle",
      "created_at": "2024-08-02T14:28:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701928409"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 277,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,27 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n-\n-\n-def is_backport_fixable_error(e: TypeError) -> bool:\n-    msg = str(e)\n-    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n+        if isinstance(value, typing.ForwardRef):\n+            try:\n+                from eval_type_backport import eval_type_backport\n+            except ImportError:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. '\n+                    'If you are making use of the new typing syntax (unions using `|` or builtins subscripting), '\n+                    'you should either replace the use of new syntax with the existing `typing` constructs '\n+                    'or install the `eval_type_backport` package. Otherwise, it might be '\n+                    \"that the type being used isn't subscriptable.\"",
      "comment": "Should we even inject the Python version being used? With sys.version_info or something?",
      "comment_id": 1701928842,
      "user": "sydney-runkle",
      "created_at": "2024-08-02T14:29:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701928842"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 277,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,27 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n-\n-\n-def is_backport_fixable_error(e: TypeError) -> bool:\n-    msg = str(e)\n-    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n+        if isinstance(value, typing.ForwardRef):\n+            try:\n+                from eval_type_backport import eval_type_backport\n+            except ImportError:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. '\n+                    'If you are making use of the new typing syntax (unions using `|` or builtins subscripting), '\n+                    'you should either replace the use of new syntax with the existing `typing` constructs '\n+                    'or install the `eval_type_backport` package. Otherwise, it might be '\n+                    \"that the type being used isn't subscriptable.\"",
      "comment": "Hum I think just mentioning the Python versions introducing the new features is fine?",
      "comment_id": 1701931435,
      "user": "Viicos",
      "created_at": "2024-08-02T14:31:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701931435"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,19 +265,23 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        if isinstance(value, typing.ForwardRef):",
      "comment": "I suggest keeping `is_backport_fixable_error`, and also updating `is_not_subscriptable_error` to check for Python <= 3.8 and `is_unsupported_types_for_union_error` for Python <= 3.9 (double check those Python versions). The newer `type 'CustomType' is not subscriptable` format isn't backport fixable because the backport only applies to old versions. So you can definitely make a better guess about whether it's worth suggesting installing `eval_type_backport`.",
      "comment_id": 1701935936,
      "user": "alexmojaki",
      "created_at": "2024-08-02T14:34:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701935936"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,27 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n-\n-\n-def is_backport_fixable_error(e: TypeError) -> bool:\n-    msg = str(e)\n-    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n+        if isinstance(value, typing.ForwardRef):\n+            try:\n+                from eval_type_backport import eval_type_backport\n+            except ImportError:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                    'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                    'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                    '`typing` constructs or install the `eval_type_backport` package. Otherwise, it might be '\n+                    \"that the type being used isn't subscriptable.\"\n+                ) from e\n+\n+            try:\n+                return eval_type_backport(value, globalns, localns, try_default=False)\n+            except TypeError as e:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. '\n+                    \"It might be that the type being used isn't subscriptable.\"",
      "comment": "I don't think it makes sense to mention the type not being subscriptable. That should already be in the traceback with the full original error message.",
      "comment_id": 1701937973,
      "user": "alexmojaki",
      "created_at": "2024-08-02T14:35:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701937973"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,27 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n-\n-\n-def is_backport_fixable_error(e: TypeError) -> bool:\n-    msg = str(e)\n-    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n+        if isinstance(value, typing.ForwardRef):\n+            try:\n+                from eval_type_backport import eval_type_backport\n+            except ImportError:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                    'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                    'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                    '`typing` constructs or install the `eval_type_backport` package. Otherwise, it might be '\n+                    \"that the type being used isn't subscriptable.\"\n+                ) from e\n+\n+            try:\n+                return eval_type_backport(value, globalns, localns, try_default=False)\n+            except TypeError as e:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. '\n+                    \"It might be that the type being used isn't subscriptable.\"",
      "comment": "Unfortunately only on 3.10+ as I mentioned [here](https://github.com/pydantic/pydantic/pull/10030#discussion_r1701872984) :/ ",
      "comment_id": 1701971157,
      "user": "Viicos",
      "created_at": "2024-08-02T15:00:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701971157"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,27 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n-\n-\n-def is_backport_fixable_error(e: TypeError) -> bool:\n-    msg = str(e)\n-    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n+        if isinstance(value, typing.ForwardRef):\n+            try:\n+                from eval_type_backport import eval_type_backport\n+            except ImportError:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                    'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                    'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                    '`typing` constructs or install the `eval_type_backport` package. Otherwise, it might be '\n+                    \"that the type being used isn't subscriptable.\"\n+                ) from e\n+\n+            try:\n+                return eval_type_backport(value, globalns, localns, try_default=False)\n+            except TypeError as e:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. '\n+                    \"It might be that the type being used isn't subscriptable.\"",
      "comment": "So doing something like this on 3.8/3.9:\r\n\r\n```python\r\nfrom __future__ import annotations\r\n\r\nclass CustomType:\r\n    pass\r\n\r\nclass Model(BaseModel):\r\n    foo: CustomType[int]\r\n```\r\n\r\nis quite hard to debug, as you only get `TypeError: 'type' object is not subscriptable`",
      "comment_id": 1701972890,
      "user": "Viicos",
      "created_at": "2024-08-02T15:02:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1701972890"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 285,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,27 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n-\n-        return eval_type_backport(value, globalns, localns, try_default=False)\n-\n-\n-def is_backport_fixable_error(e: TypeError) -> bool:\n-    msg = str(e)\n-    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n+        if isinstance(value, typing.ForwardRef):\n+            try:\n+                from eval_type_backport import eval_type_backport\n+            except ImportError:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                    'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                    'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                    '`typing` constructs or install the `eval_type_backport` package. Otherwise, it might be '\n+                    \"that the type being used isn't subscriptable.\"\n+                ) from e\n+\n+            try:\n+                return eval_type_backport(value, globalns, localns, try_default=False)\n+            except TypeError as e:\n+                raise TypeError(\n+                    f'Unable to evaluate type annotation {value.__forward_arg__!r}. '\n+                    \"It might be that the type being used isn't subscriptable.\"",
      "comment": "But you will still have `Unable to evaluate type annotation 'CustomType[int]'`.",
      "comment_id": 1702017927,
      "user": "alexmojaki",
      "created_at": "2024-08-02T15:37:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1702017927"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,38 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n+        if isinstance(value, typing.ForwardRef):\n+            if is_backport_fixable_error(e):\n+                try:\n+                    from eval_type_backport import eval_type_backport\n+                except ImportError:\n+                    raise TypeError(\n+                        f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                        'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                        'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                        '`typing` constructs or install the `eval_type_backport` package. Otherwise, it might be '\n+                        \"that the type being used isn't subscriptable.\"\n+                    ) from e\n+\n+                return eval_type_backport(value, globalns, localns, try_default=False)\n+\n             raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n+                f'Unable to evaluate type annotation {value.__forward_arg__!r}. '\n+                \"It might be that the type being used isn't subscriptable.\"\n             ) from e\n \n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        raise e\n \n \n def is_backport_fixable_error(e: TypeError) -> bool:\n     msg = str(e)\n-    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n+\n+    return (\n+        sys.version_info <= (3, 8)\n+        and msg.startswith('unsupported operand type(s) for |: ')\n+        or sys.version_info <= (3, 9)\n+        and \"' object is not subscriptable\" in msg",
      "comment": "These versions look backwards, and that `<=` looks wrong.\r\n\r\n```\r\n\u279c  ~ python3.9                                        \r\nPython 3.9.19 (main, Aug  2 2024, 16:30:42) \r\n[Clang 15.0.0 (clang-1500.3.9.4)] on darwin\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> int | str\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: unsupported operand type(s) for |: 'type' and 'type'\r\n>>> list[int]\r\nlist[int]\r\n>>> import sys\r\n>>> sys.version_info\r\nsys.version_info(major=3, minor=9, micro=19, releaselevel='final', serial=0)\r\n>>> tuple(sys.version_info)\r\n(3, 9, 19, 'final', 0)\r\n>>> sys.version_info <= (3, 9)\r\nFalse\r\n>>> (3, 8, 0) <= (3, 8)\r\nFalse\r\n```",
      "comment_id": 1702074028,
      "user": "alexmojaki",
      "created_at": "2024-08-02T16:29:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1702074028"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,38 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n+        if isinstance(value, typing.ForwardRef):\n+            if is_backport_fixable_error(e):\n+                try:\n+                    from eval_type_backport import eval_type_backport\n+                except ImportError:\n+                    raise TypeError(\n+                        f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                        'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                        'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                        '`typing` constructs or install the `eval_type_backport` package. Otherwise, it might be '\n+                        \"that the type being used isn't subscriptable.\"\n+                    ) from e\n+\n+                return eval_type_backport(value, globalns, localns, try_default=False)\n+\n             raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n+                f'Unable to evaluate type annotation {value.__forward_arg__!r}. '\n+                \"It might be that the type being used isn't subscriptable.\"\n             ) from e\n \n-        return eval_type_backport(value, globalns, localns, try_default=False)\n+        raise e\n \n \n def is_backport_fixable_error(e: TypeError) -> bool:\n     msg = str(e)\n-    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n+\n+    return (\n+        sys.version_info <= (3, 8)\n+        and msg.startswith('unsupported operand type(s) for |: ')\n+        or sys.version_info <= (3, 9)\n+        and \"' object is not subscriptable\" in msg",
      "comment": "Indeed comparing with `<=` is confusing.\r\n\r\nAs a side note, I've raised https://github.com/microsoft/pyright/discussions/8648.",
      "comment_id": 1703159257,
      "user": "Viicos",
      "created_at": "2024-08-04T11:47:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1703159257"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 280,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,34 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n+        if isinstance(value, typing.ForwardRef):\n+            if is_backport_fixable_error(e):\n+                try:\n+                    from eval_type_backport import eval_type_backport\n+                except ImportError:\n+                    raise TypeError(\n+                        f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                        'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                        'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                        '`typing` constructs or install the `eval_type_backport` package.'\n+                    ) from e\n+\n+                return eval_type_backport(value, globalns, localns, try_default=False)",
      "comment": "On Python 3.8, we will still have the unclear `TypeError: 'type' object is not subscriptable`. We could add yet another try/expect block but this starts to really hurt readability here.",
      "comment_id": 1703716650,
      "user": "Viicos",
      "created_at": "2024-08-05T08:14:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1703716650"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 280,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,34 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n+        if isinstance(value, typing.ForwardRef):\n+            if is_backport_fixable_error(e):\n+                try:\n+                    from eval_type_backport import eval_type_backport\n+                except ImportError:\n+                    raise TypeError(\n+                        f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                        'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                        'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                        '`typing` constructs or install the `eval_type_backport` package.'\n+                    ) from e\n+\n+                return eval_type_backport(value, globalns, localns, try_default=False)",
      "comment": "@Viicos I suggested `except Exception` in `eval_type_with_helpful_errors` so that there would be helpful notes for other errors. We're seeing a mysterious `NameError: name 'Dict' is not defined` and we don't know where it's coming from. The final code in the PR is still only catching `TypeError` so no note is added.",
      "comment_id": 1705728394,
      "user": "alexmojaki",
      "created_at": "2024-08-06T15:20:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1705728394"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 280,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,34 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n+        if isinstance(value, typing.ForwardRef):\n+            if is_backport_fixable_error(e):\n+                try:\n+                    from eval_type_backport import eval_type_backport\n+                except ImportError:\n+                    raise TypeError(\n+                        f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                        'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                        'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                        '`typing` constructs or install the `eval_type_backport` package.'\n+                    ) from e\n+\n+                return eval_type_backport(value, globalns, localns, try_default=False)",
      "comment": "The thing is `eval_type_backport` is used by `eval_type_lenient` (defined above), and is the one responsible for catching (and not erroring) `NameError`s",
      "comment_id": 1705733278,
      "user": "Viicos",
      "created_at": "2024-08-06T15:23:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1705733278"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10030,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 280,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,24 +265,34 @@ def eval_type_backport(\n                 value, globalns, localns\n             )\n     except TypeError as e:\n-        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n-            raise\n-        try:\n-            from eval_type_backport import eval_type_backport\n-        except ImportError:\n-            raise TypeError(\n-                f'You have a type annotation {value.__forward_arg__!r} '\n-                f'which makes use of newer typing features than are supported in your version of Python. '\n-                f'To handle this error, you should either remove the use of new syntax '\n-                f'or install the `eval_type_backport` package.'\n-            ) from e\n+        if isinstance(value, typing.ForwardRef):\n+            if is_backport_fixable_error(e):\n+                try:\n+                    from eval_type_backport import eval_type_backport\n+                except ImportError:\n+                    raise TypeError(\n+                        f'Unable to evaluate type annotation {value.__forward_arg__!r}. If you are making use '\n+                        'of the new typing syntax (unions using `|` since Python 3.10 or builtins subscripting '\n+                        'since Python 3.9), you should either replace the use of new syntax with the existing '\n+                        '`typing` constructs or install the `eval_type_backport` package.'\n+                    ) from e\n+\n+                return eval_type_backport(value, globalns, localns, try_default=False)",
      "comment": "But `eval_type_lenient` is not the only place that calls `eval_type_backport`, so NameError can still bubble up.\r\n\r\n`raise type(e)(message) from e` should work.",
      "comment_id": 1705743690,
      "user": "alexmojaki",
      "created_at": "2024-08-06T15:30:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/10030#discussion_r1705743690"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10058,
      "file_path": "pydantic/fields.py",
      "line": 431,
      "side": "LEFT",
      "diff_hunk": "@@ -424,11 +424,6 @@ def merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -> FieldInfo:\n         Returns:\n             FieldInfo: A merged FieldInfo instance.\n         \"\"\"\n-        flattened_field_infos: list[FieldInfo] = []\n-        for field_info in field_infos:\n-            flattened_field_infos.extend(x for x in field_info.metadata if isinstance(x, FieldInfo))\n-            flattened_field_infos.append(field_info)\n-        field_infos = tuple(flattened_field_infos)",
      "comment": "Perhaps I'm missing something, but I'm not understanding the case where we'd need this (and no tests are breaking with this change).",
      "comment_id": 1704833243,
      "user": "sydney-runkle",
      "created_at": "2024-08-06T02:39:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/10058#discussion_r1704833243"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10058,
      "file_path": "pydantic/fields.py",
      "line": 431,
      "side": "LEFT",
      "diff_hunk": "@@ -424,11 +424,6 @@ def merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -> FieldInfo:\n         Returns:\n             FieldInfo: A merged FieldInfo instance.\n         \"\"\"\n-        flattened_field_infos: list[FieldInfo] = []\n-        for field_info in field_infos:\n-            flattened_field_infos.extend(x for x in field_info.metadata if isinstance(x, FieldInfo))\n-            flattened_field_infos.append(field_info)\n-        field_infos = tuple(flattened_field_infos)",
      "comment": "This still seems right to me:\r\n\r\n```py\r\nfrom pydantic import BaseModel, Field\r\nfrom typing_extensions import Annotated\r\n\r\nclass Model(BaseModel):\r\n    a: Annotated[int, Field(..., description='hi there'), Field(..., alias='A')]\r\n    b: Annotated[str, Field(..., description='hi there'), Field(..., alias='B')] = Field(..., frozen=True)\r\n\r\nprint(Model.model_fields)\r\n\"\"\"\r\n{\r\n    'a': FieldInfo(annotation=int, required=True, alias='A', alias_priority=2, description='hi there'), \r\n    'b': FieldInfo(annotation=str, required=True, alias='B', alias_priority=2, description='hi there', frozen=True)\r\n}\r\n\"\"\"\r\n```",
      "comment_id": 1704837496,
      "user": "sydney-runkle",
      "created_at": "2024-08-06T02:46:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/10058#discussion_r1704837496"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10058,
      "file_path": "pydantic/fields.py",
      "line": 431,
      "side": "LEFT",
      "diff_hunk": "@@ -424,11 +424,6 @@ def merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -> FieldInfo:\n         Returns:\n             FieldInfo: A merged FieldInfo instance.\n         \"\"\"\n-        flattened_field_infos: list[FieldInfo] = []\n-        for field_info in field_infos:\n-            flattened_field_infos.extend(x for x in field_info.metadata if isinstance(x, FieldInfo))\n-            flattened_field_infos.append(field_info)\n-        field_infos = tuple(flattened_field_infos)",
      "comment": "hmmm, I also didn't get why we need these codes and why we don't have any breaking tests after this change.\r\n\r\nWould be great to ask someone else for reviewing this part.",
      "comment_id": 1705055321,
      "user": "hramezani",
      "created_at": "2024-08-06T07:35:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10058#discussion_r1705055321"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10058,
      "file_path": "pydantic/fields.py",
      "line": 431,
      "side": "LEFT",
      "diff_hunk": "@@ -424,11 +424,6 @@ def merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -> FieldInfo:\n         Returns:\n             FieldInfo: A merged FieldInfo instance.\n         \"\"\"\n-        flattened_field_infos: list[FieldInfo] = []\n-        for field_info in field_infos:\n-            flattened_field_infos.extend(x for x in field_info.metadata if isinstance(x, FieldInfo))\n-            flattened_field_infos.append(field_info)\n-        field_infos = tuple(flattened_field_infos)",
      "comment": "I've tried looking at many places in the `FieldInfo` code to see if we could hit such a path, but couldn't find any for now. However, I realize the code is quite messy, and may be inconsistent in some places (e.g. the part you removed) even if things still work (there's also some code duplication). I wonder if we could simplify things here.",
      "comment_id": 1705097709,
      "user": "Viicos",
      "created_at": "2024-08-06T08:07:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/10058#discussion_r1705097709"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10006,
      "file_path": "pydantic/functional_serializers.py",
      "line": 350,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,6 +339,16 @@ def serialize_model(self):\n \n     See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.\n \n+    Two signatures are supported for `mode='plain'`, which is the default:\n+\n+    - `(self)`\n+    - `(self, info: SerializationInfo)`\n+\n+    And two other signatures for `mode='wrap'`:\n+\n+    - `(self, nxt: SerializerFunctionWrapHandler)`\n+    - `(self, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`",
      "comment": "```suggestion\r\n    Two signatures are supported for `mode='plain'`, which is the default:\r\n\r\n    - `(self)`\r\n    - `(self, info: SerializationInfo)`\r\n\r\n    And two other signatures for `mode='wrap'`:\r\n\r\n    - `(self, nxt: SerializerFunctionWrapHandler)`\r\n    - `(self, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\r\n\r\n        See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.\r\n```",
      "comment_id": 1701896607,
      "user": "sydney-runkle",
      "created_at": "2024-08-02T14:04:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/10006#discussion_r1701896607"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10018,
      "file_path": "pydantic/_internal/_serializers.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,49 @@\n+import collections",
      "comment": "I feel like we should have `from __future__ import annotations` everywhere here",
      "comment_id": 1700621261,
      "user": "adriangb",
      "created_at": "2024-08-01T18:19:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/10018#discussion_r1700621261"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10013,
      "file_path": "pydantic/_internal/_import_utils.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,30 @@\n+from importlib import import_module\n+from typing import Any, Dict, Tuple\n+\n+\n+class CachedImportManager:\n+    def __init__(self) -> None:\n+        self._attr_cache: Dict[Tuple[str, str], Any] = {}\n+        self._module_cache: Dict[str, Any] = {}\n+\n+    def get_attr(self, attr_name: str, module_name: str) -> Any:",
      "comment": "Maybe I should switch the order of the params for a more intuitive feel?",
      "comment_id": 1700390283,
      "user": "sydney-runkle",
      "created_at": "2024-08-01T15:24:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/10013#discussion_r1700390283"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10009,
      "file_path": "pydantic/__init__.py",
      "line": 402,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,10 +399,13 @@ def __getattr__(attr_name: str) -> object:\n     from importlib import import_module\n \n     if module_name == '__module__':\n-        return import_module(f'.{attr_name}', package=package)\n+        result = import_module(f'.{attr_name}', package=package)",
      "comment": "```suggestion\r\n        result = import_module(f'.{attr_name}', package=package)\r\n        globals()[attr_name] = result\r\n        return result\r\n```",
      "comment_id": 1698946575,
      "user": "dmontagu",
      "created_at": "2024-07-31T18:36:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/10009#discussion_r1698946575"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10009,
      "file_path": "pydantic/__init__.py",
      "line": 405,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,10 +399,13 @@ def __getattr__(attr_name: str) -> object:\n     from importlib import import_module\n \n     if module_name == '__module__':\n-        return import_module(f'.{attr_name}', package=package)\n+        result = import_module(f'.{attr_name}', package=package)\n     else:\n         module = import_module(module_name, package=package)\n-        return getattr(module, attr_name)\n+        result = getattr(module, attr_name)",
      "comment": "```suggestion\r\n        result = getattr(module, attr_name)\r\n        g = globals()\r\n        for k, v in module.__dict__:\r\n            if not k.startswith('_'):\r\n                g[k] = v\r\n        return result\r\n```",
      "comment_id": 1698947599,
      "user": "dmontagu",
      "created_at": "2024-07-31T18:37:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/10009#discussion_r1698947599"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 10009,
      "file_path": "pydantic/__init__.py",
      "line": 405,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,10 +399,13 @@ def __getattr__(attr_name: str) -> object:\n     from importlib import import_module\n \n     if module_name == '__module__':\n-        return import_module(f'.{attr_name}', package=package)\n+        result = import_module(f'.{attr_name}', package=package)\n     else:\n         module = import_module(module_name, package=package)\n-        return getattr(module, attr_name)\n+        result = getattr(module, attr_name)",
      "comment": "This would ensure we don't re-import the module for everything we grab for it; this could be relevant e.g. if a user's app uses a lot of stuff defined in `pydantic.types` but imported from `pydantic`, I think.",
      "comment_id": 1698948241,
      "user": "dmontagu",
      "created_at": "2024-07-31T18:37:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/10009#discussion_r1698948241"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9999,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -260,7 +262,9 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n                 schema,\n             )\n         else:\n-            raise RuntimeError(f'Unable to apply constraint {constraint} to schema {schema_type}')\n+            # It's rare that we'd get here, but it's possible if we add a new constraint and forget to handle it\n+            # Most constraint errors are caught at runtime during attempted application\n+            raise ValueError(f\"Unable to apply constraint '{constraint}' to schema of type '{schema_type}'\")",
      "comment": "I do think `RuntimeError` is the right thing here, but not a big deal",
      "comment_id": 1698403889,
      "user": "adriangb",
      "created_at": "2024-07-31T12:12:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/9999#discussion_r1698403889"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9990,
      "file_path": "pydantic/networks.py",
      "line": 550,
      "side": "RIGHT",
      "diff_hunk": "@@ -546,118 +546,120 @@ def __str__(self) -> str:\n         return f'{self.name} <{self.email}>'\n \n \n-class IPvAnyAddress:\n-    \"\"\"Validate an IPv4 or IPv6 address.\n-\n-    ```py\n-    from pydantic import BaseModel\n-    from pydantic.networks import IPvAnyAddress\n+IPvAnyAddressType: TypeAlias = 'IPv4Address | IPv6Address'\n+IPvAnyInterfaceType: TypeAlias = 'IPv4Interface |IPv6Interface '",
      "comment": "```suggestion\r\nIPvAnyInterfaceType: TypeAlias = 'IPv4Interface | IPv6Interface'\r\n```",
      "comment_id": 1697198122,
      "user": "sydney-runkle",
      "created_at": "2024-07-30T15:48:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/9990#discussion_r1697198122"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9950,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 175,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,8 @@ def apply_each_item_validators(\n     field_name: str | None,\n ) -> core_schema.CoreSchema:\n     # This V1 compatibility shim should eventually be removed\n+    if not each_item_validators:\n+        return schema",
      "comment": "```suggestion\r\n\r\n    # fail early if each_item_validators is empty\r\n    if not each_item_validators:\r\n        return schema\r\n```",
      "comment_id": 1689979987,
      "user": "sydney-runkle",
      "created_at": "2024-07-24T15:01:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/9950#discussion_r1689979987"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9950,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 175,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,8 @@ def apply_each_item_validators(\n     field_name: str | None,\n ) -> core_schema.CoreSchema:\n     # This V1 compatibility shim should eventually be removed\n+    if not each_item_validators:\n+        return schema",
      "comment": "I felt like this needed some clarification / space from the above comment, which referred to the function as a whole, but became ambiguous with this addition.",
      "comment_id": 1689980714,
      "user": "sydney-runkle",
      "created_at": "2024-07-24T15:01:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/9950#discussion_r1689980714"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9950,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 175,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,8 @@ def apply_each_item_validators(\n     field_name: str | None,\n ) -> core_schema.CoreSchema:\n     # This V1 compatibility shim should eventually be removed\n+    if not each_item_validators:\n+        return schema",
      "comment": "Or we can even omit the comment bc the behavior is clear, but at least add a line between this and the comment above",
      "comment_id": 1689986810,
      "user": "sydney-runkle",
      "created_at": "2024-07-24T15:05:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/9950#discussion_r1689986810"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9971,
      "file_path": "tests/test_dataclasses.py",
      "line": 2950,
      "side": "RIGHT",
      "diff_hunk": "@@ -2944,3 +2944,29 @@ class Y:\n         x: Union[X, None]\n \n     assert Y(x={'y': None}).x.y is None\n+\n+@pytest.mark.parametrize(\"field_fn_unset\", [Field, dataclasses.field])\n+@pytest.mark.parametrize(\"field_fn2\", [Field, dataclasses.field])\n+def test_annotated_with_field_default_factory( field_fn_unset, field_fn2) -> None:",
      "comment": "Without entering into the details of the fix, perhaps you might want to call `make format` to let `ruff` fix formatting for you...",
      "comment_id": 1691165212,
      "user": "AlessandroMiola",
      "created_at": "2024-07-25T09:49:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/9971#discussion_r1691165212"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9971,
      "file_path": "tests/test_dataclasses.py",
      "line": 2957,
      "side": "RIGHT",
      "diff_hunk": "@@ -2944,3 +2944,29 @@ class Y:\n         x: Union[X, None]\n \n     assert Y(x={'y': None}).x.y is None\n+\n+@pytest.mark.parametrize(\"field_fn_unset\", [Field, dataclasses.field])\n+@pytest.mark.parametrize(\"field_fn2\", [Field, dataclasses.field])\n+def test_annotated_with_field_default_factory( field_fn_unset, field_fn2) -> None:\n+    \"\"\"\n+    https://github.com/pydantic/pydantic/issues/9947\n+    \"\"\"\n+\n+    # wrap in lambda to create new instance for different fields\n+    field1 =lambda: pydantic.Field(default_factory=lambda: 1)  # `Annotated` only works with pydantic field\n+    field2 = lambda:field_fn2(default_factory=lambda: 2)",
      "comment": "Same as above, `make format` might be worth a call.",
      "comment_id": 1691166647,
      "user": "AlessandroMiola",
      "created_at": "2024-07-25T09:50:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/9971#discussion_r1691166647"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9971,
      "file_path": "tests/test_dataclasses.py",
      "line": 2950,
      "side": "RIGHT",
      "diff_hunk": "@@ -2944,3 +2944,29 @@ class Y:\n         x: Union[X, None]\n \n     assert Y(x={'y': None}).x.y is None\n+\n+@pytest.mark.parametrize(\"field_fn_unset\", [Field, dataclasses.field])\n+@pytest.mark.parametrize(\"field_fn2\", [Field, dataclasses.field])\n+def test_annotated_with_field_default_factory( field_fn_unset, field_fn2) -> None:",
      "comment": "I did run the `make format` command, but weirdly I only got the following output:\r\n```\r\nPDM, version 2.17.1\r\npdm run ruff check --fix pydantic tests docs/plugins\r\nAll checks passed!\r\npdm run ruff format pydantic tests docs/plugins\r\n87 files left unchanged\r\n```\r\nIt does not format the unformatted test file, so I have to explicitly format it: \r\n```\r\n$ pdm run ruff format .\\tests\\test_dataclasses.pytaclasses.py  test_datetime.py\r\n1 file reformatted                              \r\n```\r\nIt does work for files under `pydantic/` though.\r\n",
      "comment_id": 1691217255,
      "user": "kc0506",
      "created_at": "2024-07-25T10:24:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/9971#discussion_r1691217255"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9971,
      "file_path": "tests/test_dataclasses.py",
      "line": 2950,
      "side": "RIGHT",
      "diff_hunk": "@@ -2944,3 +2944,29 @@ class Y:\n         x: Union[X, None]\n \n     assert Y(x={'y': None}).x.y is None\n+\n+@pytest.mark.parametrize(\"field_fn_unset\", [Field, dataclasses.field])\n+@pytest.mark.parametrize(\"field_fn2\", [Field, dataclasses.field])\n+def test_annotated_with_field_default_factory( field_fn_unset, field_fn2) -> None:",
      "comment": "Interesting \ud83e\udd14 might be worth a check IMO as `pdm run ruff format pydantic tests docs/plugins` does consider `tests`.\r\n",
      "comment_id": 1691376289,
      "user": "AlessandroMiola",
      "created_at": "2024-07-25T12:41:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/9971#discussion_r1691376289"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9971,
      "file_path": "pydantic/fields.py",
      "line": 491,
      "side": "RIGHT",
      "diff_hunk": "@@ -491,7 +491,7 @@ def _from_dataclass_field(dc_field: DataclassField[Any]) -> FieldInfo:\n             default = PydanticUndefined",
      "comment": "Can we make this `_Unset` for consistency as well?",
      "comment_id": 1691427556,
      "user": "sydney-runkle",
      "created_at": "2024-07-25T13:17:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/9971#discussion_r1691427556"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9971,
      "file_path": "tests/test_dataclasses.py",
      "line": 2958,
      "side": "RIGHT",
      "diff_hunk": "@@ -2944,3 +2944,30 @@ class Y:\n         x: Union[X, None]\n \n     assert Y(x={'y': None}).x.y is None\n+\n+\n+@pytest.mark.parametrize('field_fn_unset', [Field, dataclasses.field])\n+@pytest.mark.parametrize('field_fn2', [Field, dataclasses.field])\n+def test_annotated_with_field_default_factory(field_fn_unset, field_fn2) -> None:\n+    \"\"\"\n+    https://github.com/pydantic/pydantic/issues/9947\n+    \"\"\"\n+\n+    # wrap in lambda to create new instance for different fields\n+    field1 = lambda: pydantic.Field(default_factory=lambda: 1)  # `Annotated` only works with pydantic field\n+    field2 = lambda: field_fn2(default_factory=lambda: 2)",
      "comment": "Regarding ease of understanding, this pattern makes it a bit hard to digest for this tests. The cases that we're testing are simple enough and limited enough that I'd prefer we just explicitly test them all, ex: \r\n\r\n```py\r\na: Annotated[int, pydantic.Field(default_factory=lambda: 1)\r\n```\r\n\r\nIt might be a bit more verbose at the end, but it's easier to understand quickly!",
      "comment_id": 1691434152,
      "user": "sydney-runkle",
      "created_at": "2024-07-25T13:21:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/9971#discussion_r1691434152"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9977,
      "file_path": "tests/test_types.py",
      "line": 1815,
      "side": "RIGHT",
      "diff_hunk": "@@ -1806,6 +1806,13 @@ class Foo(BaseModel):\n             a: type_ = Field('foo', title='A title', description='A description', **kwargs)\n \n \n+@pytest.mark.xfail(\n+    reason=(\n+        \"We allow python validation functions to wrap the type if the constraint isn't valid for the type. \"\n+        \"An error isn't raised for an int or float annotated with this same invalid constraint, \"\n+        \"so it's ok to mark this as xfail for now, but we should improve all of them in the future.\"\n+    )\n+)",
      "comment": "FWIW I do think we could special case something like `Annotated[float, Field(max_len=10)]` to raise an error at schema building time. If we're 100% sure the constraint makes no sense we can raise an error. But in the case of `Annoated[float, AfterValidator(...), Field(max_len=10)]` or whatever that we can't.",
      "comment_id": 1691883538,
      "user": "adriangb",
      "created_at": "2024-07-25T17:43:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/9977#discussion_r1691883538"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9977,
      "file_path": "tests/test_types.py",
      "line": 1815,
      "side": "RIGHT",
      "diff_hunk": "@@ -1806,6 +1806,13 @@ class Foo(BaseModel):\n             a: type_ = Field('foo', title='A title', description='A description', **kwargs)\n \n \n+@pytest.mark.xfail(\n+    reason=(\n+        \"We allow python validation functions to wrap the type if the constraint isn't valid for the type. \"\n+        \"An error isn't raised for an int or float annotated with this same invalid constraint, \"\n+        \"so it's ok to mark this as xfail for now, but we should improve all of them in the future.\"\n+    )\n+)",
      "comment": "Agreed, I think that should be addressed in a different PR though \ud83d\udc4d ",
      "comment_id": 1691884176,
      "user": "sydney-runkle",
      "created_at": "2024-07-25T17:44:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/9977#discussion_r1691884176"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9949,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 648,
      "side": "RIGHT",
      "diff_hunk": "@@ -642,13 +642,11 @@ def _unpack_refs_defs(self, schema: CoreSchema) -> CoreSchema:\n         \"\"\"Unpack all 'definitions' schemas into `GenerateSchema.defs.definitions`\n         and return the inner schema.\n         \"\"\"\n-\n-        def get_ref(s: CoreSchema) -> str:\n-            return s['ref']  # type: ignore\n-\n         if schema['type'] == 'definitions':\n-            self.defs.definitions.update({get_ref(s): s for s in schema['definitions']})\n-            schema = schema['schema']\n+            definitions = self.defs.definitions\n+            for s in schema['definitions']:\n+                definitions[s['ref']] = s",
      "comment": "```suggestion\r\n                definitions[s['ref']] = s  # type: ignore\r\n```",
      "comment_id": 1689994272,
      "user": "sydney-runkle",
      "created_at": "2024-07-24T15:09:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/9949#discussion_r1689994272"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9949,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 648,
      "side": "RIGHT",
      "diff_hunk": "@@ -642,13 +642,11 @@ def _unpack_refs_defs(self, schema: CoreSchema) -> CoreSchema:\n         \"\"\"Unpack all 'definitions' schemas into `GenerateSchema.defs.definitions`\n         and return the inner schema.\n         \"\"\"\n-\n-        def get_ref(s: CoreSchema) -> str:\n-            return s['ref']  # type: ignore\n-\n         if schema['type'] == 'definitions':\n-            self.defs.definitions.update({get_ref(s): s for s in schema['definitions']})\n-            schema = schema['schema']\n+            definitions = self.defs.definitions\n+            for s in schema['definitions']:\n+                definitions[s['ref']] = s",
      "comment": "Similar issue to the one mentioned on the previous PR, though this was already handled above with a type ignore so I feel fine about reusing here",
      "comment_id": 1689995327,
      "user": "sydney-runkle",
      "created_at": "2024-07-24T15:10:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/9949#discussion_r1689995327"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9896,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1499,
      "side": "RIGHT",
      "diff_hunk": "@@ -1473,6 +1475,31 @@ def _type_schema(self) -> core_schema.CoreSchema:\n             custom_error_message='Input should be a type',\n         )\n \n+    def _zoneinfo_schema(self) -> core_schema.CoreSchema:\n+        \"\"\"Generate schema for a zone_info.ZoneInfo object\"\"\"\n+        # we're def >=py3.9 if ZoneInfo was included in input\n+        if sys.version_info < (3, 9):\n+            assert False, 'Unreachable'\n+\n+        # import in this path is safe\n+        from zoneinfo import ZoneInfo, ZoneInfoNotFoundError\n+\n+        def validate_str_is_valid_iana_tz(value: Any, /) -> ZoneInfo:\n+            if isinstance(value, ZoneInfo):\n+                return value\n+            try:\n+                return ZoneInfo(value)\n+            except (ZoneInfoNotFoundError, ValueError):\n+                raise PydanticCustomError('zoneinfo_str', 'invalid timezone: {value}', {'value': value})\n+\n+        ser = core_schema.plain_serializer_function_ser_schema(lambda instance: str(instance), when_used='json')\n+        metadata = build_metadata_dict(js_functions=[lambda _1, _2: {'type': 'string', 'format': 'zoneinfo'}])\n+        return core_schema.no_info_plain_validator_function(\n+            validate_str_is_valid_iana_tz,\n+            serialization=ser,",
      "comment": "Looks good, I think we have a utility for simple serialization like this, like simple str or something like that",
      "comment_id": 1686702795,
      "user": "sydney-runkle",
      "created_at": "2024-07-22T14:59:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/9896#discussion_r1686702795"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9932,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1485,
      "side": "RIGHT",
      "diff_hunk": "@@ -1481,6 +1481,8 @@ def _union_is_subclass_schema(self, union_type: Any) -> core_schema.CoreSchema:\n     def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n         \"\"\"Generate schema for a Type, e.g. `Type[int]`.\"\"\"\n         type_param = self._get_first_arg_or_any(type_)\n+        # Assume `type[Annotated[<typ>, ...]]` is equivalent to `type[<typ>]`:\n+        type_param = _typing_extra.annotated_type(type_param) or type_param",
      "comment": "@adriangb, are you ok with this assumption?\r\n\r\nIf so, then I'm happy to move forward with this PR. Thanks @Viicos!",
      "comment_id": 1686468174,
      "user": "sydney-runkle",
      "created_at": "2024-07-22T12:27:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/9932#discussion_r1686468174"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/transform_experimental.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,506 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"",
      "comment": "What if we add an `experimental` module within `pydantic`, then we could have the warning take effect when anything is imported from said module? I think that'll offer additional flexibility as we continue with this pattern for new / experimental features.\r\n\r\nSomething like: `from pydantic.experimental.transform import parse, parse_defer`\r\n\r\nOne lingering question that this leaves me with is what to do about experimental features that we include as new flags, arguments, etc. For example, we recently added an experimental flag in https://github.com/pydantic/pydantic/pull/8939 that uses a leading underscore to signify its volatility. \r\n\r\nI can also see the argument for the simple `experimental_` prefix. That's what [streamlit](https://docs.streamlit.io/develop/quick-reference/prerelease) does, and it seems to be a system that works well.\r\n\r\nAnywho, curious to hear your thoughts. @davidhewitt, I'd like to get your opinion on this subject as well!",
      "comment_id": 1610174415,
      "user": "sydney-runkle",
      "created_at": "2024-05-22T15:07:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1610174415"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/transform_experimental.py",
      "line": 353,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,506 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import re\n+from collections import deque\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property\n+from typing import TYPE_CHECKING, Annotated, Any, Callable, Generic, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    re.Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> Validate[_InT, _NewOutT]:\n+        return Validate[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    @overload\n+    def parse(self, tp: type[_NewOutT], *, strict: bool = ...) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    @overload\n+    def parse(self, *, strict: bool = ...) -> Validate[_InT, Any]:\n+        ...\n+\n+    def parse(self, tp: Any = ..., *, strict: bool = False) -> Validate[_InT, Any]:\n+        \"\"\"Parse the input into a new type.\n+\n+        If not type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+        \"\"\"\n+        return Validate[_InT, Any](self._steps + [_Parse(tp, strict=strict)])\n+\n+    def parse_defer(self, func: Callable[[], type[_NewOutT]]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return Validate[_InT, _NewOutT](self._steps + [_ParseDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGe], constraint: annotated_types.Ge) -> Validate[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGt], constraint: annotated_types.Gt) -> Validate[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLe], constraint: annotated_types.Le) -> Validate[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLt], constraint: annotated_types.Lt) -> Validate[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLen], constraint: annotated_types.Len) -> Validate[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> Validate[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _OutT], constraint: annotated_types.Predicate) -> Validate[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> Validate[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutT], constraint: re.Pattern[str]) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\"\"\"\n+        return Validate[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def pattern(self: Validate[_InT, str], pattern: str) -> Validate[_InT, str]:\n+        \"\"\"Constrain a string to match a regular expression pattern.\"\"\"\n+        return self.constrain(re.compile(pattern))\n+\n+    def gt(self: Validate[_InT, _NewOutGt], gt: _NewOutGt) -> Validate[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: Validate[_InT, _NewOutLt], lt: _NewOutLt) -> Validate[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: Validate[_InT, _NewOutGe], ge: _NewOutGe) -> Validate[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: Validate[_InT, _NewOutLe], le: _NewOutLe) -> Validate[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: Validate[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> Validate[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: Validate[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> Validate[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: Validate[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    # timezone methods\n+    def tz_naive(\n+        self: Validate[_InT, _NewOutDatetime],\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        \"\"\"Constrain a datetime to be timezone naive.\"\"\"\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def tz_aware(\n+        self: Validate[_InT, _NewOutDatetime],\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        \"\"\"Constrain a datetime to be timezone aware.\"\"\"\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def tz(self: Validate[_InT, _NewOutDatetime], tz: datetime.tzinfo) -> Validate[_InT, _NewOutDatetime]:\n+        \"\"\"Constrain a datetime to have a certain timezone.\"\"\"\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore  # TODO: what's wrong with the typing here?\n+\n+    # string methods\n+    def lower(self: Validate[_InT, _NewOutStr]) -> Validate[_InT, str]:\n+        \"\"\"Transform a string to lowercase.\"\"\"\n+        return self.transform(str.lower)\n+\n+    def upper(self: Validate[_InT, _NewOutStr]) -> Validate[_InT, str]:\n+        \"\"\"Transform a string to uppercase.\"\"\"\n+        return self.transform(str.upper)\n+\n+    def title(self: Validate[_InT, _NewOutStr]) -> Validate[_InT, str]:\n+        \"\"\"Transform a string to title case.\"\"\"\n+        return self.transform(str.title)\n+\n+    def strip(self: Validate[_InT, _NewOutStr]) -> Validate[_InT, str]:\n+        \"\"\"Strip whitespace from a string.\"\"\"\n+        return self.transform(str.strip)\n+\n+    # operators\n+    def otherwise(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return Validate([_ValidateOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return Validate([_ValidateAnd(self, other)])\n+\n+    __and__ = then\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> cs.CoreSchema:\n+        from pydantic_core import core_schema as cs\n+\n+        queue = deque(self._steps)\n+\n+        s = None\n+\n+        while queue:\n+            step = queue.popleft()\n+            s = _apply_step(step, s, handler, source_type)\n+\n+        s = s or cs.any_schema()\n+        return s\n+\n+\n+parse = Validate[Any, Any]([]).parse\n+parse_defer = Validate[Any, Any]([]).parse_defer\n+transform = Validate[Any, Any]([]).transform\n+constrain = Validate[Any, Any]([]).constrain\n+\n+\n+def _check_func(\n+    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    def handler(v: Any) -> Any:\n+        if func(v):\n+            return v\n+        raise ValueError(f'Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}')\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(handler)\n+    else:\n+        return cs.no_info_after_validator_function(handler, s)\n+\n+\n+def _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if isinstance(step, _Parse):\n+        s = _apply_parse(s, step.tp, step.strict, handler, source_type)\n+    elif isinstance(step, _ParseDefer):\n+        s = _apply_parse(s, step.tp, False, handler, source_type)\n+    elif isinstance(step, _Transform):\n+        s = _apply_transform(s, step.func)\n+    elif isinstance(step, _Constraint):\n+        s = _apply_constraint(s, step.constraint)\n+    elif isinstance(step, _ValidateOr):\n+        s = cs.union_schema([handler(step.left), handler(step.right)])\n+    else:\n+        assert isinstance(step, _ValidateAnd)\n+        s = cs.chain_schema([handler(step.left), handler(step.right)])\n+    return s\n+\n+\n+def _apply_parse(\n+    s: cs.CoreSchema | None,\n+    tp: type[Any],\n+    strict: bool,\n+    handler: GetCoreSchemaHandler,\n+    source_type: Any,\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import Strict\n+\n+    if tp is ...:\n+        return handler(source_type)\n+\n+    if strict:\n+        tp = Annotated[tp, Strict()]  # type: ignore\n+\n+    if s and s['type'] == 'any':\n+        return handler(tp)\n+    else:\n+        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)\n+\n+\n+def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(func)\n+\n+    if s['type'] == 'str':\n+        if func is str.strip:\n+            s = s.copy()\n+            s['strip_whitespace'] = True\n+            return s\n+        elif func is str.lower:\n+            s = s.copy()\n+            s['to_lower'] = True\n+            return s\n+        elif func is str.upper:\n+            s = s.copy()\n+            s['to_upper'] = True\n+            return s\n+    return cs.no_info_after_validator_function(func, s)\n+\n+\n+def _apply_constraint(  # noqa: C901\n+    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation\n+) -> cs.CoreSchema:\n+    if isinstance(constraint, annotated_types.Gt):",
      "comment": "Could be interesting to think about supporting this case as well https://github.com/pydantic/pydantic/issues/9472",
      "comment_id": 1610209219,
      "user": "sydney-runkle",
      "created_at": "2024-05-22T15:27:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1610209219"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/transform_experimental.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,506 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import re\n+from collections import deque\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property\n+from typing import TYPE_CHECKING, Annotated, Any, Callable, Generic, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    re.Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):",
      "comment": "Very cool and interesting pattern here. I appreciate the cleanliness of the code and the documentation of major methods, etc - made things quite easy to follow.\r\n\r\nI have 2 structural questions:\r\n1. Is there a better way for us to organize the schema application private functions? Not sure if a class based approach would make more sense here, but just something to think about. Ultimately, do we want to build support for this into the `_generate_schema.py` monolith? What would that look like, and how could we smoothly do that?\r\n2. There are a lot of functions that are members of the same category - like str methods, things like that. Right now obviously we've just covered the basic types and transformations, so things aren't super bloated, but I think we should consider potential blowup when we expand to more types in the future. We could use other classes to help categorize these transformations, but that makes accessing such methods more verbose, which goes directly against the intent of this pipeline system.",
      "comment_id": 1610223803,
      "user": "sydney-runkle",
      "created_at": "2024-05-22T15:37:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1610223803"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/transform_experimental.py",
      "line": 217,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,506 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import re\n+from collections import deque\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property\n+from typing import TYPE_CHECKING, Annotated, Any, Callable, Generic, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    re.Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> Validate[_InT, _NewOutT]:\n+        return Validate[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    @overload\n+    def parse(self, tp: type[_NewOutT], *, strict: bool = ...) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    @overload\n+    def parse(self, *, strict: bool = ...) -> Validate[_InT, Any]:\n+        ...\n+\n+    def parse(self, tp: Any = ..., *, strict: bool = False) -> Validate[_InT, Any]:\n+        \"\"\"Parse the input into a new type.\n+\n+        If not type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+        \"\"\"\n+        return Validate[_InT, Any](self._steps + [_Parse(tp, strict=strict)])\n+\n+    def parse_defer(self, func: Callable[[], type[_NewOutT]]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return Validate[_InT, _NewOutT](self._steps + [_ParseDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGe], constraint: annotated_types.Ge) -> Validate[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGt], constraint: annotated_types.Gt) -> Validate[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLe], constraint: annotated_types.Le) -> Validate[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLt], constraint: annotated_types.Lt) -> Validate[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLen], constraint: annotated_types.Len) -> Validate[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> Validate[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _OutT], constraint: annotated_types.Predicate) -> Validate[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> Validate[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutT], constraint: re.Pattern[str]) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\"\"\"\n+        return Validate[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def pattern(self: Validate[_InT, str], pattern: str) -> Validate[_InT, str]:\n+        \"\"\"Constrain a string to match a regular expression pattern.\"\"\"\n+        return self.constrain(re.compile(pattern))\n+\n+    def gt(self: Validate[_InT, _NewOutGt], gt: _NewOutGt) -> Validate[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: Validate[_InT, _NewOutLt], lt: _NewOutLt) -> Validate[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: Validate[_InT, _NewOutGe], ge: _NewOutGe) -> Validate[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: Validate[_InT, _NewOutLe], le: _NewOutLe) -> Validate[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: Validate[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> Validate[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: Validate[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> Validate[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: Validate[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    # timezone methods\n+    def tz_naive(\n+        self: Validate[_InT, _NewOutDatetime],\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        \"\"\"Constrain a datetime to be timezone naive.\"\"\"\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def tz_aware(\n+        self: Validate[_InT, _NewOutDatetime],\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        \"\"\"Constrain a datetime to be timezone aware.\"\"\"\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def tz(self: Validate[_InT, _NewOutDatetime], tz: datetime.tzinfo) -> Validate[_InT, _NewOutDatetime]:\n+        \"\"\"Constrain a datetime to have a certain timezone.\"\"\"\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore  # TODO: what's wrong with the typing here?",
      "comment": "No overloads for \"constrain\" match the provided arguments",
      "comment_id": 1610801651,
      "user": "adriangb",
      "created_at": "2024-05-23T00:04:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1610801651"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/transform_experimental.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,506 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import re\n+from collections import deque\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property\n+from typing import TYPE_CHECKING, Annotated, Any, Callable, Generic, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    re.Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):",
      "comment": "Marking as resolved given the new namespace changes!",
      "comment_id": 1618795901,
      "user": "sydney-runkle",
      "created_at": "2024-05-29T12:27:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1618795901"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/transform_experimental.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,506 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import re\n+from collections import deque\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property\n+from typing import TYPE_CHECKING, Annotated, Any, Callable, Generic, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    re.Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')",
      "comment": "Yes this is the output type, which gets passed on as the input to the next transformation.",
      "comment_id": 1620471326,
      "user": "adriangb",
      "created_at": "2024-05-30T10:52:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1620471326"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/transform_experimental.py",
      "line": 353,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,506 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import re\n+from collections import deque\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property\n+from typing import TYPE_CHECKING, Annotated, Any, Callable, Generic, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    re.Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> Validate[_InT, _NewOutT]:\n+        return Validate[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    @overload\n+    def parse(self, tp: type[_NewOutT], *, strict: bool = ...) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    @overload\n+    def parse(self, *, strict: bool = ...) -> Validate[_InT, Any]:\n+        ...\n+\n+    def parse(self, tp: Any = ..., *, strict: bool = False) -> Validate[_InT, Any]:\n+        \"\"\"Parse the input into a new type.\n+\n+        If not type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+        \"\"\"\n+        return Validate[_InT, Any](self._steps + [_Parse(tp, strict=strict)])\n+\n+    def parse_defer(self, func: Callable[[], type[_NewOutT]]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return Validate[_InT, _NewOutT](self._steps + [_ParseDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGe], constraint: annotated_types.Ge) -> Validate[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGt], constraint: annotated_types.Gt) -> Validate[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLe], constraint: annotated_types.Le) -> Validate[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLt], constraint: annotated_types.Lt) -> Validate[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLen], constraint: annotated_types.Len) -> Validate[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> Validate[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _OutT], constraint: annotated_types.Predicate) -> Validate[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> Validate[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutT], constraint: re.Pattern[str]) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\"\"\"\n+        return Validate[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def pattern(self: Validate[_InT, str], pattern: str) -> Validate[_InT, str]:\n+        \"\"\"Constrain a string to match a regular expression pattern.\"\"\"\n+        return self.constrain(re.compile(pattern))\n+\n+    def gt(self: Validate[_InT, _NewOutGt], gt: _NewOutGt) -> Validate[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: Validate[_InT, _NewOutLt], lt: _NewOutLt) -> Validate[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: Validate[_InT, _NewOutGe], ge: _NewOutGe) -> Validate[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: Validate[_InT, _NewOutLe], le: _NewOutLe) -> Validate[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: Validate[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> Validate[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: Validate[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> Validate[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: Validate[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    # timezone methods\n+    def tz_naive(\n+        self: Validate[_InT, _NewOutDatetime],\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        \"\"\"Constrain a datetime to be timezone naive.\"\"\"\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def tz_aware(\n+        self: Validate[_InT, _NewOutDatetime],\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        \"\"\"Constrain a datetime to be timezone aware.\"\"\"\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def tz(self: Validate[_InT, _NewOutDatetime], tz: datetime.tzinfo) -> Validate[_InT, _NewOutDatetime]:\n+        \"\"\"Constrain a datetime to have a certain timezone.\"\"\"\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore  # TODO: what's wrong with the typing here?\n+\n+    # string methods\n+    def lower(self: Validate[_InT, _NewOutStr]) -> Validate[_InT, str]:\n+        \"\"\"Transform a string to lowercase.\"\"\"\n+        return self.transform(str.lower)\n+\n+    def upper(self: Validate[_InT, _NewOutStr]) -> Validate[_InT, str]:\n+        \"\"\"Transform a string to uppercase.\"\"\"\n+        return self.transform(str.upper)\n+\n+    def title(self: Validate[_InT, _NewOutStr]) -> Validate[_InT, str]:\n+        \"\"\"Transform a string to title case.\"\"\"\n+        return self.transform(str.title)\n+\n+    def strip(self: Validate[_InT, _NewOutStr]) -> Validate[_InT, str]:\n+        \"\"\"Strip whitespace from a string.\"\"\"\n+        return self.transform(str.strip)\n+\n+    # operators\n+    def otherwise(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return Validate([_ValidateOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return Validate([_ValidateAnd(self, other)])\n+\n+    __and__ = then\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> cs.CoreSchema:\n+        from pydantic_core import core_schema as cs\n+\n+        queue = deque(self._steps)\n+\n+        s = None\n+\n+        while queue:\n+            step = queue.popleft()\n+            s = _apply_step(step, s, handler, source_type)\n+\n+        s = s or cs.any_schema()\n+        return s\n+\n+\n+parse = Validate[Any, Any]([]).parse\n+parse_defer = Validate[Any, Any]([]).parse_defer\n+transform = Validate[Any, Any]([]).transform\n+constrain = Validate[Any, Any]([]).constrain\n+\n+\n+def _check_func(\n+    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    def handler(v: Any) -> Any:\n+        if func(v):\n+            return v\n+        raise ValueError(f'Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}')\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(handler)\n+    else:\n+        return cs.no_info_after_validator_function(handler, s)\n+\n+\n+def _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if isinstance(step, _Parse):\n+        s = _apply_parse(s, step.tp, step.strict, handler, source_type)\n+    elif isinstance(step, _ParseDefer):\n+        s = _apply_parse(s, step.tp, False, handler, source_type)\n+    elif isinstance(step, _Transform):\n+        s = _apply_transform(s, step.func)\n+    elif isinstance(step, _Constraint):\n+        s = _apply_constraint(s, step.constraint)\n+    elif isinstance(step, _ValidateOr):\n+        s = cs.union_schema([handler(step.left), handler(step.right)])\n+    else:\n+        assert isinstance(step, _ValidateAnd)\n+        s = cs.chain_schema([handler(step.left), handler(step.right)])\n+    return s\n+\n+\n+def _apply_parse(\n+    s: cs.CoreSchema | None,\n+    tp: type[Any],\n+    strict: bool,\n+    handler: GetCoreSchemaHandler,\n+    source_type: Any,\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import Strict\n+\n+    if tp is ...:\n+        return handler(source_type)\n+\n+    if strict:\n+        tp = Annotated[tp, Strict()]  # type: ignore\n+\n+    if s and s['type'] == 'any':\n+        return handler(tp)\n+    else:\n+        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)\n+\n+\n+def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(func)\n+\n+    if s['type'] == 'str':\n+        if func is str.strip:\n+            s = s.copy()\n+            s['strip_whitespace'] = True\n+            return s\n+        elif func is str.lower:\n+            s = s.copy()\n+            s['to_lower'] = True\n+            return s\n+        elif func is str.upper:\n+            s = s.copy()\n+            s['to_upper'] = True\n+            return s\n+    return cs.no_info_after_validator_function(func, s)\n+\n+\n+def _apply_constraint(  # noqa: C901\n+    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation\n+) -> cs.CoreSchema:\n+    if isinstance(constraint, annotated_types.Gt):",
      "comment": "That will \"just work: here: just like the PR that ended up closing that issue we support anything that `SupportsGt`.",
      "comment_id": 1620472687,
      "user": "adriangb",
      "created_at": "2024-05-30T10:53:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1620472687"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "tests/test_docs.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,6 +166,7 @@ def set_cwd():\n \n \n @pytest.mark.filterwarnings('ignore:(parse_obj_as|schema_json_of|schema_of) is deprecated.*:DeprecationWarning')\n+@pytest.mark.filterwarnings('ignore:This functionality is experimental:UserWarning')",
      "comment": "It could be worth documenting this interaction with pytest & warnings (and runtime) if users are actually wanting to use it for anything more than scripts.",
      "comment_id": 1620604476,
      "user": "davidhewitt",
      "created_at": "2024-05-30T12:19:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1620604476"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "tests/test_transform.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+\"\"\"Tests for the experimental transform module.\"\"\"\n+\n+from typing import Optional\n+\n+import pytest\n+from typing_extensions import Annotated\n+\n+from pydantic import TypeAdapter, ValidationError\n+from pydantic.transform_experimental import parse\n+\n+\n+@pytest.mark.parametrize('potato_variation', ['potato', ' potato ', ' potato', 'potato ', ' POTATO ', ' PoTatO '])\n+def test_parse_str(potato_variation: str) -> None:\n+    ta_lower = TypeAdapter(Annotated[str, parse(str).str.strip().str.lower()])\n+    assert ta_lower.validate_python(potato_variation) == 'potato'\n+\n+\n+def test_parse_str_with_pattern() -> None:\n+    ta_pattern = TypeAdapter(Annotated[str, parse(str).str.pattern(r'[a-z]+')])\n+    assert ta_pattern.validate_python('potato') == 'potato'\n+    with pytest.raises(ValueError):\n+        ta_pattern.validate_python('POTATO')\n+\n+\n+@pytest.mark.parametrize(\n+    'method, method_arg, input_string, expected_output',\n+    [\n+        # transforms\n+        ('lower', None, 'POTATO', 'potato'),\n+        ('upper', None, 'potato', 'POTATO'),\n+        ('title', None, 'potato potato', 'Potato Potato'),\n+        ('strip', None, ' potato ', 'potato'),\n+        # constraints\n+        ('pattern', r'[a-z]+', 'potato', 'potato'),  # check lowercase\n+        # predicates\n+        ('contains', 'pot', 'potato', 'potato'),\n+        ('starts_with', 'pot', 'potato', 'potato'),\n+        ('ends_with', 'ato', 'potato', 'potato'),\n+    ],\n+)\n+def test_string_validator_valid(method: str, method_arg: Optional[str], input_string: str, expected_output: str):\n+    # annotated metadata is equivalent to parse(str).str.method(method_arg)\n+    # ex: parse(str).str.contains('pot')\n+    annotated_metadata = getattr(parse(str).str, method)\n+    annotated_metadata = annotated_metadata(method_arg) if method_arg else annotated_metadata()\n+\n+    ta = TypeAdapter(Annotated[str, annotated_metadata])\n+    assert ta.validate_python(input_string) == expected_output\n+\n+\n+def test_string_validator_invalid() -> None:\n+    ta_contains = TypeAdapter(Annotated[str, parse(str).str.contains('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_contains.validate_python('tomato')\n+\n+    ta_starts_with = TypeAdapter(Annotated[str, parse(str).str.starts_with('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_starts_with.validate_python('tomato')\n+\n+    ta_ends_with = TypeAdapter(Annotated[str, parse(str).str.ends_with('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_ends_with.validate_python('tomato')\n+\n+\n+def test_parse_int() -> None:\n+    ta_gt = TypeAdapter(Annotated[int, parse(int).gt(0)])\n+    assert ta_gt.validate_python(1) == 1\n+    assert ta_gt.validate_python('1') == 1\n+    with pytest.raises(ValidationError):\n+        ta_gt.validate_python(0)\n+\n+    ta_gt_strict = TypeAdapter(Annotated[int, parse(int, strict=True).gt(0)])\n+    assert ta_gt_strict.validate_python(1) == 1\n+    with pytest.raises(ValidationError):\n+        ta_gt_strict.validate_python('1')\n+    with pytest.raises(ValidationError):\n+        ta_gt_strict.validate_python(0)\n+\n+\n+def test_parse_str_to_int() -> None:\n+    ta = TypeAdapter(Annotated[int, parse(str).str.strip().parse(int)])\n+    assert ta.validate_python('1') == 1\n+    assert ta.validate_python(' 1 ') == 1\n+    with pytest.raises(ValidationError):\n+        ta.validate_python('a')\n+\n+\n+def test_predicates() -> None:\n+    ta_int = TypeAdapter(Annotated[int, parse(int).predicate(lambda x: x % 2 == 0)])\n+    assert ta_int.validate_python(2) == 2\n+    with pytest.raises(ValidationError):\n+        ta_int.validate_python(1)\n+\n+    ta_str = TypeAdapter(Annotated[str, parse(str).predicate(lambda x: x != 'potato')])",
      "comment": "Is this possible?\r\n\r\n```suggestion\r\n    ta_str = TypeAdapter(Annotated[str, parse(str).ne('potato')])\r\n```",
      "comment_id": 1620612572,
      "user": "davidhewitt",
      "created_at": "2024-05-30T12:24:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1620612572"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "tests/test_transform.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+\"\"\"Tests for the experimental transform module.\"\"\"\n+\n+from typing import Optional\n+\n+import pytest\n+from typing_extensions import Annotated\n+\n+from pydantic import TypeAdapter, ValidationError\n+from pydantic.transform_experimental import parse\n+\n+\n+@pytest.mark.parametrize('potato_variation', ['potato', ' potato ', ' potato', 'potato ', ' POTATO ', ' PoTatO '])\n+def test_parse_str(potato_variation: str) -> None:\n+    ta_lower = TypeAdapter(Annotated[str, parse(str).str.strip().str.lower()])\n+    assert ta_lower.validate_python(potato_variation) == 'potato'\n+\n+\n+def test_parse_str_with_pattern() -> None:\n+    ta_pattern = TypeAdapter(Annotated[str, parse(str).str.pattern(r'[a-z]+')])\n+    assert ta_pattern.validate_python('potato') == 'potato'\n+    with pytest.raises(ValueError):\n+        ta_pattern.validate_python('POTATO')\n+\n+\n+@pytest.mark.parametrize(\n+    'method, method_arg, input_string, expected_output',\n+    [\n+        # transforms\n+        ('lower', None, 'POTATO', 'potato'),\n+        ('upper', None, 'potato', 'POTATO'),\n+        ('title', None, 'potato potato', 'Potato Potato'),\n+        ('strip', None, ' potato ', 'potato'),\n+        # constraints\n+        ('pattern', r'[a-z]+', 'potato', 'potato'),  # check lowercase\n+        # predicates\n+        ('contains', 'pot', 'potato', 'potato'),\n+        ('starts_with', 'pot', 'potato', 'potato'),\n+        ('ends_with', 'ato', 'potato', 'potato'),\n+    ],\n+)\n+def test_string_validator_valid(method: str, method_arg: Optional[str], input_string: str, expected_output: str):\n+    # annotated metadata is equivalent to parse(str).str.method(method_arg)\n+    # ex: parse(str).str.contains('pot')\n+    annotated_metadata = getattr(parse(str).str, method)\n+    annotated_metadata = annotated_metadata(method_arg) if method_arg else annotated_metadata()\n+\n+    ta = TypeAdapter(Annotated[str, annotated_metadata])\n+    assert ta.validate_python(input_string) == expected_output\n+\n+\n+def test_string_validator_invalid() -> None:\n+    ta_contains = TypeAdapter(Annotated[str, parse(str).str.contains('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_contains.validate_python('tomato')\n+\n+    ta_starts_with = TypeAdapter(Annotated[str, parse(str).str.starts_with('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_starts_with.validate_python('tomato')\n+\n+    ta_ends_with = TypeAdapter(Annotated[str, parse(str).str.ends_with('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_ends_with.validate_python('tomato')\n+\n+\n+def test_parse_int() -> None:\n+    ta_gt = TypeAdapter(Annotated[int, parse(int).gt(0)])\n+    assert ta_gt.validate_python(1) == 1\n+    assert ta_gt.validate_python('1') == 1\n+    with pytest.raises(ValidationError):\n+        ta_gt.validate_python(0)\n+\n+    ta_gt_strict = TypeAdapter(Annotated[int, parse(int, strict=True).gt(0)])\n+    assert ta_gt_strict.validate_python(1) == 1\n+    with pytest.raises(ValidationError):\n+        ta_gt_strict.validate_python('1')\n+    with pytest.raises(ValidationError):\n+        ta_gt_strict.validate_python(0)\n+\n+\n+def test_parse_str_to_int() -> None:\n+    ta = TypeAdapter(Annotated[int, parse(str).str.strip().parse(int)])\n+    assert ta.validate_python('1') == 1\n+    assert ta.validate_python(' 1 ') == 1\n+    with pytest.raises(ValidationError):\n+        ta.validate_python('a')\n+\n+\n+def test_predicates() -> None:\n+    ta_int = TypeAdapter(Annotated[int, parse(int).predicate(lambda x: x % 2 == 0)])\n+    assert ta_int.validate_python(2) == 2\n+    with pytest.raises(ValidationError):\n+        ta_int.validate_python(1)\n+\n+    ta_str = TypeAdapter(Annotated[str, parse(str).predicate(lambda x: x != 'potato')])",
      "comment": "Oh yeah, I like the idea of materializing some common predicates like this",
      "comment_id": 1620656287,
      "user": "sydney-runkle",
      "created_at": "2024-05-30T12:49:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1620656287"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "tests/test_docs.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,6 +166,7 @@ def set_cwd():\n \n \n @pytest.mark.filterwarnings('ignore:(parse_obj_as|schema_json_of|schema_of) is deprecated.*:DeprecationWarning')\n+@pytest.mark.filterwarnings('ignore:This functionality is experimental:UserWarning')",
      "comment": "I think this falls into the general \"experimental\" category. How about we make a `PydanticExperimental` warning and document that @sydney-runkle ?",
      "comment_id": 1620698457,
      "user": "adriangb",
      "created_at": "2024-05-30T13:16:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1620698457"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "tests/test_docs.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,6 +166,7 @@ def set_cwd():\n \n \n @pytest.mark.filterwarnings('ignore:(parse_obj_as|schema_json_of|schema_of) is deprecated.*:DeprecationWarning')\n+@pytest.mark.filterwarnings('ignore:This functionality is experimental:UserWarning')",
      "comment": "That sounds good to me! I can do that if you'd like!",
      "comment_id": 1621054688,
      "user": "sydney-runkle",
      "created_at": "2024-05-30T16:28:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1621054688"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/transform_experimental.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,506 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"",
      "comment": "Resolving this comment, I'm going to write some docs about our approach going forward.",
      "comment_id": 1621057468,
      "user": "sydney-runkle",
      "created_at": "2024-05-30T16:30:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1621057468"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "tests/test_transform.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+\"\"\"Tests for the experimental transform module.\"\"\"\n+\n+from typing import Optional\n+\n+import pytest\n+from typing_extensions import Annotated\n+\n+from pydantic import TypeAdapter, ValidationError\n+from pydantic.transform_experimental import parse\n+\n+\n+@pytest.mark.parametrize('potato_variation', ['potato', ' potato ', ' potato', 'potato ', ' POTATO ', ' PoTatO '])\n+def test_parse_str(potato_variation: str) -> None:\n+    ta_lower = TypeAdapter(Annotated[str, parse(str).str.strip().str.lower()])\n+    assert ta_lower.validate_python(potato_variation) == 'potato'\n+\n+\n+def test_parse_str_with_pattern() -> None:\n+    ta_pattern = TypeAdapter(Annotated[str, parse(str).str.pattern(r'[a-z]+')])\n+    assert ta_pattern.validate_python('potato') == 'potato'\n+    with pytest.raises(ValueError):\n+        ta_pattern.validate_python('POTATO')\n+\n+\n+@pytest.mark.parametrize(\n+    'method, method_arg, input_string, expected_output',\n+    [\n+        # transforms\n+        ('lower', None, 'POTATO', 'potato'),\n+        ('upper', None, 'potato', 'POTATO'),\n+        ('title', None, 'potato potato', 'Potato Potato'),\n+        ('strip', None, ' potato ', 'potato'),\n+        # constraints\n+        ('pattern', r'[a-z]+', 'potato', 'potato'),  # check lowercase\n+        # predicates\n+        ('contains', 'pot', 'potato', 'potato'),\n+        ('starts_with', 'pot', 'potato', 'potato'),\n+        ('ends_with', 'ato', 'potato', 'potato'),\n+    ],\n+)\n+def test_string_validator_valid(method: str, method_arg: Optional[str], input_string: str, expected_output: str):\n+    # annotated metadata is equivalent to parse(str).str.method(method_arg)\n+    # ex: parse(str).str.contains('pot')\n+    annotated_metadata = getattr(parse(str).str, method)\n+    annotated_metadata = annotated_metadata(method_arg) if method_arg else annotated_metadata()\n+\n+    ta = TypeAdapter(Annotated[str, annotated_metadata])\n+    assert ta.validate_python(input_string) == expected_output\n+\n+\n+def test_string_validator_invalid() -> None:\n+    ta_contains = TypeAdapter(Annotated[str, parse(str).str.contains('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_contains.validate_python('tomato')\n+\n+    ta_starts_with = TypeAdapter(Annotated[str, parse(str).str.starts_with('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_starts_with.validate_python('tomato')\n+\n+    ta_ends_with = TypeAdapter(Annotated[str, parse(str).str.ends_with('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_ends_with.validate_python('tomato')\n+\n+\n+def test_parse_int() -> None:\n+    ta_gt = TypeAdapter(Annotated[int, parse(int).gt(0)])\n+    assert ta_gt.validate_python(1) == 1\n+    assert ta_gt.validate_python('1') == 1\n+    with pytest.raises(ValidationError):\n+        ta_gt.validate_python(0)\n+\n+    ta_gt_strict = TypeAdapter(Annotated[int, parse(int, strict=True).gt(0)])\n+    assert ta_gt_strict.validate_python(1) == 1\n+    with pytest.raises(ValidationError):\n+        ta_gt_strict.validate_python('1')\n+    with pytest.raises(ValidationError):\n+        ta_gt_strict.validate_python(0)\n+\n+\n+def test_parse_str_to_int() -> None:\n+    ta = TypeAdapter(Annotated[int, parse(str).str.strip().parse(int)])\n+    assert ta.validate_python('1') == 1\n+    assert ta.validate_python(' 1 ') == 1\n+    with pytest.raises(ValidationError):\n+        ta.validate_python('a')\n+\n+\n+def test_predicates() -> None:\n+    ta_int = TypeAdapter(Annotated[int, parse(int).predicate(lambda x: x % 2 == 0)])\n+    assert ta_int.validate_python(2) == 2\n+    with pytest.raises(ValidationError):\n+        ta_int.validate_python(1)\n+\n+    ta_str = TypeAdapter(Annotated[str, parse(str).predicate(lambda x: x != 'potato')])",
      "comment": "I think we need to balance what we add vs. how useful it will be. In reality I don't expect `ne` to be that used vs. e.g. `gt`.",
      "comment_id": 1621871811,
      "user": "adriangb",
      "created_at": "2024-05-31T07:25:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1621871811"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/__init__.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,10 @@\n+\"\"\"__init__.py for the experimental submodule of pydantic.\"\"\"",
      "comment": "```suggestion\r\n\"\"\"The \"experimental\" module of pydantic contains potential new features that are subject to change.\"\"\"\r\n```",
      "comment_id": 1625031749,
      "user": "samuelcolvin",
      "created_at": "2024-06-03T20:46:46Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625031749"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true",
      "comment": "```suggestion\r\nfrom pydantic._internal._internal_dataclass import slots_true as _slots_true\r\n```\r\n\r\nAnd we should also update the test that checks nothing from `_internal` is available to import publicly.",
      "comment_id": 1625054319,
      "user": "samuelcolvin",
      "created_at": "2024-06-03T21:09:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625054319"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+",
      "comment": "please can we add `__all__` here and make sure we're clear about what's public and what's not.\r\n\r\nIdeally everything that isn't public should start with an underscore.",
      "comment_id": 1625056062,
      "user": "samuelcolvin",
      "created_at": "2024-06-03T21:11:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625056062"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):",
      "comment": "```suggestion\r\nclass Pipeline(Generic[_InT, _OutT]):\r\n```",
      "comment_id": 1625056588,
      "user": "samuelcolvin",
      "created_at": "2024-06-03T21:11:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625056588"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> Validate[_InT, _NewOutT]:\n+        return Validate[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    @overload\n+    def parse(self, tp: type[_NewOutT], *, strict: bool = ...) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    @overload\n+    def parse(self, *, strict: bool = ...) -> Validate[_InT, Any]:\n+        ...\n+\n+    def parse(self, tp: Any = ..., *, strict: bool = False) -> Validate[_InT, Any]:\n+        \"\"\"Parse the input into a new type.\n+\n+        If not type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+        \"\"\"\n+        return Validate[_InT, Any](self._steps + [_Parse(tp, strict=strict)])\n+\n+    def parse_defer(self, func: Callable[[], type[_NewOutT]]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return Validate[_InT, _NewOutT](self._steps + [_ParseDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGe], constraint: annotated_types.Ge) -> Validate[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGt], constraint: annotated_types.Gt) -> Validate[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLe], constraint: annotated_types.Le) -> Validate[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLt], constraint: annotated_types.Lt) -> Validate[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLen], constraint: annotated_types.Len) -> Validate[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> Validate[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _OutT], constraint: annotated_types.Predicate) -> Validate[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> Validate[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutT], constraint: Pattern[str]) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\"\"\"\n+        return Validate[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: Validate[_InT, _NewOutGt], gt: _NewOutGt) -> Validate[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: Validate[_InT, _NewOutLt], lt: _NewOutLt) -> Validate[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: Validate[_InT, _NewOutGe], ge: _NewOutGe) -> Validate[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: Validate[_InT, _NewOutLe], le: _NewOutLe) -> Validate[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: Validate[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> Validate[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: Validate[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> Validate[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: Validate[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def not_in(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def in_(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def not_eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__ne__, value))\n+\n+    def eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__eq__, value))\n+\n+    # timezone methods\n+    @property\n+    def dt(self: Validate[_InT, _NewOutDatetime]) -> _DateTimeValidator:\n+        return _DateTimeValidator(self._steps)\n+\n+    # string methods\n+    @property\n+    def str(self: Validate[_InT, _NewOutStr]) -> _StringValidator:\n+        return _StringValidator(self._steps)\n+\n+    # operators\n+    def otherwise(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return Validate([_ValidateOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return Validate([_ValidateAnd(self, other)])\n+\n+    __and__ = then\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> cs.CoreSchema:\n+        from pydantic_core import core_schema as cs\n+\n+        queue = deque(self._steps)\n+\n+        s = None\n+\n+        while queue:\n+            step = queue.popleft()\n+            s = _apply_step(step, s, handler, source_type)\n+\n+        s = s or cs.any_schema()\n+        return s\n+\n+\n+parse = Validate[Any, Any]([]).parse\n+parse_defer = Validate[Any, Any]([]).parse_defer\n+transform = Validate[Any, Any]([]).transform\n+constrain = Validate[Any, Any]([]).constrain\n+\n+\n+class _StringValidator(Validate[str, str]):\n+    def lower(self) -> Validate[str, str]:\n+        return self.transform(str.lower)\n+\n+    def upper(self) -> Validate[str, str]:\n+        return self.transform(str.upper)\n+\n+    def title(self) -> Validate[str, str]:\n+        return self.transform(str.title)\n+\n+    def strip(self) -> Validate[str, str]:\n+        return self.transform(str.strip)\n+\n+    def pattern(self, pattern: str) -> Validate[str, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def contains(self, substring: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def starts_with(self, prefix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def ends_with(self, suffix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+\n+class _DateTimeValidator(Validate[datetime.datetime, datetime.datetime]):\n+    def tz_naive(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def tz_aware(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def tz(self, tz: datetime.tzinfo) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def with_tz(self, tz: datetime.tzinfo | None) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+\n+def _check_func(\n+    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    def handler(v: Any) -> Any:\n+        if func(v):\n+            return v\n+        raise ValueError(f'Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}')\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(handler)\n+    else:\n+        return cs.no_info_after_validator_function(handler, s)\n+\n+\n+def _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if isinstance(step, _Parse):\n+        s = _apply_parse(s, step.tp, step.strict, handler, source_type)\n+    elif isinstance(step, _ParseDefer):\n+        s = _apply_parse(s, step.tp, False, handler, source_type)\n+    elif isinstance(step, _Transform):\n+        s = _apply_transform(s, step.func)\n+    elif isinstance(step, _Constraint):\n+        s = _apply_constraint(s, step.constraint)\n+    elif isinstance(step, _ValidateOr):\n+        s = cs.union_schema([handler(step.left), handler(step.right)])\n+    else:\n+        assert isinstance(step, _ValidateAnd)\n+        s = cs.chain_schema([handler(step.left), handler(step.right)])\n+    return s\n+\n+\n+def _apply_parse(\n+    s: cs.CoreSchema | None,\n+    tp: type[Any],\n+    strict: bool,\n+    handler: GetCoreSchemaHandler,\n+    source_type: Any,\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import Strict\n+\n+    if tp is ...:\n+        return handler(source_type)\n+\n+    if strict:\n+        tp = Annotated[tp, Strict()]  # type: ignore\n+\n+    if s and s['type'] == 'any':\n+        return handler(tp)\n+    else:\n+        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)\n+\n+\n+def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(func)\n+\n+    if s['type'] == 'str':\n+        if func is str.strip:\n+            s = s.copy()\n+            s['strip_whitespace'] = True\n+            return s\n+        elif func is str.lower:\n+            s = s.copy()\n+            s['to_lower'] = True\n+            return s\n+        elif func is str.upper:\n+            s = s.copy()\n+            s['to_upper'] = True\n+            return s\n+    return cs.no_info_after_validator_function(func, s)\n+\n+\n+def _apply_constraint(  # noqa: C901\n+    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation\n+) -> cs.CoreSchema:\n+    if isinstance(constraint, annotated_types.Gt):\n+        gt = constraint.gt\n+        if s and s['type'] in ('int', 'float', 'decimal'):",
      "comment": "should we assign `s_type = s['type']` and thereby avoid the getitem 4 times?",
      "comment_id": 1625059529,
      "user": "samuelcolvin",
      "created_at": "2024-06-03T21:15:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625059529"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> Validate[_InT, _NewOutT]:\n+        return Validate[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    @overload\n+    def parse(self, tp: type[_NewOutT], *, strict: bool = ...) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    @overload\n+    def parse(self, *, strict: bool = ...) -> Validate[_InT, Any]:\n+        ...\n+\n+    def parse(self, tp: Any = ..., *, strict: bool = False) -> Validate[_InT, Any]:\n+        \"\"\"Parse the input into a new type.\n+\n+        If not type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+        \"\"\"\n+        return Validate[_InT, Any](self._steps + [_Parse(tp, strict=strict)])\n+\n+    def parse_defer(self, func: Callable[[], type[_NewOutT]]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return Validate[_InT, _NewOutT](self._steps + [_ParseDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGe], constraint: annotated_types.Ge) -> Validate[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGt], constraint: annotated_types.Gt) -> Validate[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLe], constraint: annotated_types.Le) -> Validate[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLt], constraint: annotated_types.Lt) -> Validate[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLen], constraint: annotated_types.Len) -> Validate[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> Validate[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _OutT], constraint: annotated_types.Predicate) -> Validate[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> Validate[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutT], constraint: Pattern[str]) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\"\"\"\n+        return Validate[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: Validate[_InT, _NewOutGt], gt: _NewOutGt) -> Validate[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: Validate[_InT, _NewOutLt], lt: _NewOutLt) -> Validate[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: Validate[_InT, _NewOutGe], ge: _NewOutGe) -> Validate[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: Validate[_InT, _NewOutLe], le: _NewOutLe) -> Validate[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: Validate[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> Validate[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: Validate[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> Validate[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: Validate[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def not_in(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def in_(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def not_eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__ne__, value))\n+\n+    def eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__eq__, value))\n+\n+    # timezone methods\n+    @property\n+    def dt(self: Validate[_InT, _NewOutDatetime]) -> _DateTimeValidator:\n+        return _DateTimeValidator(self._steps)\n+\n+    # string methods\n+    @property\n+    def str(self: Validate[_InT, _NewOutStr]) -> _StringValidator:\n+        return _StringValidator(self._steps)\n+\n+    # operators\n+    def otherwise(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return Validate([_ValidateOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return Validate([_ValidateAnd(self, other)])\n+\n+    __and__ = then\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> cs.CoreSchema:\n+        from pydantic_core import core_schema as cs\n+\n+        queue = deque(self._steps)\n+\n+        s = None\n+\n+        while queue:\n+            step = queue.popleft()\n+            s = _apply_step(step, s, handler, source_type)\n+\n+        s = s or cs.any_schema()\n+        return s\n+\n+\n+parse = Validate[Any, Any]([]).parse\n+parse_defer = Validate[Any, Any]([]).parse_defer\n+transform = Validate[Any, Any]([]).transform\n+constrain = Validate[Any, Any]([]).constrain\n+\n+\n+class _StringValidator(Validate[str, str]):\n+    def lower(self) -> Validate[str, str]:\n+        return self.transform(str.lower)\n+\n+    def upper(self) -> Validate[str, str]:\n+        return self.transform(str.upper)\n+\n+    def title(self) -> Validate[str, str]:\n+        return self.transform(str.title)\n+\n+    def strip(self) -> Validate[str, str]:\n+        return self.transform(str.strip)\n+\n+    def pattern(self, pattern: str) -> Validate[str, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def contains(self, substring: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def starts_with(self, prefix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def ends_with(self, suffix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+\n+class _DateTimeValidator(Validate[datetime.datetime, datetime.datetime]):\n+    def tz_naive(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def tz_aware(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def tz(self, tz: datetime.tzinfo) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def with_tz(self, tz: datetime.tzinfo | None) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+\n+def _check_func(\n+    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    def handler(v: Any) -> Any:\n+        if func(v):\n+            return v\n+        raise ValueError(f'Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}')\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(handler)\n+    else:\n+        return cs.no_info_after_validator_function(handler, s)\n+\n+\n+def _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if isinstance(step, _Parse):\n+        s = _apply_parse(s, step.tp, step.strict, handler, source_type)\n+    elif isinstance(step, _ParseDefer):\n+        s = _apply_parse(s, step.tp, False, handler, source_type)\n+    elif isinstance(step, _Transform):\n+        s = _apply_transform(s, step.func)\n+    elif isinstance(step, _Constraint):\n+        s = _apply_constraint(s, step.constraint)\n+    elif isinstance(step, _ValidateOr):\n+        s = cs.union_schema([handler(step.left), handler(step.right)])\n+    else:\n+        assert isinstance(step, _ValidateAnd)\n+        s = cs.chain_schema([handler(step.left), handler(step.right)])\n+    return s\n+\n+\n+def _apply_parse(\n+    s: cs.CoreSchema | None,\n+    tp: type[Any],\n+    strict: bool,\n+    handler: GetCoreSchemaHandler,\n+    source_type: Any,\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import Strict\n+\n+    if tp is ...:\n+        return handler(source_type)\n+\n+    if strict:\n+        tp = Annotated[tp, Strict()]  # type: ignore\n+\n+    if s and s['type'] == 'any':\n+        return handler(tp)\n+    else:\n+        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)\n+\n+\n+def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(func)\n+\n+    if s['type'] == 'str':\n+        if func is str.strip:\n+            s = s.copy()\n+            s['strip_whitespace'] = True\n+            return s\n+        elif func is str.lower:\n+            s = s.copy()\n+            s['to_lower'] = True\n+            return s\n+        elif func is str.upper:\n+            s = s.copy()\n+            s['to_upper'] = True\n+            return s\n+    return cs.no_info_after_validator_function(func, s)\n+\n+\n+def _apply_constraint(  # noqa: C901\n+    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation\n+) -> cs.CoreSchema:\n+    if isinstance(constraint, annotated_types.Gt):\n+        gt = constraint.gt\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(gt, int):\n+                s['gt'] = gt\n+            elif s['type'] == 'float' and isinstance(gt, float):\n+                s['gt'] = gt\n+            elif s['type'] == 'decimal' and isinstance(gt, Decimal):\n+                s['gt'] = gt\n+        else:\n+\n+            def check_gt(v: Any) -> bool:\n+                return v > gt\n+\n+            s = _check_func(check_gt, f'> {gt}', s)\n+    elif isinstance(constraint, annotated_types.Ge):\n+        ge = constraint.ge\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(ge, int):\n+                s['ge'] = ge\n+            elif s['type'] == 'float' and isinstance(ge, float):\n+                s['ge'] = ge\n+            elif s['type'] == 'decimal' and isinstance(ge, Decimal):\n+                s['ge'] = ge\n+\n+        def check_ge(v: Any) -> bool:\n+            return v >= ge\n+\n+        s = _check_func(check_ge, f'>= {ge}', s)\n+    elif isinstance(constraint, annotated_types.Lt):\n+        lt = constraint.lt\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(lt, int):\n+                s['lt'] = lt\n+            elif s['type'] == 'float' and isinstance(lt, float):\n+                s['lt'] = lt\n+            elif s['type'] == 'decimal' and isinstance(lt, Decimal):\n+                s['lt'] = lt\n+\n+        def check_lt(v: Any) -> bool:\n+            return v < lt\n+\n+        s = _check_func(check_lt, f'< {lt}', s)\n+    elif isinstance(constraint, annotated_types.Le):\n+        le = constraint.le\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(le, int):\n+                s['le'] = le\n+            elif s['type'] == 'float' and isinstance(le, float):\n+                s['le'] = le\n+            elif s['type'] == 'decimal' and isinstance(le, Decimal):\n+                s['le'] = le\n+\n+        def check_le(v: Any) -> bool:\n+            return v <= le\n+\n+        s = _check_func(check_le, f'<= {le}', s)\n+    elif isinstance(constraint, annotated_types.Len):\n+        min_len = constraint.min_length\n+        max_len = constraint.max_length\n+\n+        if s and s['type'] in ('str', 'list', 'tuple', 'set', 'frozenset', 'dict'):",
      "comment": "```suggestion\r\n        if s and s['type'] in {'str', 'list', 'tuple', 'set', 'frozenset', 'dict'}:\r\n```\r\nis nearly 2x faster wen looking up `'dict'`",
      "comment_id": 1625060916,
      "user": "samuelcolvin",
      "created_at": "2024-06-03T21:17:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625060916"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 527,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> Validate[_InT, _NewOutT]:\n+        return Validate[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    @overload\n+    def parse(self, tp: type[_NewOutT], *, strict: bool = ...) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    @overload\n+    def parse(self, *, strict: bool = ...) -> Validate[_InT, Any]:\n+        ...\n+\n+    def parse(self, tp: Any = ..., *, strict: bool = False) -> Validate[_InT, Any]:\n+        \"\"\"Parse the input into a new type.\n+\n+        If not type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+        \"\"\"\n+        return Validate[_InT, Any](self._steps + [_Parse(tp, strict=strict)])\n+\n+    def parse_defer(self, func: Callable[[], type[_NewOutT]]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return Validate[_InT, _NewOutT](self._steps + [_ParseDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGe], constraint: annotated_types.Ge) -> Validate[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGt], constraint: annotated_types.Gt) -> Validate[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLe], constraint: annotated_types.Le) -> Validate[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLt], constraint: annotated_types.Lt) -> Validate[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLen], constraint: annotated_types.Len) -> Validate[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> Validate[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _OutT], constraint: annotated_types.Predicate) -> Validate[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> Validate[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutT], constraint: Pattern[str]) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\"\"\"\n+        return Validate[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: Validate[_InT, _NewOutGt], gt: _NewOutGt) -> Validate[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: Validate[_InT, _NewOutLt], lt: _NewOutLt) -> Validate[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: Validate[_InT, _NewOutGe], ge: _NewOutGe) -> Validate[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: Validate[_InT, _NewOutLe], le: _NewOutLe) -> Validate[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: Validate[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> Validate[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: Validate[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> Validate[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: Validate[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def not_in(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def in_(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def not_eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__ne__, value))\n+\n+    def eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__eq__, value))\n+\n+    # timezone methods\n+    @property\n+    def dt(self: Validate[_InT, _NewOutDatetime]) -> _DateTimeValidator:\n+        return _DateTimeValidator(self._steps)\n+\n+    # string methods\n+    @property\n+    def str(self: Validate[_InT, _NewOutStr]) -> _StringValidator:\n+        return _StringValidator(self._steps)\n+\n+    # operators\n+    def otherwise(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return Validate([_ValidateOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return Validate([_ValidateAnd(self, other)])\n+\n+    __and__ = then\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> cs.CoreSchema:\n+        from pydantic_core import core_schema as cs\n+\n+        queue = deque(self._steps)\n+\n+        s = None\n+\n+        while queue:\n+            step = queue.popleft()\n+            s = _apply_step(step, s, handler, source_type)\n+\n+        s = s or cs.any_schema()\n+        return s\n+\n+\n+parse = Validate[Any, Any]([]).parse\n+parse_defer = Validate[Any, Any]([]).parse_defer\n+transform = Validate[Any, Any]([]).transform\n+constrain = Validate[Any, Any]([]).constrain\n+\n+\n+class _StringValidator(Validate[str, str]):\n+    def lower(self) -> Validate[str, str]:\n+        return self.transform(str.lower)\n+\n+    def upper(self) -> Validate[str, str]:\n+        return self.transform(str.upper)\n+\n+    def title(self) -> Validate[str, str]:\n+        return self.transform(str.title)\n+\n+    def strip(self) -> Validate[str, str]:\n+        return self.transform(str.strip)\n+\n+    def pattern(self, pattern: str) -> Validate[str, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def contains(self, substring: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def starts_with(self, prefix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def ends_with(self, suffix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+\n+class _DateTimeValidator(Validate[datetime.datetime, datetime.datetime]):\n+    def tz_naive(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def tz_aware(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def tz(self, tz: datetime.tzinfo) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def with_tz(self, tz: datetime.tzinfo | None) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+\n+def _check_func(\n+    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    def handler(v: Any) -> Any:\n+        if func(v):\n+            return v\n+        raise ValueError(f'Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}')\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(handler)\n+    else:\n+        return cs.no_info_after_validator_function(handler, s)\n+\n+\n+def _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if isinstance(step, _Parse):\n+        s = _apply_parse(s, step.tp, step.strict, handler, source_type)\n+    elif isinstance(step, _ParseDefer):\n+        s = _apply_parse(s, step.tp, False, handler, source_type)\n+    elif isinstance(step, _Transform):\n+        s = _apply_transform(s, step.func)\n+    elif isinstance(step, _Constraint):\n+        s = _apply_constraint(s, step.constraint)\n+    elif isinstance(step, _ValidateOr):\n+        s = cs.union_schema([handler(step.left), handler(step.right)])\n+    else:\n+        assert isinstance(step, _ValidateAnd)\n+        s = cs.chain_schema([handler(step.left), handler(step.right)])\n+    return s\n+\n+\n+def _apply_parse(\n+    s: cs.CoreSchema | None,\n+    tp: type[Any],\n+    strict: bool,\n+    handler: GetCoreSchemaHandler,\n+    source_type: Any,\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import Strict\n+\n+    if tp is ...:\n+        return handler(source_type)\n+\n+    if strict:\n+        tp = Annotated[tp, Strict()]  # type: ignore\n+\n+    if s and s['type'] == 'any':\n+        return handler(tp)\n+    else:\n+        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)\n+\n+\n+def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(func)\n+\n+    if s['type'] == 'str':\n+        if func is str.strip:\n+            s = s.copy()\n+            s['strip_whitespace'] = True\n+            return s\n+        elif func is str.lower:\n+            s = s.copy()\n+            s['to_lower'] = True\n+            return s\n+        elif func is str.upper:\n+            s = s.copy()\n+            s['to_upper'] = True\n+            return s\n+    return cs.no_info_after_validator_function(func, s)\n+\n+\n+def _apply_constraint(  # noqa: C901\n+    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation\n+) -> cs.CoreSchema:\n+    if isinstance(constraint, annotated_types.Gt):\n+        gt = constraint.gt\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(gt, int):\n+                s['gt'] = gt\n+            elif s['type'] == 'float' and isinstance(gt, float):\n+                s['gt'] = gt\n+            elif s['type'] == 'decimal' and isinstance(gt, Decimal):\n+                s['gt'] = gt\n+        else:\n+\n+            def check_gt(v: Any) -> bool:\n+                return v > gt\n+\n+            s = _check_func(check_gt, f'> {gt}', s)\n+    elif isinstance(constraint, annotated_types.Ge):\n+        ge = constraint.ge\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(ge, int):\n+                s['ge'] = ge\n+            elif s['type'] == 'float' and isinstance(ge, float):\n+                s['ge'] = ge\n+            elif s['type'] == 'decimal' and isinstance(ge, Decimal):\n+                s['ge'] = ge\n+\n+        def check_ge(v: Any) -> bool:\n+            return v >= ge\n+\n+        s = _check_func(check_ge, f'>= {ge}', s)\n+    elif isinstance(constraint, annotated_types.Lt):\n+        lt = constraint.lt\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(lt, int):\n+                s['lt'] = lt\n+            elif s['type'] == 'float' and isinstance(lt, float):\n+                s['lt'] = lt\n+            elif s['type'] == 'decimal' and isinstance(lt, Decimal):\n+                s['lt'] = lt\n+\n+        def check_lt(v: Any) -> bool:\n+            return v < lt\n+\n+        s = _check_func(check_lt, f'< {lt}', s)\n+    elif isinstance(constraint, annotated_types.Le):\n+        le = constraint.le\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(le, int):\n+                s['le'] = le\n+            elif s['type'] == 'float' and isinstance(le, float):\n+                s['le'] = le\n+            elif s['type'] == 'decimal' and isinstance(le, Decimal):\n+                s['le'] = le\n+\n+        def check_le(v: Any) -> bool:\n+            return v <= le\n+\n+        s = _check_func(check_le, f'<= {le}', s)\n+    elif isinstance(constraint, annotated_types.Len):\n+        min_len = constraint.min_length\n+        max_len = constraint.max_length\n+\n+        if s and s['type'] in ('str', 'list', 'tuple', 'set', 'frozenset', 'dict'):\n+            assert (\n+                s['type'] == 'str'\n+                or s['type'] == 'list'\n+                or s['type'] == 'tuple'\n+                or s['type'] == 'set'\n+                or s['type'] == 'dict'\n+                or s['type'] == 'frozenset'\n+            )\n+            s = s.copy()\n+            if min_len != 0:\n+                s['min_length'] = min_len\n+            if max_len is not None:\n+                s['max_length'] = max_len\n+\n+        def check_len(v: Any) -> bool:\n+            if max_len is not None:\n+                return (min_len <= len(v)) and (len(v) <= max_len)\n+            return min_len <= len(v)\n+\n+        s = _check_func(check_len, f'length >= {min_len} and length <= {max_len}', s)\n+    elif isinstance(constraint, annotated_types.MultipleOf):\n+        multiple_of = constraint.multiple_of\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(multiple_of, int):\n+                s['multiple_of'] = multiple_of\n+            elif s['type'] == 'float' and isinstance(multiple_of, float):\n+                s['multiple_of'] = multiple_of\n+            elif s['type'] == 'decimal' and isinstance(multiple_of, Decimal):\n+                s['multiple_of'] = multiple_of\n+\n+        def check_multiple_of(v: Any) -> bool:\n+            return v % multiple_of == 0\n+\n+        s = _check_func(check_multiple_of, f'% {multiple_of} == 0', s)\n+    elif isinstance(constraint, annotated_types.Timezone):\n+        tz = constraint.tz\n+\n+        if tz is ...:\n+            if s and s['type'] == 'datetime':\n+                s = s.copy()\n+                s['tz_constraint'] = 'aware'\n+            else:\n+\n+                def check_tz_aware(v: object) -> bool:\n+                    assert isinstance(v, datetime.datetime)\n+                    return v.tzinfo is not None\n+\n+                s = _check_func(check_tz_aware, 'timezone aware', s)\n+        elif tz is None:\n+            if s and s['type'] == 'datetime':\n+                s = s.copy()\n+                s['tz_constraint'] = 'naive'\n+            else:\n+\n+                def check_tz_naive(v: object) -> bool:\n+                    assert isinstance(v, datetime.datetime)\n+                    return v.tzinfo is None\n+\n+                s = _check_func(check_tz_naive, 'timezone naive', s)\n+        else:\n+            raise NotImplementedError('Constraining to a specific timezone is not yet supported')\n+    elif isinstance(constraint, annotated_types.Interval):\n+        if constraint.ge:\n+            s = _apply_constraint(s, annotated_types.Ge(constraint.ge))\n+        if constraint.gt:\n+            s = _apply_constraint(s, annotated_types.Gt(constraint.gt))\n+        if constraint.le:\n+            s = _apply_constraint(s, annotated_types.Le(constraint.le))\n+        if constraint.lt:\n+            s = _apply_constraint(s, annotated_types.Lt(constraint.lt))\n+        assert s is not None\n+    elif isinstance(constraint, annotated_types.Predicate):\n+        func = constraint.func\n+\n+        if func.__name__ == '<lambda>':\n+\n+            def on_lambda_err() -> str:",
      "comment": "can you add a docstirng explaing what this is doing?\r\n\r\nAlso, could this be a standalone function?",
      "comment_id": 1625062069,
      "user": "samuelcolvin",
      "created_at": "2024-06-03T21:18:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625062069"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> Validate[_InT, _NewOutT]:\n+        return Validate[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    @overload\n+    def parse(self, tp: type[_NewOutT], *, strict: bool = ...) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    @overload\n+    def parse(self, *, strict: bool = ...) -> Validate[_InT, Any]:\n+        ...\n+\n+    def parse(self, tp: Any = ..., *, strict: bool = False) -> Validate[_InT, Any]:\n+        \"\"\"Parse the input into a new type.\n+\n+        If not type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+        \"\"\"\n+        return Validate[_InT, Any](self._steps + [_Parse(tp, strict=strict)])\n+\n+    def parse_defer(self, func: Callable[[], type[_NewOutT]]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return Validate[_InT, _NewOutT](self._steps + [_ParseDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGe], constraint: annotated_types.Ge) -> Validate[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGt], constraint: annotated_types.Gt) -> Validate[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLe], constraint: annotated_types.Le) -> Validate[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLt], constraint: annotated_types.Lt) -> Validate[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLen], constraint: annotated_types.Len) -> Validate[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> Validate[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _OutT], constraint: annotated_types.Predicate) -> Validate[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> Validate[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutT], constraint: Pattern[str]) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\"\"\"\n+        return Validate[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: Validate[_InT, _NewOutGt], gt: _NewOutGt) -> Validate[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: Validate[_InT, _NewOutLt], lt: _NewOutLt) -> Validate[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: Validate[_InT, _NewOutGe], ge: _NewOutGe) -> Validate[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: Validate[_InT, _NewOutLe], le: _NewOutLe) -> Validate[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: Validate[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> Validate[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: Validate[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> Validate[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: Validate[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def not_in(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def in_(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def not_eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__ne__, value))\n+\n+    def eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__eq__, value))\n+\n+    # timezone methods\n+    @property\n+    def dt(self: Validate[_InT, _NewOutDatetime]) -> _DateTimeValidator:\n+        return _DateTimeValidator(self._steps)\n+\n+    # string methods\n+    @property\n+    def str(self: Validate[_InT, _NewOutStr]) -> _StringValidator:\n+        return _StringValidator(self._steps)\n+\n+    # operators\n+    def otherwise(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return Validate([_ValidateOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return Validate([_ValidateAnd(self, other)])\n+\n+    __and__ = then\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> cs.CoreSchema:\n+        from pydantic_core import core_schema as cs\n+\n+        queue = deque(self._steps)\n+\n+        s = None\n+\n+        while queue:\n+            step = queue.popleft()\n+            s = _apply_step(step, s, handler, source_type)\n+\n+        s = s or cs.any_schema()\n+        return s\n+\n+\n+parse = Validate[Any, Any]([]).parse\n+parse_defer = Validate[Any, Any]([]).parse_defer\n+transform = Validate[Any, Any]([]).transform\n+constrain = Validate[Any, Any]([]).constrain\n+\n+\n+class _StringValidator(Validate[str, str]):\n+    def lower(self) -> Validate[str, str]:\n+        return self.transform(str.lower)\n+\n+    def upper(self) -> Validate[str, str]:\n+        return self.transform(str.upper)\n+\n+    def title(self) -> Validate[str, str]:\n+        return self.transform(str.title)\n+\n+    def strip(self) -> Validate[str, str]:\n+        return self.transform(str.strip)\n+\n+    def pattern(self, pattern: str) -> Validate[str, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def contains(self, substring: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def starts_with(self, prefix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def ends_with(self, suffix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+\n+class _DateTimeValidator(Validate[datetime.datetime, datetime.datetime]):\n+    def tz_naive(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def tz_aware(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def tz(self, tz: datetime.tzinfo) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def with_tz(self, tz: datetime.tzinfo | None) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+\n+def _check_func(\n+    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    def handler(v: Any) -> Any:\n+        if func(v):\n+            return v\n+        raise ValueError(f'Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}')\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(handler)\n+    else:\n+        return cs.no_info_after_validator_function(handler, s)\n+\n+\n+def _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if isinstance(step, _Parse):\n+        s = _apply_parse(s, step.tp, step.strict, handler, source_type)\n+    elif isinstance(step, _ParseDefer):\n+        s = _apply_parse(s, step.tp, False, handler, source_type)\n+    elif isinstance(step, _Transform):\n+        s = _apply_transform(s, step.func)\n+    elif isinstance(step, _Constraint):\n+        s = _apply_constraint(s, step.constraint)\n+    elif isinstance(step, _ValidateOr):\n+        s = cs.union_schema([handler(step.left), handler(step.right)])\n+    else:\n+        assert isinstance(step, _ValidateAnd)\n+        s = cs.chain_schema([handler(step.left), handler(step.right)])\n+    return s\n+\n+\n+def _apply_parse(\n+    s: cs.CoreSchema | None,\n+    tp: type[Any],\n+    strict: bool,\n+    handler: GetCoreSchemaHandler,\n+    source_type: Any,\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import Strict\n+\n+    if tp is ...:\n+        return handler(source_type)\n+\n+    if strict:\n+        tp = Annotated[tp, Strict()]  # type: ignore\n+\n+    if s and s['type'] == 'any':\n+        return handler(tp)\n+    else:\n+        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)\n+\n+\n+def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(func)\n+\n+    if s['type'] == 'str':\n+        if func is str.strip:\n+            s = s.copy()\n+            s['strip_whitespace'] = True\n+            return s\n+        elif func is str.lower:\n+            s = s.copy()\n+            s['to_lower'] = True\n+            return s\n+        elif func is str.upper:\n+            s = s.copy()\n+            s['to_upper'] = True\n+            return s\n+    return cs.no_info_after_validator_function(func, s)\n+\n+\n+def _apply_constraint(  # noqa: C901\n+    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation\n+) -> cs.CoreSchema:\n+    if isinstance(constraint, annotated_types.Gt):\n+        gt = constraint.gt\n+        if s and s['type'] in ('int', 'float', 'decimal'):",
      "comment": "yep makes sense this used to be a match where it didn't really matter but now it does",
      "comment_id": 1625959332,
      "user": "adriangb",
      "created_at": "2024-06-04T12:57:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625959332"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> Validate[_InT, _NewOutT]:\n+        return Validate[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    @overload\n+    def parse(self, tp: type[_NewOutT], *, strict: bool = ...) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    @overload\n+    def parse(self, *, strict: bool = ...) -> Validate[_InT, Any]:\n+        ...\n+\n+    def parse(self, tp: Any = ..., *, strict: bool = False) -> Validate[_InT, Any]:\n+        \"\"\"Parse the input into a new type.\n+\n+        If not type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+        \"\"\"\n+        return Validate[_InT, Any](self._steps + [_Parse(tp, strict=strict)])\n+\n+    def parse_defer(self, func: Callable[[], type[_NewOutT]]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return Validate[_InT, _NewOutT](self._steps + [_ParseDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGe], constraint: annotated_types.Ge) -> Validate[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGt], constraint: annotated_types.Gt) -> Validate[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLe], constraint: annotated_types.Le) -> Validate[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLt], constraint: annotated_types.Lt) -> Validate[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLen], constraint: annotated_types.Len) -> Validate[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> Validate[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _OutT], constraint: annotated_types.Predicate) -> Validate[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> Validate[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutT], constraint: Pattern[str]) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\"\"\"\n+        return Validate[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: Validate[_InT, _NewOutGt], gt: _NewOutGt) -> Validate[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: Validate[_InT, _NewOutLt], lt: _NewOutLt) -> Validate[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: Validate[_InT, _NewOutGe], ge: _NewOutGe) -> Validate[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: Validate[_InT, _NewOutLe], le: _NewOutLe) -> Validate[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: Validate[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> Validate[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: Validate[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> Validate[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: Validate[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def not_in(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def in_(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def not_eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__ne__, value))\n+\n+    def eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__eq__, value))\n+\n+    # timezone methods\n+    @property\n+    def dt(self: Validate[_InT, _NewOutDatetime]) -> _DateTimeValidator:\n+        return _DateTimeValidator(self._steps)\n+\n+    # string methods\n+    @property\n+    def str(self: Validate[_InT, _NewOutStr]) -> _StringValidator:\n+        return _StringValidator(self._steps)\n+\n+    # operators\n+    def otherwise(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return Validate([_ValidateOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return Validate([_ValidateAnd(self, other)])\n+\n+    __and__ = then\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> cs.CoreSchema:\n+        from pydantic_core import core_schema as cs\n+\n+        queue = deque(self._steps)\n+\n+        s = None\n+\n+        while queue:\n+            step = queue.popleft()\n+            s = _apply_step(step, s, handler, source_type)\n+\n+        s = s or cs.any_schema()\n+        return s\n+\n+\n+parse = Validate[Any, Any]([]).parse\n+parse_defer = Validate[Any, Any]([]).parse_defer\n+transform = Validate[Any, Any]([]).transform\n+constrain = Validate[Any, Any]([]).constrain\n+\n+\n+class _StringValidator(Validate[str, str]):\n+    def lower(self) -> Validate[str, str]:\n+        return self.transform(str.lower)\n+\n+    def upper(self) -> Validate[str, str]:\n+        return self.transform(str.upper)\n+\n+    def title(self) -> Validate[str, str]:\n+        return self.transform(str.title)\n+\n+    def strip(self) -> Validate[str, str]:\n+        return self.transform(str.strip)\n+\n+    def pattern(self, pattern: str) -> Validate[str, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def contains(self, substring: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def starts_with(self, prefix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def ends_with(self, suffix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+\n+class _DateTimeValidator(Validate[datetime.datetime, datetime.datetime]):\n+    def tz_naive(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def tz_aware(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def tz(self, tz: datetime.tzinfo) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def with_tz(self, tz: datetime.tzinfo | None) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+\n+def _check_func(\n+    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    def handler(v: Any) -> Any:\n+        if func(v):\n+            return v\n+        raise ValueError(f'Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}')\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(handler)\n+    else:\n+        return cs.no_info_after_validator_function(handler, s)\n+\n+\n+def _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if isinstance(step, _Parse):\n+        s = _apply_parse(s, step.tp, step.strict, handler, source_type)\n+    elif isinstance(step, _ParseDefer):\n+        s = _apply_parse(s, step.tp, False, handler, source_type)\n+    elif isinstance(step, _Transform):\n+        s = _apply_transform(s, step.func)\n+    elif isinstance(step, _Constraint):\n+        s = _apply_constraint(s, step.constraint)\n+    elif isinstance(step, _ValidateOr):\n+        s = cs.union_schema([handler(step.left), handler(step.right)])\n+    else:\n+        assert isinstance(step, _ValidateAnd)\n+        s = cs.chain_schema([handler(step.left), handler(step.right)])\n+    return s\n+\n+\n+def _apply_parse(\n+    s: cs.CoreSchema | None,\n+    tp: type[Any],\n+    strict: bool,\n+    handler: GetCoreSchemaHandler,\n+    source_type: Any,\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import Strict\n+\n+    if tp is ...:\n+        return handler(source_type)\n+\n+    if strict:\n+        tp = Annotated[tp, Strict()]  # type: ignore\n+\n+    if s and s['type'] == 'any':\n+        return handler(tp)\n+    else:\n+        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)\n+\n+\n+def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(func)\n+\n+    if s['type'] == 'str':\n+        if func is str.strip:\n+            s = s.copy()\n+            s['strip_whitespace'] = True\n+            return s\n+        elif func is str.lower:\n+            s = s.copy()\n+            s['to_lower'] = True\n+            return s\n+        elif func is str.upper:\n+            s = s.copy()\n+            s['to_upper'] = True\n+            return s\n+    return cs.no_info_after_validator_function(func, s)\n+\n+\n+def _apply_constraint(  # noqa: C901\n+    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation\n+) -> cs.CoreSchema:\n+    if isinstance(constraint, annotated_types.Gt):\n+        gt = constraint.gt\n+        if s and s['type'] in ('int', 'float', 'decimal'):",
      "comment": "well actually if we do that we loose type safety in the whole function (it won't check that `s['gt'] = 1` is valid). so I'm going to leave it as is. the cost is minimal and this is during schema building not runtime",
      "comment_id": 1625961650,
      "user": "adriangb",
      "created_at": "2024-06-04T12:59:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625961650"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+",
      "comment": "actually all was already there, it was just at the bottom of the file",
      "comment_id": 1625982981,
      "user": "adriangb",
      "created_at": "2024-06-04T13:13:13Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1625982981"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 527,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ParseDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateOr:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+@dataclass(**slots_true)\n+class _ValidateAnd:\n+    left: Validate[Any, Any]\n+    right: Validate[Any, Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_Parse, _ParseDefer, _Transform, _ValidateOr, _ValidateAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+@dataclass(**slots_true)\n+class Validate(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> Validate[_InT, _NewOutT]:\n+        return Validate[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    @overload\n+    def parse(self, tp: type[_NewOutT], *, strict: bool = ...) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    @overload\n+    def parse(self, *, strict: bool = ...) -> Validate[_InT, Any]:\n+        ...\n+\n+    def parse(self, tp: Any = ..., *, strict: bool = False) -> Validate[_InT, Any]:\n+        \"\"\"Parse the input into a new type.\n+\n+        If not type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+        \"\"\"\n+        return Validate[_InT, Any](self._steps + [_Parse(tp, strict=strict)])\n+\n+    def parse_defer(self, func: Callable[[], type[_NewOutT]]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return Validate[_InT, _NewOutT](self._steps + [_ParseDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGe], constraint: annotated_types.Ge) -> Validate[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutGt], constraint: annotated_types.Gt) -> Validate[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLe], constraint: annotated_types.Le) -> Validate[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLt], constraint: annotated_types.Lt) -> Validate[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutLen], constraint: annotated_types.Len) -> Validate[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> Validate[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> Validate[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _OutT], constraint: annotated_types.Predicate) -> Validate[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: Validate[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> Validate[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: Validate[_InT, _NewOutT], constraint: Pattern[str]) -> Validate[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\"\"\"\n+        return Validate[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: Validate[_InT, _NewOutGt], gt: _NewOutGt) -> Validate[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: Validate[_InT, _NewOutLt], lt: _NewOutLt) -> Validate[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: Validate[_InT, _NewOutGe], ge: _NewOutGe) -> Validate[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: Validate[_InT, _NewOutLe], le: _NewOutLe) -> Validate[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: Validate[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> Validate[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: Validate[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> Validate[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: Validate[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> Validate[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def not_in(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def in_(self: Validate[_InT, _OutT], values: Container[_OutT]) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.predicate(partial(operator.__contains__, values))\n+\n+    def not_eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__ne__, value))\n+\n+    def eq(self: Validate[_InT, _OutT], value: _OutT) -> Validate[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.predicate(partial(operator.__eq__, value))\n+\n+    # timezone methods\n+    @property\n+    def dt(self: Validate[_InT, _NewOutDatetime]) -> _DateTimeValidator:\n+        return _DateTimeValidator(self._steps)\n+\n+    # string methods\n+    @property\n+    def str(self: Validate[_InT, _NewOutStr]) -> _StringValidator:\n+        return _StringValidator(self._steps)\n+\n+    # operators\n+    def otherwise(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return Validate([_ValidateOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: Validate[_OtherIn, _OtherOut]) -> Validate[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return Validate([_ValidateAnd(self, other)])\n+\n+    __and__ = then\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> cs.CoreSchema:\n+        from pydantic_core import core_schema as cs\n+\n+        queue = deque(self._steps)\n+\n+        s = None\n+\n+        while queue:\n+            step = queue.popleft()\n+            s = _apply_step(step, s, handler, source_type)\n+\n+        s = s or cs.any_schema()\n+        return s\n+\n+\n+parse = Validate[Any, Any]([]).parse\n+parse_defer = Validate[Any, Any]([]).parse_defer\n+transform = Validate[Any, Any]([]).transform\n+constrain = Validate[Any, Any]([]).constrain\n+\n+\n+class _StringValidator(Validate[str, str]):\n+    def lower(self) -> Validate[str, str]:\n+        return self.transform(str.lower)\n+\n+    def upper(self) -> Validate[str, str]:\n+        return self.transform(str.upper)\n+\n+    def title(self) -> Validate[str, str]:\n+        return self.transform(str.title)\n+\n+    def strip(self) -> Validate[str, str]:\n+        return self.transform(str.strip)\n+\n+    def pattern(self, pattern: str) -> Validate[str, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def contains(self, substring: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def starts_with(self, prefix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def ends_with(self, suffix: str) -> Validate[str, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+\n+class _DateTimeValidator(Validate[datetime.datetime, datetime.datetime]):\n+    def tz_naive(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def tz_aware(self) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def tz(self, tz: datetime.tzinfo) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def with_tz(self, tz: datetime.tzinfo | None) -> Validate[datetime.datetime, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+\n+def _check_func(\n+    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    def handler(v: Any) -> Any:\n+        if func(v):\n+            return v\n+        raise ValueError(f'Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}')\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(handler)\n+    else:\n+        return cs.no_info_after_validator_function(handler, s)\n+\n+\n+def _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if isinstance(step, _Parse):\n+        s = _apply_parse(s, step.tp, step.strict, handler, source_type)\n+    elif isinstance(step, _ParseDefer):\n+        s = _apply_parse(s, step.tp, False, handler, source_type)\n+    elif isinstance(step, _Transform):\n+        s = _apply_transform(s, step.func)\n+    elif isinstance(step, _Constraint):\n+        s = _apply_constraint(s, step.constraint)\n+    elif isinstance(step, _ValidateOr):\n+        s = cs.union_schema([handler(step.left), handler(step.right)])\n+    else:\n+        assert isinstance(step, _ValidateAnd)\n+        s = cs.chain_schema([handler(step.left), handler(step.right)])\n+    return s\n+\n+\n+def _apply_parse(\n+    s: cs.CoreSchema | None,\n+    tp: type[Any],\n+    strict: bool,\n+    handler: GetCoreSchemaHandler,\n+    source_type: Any,\n+) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import Strict\n+\n+    if tp is ...:\n+        return handler(source_type)\n+\n+    if strict:\n+        tp = Annotated[tp, Strict()]  # type: ignore\n+\n+    if s and s['type'] == 'any':\n+        return handler(tp)\n+    else:\n+        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)\n+\n+\n+def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.CoreSchema:\n+    from pydantic_core import core_schema as cs\n+\n+    if s is None:\n+        return cs.no_info_plain_validator_function(func)\n+\n+    if s['type'] == 'str':\n+        if func is str.strip:\n+            s = s.copy()\n+            s['strip_whitespace'] = True\n+            return s\n+        elif func is str.lower:\n+            s = s.copy()\n+            s['to_lower'] = True\n+            return s\n+        elif func is str.upper:\n+            s = s.copy()\n+            s['to_upper'] = True\n+            return s\n+    return cs.no_info_after_validator_function(func, s)\n+\n+\n+def _apply_constraint(  # noqa: C901\n+    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation\n+) -> cs.CoreSchema:\n+    if isinstance(constraint, annotated_types.Gt):\n+        gt = constraint.gt\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(gt, int):\n+                s['gt'] = gt\n+            elif s['type'] == 'float' and isinstance(gt, float):\n+                s['gt'] = gt\n+            elif s['type'] == 'decimal' and isinstance(gt, Decimal):\n+                s['gt'] = gt\n+        else:\n+\n+            def check_gt(v: Any) -> bool:\n+                return v > gt\n+\n+            s = _check_func(check_gt, f'> {gt}', s)\n+    elif isinstance(constraint, annotated_types.Ge):\n+        ge = constraint.ge\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(ge, int):\n+                s['ge'] = ge\n+            elif s['type'] == 'float' and isinstance(ge, float):\n+                s['ge'] = ge\n+            elif s['type'] == 'decimal' and isinstance(ge, Decimal):\n+                s['ge'] = ge\n+\n+        def check_ge(v: Any) -> bool:\n+            return v >= ge\n+\n+        s = _check_func(check_ge, f'>= {ge}', s)\n+    elif isinstance(constraint, annotated_types.Lt):\n+        lt = constraint.lt\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(lt, int):\n+                s['lt'] = lt\n+            elif s['type'] == 'float' and isinstance(lt, float):\n+                s['lt'] = lt\n+            elif s['type'] == 'decimal' and isinstance(lt, Decimal):\n+                s['lt'] = lt\n+\n+        def check_lt(v: Any) -> bool:\n+            return v < lt\n+\n+        s = _check_func(check_lt, f'< {lt}', s)\n+    elif isinstance(constraint, annotated_types.Le):\n+        le = constraint.le\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(le, int):\n+                s['le'] = le\n+            elif s['type'] == 'float' and isinstance(le, float):\n+                s['le'] = le\n+            elif s['type'] == 'decimal' and isinstance(le, Decimal):\n+                s['le'] = le\n+\n+        def check_le(v: Any) -> bool:\n+            return v <= le\n+\n+        s = _check_func(check_le, f'<= {le}', s)\n+    elif isinstance(constraint, annotated_types.Len):\n+        min_len = constraint.min_length\n+        max_len = constraint.max_length\n+\n+        if s and s['type'] in ('str', 'list', 'tuple', 'set', 'frozenset', 'dict'):\n+            assert (\n+                s['type'] == 'str'\n+                or s['type'] == 'list'\n+                or s['type'] == 'tuple'\n+                or s['type'] == 'set'\n+                or s['type'] == 'dict'\n+                or s['type'] == 'frozenset'\n+            )\n+            s = s.copy()\n+            if min_len != 0:\n+                s['min_length'] = min_len\n+            if max_len is not None:\n+                s['max_length'] = max_len\n+\n+        def check_len(v: Any) -> bool:\n+            if max_len is not None:\n+                return (min_len <= len(v)) and (len(v) <= max_len)\n+            return min_len <= len(v)\n+\n+        s = _check_func(check_len, f'length >= {min_len} and length <= {max_len}', s)\n+    elif isinstance(constraint, annotated_types.MultipleOf):\n+        multiple_of = constraint.multiple_of\n+        if s and s['type'] in ('int', 'float', 'decimal'):\n+            s = s.copy()\n+            if s['type'] == 'int' and isinstance(multiple_of, int):\n+                s['multiple_of'] = multiple_of\n+            elif s['type'] == 'float' and isinstance(multiple_of, float):\n+                s['multiple_of'] = multiple_of\n+            elif s['type'] == 'decimal' and isinstance(multiple_of, Decimal):\n+                s['multiple_of'] = multiple_of\n+\n+        def check_multiple_of(v: Any) -> bool:\n+            return v % multiple_of == 0\n+\n+        s = _check_func(check_multiple_of, f'% {multiple_of} == 0', s)\n+    elif isinstance(constraint, annotated_types.Timezone):\n+        tz = constraint.tz\n+\n+        if tz is ...:\n+            if s and s['type'] == 'datetime':\n+                s = s.copy()\n+                s['tz_constraint'] = 'aware'\n+            else:\n+\n+                def check_tz_aware(v: object) -> bool:\n+                    assert isinstance(v, datetime.datetime)\n+                    return v.tzinfo is not None\n+\n+                s = _check_func(check_tz_aware, 'timezone aware', s)\n+        elif tz is None:\n+            if s and s['type'] == 'datetime':\n+                s = s.copy()\n+                s['tz_constraint'] = 'naive'\n+            else:\n+\n+                def check_tz_naive(v: object) -> bool:\n+                    assert isinstance(v, datetime.datetime)\n+                    return v.tzinfo is None\n+\n+                s = _check_func(check_tz_naive, 'timezone naive', s)\n+        else:\n+            raise NotImplementedError('Constraining to a specific timezone is not yet supported')\n+    elif isinstance(constraint, annotated_types.Interval):\n+        if constraint.ge:\n+            s = _apply_constraint(s, annotated_types.Ge(constraint.ge))\n+        if constraint.gt:\n+            s = _apply_constraint(s, annotated_types.Gt(constraint.gt))\n+        if constraint.le:\n+            s = _apply_constraint(s, annotated_types.Le(constraint.le))\n+        if constraint.lt:\n+            s = _apply_constraint(s, annotated_types.Lt(constraint.lt))\n+        assert s is not None\n+    elif isinstance(constraint, annotated_types.Predicate):\n+        func = constraint.func\n+\n+        if func.__name__ == '<lambda>':\n+\n+            def on_lambda_err() -> str:",
      "comment": "I got rid of the function altogether and added a comment",
      "comment_id": 1626066407,
      "user": "adriangb",
      "created_at": "2024-06-04T13:56:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1626066407"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,595 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true\n+\n+__all__ = ['validate_as', 'parse_defer', 'transform']\n+\n+\n+@dataclass(**slots_true)\n+class _Parse:",
      "comment": "we need to rename this, should we call this `_ValidateAs`?",
      "comment_id": 1626184742,
      "user": "samuelcolvin",
      "created_at": "2024-06-04T15:05:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1626184742"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,580 @@\n+\"\"\"Experimental functionality, be prepared for this to break.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true",
      "comment": "Done, I updated this function:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/137d4d83936bf5077c4b6354c43314bca704c4f6/tests/test_exports.py#L37-L61",
      "comment_id": 1626731281,
      "user": "sydney-runkle",
      "created_at": "2024-06-04T23:07:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1626731281"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "tests/test_pipeline.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,235 @@\n+\"\"\"Tests for the experimental transform module.\"\"\"\n+from __future__ import annotations\n+\n+import datetime\n+import sys\n+import warnings\n+from decimal import Decimal\n+from typing import Any, List, Union\n+\n+import pytest\n+import pytz\n+from typing_extensions import Annotated\n+\n+if sys.version_info >= (3, 9):\n+    pass\n+\n+from pydantic import PydanticExperimentalWarning, TypeAdapter, ValidationError\n+\n+with warnings.catch_warnings():\n+    warnings.filterwarnings('ignore', category=PydanticExperimentalWarning)\n+    from pydantic.experimental.pipeline import _Pipeline, transform, validate_as\n+\n+\n+@pytest.mark.parametrize('potato_variation', ['potato', ' potato ', ' potato', 'potato ', ' POTATO ', ' PoTatO '])\n+def test_parse_str(potato_variation: str) -> None:\n+    ta_lower = TypeAdapter(Annotated[str, validate_as().str_strip().str_lower()])\n+    assert ta_lower.validate_python(potato_variation) == 'potato'\n+\n+\n+def test_parse_str_with_pattern() -> None:\n+    ta_pattern = TypeAdapter(Annotated[str, validate_as().str_pattern(r'[a-z]+')])\n+    assert ta_pattern.validate_python('potato') == 'potato'\n+    with pytest.raises(ValueError):\n+        ta_pattern.validate_python('POTATO')\n+\n+\n+@pytest.mark.parametrize(\n+    'type_, pipeline, valid_cases, invalid_cases',\n+    [\n+        (int, validate_as(...).ge(0), [0, 1, 100], [-1, -100]),\n+        (float, validate_as(...).ge(0.0), [1.8, 0.0], [-1.0]),\n+        (Decimal, validate_as(...).ge(Decimal(0.0)), [Decimal(1), Decimal(0.0)], [Decimal(-1.0)]),\n+        (int, validate_as(...).le(5), [2, 4], [6, 100]),\n+        (float, validate_as(...).le(1.0), [0.5, 0.0], [100.0]),\n+        (Decimal, validate_as(...).le(Decimal(1.0)), [Decimal(1)], [Decimal(5.0)]),\n+    ],\n+)\n+def test_ge_le(type_: Any, pipeline: _Pipeline, valid_cases: list[Any], invalid_cases: list[Any]) -> None:\n+    ta = TypeAdapter(Annotated[type_, pipeline])\n+    for x in valid_cases:\n+        assert ta.validate_python(x) == x\n+    for y in invalid_cases:\n+        with pytest.raises(ValueError):\n+            ta.validate_python(y)\n+\n+\n+def test_parse_multipleOf() -> None:\n+    ta_m = TypeAdapter(Annotated[int, validate_as(int).multiple_of(5)])\n+    assert ta_m.validate_python(5) == 5\n+    assert ta_m.validate_python(20) == 20\n+    with pytest.raises(ValueError):\n+        ta_m.validate_python(18)\n+\n+\n+def test_parse_tz() -> None:\n+    ta_tz = TypeAdapter(Annotated[datetime.datetime, validate_as(str).datetime_tz_naive()])\n+    date = datetime.datetime(2032, 6, 4, 11, 15, 30, 400000)\n+    assert ta_tz.validate_python(date) == date\n+\n+    ta_tza = TypeAdapter(Annotated[datetime.datetime, validate_as(str).datetime_tz_aware()])\n+    date_a = datetime.datetime(2032, 6, 4, 11, 15, 30, 400000, pytz.UTC)\n+    assert ta_tza.validate_python(date_a) == date_a\n+    with pytest.raises(ValueError):\n+        ta_tza.validate_python(date)\n+\n+\n+@pytest.mark.parametrize(\n+    'method, method_arg, input_string, expected_output',\n+    [\n+        # transforms\n+        ('lower', None, 'POTATO', 'potato'),\n+        ('upper', None, 'potato', 'POTATO'),\n+        ('title', None, 'potato potato', 'Potato Potato'),\n+        ('strip', None, ' potato ', 'potato'),\n+        # constraints\n+        ('pattern', r'[a-z]+', 'potato', 'potato'),  # check lowercase\n+        # predicates\n+        ('contains', 'pot', 'potato', 'potato'),\n+        ('starts_with', 'pot', 'potato', 'potato'),\n+        ('ends_with', 'ato', 'potato', 'potato'),\n+    ],\n+)\n+def test_string_validator_valid(method: str, method_arg: str | None, input_string: str, expected_output: str):\n+    # annotated metadata is equivalent to validate_as(str).str_method(method_arg)\n+    # ex: validate_as(str).str_contains('pot')\n+    annotated_metadata = getattr(validate_as(str), 'str_' + method)\n+    annotated_metadata = annotated_metadata(method_arg) if method_arg else annotated_metadata()\n+\n+    ta = TypeAdapter(Annotated[str, annotated_metadata])\n+    assert ta.validate_python(input_string) == expected_output\n+\n+\n+def test_string_validator_invalid() -> None:\n+    ta_contains = TypeAdapter(Annotated[str, validate_as(str).str_contains('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_contains.validate_python('tomato')\n+\n+    ta_starts_with = TypeAdapter(Annotated[str, validate_as(str).str_starts_with('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_starts_with.validate_python('tomato')\n+\n+    ta_ends_with = TypeAdapter(Annotated[str, validate_as(str).str_ends_with('potato')])\n+    with pytest.raises(ValidationError):\n+        ta_ends_with.validate_python('tomato')\n+\n+\n+def test_parse_int() -> None:\n+    ta_gt = TypeAdapter(Annotated[int, validate_as(int).gt(0)])\n+    assert ta_gt.validate_python(1) == 1\n+    assert ta_gt.validate_python('1') == 1\n+    with pytest.raises(ValidationError):\n+        ta_gt.validate_python(0)\n+\n+    ta_gt_strict = TypeAdapter(Annotated[int, validate_as(int, strict=True).gt(0)])\n+    assert ta_gt_strict.validate_python(1) == 1\n+    with pytest.raises(ValidationError):\n+        ta_gt_strict.validate_python('1')\n+    with pytest.raises(ValidationError):\n+        ta_gt_strict.validate_python(0)\n+\n+\n+def test_parse_str_to_int() -> None:\n+    ta = TypeAdapter(Annotated[int, validate_as(str).str_strip().validate_as(int)])\n+    assert ta.validate_python('1') == 1\n+    assert ta.validate_python(' 1 ') == 1\n+    with pytest.raises(ValidationError):\n+        ta.validate_python('a')\n+\n+\n+def test_predicates() -> None:\n+    ta_int = TypeAdapter(Annotated[int, validate_as(int).predicate(lambda x: x % 2 == 0)])\n+    assert ta_int.validate_python(2) == 2\n+    with pytest.raises(ValidationError):\n+        ta_int.validate_python(1)\n+\n+    ta_str = TypeAdapter(Annotated[str, validate_as(str).predicate(lambda x: x != 'potato')])\n+    assert ta_str.validate_python('tomato') == 'tomato'\n+    with pytest.raises(ValidationError):\n+        ta_str.validate_python('potato')\n+\n+\n+@pytest.mark.parametrize(\n+    'model, expected_val_schema, expected_ser_schema',\n+    [\n+        (\n+            Annotated[Union[int, str], validate_as() | validate_as(str)],\n+            {'anyOf': [{'type': 'integer'}, {'type': 'string'}]},\n+            {'anyOf': [{'type': 'integer'}, {'type': 'string'}]},\n+        ),\n+        (\n+            Annotated[int, validate_as() | validate_as(str).validate_as(int)],\n+            {'anyOf': [{'type': 'integer'}, {'type': 'string'}]},\n+            {'type': 'integer'},\n+        ),\n+        (\n+            Annotated[int, validate_as() | validate_as(str).transform(int)],\n+            {'anyOf': [{'type': 'integer'}, {'type': 'string'}]},\n+            {'anyOf': [{'type': 'integer'}, {'type': 'string'}]},\n+        ),\n+        (\n+            Annotated[int, validate_as() | validate_as(str).transform(int).validate_as(int)],\n+            {'anyOf': [{'type': 'integer'}, {'type': 'string'}]},\n+            {'type': 'integer'},\n+        ),\n+        (\n+            Annotated[int, validate_as(int).gt(0).lt(100)],\n+            {'type': 'integer', 'exclusiveMinimum': 0, 'exclusiveMaximum': 100},\n+            {'type': 'integer', 'exclusiveMinimum': 0, 'exclusiveMaximum': 100},\n+        ),\n+        (\n+            Annotated[int, validate_as(int).gt(0) | validate_as(int).lt(100)],\n+            {'anyOf': [{'type': 'integer', 'exclusiveMinimum': 0}, {'type': 'integer', 'exclusiveMaximum': 100}]},\n+            {'anyOf': [{'type': 'integer', 'exclusiveMinimum': 0}, {'type': 'integer', 'exclusiveMaximum': 100}]},\n+        ),\n+        (\n+            Annotated[List[int], validate_as().len(0, 100)],\n+            {'type': 'array', 'items': {'type': 'integer'}, 'maxItems': 100},\n+            {'type': 'array', 'items': {'type': 'integer'}, 'maxItems': 100},\n+        ),",
      "comment": "```suggestion\r\n        ),\r\n        (\r\n            Annotated[int, validate_as(str).transform(int)],\r\n            {'type': 'string'},\r\n            {'type': 'integer'},\r\n        ),\r\n```\r\nDoes this work? If so I think it's worth including as a test case here, since the others all seem to always include the output type as one of the allowed validation inputs; I think it's worth being explicit that if you don't explicitly make your pipeline accept the output type, it won't.",
      "comment_id": 1628177491,
      "user": "dmontagu",
      "created_at": "2024-06-05T17:44:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628177491"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]",
      "comment": "Is there a reason to use a list instead of a tuple here? It just stuck out to me that you use `validate_as = _Pipeline[Any, Any]([]).validate_as` down below, which means the function is actually a method call on a global instance, so I figured it might be a good idea to ensure instances are immutable.\r\n\r\nI guess to do that properly you might also want to make the `_Pipeline` dataclass frozen, and maybe also the various other dataclasses that comprise the `_Step`. (I guess this could be done easily by replacing `**_slots_true` with something like `**_frozen_and_slots_true`, if desirable.)\r\n\r\nI'm assuming there are no APIs that actually mutate a pipeline today but just feels like it would make it clear that that was an assumption. But I'm okay leaving as-is if you prefer or if it's otherwise an annoying/challenging thing to handle fully carefully.",
      "comment_id": 1628183067,
      "user": "dmontagu",
      "created_at": "2024-06-05T17:49:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628183067"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Transform the output of the previous step.\n+\n+        If used as the first step in a pipeline, the type of the field is used.\n+        That is, the transformation is applied to after the value is parsed to the field's type.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    def validate_as(self, tp: type[_NewOutT] | Any = Ellipsis, *, strict: bool = False) -> _Pipeline[_InT, Any]:\n+        \"\"\"Validate / parse the input into a new type.\n+\n+        If no type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+\n+        TODO: Eventually overload with type[_NewOutT] as one option and ellipsis or EllipsisType as the other,\n+        but this is blocked by 3.8 and 3.9 support.\n+        \"\"\"\n+        if tp is Ellipsis:\n+            tp = _FieldTypeMarker\n+        return _Pipeline[_InT, Any](self._steps + [_ValidateAs(tp, strict=strict)])\n+\n+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_ValidateAsDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len) -> _Pipeline[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> _Pipeline[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> _Pipeline[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> _Pipeline[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\n+\n+        We support most conditions from `annotated_types`, as well as regular expressions.\n+\n+        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n+        so you don't need to call this directly.\n+        \"\"\"\n+        return _Pipeline[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.constrain(_Eq(value))\n+\n+    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.constrain(_NotEq(value))\n+\n+    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.constrain(_In(values))\n+\n+    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.constrain(_NotIn(values))\n+\n+    # timezone methods\n+    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def datetime_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def datetime_with_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.lower)\n+\n+    # string methods\n+    def str_upper(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.upper)\n+\n+    def str_title(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.title)\n+\n+    def str_strip(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.strip)\n+\n+    def str_pattern(self: _Pipeline[_InT, str], pattern: str) -> _Pipeline[_InT, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def str_contains(self: _Pipeline[_InT, str], substring: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def str_starts_with(self: _Pipeline[_InT, str], prefix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def str_ends_with(self: _Pipeline[_InT, str], suffix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+    # operators\n+    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return _Pipeline([_PipelineOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return _Pipeline([_PipelineAnd(self, other)])\n+\n+    __and__ = then",
      "comment": "I think I understand why this API was added \u2014\u00a0as long as the input and output types of a pipeline are the same, then it's basically equivalent to do them in order. However, I'll note that sequencing the items like this may end up being unintuitive, in particular if you expect to get an error for each failure in the case of multiple independent validators, rather than just the first failure. I understand it's hard to \"fix\" that given that transformations are possible though.",
      "comment_id": 1628195119,
      "user": "dmontagu",
      "created_at": "2024-06-05T17:59:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628195119"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):",
      "comment": "I don't think we need to do it now, but I won't be surprised if we eventually want to make this type public, if only for type-hinting purposes (e.g., being able to write a function that requires a pipeline with a given input type and output type as the input). At least, in the typescript world, I not-infrequently find myself using the equivalent of `_Pipeline[T, S]` in zod as a type hint.",
      "comment_id": 1628197626,
      "user": "dmontagu",
      "created_at": "2024-06-05T18:01:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628197626"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]",
      "comment": "Agreed makes sense might as well make it immutable.",
      "comment_id": 1628197746,
      "user": "adriangb",
      "created_at": "2024-06-05T18:01:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628197746"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):",
      "comment": "I guess also if we want to let users define functions that return the result of calling `validate_as` etc., possibly with some of their own flags for whether to add certain validators etc., then they may want to annotate the return type of those functions using a public type.",
      "comment_id": 1628199567,
      "user": "dmontagu",
      "created_at": "2024-06-05T18:03:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628199567"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Transform the output of the previous step.\n+\n+        If used as the first step in a pipeline, the type of the field is used.\n+        That is, the transformation is applied to after the value is parsed to the field's type.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    def validate_as(self, tp: type[_NewOutT] | Any = Ellipsis, *, strict: bool = False) -> _Pipeline[_InT, Any]:\n+        \"\"\"Validate / parse the input into a new type.\n+\n+        If no type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+\n+        TODO: Eventually overload with type[_NewOutT] as one option and ellipsis or EllipsisType as the other,\n+        but this is blocked by 3.8 and 3.9 support.\n+        \"\"\"\n+        if tp is Ellipsis:\n+            tp = _FieldTypeMarker\n+        return _Pipeline[_InT, Any](self._steps + [_ValidateAs(tp, strict=strict)])\n+\n+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_ValidateAsDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len) -> _Pipeline[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> _Pipeline[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> _Pipeline[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> _Pipeline[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\n+\n+        We support most conditions from `annotated_types`, as well as regular expressions.\n+\n+        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n+        so you don't need to call this directly.\n+        \"\"\"\n+        return _Pipeline[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:",
      "comment": "I think it's worth putting this at either the start or the end of the list of all constraints (i.e., before `gt` or after `not_in`) , since it's really the most general of all of them",
      "comment_id": 1628205456,
      "user": "dmontagu",
      "created_at": "2024-06-05T18:07:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628205456"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Transform the output of the previous step.\n+\n+        If used as the first step in a pipeline, the type of the field is used.\n+        That is, the transformation is applied to after the value is parsed to the field's type.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    def validate_as(self, tp: type[_NewOutT] | Any = Ellipsis, *, strict: bool = False) -> _Pipeline[_InT, Any]:\n+        \"\"\"Validate / parse the input into a new type.\n+\n+        If no type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+\n+        TODO: Eventually overload with type[_NewOutT] as one option and ellipsis or EllipsisType as the other,\n+        but this is blocked by 3.8 and 3.9 support.\n+        \"\"\"\n+        if tp is Ellipsis:\n+            tp = _FieldTypeMarker\n+        return _Pipeline[_InT, Any](self._steps + [_ValidateAs(tp, strict=strict)])\n+\n+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_ValidateAsDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len) -> _Pipeline[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> _Pipeline[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> _Pipeline[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> _Pipeline[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\n+\n+        We support most conditions from `annotated_types`, as well as regular expressions.\n+\n+        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n+        so you don't need to call this directly.\n+        \"\"\"\n+        return _Pipeline[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.constrain(_Eq(value))\n+\n+    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.constrain(_NotEq(value))\n+\n+    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.constrain(_In(values))\n+\n+    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.constrain(_NotIn(values))\n+\n+    # timezone methods\n+    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def datetime_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def datetime_with_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.lower)\n+\n+    # string methods",
      "comment": "```suggestion\r\n    # string methods\r\n    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\r\n        return self.transform(str.lower)\r\n\r\n```",
      "comment_id": 1628206265,
      "user": "dmontagu",
      "created_at": "2024-06-05T18:08:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628206265"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +23,11 @@\n \n from pydantic._internal._internal_dataclass import slots_true as _slots_true\n \n+if sys.version_info < (3, 10):\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType",
      "comment": "What happens with Python < 3.10 then? What sort of type checker errors pop up?",
      "comment_id": 1628300785,
      "user": "adriangb",
      "created_at": "2024-06-05T19:04:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628300785"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +23,11 @@\n \n from pydantic._internal._internal_dataclass import slots_true as _slots_true\n \n+if sys.version_info < (3, 10):\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType",
      "comment": "When we use `EllipsisType`: \r\n\r\n```\r\n  /Users/programming/pydantic_work/pydantic/pydantic/experimental/pipeline.py:145:31 - error: Variable not allowed in type expression (reportGeneralTypeIssues)\r\n  /Users/programming/pydantic_work/pydantic/pydantic/experimental/pipeline.py:148:48 - error: Variable not allowed in type expression (reportGeneralTypeIssues)\r\n```",
      "comment_id": 1628417872,
      "user": "sydney-runkle",
      "created_at": "2024-06-05T20:52:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628417872"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 450,
      "side": "RIGHT",
      "diff_hunk": "@@ -434,6 +437,16 @@ def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.\n             s = s.copy()\n             s['to_upper'] = True\n             return s\n+\n+    # TODO: need to expand this logic to cover more cases, like datetimes, etc\n+    basic_builtin_types = [int, float, bool, str, list, dict, set, tuple, bytes]\n+    if func in basic_builtin_types:\n+        # handle case where func is a standard type constructor, like int, float, etc.\n+        # where we want to get more accurate schema information\n+        # The general challenge here is how do we infer the type of the output of a function\n+        # and attach that appropriately to the schema\n+        # For now, we're challenged by the coupling of validation and serialization info\n+        return cs.chain_schema([s, handler(func)])\n     return cs.no_info_after_validator_function(func, s)",
      "comment": "Eek, seeking feedback. This feels wrong, but works for these basic cases.\r\n\r\nI mentioned to @adriangb, I'd like to have a more in depth discussion about the coupling of our validation and serialization stuff. @davidhewitt \ud83d\udc40 ",
      "comment_id": 1628433345,
      "user": "sydney-runkle",
      "created_at": "2024-06-05T21:03:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628433345"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 441,
      "side": "RIGHT",
      "diff_hunk": "@@ -434,6 +437,16 @@ def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.\n             s = s.copy()\n             s['to_upper'] = True\n             return s\n+\n+    # TODO: need to expand this logic to cover more cases, like datetimes, etc",
      "comment": "Is this to support `transform(str)`? If so why not tell users to use `validate_as(str)`?",
      "comment_id": 1628434793,
      "user": "adriangb",
      "created_at": "2024-06-05T21:04:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628434793"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 441,
      "side": "RIGHT",
      "diff_hunk": "@@ -434,6 +437,16 @@ def _apply_transform(s: cs.CoreSchema | None, func: Callable[[Any], Any]) -> cs.\n             s = s.copy()\n             s['to_upper'] = True\n             return s\n+\n+    # TODO: need to expand this logic to cover more cases, like datetimes, etc",
      "comment": "Yeah we can... I was trying to improve JSON schema for this case @dmontagu mentioned:\r\n\r\n```\r\nta = TypeAdapter(Annotated[int, validate_as(str).transform(int)])\r\n```",
      "comment_id": 1628436832,
      "user": "sydney-runkle",
      "created_at": "2024-06-05T21:05:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628436832"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +23,11 @@\n \n from pydantic._internal._internal_dataclass import slots_true as _slots_true\n \n+if sys.version_info < (3, 10):\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType",
      "comment": "I've confirmed we're now back to this working:\r\n\r\n```py\r\nvalidate_as(str).transform(lambda x: x.strip()) # _Pipeline[Any, str]\r\n```",
      "comment_id": 1628453963,
      "user": "sydney-runkle",
      "created_at": "2024-06-05T21:18:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628453963"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Transform the output of the previous step.\n+\n+        If used as the first step in a pipeline, the type of the field is used.\n+        That is, the transformation is applied to after the value is parsed to the field's type.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    def validate_as(self, tp: type[_NewOutT] | Any = Ellipsis, *, strict: bool = False) -> _Pipeline[_InT, Any]:\n+        \"\"\"Validate / parse the input into a new type.\n+\n+        If no type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+\n+        TODO: Eventually overload with type[_NewOutT] as one option and ellipsis or EllipsisType as the other,\n+        but this is blocked by 3.8 and 3.9 support.\n+        \"\"\"\n+        if tp is Ellipsis:\n+            tp = _FieldTypeMarker\n+        return _Pipeline[_InT, Any](self._steps + [_ValidateAs(tp, strict=strict)])\n+\n+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_ValidateAsDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len) -> _Pipeline[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> _Pipeline[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> _Pipeline[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> _Pipeline[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\n+\n+        We support most conditions from `annotated_types`, as well as regular expressions.\n+\n+        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n+        so you don't need to call this directly.\n+        \"\"\"\n+        return _Pipeline[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.constrain(_Eq(value))\n+\n+    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.constrain(_NotEq(value))\n+\n+    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.constrain(_In(values))\n+\n+    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.constrain(_NotIn(values))\n+\n+    # timezone methods\n+    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def datetime_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def datetime_with_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.lower)\n+\n+    # string methods\n+    def str_upper(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.upper)\n+\n+    def str_title(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.title)\n+\n+    def str_strip(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.strip)\n+\n+    def str_pattern(self: _Pipeline[_InT, str], pattern: str) -> _Pipeline[_InT, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def str_contains(self: _Pipeline[_InT, str], substring: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def str_starts_with(self: _Pipeline[_InT, str], prefix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def str_ends_with(self: _Pipeline[_InT, str], suffix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+    # operators\n+    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return _Pipeline([_PipelineOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return _Pipeline([_PipelineAnd(self, other)])\n+\n+    __and__ = then",
      "comment": "I take it that you mean that for `validate_as(int).gt(0) & validate_as(int).gt(1)` you\u2019d expect `-1` to give two errors? Indeed it would only give one. I think that\u2019s reasonable behavior.\r\n\r\nI also think you\u2019re saying that for the case where you have a chain of constraints you could error for all of them eg `validate_as(int).gt(0).gt(1)` and indeed that will happen if they\u2019re all one after another and are known constraints, but not if they\u2019re custom predicates or there\u2019s a transformation between them. And also not when you use `&`. I think that\u2019s okay.\r\n\r\nThe one improvement we could make is \u201ccollapsing\u201d sequential constraints into one level eg `validate_as(int).predicate(lambda x: x > 0).predicate(lambda x: x % 2 == 0)` could give both errors despite it being arbitrary user code. That\u2019s a reasonable future feature request that shouldn\u2019t be too hard to implement.",
      "comment_id": 1628459436,
      "user": "adriangb",
      "created_at": "2024-06-05T21:24:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628459436"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +23,11 @@\n \n from pydantic._internal._internal_dataclass import slots_true as _slots_true\n \n+if sys.version_info < (3, 10):\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType",
      "comment": "Right but what errors do users get when using the API (if any)? We need to check pyright in strict mode.",
      "comment_id": 1628462968,
      "user": "adriangb",
      "created_at": "2024-06-05T21:27:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628462968"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]",
      "comment": "Agreed, I just implemented this change! And I learned some things about type hints with tuples and ellipses \ud83e\udd13, as well as the interactions between frozen dataclasses and generics.",
      "comment_id": 1628477914,
      "user": "sydney-runkle",
      "created_at": "2024-06-05T21:45:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628477914"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]",
      "comment": "New blog post idea - frozen dataclasess and generics \ud83d\ude02 ",
      "comment_id": 1628479282,
      "user": "sydney-runkle",
      "created_at": "2024-06-05T21:47:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628479282"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +23,11 @@\n \n from pydantic._internal._internal_dataclass import slots_true as _slots_true\n \n+if sys.version_info < (3, 10):\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType",
      "comment": "```py\r\nfrom pydantic.experimental.pipeline import validate_as\r\n\r\nint_pipeline = validate_as(str).validate_as(int)# _Pipeline[Any, int]\r\nstr_pipeline = validate_as(str).transform(lambda x: x.strip()) # _Pipeline[Any, str]\r\n\r\nreveal_type(int_pipeline)\r\n#> pydantic/test.py:9:13 - information: Type of \"int_pipeline\" is \"_Pipeline[Any, int]\"\r\nreveal_type(str_pipeline)\r\n#> pydantic/test.py:10:13 - information: Type of \"str_pipeline\" is \"_Pipeline[Any, str]\"\r\n```",
      "comment_id": 1628485009,
      "user": "sydney-runkle",
      "created_at": "2024-06-05T21:54:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628485009"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Transform the output of the previous step.\n+\n+        If used as the first step in a pipeline, the type of the field is used.\n+        That is, the transformation is applied to after the value is parsed to the field's type.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    def validate_as(self, tp: type[_NewOutT] | Any = Ellipsis, *, strict: bool = False) -> _Pipeline[_InT, Any]:\n+        \"\"\"Validate / parse the input into a new type.\n+\n+        If no type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+\n+        TODO: Eventually overload with type[_NewOutT] as one option and ellipsis or EllipsisType as the other,\n+        but this is blocked by 3.8 and 3.9 support.\n+        \"\"\"\n+        if tp is Ellipsis:\n+            tp = _FieldTypeMarker\n+        return _Pipeline[_InT, Any](self._steps + [_ValidateAs(tp, strict=strict)])\n+\n+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_ValidateAsDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len) -> _Pipeline[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> _Pipeline[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> _Pipeline[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> _Pipeline[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\n+\n+        We support most conditions from `annotated_types`, as well as regular expressions.\n+\n+        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n+        so you don't need to call this directly.\n+        \"\"\"\n+        return _Pipeline[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.constrain(_Eq(value))\n+\n+    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.constrain(_NotEq(value))\n+\n+    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.constrain(_In(values))\n+\n+    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.constrain(_NotIn(values))\n+\n+    # timezone methods\n+    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def datetime_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def datetime_with_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.lower)\n+\n+    # string methods\n+    def str_upper(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.upper)\n+\n+    def str_title(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.title)\n+\n+    def str_strip(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.strip)\n+\n+    def str_pattern(self: _Pipeline[_InT, str], pattern: str) -> _Pipeline[_InT, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def str_contains(self: _Pipeline[_InT, str], substring: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def str_starts_with(self: _Pipeline[_InT, str], prefix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def str_ends_with(self: _Pipeline[_InT, str], suffix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+    # operators\n+    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return _Pipeline([_PipelineOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return _Pipeline([_PipelineAnd(self, other)])\n+\n+    __and__ = then",
      "comment": "Yeah, my point was that I might expect `validate_as(int).predicate(lambda x: x > 0) & validate_as(int).predicate(lambda x: x % 2 == 0)` to produce two errors. (Well, knowing it's doing chaining, I'm not even sure if that's valid as written there since it repeats the `validate_as(int)`, but that's what my intuition would be for how I'd expect to use `&`.) I think it's reasonable for `validate_as(int).predicate(lambda x: x > 0).predicate(lambda x: x % 2 == 0)` to just produce one though.",
      "comment_id": 1628489129,
      "user": "dmontagu",
      "created_at": "2024-06-05T22:00:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628489129"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,18 +21,18 @@\n \n     from pydantic import GetCoreSchemaHandler\n \n+from pydantic._internal._internal_dataclass import frozen_true as _frozen_true\n from pydantic._internal._internal_dataclass import slots_true as _slots_true\n \n if sys.version_info < (3, 10):\n-    # TODO: remove this once we drop 3.9\n     EllipsisType = type(Ellipsis)\n else:\n     from types import EllipsisType\n \n __all__ = ['validate_as', 'validate_as_deferred', 'transform']\n \n \n-@dataclass(**_slots_true)\n+@dataclass(**_slots_true, **_frozen_true)",
      "comment": "I would have suggested just adding a constant to this module rather than a new constant in `_internal_dataclass`, I was thinking:\r\n\r\n```suggestion\r\n_slots_frozen = {**_slots_true, 'frozen': True}\r\n\r\n@dataclass(**_slots_frozen)\r\n```\r\nor similar, and repeated where it makes sense.\r\n\r\nHowever, I'll also note that there doesn't seem to be much downside to just doing `frozen=True` instead of `**_frozen_true`; the reason we need `**_slots_true` is for it to work with versions of python that didn't have the slots kwarg for dataclasses, but I guess all of our supported versions of python have `frozen` as a supported kwarg (or else you'd need an if-else where the `frozen_true` dict is defined for CI to pass).\r\n\r\nGiven you've made the change already I don't mind keeping it as-is if you don't want to change it again but I'm also okay with either of the above versions.",
      "comment_id": 1628493596,
      "user": "dmontagu",
      "created_at": "2024-06-05T22:06:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628493596"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +23,11 @@\n \n from pydantic._internal._internal_dataclass import slots_true as _slots_true\n \n+if sys.version_info < (3, 10):\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType",
      "comment": "Well we can't do static type checking there, but it does work at runtime:\r\n\r\n```py\r\nfrom typing import Annotated\r\n\r\nfrom pydantic.experimental.pipeline import validate_as\r\nfrom pydantic import TypeAdapter\r\n\r\nta = TypeAdapter(Annotated[int, validate_as(str).validate_as(...)])\r\nprint(ta.validate_python('1'))\r\n#> 1\r\n```",
      "comment_id": 1628501674,
      "user": "sydney-runkle",
      "created_at": "2024-06-05T22:17:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628501674"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +23,11 @@\n \n from pydantic._internal._internal_dataclass import slots_true as _slots_true\n \n+if sys.version_info < (3, 10):\n+    EllipsisType = type(Ellipsis)\n+else:\n+    from types import EllipsisType",
      "comment": "Indeed everything seems to work now!\r\n\r\n```python\r\n(\r\n    validate_as(...)\r\n    .transform(lambda x: x.strip())  # no error, no type checking (Any)\r\n    .transform(str.strip)\r\n    .transform(lambda x: x.strip())  # type checked as a string\r\n    .validate_as(int)\r\n    .transform(lambda x: x.strip())  # error, type checking as an int\r\n)\r\n```",
      "comment_id": 1628516890,
      "user": "adriangb",
      "created_at": "2024-06-05T22:34:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628516890"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Transform the output of the previous step.\n+\n+        If used as the first step in a pipeline, the type of the field is used.\n+        That is, the transformation is applied to after the value is parsed to the field's type.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    def validate_as(self, tp: type[_NewOutT] | Any = Ellipsis, *, strict: bool = False) -> _Pipeline[_InT, Any]:\n+        \"\"\"Validate / parse the input into a new type.\n+\n+        If no type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+\n+        TODO: Eventually overload with type[_NewOutT] as one option and ellipsis or EllipsisType as the other,\n+        but this is blocked by 3.8 and 3.9 support.\n+        \"\"\"\n+        if tp is Ellipsis:\n+            tp = _FieldTypeMarker\n+        return _Pipeline[_InT, Any](self._steps + [_ValidateAs(tp, strict=strict)])\n+\n+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_ValidateAsDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len) -> _Pipeline[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> _Pipeline[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> _Pipeline[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> _Pipeline[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\n+\n+        We support most conditions from `annotated_types`, as well as regular expressions.\n+\n+        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n+        so you don't need to call this directly.\n+        \"\"\"\n+        return _Pipeline[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.constrain(_Eq(value))\n+\n+    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.constrain(_NotEq(value))\n+\n+    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.constrain(_In(values))\n+\n+    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.constrain(_NotIn(values))\n+\n+    # timezone methods\n+    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def datetime_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def datetime_with_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.lower)\n+\n+    # string methods\n+    def str_upper(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.upper)\n+\n+    def str_title(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.title)\n+\n+    def str_strip(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.strip)\n+\n+    def str_pattern(self: _Pipeline[_InT, str], pattern: str) -> _Pipeline[_InT, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def str_contains(self: _Pipeline[_InT, str], substring: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def str_starts_with(self: _Pipeline[_InT, str], prefix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def str_ends_with(self: _Pipeline[_InT, str], suffix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+    # operators\n+    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return _Pipeline([_PipelineOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return _Pipeline([_PipelineAnd(self, other)])\n+\n+    __and__ = then",
      "comment": "My expectation would be the exact opposite: `&` is often a greedy operation e.g. `False & 1 / 0`. So I don't think there's a valid general intuition here. If we could make it behave as you expect I suspect there'd be complaints because it's unintuitive or because it is doing unnecessary work. I don't know why you'd expect `validate_as(int).predicate(lambda x: x > 0).predicate(lambda x: x % 2 == 0)` to produce just one error. Do you also expect `Field(min_length=10, pattern=...)` to produce a single error? In any case given that we can't really change the behavior and that no users have complained yet I suspect trying to determine what is most intuitive here is not a productive debate.",
      "comment_id": 1628523737,
      "user": "adriangb",
      "created_at": "2024-06-05T22:37:00Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1628523737"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Transform the output of the previous step.\n+\n+        If used as the first step in a pipeline, the type of the field is used.\n+        That is, the transformation is applied to after the value is parsed to the field's type.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    def validate_as(self, tp: type[_NewOutT] | Any = Ellipsis, *, strict: bool = False) -> _Pipeline[_InT, Any]:\n+        \"\"\"Validate / parse the input into a new type.\n+\n+        If no type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+\n+        TODO: Eventually overload with type[_NewOutT] as one option and ellipsis or EllipsisType as the other,\n+        but this is blocked by 3.8 and 3.9 support.\n+        \"\"\"\n+        if tp is Ellipsis:\n+            tp = _FieldTypeMarker\n+        return _Pipeline[_InT, Any](self._steps + [_ValidateAs(tp, strict=strict)])\n+\n+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_ValidateAsDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len) -> _Pipeline[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> _Pipeline[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> _Pipeline[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> _Pipeline[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\n+\n+        We support most conditions from `annotated_types`, as well as regular expressions.\n+\n+        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n+        so you don't need to call this directly.\n+        \"\"\"\n+        return _Pipeline[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.constrain(_Eq(value))\n+\n+    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.constrain(_NotEq(value))\n+\n+    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.constrain(_In(values))\n+\n+    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.constrain(_NotIn(values))\n+\n+    # timezone methods\n+    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def datetime_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def datetime_with_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.lower)\n+\n+    # string methods\n+    def str_upper(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.upper)\n+\n+    def str_title(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.title)\n+\n+    def str_strip(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.strip)\n+\n+    def str_pattern(self: _Pipeline[_InT, str], pattern: str) -> _Pipeline[_InT, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def str_contains(self: _Pipeline[_InT, str], substring: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def str_starts_with(self: _Pipeline[_InT, str], prefix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def str_ends_with(self: _Pipeline[_InT, str], suffix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+    # operators\n+    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return _Pipeline([_PipelineOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return _Pipeline([_PipelineAnd(self, other)])\n+\n+    __and__ = then",
      "comment": "I'm late to the conversation, but I'd expect it to short-circuit the same way it would for an if expression or any other useage (that I know of) for `and`.",
      "comment_id": 1684922314,
      "user": "grantmwilliams",
      "created_at": "2024-07-19T19:58:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1684922314"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Transform the output of the previous step.\n+\n+        If used as the first step in a pipeline, the type of the field is used.\n+        That is, the transformation is applied to after the value is parsed to the field's type.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    def validate_as(self, tp: type[_NewOutT] | Any = Ellipsis, *, strict: bool = False) -> _Pipeline[_InT, Any]:\n+        \"\"\"Validate / parse the input into a new type.\n+\n+        If no type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+\n+        TODO: Eventually overload with type[_NewOutT] as one option and ellipsis or EllipsisType as the other,\n+        but this is blocked by 3.8 and 3.9 support.\n+        \"\"\"\n+        if tp is Ellipsis:\n+            tp = _FieldTypeMarker\n+        return _Pipeline[_InT, Any](self._steps + [_ValidateAs(tp, strict=strict)])\n+\n+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_ValidateAsDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len) -> _Pipeline[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> _Pipeline[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> _Pipeline[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> _Pipeline[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\n+\n+        We support most conditions from `annotated_types`, as well as regular expressions.\n+\n+        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n+        so you don't need to call this directly.\n+        \"\"\"\n+        return _Pipeline[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.constrain(_Eq(value))\n+\n+    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.constrain(_NotEq(value))\n+\n+    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.constrain(_In(values))\n+\n+    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.constrain(_NotIn(values))\n+\n+    # timezone methods\n+    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def datetime_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def datetime_with_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.lower)\n+\n+    # string methods\n+    def str_upper(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.upper)\n+\n+    def str_title(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.title)\n+\n+    def str_strip(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.strip)\n+\n+    def str_pattern(self: _Pipeline[_InT, str], pattern: str) -> _Pipeline[_InT, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def str_contains(self: _Pipeline[_InT, str], substring: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def str_starts_with(self: _Pipeline[_InT, str], prefix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def str_ends_with(self: _Pipeline[_InT, str], suffix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+    # operators\n+    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return _Pipeline([_PipelineOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return _Pipeline([_PipelineAnd(self, other)])\n+\n+    __and__ = then",
      "comment": "@grantmwilliams I think it works as you'd expect then, right?",
      "comment_id": 1684928053,
      "user": "adriangb",
      "created_at": "2024-07-19T20:06:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1684928053"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9459,
      "file_path": "pydantic/experimental/pipeline.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,654 @@\n+\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n+\n+from __future__ import annotations\n+\n+import datetime\n+import operator\n+import re\n+from collections import deque\n+from collections.abc import Container\n+from dataclasses import dataclass\n+from decimal import Decimal\n+from functools import cached_property, partial\n+from typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n+\n+import annotated_types\n+from typing_extensions import Annotated\n+\n+if TYPE_CHECKING:\n+    from pydantic_core import core_schema as cs\n+\n+    from pydantic import GetCoreSchemaHandler\n+\n+from pydantic._internal._internal_dataclass import slots_true as _slots_true\n+\n+__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n+\n+\n+@dataclass(**_slots_true)\n+class _ValidateAs:\n+    tp: type[Any]\n+    strict: bool = False\n+\n+\n+@dataclass\n+class _ValidateAsDefer:\n+    func: Callable[[], type[Any]]\n+\n+    @cached_property\n+    def tp(self) -> type[Any]:\n+        return self.func()\n+\n+\n+@dataclass(**_slots_true)\n+class _Transform:\n+    func: Callable[[Any], Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineOr:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _PipelineAnd:\n+    left: _Pipeline[Any, Any]\n+    right: _Pipeline[Any, Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _Eq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _NotEq:\n+    value: Any\n+\n+\n+@dataclass(**_slots_true)\n+class _In:\n+    values: Container[Any]\n+\n+\n+@dataclass(**_slots_true)\n+class _NotIn:\n+    values: Container[Any]\n+\n+\n+_ConstraintAnnotation = Union[\n+    annotated_types.Le,\n+    annotated_types.Ge,\n+    annotated_types.Lt,\n+    annotated_types.Gt,\n+    annotated_types.Len,\n+    annotated_types.MultipleOf,\n+    annotated_types.Timezone,\n+    annotated_types.Interval,\n+    annotated_types.Predicate,\n+    # common predicates not included in annotated_types\n+    _Eq,\n+    _NotEq,\n+    _In,\n+    _NotIn,\n+    # regular expressions\n+    Pattern[str],\n+]\n+\n+\n+@dataclass(**_slots_true)\n+class _Constraint:\n+    constraint: _ConstraintAnnotation\n+\n+\n+_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n+\n+_InT = TypeVar('_InT')\n+_OutT = TypeVar('_OutT')\n+_NewOutT = TypeVar('_NewOutT')\n+\n+\n+class _FieldTypeMarker:\n+    pass\n+\n+\n+@dataclass(**_slots_true)\n+class _Pipeline(Generic[_InT, _OutT]):\n+    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n+\n+    _steps: list[_Step]\n+\n+    def transform(\n+        self,\n+        func: Callable[[_OutT], _NewOutT],\n+    ) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Transform the output of the previous step.\n+\n+        If used as the first step in a pipeline, the type of the field is used.\n+        That is, the transformation is applied to after the value is parsed to the field's type.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_Transform(func)])\n+\n+    def validate_as(self, tp: type[_NewOutT] | Any = Ellipsis, *, strict: bool = False) -> _Pipeline[_InT, Any]:\n+        \"\"\"Validate / parse the input into a new type.\n+\n+        If no type is provided, the type of the field is used.\n+\n+        Types are parsed in Pydantic's `lax` mode by default,\n+        but you can enable `strict` mode by passing `strict=True`.\n+\n+        TODO: Eventually overload with type[_NewOutT] as one option and ellipsis or EllipsisType as the other,\n+        but this is blocked by 3.8 and 3.9 support.\n+        \"\"\"\n+        if tp is Ellipsis:\n+            tp = _FieldTypeMarker\n+        return _Pipeline[_InT, Any](self._steps + [_ValidateAs(tp, strict=strict)])\n+\n+    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n+        is fully defined.\n+\n+        This is useful when you need to reference the class in it's own type annotations.\n+        \"\"\"\n+        return _Pipeline[_InT, _NewOutT](self._steps + [_ValidateAsDefer(func)])\n+\n+    # constraints\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len) -> _Pipeline[_InT, _NewOutLen]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDiv], constraint: annotated_types.MultipleOf\n+    ) -> _Pipeline[_InT, _NewOutDiv]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n+    ) -> _Pipeline[_InT, _NewOutDatetime]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(\n+        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n+    ) -> _Pipeline[_InT, _NewOutInterval]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]:\n+        ...\n+\n+    @overload\n+    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]:\n+        ...\n+\n+    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n+        \"\"\"Constrain a value to meet a certain condition.\n+\n+        We support most conditions from `annotated_types`, as well as regular expressions.\n+\n+        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n+        so you don't need to call this directly.\n+        \"\"\"\n+        return _Pipeline[_InT, _OutT](self._steps + [_Constraint(constraint)])\n+\n+    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n+        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Gt(gt))\n+\n+    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n+        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n+        return self.constrain(annotated_types.Lt(lt))\n+\n+    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n+        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Ge(ge))\n+\n+    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n+        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n+        return self.constrain(annotated_types.Le(le))\n+\n+    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n+        \"\"\"Constrain a value to have a certain length.\"\"\"\n+        return self.constrain(annotated_types.Len(min_len, max_len))\n+\n+    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]:\n+        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n+        return self.constrain(annotated_types.MultipleOf(multiple_of))\n+\n+    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:\n+        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n+        return self.constrain(annotated_types.Predicate(func))\n+\n+    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n+        return self.constrain(_Eq(value))\n+\n+    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n+        return self.constrain(_NotEq(value))\n+\n+    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to be in a certain set.\"\"\"\n+        return self.constrain(_In(values))\n+\n+    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n+        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n+        return self.constrain(_NotIn(values))\n+\n+    # timezone methods\n+    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(None))\n+\n+    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(...))\n+\n+    def datetime_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n+\n+    def datetime_with_tz(\n+        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None\n+    ) -> _Pipeline[_InT, datetime.datetime]:\n+        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n+\n+    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.lower)\n+\n+    # string methods\n+    def str_upper(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.upper)\n+\n+    def str_title(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.title)\n+\n+    def str_strip(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n+        return self.transform(str.strip)\n+\n+    def str_pattern(self: _Pipeline[_InT, str], pattern: str) -> _Pipeline[_InT, str]:\n+        return self.constrain(re.compile(pattern))\n+\n+    def str_contains(self: _Pipeline[_InT, str], substring: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: substring in v)\n+\n+    def str_starts_with(self: _Pipeline[_InT, str], prefix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.startswith(prefix))\n+\n+    def str_ends_with(self: _Pipeline[_InT, str], suffix: str) -> _Pipeline[_InT, str]:\n+        return self.predicate(lambda v: v.endswith(suffix))\n+\n+    # operators\n+    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n+        return _Pipeline([_PipelineOr(self, other)])\n+\n+    __or__ = otherwise\n+\n+    def then(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n+        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n+        return _Pipeline([_PipelineAnd(self, other)])\n+\n+    __and__ = then",
      "comment": "@adriangb I've only tested it a bit, but it seems to work exactly as expected.",
      "comment_id": 1684939220,
      "user": "grantmwilliams",
      "created_at": "2024-07-19T20:23:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/9459#discussion_r1684939220"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9843,
      "file_path": "pydantic/dataclasses.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,12 +201,7 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n \n         original_cls = cls\n \n-        config_dict = config\n-        if config_dict is None:\n-            # if not explicitly provided, read from the type\n-            cls_config = getattr(cls, '__pydantic_config__', None)\n-            if cls_config is not None:\n-                config_dict = cls_config\n+        config_dict = config or getattr(cls, '__pydantic_config__', None)",
      "comment": "`config or` is not equivalent to `config is not None`, hence the failing test. We also loose the code comment which might be useful. Considering the really small perf. improvement, maybe it's not worth keeping this PR?\r\n\r\nOr maybe we change it as:\r\n\r\n```suggestion\r\n        config_dict = config if config is not None else getattr(cls, '__pydantic_config__', None)\r\n```\r\n\r\n---\r\n\r\nWithout talking about performance, from a readability perspective, this one liner seems better imo so good to merge it as well",
      "comment_id": 1681756800,
      "user": "Viicos",
      "created_at": "2024-07-17T21:12:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/9843#discussion_r1681756800"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9843,
      "file_path": "pydantic/dataclasses.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -253,10 +248,7 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         cls.__pydantic_complete__ = pydantic_complete  # type: ignore\n         return cls\n \n-    if _cls is None:\n-        return create_dataclass\n-\n-    return create_dataclass(_cls)\n+    return create_dataclass if _cls is None else create_dataclass(_cls)",
      "comment": "Imho I think I prefer the current form:\r\n\r\n```python\r\nif _cls is None:\r\n    return create_dataclass\r\n\r\nreturn create_dataclass(_cls)\r\n```\r\n\r\nAs it makes it easier to understand the two cases, when the decorator is applied as is (`@dataclass`) and with arguments (`@datalcass(...)`).\r\n\r\nBut feel free to ignore, this is very minor",
      "comment_id": 1681761336,
      "user": "Viicos",
      "created_at": "2024-07-17T21:14:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/9843#discussion_r1681761336"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9843,
      "file_path": "pydantic/dataclasses.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -253,10 +248,7 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         cls.__pydantic_complete__ = pydantic_complete  # type: ignore\n         return cls\n \n-    if _cls is None:\n-        return create_dataclass\n-\n-    return create_dataclass(_cls)\n+    return create_dataclass if _cls is None else create_dataclass(_cls)",
      "comment": "I think I prefer the one liner here, but thanks for the feedback!",
      "comment_id": 1683061793,
      "user": "sydney-runkle",
      "created_at": "2024-07-18T15:33:44Z",
      "url": "https://github.com/pydantic/pydantic/pull/9843#discussion_r1683061793"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9843,
      "file_path": "pydantic/dataclasses.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -253,10 +248,7 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n         cls.__pydantic_complete__ = pydantic_complete  # type: ignore\n         return cls\n \n-    if _cls is None:\n-        return create_dataclass\n-\n-    return create_dataclass(_cls)\n+    return create_dataclass if _cls is None else create_dataclass(_cls)",
      "comment": "One nice thing about this new approach is that it removes the need for the noqa above",
      "comment_id": 1683251963,
      "user": "sydney-runkle",
      "created_at": "2024-07-18T17:42:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/9843#discussion_r1683251963"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9843,
      "file_path": "pydantic/dataclasses.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,12 +201,7 @@ def create_dataclass(cls: type[Any]) -> type[PydanticDataclass]:\n \n         original_cls = cls\n \n-        config_dict = config\n-        if config_dict is None:\n-            # if not explicitly provided, read from the type\n-            cls_config = getattr(cls, '__pydantic_config__', None)\n-            if cls_config is not None:\n-                config_dict = cls_config\n+        config_dict = config if config is not None else getattr(cls, '__pydantic_config__', None)",
      "comment": "```suggestion\r\n        # if config is not explicitly provided, try to read it from the type\r\n        config_dict = config if config is not None else getattr(cls, '__pydantic_config__', None)\r\n```",
      "comment_id": 1683253365,
      "user": "sydney-runkle",
      "created_at": "2024-07-18T17:43:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/9843#discussion_r1683253365"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...",
      "comment": "We could simplify even more by disregarding `ast.Assign`, which isn't possible in a Pydantic model:\r\n\r\n```python\r\nclass A(BaseModel):\r\n  a = 1\r\n# throws PydanticUserError\r\n```",
      "comment_id": 1258660533,
      "user": "Viicos",
      "created_at": "2023-07-10T18:01:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1258660533"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...",
      "comment": "If this is also true for dataclasses, I would be ok with taking the simpler route.",
      "comment_id": 1260059463,
      "user": "davidhewitt",
      "created_at": "2023-07-11T17:30:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260059463"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...",
      "comment": "dataclasses can have simple assignments (same goes for Pydantic dataclasses). But they aren't taken into account:\r\n\r\n```python\r\nfrom pydantic.dataclasses import dataclass\r\n\r\n@dataclass\r\nclass A:\r\n  a: int = 1\r\n  b = 2\r\n\r\nA.__pydantic_fields__\r\n#> {'a': FieldInfo(annotation=int, required=False, default=1, init_var=False, kw_only=False)}\r\n# Same goes for A.__dataclass_fields__, which is used to build __pydantic_fields__\r\n```",
      "comment_id": 1260639748,
      "user": "Viicos",
      "created_at": "2023-07-12T06:04:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260639748"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal)\n+        # TODO should we issue a UserWarning to indicate that docstrings won't be\n+        # taken into account?",
      "comment": "I think it is fine to have empty string as description in these cases. No need to warn.",
      "comment_id": 1260945664,
      "user": "Kludex",
      "created_at": "2023-07-12T10:10:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260945664"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.",
      "comment": "```suggestion\r\n\r\n    Returns:\r\n        A mapping containing attribute names and their corresponding docstring.\r\n```",
      "comment_id": 1260945781,
      "user": "Kludex",
      "created_at": "2023-07-12T10:10:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260945781"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.",
      "comment": "```suggestion\r\n    \"\"\"Map model attributes and their corresponding docstring.\r\n```",
      "comment_id": 1260946130,
      "user": "Kludex",
      "created_at": "2023-07-12T10:10:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260946130"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)",
      "comment": "From the [Python documentation](https://docs.python.org/3/library/inspect.html#inspect.getsource):\r\n\r\n\"A [TypeError](https://docs.python.org/3/library/exceptions.html#TypeError) is raised if the object is a built-in module, class, or function.\"\r\n\r\nWe can't have this scenario here?",
      "comment_id": 1260947151,
      "user": "Kludex",
      "created_at": "2023-07-12T10:11:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260947151"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal)\n+        # TODO should we issue a UserWarning to indicate that docstrings won't be\n+        # taken into account?\n+        return {}\n+\n+    text = textwrap.dedent(source)",
      "comment": "Why is this necessary? The AST should be valid without it. \ud83e\udd14 ",
      "comment_id": 1260948165,
      "user": "Kludex",
      "created_at": "2023-07-12T10:12:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260948165"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal)\n+        # TODO should we issue a UserWarning to indicate that docstrings won't be\n+        # taken into account?\n+        return {}\n+\n+    text = textwrap.dedent(source)\n+\n+    tree = ast.parse(text).body[0]\n+    if not isinstance(tree, ast.ClassDef):\n+        raise TypeError(f\"Expected '{ast.ClassDef.__name__}', but received '{cls}' instead\")",
      "comment": "Is there a scenario in which the first (and only element) in the body is not a `ast.ClassDef`?",
      "comment_id": 1260953051,
      "user": "Kludex",
      "created_at": "2023-07-12T10:16:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260953051"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id",
      "comment": "What's the scenario that we need to supporrt `ast.Assign`? It's not possible to build a `BaseModel` with them, is it?",
      "comment_id": 1260980117,
      "user": "Kludex",
      "created_at": "2023-07-12T10:40:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260980117"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)",
      "comment": "`cls` is supposed to be a `BaseModel`, but I'll add the `TypeError` just to be safe",
      "comment_id": 1260998233,
      "user": "Viicos",
      "created_at": "2023-07-12T10:57:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1260998233"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)",
      "comment": "I don't like defensive programming. If you know is a `BaseModel`, no need to add it.",
      "comment_id": 1261000025,
      "user": "Kludex",
      "created_at": "2023-07-12T10:59:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1261000025"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal)\n+        # TODO should we issue a UserWarning to indicate that docstrings won't be\n+        # taken into account?\n+        return {}\n+\n+    text = textwrap.dedent(source)",
      "comment": "I think it's a [leftover](https://github.com/danields761/class-doc/blob/9b122d85ce667d096ebee75a49350bbdbd48686d/class_doc.py#L266) from `class-doc`, I'll remove it",
      "comment_id": 1261000740,
      "user": "Viicos",
      "created_at": "2023-07-12T10:59:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1261000740"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id",
      "comment": "See https://github.com/pydantic/pydantic/pull/6563#discussion_r1260639748",
      "comment_id": 1261001840,
      "user": "Viicos",
      "created_at": "2023-07-12T11:00:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1261001840"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal)\n+        # TODO should we issue a UserWarning to indicate that docstrings won't be\n+        # taken into account?\n+        return {}\n+\n+    text = textwrap.dedent(source)\n+\n+    tree = ast.parse(text).body[0]\n+    if not isinstance(tree, ast.ClassDef):\n+        raise TypeError(f\"Expected '{ast.ClassDef.__name__}', but received '{cls}' instead\")",
      "comment": "If the argument passed to `cls` isn't a class, but that shouldn't happen",
      "comment_id": 1261002476,
      "user": "Viicos",
      "created_at": "2023-07-12T11:01:21Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1261002476"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal)\n+        # TODO should we issue a UserWarning to indicate that docstrings won't be\n+        # taken into account?\n+        return {}\n+\n+    text = textwrap.dedent(source)",
      "comment": "In fact it is required to avoid `IndentationError`s when models are defined in nested levels (e.g. in functions).",
      "comment_id": 1261521785,
      "user": "Viicos",
      "created_at": "2023-07-12T17:48:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1261521785"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Iterable\n+\n+\n+def _get_assign_targets(node: ast.Assign | ast.AnnAssign) -> Iterable[str]:\n+    if isinstance(node, ast.Assign):\n+        for target in node.targets:\n+            if isinstance(target, ast.Tuple):\n+                yield from (el.id for el in target.elts)\n+            else:\n+                yield target.id\n+    else:\n+        # `target` can only be `ast.Name` in the context of a `BaseModel` subclass definition\n+        yield node.target.id\n+\n+\n+def _extract_docs(cls_def: ast.ClassDef) -> dict[str, str]:\n+\n+    nodes_docs_pairs = [\n+        (node, inspect.cleandoc(next_node.value.s))\n+        for node, next_node in zip(cls_def.body, cls_def.body[1:])\n+        if isinstance(node, (ast.Assign, ast.AnnAssign))  # e.g. a: int / a = 1...\n+        if isinstance(next_node, ast.Expr)  # ...with next_node being a docstring\n+        if isinstance(next_node.value, ast.Str)\n+    ]\n+\n+    doc_mapping: dict[str, str] = {}\n+\n+    for node, docs in nodes_docs_pairs:\n+        for target in _get_assign_targets(node):\n+            doc_mapping[target] = docs\n+\n+    return doc_mapping\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Returns a mapping of the model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        source = inspect.getsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal)\n+        # TODO should we issue a UserWarning to indicate that docstrings won't be\n+        # taken into account?\n+        return {}\n+\n+    text = textwrap.dedent(source)",
      "comment": "<details><summary>MRE</summary>\r\n\r\n```python\r\ndef test():\r\n    class Model(BaseModel):\r\n        a: int\r\n        \"\"\"doc\"\"\"\r\n\r\n    source = inspect.getsource(Model)\r\n    tree = ast.parse(source)\r\n\r\ntest()\r\n#> IndentationError: unexpected indent\r\n```\r\n\r\n</details> ",
      "comment_id": 1261570548,
      "user": "Viicos",
      "created_at": "2023-07-12T18:22:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1261570548"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def test_model_no_docs_extraction():\n+    class Model(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert Model.model_fields['a'].description is None\n+    assert Model.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    class Model(BaseModel):",
      "comment": "Unfortunately `inspect.getsource` isn't working as expected with classes. Tests are failing under 3.9 because prior to https://github.com/python/cpython/pull/10307, the following would happen:\r\n\r\n<details><summary>MRE</summary>\r\n\r\n```python\r\nimport inspect\r\n\r\n\r\ndef test1():\r\n    class Model:\r\n        a = 1\r\n\r\n    print(inspect.getsource(Model))\r\n\r\n\r\ndef test2():\r\n    class Model:\r\n        a = 2\r\n\r\n    print(inspect.getsource(Model))\r\n\r\n\r\ntest1()\r\n#> uses Model with a = 1\r\ntest2()\r\n#> uses Model with a = 1 (wrong!)\r\n```\r\n</details>\r\n\r\nThis has been fixed since then, but I encountered this one: https://github.com/python/cpython/issues/106727\r\n\r\nI think this isn't a big deal, as users will probably not define two models with the same name in the same module.",
      "comment_id": 1262899854,
      "user": "Viicos",
      "created_at": "2023-07-13T18:01:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1262899854"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def test_model_no_docs_extraction():\n+    class Model(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert Model.model_fields['a'].description is None\n+    assert Model.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    class Model(BaseModel):",
      "comment": "That kinda sounds like a dealbreaker to me. I don\u2019t know why you think it\u2019s not common, it seems to me like it would happen all the time in tests.",
      "comment_id": 1262906003,
      "user": "adriangb",
      "created_at": "2023-07-13T18:08:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1262906003"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def test_model_no_docs_extraction():\n+    class Model(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert Model.model_fields['a'].description is None\n+    assert Model.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    class Model(BaseModel):",
      "comment": "Imo it's not common from a user perspective (as this only occurs if in the same module). But it is indeed way more common in tests \ud83d\ude15",
      "comment_id": 1262909246,
      "user": "Viicos",
      "created_at": "2023-07-13T18:12:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1262909246"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def test_model_no_docs_extraction():\n+    class Model(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert Model.model_fields['a'].description is None\n+    assert Model.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    class Model(BaseModel):",
      "comment": "Ah yes didn't think about that \ud83d\ude05 That was what I was afraid of by using `inspect`, and I don't see any other path except shipping our own source parsing logic, which probably isn't a good idea",
      "comment_id": 1262932132,
      "user": "Viicos",
      "created_at": "2023-07-13T18:38:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1262932132"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def test_model_no_docs_extraction():\n+    class Model(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert Model.model_fields['a'].description is None\n+    assert Model.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    class Model(BaseModel):",
      "comment": "I'll try to improve class detection on the Python side (see the related issue on cpython), but unfortunately it will not be able to cover all edge cases, such as:\r\n\r\n```python\r\nif cond:\r\n    class A: pass\r\nelse:\r\n    class A: pass        \r\n```\r\n\r\nAs this feature would be off by default, users could be warned about the potential unexpected behavior in the documentation. I'll let you decide on the output of this PR",
      "comment_id": 1264671656,
      "user": "Viicos",
      "created_at": "2023-07-16T12:07:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1264671656"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def test_model_no_docs_extraction():\n+    class Model(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert Model.model_fields['a'].description is None\n+    assert Model.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    class Model(BaseModel):",
      "comment": "So Python got some improvements since then:\r\n- https://github.com/python/cpython/pull/106815\r\n- https://github.com/python/cpython/pull/106968\r\n\r\nIt works way better if a method is defined on the class (thanks to `__code__.co_firstlineno`), but can still pick the wrong class otherwise.",
      "comment_id": 1289761082,
      "user": "Viicos",
      "created_at": "2023-08-10T08:29:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1289761082"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def test_model_no_docs_extraction():\n+    class Model(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert Model.model_fields['a'].description is None\n+    assert Model.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    class Model(BaseModel):",
      "comment": "Am I understanding correctly that this misbehavior is only on Python<=3.9?\r\n\r\nAlso, when it gets the wrong source, does it lead to actual exceptions being raised, or does it just retrieve the docstrings incorrectly?\r\n\r\nIf it only affects <=3.9 and fails gracefully in the sense that it just doesn't get the docstrings correctly, then unless I'm missing something I think the issues with `inspect.getsource` maybe shouldn't be a dealbreaker since it would require all of the following conditions to be met for it to cause problems:\r\n\r\n* You are using Python<=3.9\r\n* You have opted into the new config setting for this functionality\r\n* You have defined a model with the same name multiple times in the same module\r\n* You require the description attribute for the `FieldInfo` must be correct in the context you are using it (I mention this because most tests, even if affected by this, won't be failing because of it or testing what it affects)\r\n* You aren't happy to (or aren't aware that you can) explicitly specify the description in `Field(...)` for affected attributes\r\n\r\nIn particular, for the case of writing tests that you mentioned @adriangb I would think that this would very rarely cause problems for tests that aren't explicitly testing this functionality.\r\n\r\nIf nothing else, it seems reasonable to me to emit a warning if this particular config flag is set in `Python<=3.9`.\r\n\r\n(That said, it looks to me like there are other test failures happening right now, not just caused by this issue.)",
      "comment_id": 1296479550,
      "user": "dmontagu",
      "created_at": "2023-08-16T21:59:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1296479550"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,139 @@\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def test_model_no_docs_extraction():\n+    class Model(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert Model.model_fields['a'].description is None\n+    assert Model.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    class Model(BaseModel):",
      "comment": "The following PR:\r\n- https://github.com/python/cpython/pull/10307\r\n\r\nwas introduced in Python 3.9, and fixes class detection when they are nested in other classes.\r\n\r\nUp until now, it would still fail with the following:\r\n\r\n```python\r\nimport inspect\r\n\r\nclass Model:\r\n    a = 1\r\n\r\nclass Model:\r\n    a = 2\r\n\r\nprint(Model.a)\r\n#> 2\r\nprint(inspect.getsource(Model))\r\n#> class Model:\r\n#>     a = 1\r\n```\r\n\r\nThis got improved with the following PR (it will now pick the last class definition):\r\n- https://github.com/python/cpython/pull/106815\r\n\r\nBut still can get it wrong if you're doing something like:\r\n\r\n```python\r\nif True:\r\n    class Model:\r\n        a = 1\r\nelse:\r\n    class Model:\r\n        a = 2\r\n# Which really is an uncommon edge case\r\n```\r\n\r\n> when it gets the wrong source, does it lead to actual exceptions being raised, or does it just retrieve the docstrings incorrectly?\r\n\r\nIt will not raise currently, as I'm applying field docstrings in a safe way, but I could maybe raise if we encounter unexpected fields (I'll have to see if it's doable when inheritance is being used).\r\n\r\nSo to summarize, all of your conditions should indeed be met, except:\r\n- You are using Python<=3.9\r\n- it fails gracefully (can be fixed as I said)\r\n\r\nI'll be off for a while and will continue working on this in September if this is still accepted\r\n\r\nEdit: we are now able to accurately find the right class by walking up the frames. The solution is a bit more complex/hard to understand but work as expected, and we still fallback to the former solution if using stack frames doesn't work.",
      "comment_id": 1296808413,
      "user": "Viicos",
      "created_at": "2023-08-17T07:41:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1296808413"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,74 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Sequence\n+\n+from ._model_construction import ModelMetaclass\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Map model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        lines, _ = inspect.findsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal),\n+        # we don't want to error here.\n+        return {}\n+    else:\n+        source: Sequence[str] = []\n+        frame = inspect.currentframe()\n+\n+        if frame is None:\n+            return {}\n+\n+        while frame:\n+            if frame.f_code is ModelMetaclass.__new__.__code__:\n+                lnum = frame.f_back.f_lineno\n+                source = inspect.getblock(lines[lnum - 1 : lnum + 1])\n+                break\n+            frame = frame.f_back\n+\n+        if not source:\n+            return {}\n+\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))",
      "comment": "It's possible for the body of a class (or function) to contain some non-whitespace text at a lower indentation level than the class, in the form of a comment or the contents of some multiline string (docstring or otherwise). In that case `dedent` will still return something that's invalid syntax. A more robust method is to wrap the source in a function or class and then extract the body in the AST.",
      "comment_id": 1367958933,
      "user": "alexmojaki",
      "created_at": "2023-10-22T19:38:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1367958933"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,76 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Sequence\n+\n+from ._model_construction import ModelMetaclass\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Map model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        lines, _ = inspect.findsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal),\n+        # we don't want to error here.\n+        return {}\n+    else:\n+        source: Sequence[str] = []\n+        frame = inspect.currentframe()\n+\n+        if frame is None:\n+            return {}\n+\n+        while frame:\n+            if frame.f_code is ModelMetaclass.__new__.__code__:\n+                lnum = frame.f_back.f_lineno",
      "comment": "I think it'd be safer to keep walking up the stack from this point until you see a line such that `line.strip().startswith(\"class \")`. I'm worried someone might inherit from the metaclass and then call `super().__new__`.",
      "comment_id": 1367959659,
      "user": "alexmojaki",
      "created_at": "2023-10-22T19:44:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1367959659"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,74 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Sequence\n+\n+from ._model_construction import ModelMetaclass\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Map model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        lines, _ = inspect.findsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal),\n+        # we don't want to error here.\n+        return {}\n+    else:\n+        source: Sequence[str] = []\n+        frame = inspect.currentframe()\n+\n+        if frame is None:\n+            return {}\n+\n+        while frame:\n+            if frame.f_code is ModelMetaclass.__new__.__code__:\n+                lnum = frame.f_back.f_lineno\n+                source = inspect.getblock(lines[lnum - 1 : lnum + 1])\n+                break\n+            frame = frame.f_back\n+\n+        if not source:\n+            return {}\n+\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))",
      "comment": "Do you have an example when `dedent` would still not be enough? I'll add a test with it and try to implement the workaround",
      "comment_id": 1367959923,
      "user": "Viicos",
      "created_at": "2023-10-22T19:45:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1367959923"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,74 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Sequence\n+\n+from ._model_construction import ModelMetaclass\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Map model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        lines, _ = inspect.findsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal),\n+        # we don't want to error here.\n+        return {}\n+    else:\n+        source: Sequence[str] = []\n+        frame = inspect.currentframe()\n+\n+        if frame is None:\n+            return {}\n+\n+        while frame:\n+            if frame.f_code is ModelMetaclass.__new__.__code__:\n+                lnum = frame.f_back.f_lineno\n+                source = inspect.getblock(lines[lnum - 1 : lnum + 1])\n+                break\n+            frame = frame.f_back\n+\n+        if not source:\n+            return {}\n+\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))",
      "comment": "```python\r\ndef foo():\r\n    class A:\r\n        def bar(self):\r\n            print(\"\"\"\"\r\nAn inconveniently dedented string...\r\n            \"\"\")\r\n```",
      "comment_id": 1367960255,
      "user": "alexmojaki",
      "created_at": "2023-10-22T19:48:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1367960255"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,76 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any, Sequence\n+\n+from ._model_construction import ModelMetaclass\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Map model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        lines, _ = inspect.findsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal),\n+        # we don't want to error here.\n+        return {}\n+    else:\n+        source: Sequence[str] = []\n+        frame = inspect.currentframe()\n+\n+        if frame is None:\n+            return {}\n+\n+        while frame:\n+            if frame.f_code is ModelMetaclass.__new__.__code__:\n+                lnum = frame.f_back.f_lineno",
      "comment": "Indeed, and with this solution we are able to make it work with dataclasses/TypedDicts",
      "comment_id": 1369027739,
      "user": "Viicos",
      "created_at": "2023-10-23T17:32:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369027739"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,84 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None\n+\n+    while frame and frame.f_back:\n+        lnum = frame.f_back.f_lineno\n+        if isinstance(lnum, int) and len(lines) >= lnum and re.match(fr\"$class\\s+{cls_name}\", lines[lnum - 1].strip()):",
      "comment": "```suggestion\r\n        if isinstance(lnum, int) and len(lines) >= lnum and re.match(fr\"^class\\s+{cls_name}\", lines[lnum - 1].strip()):\r\n```",
      "comment_id": 1369045571,
      "user": "alexmojaki",
      "created_at": "2023-10-23T17:48:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369045571"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None\n+\n+    while frame and frame.f_back:\n+        lnum = frame.f_back.f_lineno\n+        if isinstance(lnum, int) and len(lines) >= lnum and re.match(fr\"class\\s+{cls_name}\", lines[lnum - 1].strip()):\n+            source = inspect.getblock(lines[lnum - 1 :])  # type: ignore",
      "comment": "I might be able to remove the `# type: ignore` with https://github.com/python/typeshed/pull/10920",
      "comment_id": 1369177308,
      "user": "Viicos",
      "created_at": "2023-10-23T19:28:02Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369177308"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None",
      "comment": "```suggestion\r\nclass DocstringVisitor(ast.NodeVisitor):\r\n    def __init__(self) -> None:\r\n        self.attrs: dict[str, str] = {}\r\n        self.previous_node: ast.AST | None = None\r\n\r\n    def visit(self, node: ast.AST) -> Any:\r\n        node_result = super().visit(node)\r\n        self.previous_node = node\r\n        return node_result\r\n\r\n    def visit_Expr(self, node: ast.Expr) -> Any:\r\n        if (\r\n            isinstance(node.value, ast.Str)\r\n            and isinstance(self.previous_node, ast.AnnAssign)\r\n            and isinstance(self.previous_node.target, ast.Name)\r\n        ):\r\n            docstring = inspect.cleandoc(node.value.s)\r\n            self.attrs[self.previous_node.target.id] = docstring\r\n```\r\n\r\nDoes this work?\r\n\r\nPersonally I'm not convinced that using a visitor is clearer or better than your first implementation. Visiting every node in the tree is a waste, and I don't like having to think about the order in which the visit methods get called.",
      "comment_id": 1369906061,
      "user": "alexmojaki",
      "created_at": "2023-10-24T09:54:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369906061"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None\n+\n+    while frame and frame.f_back:\n+        lnum = frame.f_back.f_lineno",
      "comment": "```suggestion\r\n    while frame:\r\n        lnum = frame.f_lineno\r\n```",
      "comment_id": 1369914295,
      "user": "alexmojaki",
      "created_at": "2023-10-24T10:02:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369914295"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None\n+\n+    while frame and frame.f_back:\n+        lnum = frame.f_back.f_lineno\n+        if isinstance(lnum, int) and len(lines) >= lnum and re.match(fr'class\\s+{cls_name}', lines[lnum - 1].strip()):",
      "comment": "This is just checking that the line number in the current frame 'fits' the list of lines we already have. We should be getting the lines corresponding to the current frame.",
      "comment_id": 1369918160,
      "user": "alexmojaki",
      "created_at": "2023-10-24T10:04:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369918160"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None\n+\n+    while frame and frame.f_back:\n+        lnum = frame.f_back.f_lineno\n+        if isinstance(lnum, int) and len(lines) >= lnum and re.match(fr\"class\\s+{cls_name}\", lines[lnum - 1].strip()):\n+            source = inspect.getblock(lines[lnum - 1 :])  # type: ignore",
      "comment": "Or you could just change the type of `source` to `Sequence[str]`.",
      "comment_id": 1369918621,
      "user": "alexmojaki",
      "created_at": "2023-10-24T10:05:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369918621"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 102,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None\n+\n+    while frame and frame.f_back:\n+        lnum = frame.f_back.f_lineno\n+        if isinstance(lnum, int) and len(lines) >= lnum and re.match(fr'class\\s+{cls_name}', lines[lnum - 1].strip()):\n+            source = inspect.getblock(lines[lnum - 1 :])  # type: ignore\n+            break\n+        frame = frame.f_back\n+\n+    if not source:\n+        return None\n+\n+    return source\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Map model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        lines, _ = inspect.findsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal),\n+        # we don't want to error here.\n+        return {}\n+\n+    # We first try to fetch the source lines by walking back the frames:\n+    source = _extract_source_from_frame(lines, cls.__name__)\n+    if not source:\n+        # Fallback to how inspect fetch the source lines, might not work as expected\n+        # if two classes have the same name in the same source file.\n+        source, _ = inspect.getsourcelines(cls)\n+\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if not dedent_source.startswith('class'):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def _():\\n{dedent_source}'\n+\n+    visitor = DocstringVisitor()\n+    visitor.visit(ast.parse(dedent_source))",
      "comment": "```suggestion\r\n    # Prevent syntax errors if the class is indented (e.g. inside a function block)\r\n    source_str = textwrap.indent(''.join(source), '    ')\r\n    source_str = f'def _():\\n{source_str}'\r\n\r\n    visitor = DocstringVisitor()\r\n    visitor.visit(ast.parse(source_str))\r\n```\r\n\r\nSuggestion to avoid an `if`",
      "comment_id": 1369924622,
      "user": "alexmojaki",
      "created_at": "2023-10-24T10:11:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369924622"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_fields.py",
      "line": 220,
      "side": "RIGHT",
      "diff_hunk": "@@ -208,6 +215,10 @@ def collect_model_fields(  # noqa: C901\n         for field in fields.values():\n             field.apply_typevars_map(typevars_map, types_namespace)\n \n+    if config_wrapper.use_attributes_docstring:\n+        fields_docs = extract_docstrings_from_cls(cls)\n+        _update_fields_from_docstrings(fields, fields_docs)",
      "comment": "Can you move this logic inside `_update_fields_from_docstrings` so that both calls can just be this?\r\n\r\n```suggestion\r\n    _update_fields_from_docstrings(cls, fields, config_wrapper)\r\n```",
      "comment_id": 1369927785,
      "user": "alexmojaki",
      "created_at": "2023-10-24T10:14:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369927785"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1168,
      "side": "RIGHT",
      "diff_hunk": "@@ -1144,6 +1150,12 @@ def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -> core_schema.Co\n                         )[0]\n \n                     field_info = FieldInfo.from_annotation(annotation)\n+                    if (\n+                        field_docstrings is not None\n+                        and field_info.description is None\n+                        and field_name in field_docstrings\n+                    ):\n+                        field_info.description = field_docstrings[field_name]",
      "comment": "Could you skip this and call `_update_fields_from_docstrings` at the end?",
      "comment_id": 1369930208,
      "user": "alexmojaki",
      "created_at": "2023-10-24T10:16:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369930208"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,204 @@\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter, create_model\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def test_model_no_docs_extraction():\n+    class ModelNoDocs(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert ModelNoDocs.model_fields['a'].description is None\n+    assert ModelNoDocs.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    class ModelDocs(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy that won't be used for d\"\"\"\n+\n+        e: Annotated[int, Field(description='Real description')]\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int\n+        \"\"\"G docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attributes_docstring=True,\n+        )\n+\n+    assert ModelDocs.model_fields['a'].description == 'A docs'\n+    assert ModelDocs.model_fields['b'].description == 'B docs'\n+    assert ModelDocs.model_fields['c'].description is None\n+    assert ModelDocs.model_fields['d'].description is None\n+    assert ModelDocs.model_fields['e'].description == 'Real description'\n+    assert ModelDocs.model_fields['g'].description == 'G docs'\n+\n+\n+def test_model_docs_duplicate_class():\n+    \"\"\"Ensure source parsing is working correctly when using frames.\"\"\"\n+\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attributes_docstring=True,\n+        )\n+\n+    class MyModel(BaseModel):\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attributes_docstring=True,\n+        )\n+\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+\n+def test_model_docs_dedented_string():\n+    # fmt: off\n+    class MyModel(BaseModel):\n+        def bar(self):\n+            \"\"\"\n+An inconveniently dedented string\n+            \"\"\"\n+\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attributes_docstring=True,\n+        )\n+    # fmt: on\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_dataclass_no_docs_extraction():\n+    @pydantic_dataclass\n+    class ModelDCNoDocs:\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert ModelDCNoDocs.__pydantic_fields__['a'].description is None\n+    assert ModelDCNoDocs.__pydantic_fields__['b'].description is None\n+\n+\n+def test_dataclass_docs_extraction():\n+    @pydantic_dataclass(config=ConfigDict(use_attributes_docstring=True))\n+    class ModelDCDocs:\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int = 1\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy_method that won't be used for d\"\"\"\n+\n+        e: int = Field(1, description='Real description')\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int = 1\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int = 1\n+        \"\"\"G docs\"\"\"\n+\n+        h = 1\n+        \"\"\"H docs\"\"\"\n+\n+        i: Annotated[int, Field(description='Real description')] = 1\n+        \"\"\"Won't be used\"\"\"\n+\n+    assert ModelDCDocs.__pydantic_fields__['a'].description == 'A docs'\n+    assert ModelDCDocs.__pydantic_fields__['b'].description == 'B docs'\n+    assert ModelDCDocs.__pydantic_fields__['c'].description is None\n+    assert ModelDCDocs.__pydantic_fields__['d'].description is None\n+    assert ModelDCDocs.__pydantic_fields__['e'].description == 'Real description'\n+    assert ModelDCDocs.__pydantic_fields__['g'].description == 'G docs'\n+    assert ModelDCDocs.__pydantic_fields__['i'].description == 'Real description'\n+\n+\n+def test_typeddict():\n+    class ModelTDNoDocs(TypedDict):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+    ta = TypeAdapter(ModelTDNoDocs)\n+    assert ta.json_schema() == {\n+        'properties': {'a': {'title': 'A', 'type': 'integer'}},\n+        'required': ['a'],\n+        'title': 'ModelTDNoDocs',\n+        'type': 'object',\n+    }\n+\n+    class ModelTDDocs(TypedDict):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        __pydantic_config__ = ConfigDict(use_attributes_docstring=True)\n+\n+    ta = TypeAdapter(ModelTDDocs)\n+\n+    assert ta.json_schema() == {\n+        'properties': {'a': {'title': 'A', 'type': 'integer', 'description': 'A docs'}},\n+        'required': ['a'],\n+        'title': 'ModelTDDocs',\n+        'type': 'object',\n+    }\n+\n+\n+def test_typeddict_as_field():\n+    class ModelTDAsField(TypedDict):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        __pydantic_config__ = ConfigDict(use_attributes_docstring=True)\n+\n+    class ModelWithTDField(BaseModel):\n+        td: ModelTDAsField\n+\n+    a_property = ModelWithTDField.model_json_schema()['$defs']['ModelTDAsField']['properties']['a']\n+    assert a_property['description'] == 'A docs'\n+\n+\n+def test_create_model():\n+    MyModel = create_model(",
      "comment": "I think it'd be good to add a `class MyModel` inside this function to check that it doesn't incorrectly fallback to `inspect`.",
      "comment_id": 1369939955,
      "user": "alexmojaki",
      "created_at": "2023-10-24T10:26:09Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1369939955"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None",
      "comment": "Before applying the suggestion/reverting to the old solution, I'll let maintainers decide what they prefer.",
      "comment_id": 1370414896,
      "user": "Viicos",
      "created_at": "2023-10-24T15:31:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1370414896"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None",
      "comment": "Docstring says: _Return the frame of the caller or None if this is not possible._\r\n\r\nand it is typed as `Frame | None`, so I prefer to be safe",
      "comment_id": 1370415946,
      "user": "Viicos",
      "created_at": "2023-10-24T15:32:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1370415946"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None",
      "comment": "What I mean is that the while loop below will be skipped and `source` will still be empty, and then `if not source: return None` will trigger, so it's the same either way.\r\n\r\nOn that note, you could also immediately `return source` instead of `break`.",
      "comment_id": 1370420947,
      "user": "alexmojaki",
      "created_at": "2023-10-24T15:35:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1370420947"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,6 +23,11 @@ class ModelNoDocs(BaseModel):\n \n \n def test_model_docs_extraction():\n+\n+    # Using a couple dummy decorators to make sure the frame is pointing at\n+    # the `class` line:\n+    @dec_noop",
      "comment": "I think this would be most useful in `test_model_docs_duplicate_class`, because if decorators are a problem for the frame method then this might only be passing because it's falling back to `inspect`.",
      "comment_id": 1370425203,
      "user": "alexmojaki",
      "created_at": "2023-10-24T15:38:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1370425203"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1168,
      "side": "RIGHT",
      "diff_hunk": "@@ -1144,6 +1150,12 @@ def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -> core_schema.Co\n                         )[0]\n \n                     field_info = FieldInfo.from_annotation(annotation)\n+                    if (\n+                        field_docstrings is not None\n+                        and field_info.description is None\n+                        and field_name in field_docstrings\n+                    ):\n+                        field_info.description = field_docstrings[field_name]",
      "comment": "I don't know if this is possible, considering the fact that `TypedDict`s are handled differently, and not with `FieldInfo` objects:\r\nhttps://github.com/pydantic/pydantic/blob/93e4d233e3ca5bce1e4ac018cbade55f26513a6c/pydantic/_internal/_generate_schema.py#L1123\r\nhttps://github.com/pydantic/pydantic/blob/93e4d233e3ca5bce1e4ac018cbade55f26513a6c/pydantic/_internal/_generate_schema.py#L1146-L1149",
      "comment_id": 1370694948,
      "user": "Viicos",
      "created_at": "2023-10-24T19:02:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1370694948"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 102,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None\n+\n+    while frame and frame.f_back:\n+        lnum = frame.f_back.f_lineno\n+        if isinstance(lnum, int) and len(lines) >= lnum and re.match(fr'class\\s+{cls_name}', lines[lnum - 1].strip()):\n+            source = inspect.getblock(lines[lnum - 1 :])  # type: ignore\n+            break\n+        frame = frame.f_back\n+\n+    if not source:\n+        return None\n+\n+    return source\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Map model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        lines, _ = inspect.findsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal),\n+        # we don't want to error here.\n+        return {}\n+\n+    # We first try to fetch the source lines by walking back the frames:\n+    source = _extract_source_from_frame(lines, cls.__name__)\n+    if not source:\n+        # Fallback to how inspect fetch the source lines, might not work as expected\n+        # if two classes have the same name in the same source file.\n+        source, _ = inspect.getsourcelines(cls)\n+\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if not dedent_source.startswith('class'):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def _():\\n{dedent_source}'\n+\n+    visitor = DocstringVisitor()\n+    visitor.visit(ast.parse(dedent_source))",
      "comment": "Will it work if the source is indented with tabs and not spaces (or even not 4 spaces)?\r\n(tried the suggestion and made some tests fail)",
      "comment_id": 1370717107,
      "user": "Viicos",
      "created_at": "2023-10-24T19:25:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1370717107"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 102,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None\n+\n+    while frame and frame.f_back:\n+        lnum = frame.f_back.f_lineno\n+        if isinstance(lnum, int) and len(lines) >= lnum and re.match(fr'class\\s+{cls_name}', lines[lnum - 1].strip()):\n+            source = inspect.getblock(lines[lnum - 1 :])  # type: ignore\n+            break\n+        frame = frame.f_back\n+\n+    if not source:\n+        return None\n+\n+    return source\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any]) -> dict[str, str]:\n+    \"\"\"Map model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    try:\n+        lines, _ = inspect.findsource(cls)\n+    except OSError:\n+        # Source can't be parsed (maybe because running in an interactive terminal),\n+        # we don't want to error here.\n+        return {}\n+\n+    # We first try to fetch the source lines by walking back the frames:\n+    source = _extract_source_from_frame(lines, cls.__name__)\n+    if not source:\n+        # Fallback to how inspect fetch the source lines, might not work as expected\n+        # if two classes have the same name in the same source file.\n+        source, _ = inspect.getsourcelines(cls)\n+\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if not dedent_source.startswith('class'):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def _():\\n{dedent_source}'\n+\n+    visitor = DocstringVisitor()\n+    visitor.visit(ast.parse(dedent_source))",
      "comment": "I'm guessing it would work if the indentation is not 4 spaces, but not if it was tabs. So never mind. Good catch.",
      "comment_id": 1370720234,
      "user": "alexmojaki",
      "created_at": "2023-10-24T19:28:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1370720234"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,89 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(lines: list[str], cls_name: str) -> list[str] | None:\n+    source: list[str] = []\n+    frame = inspect.currentframe()\n+\n+    if frame is None:\n+        return None\n+\n+    while frame and frame.f_back:\n+        lnum = frame.f_back.f_lineno\n+        if isinstance(lnum, int) and len(lines) >= lnum and re.match(fr'class\\s+{cls_name}', lines[lnum - 1].strip()):",
      "comment": "Good catch, this is why tests are currently failing by the way: coincidentally, when walking up the frames, `lnum` is equal to `226` at some point (somewhere in `pydantic/dataclasses.py`) which happen to be on the same line number where another class with the same name is defined in tests:\r\n\r\nhttps://github.com/pydantic/pydantic/blob/4bc1c1a2974558c64145d48a8277bd700236bea0/tests/test_docs_extraction.py#L226\r\n\r\nI still need to implement this",
      "comment_id": 1370799800,
      "user": "Viicos",
      "created_at": "2023-10-24T20:54:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1370799800"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/config.py",
      "line": 862,
      "side": "RIGHT",
      "diff_hunk": "@@ -857,5 +857,12 @@ class Model(BaseModel):\n     ```\n     \"\"\"\n \n+    use_attribute_docstrings: bool\n+    \"\"\"\n+    Whether attributes docstring should be used for `FieldInfo.description`.",
      "comment": "```suggestion\r\n    Whether docstrings of attributes (bare string literals immediately following the attribute declaration)\r\n    should be used for field descriptions.\r\n    \r\n    ```py\r\n    from pydantic import BaseModel, ConfigDict, Field\r\n    \r\n    \r\n    class Model(BaseModel):\r\n        model_config = ConfigDict(use_attribute_docstrings=True)\r\n    \r\n        x: str\r\n        \"\"\"\r\n        Example of an attribute docstring\r\n        \"\"\"\r\n    \r\n        y: int = Field(description=\"Description in Field\")\r\n        \"\"\"\r\n        Description in Field overrides attribute docstring\r\n        \"\"\"\r\n    \r\n    \r\n    print(Model.model_fields[\"x\"].description)\r\n    # > Example of an attribute docstring\r\n    print(Model.model_fields[\"y\"].description)\r\n    # > Description in Field\r\n    ```\r\n\r\n    This requires the source code of the class to be available at runtime.\r\n```",
      "comment_id": 1371480362,
      "user": "alexmojaki",
      "created_at": "2023-10-25T10:00:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1371480362"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,79 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import re\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _extract_source_from_frame(cls_name: str) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        lnum = frame.f_lineno\n+        try:\n+            lines, _ = inspect.findsource(frame)\n+        except OSError:\n+            # Source can't be parsed (maybe because running in an interactive terminal),\n+            # we don't want to error here.\n+            continue",
      "comment": "I think the tests are currently stuck in an infinite loop at this point.\r\n\r\nAre you able to run tests locally before you push?",
      "comment_id": 1371488580,
      "user": "alexmojaki",
      "created_at": "2023-10-25T10:07:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1371488580"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+import textwrap\n+\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter, create_model\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def dec_noop(obj):\n+    return obj\n+\n+\n+def test_model_no_docs_extraction():\n+    class MyModel(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.model_fields['a'].description is None\n+    assert MyModel.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    # Using a couple dummy decorators to make sure the frame is pointing at\n+    # the `class` line:\n+    @dec_noop\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy that won't be used for d\"\"\"\n+\n+        e: Annotated[int, Field(description='Real description')]\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int\n+        \"\"\"G docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+    assert MyModel.model_fields['c'].description is None\n+    assert MyModel.model_fields['d'].description is None\n+    assert MyModel.model_fields['e'].description == 'Real description'\n+    assert MyModel.model_fields['g'].description == 'G docs'\n+\n+\n+def test_model_docs_duplicate_class():\n+    \"\"\"Ensure source parsing is working correctly when using frames.\"\"\"\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+    # With https://github.com/python/cpython/pull/106815/ introduced,\n+    # inspect will fallback to the last found class in the source file.\n+    # The following is to ensure using frames will still get the correct one\n+    if True:\n+\n+        class MyModelEnclosed(BaseModel):\n+            a: int\n+            \"\"\"A docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    else:\n+\n+        class MyModelEnclosed(BaseModel):\n+            b: int\n+            \"\"\"B docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    assert MyModelEnclosed.model_fields['a'].description == 'A docs'",
      "comment": "```suggestion\r\n        class MyModel(BaseModel):\r\n            a: int\r\n            \"\"\"A docs\"\"\"\r\n\r\n            model_config = ConfigDict(\r\n                use_attribute_docstrings=True,\r\n            )\r\n\r\n    else:\r\n\r\n        class MyModel(BaseModel):\r\n            b: int\r\n            \"\"\"B docs\"\"\"\r\n\r\n            model_config = ConfigDict(\r\n                use_attribute_docstrings=True,\r\n            )\r\n\r\n    assert MyModel.model_fields['a'].description == 'A docs'\r\n```",
      "comment_id": 1371490000,
      "user": "alexmojaki",
      "created_at": "2023-10-25T10:08:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1371490000"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+import textwrap\n+\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter, create_model\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def dec_noop(obj):\n+    return obj\n+\n+\n+def test_model_no_docs_extraction():\n+    class MyModel(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.model_fields['a'].description is None\n+    assert MyModel.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    # Using a couple dummy decorators to make sure the frame is pointing at\n+    # the `class` line:\n+    @dec_noop\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy that won't be used for d\"\"\"\n+\n+        e: Annotated[int, Field(description='Real description')]\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int\n+        \"\"\"G docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+    assert MyModel.model_fields['c'].description is None\n+    assert MyModel.model_fields['d'].description is None\n+    assert MyModel.model_fields['e'].description == 'Real description'\n+    assert MyModel.model_fields['g'].description == 'G docs'\n+\n+\n+def test_model_docs_duplicate_class():\n+    \"\"\"Ensure source parsing is working correctly when using frames.\"\"\"\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+    # With https://github.com/python/cpython/pull/106815/ introduced,\n+    # inspect will fallback to the last found class in the source file.\n+    # The following is to ensure using frames will still get the correct one\n+    if True:\n+\n+        class MyModelEnclosed(BaseModel):\n+            a: int\n+            \"\"\"A docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    else:\n+\n+        class MyModelEnclosed(BaseModel):\n+            b: int\n+            \"\"\"B docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    assert MyModelEnclosed.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_dedented_string():\n+    # fmt: off\n+    class MyModel(BaseModel):\n+        def bar(self):\n+            \"\"\"\n+An inconveniently dedented string\n+            \"\"\"\n+\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+    # fmt: on\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_inheritance():\n+    class FirstModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    class SecondModel(FirstModel):\n+        a: int\n+        \"\"\"A overridden docs\"\"\"\n+\n+    assert SecondModel.model_fields['a'].description == 'A docs'\n+    assert SecondModel.model_fields['a'].description == 'A overridden docs'\n+    assert SecondModel.model_fields['b'].description == 'B docs'",
      "comment": "```suggestion\r\n    class MyModel(BaseModel):\r\n        a: int\r\n        \"\"\"A docs\"\"\"\r\n\r\n        b: int\r\n        \"\"\"B docs\"\"\"\r\n\r\n        model_config = ConfigDict(\r\n            use_attribute_docstrings=True,\r\n        )\r\n\r\n    FirstModel = MyModel\r\n\r\n    class MyModel(FirstModel):\r\n        a: int\r\n        \"\"\"A overridden docs\"\"\"\r\n\r\n    assert FirstModel.model_fields['a'].description == 'A docs'\r\n    assert MyModel.model_fields['a'].description == 'A overridden docs'\r\n    assert MyModel.model_fields['b'].description == 'B docs'\r\n```",
      "comment_id": 1371490907,
      "user": "alexmojaki",
      "created_at": "2023-10-25T10:09:33Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1371490907"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 270,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+import textwrap\n+\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter, create_model\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def dec_noop(obj):\n+    return obj\n+\n+\n+def test_model_no_docs_extraction():\n+    class MyModel(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.model_fields['a'].description is None\n+    assert MyModel.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    # Using a couple dummy decorators to make sure the frame is pointing at\n+    # the `class` line:\n+    @dec_noop\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy that won't be used for d\"\"\"\n+\n+        e: Annotated[int, Field(description='Real description')]\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int\n+        \"\"\"G docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+    assert MyModel.model_fields['c'].description is None\n+    assert MyModel.model_fields['d'].description is None\n+    assert MyModel.model_fields['e'].description == 'Real description'\n+    assert MyModel.model_fields['g'].description == 'G docs'\n+\n+\n+def test_model_docs_duplicate_class():\n+    \"\"\"Ensure source parsing is working correctly when using frames.\"\"\"\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+    # With https://github.com/python/cpython/pull/106815/ introduced,\n+    # inspect will fallback to the last found class in the source file.\n+    # The following is to ensure using frames will still get the correct one\n+    if True:\n+\n+        class MyModelEnclosed(BaseModel):\n+            a: int\n+            \"\"\"A docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    else:\n+\n+        class MyModelEnclosed(BaseModel):\n+            b: int\n+            \"\"\"B docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    assert MyModelEnclosed.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_dedented_string():\n+    # fmt: off\n+    class MyModel(BaseModel):\n+        def bar(self):\n+            \"\"\"\n+An inconveniently dedented string\n+            \"\"\"\n+\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+    # fmt: on\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_inheritance():\n+    class FirstModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    class SecondModel(FirstModel):\n+        a: int\n+        \"\"\"A overridden docs\"\"\"\n+\n+    assert SecondModel.model_fields['a'].description == 'A docs'\n+    assert SecondModel.model_fields['a'].description == 'A overridden docs'\n+    assert SecondModel.model_fields['b'].description == 'B docs'\n+\n+\n+def test_dataclass_no_docs_extraction():\n+    @pydantic_dataclass\n+    class MyModel:\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.__pydantic_fields__['a'].description is None\n+    assert MyModel.__pydantic_fields__['b'].description is None\n+\n+\n+def test_dataclass_docs_extraction():\n+    @pydantic_dataclass(config=ConfigDict(use_attribute_docstrings=True))\n+    @dec_noop\n+    class MyModel:\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int = 1\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy_method that won't be used for d\"\"\"\n+\n+        e: int = Field(1, description='Real description')\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int = 1\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int = 1\n+        \"\"\"G docs\"\"\"\n+\n+        h = 1\n+        \"\"\"H docs\"\"\"\n+\n+        i: Annotated[int, Field(description='Real description')] = 1\n+        \"\"\"Won't be used\"\"\"\n+\n+    assert MyModel.__pydantic_fields__['a'].description == 'A docs'\n+    assert MyModel.__pydantic_fields__['b'].description == 'B docs'\n+    assert MyModel.__pydantic_fields__['c'].description is None\n+    assert MyModel.__pydantic_fields__['d'].description is None\n+    assert MyModel.__pydantic_fields__['e'].description == 'Real description'\n+    assert MyModel.__pydantic_fields__['g'].description == 'G docs'\n+    assert MyModel.__pydantic_fields__['i'].description == 'Real description'\n+\n+\n+def test_typeddict():\n+    class MyModel(TypedDict):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+    ta = TypeAdapter(MyModel)\n+    assert ta.json_schema() == {\n+        'properties': {'a': {'title': 'A', 'type': 'integer'}},\n+        'required': ['a'],\n+        'title': 'MyModel',\n+        'type': 'object',\n+    }\n+\n+    class MyModel(TypedDict):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        __pydantic_config__ = ConfigDict(use_attribute_docstrings=True)\n+\n+    ta = TypeAdapter(MyModel)\n+\n+    assert ta.json_schema() == {\n+        'properties': {'a': {'title': 'A', 'type': 'integer', 'description': 'A docs'}},\n+        'required': ['a'],\n+        'title': 'MyModel',\n+        'type': 'object',\n+    }\n+\n+\n+def test_typeddict_as_field():\n+    class ModelTDAsField(TypedDict):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        __pydantic_config__ = ConfigDict(use_attribute_docstrings=True)\n+\n+    class MyModel(BaseModel):\n+        td: ModelTDAsField\n+\n+    a_property = MyModel.model_json_schema()['$defs']['ModelTDAsField']['properties']['a']\n+    assert a_property['description'] == 'A docs'\n+\n+\n+def test_create_model_test():\n+    # Duplicate class creation to ensure create_model\n+    # doesn't fallback to using inspect, which could\n+    # in turn use the wrong class:\n+    class CreatedModel(BaseModel):\n+        foo: int = 123\n+        \"\"\"Shouldn't be used\"\"\"\n+\n+    CreatedModel = create_model(\n+        'CreatedModel',\n+        foo=(int, 123),\n+        __config__=ConfigDict(use_attribute_docstrings=True),\n+    )\n+\n+    assert CreatedModel.model_fields['foo'].description is None",
      "comment": "```suggestion\r\n    class MyModel(BaseModel):\r\n        foo: int = 123\r\n        \"\"\"Shouldn't be used\"\"\"\r\n\r\n    assert MyModel.model_fields['foo'].description == \"Shouldn't be used\"\r\n\r\n    MyModel = create_model(\r\n        'MyModel',\r\n        foo=(int, 123),\r\n        __config__=ConfigDict(use_attribute_docstrings=True),\r\n    )\r\n\r\n    assert MyModel.model_fields['foo'].description is None\r\n```",
      "comment_id": 1371491982,
      "user": "alexmojaki",
      "created_at": "2023-10-25T10:10:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1371491982"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 287,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,287 @@\n+import textwrap\n+\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter, create_model\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+\n+def dec_noop(obj):\n+    return obj\n+\n+\n+def test_model_no_docs_extraction():\n+    class MyModel(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.model_fields['a'].description is None\n+    assert MyModel.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    # Using a couple dummy decorators to make sure the frame is pointing at\n+    # the `class` line:\n+    @dec_noop\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy that won't be used for d\"\"\"\n+\n+        e: Annotated[int, Field(description='Real description')]\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int\n+        \"\"\"G docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+    assert MyModel.model_fields['c'].description is None\n+    assert MyModel.model_fields['d'].description is None\n+    assert MyModel.model_fields['e'].description == 'Real description'\n+    assert MyModel.model_fields['g'].description == 'G docs'\n+\n+\n+def test_model_docs_duplicate_class():\n+    \"\"\"Ensure source parsing is working correctly when using frames.\"\"\"\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+    # With https://github.com/python/cpython/pull/106815/ introduced,\n+    # inspect will fallback to the last found class in the source file.\n+    # The following is to ensure using frames will still get the correct one\n+    if True:\n+\n+        class MyModelEnclosed(BaseModel):\n+            a: int\n+            \"\"\"A docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    else:\n+\n+        class MyModelEnclosed(BaseModel):\n+            b: int\n+            \"\"\"B docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    assert MyModelEnclosed.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_dedented_string():\n+    # fmt: off\n+    class MyModel(BaseModel):\n+        def bar(self):\n+            \"\"\"\n+An inconveniently dedented string\n+            \"\"\"\n+\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+    # fmt: on\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_inheritance():\n+    class FirstModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    class SecondModel(FirstModel):\n+        a: int\n+        \"\"\"A overridden docs\"\"\"\n+\n+    assert SecondModel.model_fields['a'].description == 'A docs'\n+    assert SecondModel.model_fields['a'].description == 'A overridden docs'\n+    assert SecondModel.model_fields['b'].description == 'B docs'\n+\n+\n+def test_dataclass_no_docs_extraction():\n+    @pydantic_dataclass\n+    class MyModel:\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.__pydantic_fields__['a'].description is None\n+    assert MyModel.__pydantic_fields__['b'].description is None\n+\n+\n+def test_dataclass_docs_extraction():\n+    @pydantic_dataclass(config=ConfigDict(use_attribute_docstrings=True))\n+    @dec_noop\n+    class MyModel:\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int = 1\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy_method that won't be used for d\"\"\"\n+\n+        e: int = Field(1, description='Real description')\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int = 1\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int = 1\n+        \"\"\"G docs\"\"\"\n+\n+        h = 1\n+        \"\"\"H docs\"\"\"\n+\n+        i: Annotated[int, Field(description='Real description')] = 1\n+        \"\"\"Won't be used\"\"\"\n+\n+    assert MyModel.__pydantic_fields__['a'].description == 'A docs'\n+    assert MyModel.__pydantic_fields__['b'].description == 'B docs'\n+    assert MyModel.__pydantic_fields__['c'].description is None\n+    assert MyModel.__pydantic_fields__['d'].description is None\n+    assert MyModel.__pydantic_fields__['e'].description == 'Real description'\n+    assert MyModel.__pydantic_fields__['g'].description == 'G docs'\n+    assert MyModel.__pydantic_fields__['i'].description == 'Real description'\n+\n+\n+def test_typeddict():\n+    class MyModel(TypedDict):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+    ta = TypeAdapter(MyModel)\n+    assert ta.json_schema() == {\n+        'properties': {'a': {'title': 'A', 'type': 'integer'}},\n+        'required': ['a'],\n+        'title': 'MyModel',\n+        'type': 'object',\n+    }\n+\n+    class MyModel(TypedDict):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        __pydantic_config__ = ConfigDict(use_attribute_docstrings=True)\n+\n+    ta = TypeAdapter(MyModel)\n+\n+    assert ta.json_schema() == {\n+        'properties': {'a': {'title': 'A', 'type': 'integer', 'description': 'A docs'}},\n+        'required': ['a'],\n+        'title': 'MyModel',\n+        'type': 'object',\n+    }\n+\n+\n+def test_typeddict_as_field():\n+    class ModelTDAsField(TypedDict):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        __pydantic_config__ = ConfigDict(use_attribute_docstrings=True)\n+\n+    class MyModel(BaseModel):\n+        td: ModelTDAsField\n+\n+    a_property = MyModel.model_json_schema()['$defs']['ModelTDAsField']['properties']['a']\n+    assert a_property['description'] == 'A docs'\n+\n+\n+def test_create_model_test():\n+    # Duplicate class creation to ensure create_model\n+    # doesn't fallback to using inspect, which could\n+    # in turn use the wrong class:\n+    class CreatedModel(BaseModel):\n+        foo: int = 123\n+        \"\"\"Shouldn't be used\"\"\"\n+\n+    CreatedModel = create_model(\n+        'CreatedModel',\n+        foo=(int, 123),\n+        __config__=ConfigDict(use_attribute_docstrings=True),\n+    )\n+\n+    assert CreatedModel.model_fields['foo'].description is None\n+\n+\n+def test_exec_cant_be_parsed():\n+    source = textwrap.dedent(\n+        \"\"\"\n+        class MyModelExec(BaseModel):\n+            a: int\n+            \\\"\\\"\\\"A docs\\\"\\\"\\\"\n+\n+            model_config = ConfigDict(use_attribute_docstrings=True)\n+        \"\"\"\n+    )\n+\n+    locals_dict = {}\n+\n+    exec(source, globals(), locals_dict)\n+    assert locals_dict['MyModelExec'].model_fields['a'].description is None",
      "comment": "```suggestion\r\n        class MyModel(BaseModel):\r\n            a: int\r\n            \\\"\\\"\\\"A docs\\\"\\\"\\\"\r\n\r\n            model_config = ConfigDict(use_attribute_docstrings=True)\r\n        \"\"\"\r\n    )\r\n\r\n    locals_dict = {}\r\n\r\n    exec(source, globals(), locals_dict)\r\n    assert locals_dict['MyModel'].model_fields['a'].description is None\r\n```",
      "comment_id": 1371492420,
      "user": "alexmojaki",
      "created_at": "2023-10-25T10:10:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1371492420"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import itertools\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        lnum = frame.f_lineno\n+        try:\n+            lines, _ = inspect.findsource(frame)\n+        except OSError:\n+            # Source can't be parsed (maybe because running in an interactive terminal),\n+            # we don't want to error here.\n+            pass\n+        else:\n+            if inspect.getmodule(frame) is inspect.getmodule(cls) and isinstance(lnum, int):\n+                block_lines = inspect.getblock(lines[lnum - 1 :])\n+                dedent_source = _dedent_source_lines(block_lines)  # type: ignore\n+                # Because lnum can point to potential decorators before the class definition,\n+                # we use ast to parse the block source:\n+                try:\n+                    block_tree = ast.parse(dedent_source)\n+                except Exception:\n+                    pass\n+                else:\n+                    selected_nodes = list(itertools.islice(ast.walk(block_tree), 4))\n+                    cls_is_second_node = cls_is_third_node = False\n+                    if len(selected_nodes) >= 4:\n+                        # If `_dedent_source_lines` wrapped the class around the workaround function\n+                        # second node is `FunctionNode`, third node is `ast.arguments`, fourth node is our class:\n+                        cls_is_third_node = (\n+                            isinstance(selected_nodes[1], ast.FunctionDef)\n+                            and selected_nodes[1].name == 'dedent_workaround'\n+                            and isinstance(selected_nodes[3], ast.ClassDef)\n+                            and selected_nodes[3].name == cls.__name__\n+                        )\n+                    if not cls_is_third_node and len(selected_nodes) >= 2:\n+                        # ...or the second element (the first one being `ast.Module`) is `ast.ClassDef` matching our class:\n+                        cls_is_second_node = (\n+                            isinstance(selected_nodes[1], ast.ClassDef) and selected_nodes[1].name == cls.__name__\n+                        )\n+                    if cls_is_second_node or cls_is_third_node:\n+                        return block_lines  # type: ignore",
      "comment": "```suggestion\r\n                    stmt = block_tree.body[0]\r\n                    if isinstance(stmt, ast.FunctionDef) and stmt.name == 'dedent_workaround':\r\n                        # `_dedent_source_lines` wrapped the class around the workaround function\r\n                        stmt = stmt.body[0]\r\n                    if isinstance(stmt, ast.ClassDef) and stmt.name == cls.__name__:\r\n                        return block_lines  # type: ignore\r\n```",
      "comment_id": 1374401448,
      "user": "alexmojaki",
      "created_at": "2023-10-27T10:54:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1374401448"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import itertools\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        lnum = frame.f_lineno\n+        try:\n+            lines, _ = inspect.findsource(frame)\n+        except OSError:\n+            # Source can't be parsed (maybe because running in an interactive terminal),\n+            # we don't want to error here.\n+            pass\n+        else:\n+            if inspect.getmodule(frame) is inspect.getmodule(cls) and isinstance(lnum, int):",
      "comment": "I think this should be checked before calling `inspect.findsource(frame)` which is a bit costly.\r\n\r\nHave you seen cases where `lnum` isn't an int?",
      "comment_id": 1374403526,
      "user": "alexmojaki",
      "created_at": "2023-10-27T10:55:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1374403526"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import itertools\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        lnum = frame.f_lineno\n+        try:\n+            lines, _ = inspect.findsource(frame)\n+        except OSError:\n+            # Source can't be parsed (maybe because running in an interactive terminal),\n+            # we don't want to error here.\n+            pass\n+        else:\n+            if inspect.getmodule(frame) is inspect.getmodule(cls) and isinstance(lnum, int):\n+                block_lines = inspect.getblock(lines[lnum - 1 :])\n+                dedent_source = _dedent_source_lines(block_lines)  # type: ignore\n+                # Because lnum can point to potential decorators before the class definition,\n+                # we use ast to parse the block source:\n+                try:\n+                    block_tree = ast.parse(dedent_source)\n+                except Exception:\n+                    pass\n+                else:\n+                    selected_nodes = list(itertools.islice(ast.walk(block_tree), 4))\n+                    cls_is_second_node = cls_is_third_node = False\n+                    if len(selected_nodes) >= 4:\n+                        # If `_dedent_source_lines` wrapped the class around the workaround function\n+                        # second node is `FunctionNode`, third node is `ast.arguments`, fourth node is our class:\n+                        cls_is_third_node = (\n+                            isinstance(selected_nodes[1], ast.FunctionDef)\n+                            and selected_nodes[1].name == 'dedent_workaround'\n+                            and isinstance(selected_nodes[3], ast.ClassDef)\n+                            and selected_nodes[3].name == cls.__name__\n+                        )\n+                    if not cls_is_third_node and len(selected_nodes) >= 2:\n+                        # ...or the second element (the first one being `ast.Module`) is `ast.ClassDef` matching our class:\n+                        cls_is_second_node = (\n+                            isinstance(selected_nodes[1], ast.ClassDef) and selected_nodes[1].name == cls.__name__\n+                        )\n+                    if cls_is_second_node or cls_is_third_node:\n+                        return block_lines  # type: ignore",
      "comment": "Also I think overriding model_parametrized_name can change the class `__name__`, better add a test to check that this still works with that.",
      "comment_id": 1374406124,
      "user": "alexmojaki",
      "created_at": "2023-10-27T10:58:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1374406124"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import itertools\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        lnum = frame.f_lineno\n+        try:\n+            lines, _ = inspect.findsource(frame)\n+        except OSError:\n+            # Source can't be parsed (maybe because running in an interactive terminal),\n+            # we don't want to error here.\n+            pass\n+        else:\n+            if inspect.getmodule(frame) is inspect.getmodule(cls) and isinstance(lnum, int):\n+                block_lines = inspect.getblock(lines[lnum - 1 :])\n+                dedent_source = _dedent_source_lines(block_lines)  # type: ignore\n+                # Because lnum can point to potential decorators before the class definition,\n+                # we use ast to parse the block source:\n+                try:\n+                    block_tree = ast.parse(dedent_source)\n+                except Exception:\n+                    pass\n+                else:\n+                    selected_nodes = list(itertools.islice(ast.walk(block_tree), 4))\n+                    cls_is_second_node = cls_is_third_node = False\n+                    if len(selected_nodes) >= 4:\n+                        # If `_dedent_source_lines` wrapped the class around the workaround function\n+                        # second node is `FunctionNode`, third node is `ast.arguments`, fourth node is our class:\n+                        cls_is_third_node = (\n+                            isinstance(selected_nodes[1], ast.FunctionDef)\n+                            and selected_nodes[1].name == 'dedent_workaround'\n+                            and isinstance(selected_nodes[3], ast.ClassDef)\n+                            and selected_nodes[3].name == cls.__name__\n+                        )\n+                    if not cls_is_third_node and len(selected_nodes) >= 2:\n+                        # ...or the second element (the first one being `ast.Module`) is `ast.ClassDef` matching our class:\n+                        cls_is_second_node = (\n+                            isinstance(selected_nodes[1], ast.ClassDef) and selected_nodes[1].name == cls.__name__\n+                        )\n+                    if cls_is_second_node or cls_is_third_node:\n+                        return block_lines  # type: ignore\n+        frame = frame.f_back\n+\n+\n+def extract_docstrings_from_cls(cls: type[Any], use_inspect: bool = False) -> dict[str, str]:\n+    \"\"\"Map model attributes and their corresponding docstring.\n+\n+    Args:\n+        cls: The class of the Pydantic model to inspect.\n+        use_inspect: Whether to skip usage of frames to find the object and use\n+            the `inspect` module instead.\n+\n+    Returns:\n+        A mapping containing attribute names and their corresponding docstring.\n+    \"\"\"\n+    if use_inspect:\n+        # Might not work as expected if two classes have the same name in the same source file.",
      "comment": "There needs to be some documentation about this for users, mentioning TypedDict and Python versions.",
      "comment_id": 1374408078,
      "user": "alexmojaki",
      "created_at": "2023-10-27T11:00:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1374408078"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import itertools\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        lnum = frame.f_lineno\n+        try:\n+            lines, _ = inspect.findsource(frame)\n+        except OSError:\n+            # Source can't be parsed (maybe because running in an interactive terminal),\n+            # we don't want to error here.\n+            pass\n+        else:\n+            if inspect.getmodule(frame) is inspect.getmodule(cls) and isinstance(lnum, int):\n+                block_lines = inspect.getblock(lines[lnum - 1 :])\n+                dedent_source = _dedent_source_lines(block_lines)  # type: ignore\n+                # Because lnum can point to potential decorators before the class definition,\n+                # we use ast to parse the block source:\n+                try:\n+                    block_tree = ast.parse(dedent_source)\n+                except Exception:",
      "comment": "I had it happen, but it was before switching from `if dedent_source.startswith('class'):` to `if dedent_source.startswith((' ', '\\t')):`.\r\n\r\nI can remove it, but I'm not sure we won't ever have any unexpected `IndentationError`s with this call",
      "comment_id": 1374434794,
      "user": "Viicos",
      "created_at": "2023-10-27T11:27:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1374434794"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import itertools\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        lnum = frame.f_lineno\n+        try:\n+            lines, _ = inspect.findsource(frame)\n+        except OSError:\n+            # Source can't be parsed (maybe because running in an interactive terminal),\n+            # we don't want to error here.\n+            pass\n+        else:\n+            if inspect.getmodule(frame) is inspect.getmodule(cls) and isinstance(lnum, int):",
      "comment": "According to typeshed:\r\n\r\n```python\r\n    # see discussion in #6769: f_lineno *can* sometimes be None,\r\n    # but you should probably file a bug report with CPython if you encounter it being None in the wild.\r\n    # An `int | None` annotation here causes too many false-positive errors.\r\n    @property\r\n    def f_lineno(self) -> int | Any: ...\r\n```\r\n\r\nMight be better to let the error be raised (`lines[lnum - 1 :]` will throw if `lnum` is `None`), so that it can be reported as stated?",
      "comment_id": 1374437275,
      "user": "Viicos",
      "created_at": "2023-10-27T11:28:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1374437275"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,117 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import itertools\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        lnum = frame.f_lineno\n+        try:\n+            lines, _ = inspect.findsource(frame)\n+        except OSError:\n+            # Source can't be parsed (maybe because running in an interactive terminal),\n+            # we don't want to error here.\n+            pass\n+        else:\n+            if inspect.getmodule(frame) is inspect.getmodule(cls) and isinstance(lnum, int):\n+                block_lines = inspect.getblock(lines[lnum - 1 :])\n+                dedent_source = _dedent_source_lines(block_lines)  # type: ignore\n+                # Because lnum can point to potential decorators before the class definition,\n+                # we use ast to parse the block source:\n+                try:\n+                    block_tree = ast.parse(dedent_source)\n+                except Exception:",
      "comment": "Ok to keep it just in case, I was just wondering. But this should do:\r\n\r\n```suggestion\r\n                except SyntaxError:\r\n```",
      "comment_id": 1374441661,
      "user": "alexmojaki",
      "created_at": "2023-10-27T11:32:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1374441661"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 194,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,334 @@\n+import textwrap\n+from typing import Generic, TypeVar\n+\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter, create_model\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+T = TypeVar('T')\n+\n+\n+def dec_noop(obj):\n+    return obj\n+\n+\n+def test_model_no_docs_extraction():\n+    class MyModel(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.model_fields['a'].description is None\n+    assert MyModel.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    # Using a couple dummy decorators to make sure the frame is pointing at\n+    # the `class` line:\n+    @dec_noop\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy that won't be used for d\"\"\"\n+\n+        e: Annotated[int, Field(description='Real description')]\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int\n+        \"\"\"G docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+    assert MyModel.model_fields['c'].description is None\n+    assert MyModel.model_fields['d'].description is None\n+    assert MyModel.model_fields['e'].description == 'Real description'\n+    assert MyModel.model_fields['g'].description == 'G docs'\n+\n+\n+def test_model_docs_duplicate_class():\n+    \"\"\"Ensure source parsing is working correctly when using frames.\"\"\"\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+    # With https://github.com/python/cpython/pull/106815/ introduced,\n+    # inspect will fallback to the last found class in the source file.\n+    # The following is to ensure using frames will still get the correct one\n+    if True:\n+\n+        class MyModel(BaseModel):\n+            a: int\n+            \"\"\"A docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    else:\n+\n+        class MyModel(BaseModel):\n+            b: int\n+            \"\"\"B docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_dedented_string():\n+    # fmt: off\n+    class MyModel(BaseModel):\n+        def bar(self):\n+            \"\"\"\n+An inconveniently dedented string\n+            \"\"\"\n+\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+    # fmt: on\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_inheritance():\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    FirstModel = MyModel\n+\n+    class MyModel(FirstModel):\n+        a: int\n+        \"\"\"A overridden docs\"\"\"\n+\n+    assert FirstModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['a'].description == 'A overridden docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+\n+def test_model_different_name():\n+    # As we extract docstrings from cls in `ModelMetaclass.__new__`,\n+    # we are not affected by `__name__` being altered in any way.\n+\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    MyModel.__name__ = 'OtherModel'\n+    print(MyModel.__name__)\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_generic():\n+    class MyModel(BaseModel, Generic[T]):\n+        a: T\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+    class MyParameterizedModel(MyModel[int]):\n+        a: int\n+        \"\"\"A parameterized docs\"\"\"\n+\n+    assert MyParameterizedModel.model_fields['a'].description == 'A parameterized docs'",
      "comment": "We hit an interesting behavior here. If you try to debug with a breakpoint L51 in `_docs_extraction.py`, you will see `_extract_source_from_frame` is called two times.\r\n\r\n`BaseModel.__class_getitem__` will manually return a new class object, and will use `model_parametrized_name` to set the name of this new class. So when writing `class MyParameterizedModel(MyModel[int])`, a first class is created when `MyModel[int]` is executed (we can't find any class declaration because the model name is set to `MyModel[int]` by Pydantic,  so no docs are extracted). Then when `MyParameterizedModel(...)` is executed and docs are successfully extracted here.\r\n\r\nIf you have other use cases with generics, please let me know",
      "comment_id": 1374499745,
      "user": "Viicos",
      "created_at": "2023-10-27T12:23:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1374499745"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 194,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,334 @@\n+import textwrap\n+from typing import Generic, TypeVar\n+\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter, create_model\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+T = TypeVar('T')\n+\n+\n+def dec_noop(obj):\n+    return obj\n+\n+\n+def test_model_no_docs_extraction():\n+    class MyModel(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.model_fields['a'].description is None\n+    assert MyModel.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    # Using a couple dummy decorators to make sure the frame is pointing at\n+    # the `class` line:\n+    @dec_noop\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy that won't be used for d\"\"\"\n+\n+        e: Annotated[int, Field(description='Real description')]\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int\n+        \"\"\"G docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+    assert MyModel.model_fields['c'].description is None\n+    assert MyModel.model_fields['d'].description is None\n+    assert MyModel.model_fields['e'].description == 'Real description'\n+    assert MyModel.model_fields['g'].description == 'G docs'\n+\n+\n+def test_model_docs_duplicate_class():\n+    \"\"\"Ensure source parsing is working correctly when using frames.\"\"\"\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+    # With https://github.com/python/cpython/pull/106815/ introduced,\n+    # inspect will fallback to the last found class in the source file.\n+    # The following is to ensure using frames will still get the correct one\n+    if True:\n+\n+        class MyModel(BaseModel):\n+            a: int\n+            \"\"\"A docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    else:\n+\n+        class MyModel(BaseModel):\n+            b: int\n+            \"\"\"B docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_dedented_string():\n+    # fmt: off\n+    class MyModel(BaseModel):\n+        def bar(self):\n+            \"\"\"\n+An inconveniently dedented string\n+            \"\"\"\n+\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+    # fmt: on\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_inheritance():\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    FirstModel = MyModel\n+\n+    class MyModel(FirstModel):\n+        a: int\n+        \"\"\"A overridden docs\"\"\"\n+\n+    assert FirstModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['a'].description == 'A overridden docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+\n+def test_model_different_name():\n+    # As we extract docstrings from cls in `ModelMetaclass.__new__`,\n+    # we are not affected by `__name__` being altered in any way.\n+\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    MyModel.__name__ = 'OtherModel'\n+    print(MyModel.__name__)\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_generic():\n+    class MyModel(BaseModel, Generic[T]):\n+        a: T\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+    class MyParameterizedModel(MyModel[int]):\n+        a: int\n+        \"\"\"A parameterized docs\"\"\"\n+\n+    assert MyParameterizedModel.model_fields['a'].description == 'A parameterized docs'",
      "comment": "I was worried that the user overriding `model_parametrized_name` might be a problem, but it seems to be fine:\r\n\r\n```python\r\nimport typing\r\nfrom typing import Generic\r\n\r\nfrom pydantic import BaseModel, ConfigDict\r\n\r\nT = typing.TypeVar(\"T\")\r\n\r\n\r\nclass MyModel(BaseModel, Generic[T]):\r\n    a: T\r\n    \"\"\"A docs\"\"\"\r\n\r\n    model_config = ConfigDict(\r\n        use_attribute_docstrings=True,\r\n    )\r\n\r\n    @classmethod\r\n    def model_parametrized_name(cls, params):\r\n        return \"OtherName\"\r\n\r\n\r\nassert MyModel.model_fields[\"a\"].description == \"A docs\"\r\nassert MyModel[int].model_fields[\"a\"].description == \"A docs\"  # maybe add this to the test\r\nassert MyModel[int].__name__ == \"OtherName\"\r\nassert MyModel.__name__ == \"MyModel\"\r\n\r\n\r\nclass MyParameterizedModel(MyModel[int]):\r\n    a: int\r\n    \"\"\"A parameterized docs\"\"\"\r\n\r\n\r\nassert MyParameterizedModel.model_fields[\"a\"].description == \"A parameterized docs\"\r\nassert MyParameterizedModel.__name__ == \"MyParameterizedModel\"\r\n```",
      "comment_id": 1374517121,
      "user": "alexmojaki",
      "created_at": "2023-10-27T12:37:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1374517121"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 60,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,105 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        if inspect.getmodule(frame) is inspect.getmodule(cls):\n+            lnum = frame.f_lineno\n+            try:\n+                lines, _ = inspect.findsource(frame)\n+            except OSError:\n+                # Source can't be parsed (maybe because running in an interactive terminal),\n+                # we don't want to error here.\n+                pass\n+            else:\n+                block_lines = inspect.getblock(lines[lnum - 1 :])\n+                dedent_source = _dedent_source_lines(block_lines)  # type: ignore",
      "comment": "Replace `list[str]` with `Sequence[str]` in the two functions so that these two `# type: ignore` comments can be removed.",
      "comment_id": 1375241006,
      "user": "alexmojaki",
      "created_at": "2023-10-28T11:53:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1375241006"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,105 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        if inspect.getmodule(frame) is inspect.getmodule(cls):\n+            lnum = frame.f_lineno\n+            try:\n+                lines, _ = inspect.findsource(frame)\n+            except OSError:\n+                # Source can't be parsed (maybe because running in an interactive terminal),",
      "comment": "```suggestion\r\n                # Source can't be retrieved (maybe because running in an interactive terminal),\r\n```",
      "comment_id": 1375241075,
      "user": "alexmojaki",
      "created_at": "2023-10-28T11:54:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1375241075"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,105 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        if inspect.getmodule(frame) is inspect.getmodule(cls):\n+            lnum = frame.f_lineno\n+            try:\n+                lines, _ = inspect.findsource(frame)\n+            except OSError:\n+                # Source can't be parsed (maybe because running in an interactive terminal),\n+                # we don't want to error here.\n+                pass\n+            else:\n+                block_lines = inspect.getblock(lines[lnum - 1 :])\n+                dedent_source = _dedent_source_lines(block_lines)  # type: ignore\n+                # Because lnum can point to potential decorators before the class definition,\n+                # we use `ast` to parse the block source:",
      "comment": "I think this comment is meaningful to us since we've seen the implementation changing with time but it doesn't seem needed for future readers. We have a block, we're checking that it looks like the class definition we want, no explanation required.",
      "comment_id": 1375241698,
      "user": "alexmojaki",
      "created_at": "2023-10-28T11:58:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1375241698"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/config.py",
      "line": 891,
      "side": "RIGHT",
      "diff_hunk": "@@ -857,5 +857,41 @@ class Model(BaseModel):\n     ```\n     \"\"\"\n \n+    use_attribute_docstrings: bool\n+    '''\n+    Whether docstrings of attributes (bare string literals immediately following the attribute declaration)\n+    should be used for field descriptions.\n+\n+    ```py\n+    from pydantic import BaseModel, ConfigDict, Field\n+\n+\n+    class Model(BaseModel):\n+        model_config = ConfigDict(use_attribute_docstrings=True)\n+\n+        x: str\n+        \"\"\"\n+        Example of an attribute docstring\n+        \"\"\"\n+\n+        y: int = Field(description=\"Description in Field\")\n+        \"\"\"\n+        Description in Field overrides attribute docstring\n+        \"\"\"\n+\n+\n+    print(Model.model_fields[\"x\"].description)\n+    # > Example of an attribute docstring\n+    print(Model.model_fields[\"y\"].description)\n+    # > Description in Field\n+    ```\n+    This requires the source code of the class to be available at runtime.\n+\n+    !!! warning \"Usage with `TypedDict`\"\n+        Due to current limitations, attribute docsrings detection may not work as expected when using `TypedDict`",
      "comment": "```suggestion\r\n        Due to current limitations, attribute docstrings detection may not work as expected when using `TypedDict`\r\n```",
      "comment_id": 1375241806,
      "user": "alexmojaki",
      "created_at": "2023-10-28T11:59:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1375241806"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "tests/test_docs_extraction.py",
      "line": 213,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+import textwrap\n+from typing import Generic, TypeVar\n+\n+from typing_extensions import Annotated, TypedDict\n+\n+from pydantic import BaseModel, ConfigDict, Field, TypeAdapter, create_model\n+from pydantic.dataclasses import dataclass as pydantic_dataclass\n+\n+T = TypeVar('T')\n+\n+\n+def dec_noop(obj):\n+    return obj\n+\n+\n+def test_model_no_docs_extraction():\n+    class MyModel(BaseModel):\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.model_fields['a'].description is None\n+    assert MyModel.model_fields['b'].description is None\n+\n+\n+def test_model_docs_extraction():\n+    # Using a couple dummy decorators to make sure the frame is pointing at\n+    # the `class` line:\n+    @dec_noop\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+        b: int = 1\n+\n+        \"\"\"B docs\"\"\"\n+        c: int = 1\n+        # This isn't used as a description.\n+\n+        d: int\n+\n+        def dummy_method(self) -> None:\n+            \"\"\"Docs for dummy that won't be used for d\"\"\"\n+\n+        e: Annotated[int, Field(description='Real description')]\n+        \"\"\"Won't be used\"\"\"\n+\n+        f: int\n+        \"\"\"F docs\"\"\"\n+\n+        \"\"\"Useless docs\"\"\"\n+\n+        g: int\n+        \"\"\"G docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+    assert MyModel.model_fields['c'].description is None\n+    assert MyModel.model_fields['d'].description is None\n+    assert MyModel.model_fields['e'].description == 'Real description'\n+    assert MyModel.model_fields['g'].description == 'G docs'\n+\n+\n+def test_model_docs_duplicate_class():\n+    \"\"\"Ensure source parsing is working correctly when using frames.\"\"\"\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    @dec_noop\n+    class MyModel(BaseModel):\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+    # With https://github.com/python/cpython/pull/106815/ introduced,\n+    # inspect will fallback to the last found class in the source file.\n+    # The following is to ensure using frames will still get the correct one\n+    if True:\n+\n+        class MyModel(BaseModel):\n+            a: int\n+            \"\"\"A docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    else:\n+\n+        class MyModel(BaseModel):\n+            b: int\n+            \"\"\"B docs\"\"\"\n+\n+            model_config = ConfigDict(\n+                use_attribute_docstrings=True,\n+            )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_dedented_string():\n+    # fmt: off\n+    class MyModel(BaseModel):\n+        def bar(self):\n+            \"\"\"\n+An inconveniently dedented string\n+            \"\"\"\n+\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+    # fmt: on\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_docs_inheritance():\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        b: int\n+        \"\"\"B docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    FirstModel = MyModel\n+\n+    class MyModel(FirstModel):\n+        a: int\n+        \"\"\"A overridden docs\"\"\"\n+\n+    assert FirstModel.model_fields['a'].description == 'A docs'\n+    assert MyModel.model_fields['a'].description == 'A overridden docs'\n+    assert MyModel.model_fields['b'].description == 'B docs'\n+\n+\n+def test_model_different_name():\n+    # As we extract docstrings from cls in `ModelMetaclass.__new__`,\n+    # we are not affected by `__name__` being altered in any way.\n+\n+    class MyModel(BaseModel):\n+        a: int\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    MyModel.__name__ = 'OtherModel'\n+    print(MyModel.__name__)\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+\n+def test_model_generic():\n+    class MyModel(BaseModel, Generic[T]):\n+        a: T\n+        \"\"\"A docs\"\"\"\n+\n+        model_config = ConfigDict(\n+            use_attribute_docstrings=True,\n+        )\n+\n+    assert MyModel.model_fields['a'].description == 'A docs'\n+\n+    class MyParameterizedModel(MyModel[int]):\n+        a: int\n+        \"\"\"A parameterized docs\"\"\"\n+\n+    assert MyParameterizedModel.model_fields['a'].description == 'A parameterized docs'\n+    assert MyModel[int].model_fields['a'].description == 'A docs'\n+\n+\n+def test_dataclass_no_docs_extraction():\n+    @pydantic_dataclass\n+    class MyModel:\n+        a: int = 1\n+        \"\"\"A docs\"\"\"\n+\n+        b: str = '1'\n+\n+        \"\"\"B docs\"\"\"\n+\n+    assert MyModel.__pydantic_fields__['a'].description is None\n+    assert MyModel.__pydantic_fields__['b'].description is None\n+\n+\n+def test_dataclass_docs_extraction():\n+    @pydantic_dataclass(config=ConfigDict(use_attribute_docstrings=True))",
      "comment": "```suggestion\r\n    @pydantic_dataclass(\r\n        config=ConfigDict(use_attribute_docstrings=True),\r\n    )\r\n```\r\n\r\nso that we can feel justified about the more complicated implementation :laughing: ",
      "comment_id": 1375241999,
      "user": "alexmojaki",
      "created_at": "2023-10-28T12:01:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1375241999"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 6563,
      "file_path": "pydantic/_internal/_docs_extraction.py",
      "line": 60,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,105 @@\n+\"\"\"Utilities related to attribute docstring extraction.\"\"\"\n+from __future__ import annotations\n+\n+import ast\n+import inspect\n+import textwrap\n+from typing import Any\n+\n+\n+class DocstringVisitor(ast.NodeVisitor):\n+    def __init__(self) -> None:\n+        super().__init__()\n+\n+        self.target: str | None = None\n+        self.attrs: dict[str, str] = {}\n+        self.previous_node_type: type[ast.AST] | None = None\n+\n+    def visit(self, node: ast.AST) -> Any:\n+        node_result = super().visit(node)\n+        self.previous_node_type = type(node)\n+        return node_result\n+\n+    def visit_AnnAssign(self, node: ast.AnnAssign) -> Any:\n+        if isinstance(node.target, ast.Name):\n+            self.target = node.target.id\n+\n+    def visit_Expr(self, node: ast.Expr) -> Any:\n+        if isinstance(node.value, ast.Str) and self.previous_node_type is ast.AnnAssign:\n+            docstring = inspect.cleandoc(node.value.s)\n+            if self.target:\n+                self.attrs[self.target] = docstring\n+            self.target = None\n+\n+\n+def _dedent_source_lines(source: list[str]) -> str:\n+    # Required for nested class definitions, e.g. in a function block\n+    dedent_source = textwrap.dedent(''.join(source))\n+    if dedent_source.startswith((' ', '\\t')):\n+        # We are in the case where there's a dedented (usually multiline) string\n+        # at a lower indentation level than the class itself. We wrap our class\n+        # in a function as a workaround.\n+        dedent_source = f'def dedent_workaround():\\n{dedent_source}'\n+    return dedent_source\n+\n+\n+def _extract_source_from_frame(cls: type[Any]) -> list[str] | None:\n+    frame = inspect.currentframe()\n+\n+    while frame:\n+        if inspect.getmodule(frame) is inspect.getmodule(cls):\n+            lnum = frame.f_lineno\n+            try:\n+                lines, _ = inspect.findsource(frame)\n+            except OSError:\n+                # Source can't be parsed (maybe because running in an interactive terminal),\n+                # we don't want to error here.\n+                pass\n+            else:\n+                block_lines = inspect.getblock(lines[lnum - 1 :])\n+                dedent_source = _dedent_source_lines(block_lines)  # type: ignore",
      "comment": "I'm waiting for pyright to release a new version that will include the typeshed changes so that I can remove the comments",
      "comment_id": 1375279439,
      "user": "Viicos",
      "created_at": "2023-10-28T16:30:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/6563#discussion_r1375279439"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9838,
      "file_path": "pydantic/type_adapter.py",
      "line": 318,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,11 +311,11 @@ def core_schema(self) -> CoreSchema:\n \n     @cached_property\n     @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator:\n+    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n         \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, SchemaValidator):\n+        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n             self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, SchemaValidator)\n+        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))",
      "comment": "This is where the problem is \u2014\u00a0because we were asserting that it was a SchemaValidator, but it could be a PluggableSchemaValidator. While we could just drop this assert, @adriangb wanted to just stop lying in the `create_schema_validator` return type annotation.",
      "comment_id": 1664868444,
      "user": "dmontagu",
      "created_at": "2024-07-03T22:16:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/9838#discussion_r1664868444"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9838,
      "file_path": "pydantic/type_adapter.py",
      "line": 318,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,11 +311,11 @@ def core_schema(self) -> CoreSchema:\n \n     @cached_property\n     @_frame_depth(2)  # +2 for @cached_property + validator(self)\n-    def validator(self) -> SchemaValidator:\n+    def validator(self) -> SchemaValidator | PluggableSchemaValidator:\n         \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n-        if not isinstance(self._validator, SchemaValidator):\n+        if not isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator)):\n             self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n-        assert isinstance(self._validator, SchemaValidator)\n+        assert isinstance(self._validator, (SchemaValidator, PluggableSchemaValidator))",
      "comment": "(And I agree with that choice, given I wasn't sure where else there might be problems.)\r\n\r\nIdeally we would make it so that a PluggableSchemaValidator was actually a subclass of SchemaValidator, or similar, but anyway this works for now.",
      "comment_id": 1664868890,
      "user": "dmontagu",
      "created_at": "2024-07-03T22:16:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/9838#discussion_r1664868890"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9838,
      "file_path": "tests/test_plugins.py",
      "line": 345,
      "side": "RIGHT",
      "diff_hunk": "@@ -341,7 +341,8 @@ def new_schema_validator(self, schema, schema_type, schema_type_path, schema_kin\n \n     plugin = Plugin()\n     with install_plugin(plugin):\n-        TypeAdapter(List[str])\n+        adapter = TypeAdapter(List[str])\n+        adapter.validate_python(['a', 'b'])",
      "comment": "This raises an error on main, so obviously it's a problem lol",
      "comment_id": 1664869172,
      "user": "dmontagu",
      "created_at": "2024-07-03T22:17:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/9838#discussion_r1664869172"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 213,
      "side": "RIGHT",
      "diff_hunk": "@@ -208,6 +208,9 @@ def path_schema_prepare_pydantic_annotations(\n     import pathlib\n \n     if source_type not in {\n+        os.PathLike[bytes],\n+        os.PathLike[str],\n+        os.PathLike[Any],",
      "comment": "I'd rather us use `get_origin` on `source_type`, and if that's `os.PathLike`, then we can move forward with building a validator that takes into account how `os.PathLike` is parametrized",
      "comment_id": 1654758273,
      "user": "sydney-runkle",
      "created_at": "2024-06-26T12:48:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1654758273"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "tests/test_types.py",
      "line": 3497,
      "side": "RIGHT",
      "diff_hunk": "@@ -3494,6 +3494,32 @@ class Model(BaseModel):\n     }\n \n \n+def test_path_like_extra_subtype():",
      "comment": "Test looks great, thanks!\r\n\r\nCould you please add some tests that verify validation errors are thrown when invalid data is passed in for each of these parametrized types?",
      "comment_id": 1654759656,
      "user": "sydney-runkle",
      "created_at": "2024-06-26T12:49:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1654759656"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "tests/test_types.py",
      "line": 3531,
      "side": "RIGHT",
      "diff_hunk": "@@ -3494,6 +3494,44 @@ class Model(BaseModel):\n     }\n \n \n+def test_path_like_extra_subtype():\n+    class Model(BaseModel):\n+        str_type: os.PathLike[str]\n+        byte_type: os.PathLike[bytes]\n+        any_type: os.PathLike[Any]\n+\n+    m = Model(\n+        str_type='/foo/bar',\n+        byte_type=b'/foo/bar',\n+        any_type='/foo/bar',\n+    )\n+    assert m.str_type == Path('/foo/bar')\n+    assert m.byte_type == Path('/foo/bar')\n+    assert m.any_type == Path('/foo/bar')\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'str_type': {'format': 'path', 'title': 'Str Type', 'type': 'string'},\n+            'byte_type': {'format': 'path', 'title': 'Byte Type', 'type': 'string'},\n+            'any_type': {'format': 'path', 'title': 'Any Type', 'type': 'string'},\n+        },\n+        'required': ['str_type', 'byte_type', 'any_type'],\n+        'title': 'Model',\n+        'type': 'object',\n+    }\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(\n+            str_type=b'/foo/bar',\n+            byte_type='/foo/bar',\n+            any_type=111,\n+        )\n+    assert exc_info.value.errors(include_url=False) == [\n+        {'type': 'path_type', 'loc': ('str_type',), 'msg': 'Input is not a valid path', 'input': b'/foo/bar'},\n+        {'type': 'path_type', 'loc': ('byte_type',), 'msg': 'Input is not a valid path', 'input': '/foo/bar'},\n+        {'type': 'path_type', 'loc': ('any_type',), 'msg': 'Input is not a valid path', 'input': 111},",
      "comment": "I tried to change the msg to something more meaningful than `Input is not a valid path` but had some trouble with `lax_schema`\r\n@sydney-runkle any suggestions ?\r\nhttps://github.com/pydantic/pydantic/blob/f024d03b832d1bbcbadf76184ed14d92571a71ca/pydantic/_internal/_std_types_schema.py#L244-L252\r\n",
      "comment_id": 1656404941,
      "user": "nix010",
      "created_at": "2024-06-27T04:49:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1656404941"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,7 +207,11 @@ def path_schema_prepare_pydantic_annotations(\n ) -> tuple[Any, list[Any]] | None:\n     import pathlib\n \n-    if source_type not in {\n+    orig_source_type = get_origin(source_type) or source_type",
      "comment": "What about:\r\n\r\n```py\r\norig_source_type: Any = get_origin(source_type) or source_type\r\nif (source_type_args := get_args(source_type)) and source_type_args[0] not in {str, bytes, Any}:\r\n    return None\r\n\r\nif orig_source_type not in {\r\n    os.PathLike,\r\n    pathlib.Path,\r\n    pathlib.PurePath,\r\n    pathlib.PosixPath,\r\n    pathlib.PurePosixPath,\r\n    pathlib.PureWindowsPath,\r\n}:\r\n    return None\r\n```",
      "comment_id": 1658999702,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T16:30:25Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1658999702"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 241,
      "side": "RIGHT",
      "diff_hunk": "@@ -217,22 +221,46 @@ def path_schema_prepare_pydantic_annotations(\n     }:\n         return None\n \n+    is_path_like_subtype_invalid = (\n+        orig_source_type == os.PathLike\n+        and orig_source_type_arg\n+        and orig_source_type_arg\n+        not in {\n+            str,\n+            bytes,\n+            Any,\n+        }\n+    )\n+\n+    if is_path_like_subtype_invalid:\n+        return None\n+\n     metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)\n-    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.STR_CONSTRAINTS, source_type)\n+    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.STR_CONSTRAINTS, orig_source_type)\n+\n+    construct_path = orig_source_type",
      "comment": "What about:\r\n\r\n```py\r\nconstruct_path = pathlib.PurePath if orig_source_type is os.PathLike else orig_source_type\r\nconstrained_schema = (\r\n    core_schema.bytes_schema(**metadata) if source_type_args and source_type_args[0] is bytes \r\n    else core_schema.str_schema(**metadata)\r\n)\r\n\r\ndef path_validator(input_value: str) -> os.PathLike[Any]:\r\n    try:\r\n        return construct_path(input_value)\r\n    except TypeError as e:\r\n        raise PydanticCustomError('path_type', 'Input is not a valid path') from e\r\n```",
      "comment_id": 1659002332,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T16:32:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1659002332"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "tests/test_types.py",
      "line": 3514,
      "side": "RIGHT",
      "diff_hunk": "@@ -3494,6 +3494,44 @@ class Model(BaseModel):\n     }\n \n \n+def test_path_like_extra_subtype():\n+    class Model(BaseModel):\n+        str_type: os.PathLike[str]\n+        byte_type: os.PathLike[bytes]\n+        any_type: os.PathLike[Any]\n+\n+    m = Model(\n+        str_type='/foo/bar',\n+        byte_type=b'/foo/bar',\n+        any_type='/foo/bar',\n+    )\n+    assert m.str_type == Path('/foo/bar')\n+    assert m.byte_type == Path('/foo/bar')\n+    assert m.any_type == Path('/foo/bar')\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'str_type': {'format': 'path', 'title': 'Str Type', 'type': 'string'},\n+            'byte_type': {'format': 'path', 'title': 'Byte Type', 'type': 'string'},",
      "comment": "Hmm, I wonder if we want to change the JSON schema for these path types...",
      "comment_id": 1659005980,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T16:35:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1659005980"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 241,
      "side": "RIGHT",
      "diff_hunk": "@@ -217,22 +221,46 @@ def path_schema_prepare_pydantic_annotations(\n     }:\n         return None\n \n+    is_path_like_subtype_invalid = (\n+        orig_source_type == os.PathLike\n+        and orig_source_type_arg\n+        and orig_source_type_arg\n+        not in {\n+            str,\n+            bytes,\n+            Any,\n+        }\n+    )\n+\n+    if is_path_like_subtype_invalid:\n+        return None\n+\n     metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)\n-    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.STR_CONSTRAINTS, source_type)\n+    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.STR_CONSTRAINTS, orig_source_type)\n+\n+    construct_path = orig_source_type",
      "comment": "I realize I've skipped the decoding here, one moment... trying to add back in with correct typing",
      "comment_id": 1659006857,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T16:36:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1659006857"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 241,
      "side": "RIGHT",
      "diff_hunk": "@@ -217,22 +221,46 @@ def path_schema_prepare_pydantic_annotations(\n     }:\n         return None\n \n+    is_path_like_subtype_invalid = (\n+        orig_source_type == os.PathLike\n+        and orig_source_type_arg\n+        and orig_source_type_arg\n+        not in {\n+            str,\n+            bytes,\n+            Any,\n+        }\n+    )\n+\n+    if is_path_like_subtype_invalid:\n+        return None\n+\n     metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)\n-    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.STR_CONSTRAINTS, source_type)\n+    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.STR_CONSTRAINTS, orig_source_type)\n+\n+    construct_path = orig_source_type",
      "comment": "I think this is type safe:\r\n\r\n```py\r\ndef path_validator(input_value: str | bytes) -> os.PathLike[str]:\r\n    try:\r\n        if source_type_args and source_type_args[0] is bytes:\r\n            if isinstance(input_value, bytes):\r\n                try:\r\n                    input_value = input_value.decode()\r\n                except UnicodeDecodeError as e:\r\n                    raise PydanticCustomError('bytes_type', 'Input must be valid bytes') from e\r\n            else:\r\n                raise PydanticCustomError('bytes_type', 'Input must be bytes')\r\n        elif not isinstance(input_value, str):\r\n            raise PydanticCustomError('path_type', 'Input is not a valid path')\r\n    \r\n        return construct_path(input_value)\r\n    except TypeError as e:\r\n        raise PydanticCustomError('path_type', 'Input is not a valid path') from e\r\n```",
      "comment_id": 1659021349,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T16:49:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1659021349"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "tests/test_types.py",
      "line": 3531,
      "side": "RIGHT",
      "diff_hunk": "@@ -3494,6 +3494,44 @@ class Model(BaseModel):\n     }\n \n \n+def test_path_like_extra_subtype():\n+    class Model(BaseModel):\n+        str_type: os.PathLike[str]\n+        byte_type: os.PathLike[bytes]\n+        any_type: os.PathLike[Any]\n+\n+    m = Model(\n+        str_type='/foo/bar',\n+        byte_type=b'/foo/bar',\n+        any_type='/foo/bar',\n+    )\n+    assert m.str_type == Path('/foo/bar')\n+    assert m.byte_type == Path('/foo/bar')\n+    assert m.any_type == Path('/foo/bar')\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'str_type': {'format': 'path', 'title': 'Str Type', 'type': 'string'},\n+            'byte_type': {'format': 'path', 'title': 'Byte Type', 'type': 'string'},\n+            'any_type': {'format': 'path', 'title': 'Any Type', 'type': 'string'},\n+        },\n+        'required': ['str_type', 'byte_type', 'any_type'],\n+        'title': 'Model',\n+        'type': 'object',\n+    }\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(\n+            str_type=b'/foo/bar',\n+            byte_type='/foo/bar',\n+            any_type=111,\n+        )\n+    assert exc_info.value.errors(include_url=False) == [\n+        {'type': 'path_type', 'loc': ('str_type',), 'msg': 'Input is not a valid path', 'input': b'/foo/bar'},\n+        {'type': 'path_type', 'loc': ('byte_type',), 'msg': 'Input is not a valid path', 'input': '/foo/bar'},\n+        {'type': 'path_type', 'loc': ('any_type',), 'msg': 'Input is not a valid path', 'input': 111},",
      "comment": "Yeah the difficulty here is that if you don't override the errors from the union schema, you get kind of a nasty spiral bc of the checks against multiple members",
      "comment_id": 1659025900,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T16:52:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1659025900"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "tests/test_types.py",
      "line": 3531,
      "side": "RIGHT",
      "diff_hunk": "@@ -3494,6 +3494,44 @@ class Model(BaseModel):\n     }\n \n \n+def test_path_like_extra_subtype():\n+    class Model(BaseModel):\n+        str_type: os.PathLike[str]\n+        byte_type: os.PathLike[bytes]\n+        any_type: os.PathLike[Any]\n+\n+    m = Model(\n+        str_type='/foo/bar',\n+        byte_type=b'/foo/bar',\n+        any_type='/foo/bar',\n+    )\n+    assert m.str_type == Path('/foo/bar')\n+    assert m.byte_type == Path('/foo/bar')\n+    assert m.any_type == Path('/foo/bar')\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'str_type': {'format': 'path', 'title': 'Str Type', 'type': 'string'},\n+            'byte_type': {'format': 'path', 'title': 'Byte Type', 'type': 'string'},\n+            'any_type': {'format': 'path', 'title': 'Any Type', 'type': 'string'},\n+        },\n+        'required': ['str_type', 'byte_type', 'any_type'],\n+        'title': 'Model',\n+        'type': 'object',\n+    }\n+\n+    with pytest.raises(ValidationError) as exc_info:\n+        Model(\n+            str_type=b'/foo/bar',\n+            byte_type='/foo/bar',\n+            any_type=111,\n+        )\n+    assert exc_info.value.errors(include_url=False) == [\n+        {'type': 'path_type', 'loc': ('str_type',), 'msg': 'Input is not a valid path', 'input': b'/foo/bar'},\n+        {'type': 'path_type', 'loc': ('byte_type',), 'msg': 'Input is not a valid path', 'input': '/foo/bar'},\n+        {'type': 'path_type', 'loc': ('any_type',), 'msg': 'Input is not a valid path', 'input': 111},",
      "comment": "Why don't we just customize it like this:\r\n\r\n```py\r\nschema = core_schema.lax_or_strict_schema(\r\n        lax_schema=core_schema.union_schema(\r\n            [\r\n                instance_schema,\r\n                core_schema.no_info_after_validator_function(path_validator, constrained_schema),\r\n            ],\r\n            custom_error_type='path_type',\r\n            custom_error_message=f'Input is not a valid path for {source_type}',\r\n            strict=True,\r\n        ),\r\n        strict_schema=instance_schema,\r\n        serialization=core_schema.to_string_ser_schema(),\r\n        strict=strict,\r\n    )\r\n```\r\n\r\nThen we can make the error handling more simple in `path_validator`",
      "comment_id": 1659029081,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T16:54:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1659029081"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,7 +207,11 @@ def path_schema_prepare_pydantic_annotations(\n ) -> tuple[Any, list[Any]] | None:\n     import pathlib\n \n-    if source_type not in {\n+    orig_source_type = get_origin(source_type) or source_type",
      "comment": "@sydney-runkle  so there's a test case like `test_string_import_callable` which make `source_type_args[0]` a list and result in `TypeError: unhashable type: 'list'`.\r\nSo I just check it below. \r\n\r\n```python\r\nis_path_like_subtype_invalid = (\r\n        orig_source_type == os.PathLike\r\n        and source_type_args\r\n        and source_type_args[0]\r\n        not in {\r\n            str,\r\n            bytes,\r\n            Any,\r\n        }\r\n    )\r\n\r\n    if is_path_like_subtype_invalid:\r\n        return None \r\n```",
      "comment_id": 1661017159,
      "user": "nix010",
      "created_at": "2024-07-01T12:58:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1661017159"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,7 +207,11 @@ def path_schema_prepare_pydantic_annotations(\n ) -> tuple[Any, list[Any]] | None:\n     import pathlib\n \n-    if source_type not in {\n+    orig_source_type = get_origin(source_type) or source_type",
      "comment": "@nix010,\r\n\r\nI believe my suggestion above does the same...",
      "comment_id": 1662917215,
      "user": "sydney-runkle",
      "created_at": "2024-07-02T17:30:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1662917215"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "tests/test_types.py",
      "line": 3514,
      "side": "RIGHT",
      "diff_hunk": "@@ -3494,6 +3494,44 @@ class Model(BaseModel):\n     }\n \n \n+def test_path_like_extra_subtype():\n+    class Model(BaseModel):\n+        str_type: os.PathLike[str]\n+        byte_type: os.PathLike[bytes]\n+        any_type: os.PathLike[Any]\n+\n+    m = Model(\n+        str_type='/foo/bar',\n+        byte_type=b'/foo/bar',\n+        any_type='/foo/bar',\n+    )\n+    assert m.str_type == Path('/foo/bar')\n+    assert m.byte_type == Path('/foo/bar')\n+    assert m.any_type == Path('/foo/bar')\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'str_type': {'format': 'path', 'title': 'Str Type', 'type': 'string'},\n+            'byte_type': {'format': 'path', 'title': 'Byte Type', 'type': 'string'},",
      "comment": "I feel like the `type` should be `bytes` for the `byte_type` path...",
      "comment_id": 1662918020,
      "user": "sydney-runkle",
      "created_at": "2024-07-02T17:31:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1662918020"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "tests/test_types.py",
      "line": 3514,
      "side": "RIGHT",
      "diff_hunk": "@@ -3494,6 +3494,44 @@ class Model(BaseModel):\n     }\n \n \n+def test_path_like_extra_subtype():\n+    class Model(BaseModel):\n+        str_type: os.PathLike[str]\n+        byte_type: os.PathLike[bytes]\n+        any_type: os.PathLike[Any]\n+\n+    m = Model(\n+        str_type='/foo/bar',\n+        byte_type=b'/foo/bar',\n+        any_type='/foo/bar',\n+    )\n+    assert m.str_type == Path('/foo/bar')\n+    assert m.byte_type == Path('/foo/bar')\n+    assert m.any_type == Path('/foo/bar')\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'str_type': {'format': 'path', 'title': 'Str Type', 'type': 'string'},\n+            'byte_type': {'format': 'path', 'title': 'Byte Type', 'type': 'string'},",
      "comment": "Honestly though, if someone complains we can fix this, I don't think it's super high priority and this gives us some flexibility to change it based on user experience.",
      "comment_id": 1664754131,
      "user": "sydney-runkle",
      "created_at": "2024-07-03T20:32:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1664754131"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9764,
      "file_path": "tests/test_types.py",
      "line": 3514,
      "side": "RIGHT",
      "diff_hunk": "@@ -3494,6 +3494,44 @@ class Model(BaseModel):\n     }\n \n \n+def test_path_like_extra_subtype():\n+    class Model(BaseModel):\n+        str_type: os.PathLike[str]\n+        byte_type: os.PathLike[bytes]\n+        any_type: os.PathLike[Any]\n+\n+    m = Model(\n+        str_type='/foo/bar',\n+        byte_type=b'/foo/bar',\n+        any_type='/foo/bar',\n+    )\n+    assert m.str_type == Path('/foo/bar')\n+    assert m.byte_type == Path('/foo/bar')\n+    assert m.any_type == Path('/foo/bar')\n+    assert Model.model_json_schema() == {\n+        'properties': {\n+            'str_type': {'format': 'path', 'title': 'Str Type', 'type': 'string'},\n+            'byte_type': {'format': 'path', 'title': 'Byte Type', 'type': 'string'},",
      "comment": "Bc it's really a string once you populate the path",
      "comment_id": 1664755045,
      "user": "sydney-runkle",
      "created_at": "2024-07-03T20:33:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/9764#discussion_r1664755045"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9591,
      "file_path": "pydantic/json_schema.py",
      "line": 665,
      "side": "RIGHT",
      "diff_hunk": "@@ -660,6 +661,9 @@ def str_schema(self, schema: core_schema.StringSchema) -> JsonSchemaValue:\n         \"\"\"\n         json_schema = {'type': 'string'}\n         self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)\n+        if isinstance(json_schema.get('pattern'), Pattern):\n+            # for now, we skip application of regex flags to the pattern",
      "comment": "```suggestion\r\n            # TODO: should we add regex flags to the pattern?\r\n```",
      "comment_id": 1633285980,
      "user": "davidhewitt",
      "created_at": "2024-06-10T13:48:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/9591#discussion_r1633285980"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9818,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 248,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,8 +241,14 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n             if constraint == 'multiple_of':\n                 json_schema_constraint = 'multiple_of'\n             elif constraint in {'min_length', 'max_length'}:\n-                if schema['type'] == 'list' or (\n-                    schema['type'] == 'json-or-python' and schema['json_schema']['type'] == 'list'\n+                inner_schema = (\n+                    schema['schema']  # type: ignore\n+                    if schema_type in {'function-before', 'function-wrap', 'function-after'}\n+                    else schema\n+                )",
      "comment": "I think maybe you should unpack these more recursively. Something like:\r\n```python\r\ninner_schema = schema\r\nwhile inner_schema['type'] in {'function-before', 'function-wrap', 'function-after'}:\r\n    inner_schema = inner_schema['schema']\r\n```\r\nThis will handle the case where multiple function validators wrap the same schema.",
      "comment_id": 1662638670,
      "user": "dmontagu",
      "created_at": "2024-07-02T14:26:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/9818#discussion_r1662638670"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9818,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 272,
      "side": "RIGHT",
      "diff_hunk": "@@ -235,41 +232,46 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n                 schema[constraint] = value\n             continue\n \n-        if constraint in {'pattern', 'strip_whitespace', 'to_lower', 'to_upper', 'coerce_numbers_to_str'}:\n+        if constraint in chain_schema_constraints:\n             chain_schema_steps.append(cs.str_schema(**{constraint: value}))\n-        elif constraint in {'gt', 'ge', 'lt', 'le', 'multiple_of', 'min_length', 'max_length'}:\n-            if constraint == 'multiple_of':\n-                json_schema_constraint = 'multiple_of'\n-            elif constraint in {'min_length', 'max_length'}:\n-                if schema['type'] == 'list' or (\n-                    schema['type'] == 'json-or-python' and schema['json_schema']['type'] == 'list'\n+        elif constraint in {*NUMERIC_CONSTRAINTS, *LENGTH_CONSTRAINTS}:\n+            if constraint in NUMERIC_CONSTRAINTS:\n+                json_schema_constraint = constraint\n+            elif constraint in LENGTH_CONSTRAINTS:\n+                inner_schema = schema\n+                while inner_schema['type'] in {'function-before', 'function-wrap', 'function-after'}:\n+                    inner_schema = inner_schema['schema']  # type: ignore\n+                inner_schema_type = inner_schema['type']\n+                if inner_schema_type == 'list' or (\n+                    inner_schema_type == 'json-or-python' and inner_schema['json_schema']['type'] == 'list'  # type: ignore\n                 ):\n                     json_schema_constraint = 'minItems' if constraint == 'min_length' else 'maxItems'\n                 else:\n                     json_schema_constraint = 'minLength' if constraint == 'min_length' else 'maxLength'\n-            else:\n-                json_schema_constraint = constraint\n \n             schema = cs.no_info_after_validator_function(\n-                partial(COMPARISON_VALIDATORS[constraint], **{constraint: value}), schema\n+                partial(get_constraint_validator(constraint), **{constraint: value}), schema\n             )\n-\n             add_js_update_schema(schema, lambda: {json_schema_constraint: as_jsonable_value(value)})\n         elif constraint == 'allow_inf_nan' and value is False:\n             schema = cs.no_info_after_validator_function(\n-                _validators.forbid_inf_nan_check,\n+                forbid_inf_nan_check,\n                 schema,\n             )\n         else:\n             raise RuntimeError(f'Unable to apply constraint {constraint} to schema {schema_type}')\n \n     for annotation in other_metadata:\n-        if isinstance(annotation, (at.Gt, at.Ge, at.Lt, at.Le, at.MultipleOf, at.MinLen, at.MaxLen)):\n-            constraint = CONSTRAINT_STR_FROM_ANNOTATED_TYPE[type(annotation)]\n+        try:\n+            constraint = _get_at_to_constraint_map()[type(annotation)]\n             schema = cs.no_info_after_validator_function(\n-                partial(COMPARISON_VALIDATORS[constraint], {constraint: getattr(annotation, constraint)}), schema\n+                partial(get_constraint_validator(constraint), {constraint: getattr(annotation, constraint)}), schema\n             )\n-        elif isinstance(annotation, at.Predicate):\n+            continue\n+        except KeyError:\n+            pass",
      "comment": "So this is one option for the fetching of the constraint",
      "comment_id": 1662865442,
      "user": "sydney-runkle",
      "created_at": "2024-07-02T16:48:59Z",
      "url": "https://github.com/pydantic/pydantic/pull/9818#discussion_r1662865442"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9818,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 329,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,31 +314,19 @@ def collect_known_metadata(annotations: Iterable[Any]) -> tuple[dict[str, Any],\n         #> ({'gt': 1, 'min_length': 42}, [Ellipsis])\n         ```\n     \"\"\"\n-    import annotated_types as at\n-\n     annotations = expand_grouped_metadata(annotations)\n \n     res: dict[str, Any] = {}\n     remaining: list[Any] = []\n+\n     for annotation in annotations:\n         # isinstance(annotation, PydanticMetadata) also covers ._fields:_PydanticGeneralMetadata\n         if isinstance(annotation, PydanticMetadata):\n             res.update(annotation.__dict__)\n         # we don't use dataclasses.asdict because that recursively calls asdict on the field values\n-        elif isinstance(annotation, at.MinLen):\n-            res.update({'min_length': annotation.min_length})\n-        elif isinstance(annotation, at.MaxLen):\n-            res.update({'max_length': annotation.max_length})\n-        elif isinstance(annotation, at.Gt):\n-            res.update({'gt': annotation.gt})\n-        elif isinstance(annotation, at.Ge):\n-            res.update({'ge': annotation.ge})\n-        elif isinstance(annotation, at.Lt):\n-            res.update({'lt': annotation.lt})\n-        elif isinstance(annotation, at.Le):\n-            res.update({'le': annotation.le})\n-        elif isinstance(annotation, at.MultipleOf):\n-            res.update({'multiple_of': annotation.multiple_of})\n+        elif (annotation_type := type(annotation)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+            constraint = at_to_constraint_map[annotation_type]\n+            res[constraint] = getattr(annotation, constraint)",
      "comment": "And this is the other - lmk what you prefer @dmontagu ",
      "comment_id": 1662865725,
      "user": "sydney-runkle",
      "created_at": "2024-07-02T16:49:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/9818#discussion_r1662865725"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9818,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 164,
      "side": "RIGHT",
      "diff_hunk": "@@ -168,6 +157,25 @@ def expand_grouped_metadata(annotations: Iterable[Any]) -> Iterable[Any]:\n             yield annotation\n \n \n+@lru_cache\n+def _get_at_to_constraint_map() -> dict[type, str]:\n+    \"\"\"Return a mapping of annotated types to constraints.\n+\n+    Stored in this function because we don't allow global imports of annotated types, but we cache for performance.",
      "comment": "May also want to mention that the main reason for doing this in a cached function is not so much for performance, but so that we can define it in one place rather than copy/pasting the definition. We need it to be in a function in order to defer the import, and we cache the result of that function call because .. why not",
      "comment_id": 1662867647,
      "user": "dmontagu",
      "created_at": "2024-07-02T16:50:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/9818#discussion_r1662867647"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9818,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 329,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,31 +314,19 @@ def collect_known_metadata(annotations: Iterable[Any]) -> tuple[dict[str, Any],\n         #> ({'gt': 1, 'min_length': 42}, [Ellipsis])\n         ```\n     \"\"\"\n-    import annotated_types as at\n-\n     annotations = expand_grouped_metadata(annotations)\n \n     res: dict[str, Any] = {}\n     remaining: list[Any] = []\n+\n     for annotation in annotations:\n         # isinstance(annotation, PydanticMetadata) also covers ._fields:_PydanticGeneralMetadata\n         if isinstance(annotation, PydanticMetadata):\n             res.update(annotation.__dict__)\n         # we don't use dataclasses.asdict because that recursively calls asdict on the field values\n-        elif isinstance(annotation, at.MinLen):\n-            res.update({'min_length': annotation.min_length})\n-        elif isinstance(annotation, at.MaxLen):\n-            res.update({'max_length': annotation.max_length})\n-        elif isinstance(annotation, at.Gt):\n-            res.update({'gt': annotation.gt})\n-        elif isinstance(annotation, at.Ge):\n-            res.update({'ge': annotation.ge})\n-        elif isinstance(annotation, at.Lt):\n-            res.update({'lt': annotation.lt})\n-        elif isinstance(annotation, at.Le):\n-            res.update({'le': annotation.le})\n-        elif isinstance(annotation, at.MultipleOf):\n-            res.update({'multiple_of': annotation.multiple_of})\n+        elif (annotation_type := type(annotation)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+            constraint = at_to_constraint_map[annotation_type]\n+            res[constraint] = getattr(annotation, constraint)",
      "comment": "Do you need to handle the possible `AttributeError` here? I saw a KeyError handled above, thought it might be related, but maybe not?",
      "comment_id": 1662872465,
      "user": "dmontagu",
      "created_at": "2024-07-02T16:55:11Z",
      "url": "https://github.com/pydantic/pydantic/pull/9818#discussion_r1662872465"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9818,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 329,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,31 +314,19 @@ def collect_known_metadata(annotations: Iterable[Any]) -> tuple[dict[str, Any],\n         #> ({'gt': 1, 'min_length': 42}, [Ellipsis])\n         ```\n     \"\"\"\n-    import annotated_types as at\n-\n     annotations = expand_grouped_metadata(annotations)\n \n     res: dict[str, Any] = {}\n     remaining: list[Any] = []\n+\n     for annotation in annotations:\n         # isinstance(annotation, PydanticMetadata) also covers ._fields:_PydanticGeneralMetadata\n         if isinstance(annotation, PydanticMetadata):\n             res.update(annotation.__dict__)\n         # we don't use dataclasses.asdict because that recursively calls asdict on the field values\n-        elif isinstance(annotation, at.MinLen):\n-            res.update({'min_length': annotation.min_length})\n-        elif isinstance(annotation, at.MaxLen):\n-            res.update({'max_length': annotation.max_length})\n-        elif isinstance(annotation, at.Gt):\n-            res.update({'gt': annotation.gt})\n-        elif isinstance(annotation, at.Ge):\n-            res.update({'ge': annotation.ge})\n-        elif isinstance(annotation, at.Lt):\n-            res.update({'lt': annotation.lt})\n-        elif isinstance(annotation, at.Le):\n-            res.update({'le': annotation.le})\n-        elif isinstance(annotation, at.MultipleOf):\n-            res.update({'multiple_of': annotation.multiple_of})\n+        elif (annotation_type := type(annotation)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+            constraint = at_to_constraint_map[annotation_type]\n+            res[constraint] = getattr(annotation, constraint)",
      "comment": "I find this cleaner than the other spot if that's what you are asking about, but it's not a big deal.\r\n\r\nI think there are some micro-optimizations we could do to improve performance by reducing the number of calls to the `_get_at_to_constraint_map` (in particular, to make sure it doesn't get called in a loop) but it's probably not worth the effort, it would probably be a lot uglier to save like 5ms in a big app.",
      "comment_id": 1662875076,
      "user": "dmontagu",
      "created_at": "2024-07-02T16:56:42Z",
      "url": "https://github.com/pydantic/pydantic/pull/9818#discussion_r1662875076"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9818,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 329,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,31 +314,19 @@ def collect_known_metadata(annotations: Iterable[Any]) -> tuple[dict[str, Any],\n         #> ({'gt': 1, 'min_length': 42}, [Ellipsis])\n         ```\n     \"\"\"\n-    import annotated_types as at\n-\n     annotations = expand_grouped_metadata(annotations)\n \n     res: dict[str, Any] = {}\n     remaining: list[Any] = []\n+\n     for annotation in annotations:\n         # isinstance(annotation, PydanticMetadata) also covers ._fields:_PydanticGeneralMetadata\n         if isinstance(annotation, PydanticMetadata):\n             res.update(annotation.__dict__)\n         # we don't use dataclasses.asdict because that recursively calls asdict on the field values\n-        elif isinstance(annotation, at.MinLen):\n-            res.update({'min_length': annotation.min_length})\n-        elif isinstance(annotation, at.MaxLen):\n-            res.update({'max_length': annotation.max_length})\n-        elif isinstance(annotation, at.Gt):\n-            res.update({'gt': annotation.gt})\n-        elif isinstance(annotation, at.Ge):\n-            res.update({'ge': annotation.ge})\n-        elif isinstance(annotation, at.Lt):\n-            res.update({'lt': annotation.lt})\n-        elif isinstance(annotation, at.Le):\n-            res.update({'le': annotation.le})\n-        elif isinstance(annotation, at.MultipleOf):\n-            res.update({'multiple_of': annotation.multiple_of})\n+        elif (annotation_type := type(annotation)) in (at_to_constraint_map := _get_at_to_constraint_map()):\n+            constraint = at_to_constraint_map[annotation_type]\n+            res[constraint] = getattr(annotation, constraint)",
      "comment": "Don't need to deal with the attribute error here bc we do the `in` check above. I'll go with this approach!",
      "comment_id": 1662882533,
      "user": "sydney-runkle",
      "created_at": "2024-07-02T17:02:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/9818#discussion_r1662882533"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9787,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1263,
      "side": "RIGHT",
      "diff_hunk": "@@ -1248,7 +1255,12 @@ def _literal_schema(self, literal_type: Any) -> CoreSchema:\n         \"\"\"Generate schema for a Literal.\"\"\"\n         expected = _typing_extra.all_literal_values(literal_type)\n         assert expected, f'literal \"expected\" cannot be empty, obj={literal_type}'\n-        return core_schema.literal_schema(expected)\n+        schema = core_schema.literal_schema(expected)\n+\n+        if self._config_wrapper.use_enum_values:\n+            schema = core_schema.no_info_after_validator_function(enum_or_var_gettr, schema)\n+\n+        return schema",
      "comment": "```suggestion\r\n        schema = core_schema.literal_schema(expected)\r\n\r\n        if self._config_wrapper.use_enum_values:\r\n            schema = core_schema.no_info_after_validator_function(\r\n                lambda v: v.value if isinstance(v, Enum) else v, schema\r\n            )\r\n\r\n        return schema\r\n```",
      "comment_id": 1658846663,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T14:28:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/9787#discussion_r1658846663"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9787,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1253,
      "side": "RIGHT",
      "diff_hunk": "@@ -1248,7 +1248,14 @@ def _literal_schema(self, literal_type: Any) -> CoreSchema:\n         \"\"\"Generate schema for a Literal.\"\"\"\n         expected = _typing_extra.all_literal_values(literal_type)\n         assert expected, f'literal \"expected\" cannot be empty, obj={literal_type}'\n-        return core_schema.literal_schema(expected)\n+        schema = core_schema.literal_schema(expected)\n+\n+        if self._config_wrapper.use_enum_values:",
      "comment": "Let's add one more check, where we only apply this change if there's one or more `Enum`s in `expected.",
      "comment_id": 1659059514,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T17:06:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/9787#discussion_r1659059514"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9787,
      "file_path": "tests/test_main.py",
      "line": 776,
      "side": "RIGHT",
      "diff_hunk": "@@ -768,33 +768,59 @@ class Model(BaseModel):\n     assert foo == 'foo'\n \n \n-def test_literal_enum_values():\n-    FooEnum = Enum('FooEnum', {'foo': 'foo_value', 'bar': 'bar_value'})\n+class StrFoo(str, Enum):\n+    FOO = 'foo'\n+    BAR = 'bar'\n \n+\n+def test_literal_use_enum_values():",
      "comment": "Let's leave this old test as is, and create a new one in addition please!",
      "comment_id": 1659064543,
      "user": "sydney-runkle",
      "created_at": "2024-06-28T17:08:55Z",
      "url": "https://github.com/pydantic/pydantic/pull/9787#discussion_r1659064543"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9787,
      "file_path": "tests/test_main.py",
      "line": 776,
      "side": "RIGHT",
      "diff_hunk": "@@ -768,33 +768,59 @@ class Model(BaseModel):\n     assert foo == 'foo'\n \n \n-def test_literal_enum_values():\n-    FooEnum = Enum('FooEnum', {'foo': 'foo_value', 'bar': 'bar_value'})\n+class StrFoo(str, Enum):\n+    FOO = 'foo'\n+    BAR = 'bar'\n \n+\n+def test_literal_use_enum_values():",
      "comment": "Reverted as much as possible to the original test, the two remaining changes are needed to adopt it to this MR",
      "comment_id": 1662115014,
      "user": "kwint",
      "created_at": "2024-07-02T08:51:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/9787#discussion_r1662115014"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9787,
      "file_path": "tests/test_main.py",
      "line": 782,
      "side": "RIGHT",
      "diff_hunk": "@@ -777,9 +777,9 @@ class Model(BaseModel):\n         model_config = ConfigDict(use_enum_values=True)\n \n     m = Model(baz=FooEnum.foo)\n-    assert m.model_dump() == {'baz': FooEnum.foo, 'boo': 'hoo'}\n+    assert m.model_dump() == {'baz': 'foo_value', 'boo': 'hoo'}\n     assert m.model_dump(mode='json') == {'baz': 'foo_value', 'boo': 'hoo'}\n-    assert m.baz.value == 'foo_value'\n+    assert m.baz == 'foo_value'",
      "comment": "Hmm, this existing test makes me think that this would technically be a breaking change...",
      "comment_id": 1662460876,
      "user": "sydney-runkle",
      "created_at": "2024-07-02T12:51:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/9787#discussion_r1662460876"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9787,
      "file_path": "tests/test_main.py",
      "line": 782,
      "side": "RIGHT",
      "diff_hunk": "@@ -777,9 +777,9 @@ class Model(BaseModel):\n         model_config = ConfigDict(use_enum_values=True)\n \n     m = Model(baz=FooEnum.foo)\n-    assert m.model_dump() == {'baz': FooEnum.foo, 'boo': 'hoo'}\n+    assert m.model_dump() == {'baz': 'foo_value', 'boo': 'hoo'}\n     assert m.model_dump(mode='json') == {'baz': 'foo_value', 'boo': 'hoo'}\n-    assert m.baz.value == 'foo_value'\n+    assert m.baz == 'foo_value'",
      "comment": "Looks like this test was initially introduced in https://github.com/pydantic/pydantic/pull/1838/files, where I think this assertion:\r\n\r\n```py\r\nassert m.baz.value == 'foo_value'\r\n```\r\n\r\nWas definitely a mistake",
      "comment_id": 1662576441,
      "user": "sydney-runkle",
      "created_at": "2024-07-02T13:50:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/9787#discussion_r1662576441"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9787,
      "file_path": "tests/test_main.py",
      "line": 782,
      "side": "RIGHT",
      "diff_hunk": "@@ -777,9 +777,9 @@ class Model(BaseModel):\n         model_config = ConfigDict(use_enum_values=True)\n \n     m = Model(baz=FooEnum.foo)\n-    assert m.model_dump() == {'baz': FooEnum.foo, 'boo': 'hoo'}\n+    assert m.model_dump() == {'baz': 'foo_value', 'boo': 'hoo'}\n     assert m.model_dump(mode='json') == {'baz': 'foo_value', 'boo': 'hoo'}\n-    assert m.baz.value == 'foo_value'\n+    assert m.baz == 'foo_value'",
      "comment": "So I'll modify my claim - I think this is definitely a fix, not a breaking change.",
      "comment_id": 1662581672,
      "user": "sydney-runkle",
      "created_at": "2024-07-02T13:53:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/9787#discussion_r1662581672"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9787,
      "file_path": "tests/test_main.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -796,6 +796,34 @@ class Model(BaseModel):\n     ]\n \n \n+class StrFoo(str, Enum):\n+    FOO = 'foo'\n+    BAR = 'bar'\n+\n+\n+@pytest.mark.parametrize('value', [StrFoo.FOO, StrFoo.FOO.value, 'foo', 'hello'])\n+def test_literal_use_enum_values_multi_type(value):\n+    class Model(BaseModel):\n+        baz: Literal[StrFoo.FOO, 'hello']\n+        model_config = ConfigDict(use_enum_values=True)\n+\n+    assert isinstance(Model(baz=value).baz, str)\n+\n+\n+def test_literal_use_enum_values_with_default():\n+    class Model(BaseModel):\n+        baz: Literal[StrFoo.FOO] = Field(default=StrFoo.FOO)\n+        model_config = ConfigDict(use_enum_values=True)\n+\n+    assert isinstance(Model().baz, str)\n+\n+    validated = Model.model_validate_json('{\"baz\": \"foo\"}')\n+    assert isinstance(validated.baz, str)\n+\n+    validated = Model.model_validate({'baz': StrFoo.FOO})\n+    assert isinstance(validated.baz, str)",
      "comment": "```suggestion\r\n@pytest.mark.parametrize('value', [StrFoo.FOO, StrFoo.FOO.value, 'foo', 'hello'])\r\ndef test_literal_use_enum_values_multi_type(value) -> None:\r\n    class Model(BaseModel):\r\n        baz: Literal[StrFoo.FOO, 'hello']\r\n        model_config = ConfigDict(use_enum_values=True)\r\n\r\n    assert isinstance(Model(baz=value).baz, str)\r\n\r\n\r\ndef test_literal_use_enum_values_with_default() -> None:\r\n    class Model(BaseModel):\r\n        baz: Literal[StrFoo.FOO] = Field(default=StrFoo.FOO)\r\n        model_config = ConfigDict(use_enum_values=True, validate_default=True)\r\n\r\n    validated = Model()\r\n    assert type(validated.baz) is str\r\n    assert type(validated.model_dump()['baz']) is str\r\n\r\n    validated = Model.model_validate_json('{\"baz\": \"foo\"}')\r\n    assert type(validated.baz) is str\r\n    assert type(validated.model_dump()['baz']) is str\r\n\r\n    validated = Model.model_validate({'baz': StrFoo.FOO})\r\n    assert type(validated.baz) is str\r\n    assert type(validated.model_dump()['baz']) is str\r\n```",
      "comment_id": 1662588697,
      "user": "sydney-runkle",
      "created_at": "2024-07-02T13:57:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/9787#discussion_r1662588697"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9760,
      "file_path": "tests/test_validate_call.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -803,3 +804,44 @@ def foo(bar: 'list[int | str]') -> 'list[int | str]':\n             'input': {'not a str or int'},\n         },\n     ]\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_validate_call_with_pep_695_syntax() -> None:\n+    globs = {}\n+    exec(\n+        \"\"\"\n+from typing import Iterable\n+from pydantic import validate_call\n+\n+@validate_call\n+def max[T](args: Iterable[T]) -> T:\n+    return sorted(args, reverse=True)[0]\n+        \"\"\",\n+        globs,\n+    )\n+    max = globs['max']\n+    assert len(max.__type_params__) == 1",
      "comment": "Is there any way to test that `validate_call` is actually using/seeing `T`?",
      "comment_id": 1655038836,
      "user": "alexmojaki",
      "created_at": "2024-06-26T14:55:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/9760#discussion_r1655038836"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9760,
      "file_path": "tests/test_validate_call.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -803,3 +804,44 @@ def foo(bar: 'list[int | str]') -> 'list[int | str]':\n             'input': {'not a str or int'},\n         },\n     ]\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_validate_call_with_pep_695_syntax() -> None:\n+    globs = {}\n+    exec(\n+        \"\"\"\n+from typing import Iterable\n+from pydantic import validate_call\n+\n+@validate_call\n+def max[T](args: Iterable[T]) -> T:\n+    return sorted(args, reverse=True)[0]\n+        \"\"\",\n+        globs,\n+    )\n+    max = globs['max']\n+    assert len(max.__type_params__) == 1",
      "comment": "Well, I don't think it is: https://github.com/pydantic/pydantic/issues/7796\r\n\r\nWhich I think is something we can fix separately with the issue above",
      "comment_id": 1655067130,
      "user": "sydney-runkle",
      "created_at": "2024-06-26T15:09:57Z",
      "url": "https://github.com/pydantic/pydantic/pull/9760#discussion_r1655067130"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9760,
      "file_path": "tests/test_validate_call.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -803,3 +804,44 @@ def foo(bar: 'list[int | str]') -> 'list[int | str]':\n             'input': {'not a str or int'},\n         },\n     ]\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_validate_call_with_pep_695_syntax() -> None:\n+    globs = {}\n+    exec(\n+        \"\"\"\n+from typing import Iterable\n+from pydantic import validate_call\n+\n+@validate_call\n+def max[T](args: Iterable[T]) -> T:\n+    return sorted(args, reverse=True)[0]\n+        \"\"\",\n+        globs,\n+    )\n+    max = globs['max']\n+    assert len(max.__type_params__) == 1",
      "comment": "but is there a type param in the pydantic schema or something? or is it replaced with `Any`?",
      "comment_id": 1655071138,
      "user": "alexmojaki",
      "created_at": "2024-06-26T15:12:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/9760#discussion_r1655071138"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9760,
      "file_path": "tests/test_validate_call.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -803,3 +804,44 @@ def foo(bar: 'list[int | str]') -> 'list[int | str]':\n             'input': {'not a str or int'},\n         },\n     ]\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_validate_call_with_pep_695_syntax() -> None:\n+    globs = {}\n+    exec(\n+        \"\"\"\n+from typing import Iterable\n+from pydantic import validate_call\n+\n+@validate_call\n+def max[T](args: Iterable[T]) -> T:\n+    return sorted(args, reverse=True)[0]\n+        \"\"\",\n+        globs,\n+    )\n+    max = globs['max']\n+    assert len(max.__type_params__) == 1",
      "comment": "It has an arguments schema with an `Any` for the item type",
      "comment_id": 1655087775,
      "user": "sydney-runkle",
      "created_at": "2024-06-26T15:24:03Z",
      "url": "https://github.com/pydantic/pydantic/pull/9760#discussion_r1655087775"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9760,
      "file_path": "tests/test_validate_call.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -803,3 +804,44 @@ def foo(bar: 'list[int | str]') -> 'list[int | str]':\n             'input': {'not a str or int'},\n         },\n     ]\n+\n+\n+@pytest.mark.skipif(sys.version_info < (3, 12), reason='requires Python 3.12+ for PEP 695 syntax with generics')\n+def test_validate_call_with_pep_695_syntax() -> None:\n+    globs = {}\n+    exec(\n+        \"\"\"\n+from typing import Iterable\n+from pydantic import validate_call\n+\n+@validate_call\n+def max[T](args: Iterable[T]) -> T:\n+    return sorted(args, reverse=True)[0]\n+        \"\"\",\n+        globs,\n+    )\n+    max = globs['max']\n+    assert len(max.__type_params__) == 1",
      "comment": "In a sense this PR is a bit silly, bc we're fixing the syntax for something that doesn't work, but it at least sets the stage to get the type params in accessible places.",
      "comment_id": 1655088515,
      "user": "sydney-runkle",
      "created_at": "2024-06-26T15:24:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/9760#discussion_r1655088515"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9727,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 736,
      "side": "RIGHT",
      "diff_hunk": "@@ -717,37 +717,33 @@ def unwrap_wrapped_function(\n     unwrap_class_static_method: bool = True,\n ) -> Any:\n     \"\"\"Recursively unwraps a wrapped function until the underlying function is reached.\n-    This handles property, functools.partial, functools.partialmethod, staticmethod and classmethod.\n+    This handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod.\n \n     Args:\n         func: The function to unwrap.\n-        unwrap_partial: If True (default), unwrap partial and partialmethod decorators, otherwise don't.\n-            decorators.\n+        unwrap_partial: If True (default), unwrap partial and partialmethod decorators.\n         unwrap_class_static_method: If True (default), also unwrap classmethod and staticmethod\n             decorators. If False, only unwrap partial and partialmethod decorators.\n \n     Returns:\n         The underlying function of the wrapped function.\n     \"\"\"\n-    all: set[Any] = {property, cached_property}\n-\n-    if unwrap_partial:\n-        all.update({partial, partialmethod})\n-\n-    if unwrap_class_static_method:\n-        all.update({staticmethod, classmethod})\n+    # Define the types we want to check against as a single tuple.\n+    unwrap_types = (\n+        (property, cached_property)\n+        + (partial, partialmethod if unwrap_partial else ())\n+        + (staticmethod, classmethod if unwrap_class_static_method else ())\n+    )",
      "comment": "```suggestion\r\n    unwrap_types = (\r\n        (property, cached_property)\r\n        + (partial, partialmethod) if unwrap_partial else ()\r\n        + (staticmethod, classmethod) if unwrap_class_static_method else ()\r\n    )\r\n```",
      "comment_id": 1649507685,
      "user": "sydney-runkle",
      "created_at": "2024-06-22T00:12:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/9727#discussion_r1649507685"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9727,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 746,
      "side": "RIGHT",
      "diff_hunk": "@@ -717,37 +717,33 @@ def unwrap_wrapped_function(\n     unwrap_class_static_method: bool = True,\n ) -> Any:\n     \"\"\"Recursively unwraps a wrapped function until the underlying function is reached.\n-    This handles property, functools.partial, functools.partialmethod, staticmethod and classmethod.\n+    This handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod.\n \n     Args:\n         func: The function to unwrap.\n-        unwrap_partial: If True (default), unwrap partial and partialmethod decorators, otherwise don't.\n-            decorators.\n+        unwrap_partial: If True (default), unwrap partial and partialmethod decorators.\n         unwrap_class_static_method: If True (default), also unwrap classmethod and staticmethod\n             decorators. If False, only unwrap partial and partialmethod decorators.\n \n     Returns:\n         The underlying function of the wrapped function.\n     \"\"\"\n-    all: set[Any] = {property, cached_property}\n-\n-    if unwrap_partial:\n-        all.update({partial, partialmethod})\n-\n-    if unwrap_class_static_method:\n-        all.update({staticmethod, classmethod})\n+    # Define the types we want to check against as a single tuple.\n+    unwrap_types = (\n+        (property, cached_property)\n+        + (partial, partialmethod if unwrap_partial else ())\n+        + (staticmethod, classmethod if unwrap_class_static_method else ())\n+    )\n \n-    while isinstance(func, tuple(all)):\n-        if unwrap_class_static_method and isinstance(func, (classmethod, staticmethod)):\n-            func = func.__func__\n-        elif isinstance(func, (partial, partialmethod)):\n+    while isinstance(func, unwrap_types):\n+        if isinstance(func, (partial, partialmethod)):\n             func = func.func\n         elif isinstance(func, property):\n             func = func.fget  # arbitrary choice, convenient for computed fields\n-        else:\n-            # Make coverage happy as it can only get here in the last possible case\n-            assert isinstance(func, cached_property)\n+        elif isinstance(func, cached_property):\n             func = func.func  # type: ignore\n+        elif unwrap_class_static_method and isinstance(func, (classmethod, staticmethod)):\n+            func = func.__func__",
      "comment": "One note here - I think we might make coverage unhappy with this change",
      "comment_id": 1649508895,
      "user": "sydney-runkle",
      "created_at": "2024-06-22T00:18:19Z",
      "url": "https://github.com/pydantic/pydantic/pull/9727#discussion_r1649508895"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9727,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 736,
      "side": "RIGHT",
      "diff_hunk": "@@ -717,37 +717,33 @@ def unwrap_wrapped_function(\n     unwrap_class_static_method: bool = True,\n ) -> Any:\n     \"\"\"Recursively unwraps a wrapped function until the underlying function is reached.\n-    This handles property, functools.partial, functools.partialmethod, staticmethod and classmethod.\n+    This handles property, functools.partial, functools.partialmethod, staticmethod, and classmethod.\n \n     Args:\n         func: The function to unwrap.\n-        unwrap_partial: If True (default), unwrap partial and partialmethod decorators, otherwise don't.\n-            decorators.\n+        unwrap_partial: If True (default), unwrap partial and partialmethod decorators.\n         unwrap_class_static_method: If True (default), also unwrap classmethod and staticmethod\n             decorators. If False, only unwrap partial and partialmethod decorators.\n \n     Returns:\n         The underlying function of the wrapped function.\n     \"\"\"\n-    all: set[Any] = {property, cached_property}\n-\n-    if unwrap_partial:\n-        all.update({partial, partialmethod})\n-\n-    if unwrap_class_static_method:\n-        all.update({staticmethod, classmethod})\n+    # Define the types we want to check against as a single tuple.\n+    unwrap_types = (\n+        (property, cached_property)\n+        + (partial, partialmethod if unwrap_partial else ())\n+        + (staticmethod, classmethod if unwrap_class_static_method else ())\n+    )",
      "comment": "thank you for this, I played a bit with the different ways of doing this and found the best one which had the correct behavior. Updated the PR with the change",
      "comment_id": 1653612796,
      "user": "misrasaurabh1",
      "created_at": "2024-06-25T21:49:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/9727#discussion_r1653612796"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9743,
      "file_path": "pydantic/_internal/_typing_extra.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -109,10 +109,8 @@ def all_literal_values(type_: type[Any]) -> list[Any]:\n \n \n def is_annotated(ann_type: Any) -> bool:\n-    from ._utils import lenient_issubclass\n-\n     origin = get_origin(ann_type)\n-    return origin is not None and lenient_issubclass(origin, Annotated)\n+    return (origin is not None) and (origin is Annotated)",
      "comment": "```suggestion\r\n    return origin is Annotated\r\n```",
      "comment_id": 1653380170,
      "user": "sydney-runkle",
      "created_at": "2024-06-25T19:02:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/9743#discussion_r1653380170"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9743,
      "file_path": "tests/test_computed_fields.py",
      "line": 432,
      "side": "RIGHT",
      "diff_hunk": "@@ -427,7 +427,10 @@ def _double(self) -> int:\n     assert m.model_dump() == {'x': 2, '_double': 4}\n \n \n-@pytest.mark.skipif(sys.version_info < (3, 9), reason='@computed_field @classmethod @property only works in 3.9+')\n+@pytest.mark.skipif(\n+    sys.version_info < (3, 9) or sys.version_info >= (3, 13),\n+    reason='@computed_field @classmethod @property only works in 3.9-3.12',",
      "comment": "I didn't find an easy way - I suppose you could create a custom decorator that basically handles the `classmethod` stuff with `__wrapped__` as suggested here:\r\n\r\nhttps://github.com/python/cpython/pull/92379/files#diff-78f24041d66ab8ed2ae1aee94bcd42396d27af833cb96a3c506294c6d6dce82d",
      "comment_id": 1653395326,
      "user": "sydney-runkle",
      "created_at": "2024-06-25T19:11:40Z",
      "url": "https://github.com/pydantic/pydantic/pull/9743#discussion_r1653395326"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9743,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +37,11 @@ def __init__(self, function: Callable[..., Any], config: ConfigDict | None, vali\n             self.__module__ = function.__module__\n \n         namespace = _typing_extra.add_module_globals(function, None)\n+        # TODO: this is a bit of a hack, we should probably have a better way to handle this\n+        # specifically, we shouldn't be pumping the namespace full of type_params\n+        # when we take namespace and type_params arguments in eval_type_backport\n+        type_params = getattr(schema_type, '__type_params__', ())\n+        namespace.update({param.__name__: param for param in type_params})",
      "comment": "```suggestion\r\n        namespace = {param.__name__: param for param in type_params} | namespace\r\n```\r\n\r\nThis gives `type_params` lower precedence which is important",
      "comment_id": 1653398803,
      "user": "alexmojaki",
      "created_at": "2024-06-25T19:13:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/9743#discussion_r1653398803"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9743,
      "file_path": "pydantic/_internal/_validate_call.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +37,11 @@ def __init__(self, function: Callable[..., Any], config: ConfigDict | None, vali\n             self.__module__ = function.__module__\n \n         namespace = _typing_extra.add_module_globals(function, None)\n+        # TODO: this is a bit of a hack, we should probably have a better way to handle this\n+        # specifically, we shouldn't be pumping the namespace full of type_params\n+        # when we take namespace and type_params arguments in eval_type_backport\n+        type_params = getattr(schema_type, '__type_params__', ())\n+        namespace.update({param.__name__: param for param in type_params})",
      "comment": "Ah yeah, but the `|` syntax isn't supported in 3.8",
      "comment_id": 1653400303,
      "user": "sydney-runkle",
      "created_at": "2024-06-25T19:14:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/9743#discussion_r1653400303"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9751,
      "file_path": "pydantic/typing.py",
      "line": 402,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +399,10 @@ def resolve_annotations(raw_annotations: Dict[str, Type[Any]], module_name: Opti\n             else:\n                 value = ForwardRef(value, is_argument=False)\n         try:\n-            value = _eval_type(value, base_globals, None)\n+            if sys.version_info > (3, 13):",
      "comment": "Shouldn't it be `>= 3.13`?\r\n```suggestion\r\n            if sys.version_info >= (3, 13):\r\n```",
      "comment_id": 1652814316,
      "user": "hramezani",
      "created_at": "2024-06-25T13:20:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/9751#discussion_r1652814316"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9751,
      "file_path": "pydantic/typing.py",
      "line": 402,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +399,10 @@ def resolve_annotations(raw_annotations: Dict[str, Type[Any]], module_name: Opti\n             else:\n                 value = ForwardRef(value, is_argument=False)\n         try:\n-            value = _eval_type(value, base_globals, None)\n+            if sys.version_info > (3, 13):",
      "comment": "```suggestion\r\n            if sys.version_info[:2] >= (3, 13):\r\n```",
      "comment_id": 1652825908,
      "user": "alexmojaki",
      "created_at": "2024-06-25T13:27:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/9751#discussion_r1652825908"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9751,
      "file_path": "pydantic/typing.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +399,10 @@ def resolve_annotations(raw_annotations: Dict[str, Type[Any]], module_name: Opti\n             else:\n                 value = ForwardRef(value, is_argument=False)\n         try:\n-            value = _eval_type(value, base_globals, None)\n+            if sys.version_info > (3, 13):\n+                value = _eval_type(value, base_globals, None, type_params=())",
      "comment": "I assume we're fine with the new type param syntax just not working in v1?",
      "comment_id": 1652827241,
      "user": "alexmojaki",
      "created_at": "2024-06-25T13:28:26Z",
      "url": "https://github.com/pydantic/pydantic/pull/9751#discussion_r1652827241"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9751,
      "file_path": "pydantic/typing.py",
      "line": 402,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +399,10 @@ def resolve_annotations(raw_annotations: Dict[str, Type[Any]], module_name: Opti\n             else:\n                 value = ForwardRef(value, is_argument=False)\n         try:\n-            value = _eval_type(value, base_globals, None)\n+            if sys.version_info > (3, 13):",
      "comment": "I don't think I think we use the pattern I've suggested for almost all of our version info checks...",
      "comment_id": 1652840503,
      "user": "sydney-runkle",
      "created_at": "2024-06-25T13:37:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/9751#discussion_r1652840503"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9751,
      "file_path": "pydantic/typing.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +399,10 @@ def resolve_annotations(raw_annotations: Dict[str, Type[Any]], module_name: Opti\n             else:\n                 value = ForwardRef(value, is_argument=False)\n         try:\n-            value = _eval_type(value, base_globals, None)\n+            if sys.version_info > (3, 13):\n+                value = _eval_type(value, base_globals, None, type_params=())",
      "comment": "@vfazio, to your point from earlier, this is more of a bandaid and not an actual fix (we're not really adding support for 3.13, just ensuring it doesn't break things)",
      "comment_id": 1652842085,
      "user": "sydney-runkle",
      "created_at": "2024-06-25T13:38:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/9751#discussion_r1652842085"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/fields.py",
      "line": 758,
      "side": "RIGHT",
      "diff_hunk": "@@ -752,6 +755,7 @@ def Field(  # noqa: C901\n         decimal_places: Maximum number of decimal places allowed for numbers.\n         union_mode: The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`.\n             See [Union Mode](../concepts/unions.md#union-modes) for details.\n+        fail_fast: If `True`, validation will stop on the first error. If `False`, all validation errors will be collected.",
      "comment": "I think we should clarify that this is for iterable types throughout the docs in this PR",
      "comment_id": 1649223608,
      "user": "sydney-runkle",
      "created_at": "2024-06-21T17:04:31Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649223608"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3015,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,31 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"A `FailFast` can be used to specify that validation should stop at the first error.",
      "comment": "```suggestion\r\n    \"\"\"A `FailFast` annotation can be used to specify that validation should stop at the first error.\r\n```",
      "comment_id": 1649224926,
      "user": "sydney-runkle",
      "created_at": "2024-06-21T17:05:24Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649224926"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3017,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,31 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"A `FailFast` can be used to specify that validation should stop at the first error.\n+\n+    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.",
      "comment": "Let's add a note on performance here.\r\n\r\nGiven that this is a performance focused feature, let's also add a note on this to the `Performance` section of the conceptual docs.",
      "comment_id": 1649227941,
      "user": "sydney-runkle",
      "created_at": "2024-06-21T17:06:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649227941"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3028,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,31 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"A `FailFast` can be used to specify that validation should stop at the first error.\n+\n+    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.\n+\n+    ```py\n+    from typing import List\n+    from typing_extensions import Annotated\n+    from pydantic import BaseModel, FailFast\n+\n+    class Model(BaseModel):\n+        x: Annotated[List[int], FailFast()]\n+\n+    # This will raise a single error for the first invalid value and stop validation\n+    obj = Model(x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 'c'])",
      "comment": "I believe there's a test failing here just bc of this formatting - example looks good overall.\r\n\r\nYou can also use `mkdocs` [annotations](https://squidfunk.github.io/mkdocs-material/reference/annotations/) to make this look a bit cleaner.",
      "comment_id": 1649229906,
      "user": "sydney-runkle",
      "created_at": "2024-06-21T17:07:29Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649229906"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3036,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,33 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"\n+    A `FailFast` can be used to specify that validation should stop at the first error.\n+\n+    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.\n+\n+    ```py\n+    from typing_extensions import Annotated\n+    from pydantic import BaseModel, FailFast\n+\n+    class Model(BaseModel):\n+        x: Annotated[int, FailFast()]\n+\n+    # This will raise a single error for the first invalid value and stop validation\n+    obj = Model(\n+        x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 10, 'c']\n+    )\n+    ```\n+    \"\"\"\n+\n+    fail_fast: bool = True\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n+        schema = handler(source_type)\n+        schema['fail_fast'] = self.fail_fast  # type: ignore",
      "comment": "I think we might be able to skip adding this function here, and instead apply this constraint when we apply other metadata, in `_internal/_known_annotated_metadata.py`",
      "comment_id": 1649234106,
      "user": "sydney-runkle",
      "created_at": "2024-06-21T17:11:30Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649234106"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3036,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,33 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"\n+    A `FailFast` can be used to specify that validation should stop at the first error.\n+\n+    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.\n+\n+    ```py\n+    from typing_extensions import Annotated\n+    from pydantic import BaseModel, FailFast\n+\n+    class Model(BaseModel):\n+        x: Annotated[int, FailFast()]\n+\n+    # This will raise a single error for the first invalid value and stop validation\n+    obj = Model(\n+        x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 10, 'c']\n+    )\n+    ```\n+    \"\"\"\n+\n+    fail_fast: bool = True\n+\n+    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n+        schema = handler(source_type)\n+        schema['fail_fast'] = self.fail_fast  # type: ignore",
      "comment": "Specifically in the `apply_known_metadata` function",
      "comment_id": 1649234769,
      "user": "sydney-runkle",
      "created_at": "2024-06-21T17:12:12Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649234769"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3017,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,31 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"A `FailFast` can be used to specify that validation should stop at the first error.\n+\n+    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.",
      "comment": "What exactly should I add about performance? Do you smth in mind?",
      "comment_id": 1649331098,
      "user": "uriyyo",
      "created_at": "2024-06-21T18:59:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649331098"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3028,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,31 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"A `FailFast` can be used to specify that validation should stop at the first error.\n+\n+    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.\n+\n+    ```py\n+    from typing import List\n+    from typing_extensions import Annotated\n+    from pydantic import BaseModel, FailFast\n+\n+    class Model(BaseModel):\n+        x: Annotated[List[int], FailFast()]\n+\n+    # This will raise a single error for the first invalid value and stop validation\n+    obj = Model(x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 'c'])",
      "comment": "I guess that's because this version of `pydantic-core` doesn't support `fail_fast` and raises `SchemaError`",
      "comment_id": 1649334709,
      "user": "uriyyo",
      "created_at": "2024-06-21T19:04:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649334709"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3017,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,31 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"A `FailFast` can be used to specify that validation should stop at the first error.\n+\n+    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.",
      "comment": "Just that you might want to enable this setting if you want to validate your data faster (basically, if you use this, validation will be more performant with the caveat that you get less information).\r\n\r\nIn a sense, I think we should use `performance` as a buzzword where applicable bc people generally really appreciate the callout.",
      "comment_id": 1649501948,
      "user": "sydney-runkle",
      "created_at": "2024-06-21T23:51:56Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649501948"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3028,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,31 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"A `FailFast` can be used to specify that validation should stop at the first error.\n+\n+    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.\n+\n+    ```py\n+    from typing import List\n+    from typing_extensions import Annotated\n+    from pydantic import BaseModel, FailFast\n+\n+    class Model(BaseModel):\n+        x: Annotated[List[int], FailFast()]\n+\n+    # This will raise a single error for the first invalid value and stop validation\n+    obj = Model(x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 'c'])",
      "comment": "Ah yes, you're right. Should be fixed once we bump `pydantic-core` with your new feature.",
      "comment_id": 1649502257,
      "user": "sydney-runkle",
      "created_at": "2024-06-21T23:53:16Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649502257"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,7 +15,7 @@\n \n \n STRICT = {'strict'}\n-SEQUENCE_CONSTRAINTS = {'min_length', 'max_length'}\n+SEQUENCE_CONSTRAINTS = {'min_length', 'max_length', 'fail_fast'}",
      "comment": "I don't think this applies to all of the cases where we use `*SEQUENCE_CONSTRAINTS.\r\n\r\nThis implies that the `fail-fast` constraint is valid for strings, bytes, lists, tuples, sets, dicts, and generators.\r\n\r\nDoes the `fail-fast` setting work for all of those? I'm guessing not `str` or `bytes`, and probably not `dict`.\r\n\r\nSo we should probably apply this individually to the sequences for which is currently works. If it does apply to `dict`, let's add a test for that as well.",
      "comment_id": 1649503753,
      "user": "sydney-runkle",
      "created_at": "2024-06-21T23:59:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649503753"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 310,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,6 +307,7 @@ class SequenceValidator:\n     min_length: int | None = None\n     max_length: int | None = None\n     strict: bool | None = None\n+    fail_fast: bool | None = None",
      "comment": "Same question - is `fail_fast` applicable to all sequence types? It probably should be for this case, but the case about where we reuse `SEQUENCE_CONSTRAINTS` is where more of my concern lies.",
      "comment_id": 1649504540,
      "user": "sydney-runkle",
      "created_at": "2024-06-22T00:02:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649504540"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 310,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,6 +307,7 @@ class SequenceValidator:\n     min_length: int | None = None\n     max_length: int | None = None\n     strict: bool | None = None\n+    fail_fast: bool | None = None",
      "comment": "Also, let's add some tests for `my_field: Sequence = Field(..., fail_fast=True)`, etc.",
      "comment_id": 1649504743,
      "user": "sydney-runkle",
      "created_at": "2024-06-22T00:03:05Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649504743"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 310,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,6 +307,7 @@ class SequenceValidator:\n     min_length: int | None = None\n     max_length: int | None = None\n     strict: bool | None = None\n+    fail_fast: bool | None = None",
      "comment": "Then see what happens with a `deque` or something like that",
      "comment_id": 1649504781,
      "user": "sydney-runkle",
      "created_at": "2024-06-22T00:03:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649504781"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/types.py",
      "line": 3017,
      "side": "RIGHT",
      "diff_hunk": "@@ -3007,3 +3008,31 @@ def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHa\n That is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\n any invalid items are discarded and the valid ones are returned.\n \"\"\"\n+\n+\n+@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\n+class FailFast:\n+    \"\"\"A `FailFast` can be used to specify that validation should stop at the first error.\n+\n+    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.",
      "comment": "I'm also happy to add these performance docs later if you'd prefer :).",
      "comment_id": 1649504929,
      "user": "sydney-runkle",
      "created_at": "2024-06-22T00:03:54Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649504929"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 310,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,6 +307,7 @@ class SequenceValidator:\n     min_length: int | None = None\n     max_length: int | None = None\n     strict: bool | None = None\n+    fail_fast: bool | None = None",
      "comment": "> Same question - is fail_fast applicable to all sequence types? \r\n\r\nYou are right, it's not applicable to all sequence types. But I don't know how to correctly pass fail_fast to schema. Before calling `apply_known_metadata` it' always calls `sequence_like_prepare_pydantic_annotations` that fails because `fail_fast` is not in a list of `SEQUENCE_CONSTRAINTS`.\r\n\r\nMaybe you have PR example how to correctly implement staff like this?",
      "comment_id": 1649686764,
      "user": "uriyyo",
      "created_at": "2024-06-22T12:02:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649686764"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9708,
      "file_path": "pydantic/_internal/_std_types_schema.py",
      "line": 310,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,6 +307,7 @@ class SequenceValidator:\n     min_length: int | None = None\n     max_length: int | None = None\n     strict: bool | None = None\n+    fail_fast: bool | None = None",
      "comment": "> Also, let's add some tests for my_field: Sequence = Field(..., fail_fast=True), etc.\r\n\r\nIt won't work for now. I guess first we need to implement a way how from python say rust to stop validation. \r\n\r\nMore context here - https://github.com/pydantic/pydantic-core/pull/1322#issuecomment-2166798608",
      "comment_id": 1649687531,
      "user": "uriyyo",
      "created_at": "2024-06-22T12:08:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/9708#discussion_r1649687531"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9747,
      "file_path": "pydantic/alias_generators.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,9 +49,10 @@ def to_snake(camel: str) -> str:\n     Returns:\n         The converted string in snake_case.\n     \"\"\"\n-    snake = re.sub(r'([a-zA-Z])([0-9])', lambda m: f'{m.group(1)}_{m.group(2)}', camel)\n-    snake = re.sub(r'([a-z0-9])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)\n-    snake = re.sub(r'([A-Z]+)([A-Z][a-z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)\n-    # Replace hyphens with underscores to handle kebab-case\n-    snake = snake.replace('-', '_')\n+    # Use the regex to split and join parts by underscore, then lower the case\n+    snake = re.sub(\n+        r'(?<=[a-zA-Z])(?=[0-9])|(?<=[a-z0-9])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|-',\n+        '_',\n+        camel,\n+    )",
      "comment": "```suggestion\r\n    # `(?<=[a-zA-Z])(?=[0-9])` matches the space between a letter and a digit\r\n    # `(?<=[a-z0-9])(?=[A-Z])` matches the space between a lowercase letter / digit and uppercase letter\r\n    # `(?<=[A-Z])(?=[A-Z][a-z])` matches the space between two uppercase letters when the latter is followed by a lowercase letter\r\n    # `-` matches a hyphen in order to convert kebab case strings \r\n    snake = re.sub(\r\n        r'(?<=[a-zA-Z])(?=[0-9])|(?<=[a-z0-9])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|-',\r\n        '_',\r\n        camel,\r\n    )\r\n```",
      "comment_id": 1652791009,
      "user": "sydney-runkle",
      "created_at": "2024-06-25T13:06:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/9747#discussion_r1652791009"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9747,
      "file_path": "pydantic/alias_generators.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,9 +49,13 @@ def to_snake(camel: str) -> str:\n     Returns:\n         The converted string in snake_case.\n     \"\"\"\n-    snake = re.sub(r'([a-zA-Z])([0-9])', lambda m: f'{m.group(1)}_{m.group(2)}', camel)\n-    snake = re.sub(r'([a-z0-9])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)\n-    snake = re.sub(r'([A-Z]+)([A-Z][a-z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)\n-    # Replace hyphens with underscores to handle kebab-case\n-    snake = snake.replace('-', '_')\n+    # `(?<=[a-zA-Z])(?=[0-9])` matches the space between a letter and a digit\n+    # `(?<=[a-z0-9])(?=[A-Z])` matches the space between a lowercase letter / digit and uppercase letter\n+    # `(?<=[A-Z])(?=[A-Z][a-z])` matches the space between two uppercase letters when the latter is followed by a lowercase letter\n+    # `-` matches a hyphen in order to convert kebab case strings ",
      "comment": "```suggestion\r\n    # `-` matches a hyphen in order to convert kebab case strings\r\n```",
      "comment_id": 1652794434,
      "user": "sydney-runkle",
      "created_at": "2024-06-25T13:08:49Z",
      "url": "https://github.com/pydantic/pydantic/pull/9747#discussion_r1652794434"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9183,
      "file_path": "pydantic/fields.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -213,6 +221,8 @@ def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:\n         self.serialization_alias = kwargs.pop('serialization_alias', None)\n         alias_is_set = any(alias is not None for alias in (self.alias, self.validation_alias, self.serialization_alias))\n         self.alias_priority = kwargs.pop('alias_priority', None) or 2 if alias_is_set else None\n+        self.field_title_generator = kwargs.pop('field_title_generator', None)\n+        self.title_priority = kwargs.pop('title_priority', None) or 2 if self.title is not None else None",
      "comment": "Very minor nit - can we order these in the same order as seen in the attribute docstring?",
      "comment_id": 1585551515,
      "user": "sydney-runkle",
      "created_at": "2024-04-30T21:38:06Z",
      "url": "https://github.com/pydantic/pydantic/pull/9183#discussion_r1585551515"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9183,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1157,
      "side": "RIGHT",
      "diff_hunk": "@@ -1105,6 +1151,10 @@ def set_discriminator(schema: CoreSchema) -> CoreSchema:\n         schema = self._apply_field_serializers(\n             schema, filter_field_decorator_info_by_field(decorators.field_serializers.values(), name)\n         )\n+        field_title_generator = field_info.field_title_generator or self._config_wrapper.field_title_generator\n+        if field_title_generator is not None:\n+            self._apply_field_title_generator_to_field_info(field_title_generator, field_info, name)\n+",
      "comment": "Looks like we repeat this exact same logic 3x at least, maybe use a function to abstract away some of this?",
      "comment_id": 1585553595,
      "user": "sydney-runkle",
      "created_at": "2024-04-30T21:40:20Z",
      "url": "https://github.com/pydantic/pydantic/pull/9183#discussion_r1585553595"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9183,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 216,
      "side": "RIGHT",
      "diff_hunk": "@@ -202,19 +201,26 @@ def apply_each_item_validators(\n \n \n def modify_model_json_schema(\n-    schema_or_field: CoreSchemaOrField, handler: GetJsonSchemaHandler, *, cls: Any\n+    schema_or_field: CoreSchemaOrField,\n+    handler: GetJsonSchemaHandler,\n+    *,\n+    cls: Any,\n+    title: str | None = None,\n ) -> JsonSchemaValue:\n     \"\"\"Add title and description for model-like classes' JSON schema.\n \n     Args:\n         schema_or_field: The schema data to generate a JSON schema from.\n         handler: The `GetCoreSchemaHandler` instance.\n         cls: The model-like class.\n+        title: The title to set for the model's schema, defaults to the models name",
      "comment": "```suggestion\r\n        title: The title to set for the model's schema, defaults to the model's name\r\n```",
      "comment_id": 1585554391,
      "user": "sydney-runkle",
      "created_at": "2024-04-30T21:41:01Z",
      "url": "https://github.com/pydantic/pydantic/pull/9183#discussion_r1585554391"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9183,
      "file_path": "pydantic/fields.py",
      "line": 997,
      "side": "RIGHT",
      "diff_hunk": "@@ -977,6 +994,7 @@ class ComputedFieldInfo:\n         alias: The alias of the property to be used during serialization.\n         alias_priority: The priority of the alias. This affects whether an alias generator is used.\n         title: Title of the computed field to include in the serialization JSON schema.\n+        title_priority: Priority of the title. This affects whether a title generator is used.",
      "comment": "```suggestion\r\n        title_priority: Priority of the title. This affects whether a title generator is used.\r\n        field_title_generator: A callable that takes a field name and returns title for it.\r\n```",
      "comment_id": 1601531777,
      "user": "sydney-runkle",
      "created_at": "2024-05-15T12:16:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/9183#discussion_r1601531777"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9183,
      "file_path": "pydantic/config.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,11 +33,18 @@ class ConfigDict(TypedDict, total=False):\n     title: str | None\n     \"\"\"The title for the generated JSON schema, defaults to the model's name\"\"\"\n \n+    class_title_generator: Callable[[str], str] | None\n+    \"\"\"A callable that takes a class name and returns the title for it. Defaults to `None`.\"\"\"",
      "comment": "we should be clear about whether this works for:\r\n* pydantic models?\r\n* dataclasses?\r\n* typeddicts?",
      "comment_id": 1619102667,
      "user": "samuelcolvin",
      "created_at": "2024-05-29T15:35:38Z",
      "url": "https://github.com/pydantic/pydantic/pull/9183#discussion_r1619102667"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9183,
      "file_path": "pydantic/fields.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,6 +108,8 @@ class FieldInfo(_repr.Representation):\n         validation_alias: The validation alias of the field.\n         serialization_alias: The serialization alias of the field.\n         title: The title of the field.\n+        title_priority: Priority of the field's title. This affects whether a title generator is used.",
      "comment": "Are you sure we need this? If so, I think it needs more documentation.",
      "comment_id": 1619103334,
      "user": "samuelcolvin",
      "created_at": "2024-05-29T15:36:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/9183#discussion_r1619103334"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9183,
      "file_path": "pydantic/fields.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,6 +108,8 @@ class FieldInfo(_repr.Representation):\n         validation_alias: The validation alias of the field.\n         serialization_alias: The serialization alias of the field.\n         title: The title of the field.\n+        title_priority: Priority of the field's title. This affects whether a title generator is used.",
      "comment": "I guess I wanted to have a similar API to `alias_generator` and `alias_priority`. Do you think it's worth keeping? If so I'll add more documentation.",
      "comment_id": 1622556374,
      "user": "NeevCohen",
      "created_at": "2024-05-31T14:58:53Z",
      "url": "https://github.com/pydantic/pydantic/pull/9183#discussion_r1622556374"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9183,
      "file_path": "pydantic/config.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,11 +33,18 @@ class ConfigDict(TypedDict, total=False):\n     title: str | None\n     \"\"\"The title for the generated JSON schema, defaults to the model's name\"\"\"\n \n+    class_title_generator: Callable[[str], str] | None\n+    \"\"\"A callable that takes a class name and returns the title for it. Defaults to `None`.\"\"\"",
      "comment": "It works for all model and model-like (pydantic dataclass, builtin dataclass, typeddict) types. `ConfigDict` can be applied to all of them so IMO it's a little redundant. Changing the name to `model_title_generator` makes this even more clear I feel.\r\n\r\n\r\nI will add more documentation if you feel it's necessary.",
      "comment_id": 1622564233,
      "user": "NeevCohen",
      "created_at": "2024-05-31T15:04:14Z",
      "url": "https://github.com/pydantic/pydantic/pull/9183#discussion_r1622564233"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9183,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1581,
      "side": "RIGHT",
      "diff_hunk": "@@ -1523,6 +1578,7 @@ def _dataclass_schema(\n                         dataclass_bases_stack.enter_context(self._types_namespace_stack.push(dataclass_base))\n \n                 # Pushing a config overwrites the previous config, so iterate though the MRO backwards\n+                config = None",
      "comment": "I have a suspicion that this isn't needed, but perhaps that's wrong",
      "comment_id": 1651790243,
      "user": "sydney-runkle",
      "created_at": "2024-06-25T00:12:07Z",
      "url": "https://github.com/pydantic/pydantic/pull/9183#discussion_r1651790243"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9740,
      "file_path": "tests/test_aliases.py",
      "line": 594,
      "side": "RIGHT",
      "diff_hunk": "@@ -585,6 +586,14 @@ class Model(BaseModel):\n     assert Model.model_fields['x'].validation_alias == value\n \n \n+def test_search_dict_for_alias_path():\n+    class Model(BaseModel):\n+        x: str = Field(validation_alias=AliasPath('a', 1))\n+\n+    assert Model.model_fields['x'].validation_alias.search_dict_for_path({'a': ['hello', 'world']}) == 'world'\n+    assert Model.model_fields['x'].validation_alias.search_dict_for_path({'a': 'hello'}) is PydanticUndefined",
      "comment": "```suggestion\r\n    class Model(BaseModel):\r\n        ap = AliasPath('a', 1)\r\n        assert ap.search_dict_for_path({'a': ['hello', 'world']}) == 'world'\r\n        assert ap.search_dict_for_path({'a': 'hello'}) is PydanticUndefined\r\n```\r\n\r\nLittle simplification, we don't need the model abstraction here :)",
      "comment_id": 1651318549,
      "user": "sydney-runkle",
      "created_at": "2024-06-24T16:30:37Z",
      "url": "https://github.com/pydantic/pydantic/pull/9740#discussion_r1651318549"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9740,
      "file_path": "tests/test_aliases.py",
      "line": 593,
      "side": "RIGHT",
      "diff_hunk": "@@ -585,6 +586,13 @@ class Model(BaseModel):\n     assert Model.model_fields['x'].validation_alias == value\n \n \n+def test_search_dict_for_alias_path():\n+    class Model(BaseModel):\n+        ap = AliasPath('a', 1)\n+        assert ap.search_dict_for_path({'a': ['hello', 'world']}) == 'world'\n+        assert ap.search_dict_for_path({'a': 'hello'}) is PydanticUndefined",
      "comment": "```suggestion\r\n    ap = AliasPath('a', 1)\r\n    assert ap.search_dict_for_path({'a': ['hello', 'world']}) == 'world'\r\n    assert ap.search_dict_for_path({'a': 'hello'}) is PydanticUndefined\r\n```",
      "comment_id": 1651319658,
      "user": "sydney-runkle",
      "created_at": "2024-06-24T16:31:36Z",
      "url": "https://github.com/pydantic/pydantic/pull/9740#discussion_r1651319658"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9702,
      "file_path": "tests/test_config.py",
      "line": 365,
      "side": "RIGHT",
      "diff_hunk": "@@ -348,54 +347,39 @@ class Model(BaseModel):\n         assert m == m.model_copy()\n \n     def test_config_class_is_deprecated(self):\n-        with warnings.catch_warnings():\n-            # we need to explicitly ignore the other warning in pytest-8\n-            # TODO: rewrite it to use two nested pytest.warns() when pytest-7 is no longer supported\n-            warnings.simplefilter('ignore')\n-            with pytest.warns(\n-                PydanticDeprecatedSince20,\n-                match='Support for class-based `config` is deprecated, use ConfigDict instead.',\n-            ):\n-\n-                class Config(BaseConfig):\n-                    pass\n+        with pytest.warns(PydanticDeprecatedSince20) as all_warnings:\n+\n+            class Config(BaseConfig):\n+                pass\n+\n+        assert len(all_warnings) == 2\n+        expected_warnings = [\n+            'BaseConfig is deprecated. Use the `pydantic.ConfigDict` instead',\n+            'Support for class-based `config` is deprecated, use ConfigDict instead',\n+        ]\n+        assert [w.message.message for w in all_warnings] == expected_warnings\n \n     def test_config_class_attributes_are_deprecated(self):",
      "comment": "Looks like we're getting some failures for these two:\r\n\r\nhttps://github.com/pydantic/pydantic/actions/runs/9590698692/job/26446460308?pr=9702\r\n\r\nThe changes look alright to me, though I haven't dug into the error cause.",
      "comment_id": 1647706499,
      "user": "sydney-runkle",
      "created_at": "2024-06-20T14:45:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/9702#discussion_r1647706499"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9702,
      "file_path": "tests/test_config.py",
      "line": 365,
      "side": "RIGHT",
      "diff_hunk": "@@ -348,54 +347,39 @@ class Model(BaseModel):\n         assert m == m.model_copy()\n \n     def test_config_class_is_deprecated(self):\n-        with warnings.catch_warnings():\n-            # we need to explicitly ignore the other warning in pytest-8\n-            # TODO: rewrite it to use two nested pytest.warns() when pytest-7 is no longer supported\n-            warnings.simplefilter('ignore')\n-            with pytest.warns(\n-                PydanticDeprecatedSince20,\n-                match='Support for class-based `config` is deprecated, use ConfigDict instead.',\n-            ):\n-\n-                class Config(BaseConfig):\n-                    pass\n+        with pytest.warns(PydanticDeprecatedSince20) as all_warnings:\n+\n+            class Config(BaseConfig):\n+                pass\n+\n+        assert len(all_warnings) == 2\n+        expected_warnings = [\n+            'BaseConfig is deprecated. Use the `pydantic.ConfigDict` instead',\n+            'Support for class-based `config` is deprecated, use ConfigDict instead',\n+        ]\n+        assert [w.message.message for w in all_warnings] == expected_warnings\n \n     def test_config_class_attributes_are_deprecated(self):",
      "comment": "Would this be a case where the nested context managers could help?",
      "comment_id": 1647707612,
      "user": "sydney-runkle",
      "created_at": "2024-06-20T14:45:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/9702#discussion_r1647707612"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9702,
      "file_path": "tests/test_config.py",
      "line": 365,
      "side": "RIGHT",
      "diff_hunk": "@@ -348,54 +347,39 @@ class Model(BaseModel):\n         assert m == m.model_copy()\n \n     def test_config_class_is_deprecated(self):\n-        with warnings.catch_warnings():\n-            # we need to explicitly ignore the other warning in pytest-8\n-            # TODO: rewrite it to use two nested pytest.warns() when pytest-7 is no longer supported\n-            warnings.simplefilter('ignore')\n-            with pytest.warns(\n-                PydanticDeprecatedSince20,\n-                match='Support for class-based `config` is deprecated, use ConfigDict instead.',\n-            ):\n-\n-                class Config(BaseConfig):\n-                    pass\n+        with pytest.warns(PydanticDeprecatedSince20) as all_warnings:\n+\n+            class Config(BaseConfig):\n+                pass\n+\n+        assert len(all_warnings) == 2\n+        expected_warnings = [\n+            'BaseConfig is deprecated. Use the `pydantic.ConfigDict` instead',\n+            'Support for class-based `config` is deprecated, use ConfigDict instead',\n+        ]\n+        assert [w.message.message for w in all_warnings] == expected_warnings\n \n     def test_config_class_attributes_are_deprecated(self):",
      "comment": "In some ways, I'd rather we go with that approach so that the error messages are localized and make more sense when contextualized directly above the error-throwing statement.",
      "comment_id": 1647709680,
      "user": "sydney-runkle",
      "created_at": "2024-06-20T14:47:04Z",
      "url": "https://github.com/pydantic/pydantic/pull/9702#discussion_r1647709680"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9702,
      "file_path": "tests/test_config.py",
      "line": 365,
      "side": "RIGHT",
      "diff_hunk": "@@ -348,54 +347,39 @@ class Model(BaseModel):\n         assert m == m.model_copy()\n \n     def test_config_class_is_deprecated(self):\n-        with warnings.catch_warnings():\n-            # we need to explicitly ignore the other warning in pytest-8\n-            # TODO: rewrite it to use two nested pytest.warns() when pytest-7 is no longer supported\n-            warnings.simplefilter('ignore')\n-            with pytest.warns(\n-                PydanticDeprecatedSince20,\n-                match='Support for class-based `config` is deprecated, use ConfigDict instead.',\n-            ):\n-\n-                class Config(BaseConfig):\n-                    pass\n+        with pytest.warns(PydanticDeprecatedSince20) as all_warnings:\n+\n+            class Config(BaseConfig):\n+                pass\n+\n+        assert len(all_warnings) == 2\n+        expected_warnings = [\n+            'BaseConfig is deprecated. Use the `pydantic.ConfigDict` instead',\n+            'Support for class-based `config` is deprecated, use ConfigDict instead',\n+        ]\n+        assert [w.message.message for w in all_warnings] == expected_warnings\n \n     def test_config_class_attributes_are_deprecated(self):",
      "comment": "I doubt this one can be nested -- since `typing-extensions=4.6.1` only emits one warning rather two, there'd still be a failure when the outer block doesn't throw a warning.",
      "comment_id": 1648360922,
      "user": "s-t-e-v-e-n-k",
      "created_at": "2024-06-21T03:10:32Z",
      "url": "https://github.com/pydantic/pydantic/pull/9702#discussion_r1648360922"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9162,
      "file_path": "tests/test_v1.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,2 +1,31 @@\n+import importlib\n+import os\n+\n+import pydantic\n+\n+\n def test_imports() -> None:\n     from pydantic.v1 import BaseModel, dataclasses  # noqa: F401\n+\n+\n+def test_imports_from_modules() -> None:\n+    \"\"\"That specific objects can be imported from modules directly through the\n+    ``v1`` namespace.\"\"\"\n+    from pydantic.v1.fields import ModelField  # noqa: F401\n+    from pydantic.v1.generics import GenericModel  # noqa: F401\n+    from pydantic.v1.validators import bool_validator  # noqa: F401\n+\n+\n+def test_can_import_modules_from_v1() -> None:\n+    \"\"\"That imports from any module in pydantic can be imported through\n+    ``pydantic.v1.<module>``\"\"\"\n+    for module_fname in os.listdir(pydantic.__path__[0]):\n+        if (\n+            module_fname.startswith(\"_\")\n+            or not module_fname.endswith(\".py\")\n+            or module_fname == \"v1.py\"\n+        ):\n+            continue\n+        module_name = module_fname[:-3]\n+\n+        _ = importlib.import_module(f\"pydantic.v1.{module_name}\")",
      "comment": "```suggestion\r\n        if (\r\n            module_fname.startswith('_')\r\n            or not module_fname.endswith('.py')\r\n            or module_fname == 'v1.py'\r\n        ):\r\n            continue\r\n        module_name = module_fname[:-3]\r\n\r\n        _ = importlib.import_module(f'pydantic.v1.{module_name}')\r\n```",
      "comment_id": 1585433910,
      "user": "sydney-runkle",
      "created_at": "2024-04-30T19:31:51Z",
      "url": "https://github.com/pydantic/pydantic/pull/9162#discussion_r1585433910"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9162,
      "file_path": "pydantic/v1.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,6 +2,13 @@\n # flake8: noqa\n from pydantic import *\n \n+\n+import os",
      "comment": "```suggestion\r\nimport os\r\n\r\nfrom pydantic import *\r\n```",
      "comment_id": 1585436354,
      "user": "sydney-runkle",
      "created_at": "2024-04-30T19:34:28Z",
      "url": "https://github.com/pydantic/pydantic/pull/9162#discussion_r1585436354"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9162,
      "file_path": "tests/test_v1.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,2 +1,31 @@\n+import importlib\n+import os\n+\n+import pydantic\n+\n+\n def test_imports() -> None:\n     from pydantic.v1 import BaseModel, dataclasses  # noqa: F401\n+\n+\n+def test_imports_from_modules() -> None:\n+    \"\"\"That specific objects can be imported from modules directly through the\n+    ``v1`` namespace.\"\"\"\n+    from pydantic.v1.fields import ModelField  # noqa: F401\n+    from pydantic.v1.generics import GenericModel  # noqa: F401\n+    from pydantic.v1.validators import bool_validator  # noqa: F401\n+\n+\n+def test_can_import_modules_from_v1() -> None:\n+    \"\"\"That imports from any module in pydantic can be imported through\n+    ``pydantic.v1.<module>``\"\"\"\n+    for module_fname in os.listdir(pydantic.__path__[0]):\n+        if (\n+            module_fname.startswith('_')\n+            or not module_fname.endswith('.py')\n+            or module_fname == 'v1.py'\n+        ):",
      "comment": "```suggestion\r\n        if module_fname.startswith('_') or not module_fname.endswith('.py') or module_fname == 'v1.py':\r\n```",
      "comment_id": 1585447977,
      "user": "sydney-runkle",
      "created_at": "2024-04-30T19:46:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/9162#discussion_r1585447977"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9660,
      "file_path": "pydantic/v1/typing.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,83 @@\n+# ruff: noqa: F403,F401,F405\n+# flake8: noqa: F401,F405\n+from typing import TYPE_CHECKING\n+\n+if TYPE_CHECKING:\n+    from pydantic.typing import *\n+else:\n+    # explicit importing\n+    from pydantic.typing import (",
      "comment": "Note I'm *a bit* worried about these, for example if a module uses a `__all__` it does not stop someone using `from pydantic.<module> import <SymbolNotProvidedInAllButPresent>` whereas with these imports `from pydantic.v1.<module> import <SymbolNotProvidedInAllButPresent>` will *not* be found. \r\n\r\nI'm not sure _how common_ this will actually be (I'm sure _some people_ will definitely import objects from a module that does not have them defined in `__all__` \ud83d\ude43) but I'm also not too sure whether we _want_ to support that in this either. \r\n\r\nPersonally I'm _kinda_ fine with this, but happy to take opinions. Also, this will likely need a migration guide update too right?",
      "comment_id": 1642483199,
      "user": "rx-dwoodward",
      "created_at": "2024-06-17T09:16:47Z",
      "url": "https://github.com/pydantic/pydantic/pull/9660#discussion_r1642483199"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9660,
      "file_path": "pydantic/v1/typing.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,83 @@\n+# ruff: noqa: F403,F401,F405\n+# flake8: noqa: F401,F405\n+from typing import TYPE_CHECKING\n+\n+if TYPE_CHECKING:\n+    from pydantic.typing import *\n+else:\n+    # explicit importing\n+    from pydantic.typing import (",
      "comment": "I'd argue that `from pydantic.<module> import <SymbolNotProvidedInAllButPresent>` amounts to depending on an undocumented implementation detail in the old API, and that you should be free to avoid replicating that in the \"new\" `pydantic.v1.*` API.",
      "comment_id": 1642533562,
      "user": "jherland",
      "created_at": "2024-06-17T09:49:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/9660#discussion_r1642533562"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9674,
      "file_path": "tests/test_pipeline.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,12 +25,12 @@\n \n @pytest.mark.parametrize('potato_variation', ['potato', ' potato ', ' potato', 'potato ', ' POTATO ', ' PoTatO '])\n def test_parse_str(potato_variation: str) -> None:\n-    ta_lower = TypeAdapter(Annotated[str, validate_as(...).str_strip().str_lower()])\n+    ta_lower = TypeAdapter[str](Annotated[str, validate_as(...).str_strip().str_lower()])",
      "comment": "What error do we get if we don't explicitly parametrize the `TypeAdapter`? Is there any way for said type to be inferred from the annotation?",
      "comment_id": 1643500107,
      "user": "sydney-runkle",
      "created_at": "2024-06-17T22:38:08Z",
      "url": "https://github.com/pydantic/pydantic/pull/9674#discussion_r1643500107"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9674,
      "file_path": "tests/test_pipeline.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,12 +25,12 @@\n \n @pytest.mark.parametrize('potato_variation', ['potato', ' potato ', ' potato', 'potato ', ' POTATO ', ' PoTatO '])\n def test_parse_str(potato_variation: str) -> None:\n-    ta_lower = TypeAdapter(Annotated[str, validate_as(...).str_strip().str_lower()])\n+    ta_lower = TypeAdapter[str](Annotated[str, validate_as(...).str_strip().str_lower()])",
      "comment": "Probably not haha I'm guessing you would have already handled that, but just wanted to check. Guessing it's the whole generic can of worms.",
      "comment_id": 1643505207,
      "user": "sydney-runkle",
      "created_at": "2024-06-17T22:46:43Z",
      "url": "https://github.com/pydantic/pydantic/pull/9674#discussion_r1643505207"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9674,
      "file_path": "tests/test_pipeline.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,12 +25,12 @@\n \n @pytest.mark.parametrize('potato_variation', ['potato', ' potato ', ' potato', 'potato ', ' POTATO ', ' PoTatO '])\n def test_parse_str(potato_variation: str) -> None:\n-    ta_lower = TypeAdapter(Annotated[str, validate_as(...).str_strip().str_lower()])\n+    ta_lower = TypeAdapter[str](Annotated[str, validate_as(...).str_strip().str_lower()])",
      "comment": "Not until the TypeForm PEP gets merged...\r\n\r\nI thought it used to end up as `TypeAdapter[Any]` but it seems like it doesn't now. Maybe because of https://github.com/pydantic/pydantic/commit/8a896c51561fe9aa51cd7a8adabdb79b70bd5bce?",
      "comment_id": 1643515402,
      "user": "adriangb",
      "created_at": "2024-06-17T23:03:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/9674#discussion_r1643515402"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9674,
      "file_path": "tests/test_pipeline.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,18 +67,18 @@ def test_ge_le_gt_lt(\n @pytest.mark.parametrize(\n     'type_, pipeline, valid_cases, invalid_cases',\n     [\n-        (int, validate_as(int).multiple_of(5), [5, 20, 0], [18, 7]),\n-        (float, validate_as(float).multiple_of(2.5), [2.5, 5.0, 7.5], [3.0, 1.1]),\n+        (int, validate_as(int).multiple_of(5), [5, 20, 0], [18, 7]),  # type: ignore",
      "comment": "It had to do with the typing of `multiple_of`. I'm still not 100% certain it's correct but since it's just typing good enough.",
      "comment_id": 1643516633,
      "user": "adriangb",
      "created_at": "2024-06-17T23:05:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/9674#discussion_r1643516633"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9674,
      "file_path": "tests/test_pipeline.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,13 +115,13 @@ def test_interval_constraints(type_: Any, pipeline: Any, valid_cases: list[Any],\n     [\n         (\n             str,\n-            validate_as(str).len(min_len=2, max_len=5),\n+            validate_as(str).len(min_len=2, max_len=5),  # type: ignore",
      "comment": "This one was because some of the types like `list` where missing parametrization below (needs to be `list[int]`)",
      "comment_id": 1643525075,
      "user": "adriangb",
      "created_at": "2024-06-17T23:12:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/9674#discussion_r1643525075"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9674,
      "file_path": "tests/test_pipeline.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,12 +25,12 @@\n \n @pytest.mark.parametrize('potato_variation', ['potato', ' potato ', ' potato', 'potato ', ' POTATO ', ' PoTatO '])\n def test_parse_str(potato_variation: str) -> None:\n-    ta_lower = TypeAdapter(Annotated[str, validate_as(...).str_strip().str_lower()])\n+    ta_lower = TypeAdapter[str](Annotated[str, validate_as(...).str_strip().str_lower()])",
      "comment": "Looks like https://github.com/pydantic/pydantic/commit/953bbea8636742232dc659f8d92936c4b1ea94c1#diff-2695629fb80cb6eb6be5260a4611b3b831a7ebd53041d01f37c0d67dd55928fa is the one that broke it",
      "comment_id": 1643534088,
      "user": "adriangb",
      "created_at": "2024-06-17T23:18:50Z",
      "url": "https://github.com/pydantic/pydantic/pull/9674#discussion_r1643534088"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9674,
      "file_path": "tests/test_pipeline.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,12 +25,12 @@\n \n @pytest.mark.parametrize('potato_variation', ['potato', ' potato ', ' potato', 'potato ', ' POTATO ', ' PoTatO '])\n def test_parse_str(potato_variation: str) -> None:\n-    ta_lower = TypeAdapter(Annotated[str, validate_as(...).str_strip().str_lower()])\n+    ta_lower = TypeAdapter[str](Annotated[str, validate_as(...).str_strip().str_lower()])",
      "comment": "Hum, in my https://github.com/pydantic/pydantic/pull/9570 fix I kept the `__init__` so that users would be forced to parametrize the `TypeAdapter` if the type checker can't use the first overload. But having an implicit fallback to `TypeAdapter[Any]` seems good as well",
      "comment_id": 1643860706,
      "user": "Viicos",
      "created_at": "2024-06-18T06:02:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/9674#discussion_r1643860706"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9604,
      "file_path": "pydantic/fields.py",
      "line": 376,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,12 +373,12 @@ class MyModel(pydantic.BaseModel):\n             init_var = False\n             if annotation is dataclasses.InitVar:\n                 init_var = True\n-                annotation = Any\n+                annotation = typing.cast(Any, Any)",
      "comment": "This is a really weird behavior from pyright, where the following would happen:\r\n\r\n```python\r\nfrom typing import Any\r\n\r\nvar = Any\r\n\r\nreveal_type(var)  # Revealed type is \"Any\"\r\n\r\ndef func(arg: type): pass\r\n\r\nfunc(var)  # Type error\r\n```\r\n\r\nThe reason is that `var` is inferred as being the actual `typing.Any` object, and not the `Any` \"typing concept\" (but pyright displays it the same way).\r\n\r\nThis also relates to the Typing form PEP, that would be of great help here.",
      "comment_id": 1631290993,
      "user": "Viicos",
      "created_at": "2024-06-07T14:16:34Z",
      "url": "https://github.com/pydantic/pydantic/pull/9604#discussion_r1631290993"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9604,
      "file_path": "pydantic/types.py",
      "line": 477,
      "side": "RIGHT",
      "diff_hunk": "@@ -474,7 +474,7 @@ class ConstrainedExample(BaseModel):\n         '''\n     ```\n     \"\"\"  # noqa: D212\n-    return Annotated[\n+    return Annotated[  # pyright: ignore[reportReturnType]",
      "comment": "Maybe @adriangb would know - you're up to date on typing with `Annotated` \ud83c\udf1f ",
      "comment_id": 1631386832,
      "user": "sydney-runkle",
      "created_at": "2024-06-07T15:31:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/9604#discussion_r1631386832"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9604,
      "file_path": "pydantic/fields.py",
      "line": 376,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,12 +373,12 @@ class MyModel(pydantic.BaseModel):\n             init_var = False\n             if annotation is dataclasses.InitVar:\n                 init_var = True\n-                annotation = Any\n+                annotation = typing.cast(Any, Any)",
      "comment": "Hmph, I was definitely confused by this before reading the explanation. Do you think this is something that might change on the pyright end of things any time soon?",
      "comment_id": 1631388063,
      "user": "sydney-runkle",
      "created_at": "2024-06-07T15:32:52Z",
      "url": "https://github.com/pydantic/pydantic/pull/9604#discussion_r1631388063"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9604,
      "file_path": "pydantic/types.py",
      "line": 477,
      "side": "RIGHT",
      "diff_hunk": "@@ -474,7 +474,7 @@ class ConstrainedExample(BaseModel):\n         '''\n     ```\n     \"\"\"  # noqa: D212\n-    return Annotated[\n+    return Annotated[  # pyright: ignore[reportReturnType]",
      "comment": "This seems fine actually, these functions are already so hacky anyways, I'm not surprised this is a problem.",
      "comment_id": 1631564353,
      "user": "sydney-runkle",
      "created_at": "2024-06-07T18:30:58Z",
      "url": "https://github.com/pydantic/pydantic/pull/9604#discussion_r1631564353"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9604,
      "file_path": "pydantic/fields.py",
      "line": 324,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,7 +321,7 @@ class MyModel(pydantic.BaseModel):\n                 new_field_info.metadata = metadata\n                 return new_field_info\n \n-        return FieldInfo(annotation=annotation, frozen=final or None)\n+        return FieldInfo(annotation=annotation, frozen=final or None)  # pyright: ignore[reportArgumentType]",
      "comment": "`annotation` is inferred as `type[Any] | type[Final]` because of the `if annotation is not typing_extensions.Final:` check on line 300. And with the recent changes in pyright regarding special forms (such as `Final`), `type[Final]` is not compatible with `type[Any]`. Hopefully this will also be resolved with the TypeForm PEP.",
      "comment_id": 1631976491,
      "user": "Viicos",
      "created_at": "2024-06-08T08:51:27Z",
      "url": "https://github.com/pydantic/pydantic/pull/9604#discussion_r1631976491"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9604,
      "file_path": "pydantic/fields.py",
      "line": 376,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,12 +373,12 @@ class MyModel(pydantic.BaseModel):\n             init_var = False\n             if annotation is dataclasses.InitVar:\n                 init_var = True\n-                annotation = Any\n+                annotation = typing.cast(Any, Any)",
      "comment": "Unfortunately we are using some undefined behavior here (`Any` is meant to be used as an annotation, not as a value), so I don't expect pyright to special case things here :/ But this clearly shows the need for a TypeForm feature in the typing system!",
      "comment_id": 1631982074,
      "user": "Viicos",
      "created_at": "2024-06-08T09:03:23Z",
      "url": "https://github.com/pydantic/pydantic/pull/9604#discussion_r1631982074"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9604,
      "file_path": "pydantic/fields.py",
      "line": 376,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,12 +373,12 @@ class MyModel(pydantic.BaseModel):\n             init_var = False\n             if annotation is dataclasses.InitVar:\n                 init_var = True\n-                annotation = Any\n+                annotation = typing.cast(Any, Any)",
      "comment": "I can probably add a comment in the code in the meanwhile",
      "comment_id": 1631982202,
      "user": "Viicos",
      "created_at": "2024-06-08T09:03:48Z",
      "url": "https://github.com/pydantic/pydantic/pull/9604#discussion_r1631982202"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9604,
      "file_path": "pydantic/fields.py",
      "line": 376,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,12 +373,12 @@ class MyModel(pydantic.BaseModel):\n             init_var = False\n             if annotation is dataclasses.InitVar:\n                 init_var = True\n-                annotation = Any\n+                annotation = typing.cast(Any, Any)",
      "comment": "@Viicos,\r\n\r\nThat'd be great. Yeah, I realize now that a lot of the changes here just showcase the utility of a `TypeForm` feature :).",
      "comment_id": 1632384468,
      "user": "sydney-runkle",
      "created_at": "2024-06-09T20:17:35Z",
      "url": "https://github.com/pydantic/pydantic/pull/9604#discussion_r1632384468"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9639,
      "file_path": "pydantic/v1/_hypothesis_plugin.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,7 +35,7 @@\n import pydantic\n import pydantic.color\n import pydantic.types\n-from pydantic.utils import lenient_issubclass\n+from pydantic.v1.utils import lenient_issubclass",
      "comment": "This looks odd, but is actually fine, bc `pydantic` just uses a backport here from V1 anyways.",
      "comment_id": 1636427514,
      "user": "sydney-runkle",
      "created_at": "2024-06-12T13:03:18Z",
      "url": "https://github.com/pydantic/pydantic/pull/9639#discussion_r1636427514"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9623,
      "file_path": "pydantic/_internal/_generate_schema.py",
      "line": 1447,
      "side": "LEFT",
      "diff_hunk": "@@ -1444,7 +1444,6 @@ def _sequence_schema(self, sequence_type: Any) -> core_schema.CoreSchema:\n         item_type = self._get_first_arg_or_any(sequence_type)\n         item_type_schema = self.generate_schema(item_type)\n         list_schema = core_schema.list_schema(item_type_schema)\n-        metadata = build_metadata_dict(initial_metadata={'known_metadata_as': typing.Sequence})",
      "comment": "This was driving me nuts - I think we're trying to stray away from excessive use of metadata flags, so I've removed this logic.",
      "comment_id": 1633711399,
      "user": "sydney-runkle",
      "created_at": "2024-06-10T19:05:45Z",
      "url": "https://github.com/pydantic/pydantic/pull/9623#discussion_r1633711399"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9623,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -222,142 +231,39 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -> CoreSchema | No\n                 schema[constraint] = value\n             continue\n \n-        if constraint == 'allow_inf_nan' and value is False:\n-            return cs.no_info_after_validator_function(\n-                _validators.forbid_inf_nan_check,\n-                schema,\n-            )\n-        elif constraint == 'pattern':\n-            # insert a str schema to make sure the regex engine matches\n-            return cs.chain_schema(\n-                [\n-                    schema,\n-                    cs.str_schema(pattern=value),\n-                ]\n-            )\n-        elif constraint == 'gt':\n-            s = cs.no_info_after_validator_function(\n-                partial(_validators.greater_than_validator, gt=value),\n-                schema,\n-            )\n-            add_js_update_schema(s, lambda: {'gt': as_jsonable_value(value)})\n-            return s\n-        elif constraint == 'ge':\n-            return cs.no_info_after_validator_function(\n-                partial(_validators.greater_than_or_equal_validator, ge=value),\n-                schema,\n-            )\n-        elif constraint == 'lt':\n-            return cs.no_info_after_validator_function(\n-                partial(_validators.less_than_validator, lt=value),\n-                schema,\n-            )\n-        elif constraint == 'le':\n-            return cs.no_info_after_validator_function(\n-                partial(_validators.less_than_or_equal_validator, le=value),\n-                schema,\n-            )\n-        elif constraint == 'multiple_of':\n-            return cs.no_info_after_validator_function(\n-                partial(_validators.multiple_of_validator, multiple_of=value),\n-                schema,\n-            )\n-        elif constraint == 'min_length':\n-            s = cs.no_info_after_validator_function(\n-                partial(_validators.min_length_validator, min_length=value),\n-                schema,\n-            )\n-            if _is_sequence_metadata(schema):\n-                add_js_update_schema(s, lambda: {'minItems': (as_jsonable_value(value))})\n-                return s\n-            add_js_update_schema(s, lambda: {'minLength': (as_jsonable_value(value))})\n-            return s\n-        elif constraint == 'max_length':\n-            s = cs.no_info_after_validator_function(\n-                partial(_validators.max_length_validator, max_length=value),\n-                schema,\n-            )\n-            if _is_sequence_metadata(schema):\n-                add_js_update_schema(s, lambda: {'maxItems': (as_jsonable_value(value))})\n-                return s\n-            add_js_update_schema(s, lambda: {'maxLength': (as_jsonable_value(value))})\n-            return s\n-        elif constraint == 'strip_whitespace':\n-            return cs.chain_schema(\n-                [\n-                    schema,\n-                    cs.str_schema(strip_whitespace=True),\n-                ]\n-            )\n-        elif constraint == 'to_lower':\n-            return cs.chain_schema(\n-                [\n-                    schema,\n-                    cs.str_schema(to_lower=True),\n-                ]\n-            )\n-        elif constraint == 'to_upper':\n-            return cs.chain_schema(\n-                [\n-                    schema,\n-                    cs.str_schema(to_upper=True),\n-                ]\n-            )\n-        elif constraint == 'min_length':\n-            return cs.no_info_after_validator_function(\n-                partial(_validators.min_length_validator, min_length=annotation.min_length),\n-                schema,\n+        if constraint in {'pattern', 'strip_whitespace', 'to_lower', 'to_upper', 'coerce_numbers_to_str'}:\n+            chain_schema_steps.append(cs.str_schema(**{constraint: value}))\n+        elif constraint in {'gt', 'ge', 'lt', 'le', 'multiple_of', 'min_length', 'max_length'}:\n+            if constraint == 'multiple_of':\n+                json_schema_constraint = 'multiple_of'\n+            elif constraint in {'min_length', 'max_length'}:\n+                if schema['type'] == 'list' or (\n+                    schema['type'] == 'json-or-python' and schema['json_schema']['type'] == 'list'\n+                ):\n+                    json_schema_constraint = 'minItems' if constraint == 'min_length' else 'maxItems'\n+                else:\n+                    json_schema_constraint = 'minLength' if constraint == 'min_length' else 'maxLength'\n+            else:\n+                json_schema_constraint = constraint\n+\n+            schema = cs.no_info_after_validator_function(\n+                partial(COMPARISON_VALIDATORS[constraint], **{constraint: value}), schema\n             )",
      "comment": "This might be slightly less readable, but I'd argue the redundancy before was worse...",
      "comment_id": 1633712809,
      "user": "sydney-runkle",
      "created_at": "2024-06-10T19:07:22Z",
      "url": "https://github.com/pydantic/pydantic/pull/9623#discussion_r1633712809"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9623,
      "file_path": "pydantic/_internal/_known_annotated_metadata.py",
      "line": 287,
      "side": "RIGHT",
      "diff_hunk": "@@ -375,6 +281,10 @@ def val_func(v: Any) -> Any:\n         # ignore any other unknown metadata\n         return None\n \n+    if chain_schema_steps:\n+        chain_schema_steps = [schema] + chain_schema_steps\n+        return cs.chain_schema(chain_schema_steps)\n+",
      "comment": "One interesting question here is what happens when you have mixes of constraints that are applied as validator functions vs chain schema additions. This implementation isn't breaking any tests (in fact, fixing bugs), but I could see an argument for considering a pattern for this more carefully.",
      "comment_id": 1633713720,
      "user": "sydney-runkle",
      "created_at": "2024-06-10T19:08:17Z",
      "url": "https://github.com/pydantic/pydantic/pull/9623#discussion_r1633713720"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9527,
      "file_path": "tests/conftest.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,7 +49,7 @@ def _create_module_file(code, tmp_path, name):\n def disable_error_urls():\n     # Don't add URLs during docs tests when printing\n     # Otherwise we'll get version numbers in the URLs that will update frequently\n-    os.environ['PYDANTIC_ERRORS_OMIT_URL'] = 'true'\n+    os.environ['PYDANTIC_ERRORS_INCLUDE_URL'] = 'false'",
      "comment": "This could potentially be a breaking change (though I'm not sure who might have this enabled?)",
      "comment_id": 1624634154,
      "user": "sydney-runkle",
      "created_at": "2024-06-03T15:14:39Z",
      "url": "https://github.com/pydantic/pydantic/pull/9527#discussion_r1624634154"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9527,
      "file_path": "tests/conftest.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,7 +49,7 @@ def _create_module_file(code, tmp_path, name):\n def disable_error_urls():\n     # Don't add URLs during docs tests when printing\n     # Otherwise we'll get version numbers in the URLs that will update frequently\n-    os.environ['PYDANTIC_ERRORS_OMIT_URL'] = 'true'\n+    os.environ['PYDANTIC_ERRORS_INCLUDE_URL'] = 'false'",
      "comment": "Could it, in a conftest? Based on the commit message for that bit in #9040 this also to silence a warning.",
      "comment_id": 1625253734,
      "user": "s-t-e-v-e-n-k",
      "created_at": "2024-06-04T02:30:41Z",
      "url": "https://github.com/pydantic/pydantic/pull/9527#discussion_r1625253734"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9478,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 783,
      "side": "RIGHT",
      "diff_hunk": "@@ -774,7 +778,25 @@ def get_function_return_type(\n \n \n def count_positional_params(sig: Signature) -> int:\n-    return sum(1 for param in sig.parameters.values() if can_be_positional(param))\n+    \"\"\"Get the number of positional (required) arguments of a signature.\n+\n+    This function should only be used to inspect signatures of validation and serialization functions.",
      "comment": "I'm not too happy with how this function grew, hence this \"warning\" in the docstring. At some point, maybe this inspection of validators/serializers signature could be refactored, e.g.:\r\n\r\n```python\r\n@dataclass\r\nclass FunctionInfo:\r\n    func: Callable[..., Any]\r\n\r\n    @property\r\n    def requires_info_arg(self) -> bool: ...\r\n\r\n    ...\r\n```",
      "comment_id": 1608916010,
      "user": "Viicos",
      "created_at": "2024-05-21T20:29:15Z",
      "url": "https://github.com/pydantic/pydantic/pull/9478#discussion_r1608916010"
    },
    {
      "repo": "pydantic/pydantic",
      "pr_number": 9478,
      "file_path": "pydantic/_internal/_decorators.py",
      "line": 780,
      "side": "RIGHT",
      "diff_hunk": "@@ -774,7 +778,25 @@ def get_function_return_type(\n \n \n def count_positional_params(sig: Signature) -> int:",
      "comment": "It seems like the behaviour of this function changed to have the required arguments property, should we rename it to avoid accidents in case anyone is trying to borrow our internals?",
      "comment_id": 1617743364,
      "user": "davidhewitt",
      "created_at": "2024-05-28T18:39:10Z",
      "url": "https://github.com/pydantic/pydantic/pull/9478#discussion_r1617743364"
    }
  ]
}