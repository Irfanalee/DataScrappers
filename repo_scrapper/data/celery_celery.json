{
  "repo": "celery/celery",
  "scraped_at": "2026-02-03T13:50:11.745402",
  "stats": {
    "total_comments": 948,
    "filtered": {
      "too_short": 286,
      "not_python": 169,
      "too_long": 5,
      "no_diff_hunk": 2,
      "skip_pattern:thanks!": 1
    },
    "kept": 485
  },
  "examples": [
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,22 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    \n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60},  # retry 2 times in 10 minutes\n+)\n+def error_task():",
      "comment": "`bind=True` means Celery will pass the task instance as the first arg, but `error_task` doesn\u2019t accept `self`. This will raise a `TypeError` before the body runs (and may prevent `autoretry_for` from behaving as intended). Consider adding a `self` parameter or dropping `bind=True` if binding isn\u2019t needed.\n```suggestion\ndef error_task(self):\n```",
      "comment_id": 2753793103,
      "user": "Copilot",
      "created_at": "2026-02-02T11:06:04Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2753793103"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,22 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    \n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60},  # retry 2 times in 10 minutes",
      "comment": "The comment says \u201cretry 2 times in 10 minutes\u201d, but `retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60}` will wait 10 minutes before *each* retry. That\u2019s typically ~20 minutes total delay across two retries (plus execution time). Consider rewording the comment to match Celery\u2019s `countdown` semantics.\n```suggestion\n    retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60},  # retry up to 2 times with 10 minutes between retries\n```",
      "comment_id": 2753793129,
      "user": "Copilot",
      "created_at": "2026-02-02T11:06:05Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2753793129"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,22 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    ",
      "comment": "There\u2019s trailing whitespace on this blank line. This can cause `flake8` to fail (W293) in CI/pre-commit. Consider removing the extra spaces.\n```suggestion\n\n```",
      "comment_id": 2753793150,
      "user": "Copilot",
      "created_at": "2026-02-02T11:06:05Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2753793150"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,22 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    \n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60},  # retry 2 times in 10 minutes\n+)\n+def error_task():\n+    raise Exception(\"Test error\")\n+\n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_backoff=5,  # Factor in seconds (first retry: 5s, second: 10s, third: 20s, etc.)\n+    retry_jitter=False,  # Set False to disable randomization (use exact values: 5s, 10s, 20s)\n+    retry_kwargs={\"max_retries\": 3},\n+)\n+def error_backoff_test(self):\n+    raise Exception(\"Test error\")\n+    return \"Success\"",
      "comment": "`return \"Success\"` is unreachable because it follows an unconditional `raise`. If the goal is to demonstrate backoff retries and eventual success, consider raising only while `self.request.retries` is below a threshold and returning success afterward; otherwise, remove the dead `return` line.\n```suggestion\n\n```",
      "comment_id": 2753793175,
      "user": "Copilot",
      "created_at": "2026-02-02T11:06:05Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2753793175"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,22 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    \n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60},  # retry 2 times in 10 minutes\n+)\n+def error_task():",
      "comment": "yes, it's correct, need \"self\" for it. I forgot when I typed it again.",
      "comment_id": 2754012301,
      "user": "sbc-khacnha",
      "created_at": "2026-02-02T12:05:15Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2754012301"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,23 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    \n+\n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60},  # retry up to 2 times with 10 minutes between retries\n+)\n+def error_task(self):\n+    raise Exception(\"Test error\")\n+\n+\n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_backoff=5,  # Factor in seconds (first retry: 5s, second: 10s, third: 20s, etc.)\n+    retry_jitter=False,  # Set False to disable randomization (use exact values: 5s, 10s, 20s)\n+    retry_kwargs={\"max_retries\": 3},\n+)\n+def error_backoff_test(self):\n+    raise Exception(\"Test error\")",
      "comment": "This task always raises an exception, so calling it will never succeed (even after retries). For a clearer example, consider failing only for the first N retries (using `self.request.retries`) or gating failure behind a parameter so users can see a successful run.",
      "comment_id": 2754152220,
      "user": "Copilot",
      "created_at": "2026-02-02T12:42:37Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2754152220"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,23 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    \n+",
      "comment": "Line contains trailing whitespace on an otherwise blank line. Please remove the extra spaces to avoid noisy diffs and keep the example clean.\n```suggestion\n\n```",
      "comment_id": 2754152233,
      "user": "Copilot",
      "created_at": "2026-02-02T12:42:38Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2754152233"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,23 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    \n+\n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60},  # retry up to 2 times with 10 minutes between retries\n+)\n+def error_task(self):\n+    raise Exception(\"Test error\")\n+\n+\n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_backoff=5,  # Factor in seconds (first retry: 5s, second: 10s, third: 20s, etc.)\n+    retry_jitter=False,  # Set False to disable randomization (use exact values: 5s, 10s, 20s)\n+    retry_kwargs={\"max_retries\": 3},\n+)\n+def error_backoff_test(self):\n+    raise Exception(\"Test error\")",
      "comment": "`error_backoff_test` reads like a test helper and may be confusing in an example app. Consider renaming to describe the behavior being demonstrated (e.g., \u201cretry_with_backoff\u201d) so users know it\u2019s a task example rather than a test.",
      "comment_id": 2754152242,
      "user": "Copilot",
      "created_at": "2026-02-02T12:42:38Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2754152242"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,23 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    \n+\n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60},  # retry up to 2 times with 10 minutes between retries\n+)\n+def error_task(self):\n+    raise Exception(\"Test error\")",
      "comment": "This task always raises an exception, so calling it will never succeed (even after retries). If the goal is to demonstrate retries, consider making the failure conditional (e.g., based on an argument or `self.request.retries`) or adding a short comment warning that this task is intentionally failing for demonstration.",
      "comment_id": 2754152248,
      "user": "Copilot",
      "created_at": "2026-02-02T12:42:38Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2754152248"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10081,
      "file_path": "examples/django/demoapp/tasks.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,3 +30,23 @@ def rename_widget(widget_id, name):\n     w = Widget.objects.get(id=widget_id)\n     w.name = name\n     w.save()\n+    \n+\n+@shared_task(\n+    bind=True,\n+    autoretry_for=(Exception,),\n+    retry_kwargs={\"max_retries\": 2, \"countdown\": 10 * 60},  # retry up to 2 times with 10 minutes between retries\n+)\n+def error_task(self):\n+    raise Exception(\"Test error\")",
      "comment": "Yes, I deliberately added `raise Exception(\"Test error\")` that to illustrate the example. I think it's fine to leave it like that.",
      "comment_id": 2756717848,
      "user": "sbc-khacnha",
      "created_at": "2026-02-03T01:24:50Z",
      "url": "https://github.com/celery/celery/pull/10081#discussion_r2756717848"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9665,
      "file_path": "celery/backends/mongodb.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,7 @@\n         from bson.binary import Binary\n     except ImportError:\n         from pymongo.binary import Binary\n+    from pymongo import uri_parser",
      "comment": "This import change could break backward compatibility with older pymongo versions. Should we add a try/except import pattern to handle both the old (`pymongo.uri_parser`) and new (`from pymongo import uri_parser`) import styles, ensuring compatibility across pymongo versions?",
      "comment_id": 2415704003,
      "user": "Copilot",
      "created_at": "2025-10-09T06:32:30Z",
      "url": "https://github.com/celery/celery/pull/9665#discussion_r2415704003"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9665,
      "file_path": "celery/backends/mongodb.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,7 @@\n         from bson.binary import Binary\n     except ImportError:\n         from pymongo.binary import Binary\n+    from pymongo import uri_parser",
      "comment": "The LLM slop is wasting your time here.  `from pymongo import uri_parser` is fine in both old and new versions.",
      "comment_id": 2468650853,
      "user": "cjwatson",
      "created_at": "2025-10-28T09:18:04Z",
      "url": "https://github.com/celery/celery/pull/9665#discussion_r2468650853"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9950,
      "file_path": "celery/backends/redis.py",
      "line": 543,
      "side": "RIGHT",
      "diff_hunk": "@@ -540,7 +540,7 @@ def on_chord_part_return(self, request, state, result,\n                 callback = maybe_signature(request.chord, app=app)\n                 total = int(chord_size_bytes) + totaldiff\n                 if readycount == total:\n-                    header_result = GroupResult.restore(gid)\n+                    header_result = GroupResult.restore(gid, app=app)",
      "comment": "good catch! can you also add unit test to verify this?",
      "comment_id": 2434883905,
      "user": "auvipy",
      "created_at": "2025-10-16T07:35:05Z",
      "url": "https://github.com/celery/celery/pull/9950#discussion_r2434883905"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9950,
      "file_path": "celery/backends/redis.py",
      "line": 543,
      "side": "RIGHT",
      "diff_hunk": "@@ -540,7 +540,7 @@ def on_chord_part_return(self, request, state, result,\n                 callback = maybe_signature(request.chord, app=app)\n                 total = int(chord_size_bytes) + totaldiff\n                 if readycount == total:\n-                    header_result = GroupResult.restore(gid)\n+                    header_result = GroupResult.restore(gid, app=app)",
      "comment": "[nitpick] Would it be more direct to pass the backend explicitly instead of the app? Using backend=self makes the dependency explicit and avoids relying on app resolution: header_result = GroupResult.restore(gid, backend=self). This keeps behavior identical while ensuring the exact backend instance handling the chord is used.\n```suggestion\n                    header_result = GroupResult.restore(gid, backend=self)\n```",
      "comment_id": 2434885468,
      "user": "Copilot",
      "created_at": "2025-10-16T07:35:40Z",
      "url": "https://github.com/celery/celery/pull/9950#discussion_r2434885468"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9950,
      "file_path": "celery/backends/redis.py",
      "line": 543,
      "side": "RIGHT",
      "diff_hunk": "@@ -540,7 +540,7 @@ def on_chord_part_return(self, request, state, result,\n                 callback = maybe_signature(request.chord, app=app)\n                 total = int(chord_size_bytes) + totaldiff\n                 if readycount == total:\n-                    header_result = GroupResult.restore(gid)\n+                    header_result = GroupResult.restore(gid, app=app)",
      "comment": "I don't think this is a better suggestion. Yes, it would work. But it would still need to resolve the app, and will be resolving the app to an incorrect app. Since we are only using the backend of the app for now, it wouldn't matter. But if we were to pass in the app instead of the backend, it would still leave us the ability to do anything else we want to do with the correct app if we wanted to do so in the future.\r\n\r\n```python\r\n    @classmethod\r\n    def restore(cls, id, backend=None, app=None):\r\n        \"\"\"Restore previously saved group result.\"\"\"\r\n        app = app or (\r\n            cls.app if not isinstance(cls.app, property) else current_app\r\n        )\r\n        backend = backend or app.backend\r\n        return backend.restore_group(id)\r\n``` ",
      "comment_id": 2450187927,
      "user": "kumuthu53",
      "created_at": "2025-10-22T02:01:43Z",
      "url": "https://github.com/celery/celery/pull/9950#discussion_r2450187927"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9950,
      "file_path": "celery/backends/redis.py",
      "line": 543,
      "side": "RIGHT",
      "diff_hunk": "@@ -540,7 +540,7 @@ def on_chord_part_return(self, request, state, result,\n                 callback = maybe_signature(request.chord, app=app)\n                 total = int(chord_size_bytes) + totaldiff\n                 if readycount == total:\n-                    header_result = GroupResult.restore(gid)\n+                    header_result = GroupResult.restore(gid, app=app)",
      "comment": "@auvipy, there is already unit test which checks how `GroupResult.restore` is being called. Which failed, referenced by your [comment](https://github.com/celery/celery/pull/9950#pullrequestreview-3344877690) after my change, because it was making sure `GroupResult.restore` was only being called with the group.\r\n\r\nI have now changed this unit test such that it checks that `GroupResult.restore` is also called with the correct app.\r\n\r\n```python\r\n# Confirm that the `GroupResult.restore` mock was called\r\ncomplex_header_result.assert_called_once_with(request.group, app=self.b.app)\r\n``` \r\n\r\nAll of the tests for the Redis backend now pass.\r\n\r\n```shell\r\n$ pytest t/unit/backends/test_redis.py\r\n======================================================================================================== test session starts =========================================================================================================\r\nplatform linux -- Python 3.13.9, pytest-8.4.2, pluggy-1.6.0\r\nrootdir: /home/kumuthu/projects/open-lynxx/celery\r\nconfigfile: pyproject.toml\r\nplugins: celery-1.2.1, pytest_docker_tools-3.1.9, subtests-0.14.2, timeout-2.3.1, rerunfailures-16.1, order-1.3.0, click-1.1.0\r\ncollected 90 items                                                                                                                                                                                                                   \r\n\r\nt/unit/backends/test_redis.py ..........................................................................................                                                                                                       [100%]\r\n\r\n========================================================================================================= 90 passed in 0.40s =========================================================================================================\r\n\r\n``` \r\n\r\n",
      "comment_id": 2453868158,
      "user": "kumuthu53",
      "created_at": "2025-10-23T04:08:21Z",
      "url": "https://github.com/celery/celery/pull/9950#discussion_r2453868158"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9959,
      "file_path": "celery/worker/consumer/delayed_delivery.py",
      "line": 184,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,7 +167,23 @@ def _bind_queues(self, app: Celery, connection: Connection) -> None:\n                     \"Failed to bind queue %r: %s\",\n                     queue.name, str(e)\n                 )\n-                raise\n+\n+                # We must re-raise on retried exceptions to ensure they are\n+                # caught with the outer retry_over_time mechanism.\n+                #\n+                # This could be removed if kombu used the `except*` clause to\n+                # catch specific exceptions from an ExceptionGroup.\n+                if isinstance(e, RETRIED_EXCEPTIONS):\n+                    raise\n+\n+                exceptions.append(e)\n+\n+        if exceptions:\n+            raise ExceptionGroup(\n+                \"One or more failures occurred while binding queues to \" +\n+                \"delayed delivery exchanges\",",
      "comment": "[nitpick] The error message uses string concatenation with `+` across multiple lines. Consider using a multi-line string literal or parenthesized concatenation for better readability: `\\\"One or more failures occurred while binding queues to delayed delivery exchanges\\\"`\n```suggestion\n                (\"One or more failures occurred while binding queues to \"\n                 \"delayed delivery exchanges\"),\n```",
      "comment_id": 2444752725,
      "user": "Copilot",
      "created_at": "2025-10-20T11:32:20Z",
      "url": "https://github.com/celery/celery/pull/9959#discussion_r2444752725"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9959,
      "file_path": "celery/worker/consumer/delayed_delivery.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,7 +167,30 @@ def _bind_queues(self, app: Celery, connection: Connection) -> None:\n                     \"Failed to bind queue %r: %s\",\n                     queue.name, str(e)\n                 )\n-                raise\n+\n+                # We must re-raise on retried exceptions to ensure they are\n+                # caught with the outer retry_over_time mechanism.\n+                #\n+                # This could be removed if:\n+                # * The minimum python version for Celery and Kombu is increased\n+                #   to 3.11.\n+                # * Kombu updated to use the `except*` clause to catch specific\n+                #   exceptions from an ExceptionGroup.\n+                # * We switch to using ExceptionGroup below to raise multiple\n+                #   exceptions.\n+                if isinstance(e, RETRIED_EXCEPTIONS):\n+                    raise\n+\n+                exceptions.append(e)\n+\n+        if exceptions:\n+            # Raise a single exception summarizing all binding failures\n+            # In Python 3.11+, we could use ExceptionGroup here instead.\n+            raise RuntimeError(\n+                (\"One or more failures occurred while binding queues to \"\n+                 \"delayed delivery exchanges\\n\") +\n+                \"\\n\".join(str(e) for e in exceptions),\n+            )",
      "comment": "Alternatively, this backport of [PEP 654's ExceptionGroup](https://github.com/agronholm/exceptiongroup) could be used when the runtime python version of < 3.11.  I've not used this backport before and can't endorse it.",
      "comment_id": 2444883455,
      "user": "Izzette",
      "created_at": "2025-10-20T12:34:06Z",
      "url": "https://github.com/celery/celery/pull/9959#discussion_r2444883455"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9959,
      "file_path": "celery/worker/consumer/delayed_delivery.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,7 +167,30 @@ def _bind_queues(self, app: Celery, connection: Connection) -> None:\n                     \"Failed to bind queue %r: %s\",\n                     queue.name, str(e)\n                 )\n-                raise\n+\n+                # We must re-raise on retried exceptions to ensure they are\n+                # caught with the outer retry_over_time mechanism.\n+                #\n+                # This could be removed if:\n+                # * The minimum python version for Celery and Kombu is increased\n+                #   to 3.11.\n+                # * Kombu updated to use the `except*` clause to catch specific\n+                #   exceptions from an ExceptionGroup.\n+                # * We switch to using ExceptionGroup below to raise multiple\n+                #   exceptions.\n+                if isinstance(e, RETRIED_EXCEPTIONS):\n+                    raise\n+\n+                exceptions.append(e)\n+\n+        if exceptions:\n+            # Raise a single exception summarizing all binding failures\n+            # In Python 3.11+, we could use ExceptionGroup here instead.\n+            raise RuntimeError(\n+                (\"One or more failures occurred while binding queues to \"\n+                 \"delayed delivery exchanges\\n\") +\n+                \"\\n\".join(str(e) for e in exceptions),\n+            )",
      "comment": "Done in https://github.com/celery/celery/pull/9959/commits/223decced66b85cbe44e3d90192f943e9c6d109f.",
      "comment_id": 2445228391,
      "user": "Izzette",
      "created_at": "2025-10-20T14:42:03Z",
      "url": "https://github.com/celery/celery/pull/9959#discussion_r2445228391"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9959,
      "file_path": "celery/worker/consumer/delayed_delivery.py",
      "line": 191,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,7 +170,27 @@ def _bind_queues(self, app: Celery, connection: Connection) -> None:\n                     \"Failed to bind queue %r: %s\",\n                     queue.name, str(e)\n                 )\n-                raise\n+\n+                # We must re-raise on retried exceptions to ensure they are\n+                # caught with the outer retry_over_time mechanism.\n+                #\n+                # This could be removed if one of:\n+                # * The minimum python version for Celery and Kombu is\n+                #   increased to 3.11. Kombu updated to use the `except*`\n+                #   clause to catch specific exceptions from an ExceptionGroup.\n+                # * Kombu's retry_over_time utility is updated to use the\n+                #   catch utility from agronholm's exceptiongroup backport.\n+                if isinstance(e, RETRIED_EXCEPTIONS):\n+                    raise\n+\n+                exceptions.append(e)\n+\n+        if exceptions:\n+            raise ExceptionGroup(\n+                (\"One or more failures occurred while binding queues to \"\n+                 \"delayed delivery exchanges\\n\"),",
      "comment": "The trailing newline in the ExceptionGroup message appears unintentional and may affect formatting in logs or error displays. Should this newline be removed to keep the message concise?",
      "comment_id": 2446007175,
      "user": "Copilot",
      "created_at": "2025-10-20T20:11:34Z",
      "url": "https://github.com/celery/celery/pull/9959#discussion_r2446007175"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9959,
      "file_path": "celery/worker/consumer/delayed_delivery.py",
      "line": 191,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,7 +170,27 @@ def _bind_queues(self, app: Celery, connection: Connection) -> None:\n                     \"Failed to bind queue %r: %s\",\n                     queue.name, str(e)\n                 )\n-                raise\n+\n+                # We must re-raise on retried exceptions to ensure they are\n+                # caught with the outer retry_over_time mechanism.\n+                #\n+                # This could be removed if one of:\n+                # * The minimum python version for Celery and Kombu is\n+                #   increased to 3.11. Kombu updated to use the `except*`\n+                #   clause to catch specific exceptions from an ExceptionGroup.\n+                # * Kombu's retry_over_time utility is updated to use the\n+                #   catch utility from agronholm's exceptiongroup backport.\n+                if isinstance(e, RETRIED_EXCEPTIONS):\n+                    raise\n+\n+                exceptions.append(e)\n+\n+        if exceptions:\n+            raise ExceptionGroup(\n+                (\"One or more failures occurred while binding queues to \"\n+                 \"delayed delivery exchanges\\n\"),",
      "comment": "Actually this is a good catch from Copilot.  I'm going to remove the newline.\n```suggestion\n                (\"One or more failures occurred while binding queues to \"\n                 \"delayed delivery exchanges\"),\n```",
      "comment_id": 2447105619,
      "user": "Izzette",
      "created_at": "2025-10-21T07:53:23Z",
      "url": "https://github.com/celery/celery/pull/9959#discussion_r2447105619"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9959,
      "file_path": "t/unit/worker/test_native_delayed_delivery.py",
      "line": 395,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,3 +308,162 @@ def test_setup_bind_error(self, mock_bind, caplog):\n         assert len([r for r in caplog.records if r.levelname == \"CRITICAL\"]) == 1\n         assert any(\"Failed to bind queue\" in r.message for r in caplog.records)\n         assert any(\"Failed to setup delayed delivery for all broker URLs\" in r.message for r in caplog.records)\n+\n+    @patch('celery.worker.consumer.delayed_delivery.bind_queue_to_native_delayed_delivery_exchange')\n+    def test_bind_queues_continues_after_failure(self, mock_bind, caplog):\n+        \"\"\"\n+        Test that binding continues for remaining queues after one fails.\n+        \"\"\"\n+        consumer_mock = MagicMock()\n+        consumer_mock.app.conf.broker_native_delayed_delivery_queue_type = \\\n+            'classic'\n+        consumer_mock.app.conf.broker_url = 'amqp://'\n+\n+        # Create three queues\n+        queue1 = Queue('queue1', exchange=Exchange('exchange1', type='topic'))\n+        queue2 = Queue('queue2', exchange=Exchange('exchange2', type='topic'))\n+        queue3 = Queue('queue3', exchange=Exchange('exchange3', type='topic'))\n+\n+        consumer_mock.app.amqp.queues = {\n+            'queue1': queue1,\n+            'queue2': queue2,\n+            'queue3': queue3,\n+        }\n+\n+        # Make the second queue fail to bind\n+        def bind_side_effect(connection, queue):\n+            if queue.name == 'queue2':\n+                raise NotFound(\n+                    reply_text=\"NOT_FOUND - no queue 'queue2' in vhost '/'\",\n+                    method_name=\"Queue.bind\",\n+                    reply_code=404,\n+                )\n+\n+        mock_bind.side_effect = bind_side_effect\n+\n+        delayed_delivery = DelayedDelivery(consumer_mock)\n+        delayed_delivery.start(consumer_mock)\n+\n+        # Verify that bind was called for all three queues\n+        assert mock_bind.call_count == 3\n+\n+        # Verify error was logged for queue2\n+        error_logs = [r for r in caplog.records if r.levelname == \"ERROR\"]\n+        expected_msg = \\\n+            \"Queue.bind: (404) NOT_FOUND - no queue 'queue2' in vhost '/'\"\n+        assert any(expected_msg in r.message for r in error_logs)\n+\n+    @patch('celery.worker.consumer.delayed_delivery.bind_queue_to_native_delayed_delivery_exchange')\n+    def test_bind_queues_raises_exceptions_on_failures(self, mock_bind):\n+        \"\"\"Test that Exceptions are raised with all binding failures.\"\"\"\n+        consumer_mock = MagicMock()\n+        consumer_mock.app.conf.broker_native_delayed_delivery_queue_type = \\\n+            'classic'\n+        consumer_mock.app.conf.broker_url = 'amqp://'\n+\n+        # Create three queues\n+        queue1 = Queue('queue1', exchange=Exchange('exchange1', type='topic'))\n+        queue2 = Queue('queue2', exchange=Exchange('exchange2', type='topic'))\n+        queue3 = Queue('queue3', exchange=Exchange('exchange3', type='topic'))\n+\n+        consumer_mock.app.amqp.queues = {\n+            'queue1': queue1,\n+            'queue2': queue2,\n+            'queue3': queue3,\n+        }\n+\n+        # Make queue1 and queue3 fail with different errors\n+        def bind_side_effect(connection, queue):\n+            if queue.name == 'queue1':\n+                raise ValueError(\"Queue1 binding failed\")\n+            elif queue.name == 'queue3':\n+                raise RuntimeError(\"Queue3 binding failed\")\n+\n+        mock_bind.side_effect = bind_side_effect\n+\n+        delayed_delivery = DelayedDelivery(consumer_mock)\n+\n+        # Should raise RuntimeError containing both exceptions messages\n+        with pytest.raises(ExceptionGroup) as exc_info:\n+            delayed_delivery._setup_delayed_delivery(consumer_mock, 'amqp://')\n+\n+        # Verify the RuntimeError message contains both exceptions\n+        exception_group = exc_info.value\n+        assert str(exception_group) == (\n+            \"One or more failures occurred while binding queues to delayed \"\n+            \"delivery exchanges\\n\"\n+            \" (2 sub-exceptions)\"",
      "comment": "```suggestion\n            \"delivery exchanges (2 sub-exceptions)\"\n```",
      "comment_id": 2447107562,
      "user": "Izzette",
      "created_at": "2025-10-21T07:53:59Z",
      "url": "https://github.com/celery/celery/pull/9959#discussion_r2447107562"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9959,
      "file_path": "celery/worker/consumer/delayed_delivery.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,6 +160,7 @@ def _bind_queues(self, app: Celery, connection: Connection) -> None:\n             logger.warning(\"No queues found to bind for delayed delivery\")\n             return\n \n+        exceptions: list[Exception] = []",
      "comment": "The type annotation uses PEP 585 syntax (`list[Exception]`), which requires Python 3.9+. Should we use `List[Exception]` from typing instead for compatibility with earlier Python versions, or verify that Celery's minimum Python version is 3.9+?\n```suggestion\n        exceptions: List[Exception] = []\n```",
      "comment_id": 2452553388,
      "user": "Copilot",
      "created_at": "2025-10-22T15:47:24Z",
      "url": "https://github.com/celery/celery/pull/9959#discussion_r2452553388"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9952,
      "file_path": "t/unit/app/test_beat.py",
      "line": 724,
      "side": "RIGHT",
      "diff_hunk": "@@ -708,6 +709,25 @@ def test_create_schedule_corrupted_dbm_error(self):\n         s._create_schedule()\n         s._destroy_open_corrupted_schedule.assert_called_with(expected_error)\n \n+    def test_create_schedule_corrupted_pickle_error(self):\n+        \"\"\"\n+        Test that any UnpicklingError that might happen when opening beat-schedule.db are caught\n+        \"\"\"\n+        s = create_persistent_scheduler()[0](app=self.app,\n+                                             schedule_filename='schedule')\n+        s._store = MagicMock()\n+        s._destroy_open_corrupted_schedule = Mock()\n+        s._destroy_open_corrupted_schedule.return_value = MagicMock()\n+\n+        # self._store['entries'] = {} will throw a pickle.UnpicklingError\n+        s._store.__getitem__.side_effect = pickle.UnpicklingError(\"test\")\n+        # then, when _create_schedule tries to reset _store['entries'], throw another error, specifically dbm.error",
      "comment": "The inline comments don\u2019t match the code: line 722 describes a set operation but the code stubs __getitem__; line 724 mentions dbm.error but the code uses UnpicklingError. Suggest updating to: `# Accessing self._store['entries'] will raise a pickle.UnpicklingError` and `# Then, when _create_schedule tries to reset _store['entries'], raise another UnpicklingError`.\n```suggestion\n        # Accessing self._store['entries'] will raise a pickle.UnpicklingError\n        s._store.__getitem__.side_effect = pickle.UnpicklingError(\"test\")\n        # Then, when _create_schedule tries to reset _store['entries'], raise another UnpicklingError\n```",
      "comment_id": 2435797841,
      "user": "Copilot",
      "created_at": "2025-10-16T12:51:46Z",
      "url": "https://github.com/celery/celery/pull/9952#discussion_r2435797841"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9952,
      "file_path": "t/unit/app/test_beat.py",
      "line": 714,
      "side": "RIGHT",
      "diff_hunk": "@@ -708,6 +709,25 @@ def test_create_schedule_corrupted_dbm_error(self):\n         s._create_schedule()\n         s._destroy_open_corrupted_schedule.assert_called_with(expected_error)\n \n+    def test_create_schedule_corrupted_pickle_error(self):\n+        \"\"\"\n+        Test that any UnpicklingError that might happen when opening beat-schedule.db are caught",
      "comment": "Grammatical agreement: 'UnpicklingError' is singular; change 'are caught' to 'is caught'.\n```suggestion\n        Test that any UnpicklingError that might happen when opening beat-schedule.db is caught\n```",
      "comment_id": 2435797873,
      "user": "Copilot",
      "created_at": "2025-10-16T12:51:46Z",
      "url": "https://github.com/celery/celery/pull/9952#discussion_r2435797873"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9953,
      "file_path": "celery/fixups/django.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,6 +202,9 @@ def _close_database(self) -> None:\n         for conn in self._db.connections.all():\n             try:\n                 conn.close()\n+                if hasattr(conn, \"close_pool\"):\n+                    with contextlib.suppress(KeyError):\n+                        conn.close_pool()",
      "comment": "\"This appears to be a user-facing behavior change (connections now have their pools closed explicitly), which could affect existing users with custom connection implementations. Is this intended?",
      "comment_id": 2441752048,
      "user": "Copilot",
      "created_at": "2025-10-18T07:44:42Z",
      "url": "https://github.com/celery/celery/pull/9953#discussion_r2441752048"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9953,
      "file_path": "celery/fixups/django.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,6 +202,9 @@ def _close_database(self) -> None:\n         for conn in self._db.connections.all():\n             try:\n                 conn.close()\n+                if hasattr(conn, \"close_pool\"):\n+                    with contextlib.suppress(KeyError):\n+                        conn.close_pool()",
      "comment": "just to be extra cautious, is there any way we can let the old custom pools working as before?",
      "comment_id": 2441755096,
      "user": "auvipy",
      "created_at": "2025-10-18T07:53:06Z",
      "url": "https://github.com/celery/celery/pull/9953#discussion_r2441755096"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9953,
      "file_path": "celery/fixups/django.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,6 +202,9 @@ def _close_database(self) -> None:\n         for conn in self._db.connections.all():\n             try:\n                 conn.close()\n+                if hasattr(conn, \"close_pool\"):\n+                    with contextlib.suppress(KeyError):\n+                        conn.close_pool()",
      "comment": "Maybe I can extend the check with something like `django.conf.settings[conn.alias].get(\"OPTIONS\", {}).get(\"pool\")` to make sure Django's Connection pool is enabled for this connection: https://docs.djangoproject.com/en/5.2/ref/databases/#connection-pool\r\n\r\nFor extra safety we could also introduce some new constant like `CELERY_CLOSE_DB_POOL = [\"default\"]`. But I would rather relay on Django settings and have this potential option to be able do explicit enable/disable. ",
      "comment_id": 2442253267,
      "user": "petrprikryl",
      "created_at": "2025-10-18T11:30:42Z",
      "url": "https://github.com/celery/celery/pull/9953#discussion_r2442253267"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9953,
      "file_path": "celery/fixups/django.py",
      "line": 206,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,6 +202,10 @@ def _close_database(self) -> None:\n         for conn in self._db.connections.all():\n             try:\n                 conn.close()\n+                pool_enabled = self._settings.DATABASES.get(conn.alias, {}).get(\"OPTIONS\", {}).get(\"pool\")\n+                if pool_enabled and hasattr(conn, \"close_pool\"):",
      "comment": "The KeyError suppression lacks explanation. Should we add a brief inline comment explaining when/why close_pool() raises KeyError (e.g., '# close_pool() raises KeyError if pool already closed')? This would help future maintainers understand the expected failure mode.\n```suggestion\n                if pool_enabled and hasattr(conn, \"close_pool\"):\n                    # close_pool() raises KeyError if the pool is already closed or does not exist\n```",
      "comment_id": 2444922329,
      "user": "Copilot",
      "created_at": "2025-10-20T12:50:58Z",
      "url": "https://github.com/celery/celery/pull/9953#discussion_r2444922329"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10045,
      "file_path": "t/unit/fixups/test_django.py",
      "line": 447,
      "side": "RIGHT",
      "diff_hunk": "@@ -410,3 +411,46 @@ def test_django_setup(self, patching):\n         f = self.Fixup(self.app)\n         f.django_setup()\n         django.setup.assert_called_with()\n+\n+    def test_no_recursive_worker_instantiation(self, patching):\n+        \"\"\"Test that DjangoWorkerFixup doesn't create a WorkController in __init__.\n+\n+        This is a direct test of the root cause: DjangoWorkerFixup.__init__\n+        should NOT instantiate a WorkController when worker=None.\n+\n+        Current behavior (BUG):\n+        - DjangoWorkerFixup(app, worker=None) creates WorkController(app)\n+        - This causes recursive instantiation when called from signals\n+\n+        Expected behavior (after fix):\n+        - DjangoWorkerFixup(app, worker=None) should set self.worker = None\n+        - Worker should be set later via the on_worker_init callback\n+        \"\"\"\n+        from celery.worker import WorkController\n+\n+        patching('celery.fixups.django.symbol_by_name')\n+        patching('celery.fixups.django.import_module')\n+        patching.modules('django', 'django.db', 'django.core.checks')\n+\n+        # Track WorkController instantiations\n+        instantiation_count = {'count': 0}\n+        original_init = WorkController.__init__\n+\n+        def tracking_init(self_worker, *args, **kwargs):\n+            instantiation_count['count'] += 1\n+            return original_init(self_worker, *args, **kwargs)\n+\n+        with patch.object(WorkController, '__init__', tracking_init):\n+            # Creating DjangoWorkerFixup without a worker argument\n+            # should NOT create a WorkController instance\n+            try:\n+                DjangoWorkerFixup(self.app, worker=None)",
      "comment": "The test is passing `worker=None` to `DjangoWorkerFixup`, but the updated `__init__` method no longer accepts a `worker` parameter. This will cause a TypeError when the test runs.",
      "comment_id": 2656077783,
      "user": "Copilot",
      "created_at": "2026-01-01T04:18:12Z",
      "url": "https://github.com/celery/celery/pull/10045#discussion_r2656077783"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10045,
      "file_path": "t/unit/fixups/test_django.py",
      "line": 448,
      "side": "RIGHT",
      "diff_hunk": "@@ -410,3 +411,46 @@ def test_django_setup(self, patching):\n         f = self.Fixup(self.app)\n         f.django_setup()\n         django.setup.assert_called_with()\n+\n+    def test_no_recursive_worker_instantiation(self, patching):\n+        \"\"\"Test that DjangoWorkerFixup doesn't create a WorkController in __init__.\n+\n+        This is a direct test of the root cause: DjangoWorkerFixup.__init__\n+        should NOT instantiate a WorkController when worker=None.\n+\n+        Current behavior (BUG):\n+        - DjangoWorkerFixup(app, worker=None) creates WorkController(app)\n+        - This causes recursive instantiation when called from signals\n+\n+        Expected behavior (after fix):\n+        - DjangoWorkerFixup(app, worker=None) should set self.worker = None\n+        - Worker should be set later via the on_worker_init callback\n+        \"\"\"\n+        from celery.worker import WorkController\n+\n+        patching('celery.fixups.django.symbol_by_name')\n+        patching('celery.fixups.django.import_module')\n+        patching.modules('django', 'django.db', 'django.core.checks')\n+\n+        # Track WorkController instantiations\n+        instantiation_count = {'count': 0}\n+        original_init = WorkController.__init__\n+\n+        def tracking_init(self_worker, *args, **kwargs):\n+            instantiation_count['count'] += 1\n+            return original_init(self_worker, *args, **kwargs)\n+\n+        with patch.object(WorkController, '__init__', tracking_init):\n+            # Creating DjangoWorkerFixup without a worker argument\n+            # should NOT create a WorkController instance\n+            try:\n+                DjangoWorkerFixup(self.app, worker=None)\n+            except (RecursionError, AttributeError, TypeError):",
      "comment": "'except' clause does nothing but pass and there is no explanatory comment.\n```suggestion\n            except (RecursionError, AttributeError, TypeError):\n                # Older/buggy DjangoWorkerFixup implementations may raise one of\n                # these errors when instantiated with worker=None; we ignore them\n                # here because this test only asserts on WorkController creation.\n```",
      "comment_id": 2656077786,
      "user": "Copilot",
      "created_at": "2026-01-01T04:18:12Z",
      "url": "https://github.com/celery/celery/pull/10045#discussion_r2656077786"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10045,
      "file_path": "celery/fixups/django.py",
      "line": 217,
      "side": "RIGHT",
      "diff_hunk": "@@ -210,14 +210,20 @@ def close_database(self, **kwargs: Any) -> None:\n             self._close_database()\n         self._db_recycles += 1\n \n+    def _is_prefork(self) -> bool:\n+        if self.worker is None:\n+            return False\n+        pool = self.worker.pool_cls if isinstance(self.worker.pool_cls, str) else self.worker.pool_cls.__module__\n+        return \"prefork\" in pool",
      "comment": "The new `_is_prefork()` method lacks test coverage. Since this method introduces new logic to handle cases where `worker` is None or `pool_cls` is a string, should we add unit tests to verify:\n1. Behavior when `self.worker` is None (returns False)\n2. Behavior when `pool_cls` is a string containing \"prefork\"\n3. Behavior when `pool_cls` is a class with __module__ containing \"prefork\"\n4. Behavior when neither condition contains \"prefork\"\n\nThis is important because the method replaces inline logic that was previously tested indirectly through test_close_database_conn_pool_thread_pool.",
      "comment_id": 2656759499,
      "user": "Copilot",
      "created_at": "2026-01-02T02:46:44Z",
      "url": "https://github.com/celery/celery/pull/10045#discussion_r2656759499"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10045,
      "file_path": "t/unit/fixups/test_django.py",
      "line": 427,
      "side": "RIGHT",
      "diff_hunk": "@@ -410,3 +411,43 @@ def test_django_setup(self, patching):\n         f = self.Fixup(self.app)\n         f.django_setup()\n         django.setup.assert_called_with()\n+\n+    def test_no_recursive_worker_instantiation(self, patching):\n+        \"\"\"Test that DjangoWorkerFixup doesn't create a WorkController in __init__.\n+\n+        This is a direct test of the root cause: DjangoWorkerFixup.__init__\n+        should NOT instantiate a WorkController when worker=None.\n+\n+        Current behavior (BUG):\n+        - DjangoWorkerFixup(app, worker=None) creates WorkController(app)\n+        - This causes recursive instantiation when called from signals\n+\n+        Expected behavior (after fix):\n+        - DjangoWorkerFixup(app, worker=None) should set self.worker = None\n+        - Worker should be set later via the on_worker_init callback",
      "comment": "The docstring for `test_no_recursive_worker_instantiation` contains outdated information. It mentions \"Current behavior (BUG)\" and \"DjangoWorkerFixup(app, worker=None)\", but the fix has already been applied, so this test validates the expected behavior rather than documenting a bug. Consider updating the docstring to reflect that this is a regression test verifying that the fix remains in place, not documentation of current buggy behavior.\n```suggestion\n        \"\"\"Regression test: DjangoWorkerFixup must not create a WorkController in __init__.\n\n        Historically, DjangoWorkerFixup.__init__ instantiated a WorkController when\n        called with worker=None, which could cause recursive instantiation when\n        invoked from worker lifecycle signals.\n\n        This test verifies the fixed behavior:\n        - DjangoWorkerFixup(app, worker=None) must not create a WorkController\n        - It should instead leave self.worker unset and rely on on_worker_init\n          to attach the actual worker instance later\n```",
      "comment_id": 2656759502,
      "user": "Copilot",
      "created_at": "2026-01-02T02:46:44Z",
      "url": "https://github.com/celery/celery/pull/10045#discussion_r2656759502"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10045,
      "file_path": "t/integration/test_django_settings.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+import logging\n+\n+logging.info(\"Initializing Django settings for Celery integration tests\")\n+",
      "comment": "The logging.info call at module level in a settings file is unusual and could produce unexpected output during test execution. Django settings modules typically contain only configuration variables. Consider removing this logging statement or moving it to a more appropriate location if this diagnostic output is needed.\n```suggestion\n\n```",
      "comment_id": 2656759517,
      "user": "Copilot",
      "created_at": "2026-01-02T02:46:45Z",
      "url": "https://github.com/celery/celery/pull/10045#discussion_r2656759517"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10045,
      "file_path": "t/integration/test_worker.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,3 +19,49 @@ def test_run_worker():\n         \"Retrying to establish a connection to the message broker after a connection \"\n         \"loss has been disabled (app.conf.broker_connection_retry_on_startup=False). \"\n         \"Shutting down...\") != -1, output\n+\n+\n+def test_django_fixup_direct_worker(caplog):\n+    \"\"\"Test Django fixup by directly instantiating Celery worker without subprocess.\"\"\"\n+    import logging\n+\n+    import django\n+\n+    # Set logging level to capture debug messages\n+    caplog.set_level(logging.DEBUG)\n+\n+    # Configure Django settings\n+    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 't.integration.test_django_settings')\n+    django.setup()\n+\n+    # Create Celery app with Django integration\n+    app = Celery('test_django_direct')\n+    app.config_from_object('django.conf:settings', namespace='CELERY')\n+    app.autodiscover_tasks()\n+\n+    # Test that we can access worker configuration without recursion errors\n+    # This should trigger the Django fixup initialization\n+    worker = app.Worker(\n+        pool='solo',\n+        concurrency=1,\n+        loglevel='debug'\n+    )\n+\n+    # Accessing pool_cls should not cause AttributeError\n+    pool_cls = worker.pool_cls\n+    assert pool_cls is not None\n+\n+    # Verify pool_cls has __module__ attribute (should be a class, not a string)\n+    assert hasattr(pool_cls, '__module__'), \\\n+        f\"pool_cls should be a class with __module__, got {type(pool_cls)}: {pool_cls}\"\n+\n+    # Capture and check logs\n+    log_output = caplog.text\n+\n+    # Verify no recursion-related errors in logs\n+    assert \"RecursionError\" not in log_output, f\"RecursionError found in logs:\\n{log_output}\"\n+    assert \"maximum recursion depth exceeded\" not in log_output, \\\n+        f\"Recursion depth error found in logs:\\n{log_output}\"\n+\n+    assert \"AttributeError: 'str' object has no attribute '__module__'.\" not in log_output, \\\n+        f\"AttributeError found in logs:\\n{log_output}\"",
      "comment": "I replaced os.environ with monkeypatch to prevent the issues mentioned in the comment",
      "comment_id": 2657688025,
      "user": "bruunotrindade",
      "created_at": "2026-01-02T13:06:04Z",
      "url": "https://github.com/celery/celery/pull/10045#discussion_r2657688025"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10045,
      "file_path": "t/integration/test_django_settings.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+import logging\n+\n+logging.info(\"Initializing Django settings for Celery integration tests\")\n+",
      "comment": "It's expected because the stacktrace and the exceptions become visible when logging is used",
      "comment_id": 2657689535,
      "user": "bruunotrindade",
      "created_at": "2026-01-02T13:07:13Z",
      "url": "https://github.com/celery/celery/pull/10045#discussion_r2657689535"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10045,
      "file_path": "celery/fixups/django.py",
      "line": 134,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,10 +129,10 @@ def _now(self) -> datetime:\n \n class DjangoWorkerFixup:\n     _db_recycles = 0\n+    worker = None  # Set via on_worker_init callback to avoid recursive WorkController instantiation\n \n-    def __init__(self, app: \"Celery\", worker: Optional[\"WorkController\"] = None) -> None:\n+    def __init__(self, app: \"Celery\") -> None:",
      "comment": "This is a backward-incompatible API change (removing the `worker` parameter from `__init__`). Is this intended?\n\nIf yes: This should be documented with `versionchanged::` in the docstring and included in the changelog/whatsnew, noting that users creating `DjangoWorkerFixup` directly should now set the worker attribute separately after instantiation.\n\nIf no: Could we maintain backward compatibility by keeping the optional `worker` parameter but not creating a `WorkController` when it's `None`? For example: `def __init__(self, app: \"Celery\", worker: Optional[\"WorkController\"] = None)` and then `self.worker = worker` without the fallback instantiation.",
      "comment_id": 2659459633,
      "user": "Copilot",
      "created_at": "2026-01-04T07:04:31Z",
      "url": "https://github.com/celery/celery/pull/10045#discussion_r2659459633"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10045,
      "file_path": "celery/fixups/django.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,10 +129,10 @@ def _now(self) -> datetime:\n \n class DjangoWorkerFixup:\n     _db_recycles = 0\n+    worker = None  # Set via on_worker_init callback to avoid recursive WorkController instantiation",
      "comment": "This is a user-facing behavior change in the Django fixup. Should we add documentation updates (versionchanged::) and a whatsnew/changelog entry?\n\nThe change affects how `DjangoWorkerFixup` is initialized and how the worker instance is set (now deferred to `on_worker_init` callback). Users who create `DjangoWorkerFixup` directly will need to be aware of this change, and the changelog should note this fixes the recursion bug (#10042) and the AttributeError when pool_cls is a string.",
      "comment_id": 2659459636,
      "user": "Copilot",
      "created_at": "2026-01-04T07:04:32Z",
      "url": "https://github.com/celery/celery/pull/10045#discussion_r2659459636"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7620,
      "file_path": "celery/backends/base.py",
      "line": 826,
      "side": "RIGHT",
      "diff_hunk": "@@ -817,11 +817,25 @@ class BaseKeyValueStoreBackend(Backend):\n     def __init__(self, *args, **kwargs):\n         if hasattr(self.key_t, '__func__'):  # pragma: no cover\n             self.key_t = self.key_t.__func__  # remove binding\n-        self._encode_prefixes()\n         super().__init__(*args, **kwargs)\n+        self._add_global_keyprefix()\n+        self._encode_prefixes()\n         if self.implements_incr:\n             self.apply_chord = self._apply_chord_incr\n \n+    def _add_global_keyprefix(self):",
      "comment": "from my understanding, this feature needs to be documented properly",
      "comment_id": 1012654253,
      "user": "auvipy",
      "created_at": "2022-11-03T09:17:07Z",
      "url": "https://github.com/celery/celery/pull/7620#discussion_r1012654253"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7620,
      "file_path": "celery/backends/base.py",
      "line": 826,
      "side": "RIGHT",
      "diff_hunk": "@@ -817,11 +817,25 @@ class BaseKeyValueStoreBackend(Backend):\n     def __init__(self, *args, **kwargs):\n         if hasattr(self.key_t, '__func__'):  # pragma: no cover\n             self.key_t = self.key_t.__func__  # remove binding\n-        self._encode_prefixes()\n         super().__init__(*args, **kwargs)\n+        self._add_global_keyprefix()\n+        self._encode_prefixes()\n         if self.implements_incr:\n             self.apply_chord = self._apply_chord_incr\n \n+    def _add_global_keyprefix(self):",
      "comment": "@auvipy If you could elaborate on what you exactly mean here, that would help a lot on our side to adjust the PR as per your needs.\r\n\r\nAnyways, the method already has docstrings and the feature is already documented based on my understanding: https://docs.celeryq.dev/en/master/search.html?q=keyprefix.",
      "comment_id": 1015162243,
      "user": "gabor-boros",
      "created_at": "2022-11-07T09:04:13Z",
      "url": "https://github.com/celery/celery/pull/7620#discussion_r1015162243"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10048,
      "file_path": "celery/contrib/testing/worker.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,7 +42,9 @@ def __init__(self, *args, **kwargs):\n \n         super().__init__(*args, **kwargs)\n \n-        if self.pool_cls.__module__.split('.')[-1] == 'prefork':\n+        # Defensive check: pool_cls may be a string (e.g., 'prefork') or a class\n+        pool_module = self.pool_cls if isinstance(self.pool_cls, str) else self.pool_cls.__module__\n+        if pool_module.split('.')[-1] == 'prefork':",
      "comment": "The changes to `TestWorkController.__init__` add defensive handling for string `pool_cls`, but there are no unit tests verifying this works correctly. This is different from the `Beat.create` method where two new tests were added. Should we add similar tests for `TestWorkController` to ensure the string pool_cls case is covered?",
      "comment_id": 2659467735,
      "user": "Copilot",
      "created_at": "2026-01-04T07:22:28Z",
      "url": "https://github.com/celery/celery/pull/10048#discussion_r2659467735"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9869,
      "file_path": "t/unit/worker/test_control.py",
      "line": 838,
      "side": "RIGHT",
      "diff_hunk": "@@ -815,3 +815,56 @@ def test_query_task(self):\n             assert ret[req1.id][0] == 'reserved'\n         finally:\n             worker_state.reserved_requests.clear()\n+\n+    @patch('celery.Celery.backend', new=PropertyMock(name='backend'))\n+    def test_revoke_backend_status_update(self):\n+        state = self.create_state()\n+        task_ids = ['task-1', 'task-2']\n+\n+        control._revoke(state, task_ids)\n+\n+        assert self.app.backend.mark_as_revoked.call_count == 2\n+        calls = self.app.backend.mark_as_revoked.call_args_list\n+        assert calls[0] == (('task-1',), {'reason': 'revoked', 'store_result': True})\n+        assert calls[1] == (('task-2',), {'reason': 'revoked', 'store_result': True})\n+\n+    @patch('celery.Celery.backend', new=PropertyMock(name='backend'))\n+    def test_revoke_backend_failure_defensive(self):\n+        self.app.backend.mark_as_revoked.side_effect = Exception(\"Backend error\")\n+        state = self.create_state()\n+\n+        control._revoke(state, ['task-1'])\n+\n+        assert 'task-1' in revoked",
      "comment": "The test references `revoked` but this variable is not defined in the test scope. This should likely be `worker_state.revoked` based on the context of the _revoke function.\n```suggestion\n        assert 'task-1' in worker_state.revoked\n```",
      "comment_id": 2301778333,
      "user": "Copilot",
      "created_at": "2025-08-26T18:19:51Z",
      "url": "https://github.com/celery/celery/pull/9869#discussion_r2301778333"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9869,
      "file_path": "celery/worker/control.py",
      "line": 222,
      "side": "RIGHT",
      "diff_hunk": "@@ -216,6 +216,13 @@ def _revoke(state, task_ids, terminate=False, signal=None, **kwargs):\n     terminated = set()\n \n     worker_state.revoked.update(task_ids)\n+\n+    for task_id in task_ids:\n+        try:\n+            state.app.backend.mark_as_revoked(task_id, reason='revoked', store_result=True)",
      "comment": "This appears to be a user-facing behavior change where revoked tasks are now marked in the backend, which could affect existing users who rely on specific backend state handling. Is this intended? If yes: Could we add migration guidance in the PR description and docs (versionchanged::), and consider a compat/deprecation path through vX.Y?",
      "comment_id": 2301778340,
      "user": "Copilot",
      "created_at": "2025-08-26T18:19:51Z",
      "url": "https://github.com/celery/celery/pull/9869#discussion_r2301778340"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9869,
      "file_path": "celery/worker/control.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -216,6 +216,13 @@ def _revoke(state, task_ids, terminate=False, signal=None, **kwargs):\n     terminated = set()\n \n     worker_state.revoked.update(task_ids)\n+\n+    for task_id in task_ids:\n+        try:\n+            state.app.backend.mark_as_revoked(task_id, reason='revoked', store_result=True)\n+        except Exception as exc:\n+            logger.warning('Failed to mark task %s as revoked in backend: %s', task_id, exc)",
      "comment": "This appears to be a user-facing behavior change (no backend update \u2192 backend update on revoke), which could impact existing users who may not expect this side effect or may have backends that don't support `mark_as_revoked`. Is this intended? If yes: Could we add migration guidance in the PR description and docs (versionchanged::), and consider whether all backends implement `mark_as_revoked` safely? If no: Would reverting to the previous behavior and adding a regression test make sense?",
      "comment_id": 2464469023,
      "user": "Copilot",
      "created_at": "2025-10-27T05:31:21Z",
      "url": "https://github.com/celery/celery/pull/9869#discussion_r2464469023"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9910,
      "file_path": "celery/canvas.py",
      "line": 1744,
      "side": "RIGHT",
      "diff_hunk": "@@ -1741,7 +1741,7 @@ def _prepared(self, tasks, partial_args, group_id, root_id, app,\n \n     def _apply_tasks(self, tasks, producer=None, app=None, p=None,\n                      add_to_parent=None, chord=None,\n-                     args=None, kwargs=None, **options):\n+                     args=None, kwargs=None, group_index=None, **options):",
      "comment": "It won't be used, I added the parameter to prevent it from being included in the `options`",
      "comment_id": 2377870192,
      "user": "simonepozzoli-pix4d",
      "created_at": "2025-09-25T06:17:33Z",
      "url": "https://github.com/celery/celery/pull/9910#discussion_r2377870192"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9910,
      "file_path": "celery/canvas.py",
      "line": 1744,
      "side": "RIGHT",
      "diff_hunk": "@@ -1741,7 +1741,7 @@ def _prepared(self, tasks, partial_args, group_id, root_id, app,\n \n     def _apply_tasks(self, tasks, producer=None, app=None, p=None,\n                      add_to_parent=None, chord=None,\n-                     args=None, kwargs=None, **options):\n+                     args=None, kwargs=None, group_index=None, **options):",
      "comment": "To further explain myself: calling `group._apply_tasks(group_index=0)`, all tasks schedule for this group would have the same group_index and results from this group can't be ordered.\r\nIMO is not correct to pass a `group_index` to this method, it should be ignored when scheduling groups.",
      "comment_id": 2377945900,
      "user": "simonepozzoli-pix4d",
      "created_at": "2025-09-25T06:55:28Z",
      "url": "https://github.com/celery/celery/pull/9910#discussion_r2377945900"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9910,
      "file_path": "celery/canvas.py",
      "line": 1744,
      "side": "RIGHT",
      "diff_hunk": "@@ -1741,7 +1741,7 @@ def _prepared(self, tasks, partial_args, group_id, root_id, app,\n \n     def _apply_tasks(self, tasks, producer=None, app=None, p=None,\n                      add_to_parent=None, chord=None,\n-                     args=None, kwargs=None, **options):\n+                     args=None, kwargs=None, group_index=None, **options):",
      "comment": "Adding the `group_index` parameter appears to be a signature change to the `_apply_tasks` method. Is this intended to be a breaking change, or should backward compatibility be maintained? If this is a private method (indicated by the underscore prefix), the change may be acceptable, but it would be helpful to understand if any internal callers need updates.\n```suggestion\n                     args=None, kwargs=None, **options, group_index=None):\n```",
      "comment_id": 2390871908,
      "user": "Copilot",
      "created_at": "2025-09-30T10:49:23Z",
      "url": "https://github.com/celery/celery/pull/9910#discussion_r2390871908"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9910,
      "file_path": "celery/canvas.py",
      "line": 1744,
      "side": "RIGHT",
      "diff_hunk": "@@ -1741,7 +1741,7 @@ def _prepared(self, tasks, partial_args, group_id, root_id, app,\n \n     def _apply_tasks(self, tasks, producer=None, app=None, p=None,\n                      add_to_parent=None, chord=None,\n-                     args=None, kwargs=None, **options):\n+                     args=None, kwargs=None, group_index=None, **options):",
      "comment": "This is a syntax error, I will revert the applied changes",
      "comment_id": 2399227563,
      "user": "simonepozzoli-pix4d",
      "created_at": "2025-10-02T15:29:48Z",
      "url": "https://github.com/celery/celery/pull/9910#discussion_r2399227563"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "celery/fixups/django.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -119,9 +124,9 @@ def _now(self) -> datetime:\n class DjangoWorkerFixup:\n     _db_recycles = 0\n \n-    def __init__(self, app: \"Celery\") -> None:\n+    def __init__(self, app: \"Celery\", worker: \"WorkController\") -> None:\n         self.app = app\n-        self.db_reuse_max = self.app.conf.get('CELERY_DB_REUSE_MAX', None)\n+        self.worker = worker",
      "comment": "The removal of the `self.db_reuse_max` assignment in `__init__` appears to be unintentional, as it's still referenced in the `close_database` method at lines 199 and 201. This will cause an `AttributeError` when `close_database` is called. Is this intended?\n- If yes: The `db_reuse_max` attribute needs to be set somewhere (perhaps as a property that reads from `self.app.conf.get('CELERY_DB_REUSE_MAX', None)`), or the logic in `close_database` needs to be updated.\n- If no: Should we restore the line `self.db_reuse_max = self.app.conf.get('CELERY_DB_REUSE_MAX', None)` after line 129?",
      "comment_id": 2616204636,
      "user": "Copilot",
      "created_at": "2025-12-13T09:49:20Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2616204636"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "celery/fixups/django.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -119,9 +124,9 @@ def _now(self) -> datetime:\n class DjangoWorkerFixup:\n     _db_recycles = 0\n \n-    def __init__(self, app: \"Celery\") -> None:\n+    def __init__(self, app: \"Celery\", worker: \"WorkController\") -> None:",
      "comment": "This appears to be a backward-compatibility breaking change: the `DjangoWorkerFixup.__init__` signature now requires a `worker` parameter. Is this intended?\n- If yes: Could we add migration guidance in the PR description and docs (versionchanged::), and consider a compatibility approach (e.g., making `worker` optional with a default of `None` and handling that case gracefully) through the next major version?\n- If no: Should we make the `worker` parameter optional to maintain backward compatibility with existing code that instantiates `DjangoWorkerFixup` directly?",
      "comment_id": 2616204639,
      "user": "Copilot",
      "created_at": "2025-12-13T09:49:21Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2616204639"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "celery/fixups/django.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,7 +93,7 @@ def install(self) -> \"DjangoFixup\":\n     @property\n     def worker_fixup(self) -> \"DjangoWorkerFixup\":\n         if self._worker_fixup is None:\n-            self._worker_fixup = DjangoWorkerFixup(self.app)\n+            self._worker_fixup = DjangoWorkerFixup(self.app, self.worker)",
      "comment": "The `worker_fixup` property accesses `self.worker` which is `None` until `on_worker_init` is called. However, `on_import_modules` (lines 103-105) calls `self.worker_fixup.validate_models()` before `on_worker_init` has set `self.worker`. This will cause `DjangoWorkerFixup` to be instantiated with `worker=None`, which will lead to an `AttributeError` when line 213 tries to access `self.worker.pool_cls.__module__`. Should we handle the case where `worker` might be `None` in the `worker_fixup` property, or ensure `worker` is set before `on_import_modules` is called?",
      "comment_id": 2616204640,
      "user": "Copilot",
      "created_at": "2025-12-13T09:49:21Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2616204640"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "celery/fixups/django.py",
      "line": 212,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,7 +210,7 @@ def _close_database(self) -> None:\n             # Support Django < 4.1\n             connections = self._db.connections.all()\n \n-        is_prefork = self.app.conf.get('worker_pool', 'prefork') == \"prefork\"\n+        is_prefork = \"prefork\" in self.worker.pool_cls.__module__",
      "comment": "The prefork detection logic `\"prefork\" in self.worker.pool_cls.__module__` assumes `self.worker` is not `None`. However, there are code paths where `worker` could be `None` (e.g., when `worker_fixup` is accessed before `on_worker_init`). Should we add a safety check here, such as `is_prefork = self.worker and \"prefork\" in self.worker.pool_cls.__module__` or ensure `worker` is always set before this code is reached?\n```suggestion\n        is_prefork = self.worker is not None and \"prefork\" in self.worker.pool_cls.__module__\n```",
      "comment_id": 2616204641,
      "user": "Copilot",
      "created_at": "2025-12-13T09:49:21Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2616204641"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "celery/fixups/django.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -65,6 +66,8 @@ def fixup(app: \"Celery\", env: str = 'DJANGO_SETTINGS_MODULE') -> Optional[\"Djang\n class DjangoFixup:\n     \"\"\"Fixup installed when using Django.\"\"\"\n \n+    worker: \"WorkController\" = None\n+\n     def __init__(self, app: \"Celery\"):\n         self.app = app",
      "comment": "The `worker` attribute is defined as a class-level attribute rather than an instance attribute. While this is shadowed when assigned in `on_worker_init` (line 108), it's better practice to initialize it as an instance attribute in `__init__` to avoid potential confusion or unexpected behavior. Consider adding `self.worker: Optional[\"WorkController\"] = None` in the `__init__` method and removing the class-level attribute.\n```suggestion\n\n    def __init__(self, app: \"Celery\"):\n        self.app = app\n        self.worker: Optional[\"WorkController\"] = None\n```",
      "comment_id": 2616204643,
      "user": "Copilot",
      "created_at": "2025-12-13T09:49:21Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2616204643"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "celery/fixups/django.py",
      "line": 212,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,7 +210,7 @@ def _close_database(self) -> None:\n             # Support Django < 4.1\n             connections = self._db.connections.all()\n \n-        is_prefork = self.app.conf.get('worker_pool', 'prefork') == \"prefork\"\n+        is_prefork = \"prefork\" in self.worker.pool_cls.__module__",
      "comment": "Since `DjangoWorkerFixup.__init__` signature has changed to require a `worker` parameter, the new prefork detection behavior on line 213 lacks test coverage. Could we add a focused unit test that verifies the prefork detection works correctly with different pool types (e.g., prefork, threads, gevent)?",
      "comment_id": 2616204644,
      "user": "Copilot",
      "created_at": "2025-12-13T09:49:22Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2616204644"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "celery/fixups/django.py",
      "line": 124,
      "side": "LEFT",
      "diff_hunk": "@@ -119,9 +124,9 @@ def _now(self) -> datetime:\n class DjangoWorkerFixup:\n     _db_recycles = 0\n \n-    def __init__(self, app: \"Celery\") -> None:\n+    def __init__(self, app: \"Celery\", worker: \"WorkController\") -> None:\n         self.app = app\n-        self.db_reuse_max = self.app.conf.get('CELERY_DB_REUSE_MAX', None)",
      "comment": "accident, not intentionally\r\n\r\ni will revert this line change while fixing the tests",
      "comment_id": 2618814595,
      "user": "petrprikryl",
      "created_at": "2025-12-15T10:20:50Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2618814595"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "t/unit/fixups/test_django.py",
      "line": 363,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +339,28 @@ class DJSettings:\n             conn.close.assert_called_once_with()\n             conn.close_pool.assert_not_called()\n \n+    def test_close_database_conn_pool_thread_pool(self):\n+        class DJSettings:\n+            DATABASES = {}\n+\n+        with self.fixup_context(self.app) as (f, _, _):\n+            conn = Mock()\n+            conn.alias = \"default\"\n+            conn.close_pool = Mock()\n+            f._db.connections.all = Mock(return_value=[conn])\n+            f._settings = DJSettings\n+\n+            f._settings.DATABASES[\"default\"] = {\"OPTIONS\": {\"pool\": True}}\n+            f.close_database()\n+            conn.close.assert_called_once_with()\n+            conn.close_pool.assert_called_once_with()\n+\n+            conn.reset_mock()\n+            f.worker.pool_cls = ThreadTaskPool\n+            f.close_database()\n+            conn.close.assert_called_once_with()\n+            conn.close_pool.assert_not_called()",
      "comment": "This test verifies the thread pool behavior by directly setting f.worker.pool_cls = ThreadTaskPool. However, this doesn't test the actual module-based detection logic. The detection uses `\"prefork\" in self.worker.pool_cls.__module__`, so setting pool_cls to ThreadTaskPool class directly works, but it would be more robust to also verify that the __module__ check works correctly.\n\nConsider adding an assertion that verifies ThreadTaskPool.__module__ doesn't contain \"prefork\", to ensure the test is actually exercising the detection logic rather than just the condition branch.",
      "comment_id": 2621573036,
      "user": "Copilot",
      "created_at": "2025-12-16T02:57:51Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2621573036"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "celery/fixups/django.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,6 +103,8 @@ def on_import_modules(self, **kwargs: Any) -> None:\n         self.worker_fixup.validate_models()\n \n     def on_worker_init(self, **kwargs: Any) -> None:\n+        worker: \"WorkController\" = kwargs.get(\"sender\")",
      "comment": "The on_worker_init signal handler retrieves the worker from kwargs but doesn't handle the case where 'sender' might be None or missing. While signals.worker_init.send() at line 127 of worker.py always passes sender=self, it would be more defensive to add error handling here.\n\nConsider adding a check: if worker is None, log a warning or raise an informative error, rather than silently proceeding with a potentially incorrect worker instance from the fallback.\n```suggestion\n        worker: \"WorkController\" = kwargs.get(\"sender\")\n        if worker is None:\n            warnings.warn(\n                \"DjangoFixup.on_worker_init called without a sender (worker instance). \"\n                \"This may indicate a misconfiguration or an internal error.\",\n                FixupWarning,\n                stacklevel=2,\n            )\n            return\n```",
      "comment_id": 2621573049,
      "user": "Copilot",
      "created_at": "2025-12-16T02:57:51Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2621573049"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "t/unit/fixups/test_django.py",
      "line": 176,
      "side": "RIGHT",
      "diff_hunk": "@@ -168,9 +170,10 @@ def test_init(self):\n             assert f\n \n     def test_install(self):\n+        worker = WorkController(self.app)\n         self.app.conf = {'CELERY_DB_REUSE_MAX': None}\n         self.app.loader = Mock()\n-        with self.fixup_context(self.app) as (f, _, _):\n+        with self.fixup_context(self.app, worker=worker) as (f, _, _):",
      "comment": "When creating DjangoWorkerFixup in tests without providing a worker argument, the fallback WorkController(app) will be created. This WorkController initialization has side effects (calls app.loader.init_worker(), sends signals, etc.) that could interfere with test isolation or cause unexpected behavior in tests that don't expect these side effects.\n\nConsider whether tests should explicitly pass a Mock worker instance to avoid these side effects, or document that tests using this fixup need to be aware of WorkController initialization.",
      "comment_id": 2621573054,
      "user": "Copilot",
      "created_at": "2025-12-16T02:57:51Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2621573054"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "celery/fixups/django.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,6 +103,8 @@ def on_import_modules(self, **kwargs: Any) -> None:\n         self.worker_fixup.validate_models()\n \n     def on_worker_init(self, **kwargs: Any) -> None:\n+        worker: \"WorkController\" = kwargs.get(\"sender\")",
      "comment": "Added check with warning to avoid setting `None` as `worker`.",
      "comment_id": 2622640976,
      "user": "petrprikryl",
      "created_at": "2025-12-16T10:11:24Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2622640976"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10023,
      "file_path": "t/unit/fixups/test_django.py",
      "line": 176,
      "side": "RIGHT",
      "diff_hunk": "@@ -168,9 +170,10 @@ def test_init(self):\n             assert f\n \n     def test_install(self):\n+        worker = WorkController(self.app)\n         self.app.conf = {'CELERY_DB_REUSE_MAX': None}\n         self.app.loader = Mock()\n-        with self.fixup_context(self.app) as (f, _, _):\n+        with self.fixup_context(self.app, worker=worker) as (f, _, _):",
      "comment": "Replaced direct usage of `WorkController` with `Mock`.",
      "comment_id": 2622643967,
      "user": "petrprikryl",
      "created_at": "2025-12-16T10:12:16Z",
      "url": "https://github.com/celery/celery/pull/10023#discussion_r2622643967"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10013,
      "file_path": "celery/backends/redis.py",
      "line": 689,
      "side": "RIGHT",
      "diff_hunk": "@@ -683,8 +683,8 @@ def _params_from_url(self, url, defaults):\n         for param in (\"host\", \"port\", \"db\", \"password\"):\n             connparams.pop(param)\n \n-        # Adding db/password in connparams to connect to the correct instance\n-        for param in (\"db\", \"password\"):\n+        # Adding db/password/username in connparams to connect to the correct instance\n+        for param in (\"db\", \"password\", \"username\"):\n             if connparams['hosts'] and param in connparams['hosts'][0]:\n                 connparams[param] = connparams['hosts'][0].get(param)",
      "comment": "This appears to enable Redis Sentinel ACL authentication (username + password), which is user-facing behavior. Should we add documentation updates showing the usage pattern with username in the sentinel URL?\n\nIf yes: Could we add an example in `docs/getting-started/backends-and-brokers/redis.rst` near line 108 (in the Sentinel result backend section) showing:\n```python\napp.conf.result_backend = 'sentinel://myuser:mypass@host:port/db;...'\n```\nand possibly a `versionchanged:: 5.6.1` note mentioning ACL auth support for Sentinel result backends?\n\nIf no: Could you share the rationale for deferring docs, and note where users should look for usage guidance?",
      "comment_id": 2584273590,
      "user": "Copilot",
      "created_at": "2025-12-03T09:17:51Z",
      "url": "https://github.com/celery/celery/pull/10013#discussion_r2584273590"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10013,
      "file_path": "celery/backends/redis.py",
      "line": 689,
      "side": "RIGHT",
      "diff_hunk": "@@ -683,8 +683,8 @@ def _params_from_url(self, url, defaults):\n         for param in (\"host\", \"port\", \"db\", \"password\"):\n             connparams.pop(param)\n \n-        # Adding db/password in connparams to connect to the correct instance\n-        for param in (\"db\", \"password\"):\n+        # Adding db/password/username in connparams to connect to the correct instance\n+        for param in (\"db\", \"password\", \"username\"):\n             if connparams['hosts'] and param in connparams['hosts'][0]:\n                 connparams[param] = connparams['hosts'][0].get(param)",
      "comment": "This is actually a bugfix rather than a new feature. The parent `RedisBackend._params_from_url` method already parses username from URLs, and regular Redis URLs already support ACL authentication with the `username:password@host` format.\r\nThe issue was that `SentinelBackend._params_from_url` was only copying db and password to the top-level connparams, but not username \u2014 so the username was being parsed from the URL but then lost before being passed to the Sentinel connection.\r\nSince users would already expect Sentinel URLs to work the same way as regular Redis URLs (which is the documented behavior), I don't think we need additional documentation for this. The fix just makes Sentinel behave consistently with the existing URL format.",
      "comment_id": 2584286057,
      "user": "anthonykuzmich7",
      "created_at": "2025-12-03T09:21:29Z",
      "url": "https://github.com/celery/celery/pull/10013#discussion_r2584286057"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9911,
      "file_path": "celery/worker/consumer/consumer.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -488,9 +492,10 @@ def ensure_connected(self, conn):\n         def _error_handler(exc, interval, next_step=CONNECTION_RETRY_STEP):\n             if getattr(conn, 'alt', None) and interval == 0:\n                 next_step = CONNECTION_FAILOVER\n+            self.broker_connection_retry_attempt += 1\n             next_step = next_step.format(\n                 when=humanize_seconds(interval, 'in', ' '),\n-                retries=int(interval / 2),\n+                retries=self.broker_connection_retry_attempt,\n                 max_retries=self.app.conf.broker_connection_max_retries)",
      "comment": "The retry counter is incremented on every error, but should this happen before the failover check? If `interval == 0` indicates an immediate failover rather than a retry attempt, incrementing the counter might be misleading for users monitoring retry counts.",
      "comment_id": 2378864348,
      "user": "Copilot",
      "created_at": "2025-09-25T12:06:21Z",
      "url": "https://github.com/celery/celery/pull/9911#discussion_r2378864348"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9911,
      "file_path": "celery/worker/consumer/consumer.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -488,9 +492,10 @@ def ensure_connected(self, conn):\n         def _error_handler(exc, interval, next_step=CONNECTION_RETRY_STEP):\n             if getattr(conn, 'alt', None) and interval == 0:\n                 next_step = CONNECTION_FAILOVER\n+            self.broker_connection_retry_attempt += 1\n             next_step = next_step.format(\n                 when=humanize_seconds(interval, 'in', ' '),\n-                retries=int(interval / 2),\n+                retries=self.broker_connection_retry_attempt,\n                 max_retries=self.app.conf.broker_connection_max_retries)",
      "comment": "can you please cross check this and share your thoughts?",
      "comment_id": 2378872366,
      "user": "auvipy",
      "created_at": "2025-09-25T12:09:38Z",
      "url": "https://github.com/celery/celery/pull/9911#discussion_r2378872366"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9911,
      "file_path": "celery/worker/consumer/consumer.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -488,9 +492,10 @@ def ensure_connected(self, conn):\n         def _error_handler(exc, interval, next_step=CONNECTION_RETRY_STEP):\n             if getattr(conn, 'alt', None) and interval == 0:\n                 next_step = CONNECTION_FAILOVER\n+            self.broker_connection_retry_attempt += 1\n             next_step = next_step.format(\n                 when=humanize_seconds(interval, 'in', ' '),\n-                retries=int(interval / 2),\n+                retries=self.broker_connection_retry_attempt,\n                 max_retries=self.app.conf.broker_connection_max_retries)",
      "comment": "Thanks, fixed retry counter to not increment on failover (to avoid incorrect counts). Added an assert to catch this case. Tested manually as well for the failover case (count starts at 1). \r\n\r\n<img width=\"1067\" height=\"166\" alt=\"Screenshot 2025-09-25 at 10 36 55\u202fPM\" src=\"https://github.com/user-attachments/assets/84e45637-b78d-44b3-9d8e-a76f9c45ea81\" />\r\n\r\n\r\n\r\n ",
      "comment_id": 2380918690,
      "user": "sumo1998",
      "created_at": "2025-09-26T05:37:36Z",
      "url": "https://github.com/celery/celery/pull/9911#discussion_r2380918690"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9911,
      "file_path": "celery/worker/consumer/consumer.py",
      "line": 495,
      "side": "RIGHT",
      "diff_hunk": "@@ -488,9 +492,11 @@ def ensure_connected(self, conn):\n         def _error_handler(exc, interval, next_step=CONNECTION_RETRY_STEP):\n             if getattr(conn, 'alt', None) and interval == 0:\n                 next_step = CONNECTION_FAILOVER\n+            else:",
      "comment": "The retry counter is incremented for all non-failover scenarios, but it should only increment for actual retry attempts. If `interval == 0` without failover alternatives, this might not represent a retry scenario that should be counted.\n```suggestion\n            elif interval > 0:\n```",
      "comment_id": 2384180535,
      "user": "Copilot",
      "created_at": "2025-09-27T14:05:05Z",
      "url": "https://github.com/celery/celery/pull/9911#discussion_r2384180535"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9904,
      "file_path": "celery/backends/database/models.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,14 +10,16 @@\n \n __all__ = ('Task', 'TaskExtended', 'TaskSet')\n \n+DialectSpecificInteger = sa.Integer().with_variant(sa.BigInteger, 'mssql')\n+\n \n class Task(ResultModelBase):\n     \"\"\"Task result/status.\"\"\"\n \n     __tablename__ = 'celery_taskmeta'\n     __table_args__ = {'sqlite_autoincrement': True}\n \n-    id = sa.Column(sa.Integer, sa.Sequence('task_id_sequence'),\n+    id = sa.Column(DialectSpecificInteger, sa.Sequence('task_id_sequence'),",
      "comment": "Yes, it will use different field types for **mssql** only. For other dialects, nothing changes. \r\nWorth mentioning, it appears it was never working for mssql before: celery will crash as soon as it receives the first task.",
      "comment_id": 2366004339,
      "user": "vladborovtsov",
      "created_at": "2025-09-21T07:08:34Z",
      "url": "https://github.com/celery/celery/pull/9904#discussion_r2366004339"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9904,
      "file_path": "celery/backends/database/models.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,14 +10,16 @@\n \n __all__ = ('Task', 'TaskExtended', 'TaskSet')\n \n+DialectSpecificInteger = sa.Integer().with_variant(sa.BigInteger, 'mssql')\n+\n \n class Task(ResultModelBase):\n     \"\"\"Task result/status.\"\"\"\n \n     __tablename__ = 'celery_taskmeta'\n     __table_args__ = {'sqlite_autoincrement': True}\n \n-    id = sa.Column(sa.Integer, sa.Sequence('task_id_sequence'),\n+    id = sa.Column(DialectSpecificInteger, sa.Sequence('task_id_sequence'),",
      "comment": "is it possible to add some unit tests or integration test to verify the change?\r\n",
      "comment_id": 2366103280,
      "user": "auvipy",
      "created_at": "2025-09-21T08:35:31Z",
      "url": "https://github.com/celery/celery/pull/9904#discussion_r2366103280"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9904,
      "file_path": "celery/backends/database/models.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,14 +10,16 @@\n \n __all__ = ('Task', 'TaskExtended', 'TaskSet')\n \n+DialectSpecificInteger = sa.Integer().with_variant(sa.BigInteger, 'mssql')\n+\n \n class Task(ResultModelBase):\n     \"\"\"Task result/status.\"\"\"\n \n     __tablename__ = 'celery_taskmeta'\n     __table_args__ = {'sqlite_autoincrement': True}\n \n-    id = sa.Column(sa.Integer, sa.Sequence('task_id_sequence'),\n+    id = sa.Column(DialectSpecificInteger, sa.Sequence('task_id_sequence'),",
      "comment": "I\u2019m not sure if it\u2019s elegant enough, but see the next commit.\r\n\r\nI also want to mention that the change already partially covered by existing tests: SQLite won\u2019t allow anything other than *integer* for the auto-increment PK column. ",
      "comment_id": 2366157284,
      "user": "vladborovtsov",
      "created_at": "2025-09-21T10:02:57Z",
      "url": "https://github.com/celery/celery/pull/9904#discussion_r2366157284"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9904,
      "file_path": "celery/backends/database/models.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,14 +10,16 @@\n \n __all__ = ('Task', 'TaskExtended', 'TaskSet')\n \n+DialectSpecificInteger = sa.Integer().with_variant(sa.BigInteger, 'mssql')\n+\n \n class Task(ResultModelBase):\n     \"\"\"Task result/status.\"\"\"\n \n     __tablename__ = 'celery_taskmeta'\n     __table_args__ = {'sqlite_autoincrement': True}\n \n-    id = sa.Column(sa.Integer, sa.Sequence('task_id_sequence'),\n+    id = sa.Column(DialectSpecificInteger, sa.Sequence('task_id_sequence'),",
      "comment": "The unit tests are mainly useful to avoid regression if something changes this logic in the future so I think we're g2g, but we can wait for your final approval first @auvipy ",
      "comment_id": 2366220440,
      "user": "Nusnus",
      "created_at": "2025-09-21T13:00:21Z",
      "url": "https://github.com/celery/celery/pull/9904#discussion_r2366220440"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9862,
      "file_path": "celery/utils/time.py",
      "line": 171,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,9 +161,16 @@ def get_timezone(self, zone: str | tzinfo) -> tzinfo:\n         return zone\n \n     @cached_property\n-    def local(self) -> LocalTimezone:\n-        \"\"\"Return LocalTimezone instance for the application.\"\"\"\n-        return LocalTimezone()\n+    def local(self) -> tzinfo:\n+        \"\"\"Return the local system timezone for the application.\"\"\"\n+        try:\n+            timezone = get_localzone()\n+        except Exception as ex:\n+            timezone = None\n+            logger.warning(\"Failed to retrieve local timezone (%s): %s\", type(ex).__name__, ex)\n+        if timezone is None:",
      "comment": "This catches all exceptions broadly when calling `get_localzone()`. Should we be more specific about which exceptions to catch, or document what specific failure scenarios this handles? A broad exception handler could mask unexpected errors that should be surfaced to developers.",
      "comment_id": 2312434930,
      "user": "Copilot",
      "created_at": "2025-08-31T12:17:45Z",
      "url": "https://github.com/celery/celery/pull/9862#discussion_r2312434930"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9862,
      "file_path": "celery/utils/time.py",
      "line": 171,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,9 +161,16 @@ def get_timezone(self, zone: str | tzinfo) -> tzinfo:\n         return zone\n \n     @cached_property\n-    def local(self) -> LocalTimezone:\n-        \"\"\"Return LocalTimezone instance for the application.\"\"\"\n-        return LocalTimezone()\n+    def local(self) -> tzinfo:\n+        \"\"\"Return the local system timezone for the application.\"\"\"\n+        try:\n+            timezone = get_localzone()\n+        except Exception as ex:\n+            timezone = None\n+            logger.warning(\"Failed to retrieve local timezone (%s): %s\", type(ex).__name__, ex)\n+        if timezone is None:",
      "comment": "Several possible exceptions: `ZoneInfoNotFoundError`, `LookupError`, `ValueError`. In addition it could try to access files to get the timezone, depending on the OS, so exceptions could come from that as well. We want `LocalTimezone` to always be the fallback so no value in capturing more specific exceptions.",
      "comment_id": 2312445286,
      "user": "woutdenolf",
      "created_at": "2025-08-31T12:45:54Z",
      "url": "https://github.com/celery/celery/pull/9862#discussion_r2312445286"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9862,
      "file_path": "celery/utils/time.py",
      "line": 171,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,9 +161,16 @@ def get_timezone(self, zone: str | tzinfo) -> tzinfo:\n         return zone\n \n     @cached_property\n-    def local(self) -> LocalTimezone:\n-        \"\"\"Return LocalTimezone instance for the application.\"\"\"\n-        return LocalTimezone()\n+    def local(self) -> tzinfo:\n+        \"\"\"Return the local system timezone for the application.\"\"\"\n+        try:\n+            timezone = get_localzone()\n+        except Exception as ex:\n+            timezone = None\n+            logger.warning(\"Failed to retrieve local timezone (%s): %s\", type(ex).__name__, ex)\n+        if timezone is None:",
      "comment": "> yes please....\r\n\r\nSorry I don't understand. I explained why I capture `Exception` as opposed to more specific exception types in response to the copilot suggestion. This means you agree?",
      "comment_id": 2319335617,
      "user": "woutdenolf",
      "created_at": "2025-09-03T15:24:48Z",
      "url": "https://github.com/celery/celery/pull/9862#discussion_r2319335617"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9879,
      "file_path": "t/unit/backends/test_redis.py",
      "line": 419,
      "side": "RIGHT",
      "diff_hunk": "@@ -397,6 +406,36 @@ def test_username_password_from_redis_conf(self):\n         assert x.connparams['username'] == 'username'\n         assert x.connparams['password'] == 'password'\n \n+    def test_credential_provider_from_redis_conf(self):\n+        self.app.conf.redis_backend_credential_provider = \"redis.CredentialProvider\"\n+        x = self.Backend(app=self.app)\n+\n+        assert x.connparams\n+        assert 'credential_provider' in x.connparams\n+        assert 'username' not in x.connparams\n+        assert 'password' not in x.connparams\n+\n+        # with local credential provider\n+        self.app.conf.redis_backend_credential_provider = MyCredentialProvider()",
      "comment": "The variable `x` is being used without being reassigned after changing the configuration. This test is checking the connparams of the previously created backend instance rather than a new one with the updated credential provider configuration.\n```suggestion\n        self.app.conf.redis_backend_credential_provider = MyCredentialProvider()\n        x = self.Backend(app=self.app)\n```",
      "comment_id": 2337230871,
      "user": "Copilot",
      "created_at": "2025-09-10T16:02:11Z",
      "url": "https://github.com/celery/celery/pull/9879#discussion_r2337230871"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9879,
      "file_path": "t/unit/backends/test_redis.py",
      "line": 430,
      "side": "RIGHT",
      "diff_hunk": "@@ -397,6 +406,36 @@ def test_username_password_from_redis_conf(self):\n         assert x.connparams['username'] == 'username'\n         assert x.connparams['password'] == 'password'\n \n+    def test_credential_provider_from_redis_conf(self):\n+        self.app.conf.redis_backend_credential_provider = \"redis.CredentialProvider\"\n+        x = self.Backend(app=self.app)\n+\n+        assert x.connparams\n+        assert 'credential_provider' in x.connparams\n+        assert 'username' not in x.connparams\n+        assert 'password' not in x.connparams\n+\n+        # with local credential provider\n+        self.app.conf.redis_backend_credential_provider = MyCredentialProvider()\n+        assert x.connparams\n+        assert 'credential_provider' in x.connparams\n+        assert 'username' not in x.connparams\n+        assert 'password' not in x.connparams\n+\n+        # raise ImportError\n+        self.app.conf.redis_backend_credential_provider = \"not_exist.CredentialProvider\"\n+        with pytest.raises(ImportError):\n+            x = self.Backend(app=self.app)\n+            assert x.connparams\n+            assert 'credential_provider' in x.connparams",
      "comment": "The assertions inside the `with pytest.raises(ImportError):` block will never execute because the ImportError is expected to be raised during `self.Backend(app=self.app)`. These assertions should be removed as they are unreachable code.\n```suggestion\n\n```",
      "comment_id": 2337230888,
      "user": "Copilot",
      "created_at": "2025-09-10T16:02:12Z",
      "url": "https://github.com/celery/celery/pull/9879#discussion_r2337230888"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9879,
      "file_path": "t/unit/backends/test_redis.py",
      "line": 437,
      "side": "RIGHT",
      "diff_hunk": "@@ -397,6 +406,36 @@ def test_username_password_from_redis_conf(self):\n         assert x.connparams['username'] == 'username'\n         assert x.connparams['password'] == 'password'\n \n+    def test_credential_provider_from_redis_conf(self):\n+        self.app.conf.redis_backend_credential_provider = \"redis.CredentialProvider\"\n+        x = self.Backend(app=self.app)\n+\n+        assert x.connparams\n+        assert 'credential_provider' in x.connparams\n+        assert 'username' not in x.connparams\n+        assert 'password' not in x.connparams\n+\n+        # with local credential provider\n+        self.app.conf.redis_backend_credential_provider = MyCredentialProvider()\n+        assert x.connparams\n+        assert 'credential_provider' in x.connparams\n+        assert 'username' not in x.connparams\n+        assert 'password' not in x.connparams\n+\n+        # raise ImportError\n+        self.app.conf.redis_backend_credential_provider = \"not_exist.CredentialProvider\"\n+        with pytest.raises(ImportError):\n+            x = self.Backend(app=self.app)\n+            assert x.connparams\n+            assert 'credential_provider' in x.connparams\n+\n+        # raise value Error\n+        self.app.conf.redis_backend_credential_provider = NonCredentialProvider()\n+        with pytest.raises(ValueError):\n+            x = self.Backend(app=self.app)\n+            assert x.connparams\n+            assert 'credential_provider' in x.connparams",
      "comment": "Similar to the ImportError case, these assertions inside the `with pytest.raises(ValueError):` block are unreachable because the ValueError is expected to be raised during backend instantiation.\n```suggestion\n\n```",
      "comment_id": 2337230895,
      "user": "Copilot",
      "created_at": "2025-09-10T16:02:12Z",
      "url": "https://github.com/celery/celery/pull/9879#discussion_r2337230895"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9879,
      "file_path": "t/unit/backends/test_redis.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -424,6 +463,51 @@ def test_url(self):\n         assert x.connparams['socket_timeout'] == 30.0\n         assert x.connparams['socket_connect_timeout'] == 100.0\n \n+    def test_url_with_credential_provider(self):\n+        self.app.conf.redis_socket_timeout = 30.0\n+        self.app.conf.redis_socket_connect_timeout = 100.0\n+        x = self.Backend(\n+            'redis://:bosco@vandelay.com:123/1?credential_provider=redis.CredentialProvider', app=self.app,\n+        )\n+\n+        assert x.connparams\n+        assert x.connparams['host'] == 'vandelay.com'\n+        assert x.connparams['db'] == 1\n+        assert x.connparams['port'] == 123\n+        assert x.connparams['socket_timeout'] == 30.0\n+        assert x.connparams['socket_connect_timeout'] == 100.0\n+        assert isinstance(x.connparams['credential_provider'], CredentialProvider)\n+        assert \"username\" not in x.connparams\n+        assert \"password\" not in x.connparams\n+\n+        # without username and password\n+        x = self.Backend(\n+            'redis://@vandelay.com:123/1?credential_provider=redis.UsernamePasswordCredentialProvider', app=self.app,\n+        )\n+        assert x.connparams\n+        assert x.connparams['host'] == 'vandelay.com'\n+        assert x.connparams['db'] == 1\n+        assert x.connparams['port'] == 123\n+        assert isinstance(x.connparams['credential_provider'], CredentialProvider)\n+\n+        # raise importError\n+        with pytest.raises(ImportError):\n+            x = self.Backend(\n+                'redis://@vandelay.com:123/1?credential_provider=not_exist.CredentialProvider', app=self.app,\n+            )\n+            assert x.connparams\n+            assert 'credential_provider' in x.connparams",
      "comment": "Unreachable assertions after the expected ImportError. These assertions will never execute because the exception is raised during backend instantiation.",
      "comment_id": 2337230902,
      "user": "Copilot",
      "created_at": "2025-09-10T16:02:12Z",
      "url": "https://github.com/celery/celery/pull/9879#discussion_r2337230902"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9879,
      "file_path": "t/unit/backends/test_redis.py",
      "line": 510,
      "side": "RIGHT",
      "diff_hunk": "@@ -424,6 +463,51 @@ def test_url(self):\n         assert x.connparams['socket_timeout'] == 30.0\n         assert x.connparams['socket_connect_timeout'] == 100.0\n \n+    def test_url_with_credential_provider(self):\n+        self.app.conf.redis_socket_timeout = 30.0\n+        self.app.conf.redis_socket_connect_timeout = 100.0\n+        x = self.Backend(\n+            'redis://:bosco@vandelay.com:123/1?credential_provider=redis.CredentialProvider', app=self.app,\n+        )\n+\n+        assert x.connparams\n+        assert x.connparams['host'] == 'vandelay.com'\n+        assert x.connparams['db'] == 1\n+        assert x.connparams['port'] == 123\n+        assert x.connparams['socket_timeout'] == 30.0\n+        assert x.connparams['socket_connect_timeout'] == 100.0\n+        assert isinstance(x.connparams['credential_provider'], CredentialProvider)\n+        assert \"username\" not in x.connparams\n+        assert \"password\" not in x.connparams\n+\n+        # without username and password\n+        x = self.Backend(\n+            'redis://@vandelay.com:123/1?credential_provider=redis.UsernamePasswordCredentialProvider', app=self.app,\n+        )\n+        assert x.connparams\n+        assert x.connparams['host'] == 'vandelay.com'\n+        assert x.connparams['db'] == 1\n+        assert x.connparams['port'] == 123\n+        assert isinstance(x.connparams['credential_provider'], CredentialProvider)\n+\n+        # raise importError\n+        with pytest.raises(ImportError):\n+            x = self.Backend(\n+                'redis://@vandelay.com:123/1?credential_provider=not_exist.CredentialProvider', app=self.app,\n+            )\n+            assert x.connparams\n+            assert 'credential_provider' in x.connparams\n+\n+        # raise valueError\n+        with pytest.raises(ValueError):\n+            # some non-credential provider class\n+            # not ideal but serve purpose\n+            x = self.Backend(\n+                'redis://@vandelay.com:123/1?credential_provider=abc.ABC', app=self.app,\n+            )\n+            assert x.connparams\n+            assert 'credential_provider' in x.connparams\n+",
      "comment": "Unreachable assertions after the expected ValueError. These assertions will never execute because the exception is raised during backend instantiation.\n```suggestion\n\n```",
      "comment_id": 2337230906,
      "user": "Copilot",
      "created_at": "2025-09-10T16:02:12Z",
      "url": "https://github.com/celery/celery/pull/9879#discussion_r2337230906"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10015,
      "file_path": "celery/fixups/django.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,7 +199,7 @@ def close_database(self, **kwargs: Any) -> None:\n         self._db_recycles += 1\n \n     def _close_database(self) -> None:\n-        for conn in self._db.connections.all():\n+        for conn in self._db.connections.all(initialized_only=True):",
      "comment": "The `initialized_only` parameter was added to Django's `ConnectionHandler.all()` in Django 3.1 (August 2020). However, the current codebase supports Django >= 2.2.28 (per requirements/extras/django.txt) and checks for Django >= 1.11 (line 48). Is this intended to be a breaking change requiring Django 3.1+?\n\nIf yes: Should we update the minimum Django version check on line 48 and in requirements/extras/django.txt, add a migration note in the PR description/docs, and document this version requirement change?\n\nIf no: Should we handle this gracefully for older Django versions (e.g., using a try/except or version check to fall back to `connections.all()` without parameters)?",
      "comment_id": 2589761580,
      "user": "Copilot",
      "created_at": "2025-12-04T16:29:44Z",
      "url": "https://github.com/celery/celery/pull/10015#discussion_r2589761580"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10015,
      "file_path": "t/unit/fixups/test_django.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -262,7 +262,7 @@ def test__close_database(self):\n             f.interface_errors = ()\n \n             f._db.connections = Mock()  # ConnectionHandler\n-            f._db.connections.all.side_effect = lambda: conns\n+            f._db.connections.all.side_effect = lambda initialized_only: conns",
      "comment": "The test mock now accepts an `initialized_only` parameter, but several other tests in this file mock `connections.all` without accounting for this new parameter (lines 188, 280, 297, 306, 319). These tests may fail with a TypeError when the actual code calls `connections.all(initialized_only=True)` but the mock doesn't accept the parameter.\n\nShould we update these other test mocks to also accept the parameter, either by:\n- Using `lambda initialized_only=False: conns` pattern\n- Using `Mock(return_value=[conn])` which accepts any arguments by default\n- Using `Mock(side_effect=lambda **kwargs: [conn])`\n\nThe current tests appear to work because Mock objects accept arbitrary arguments, but it would be more explicit and maintainable to handle the parameter consistently across all tests.",
      "comment_id": 2589761615,
      "user": "Copilot",
      "created_at": "2025-12-04T16:29:44Z",
      "url": "https://github.com/celery/celery/pull/10015#discussion_r2589761615"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10015,
      "file_path": "celery/fixups/django.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,7 +199,7 @@ def close_database(self, **kwargs: Any) -> None:\n         self._db_recycles += 1\n \n     def _close_database(self) -> None:\n-        for conn in self._db.connections.all():\n+        for conn in self._db.connections.all(initialized_only=True):",
      "comment": "@auvipy how would you suggest we address this issue? The oldest version of Django that is still being supported by the Django team is 4.2. The previous LTS version was 3.2 which was EOL in April 2024.\r\n\r\nI also notice that the docs state that the django requirement is for informational purposes only and \"You should probably not use this in your requirements, it's here for informational purposes only.\" It also isn't used in any tests.\r\n\r\nFor now I've gone ahead and wrapped the method call in exception handling which seems like the path of least resistance for now.",
      "comment_id": 2597528350,
      "user": "snopoke",
      "created_at": "2025-12-08T08:24:36Z",
      "url": "https://github.com/celery/celery/pull/10015#discussion_r2597528350"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10015,
      "file_path": "celery/fixups/django.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,7 +199,7 @@ def close_database(self, **kwargs: Any) -> None:\n         self._db_recycles += 1\n \n     def _close_database(self) -> None:\n-        for conn in self._db.connections.all():\n+        for conn in self._db.connections.all(initialized_only=True):",
      "comment": "I'm not sure the copilot is correct here. It appears to me that the `initialized_only` parameter was added in 4.1 (see https://github.com/django/django/pull/15490), not 3.1.",
      "comment_id": 2598914689,
      "user": "danlamanna",
      "created_at": "2025-12-08T14:46:31Z",
      "url": "https://github.com/celery/celery/pull/10015#discussion_r2598914689"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10015,
      "file_path": "celery/fixups/django.py",
      "line": 205,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,7 +199,13 @@ def close_database(self, **kwargs: Any) -> None:\n         self._db_recycles += 1\n \n     def _close_database(self) -> None:\n-        for conn in self._db.connections.all():\n+        try:\n+            connections = self._db.connections.all(initialized_only=True)\n+        except TypeError:\n+            # Support Django < 3.1",
      "comment": "```suggestion\n            # Support Django < 4.1\n```",
      "comment_id": 2599196711,
      "user": "auvipy",
      "created_at": "2025-12-08T16:02:21Z",
      "url": "https://github.com/celery/celery/pull/10015#discussion_r2599196711"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,33 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            pass",
      "comment": "The broad exception handler silently suppresses all errors from `hub.fire_timers()`. This could hide important issues during shutdown. Consider logging exceptions at least at debug level to aid troubleshooting:\n\n```python\nexcept Exception as exc:\n    logger.debug('Error firing timers during shutdown: %r', exc)\n```\n\nThis would maintain the robustness (not failing shutdown on timer errors) while providing visibility for debugging.",
      "comment_id": 2506165473,
      "user": "Copilot",
      "created_at": "2025-11-08T04:14:38Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2506165473"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,33 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            pass",
      "comment": "[nitpick] The `time.sleep(0.5)` hardcoded interval may be too frequent or too slow depending on the heartbeat requirements. Could we document why 0.5 seconds was chosen, or consider making it configurable? For reference, heartbeats in `loops.py` use a configurable rate parameter (`hbrate=2.0`).\n\nIf 0.5s is intentional and adequate for all use cases, a brief inline comment explaining the rationale would help future maintainers.\n```suggestion\n                            pass\n                        # 0.5s chosen to balance responsiveness and CPU usage during shutdown;\n                        # matches async heartbeat defaults elsewhere (see loops.py hbrate=2.0).\n```",
      "comment_id": 2506165477,
      "user": "Copilot",
      "created_at": "2025-11-08T04:14:38Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2506165477"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,33 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            pass",
      "comment": "can you please cross check this suggestion? if it is valid or not",
      "comment_id": 2506299361,
      "user": "auvipy",
      "created_at": "2025-11-08T06:08:04Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2506299361"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/worker/consumer/consumer.py",
      "line": 459,
      "side": "LEFT",
      "diff_hunk": "@@ -455,8 +455,6 @@ def on_close(self):\n         # to the current channel.\n         if self.controller and self.controller.semaphore:\n             self.controller.semaphore.clear()\n-        if self.timer:",
      "comment": "should we remove the timer check? can you please explain bit more on this?",
      "comment_id": 2506300043,
      "user": "auvipy",
      "created_at": "2025-11-08T06:08:52Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2506300043"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,33 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            pass",
      "comment": "I agree that it's worth logging any exceptions. I'll add some logging.\r\n\r\n- [x] Add logging of exceptions",
      "comment_id": 2511131528,
      "user": "weetster",
      "created_at": "2025-11-10T16:01:29Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2511131528"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,33 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            pass",
      "comment": "I'll add a comment to explain the choice.\r\n\r\n- [x] Add comment",
      "comment_id": 2511134696,
      "user": "weetster",
      "created_at": "2025-11-10T16:02:31Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2511134696"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/worker/consumer/consumer.py",
      "line": 459,
      "side": "LEFT",
      "diff_hunk": "@@ -455,8 +455,6 @@ def on_close(self):\n         # to the current channel.\n         if self.controller and self.controller.semaphore:\n             self.controller.semaphore.clear()\n-        if self.timer:",
      "comment": "I removed the `timer.clear()` here because the Consumer component shuts down first in the shutdown order. If timers were cleared here, then the Pool and Hub components would not be able to rely on the registered timers while they shut down (after the Consumer shuts down). The Timer component will clean up the registered timers when it shuts down (after Pool and Hub have already shut down).\r\n\r\nJust for reference, I believe the shutdown order is:\r\n\r\n1. Consumer\r\n2. Pool\r\n3. Hub\r\n4. Timer",
      "comment_id": 2511144241,
      "user": "weetster",
      "created_at": "2025-11-10T16:05:37Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2511144241"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "t/integration/test_prefork_shutdown.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+\"\"\"Integration tests for prefork pool shutdown behaviour.\n+\n+These tests verify that the prefork pool gracefully shuts down and maintains\n+heartbeats during the shutdown process, preventing connection loss during\n+worker drain.\n+\"\"\"\n+\n+from time import sleep\n+\n+import pytest\n+\n+from celery.contrib.testing.worker import start_worker\n+from celery.worker import state\n+\n+from .tasks import sleeping\n+\n+TEST_HEARTBEAT = 2\n+LONG_TASK_DURATION = 10  # Exceeds 4-second timeout (2 * 2-second heartbeat)\n+TIMEOUT = LONG_TASK_DURATION * 2\n+\n+\n+@pytest.fixture\n+def heartbeat_worker(celery_session_app):\n+    \"\"\"Worker with short heartbeat for testing purposes.\"\"\"\n+\n+    # Temporarily lower heartbeat for this test\n+    original_heartbeat = celery_session_app.conf.broker_heartbeat\n+    celery_session_app.conf.broker_heartbeat = TEST_HEARTBEAT\n+\n+    original_acks_late = celery_session_app.conf.task_acks_late\n+    celery_session_app.conf.task_acks_late = True\n+\n+    with start_worker(\n+        celery_session_app,\n+        pool=\"prefork\",\n+        without_heartbeat=False,\n+        concurrency=4,\n+        shutdown_timeout=TIMEOUT,\n+        perform_ping_check=False,\n+    ) as worker:\n+        # Verify that low heartbeat is configured correctly\n+        assert worker.consumer.amqheartbeat == TEST_HEARTBEAT\n+\n+        yield worker\n+\n+    celery_session_app.conf.broker_heartbeat = original_heartbeat\n+    celery_session_app.conf.acks_late = original_acks_late\n+\n+\n+class test_prefork_shutdown:\n+    \"\"\"Test prefork shutdown with heartbeat maintenance.\"\"\"\n+\n+    # Test timeout should be longer than worker timeout\n+    @pytest.mark.timeout(timeout=TIMEOUT * 2)\n+    @pytest.mark.usefixtures(\"heartbeat_worker\")\n+    def test_shutdown_with_long_running_tasks(self):\n+        \"\"\"Test that graceful shutdown completes long-running tasks without\n+        connection loss.\n+\n+        This test verifies that when the prefork pool is shutting down with\n+        long-running tasks, heartbeats continue to be sent to maintain the\n+        broker connection.\n+\n+        - Heartbeat frames sent every 3 seconds\n+        - Connection closes after 12 seconds (two missed frames) without heartbeats\n+        - Tasks run 15 seconds to exceed 12-second threshold",
      "comment": "Documentation comment contradicts test values: The docstring states \"Heartbeat frames sent every 3 seconds\" and \"Connection closes after 12 seconds\", but `TEST_HEARTBEAT = 2` (line 17). With a 2-second heartbeat interval, frames are sent approximately every second (heartbeat / rate where rate=2.0), not every 3 seconds. The connection timeout would be approximately 4 seconds (2 * heartbeat), not 12 seconds. Either update the constants or fix the documentation to match.\n```suggestion\n        - Heartbeat frames sent every 2 seconds\n        - Connection closes after 4 seconds (two missed frames) without heartbeats\n        - Tasks run 10 seconds to exceed 4-second threshold\n```",
      "comment_id": 2533829789,
      "user": "Copilot",
      "created_at": "2025-11-17T12:12:42Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2533829789"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "t/integration/test_prefork_shutdown.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+\"\"\"Integration tests for prefork pool shutdown behaviour.\n+\n+These tests verify that the prefork pool gracefully shuts down and maintains\n+heartbeats during the shutdown process, preventing connection loss during\n+worker drain.\n+\"\"\"\n+\n+from time import sleep\n+\n+import pytest\n+\n+from celery.contrib.testing.worker import start_worker\n+from celery.worker import state\n+\n+from .tasks import sleeping\n+\n+TEST_HEARTBEAT = 2\n+LONG_TASK_DURATION = 10  # Exceeds 4-second timeout (2 * 2-second heartbeat)",
      "comment": "[nitpick] Incorrect timeout comment: The comment states \"Exceeds 4-second timeout (2 * 2-second heartbeat)\", but this misrepresents AMQP heartbeat behavior. The broker typically closes connections after missing 2 consecutive heartbeat intervals, which would be approximately 2 * heartbeat seconds. With `TEST_HEARTBEAT = 2`, the connection timeout would be around 4 seconds, but the task duration is 10 seconds, which is more than twice the timeout. The comment should clarify that it's the connection timeout, not just a simple multiplication.\n```suggestion\nLONG_TASK_DURATION = 10  # Exceeds AMQP connection timeout (~4 seconds: broker closes after missing 2 consecutive 2-second heartbeats)\n```",
      "comment_id": 2533829830,
      "user": "Copilot",
      "created_at": "2025-11-17T12:12:42Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2533829830"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 175,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,39 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            logger.warning(\n+                                \"Exception in timer thread during prefork on_stop()\",\n+                                exc_info=True,\n+                            )\n+                        # 0.5 seconds was chosen as a balance between joining quickly\n+                        # after the pool join is complete and sleeping long enough to\n+                        # avoid excessive CPU usage.\n+                        time.sleep(0.5)\n+\n+                timer_thread = threading.Thread(target=fire_timers_loop, daemon=True)\n+                timer_thread.start()\n+\n+                try:\n+                    self._pool.join()\n+                finally:\n+                    shutdown_event.set()\n+                    timer_thread.join(timeout=1.0)",
      "comment": "[nitpick] Timer thread may not terminate cleanly: If `timer_thread.join(timeout=1.0)` times out, the daemon thread continues running. Since it's a daemon thread, it will be forcibly terminated when the process exits, potentially interrupting `hub.fire_timers()` mid-execution. Consider logging a warning if the join times out, or increasing the timeout to ensure cleaner shutdown.\n```suggestion\n                    timer_thread.join(timeout=1.0)\n                    if timer_thread.is_alive():\n                        logger.warning(\n                            \"Timer thread did not terminate cleanly after join(timeout=1.0); \"\n                            \"it may be forcibly killed during process exit, potentially interrupting hub.fire_timers().\"\n                        )\n```",
      "comment_id": 2533829859,
      "user": "Copilot",
      "created_at": "2025-11-17T12:12:43Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2533829859"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,39 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            logger.warning(\n+                                \"Exception in timer thread during prefork on_stop()\",\n+                                exc_info=True,\n+                            )\n+                        # 0.5 seconds was chosen as a balance between joining quickly\n+                        # after the pool join is complete and sleeping long enough to\n+                        # avoid excessive CPU usage.\n+                        time.sleep(0.5)\n+\n+                timer_thread = threading.Thread(target=fire_timers_loop, daemon=True)\n+                timer_thread.start()\n+\n+                try:\n+                    self._pool.join()\n+                finally:\n+                    shutdown_event.set()\n+                    timer_thread.join(timeout=1.0)\n+            else:\n+                self._pool.join()\n+",
      "comment": "This appears to be a user-facing behavior change (continuing to send heartbeats during graceful shutdown). Is this intended?\n- If yes: Should we add docs updates (versionchanged::) in relevant documentation, such as the shutdown behavior section or broker heartbeat documentation? Also, consider adding a brief note in the PR description for whatsnew/changelog.\n- If no: Should we revert or adjust the behavior so it remains consistent until we can introduce a documented change?",
      "comment_id": 2533829876,
      "user": "Copilot",
      "created_at": "2025-11-17T12:12:43Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2533829876"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/worker/loops.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,28 +81,21 @@ def asynloop(obj, connection, consumer, blueprint, hub, qos,\n     hub.propagate_errors = errors\n     loop = hub.create_loop()\n \n-    try:\n-        while blueprint.state == RUN and obj.connection:\n-            state.maybe_shutdown()\n-            if heartbeat_error[0] is not None:\n-                raise heartbeat_error[0]\n-\n-            # We only update QoS when there's no more messages to read.\n-            # This groups together qos calls, and makes sure that remote\n-            # control commands will be prioritized over task messages.\n-            if qos.prev != qos.value:\n-                update_qos()\n-\n-            try:\n-                next(loop)\n-            except StopIteration:\n-                loop = hub.create_loop()\n-    finally:\n+    while blueprint.state == RUN and obj.connection:\n+        state.maybe_shutdown()\n+        if heartbeat_error[0] is not None:\n+            raise heartbeat_error[0]\n+\n+        # We only update QoS when there's no more messages to read.\n+        # This groups together qos calls, and makes sure that remote\n+        # control commands will be prioritized over task messages.\n+        if qos.prev != qos.value:\n+            update_qos()\n+\n         try:\n-            hub.reset()\n-        except Exception as exc:  # pylint: disable=broad-except\n-            logger.exception(\n-                'Error cleaning up after event loop: %r', exc)\n+            next(loop)\n+        except StopIteration:\n+            loop = hub.create_loop()",
      "comment": "This code removes try/finally cleanup that previously called `hub.reset()`. Was that intentional?\n- If yes: Could we add a brief rationale in the commit message or PR description explaining why hub cleanup is no longer needed here, and document where hub cleanup now occurs?\n- If no: Should we keep the cleanup to ensure hub resources are properly released, or ensure cleanup happens elsewhere in the shutdown sequence?",
      "comment_id": 2533829904,
      "user": "Copilot",
      "created_at": "2025-11-17T12:12:44Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2533829904"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "t/integration/test_prefork_shutdown.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+\"\"\"Integration tests for prefork pool shutdown behaviour.\n+\n+These tests verify that the prefork pool gracefully shuts down and maintains\n+heartbeats during the shutdown process, preventing connection loss during\n+worker drain.\n+\"\"\"\n+\n+from time import sleep\n+\n+import pytest\n+\n+from celery.contrib.testing.worker import start_worker\n+from celery.worker import state\n+\n+from .tasks import sleeping\n+\n+TEST_HEARTBEAT = 2\n+LONG_TASK_DURATION = 10  # Exceeds 4-second timeout (2 * 2-second heartbeat)\n+TIMEOUT = LONG_TASK_DURATION * 2\n+\n+\n+@pytest.fixture\n+def heartbeat_worker(celery_session_app):\n+    \"\"\"Worker with short heartbeat for testing purposes.\"\"\"\n+\n+    # Temporarily lower heartbeat for this test\n+    original_heartbeat = celery_session_app.conf.broker_heartbeat\n+    celery_session_app.conf.broker_heartbeat = TEST_HEARTBEAT\n+\n+    original_acks_late = celery_session_app.conf.task_acks_late\n+    celery_session_app.conf.task_acks_late = True\n+\n+    with start_worker(\n+        celery_session_app,\n+        pool=\"prefork\",\n+        without_heartbeat=False,\n+        concurrency=4,\n+        shutdown_timeout=TIMEOUT,\n+        perform_ping_check=False,\n+    ) as worker:\n+        # Verify that low heartbeat is configured correctly\n+        assert worker.consumer.amqheartbeat == TEST_HEARTBEAT\n+\n+        yield worker\n+\n+    celery_session_app.conf.broker_heartbeat = original_heartbeat\n+    celery_session_app.conf.acks_late = original_acks_late",
      "comment": "Configuration attribute mismatch: Line 30 sets `task_acks_late`, but line 47 tries to restore `acks_late`. These are different configuration attributes. Should restore using `celery_session_app.conf.task_acks_late = original_acks_late` for consistency.\n```suggestion\n    celery_session_app.conf.task_acks_late = original_acks_late\n```",
      "comment_id": 2533829925,
      "user": "Copilot",
      "created_at": "2025-11-17T12:12:44Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2533829925"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "t/integration/test_prefork_shutdown.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+\"\"\"Integration tests for prefork pool shutdown behaviour.\n+\n+These tests verify that the prefork pool gracefully shuts down and maintains\n+heartbeats during the shutdown process, preventing connection loss during\n+worker drain.\n+\"\"\"\n+\n+from time import sleep\n+\n+import pytest\n+\n+from celery.contrib.testing.worker import start_worker\n+from celery.worker import state\n+\n+from .tasks import sleeping\n+\n+TEST_HEARTBEAT = 2\n+LONG_TASK_DURATION = 10  # Exceeds 4-second timeout (2 * 2-second heartbeat)\n+TIMEOUT = LONG_TASK_DURATION * 2\n+\n+\n+@pytest.fixture\n+def heartbeat_worker(celery_session_app):\n+    \"\"\"Worker with short heartbeat for testing purposes.\"\"\"\n+\n+    # Temporarily lower heartbeat for this test\n+    original_heartbeat = celery_session_app.conf.broker_heartbeat\n+    celery_session_app.conf.broker_heartbeat = TEST_HEARTBEAT\n+\n+    original_acks_late = celery_session_app.conf.task_acks_late\n+    celery_session_app.conf.task_acks_late = True\n+\n+    with start_worker(\n+        celery_session_app,\n+        pool=\"prefork\",\n+        without_heartbeat=False,\n+        concurrency=4,\n+        shutdown_timeout=TIMEOUT,\n+        perform_ping_check=False,\n+    ) as worker:\n+        # Verify that low heartbeat is configured correctly\n+        assert worker.consumer.amqheartbeat == TEST_HEARTBEAT\n+\n+        yield worker\n+\n+    celery_session_app.conf.broker_heartbeat = original_heartbeat\n+    celery_session_app.conf.acks_late = original_acks_late",
      "comment": "@weetster can you please cross check this and other suggestions?",
      "comment_id": 2533859209,
      "user": "auvipy",
      "created_at": "2025-11-17T12:21:30Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2533859209"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,39 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            logger.warning(\n+                                \"Exception in timer thread during prefork on_stop()\",\n+                                exc_info=True,\n+                            )\n+                        # 0.5 seconds was chosen as a balance between joining quickly\n+                        # after the pool join is complete and sleeping long enough to\n+                        # avoid excessive CPU usage.\n+                        time.sleep(0.5)\n+\n+                timer_thread = threading.Thread(target=fire_timers_loop, daemon=True)\n+                timer_thread.start()\n+\n+                try:\n+                    self._pool.join()\n+                finally:\n+                    shutdown_event.set()\n+                    timer_thread.join(timeout=1.0)\n+            else:\n+                self._pool.join()\n+",
      "comment": "The Celery documentation for shutting down a worker already states \"When shutdown is initiated the worker will finish all currently executing tasks before it actually terminates.\" which is not accurate without the fix in this PR. The fix ensures that tasks really do complete before the worker terminates. A documentation update isn't needed, in my opinion, but we could still add one if maintainers decide that it's necessary.\r\n\r\nhttps://docs.celeryq.dev/en/v5.4.0/userguide/workers.html#stopping-the-worker",
      "comment_id": 2553385860,
      "user": "weetster",
      "created_at": "2025-11-22T22:31:02Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2553385860"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/worker/loops.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,28 +81,21 @@ def asynloop(obj, connection, consumer, blueprint, hub, qos,\n     hub.propagate_errors = errors\n     loop = hub.create_loop()\n \n-    try:\n-        while blueprint.state == RUN and obj.connection:\n-            state.maybe_shutdown()\n-            if heartbeat_error[0] is not None:\n-                raise heartbeat_error[0]\n-\n-            # We only update QoS when there's no more messages to read.\n-            # This groups together qos calls, and makes sure that remote\n-            # control commands will be prioritized over task messages.\n-            if qos.prev != qos.value:\n-                update_qos()\n-\n-            try:\n-                next(loop)\n-            except StopIteration:\n-                loop = hub.create_loop()\n-    finally:\n+    while blueprint.state == RUN and obj.connection:\n+        state.maybe_shutdown()\n+        if heartbeat_error[0] is not None:\n+            raise heartbeat_error[0]\n+\n+        # We only update QoS when there's no more messages to read.\n+        # This groups together qos calls, and makes sure that remote\n+        # control commands will be prioritized over task messages.\n+        if qos.prev != qos.value:\n+            update_qos()\n+\n         try:\n-            hub.reset()\n-        except Exception as exc:  # pylint: disable=broad-except\n-            logger.exception(\n-                'Error cleaning up after event loop: %r', exc)\n+            next(loop)\n+        except StopIteration:\n+            loop = hub.create_loop()",
      "comment": "I wrote a detailed explanation in the original description of this PR that outlines why the removal was necessary. Hub cleanup is handled by the Hub component's shutdown/stop functions and should not be handled by the Consumer component's event loop termination.",
      "comment_id": 2553386695,
      "user": "weetster",
      "created_at": "2025-11-22T22:33:16Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2553386695"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,39 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            logger.warning(\n+                                \"Exception in timer thread during prefork on_stop()\",\n+                                exc_info=True,\n+                            )\n+                        # 0.5 seconds was chosen as a balance between joining quickly\n+                        # after the pool join is complete and sleeping long enough to\n+                        # avoid excessive CPU usage.\n+                        time.sleep(0.5)\n+\n+                timer_thread = threading.Thread(target=fire_timers_loop, daemon=True)\n+                timer_thread.start()\n+\n+                try:\n+                    self._pool.join()\n+                finally:\n+                    shutdown_event.set()\n+                    timer_thread.join(timeout=1.0)\n+            else:\n+                self._pool.join()\n+",
      "comment": "we can rephrase it like it was not working as documented",
      "comment_id": 2553882399,
      "user": "auvipy",
      "created_at": "2025-11-23T08:43:59Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2553882399"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/concurrency/prefork.py",
      "line": 168,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,7 +143,44 @@ def on_stop(self):\n         \"\"\"Gracefully stop the pool.\"\"\"\n         if self._pool is not None and self._pool._state in (RUN, CLOSE):\n             self._pool.close()\n-            self._pool.join()\n+\n+            # Keep firing timers (for heartbeats on async transports) while\n+            # the pool drains. If not using an async transport, no hub exists\n+            # and the timer thread is not created.\n+            hub = get_event_loop()\n+            if hub is not None:\n+                shutdown_event = threading.Event()\n+\n+                def fire_timers_loop():\n+                    while not shutdown_event.is_set():\n+                        try:\n+                            hub.fire_timers()\n+                        except Exception:\n+                            logger.warning(\n+                                \"Exception in timer thread during prefork on_stop()\",\n+                                exc_info=True,\n+                            )\n+                        # 0.5 seconds was chosen as a balance between joining quickly\n+                        # after the pool join is complete and sleeping long enough to\n+                        # avoid excessive CPU usage.\n+                        time.sleep(0.5)\n+\n+                timer_thread = threading.Thread(target=fire_timers_loop, daemon=True)",
      "comment": "[nitpick] Consider adding a descriptive name to the timer thread to aid debugging and observability. Thread names appear in stack traces, debuggers, and monitoring tools, making issues easier to diagnose. For example:\n\n```python\ntimer_thread = threading.Thread(\n    target=fire_timers_loop,\n    daemon=True,\n    name=\"prefork-timer-shutdown\"\n)\n```\n\nThis naming pattern is used elsewhere in the codebase (e.g., `celery/utils/threads.py:44-52`) where threads are given meaningful names.\n```suggestion\n                timer_thread = threading.Thread(\n                    target=fire_timers_loop,\n                    daemon=True,\n                    name=\"prefork-timer-shutdown\"\n                )\n```",
      "comment_id": 2554637869,
      "user": "Copilot",
      "created_at": "2025-11-24T04:48:53Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2554637869"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9986,
      "file_path": "celery/worker/components.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -75,7 +75,9 @@ def create(self, w):\n         return self\n \n     def start(self, w):\n-        pass\n+        # ensure the kombu hub's poller is created (accessing the\n+        # property ensures this)",
      "comment": "[nitpick] The comment states \"ensure the kombu hub's poller is created (accessing the property ensures this)\" but the code assigns the result to a throwaway variable `_`. This is a valid pattern, but could we add clarity by explaining *why* the poller needs to be initialized here?\n\nSince `asynloop()` no longer calls `hub.reset()` during shutdown (removed in this PR), this initialization becomes critical to ensure the poller is ready before the event loop starts. This rationale would help future maintainers understand why this seemingly no-op line is essential.\n\nSuggested enhancement:\n```python\ndef start(self, w):\n    # Ensure the kombu hub's poller is initialized before the event loop starts.\n    # Since asynloop() no longer resets the hub on exit (to preserve timers\n    # during shutdown), we must initialize the poller upfront.\n    _ = w.hub.poller\n```\n```suggestion\n        # Ensure the kombu hub's poller is initialized before the event loop starts.\n        # Since asynloop() no longer resets the hub on exit (to preserve timers\n        # during shutdown), we must initialize the poller upfront.\n```",
      "comment_id": 2554637875,
      "user": "Copilot",
      "created_at": "2025-11-24T04:48:54Z",
      "url": "https://github.com/celery/celery/pull/9986#discussion_r2554637875"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10010,
      "file_path": "celery/contrib/sphinx.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,7 +29,23 @@\n syntax.\n \n Use ``.. autotask::`` to alternatively manually document a task.\n+\n+Sphinx 9.0+ Compatibility",
      "comment": "https://github.com/sphinx-doc/sphinx/releases/tag/v9.0.0 was released while the CI was running and broke some jobs. This enables the backward compatibility flag to revert to the previous behavior: [autodoc_use_legacy_class_based](https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html#confval-autodoc_use_legacy_class_based)",
      "comment_id": 2574173962,
      "user": "Nusnus",
      "created_at": "2025-11-30T16:50:27Z",
      "url": "https://github.com/celery/celery/pull/10010#discussion_r2574173962"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,12 +194,49 @@ def task_message_handler(message, body, ack, reject, callbacks,\n             bucket = get_bucket(task.name)\n \n         if eta and bucket:\n+            # Check if we've reached the ETA task limit\n+            if eta_task_limit is not None and eta_task_count >= eta_task_limit:\n+                info(\"ETA task limit reached (%s/%s), rejecting task %s\",\n+                     eta_task_count, eta_task_limit, req.id)\n+                req.reject(requeue=True)\n+                return\n+\n+            # Track the ETA task\n+            nonlocal eta_task_count\n+            eta_task_count += 1\n+\n             consumer.qos.increment_eventually()\n-            return call_at(eta, limit_post_eta, (req, bucket, 1),\n+\n+            # Define a callback to decrement the counter when the task is executed\n+            def eta_callback(*args):\n+                nonlocal eta_task_count\n+                eta_task_count = max(0, eta_task_count - 1)\n+                return limit_post_eta(*args)\n+\n+            return call_at(eta, eta_callback, (req, bucket, 1),\n                            priority=6)\n+\n         if eta:\n+            # Check if we've reached the ETA task limit\n+            if eta_task_limit is not None and eta_task_count >= eta_task_limit:\n+                info(\"ETA task limit reached (%s/%s), rejecting task %s\",\n+                     eta_task_count, eta_task_limit, req.id)\n+                req.reject(requeue=True)\n+                return\n+\n+            # Track the ETA task\n+            nonlocal eta_task_count\n+            eta_task_count += 1\n+\n             consumer.qos.increment_eventually()\n-            call_at(eta, apply_eta_task, (req,), priority=6)\n+\n+            # Define a callback to decrement the counter when the task is executed\n+            def eta_callback(*args):\n+                nonlocal eta_task_count\n+                eta_task_count = max(0, eta_task_count - 1)\n+                return apply_eta_task(*args)\n+\n+            call_at(eta, eta_callback, (req,), priority=6)",
      "comment": "The eta_task_count increment and limit check logic is duplicated in two places (lines 198-208 and 221-231). Consider extracting this into a helper function to reduce code duplication and improve maintainability.",
      "comment_id": 2262781882,
      "user": "Copilot",
      "created_at": "2025-08-08T12:05:40Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2262781882"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 213,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,12 +194,49 @@ def task_message_handler(message, body, ack, reject, callbacks,\n             bucket = get_bucket(task.name)\n \n         if eta and bucket:\n+            # Check if we've reached the ETA task limit\n+            if eta_task_limit is not None and eta_task_count >= eta_task_limit:\n+                info(\"ETA task limit reached (%s/%s), rejecting task %s\",\n+                     eta_task_count, eta_task_limit, req.id)\n+                req.reject(requeue=True)\n+                return\n+\n+            # Track the ETA task\n+            nonlocal eta_task_count\n+            eta_task_count += 1\n+\n             consumer.qos.increment_eventually()\n-            return call_at(eta, limit_post_eta, (req, bucket, 1),\n+\n+            # Define a callback to decrement the counter when the task is executed\n+            def eta_callback(*args):\n+                nonlocal eta_task_count\n+                eta_task_count = max(0, eta_task_count - 1)",
      "comment": "Using max(0, eta_task_count - 1) could mask bugs where the counter goes negative. If the counter becomes negative, it indicates a logic error that should be addressed rather than silently corrected. Consider using a simple decrement with logging if it goes below zero for debugging purposes.\n```suggestion\n                eta_task_count -= 1\n                if eta_task_count < 0:\n                    logger.warning(\n                        \"eta_task_count went negative (%d) after decrement in eta_callback for task %r\",\n                        eta_task_count, getattr(req, 'id', None)\n                    )\n```",
      "comment_id": 2262781891,
      "user": "Copilot",
      "created_at": "2025-08-08T12:05:41Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2262781891"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -128,6 +129,31 @@ def default(task, app, consumer,\n     Req = create_request_cls(Request, task, consumer.pool, hostname, eventer, app=app)\n \n     revoked_tasks = consumer.controller.state.revoked\n+    eta_task_limit = getattr(app.conf, 'worker_eta_task_limit', None)\n+\n+    class ETATaskTracker:\n+        \"\"\"Track ETA tasks to enforce limits.\"\"\"\n+        def __init__(self):\n+            self.count = 0",
      "comment": "Couldn't we use kombu's native prefetch count tracking for this , and cap the count there , instead of maintaining another count in celery?  I am not very familiar with celery's code base but I wonder if that would be a cleaner approach ?\r\n\r\n[here](https://github.com/celery/kombu/blob/v5.5.4/kombu/common.py#L402) is where it is maintained in kombu.",
      "comment_id": 2264631446,
      "user": "AyoubOm",
      "created_at": "2025-08-09T09:29:27Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2264631446"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -128,6 +129,31 @@ def default(task, app, consumer,\n     Req = create_request_cls(Request, task, consumer.pool, hostname, eventer, app=app)\n \n     revoked_tasks = consumer.controller.state.revoked\n+    eta_task_limit = getattr(app.conf, 'worker_eta_task_limit', None)\n+\n+    class ETATaskTracker:\n+        \"\"\"Track ETA tasks to enforce limits.\"\"\"\n+        def __init__(self):\n+            self.count = 0\n+\n+        def check_limit(self, req):\n+            if eta_task_limit is not None and self.count >= eta_task_limit:\n+                info(\"ETA task limit reached (%s/%s), rejecting task %s\",\n+                     self.count, eta_task_limit, req.id)\n+                req.reject(requeue=True)",
      "comment": "Does this mean that we check the count after fetching a task ? If so, why don't we check the count before task fetching  ? Because otherwise, we may have lot of tasks going from the queue to the worker then from the worker back to the queue without any processing, it could be some waste of the network ?",
      "comment_id": 2264632325,
      "user": "AyoubOm",
      "created_at": "2025-08-09T09:32:57Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2264632325"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,12 +217,27 @@ def task_message_handler(message, body, ack, reject, callbacks,\n             bucket = get_bucket(task.name)\n \n         if eta and bucket:\n+            # Check if we've reached the ETA task limit\n+            if eta_tracker.check_limit(req):",
      "comment": "I think if we cap the prefetch count from kombu directly, we wouldn't need this change. It will be automatically handled by `consumer.qos.increment_eventually()`, which won't increment the count when it reaches the limit. Just sharing my investigation results when I was debugging that issue.",
      "comment_id": 2264634746,
      "user": "AyoubOm",
      "created_at": "2025-08-09T09:41:44Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2264634746"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -128,6 +129,31 @@ def default(task, app, consumer,\n     Req = create_request_cls(Request, task, consumer.pool, hostname, eventer, app=app)\n \n     revoked_tasks = consumer.controller.state.revoked\n+    eta_task_limit = getattr(app.conf, 'worker_eta_task_limit', None)\n+\n+    class ETATaskTracker:\n+        \"\"\"Track ETA tasks to enforce limits.\"\"\"\n+        def __init__(self):\n+            self.count = 0",
      "comment": "you're right here, there is no need to maintain separate counter, while we can use the counter internally being maintained by qos",
      "comment_id": 2264687954,
      "user": "sashu2310",
      "created_at": "2025-08-09T12:19:47Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2264687954"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,12 +217,27 @@ def task_message_handler(message, body, ack, reject, callbacks,\n             bucket = get_bucket(task.name)\n \n         if eta and bucket:\n+            # Check if we've reached the ETA task limit\n+            if eta_tracker.check_limit(req):",
      "comment": "thanks for pointing towards the right strategy to cap the worker from prefetching excessive tasks with eta, if some limit is configured. Have pushed the updated strategy with unit tests.",
      "comment_id": 2264701219,
      "user": "sashu2310",
      "created_at": "2025-08-09T13:04:03Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2264701219"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,34 +124,18 @@ def default(task, app, consumer,\n     limit_task = consumer._limit_task\n     limit_post_eta = consumer._limit_post_eta\n     Request = symbol_by_name(task.Request)\n-    Req = create_request_cls(Request, task, consumer.pool, hostname, eventer, app=app)\n+    Req = create_request_cls(Request, task, consumer.pool, hostname, eventer,\n+                             app=app)\n \n     revoked_tasks = consumer.controller.state.revoked\n     eta_task_limit = getattr(app.conf, 'worker_eta_task_limit', None)\n \n-    class ETATaskTracker:\n-        \"\"\"Track ETA tasks to enforce limits.\"\"\"\n-        def __init__(self):\n-            self.count = 0\n-\n-        def check_limit(self, req):\n-            if eta_task_limit is not None and self.count >= eta_task_limit:\n-                info(\"ETA task limit reached (%s/%s), rejecting task %s\",\n-                     self.count, eta_task_limit, req.id)\n-                req.reject(requeue=True)\n-                return True\n-\n-            self.count += 1\n-            return False\n-\n-        def create_callback(self, req, original_callback):\n-            def eta_callback(*args):\n-                self.count = max(0, self.count - 1)\n-                return original_callback(*args)\n-            eta_callback.__name__ = 'eta_callback'\n-            return eta_callback\n-\n-    eta_tracker = ETATaskTracker()\n+    # Apply ETA task limit to QoS prefetch count if configured\n+    if eta_task_limit is not None:\n+        # Set a maximum prefetch count to limit ETA tasks\n+        original_prefetch = consumer.qos.value\n+        consumer.qos.value = min(original_prefetch, eta_task_limit)\n+        consumer.qos.set(consumer.qos.value)",
      "comment": "Thanks for the quick update ! But are you sure this works ? It seems that this code would be executed only once during the strategy initialization ? But the actual incrementation of prefetch count is done on each task fetching inside `task_message_handler` ([here](https://github.com/celery/celery/blob/v5.5.3/celery/worker/strategy.py#L198) for example). So maybe it should be moved there.\r\n\r\nHowever, I still believe that this should more appear in kombu ? For example when you define the consumer or consumer.qos you would pass it the prefetch limit. And when you call `consumer.qos.increment_eventually()` it would not increment after the limit is reached. The benefit of this approach is that you don't violate the single responsibility principle, and the cap of prefetch count would be transparent here when done in kombu. Basically, you won't need any change here in strategy apart from passing that prefetch limit when you initialize the consumer or consumer.qos whichever is initialized here. ",
      "comment_id": 2264996278,
      "user": "AyoubOm",
      "created_at": "2025-08-09T21:49:51Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2264996278"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,34 +124,18 @@ def default(task, app, consumer,\n     limit_task = consumer._limit_task\n     limit_post_eta = consumer._limit_post_eta\n     Request = symbol_by_name(task.Request)\n-    Req = create_request_cls(Request, task, consumer.pool, hostname, eventer, app=app)\n+    Req = create_request_cls(Request, task, consumer.pool, hostname, eventer,\n+                             app=app)\n \n     revoked_tasks = consumer.controller.state.revoked\n     eta_task_limit = getattr(app.conf, 'worker_eta_task_limit', None)\n \n-    class ETATaskTracker:\n-        \"\"\"Track ETA tasks to enforce limits.\"\"\"\n-        def __init__(self):\n-            self.count = 0\n-\n-        def check_limit(self, req):\n-            if eta_task_limit is not None and self.count >= eta_task_limit:\n-                info(\"ETA task limit reached (%s/%s), rejecting task %s\",\n-                     self.count, eta_task_limit, req.id)\n-                req.reject(requeue=True)\n-                return True\n-\n-            self.count += 1\n-            return False\n-\n-        def create_callback(self, req, original_callback):\n-            def eta_callback(*args):\n-                self.count = max(0, self.count - 1)\n-                return original_callback(*args)\n-            eta_callback.__name__ = 'eta_callback'\n-            return eta_callback\n-\n-    eta_tracker = ETATaskTracker()\n+    # Apply ETA task limit to QoS prefetch count if configured\n+    if eta_task_limit is not None:\n+        # Set a maximum prefetch count to limit ETA tasks\n+        original_prefetch = consumer.qos.value\n+        consumer.qos.value = min(original_prefetch, eta_task_limit)\n+        consumer.qos.set(consumer.qos.value)",
      "comment": "You're absolutely right, I had limited knowledge of the Kombu implementation details. My approach is flawed since increment_eventually bypasses the limit I set during initialisation.\r\nLet me go through the Kombu QoS implementation and come back with a better solution that handles this at the right architectural layer. Meanwhile, I am converting this PR as a draft.",
      "comment_id": 2265125876,
      "user": "sashu2310",
      "created_at": "2025-08-10T05:50:28Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2265125876"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/app/defaults.py",
      "line": 339,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +336,7 @@ def __repr__(self):\n         pool_restarts=Option(False, type='bool'),\n         proc_alive_timeout=Option(4.0, type='float'),\n         prefetch_multiplier=Option(4, type='int'),\n+        worker_eta_task_limit=Option(None, type='int'),",
      "comment": "The worker_eta_task_limit option allows None as a valid value but is typed as 'int'. Consider using type='any' or add validation to handle None explicitly, as this could cause type conversion issues when the configuration is processed.\n```suggestion\n        worker_eta_task_limit=Option(None, type='any'),\n```",
      "comment_id": 2265141427,
      "user": "Copilot",
      "created_at": "2025-08-10T06:49:16Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2265141427"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/app/defaults.py",
      "line": 339,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +336,7 @@ def __repr__(self):\n         pool_restarts=Option(False, type='bool'),\n         proc_alive_timeout=Option(4.0, type='float'),\n         prefetch_multiplier=Option(4, type='int'),\n+        worker_eta_task_limit=Option(None, type='int'),",
      "comment": "The Option class handles this correctly - it doesn't try to convert None values, only non-None values get type conversion",
      "comment_id": 2265145501,
      "user": "sashu2310",
      "created_at": "2025-08-10T07:01:17Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2265145501"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/strategy.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,34 +124,18 @@ def default(task, app, consumer,\n     limit_task = consumer._limit_task\n     limit_post_eta = consumer._limit_post_eta\n     Request = symbol_by_name(task.Request)\n-    Req = create_request_cls(Request, task, consumer.pool, hostname, eventer, app=app)\n+    Req = create_request_cls(Request, task, consumer.pool, hostname, eventer,\n+                             app=app)\n \n     revoked_tasks = consumer.controller.state.revoked\n     eta_task_limit = getattr(app.conf, 'worker_eta_task_limit', None)\n \n-    class ETATaskTracker:\n-        \"\"\"Track ETA tasks to enforce limits.\"\"\"\n-        def __init__(self):\n-            self.count = 0\n-\n-        def check_limit(self, req):\n-            if eta_task_limit is not None and self.count >= eta_task_limit:\n-                info(\"ETA task limit reached (%s/%s), rejecting task %s\",\n-                     self.count, eta_task_limit, req.id)\n-                req.reject(requeue=True)\n-                return True\n-\n-            self.count += 1\n-            return False\n-\n-        def create_callback(self, req, original_callback):\n-            def eta_callback(*args):\n-                self.count = max(0, self.count - 1)\n-                return original_callback(*args)\n-            eta_callback.__name__ = 'eta_callback'\n-            return eta_callback\n-\n-    eta_tracker = ETATaskTracker()\n+    # Apply ETA task limit to QoS prefetch count if configured\n+    if eta_task_limit is not None:\n+        # Set a maximum prefetch count to limit ETA tasks\n+        original_prefetch = consumer.qos.value\n+        consumer.qos.value = min(original_prefetch, eta_task_limit)\n+        consumer.qos.set(consumer.qos.value)",
      "comment": "I have made all the necessary fixes, now we are initialising qos class with worker_eta_limit itself and inside kombu only, we can limit the number of tasks if any limit is given.\r\nPR: https://github.com/celery/kombu/pull/2348",
      "comment_id": 2265148101,
      "user": "sashu2310",
      "created_at": "2025-08-10T07:10:38Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2265148101"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/consumer/tasks.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,7 +46,8 @@ def set_prefetch_count(prefetch_count):\n                 prefetch_count=prefetch_count,\n                 apply_global=qos_global,\n             )\n-        c.qos = QoS(set_prefetch_count, c.initial_prefetch_count)\n+        eta_task_limit = getattr(c.app.conf, 'worker_eta_task_limit', None)",
      "comment": "Can it be accessed as a field `c.app.conf.worker_eta_task_limit` ?",
      "comment_id": 2281852673,
      "user": "AyoubOm",
      "created_at": "2025-08-18T09:34:28Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2281852673"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9853,
      "file_path": "celery/worker/consumer/tasks.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,7 +46,8 @@ def set_prefetch_count(prefetch_count):\n                 prefetch_count=prefetch_count,\n                 apply_global=qos_global,\n             )\n-        c.qos = QoS(set_prefetch_count, c.initial_prefetch_count)\n+        eta_task_limit = getattr(c.app.conf, 'worker_eta_task_limit', None)",
      "comment": "thanks for pointing out this unncessary fallback access, it can be accessed as a field safely, since we have already made sure that it has None, in case no valid value has been passed",
      "comment_id": 2288923095,
      "user": "sashu2310",
      "created_at": "2025-08-20T18:06:50Z",
      "url": "https://github.com/celery/celery/pull/9853#discussion_r2288923095"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/redis.py",
      "line": 134,
      "side": "RIGHT",
      "diff_hunk": "@@ -128,9 +128,9 @@ def reconnect_on_error(self):\n         except self._connection_errors:\n             try:\n                 self._ensure(self._reconnect_pubsub, ())\n-            except self._connection_errors:\n+            except self._connection_errors as e:\n                 logger.critical(E_RETRY_LIMIT_EXCEEDED)\n-                raise\n+                raise RuntimeError(E_RETRY_LIMIT_EXCEEDED) from e",
      "comment": "@Nusnus would you be able to help me understand if a `RuntimeError` is what we'd want to raise here, or if there's a more specific exception available to us in Python (in general), or in this repository (perhaps there's an error class that we'd want to subclass) that we can raise here that clients waiting for task results can more easily capture and handle?",
      "comment_id": 1809715872,
      "user": "linusphan",
      "created_at": "2024-10-22T01:17:07Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r1809715872"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,23 +83,37 @@ def _send_drain_complete_event(self):\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n+        self._mutex = threading.Lock()\n         self._started = threading.Event()\n         self._stopped = threading.Event()\n         self._shutdown = threading.Event()\n         self._create_drain_complete_event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n-            try:\n-                self.result_consumer.drain_events(timeout=1)\n-                self._send_drain_complete_event()\n-                self._create_drain_complete_event()\n-            except socket.timeout:\n-                pass\n-        self._shutdown.set()\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                    self._create_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            with self._mutex:\n+                self._exc = e\n+        finally:\n+            self._shutdown.set()\n \n     def start(self):\n+        if self._shutdown.is_set():\n+            with self._mutex:\n+                if self._exc is not None:\n+                    raise self._exc\n+                else:\n+                    raise Exception(E_CELERY_RESTART_REQUIRED)",
      "comment": "Also an open question here: do we want to tell clients that they need to restart the celery app, or would we rather attempt to restart the greenlet run loop within celery if the greenlet is forced to exit from unhandled exceptions?",
      "comment_id": 1809721087,
      "user": "linusphan",
      "created_at": "2024-10-22T01:26:14Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r1809721087"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/redis.py",
      "line": 134,
      "side": "RIGHT",
      "diff_hunk": "@@ -128,9 +128,9 @@ def reconnect_on_error(self):\n         except self._connection_errors:\n             try:\n                 self._ensure(self._reconnect_pubsub, ())\n-            except self._connection_errors:\n+            except self._connection_errors as e:\n                 logger.critical(E_RETRY_LIMIT_EXCEEDED)\n-                raise\n+                raise RuntimeError(E_RETRY_LIMIT_EXCEEDED) from e",
      "comment": "To add a bit more context -- previously, this error (`e`) was being raised on the green thread, causing it to exit, but that error was never checked/propagated to the main/calling thread.\r\n\r\nThe change in this PR now propagates any errors raised from `result_consumer.drain_events` on the green thread to the calling thread, so this error would now be exposed to end-users in the event that redis max retries are reached.  \r\n\r\nThe reason we're opting to throw a new error here is to provide the end-user with the error message:\r\n\r\n```\r\nRetry limit exceeded while trying to reconnect to the Celery redis result store backend. \r\nThe Celery application must be restarted.\r\n```\r\n\r\nWithout this change, we would be throwing a `ConnectionError`, and the message would be lacking the context on the action the user (or app) needs to take to restore service. We're under the impression `ConnectionError` implies the error may be transient and could \"fix itself\" given time.  \r\n\r\nThat said, `RuntimeError` feels generic/too broad for the app to catch and enter a graceful shutdown on, but we're not sure how the celery project feels about creating/exporting their own errors for this situation.",
      "comment_id": 1815464454,
      "user": "mothershipper",
      "created_at": "2024-10-24T17:31:29Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r1815464454"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,11 +13,36 @@\n from celery.exceptions import TimeoutError\n from celery.utils.threads import THREAD_TIMEOUT_MAX\n \n+E_CELERY_RESTART_REQUIRED = \"\"\"\n+Celery must be restarted because a shutdown signal was detected.\n+\"\"\"",
      "comment": "The `E_CELERY_RESTART_REQUIRED` constant starts with a leading newline, which will produce an empty first line in the error output; remove the leading newline for cleaner messages.\n```suggestion\nE_CELERY_RESTART_REQUIRED = \"Celery must be restarted because a shutdown signal was detected.\"\n```",
      "comment_id": 2196800690,
      "user": "Copilot",
      "created_at": "2025-07-10T07:06:00Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2196800690"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +87,68 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n-            try:\n-                self.result_consumer.drain_events(timeout=1)\n-                self._send_drain_complete_event()\n-                self._create_drain_complete_event()\n-            except socket.timeout:\n-                pass\n-        self._shutdown.set()\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e\n+            raise\n+        finally:\n+            self._send_drain_complete_event()\n+            self._shutdown.set()",
      "comment": "`self._shutdown.set()` is placed outside the `finally` block and won\u2019t run if an exception is raised in `run()`, potentially leaving the drainer in an inconsistent state. Move it inside the `finally` to guarantee it always executes.\n```suggestion\n            try:\n                self._shutdown.set()\n            except Exception:\n                pass\n```",
      "comment_id": 2196800709,
      "user": "Copilot",
      "created_at": "2025-07-10T07:06:00Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2196800709"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,71 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e",
      "comment": "The _exc attribute is being accessed from multiple threads/greenlets without synchronization. Consider using a lock or atomic operation to prevent race conditions when setting and reading this exception state.",
      "comment_id": 2197407643,
      "user": "Copilot",
      "created_at": "2025-07-10T11:08:30Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2197407643"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,71 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e\n+            raise\n+        finally:\n+            self._send_drain_complete_event()\n             try:\n-                self.result_consumer.drain_events(timeout=1)\n-                self._send_drain_complete_event()\n-                self._create_drain_complete_event()\n-            except socket.timeout:\n+                self._shutdown.set()\n+            except Exception:\n                 pass\n-        self._shutdown.set()\n \n     def start(self):\n+        if self._shutdown.is_set():\n+            if self._exc is not None:\n+                raise self._exc\n+            else:\n+                raise Exception(E_CELERY_RESTART_REQUIRED)\n+\n         if not self._started.is_set():\n             self._g = self.spawn(self.run)\n             self._started.wait()\n \n     def stop(self):\n         self._stopped.set()\n-        self._send_drain_complete_event()\n         self._shutdown.wait(THREAD_TIMEOUT_MAX)\n \n     def wait_for(self, p, wait, timeout=None):\n         self.start()\n         if not p.ready:\n             self._drain_complete_event.wait(timeout=timeout)\n \n+            if self._exc is not None:",
      "comment": "The _exc attribute is being read without synchronization while it could be modified by another greenlet in the run() method. This could lead to race conditions or inconsistent state.",
      "comment_id": 2197407656,
      "user": "Copilot",
      "created_at": "2025-07-10T11:08:30Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2197407656"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "t/unit/backends/test_asynchronous.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,7 +212,12 @@ def schedule_thread(self, thread):\n         return g\n \n     def teardown_thread(self, thread):\n-        thread.wait()\n+        try:",
      "comment": "The bare except clause catches all exceptions without specific handling. Consider catching specific exception types or at least logging the ignored exceptions for debugging purposes.",
      "comment_id": 2197407668,
      "user": "Copilot",
      "created_at": "2025-07-10T11:08:30Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2197407668"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,71 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e\n+            raise\n+        finally:\n+            self._send_drain_complete_event()\n             try:\n-                self.result_consumer.drain_events(timeout=1)\n-                self._send_drain_complete_event()\n-                self._create_drain_complete_event()\n-            except socket.timeout:\n+                self._shutdown.set()\n+            except Exception:\n                 pass",
      "comment": "The bare except clause silently ignores all exceptions when setting the shutdown event. Consider logging these exceptions or being more specific about which exceptions to ignore.\n```suggestion\n            except RuntimeError as e:\n                import logging\n                logging.error(f\"Failed to set shutdown event: {e}\")\n```",
      "comment_id": 2197407685,
      "user": "Copilot",
      "created_at": "2025-07-10T11:08:31Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2197407685"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,71 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e",
      "comment": "@linusphan can you please check if this suggestions are valid?",
      "comment_id": 2197413766,
      "user": "auvipy",
      "created_at": "2025-07-10T11:11:32Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2197413766"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,71 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e",
      "comment": "@auvipy Yes, I'll check the suggestions. Thanks for the heads up.",
      "comment_id": 2198736534,
      "user": "linusphan",
      "created_at": "2025-07-10T21:01:23Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2198736534"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,71 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e",
      "comment": "This is addressed in the latest commits. We're using the shutdown event for synchronization, as the only way the `shutdown` flag gets set is if the exception setting line has already executed to completion",
      "comment_id": 2198966658,
      "user": "linusphan",
      "created_at": "2025-07-10T23:15:12Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2198966658"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,71 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e\n+            raise\n+        finally:\n+            self._send_drain_complete_event()\n             try:\n-                self.result_consumer.drain_events(timeout=1)\n-                self._send_drain_complete_event()\n-                self._create_drain_complete_event()\n-            except socket.timeout:\n+                self._shutdown.set()\n+            except Exception:\n                 pass\n-        self._shutdown.set()\n \n     def start(self):\n+        if self._shutdown.is_set():\n+            if self._exc is not None:\n+                raise self._exc\n+            else:\n+                raise Exception(E_CELERY_RESTART_REQUIRED)\n+\n         if not self._started.is_set():\n             self._g = self.spawn(self.run)\n             self._started.wait()\n \n     def stop(self):\n         self._stopped.set()\n-        self._send_drain_complete_event()\n         self._shutdown.wait(THREAD_TIMEOUT_MAX)\n \n     def wait_for(self, p, wait, timeout=None):\n         self.start()\n         if not p.ready:\n             self._drain_complete_event.wait(timeout=timeout)\n \n+            if self._exc is not None:",
      "comment": "This is addressed in the latest commits. The `_shutdown` event will act as synchronization to ensure `_exc` is safely read without race conditions. Also, the drainer only uses one greenlet ata time for the `run()` method. When `_shutdown` is set, we know the greenlet has completed and `_exc` should be in its final state.",
      "comment_id": 2198979160,
      "user": "linusphan",
      "created_at": "2025-07-10T23:21:29Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2198979160"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "t/unit/backends/test_asynchronous.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,7 +212,12 @@ def schedule_thread(self, thread):\n         return g\n \n     def teardown_thread(self, thread):\n-        thread.wait()\n+        try:",
      "comment": "The bare except clause is intentional as eventlet's wait() method will propagate exceptions from the green thread, unlike similar methods in gevent and python's threading library. This keeps the same behavior as the other implementations of teardown_thread for the other drainer tests. Changing this behavior would be a bigger change that is not needed at this time.",
      "comment_id": 2201821124,
      "user": "linusphan",
      "created_at": "2025-07-11T20:50:53Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2201821124"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,82 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e\n+            raise\n+        finally:\n+            self._send_drain_complete_event()\n             try:\n-                self.result_consumer.drain_events(timeout=1)\n-                self._send_drain_complete_event()\n-                self._create_drain_complete_event()\n-            except socket.timeout:\n-                pass\n-        self._shutdown.set()\n+                self._shutdown.set()\n+            except RuntimeError as e:\n+                import logging\n+                logging.error(f\"Failed to set shutdown event: {e}\")\n \n     def start(self):\n+        self._ensure_not_shut_down()\n+\n         if not self._started.is_set():\n             self._g = self.spawn(self.run)\n             self._started.wait()\n \n     def stop(self):\n         self._stopped.set()\n-        self._send_drain_complete_event()\n         self._shutdown.wait(THREAD_TIMEOUT_MAX)\n \n     def wait_for(self, p, wait, timeout=None):\n         self.start()\n         if not p.ready:\n             self._drain_complete_event.wait(timeout=timeout)\n \n+            self._ensure_not_shut_down()\n+\n+    def _ensure_not_shut_down(self):\n+        \"\"\"Currently used to ensure the drainer has not run to completion.\n+\n+        Raises if the shutdown event has been signaled (either due to an exception\n+        or stop() being called).\n+\n+        The _shutdown event acts as synchronization to ensure _exc is properly\n+        set before it is read from, avoiding need for locks.\n+        \"\"\"\n+        if self._shutdown.is_set():\n+            if self._exc is not None:\n+                raise self._exc\n+            else:\n+                raise Exception(E_CELERY_RESTART_REQUIRED)",
      "comment": "[nitpick] Raising a plain `Exception` for a restart\u2010required condition can be hard to distinguish. Consider defining and raising a dedicated exception class (e.g., `CeleryRestartRequired`) to make this control flow explicit.\n```suggestion\n                raise CeleryRestartRequired(E_CELERY_RESTART_REQUIRED)\n```",
      "comment_id": 2202415514,
      "user": "Copilot",
      "created_at": "2025-07-12T07:38:52Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2202415514"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,82 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e\n+            raise\n+        finally:\n+            self._send_drain_complete_event()\n             try:\n-                self.result_consumer.drain_events(timeout=1)\n-                self._send_drain_complete_event()\n-                self._create_drain_complete_event()\n-            except socket.timeout:\n-                pass\n-        self._shutdown.set()\n+                self._shutdown.set()\n+            except RuntimeError as e:\n+                import logging\n+                logging.error(f\"Failed to set shutdown event: {e}\")\n \n     def start(self):\n+        self._ensure_not_shut_down()\n+\n         if not self._started.is_set():\n             self._g = self.spawn(self.run)\n             self._started.wait()\n \n     def stop(self):\n         self._stopped.set()\n-        self._send_drain_complete_event()\n         self._shutdown.wait(THREAD_TIMEOUT_MAX)\n \n     def wait_for(self, p, wait, timeout=None):\n         self.start()\n         if not p.ready:\n             self._drain_complete_event.wait(timeout=timeout)\n \n+            self._ensure_not_shut_down()\n+\n+    def _ensure_not_shut_down(self):\n+        \"\"\"Currently used to ensure the drainer has not run to completion.\n+\n+        Raises if the shutdown event has been signaled (either due to an exception\n+        or stop() being called).\n+\n+        The _shutdown event acts as synchronization to ensure _exc is properly\n+        set before it is read from, avoiding need for locks.\n+        \"\"\"\n+        if self._shutdown.is_set():\n+            if self._exc is not None:\n+                raise self._exc\n+            else:\n+                raise CeleryRestartRequired(E_CELERY_RESTART_REQUIRED)",
      "comment": "```suggestion\r\n                raise Exception(E_CELERY_RESTART_REQUIRED)\r\n```",
      "comment_id": 2203221496,
      "user": "auvipy",
      "created_at": "2025-07-13T07:42:25Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2203221496"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,82 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e\n+            raise\n+        finally:\n+            self._send_drain_complete_event()\n             try:\n-                self.result_consumer.drain_events(timeout=1)\n-                self._send_drain_complete_event()\n-                self._create_drain_complete_event()\n-            except socket.timeout:\n-                pass\n-        self._shutdown.set()\n+                self._shutdown.set()\n+            except RuntimeError as e:\n+                import logging\n+                logging.error(f\"Failed to set shutdown event: {e}\")",
      "comment": "This catch-all exception handling in the finally block could mask important errors. Should we be more specific about which RuntimeError we expect here, or consider re-raising after logging?",
      "comment_id": 2303839525,
      "user": "Copilot",
      "created_at": "2025-08-27T12:50:58Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2303839525"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9371,
      "file_path": "celery/backends/asynchronous.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,53 +85,82 @@ def drain_events_until(self, p, timeout=None, interval=1, on_interval=None, wait\n     def wait_for(self, p, wait, timeout=None):\n         wait(timeout=timeout)\n \n+    def _event(self):\n+        return threading.Event()\n+\n \n class greenletDrainer(Drainer):\n     spawn = None\n+    _exc = None\n     _g = None\n     _drain_complete_event = None    # event, sended (and recreated) after every drain_events iteration\n \n-    def _create_drain_complete_event(self):\n-        \"\"\"create new self._drain_complete_event object\"\"\"\n-        pass\n-\n     def _send_drain_complete_event(self):\n-        \"\"\"raise self._drain_complete_event for wakeup .wait_for\"\"\"\n-        pass\n+        self._drain_complete_event.set()\n+        self._drain_complete_event = self._event()\n \n     def __init__(self, *args, **kwargs):\n         super().__init__(*args, **kwargs)\n-        self._started = threading.Event()\n-        self._stopped = threading.Event()\n-        self._shutdown = threading.Event()\n-        self._create_drain_complete_event()\n+\n+        self._started = self._event()\n+        self._stopped = self._event()\n+        self._shutdown = self._event()\n+        self._drain_complete_event = self._event()\n \n     def run(self):\n         self._started.set()\n-        while not self._stopped.is_set():\n+\n+        try:\n+            while not self._stopped.is_set():\n+                try:\n+                    self.result_consumer.drain_events(timeout=1)\n+                    self._send_drain_complete_event()\n+                except socket.timeout:\n+                    pass\n+        except Exception as e:\n+            self._exc = e\n+            raise\n+        finally:\n+            self._send_drain_complete_event()\n             try:\n-                self.result_consumer.drain_events(timeout=1)\n-                self._send_drain_complete_event()\n-                self._create_drain_complete_event()\n-            except socket.timeout:\n-                pass\n-        self._shutdown.set()\n+                self._shutdown.set()\n+            except RuntimeError as e:\n+                import logging",
      "comment": "The import statement should be moved to the top of the file with other imports rather than importing within the exception handler.\n```suggestion\n\n```",
      "comment_id": 2303839550,
      "user": "Copilot",
      "created_at": "2025-08-27T12:50:59Z",
      "url": "https://github.com/celery/celery/pull/9371#discussion_r2303839550"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9815,
      "file_path": "celery/app/amqp.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -181,7 +193,16 @@ def deselect(self, exclude):\n                 self._consume_from.pop(queue, None)\n \n     def new_missing(self, name):\n-        return Queue(name, self.autoexchange(name), name)\n+        queue_arguments = None\n+        if self.create_missing_queue_type:",
      "comment": "[nitpick] Consider only adding the x-queue-type argument when the type is non-default (e.g. != \"classic\") to avoid declaring redundant arguments for classic queues.\n```suggestion\n        if self.create_missing_queue_type and self.create_missing_queue_type != \"classic\":\n```",
      "comment_id": 2209113932,
      "user": "Copilot",
      "created_at": "2025-07-16T03:07:00Z",
      "url": "https://github.com/celery/celery/pull/9815#discussion_r2209113932"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9815,
      "file_path": "celery/events/receiver.py",
      "line": 68,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,25 +35,39 @@ class EventReceiver(ConsumerMixin):\n \n     def __init__(self, channel, handlers=None, routing_key='#',\n                  node_id=None, app=None, queue_prefix=None,\n-                 accept=None, queue_ttl=None, queue_expires=None):\n+                 accept=None, queue_ttl=None, queue_expires=None,\n+                 queue_exclusive=None,\n+                 queue_durable=None):\n         self.app = app_or_default(app or self.app)\n         self.channel = maybe_channel(channel)\n         self.handlers = {} if handlers is None else handlers\n         self.routing_key = routing_key\n         self.node_id = node_id or uuid()\n-        self.queue_prefix = queue_prefix or self.app.conf.event_queue_prefix\n+        cfg = self.app.conf\n+        self.queue_prefix = queue_prefix or cfg.event_queue_prefix\n         self.exchange = get_exchange(\n             self.connection or self.app.connection_for_write(),\n-            name=self.app.conf.event_exchange)\n+            name=cfg.event_exchange)\n         if queue_ttl is None:\n-            queue_ttl = self.app.conf.event_queue_ttl\n+            queue_ttl = cfg.event_queue_ttl\n         if queue_expires is None:\n-            queue_expires = self.app.conf.event_queue_expires\n+            queue_expires = cfg.event_queue_expires\n+        if queue_exclusive is None:\n+            queue_exclusive = cfg.event_queue_exclusive\n+        if queue_durable is None:\n+            queue_durable = cfg.event_queue_durable\n+        if queue_exclusive and queue_durable:\n+            raise ImproperlyConfigured(\n+                'Queue cannot be both exclusive and durable, '\n+                'choose one or the other.'\n+            )\n         self.queue = Queue(\n             '.'.join([self.queue_prefix, self.node_id]),\n             exchange=self.exchange,\n             routing_key=self.routing_key,\n-            auto_delete=True, durable=False,\n+            auto_delete=True and (not queue_durable),",
      "comment": "The expression 'True and (not queue_durable)' is unnecessarily complex. It can be simplified to 'not queue_durable' since 'True and X' always equals X.\n```suggestion\n            auto_delete=not queue_durable,\n```",
      "comment_id": 2264561581,
      "user": "Copilot",
      "created_at": "2025-08-09T06:56:47Z",
      "url": "https://github.com/celery/celery/pull/9815#discussion_r2264561581"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9815,
      "file_path": "celery/app/amqp.py",
      "line": 273,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,14 +259,18 @@ def create_task_message(self):\n     def send_task_message(self):\n         return self._create_task_sender()\n \n-    def Queues(self, queues, create_missing=None,\n-               autoexchange=None, max_priority=None):\n+    def Queues(self, queues, create_missing=None, create_missing_queue_type=None,\n+               create_missing_queue_exchange_type=None, autoexchange=None, max_priority=None):\n         # Create new :class:`Queues` instance, using queue defaults\n         # from the current configuration.\n         conf = self.app.conf\n         default_routing_key = conf.task_default_routing_key\n         if create_missing is None:\n             create_missing = conf.task_create_missing_queues\n+            if create_missing_queue_type is None:\n+                create_missing_queue_type = conf.task_create_missing_queue_type\n+            if create_missing_queue_exchange_type is None:\n+                create_missing_queue_exchange_type = conf.task_create_missing_queue_exchange_type",
      "comment": "The condition `if create_missing_queue_type is None:` should check `create_missing` instead of being nested inside it. When `create_missing` is False, the queue type parameter should still be respected if explicitly provided.\n```suggestion\n        if create_missing_queue_type is None:\n            create_missing_queue_type = conf.task_create_missing_queue_type\n        if create_missing_queue_exchange_type is None:\n            create_missing_queue_exchange_type = conf.task_create_missing_queue_exchange_type\n```",
      "comment_id": 2265246725,
      "user": "Copilot",
      "created_at": "2025-08-10T11:48:16Z",
      "url": "https://github.com/celery/celery/pull/9815#discussion_r2265246725"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9815,
      "file_path": "celery/app/amqp.py",
      "line": 273,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,14 +259,18 @@ def create_task_message(self):\n     def send_task_message(self):\n         return self._create_task_sender()\n \n-    def Queues(self, queues, create_missing=None,\n-               autoexchange=None, max_priority=None):\n+    def Queues(self, queues, create_missing=None, create_missing_queue_type=None,\n+               create_missing_queue_exchange_type=None, autoexchange=None, max_priority=None):\n         # Create new :class:`Queues` instance, using queue defaults\n         # from the current configuration.\n         conf = self.app.conf\n         default_routing_key = conf.task_default_routing_key\n         if create_missing is None:\n             create_missing = conf.task_create_missing_queues\n+            if create_missing_queue_type is None:\n+                create_missing_queue_type = conf.task_create_missing_queue_type\n+            if create_missing_queue_exchange_type is None:\n+                create_missing_queue_exchange_type = conf.task_create_missing_queue_exchange_type",
      "comment": "Similar to the queue type, this condition should not be nested inside the `create_missing` check. The exchange type parameter should be respected when explicitly provided, regardless of the `create_missing` flag.\n```suggestion\n        if create_missing_queue_exchange_type is None:\n            create_missing_queue_exchange_type = conf.task_create_missing_queue_exchange_type\n```",
      "comment_id": 2265246726,
      "user": "Copilot",
      "created_at": "2025-08-10T11:48:17Z",
      "url": "https://github.com/celery/celery/pull/9815#discussion_r2265246726"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9815,
      "file_path": "celery/app/amqp.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -181,7 +193,16 @@ def deselect(self, exclude):\n                 self._consume_from.pop(queue, None)\n \n     def new_missing(self, name):\n-        return Queue(name, self.autoexchange(name), name)\n+        queue_arguments = None\n+        if self.create_missing_queue_type and self.create_missing_queue_type != \"classic\":",
      "comment": "The hardcoded string \"classic\" should be defined as a constant to improve maintainability and avoid potential typos.\n```suggestion\n        if self.create_missing_queue_type and self.create_missing_queue_type != CLASSIC_QUEUE_TYPE:\n```",
      "comment_id": 2265248298,
      "user": "Copilot",
      "created_at": "2025-08-10T11:52:21Z",
      "url": "https://github.com/celery/celery/pull/9815#discussion_r2265248298"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9815,
      "file_path": "celery/app/amqp.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -181,7 +193,16 @@ def deselect(self, exclude):\n                 self._consume_from.pop(queue, None)\n \n     def new_missing(self, name):\n-        return Queue(name, self.autoexchange(name), name)\n+        queue_arguments = None\n+        if self.create_missing_queue_type and self.create_missing_queue_type != \"classic\":\n+            queue_arguments = {\"x-queue-type\": self.create_missing_queue_type}",
      "comment": "The hardcoded AMQP argument name \"x-queue-type\" should be defined as a constant to improve maintainability.\n```suggestion\n            queue_arguments = {X_QUEUE_TYPE_ARGUMENT: self.create_missing_queue_type}\n```",
      "comment_id": 2265248304,
      "user": "Copilot",
      "created_at": "2025-08-10T11:52:21Z",
      "url": "https://github.com/celery/celery/pull/9815#discussion_r2265248304"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9815,
      "file_path": "celery/app/amqp.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -181,7 +193,16 @@ def deselect(self, exclude):\n                 self._consume_from.pop(queue, None)\n \n     def new_missing(self, name):\n-        return Queue(name, self.autoexchange(name), name)\n+        queue_arguments = None\n+        if self.create_missing_queue_type and self.create_missing_queue_type != \"classic\":",
      "comment": "There's no validation of the `create_missing_queue_type` value. Invalid queue types could cause runtime errors when the broker attempts to declare the queue.\n```suggestion\n        if self.create_missing_queue_type and self.create_missing_queue_type != \"classic\":\n            if self.create_missing_queue_type not in (\"classic\", \"quorum\"):\n                raise ValueError(\n                    f\"Invalid queue type '{self.create_missing_queue_type}'. \"\n                    \"Valid types are 'classic' and 'quorum'.\"\n                )\n```",
      "comment_id": 2265248307,
      "user": "Copilot",
      "created_at": "2025-08-10T11:52:21Z",
      "url": "https://github.com/celery/celery/pull/9815#discussion_r2265248307"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9815,
      "file_path": "celery/events/receiver.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,25 +35,39 @@ class EventReceiver(ConsumerMixin):\n \n     def __init__(self, channel, handlers=None, routing_key='#',\n                  node_id=None, app=None, queue_prefix=None,\n-                 accept=None, queue_ttl=None, queue_expires=None):\n+                 accept=None, queue_ttl=None, queue_expires=None,\n+                 queue_exclusive=None,\n+                 queue_durable=None):\n         self.app = app_or_default(app or self.app)\n         self.channel = maybe_channel(channel)\n         self.handlers = {} if handlers is None else handlers\n         self.routing_key = routing_key\n         self.node_id = node_id or uuid()\n-        self.queue_prefix = queue_prefix or self.app.conf.event_queue_prefix\n+        cfg = self.app.conf",
      "comment": "Tbh I think the full `self.app.conf` should be used instead to make the code cleaner.",
      "comment_id": 2288628141,
      "user": "Nusnus",
      "created_at": "2025-08-20T16:03:28Z",
      "url": "https://github.com/celery/celery/pull/9815#discussion_r2288628141"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9865,
      "file_path": "celery/backends/couchdb.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,4 +96,5 @@ def mget(self, keys):\n         return [self.get(key) for key in keys]\n \n     def delete(self, key):\n+        key = bytes_to_str(key)",
      "comment": "The `bytes_to_str` function is being used but it's not imported. This will result in a NameError when the delete() method is called.",
      "comment_id": 2280250513,
      "user": "Copilot",
      "created_at": "2025-08-16T05:17:10Z",
      "url": "https://github.com/celery/celery/pull/9865#discussion_r2280250513"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9865,
      "file_path": "t/unit/backends/test_couchdb.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,3 +117,96 @@ def test_backend_params_by_url(self):\n             assert x.username == 'johndoe'\n             assert x.password == 'mysecret'\n             assert x.port == 123\n+\n+class CouchSessionMock:\n+    \"\"\"\n+    Mock for `requests.session` that emulates couchdb storage.\n+    \"\"\"\n+\n+    _store = {}\n+\n+    def request(self, method, url, stream=False, data=None, params=None,\n+                 headers=None, **kw):\n+        tid = urlparse(url).path.split(\"/\")[-1]\n+\n+        response = Mock()\n+        response.headers = {\"content-type\": \"application/json\"}\n+        response.status_code = 200\n+        response.content = b''\n+\n+        if method == \"GET\":\n+            if tid not in self._store:\n+                return self._not_found_response()\n+            response.content = self._store.get(tid)\n+        elif method == \"PUT\":\n+            self._store[tid] = data\n+            response.content = str_to_bytes(f'{{\"ok\":true,\"id\":\"{tid}\",\"rev\":\"1-revid\"}}')\n+        elif method == \"HEAD\":\n+            if tid not in self._store:\n+                return self._not_found_response()\n+            response.headers.update({\"etag\": \"1-revid\"})\n+        elif method == \"DELETE\":\n+            if tid not in self._store:\n+                return self._not_found_response()\n+            del self._store[tid]\n+            response.content = str_to_bytes(f'{{\"ok\":true,\"id\":\"{tid}\",\"rev\":\"1-revid\"}}')\n+        else:\n+            raise NotImplemented(f\"CouchSessionMock.request() does not handle {method} method\")",
      "comment": "Should raise `NotImplementedError` instead of `NotImplemented`. `NotImplemented` is a singleton value used for rich comparison methods, while `NotImplementedError` is the proper exception class for unimplemented functionality.\n```suggestion\n            raise NotImplementedError(f\"CouchSessionMock.request() does not handle {method} method\")\n```",
      "comment_id": 2284622636,
      "user": "Copilot",
      "created_at": "2025-08-19T09:05:42Z",
      "url": "https://github.com/celery/celery/pull/9865#discussion_r2284622636"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9865,
      "file_path": "celery/backends/couchdb.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,4 +96,5 @@ def mget(self, keys):\n         return [self.get(key) for key in keys]\n \n     def delete(self, key):\n+        key = bytes_to_str(key)",
      "comment": "> The `bytes_to_str` function is being used but it's not imported. \r\n\r\n`bytes_to_str` is imported here:\r\nhttps://github.com/celery/celery/blob/33eb14852310996b1909c8388cd319809d6c8626/celery/backends/couchdb.py#L2",
      "comment_id": 2285039921,
      "user": "temaxuck",
      "created_at": "2025-08-19T12:04:50Z",
      "url": "https://github.com/celery/celery/pull/9865#discussion_r2285039921"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10000,
      "file_path": "celery/concurrency/asynpool.py",
      "line": 409,
      "side": "RIGHT",
      "diff_hunk": "@@ -406,7 +406,7 @@ def _flush_outqueue(self, fd, remove, process_index, on_state_change):\n             try:\n                 setblocking(reader, 0)\n             except OSError:\n-                return remove(fd)\n+                remove(fd)",
      "comment": "This change removes the `return` inside the `finally` block, which is good for Python 3.14 compatibility. However, other error paths in this function (lines 387, 393, 401) use `return remove(fd)`. Should we verify whether the return value of `remove(fd)` is significant? If `remove(fd)` returns a value that matters to the caller, this change would alter the function's behavior in the error case. If the return value doesn't matter, consider documenting why the finally-block case differs from the other error paths.",
      "comment_id": 2541912308,
      "user": "Copilot",
      "created_at": "2025-11-19T13:02:42Z",
      "url": "https://github.com/celery/celery/pull/10000#discussion_r2541912308"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10000,
      "file_path": "celery/concurrency/asynpool.py",
      "line": 409,
      "side": "RIGHT",
      "diff_hunk": "@@ -406,7 +406,7 @@ def _flush_outqueue(self, fd, remove, process_index, on_state_change):\n             try:\n                 setblocking(reader, 0)\n             except OSError:\n-                return remove(fd)\n+                remove(fd)",
      "comment": "@auvipy nah, you're right to question that... My thought was too simplistic. If you would, you can take a look at my updated suggestion \ud83d\udc4d\ud83c\udffc ",
      "comment_id": 2544725654,
      "user": "torarvid",
      "created_at": "2025-11-20T07:49:10Z",
      "url": "https://github.com/celery/celery/pull/10000#discussion_r2544725654"
    },
    {
      "repo": "celery/celery",
      "pr_number": 10000,
      "file_path": "celery/concurrency/asynpool.py",
      "line": 411,
      "side": "RIGHT",
      "diff_hunk": "@@ -391,22 +391,25 @@ def _flush_outqueue(self, fd, remove, process_index, on_state_change):\n             setblocking(reader, 1)\n         except OSError:\n             return remove(fd)\n+        result = None\n         try:\n             if reader.poll(0):\n                 task = reader.recv()\n             else:\n                 task = None\n                 sleep(0.5)\n         except (OSError, EOFError):\n-            return remove(fd)\n+            result = remove(fd)\n         else:\n             if task:\n                 on_state_change(task)\n         finally:\n             try:\n                 setblocking(reader, 0)\n             except OSError:\n-                return remove(fd)\n+                result = remove(fd)\n+                ",
      "comment": "Trailing whitespace detected on this line. Please remove it.\n```suggestion\n\n```",
      "comment_id": 2545709243,
      "user": "Copilot",
      "created_at": "2025-11-20T11:50:40Z",
      "url": "https://github.com/celery/celery/pull/10000#discussion_r2545709243"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9678,
      "file_path": "t/unit/worker/test_request.py",
      "line": 891,
      "side": "RIGHT",
      "diff_hunk": "@@ -870,6 +870,23 @@ def test_on_failure_task_cancelled(self):\n         job.on_failure(exc_info)\n         assert not job.eventer.send.called\n \n+    def test_on_failure_should_terminate(self):\n+        from celery.worker import state\n+        state.should_terminate = True\n+        job = self.xRequest()\n+        job.send_event = Mock(name='send_event')\n+        job.task.backend = Mock(name='backend')\n+\n+        try:\n+            raise KeyError('foo')\n+        except KeyError:\n+            exc_info = ExceptionInfo()\n+            job.on_failure(exc_info)\n+\n+        job.send_event.assert_not_called()\n+        job.task.backend.mark_as_failure.assert_not_called()\n+        state.should_terminate = None\n+",
      "comment": "Resetting state.should_terminate should be performed in a finally block to ensure the flag is always cleared even if an exception occurs, preventing side effects on subsequent tests.\n```suggestion\n            try:\n                raise KeyError('foo')\n            except KeyError:\n                exc_info = ExceptionInfo()\n                job.on_failure(exc_info)\n\n            job.send_event.assert_not_called()\n            job.task.backend.mark_as_failure.assert_not_called()\n        finally:\n            state.should_terminate = None\n```",
      "comment_id": 2065465171,
      "user": "Copilot",
      "created_at": "2025-04-29T05:11:54Z",
      "url": "https://github.com/celery/celery/pull/9678#discussion_r2065465171"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9678,
      "file_path": "celery/worker/request.py",
      "line": 622,
      "side": "RIGHT",
      "diff_hunk": "@@ -617,6 +619,12 @@ def on_failure(self, exc_info, send_failed_event=True, return_ok=False):\n                 # need to be removed from prefetched local queue\n                 self.reject(requeue=False)\n \n+        # This is a special case where the task failure handing is done during",
      "comment": "Consider correcting 'handing' to 'handling' in the comment for clarity.\n```suggestion\n        # This is a special case where the task failure handling is done during\n```",
      "comment_id": 2065465187,
      "user": "Copilot",
      "created_at": "2025-04-29T05:11:54Z",
      "url": "https://github.com/celery/celery/pull/9678#discussion_r2065465187"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9678,
      "file_path": "celery/worker/request.py",
      "line": 528,
      "side": "RIGHT",
      "diff_hunk": "@@ -525,14 +525,16 @@ def on_timeout(self, soft, timeout):\n                  timeout, self.name, self.id)\n         else:\n             task_ready(self)\n-            error('Hard time limit (%ss) exceeded for %s[%s]',\n-                  timeout, self.name, self.id)\n-            exc = TimeLimitExceeded(timeout)\n-\n-            self.task.backend.mark_as_failure(\n-                self.id, exc, request=self._context,\n-                store_result=self.store_errors,\n-            )\n+            # This is a special case where the task timeout handing is done during",
      "comment": "```suggestion\r\n            # This is a special case where the task timeout handling is done during\r\n```",
      "comment_id": 2065466099,
      "user": "auvipy",
      "created_at": "2025-04-29T05:12:23Z",
      "url": "https://github.com/celery/celery/pull/9678#discussion_r2065466099"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9678,
      "file_path": "celery/worker/request.py",
      "line": 622,
      "side": "RIGHT",
      "diff_hunk": "@@ -617,6 +619,12 @@ def on_failure(self, exc_info, send_failed_event=True, return_ok=False):\n                 # need to be removed from prefetched local queue\n                 self.reject(requeue=False)\n \n+        # This is a special case where the task failure handing is done during",
      "comment": "```suggestion\r\n        # This is a special case where the task failure handling is done during\r\n```",
      "comment_id": 2065467746,
      "user": "auvipy",
      "created_at": "2025-04-29T05:13:44Z",
      "url": "https://github.com/celery/celery/pull/9678#discussion_r2065467746"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9678,
      "file_path": "t/unit/worker/test_request.py",
      "line": 893,
      "side": "RIGHT",
      "diff_hunk": "@@ -870,6 +870,24 @@ def test_on_failure_task_cancelled(self):\n         job.on_failure(exc_info)\n         assert not job.eventer.send.called\n \n+    def test_on_failure_should_terminate(self):\n+        from celery.worker import state\n+        state.should_terminate = True\n+        job = self.xRequest()\n+        job.send_event = Mock(name='send_event')\n+        job.task.backend = Mock(name='backend')\n+\n+        try:\n+            try:\n+                raise KeyError('foo')\n+            except KeyError:\n+                exc_info = ExceptionInfo()\n+                job.on_failure(exc_info)\n+\n+            job.send_event.assert_not_called()\n+            job.task.backend.mark_as_failure.assert_not_called()\n+        finally:\n+            state.should_terminate = None\n     def test_from_message_invalid_kwargs(self):",
      "comment": "```suggestion\r\n\r\n    def test_from_message_invalid_kwargs(self):\r\n```",
      "comment_id": 2065477519,
      "user": "auvipy",
      "created_at": "2025-04-29T05:22:43Z",
      "url": "https://github.com/celery/celery/pull/9678#discussion_r2065477519"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9678,
      "file_path": "t/unit/worker/test_request.py",
      "line": 890,
      "side": "RIGHT",
      "diff_hunk": "@@ -870,6 +870,25 @@ def test_on_failure_task_cancelled(self):\n         job.on_failure(exc_info)\n         assert not job.eventer.send.called\n \n+    def test_on_failure_should_terminate(self):\n+        from celery.worker import state\n+        state.should_terminate = True\n+        job = self.xRequest()\n+        job.send_event = Mock(name='send_event')\n+        job.task.backend = Mock(name='backend')\n+\n+        try:\n+            try:\n+                raise KeyError('foo')\n+            except KeyError:\n+                exc_info = ExceptionInfo()\n+                job.on_failure(exc_info)\n+\n+            job.send_event.assert_not_called()\n+            job.task.backend.mark_as_failure.assert_not_called()\n+        finally:\n+            state.should_terminate = None",
      "comment": "Resetting `should_terminate` to `None` may leave state in an unexpected non-boolean value; consider restoring it to its original boolean (e.g., `False`) or capturing and restoring the pre-test value.\n```suggestion\n            state.should_terminate = original_should_terminate\n```",
      "comment_id": 2181515241,
      "user": "Copilot",
      "created_at": "2025-07-03T03:18:19Z",
      "url": "https://github.com/celery/celery/pull/9678#discussion_r2181515241"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9678,
      "file_path": "t/unit/worker/test_request.py",
      "line": 969,
      "side": "RIGHT",
      "diff_hunk": "@@ -937,6 +956,18 @@ def test_on_soft_timeout(self, patching):\n         job.on_timeout(soft=True, timeout=1336)\n         assert self.mytask.backend.get_status(job.id) == states.PENDING\n \n+    def test_on_timeout_should_terminate(self, patching):\n+        from celery.worker import state\n+        warn = patching('celery.worker.request.warn')\n+        error = patching('celery.worker.request.error')\n+\n+        state.should_terminate = True\n+        job = self.xRequest()\n+        job.on_timeout(None, None)\n+        warn.assert_not_called()\n+        error.assert_not_called()\n+        state.should_terminate = None",
      "comment": "Resetting `should_terminate` to `None` may leave state in an unexpected non-boolean value; consider restoring it to its original boolean (e.g., `False`) or capturing and restoring the pre-test value.\n```suggestion\n        original_should_terminate = state.should_terminate\n        try:\n            state.should_terminate = True\n            job = self.xRequest()\n            job.on_timeout(None, None)\n            warn.assert_not_called()\n            error.assert_not_called()\n        finally:\n            state.should_terminate = original_should_terminate\n```",
      "comment_id": 2181515319,
      "user": "Copilot",
      "created_at": "2025-07-03T03:18:20Z",
      "url": "https://github.com/celery/celery/pull/9678#discussion_r2181515319"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9678,
      "file_path": "t/unit/worker/test_request.py",
      "line": 891,
      "side": "RIGHT",
      "diff_hunk": "@@ -870,6 +870,25 @@ def test_on_failure_task_cancelled(self):\n         job.on_failure(exc_info)\n         assert not job.eventer.send.called\n \n+    def test_on_failure_should_terminate(self):\n+        from celery.worker import state\n+        state.should_terminate = True\n+        job = self.xRequest()\n+        job.send_event = Mock(name='send_event')\n+        job.task.backend = Mock(name='backend')\n+\n+        try:\n+            try:\n+                raise KeyError('foo')\n+            except KeyError:\n+                exc_info = ExceptionInfo()\n+                job.on_failure(exc_info)\n+\n+            job.send_event.assert_not_called()\n+            job.task.backend.mark_as_failure.assert_not_called()\n+        finally:\n+            state.should_terminate = original_should_terminate",
      "comment": "`original_should_terminate` is never initialized before being restored. Capture the previous value of `state.should_terminate` (e.g., `original_should_terminate = state.should_terminate`) before setting it to `True`.",
      "comment_id": 2189011670,
      "user": "Copilot",
      "created_at": "2025-07-07T05:35:20Z",
      "url": "https://github.com/celery/celery/pull/9678#discussion_r2189011670"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9678,
      "file_path": "celery/apps/worker.py",
      "line": 418,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,6 +412,9 @@ def on_cold_shutdown(worker: Worker):\n     # Cancel all unacked requests and allow the worker to terminate naturally\n     worker.consumer.cancel_all_unacked_requests()\n \n+    from celery.worker import state\n+    state.should_terminate = True\n+\n     # Stop the pool to allow successful tasks call on_success()",
      "comment": "[nitpick] The comment \"Stop the pool to allow successful tasks call on_success()\" could be clarified. Successful tasks have already called `on_success()` by this point (which is how they were preserved in `cancel_all_unacked_requests()`). The `pool.stop()` call actually waits for the pool to finish processing and allows any remaining task completion callbacks to finish. Consider updating the comment to: \"Stop the pool and wait for any remaining task completion to finish\" or similar.\n```suggestion\n    # Stop the pool and wait for any remaining task completion to finish\n```",
      "comment_id": 2531973294,
      "user": "Copilot",
      "created_at": "2025-11-16T13:56:14Z",
      "url": "https://github.com/celery/celery/pull/9678#discussion_r2531973294"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9121,
      "file_path": "celery/app/defaults.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -261,6 +261,7 @@ def __repr__(self):\n         inherit_parent_priority=Option(False, type='bool'),\n         default_delivery_mode=Option(2, type='string'),\n         default_queue=Option('celery'),\n+        default_queue_type=Option('classic', type='string'),",
      "comment": "@Nusnus Hey, do you remember why you defaulted to `classic`?",
      "comment_id": 2513797841,
      "user": "ulgens",
      "created_at": "2025-11-11T11:05:36Z",
      "url": "https://github.com/celery/celery/pull/9121#discussion_r2513797841"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9121,
      "file_path": "celery/app/defaults.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -261,6 +261,7 @@ def __repr__(self):\n         inherit_parent_priority=Option(False, type='bool'),\n         default_delivery_mode=Option(2, type='string'),\n         default_queue=Option('celery'),\n+        default_queue_type=Option('classic', type='string'),",
      "comment": "so that the existing deployments dont break. and can be switched in feature gracefully...",
      "comment_id": 2514786331,
      "user": "auvipy",
      "created_at": "2025-11-11T16:00:45Z",
      "url": "https://github.com/celery/celery/pull/9121#discussion_r2514786331"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9121,
      "file_path": "celery/app/defaults.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -261,6 +261,7 @@ def __repr__(self):\n         inherit_parent_priority=Option(False, type='bool'),\n         default_delivery_mode=Option(2, type='string'),\n         default_queue=Option('celery'),\n+        default_queue_type=Option('classic', type='string'),",
      "comment": "I was asking because RabbitMQ's default is quorum, and realized Celery is overriding it. Is there a possibility to deprecate that behaviour gradually?",
      "comment_id": 2514888528,
      "user": "ulgens",
      "created_at": "2025-11-11T16:28:30Z",
      "url": "https://github.com/celery/celery/pull/9121#discussion_r2514888528"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9121,
      "file_path": "celery/app/defaults.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -261,6 +261,7 @@ def __repr__(self):\n         inherit_parent_priority=Option(False, type='bool'),\n         default_delivery_mode=Option(2, type='string'),\n         default_queue=Option('celery'),\n+        default_queue_type=Option('classic', type='string'),",
      "comment": "there are many versions of rabbitmq where qourum is not default",
      "comment_id": 2516671028,
      "user": "auvipy",
      "created_at": "2025-11-12T04:10:51Z",
      "url": "https://github.com/celery/celery/pull/9121#discussion_r2516671028"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9121,
      "file_path": "celery/app/defaults.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -261,6 +261,7 @@ def __repr__(self):\n         inherit_parent_priority=Option(False, type='bool'),\n         default_delivery_mode=Option(2, type='string'),\n         default_queue=Option('celery'),\n+        default_queue_type=Option('classic', type='string'),",
      "comment": "@auvipy I'm missing your point. In past releases, yes. It became the recommended queue type in 2024.",
      "comment_id": 2517433342,
      "user": "ulgens",
      "created_at": "2025-11-12T08:50:26Z",
      "url": "https://github.com/celery/celery/pull/9121#discussion_r2517433342"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9121,
      "file_path": "celery/app/defaults.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -261,6 +261,7 @@ def __repr__(self):\n         inherit_parent_priority=Option(False, type='bool'),\n         default_delivery_mode=Option(2, type='string'),\n         default_queue=Option('celery'),\n+        default_queue_type=Option('classic', type='string'),",
      "comment": "> @auvipy I'm missing your point. In past releases, yes. It became the recommended queue type in 2024.\r\n\r\nit is for legacy celery projects in the wild and enterprise environment. you don't need to worry about it.",
      "comment_id": 2518964846,
      "user": "auvipy",
      "created_at": "2025-11-12T16:21:06Z",
      "url": "https://github.com/celery/celery/pull/9121#discussion_r2518964846"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9121,
      "file_path": "celery/app/defaults.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -261,6 +261,7 @@ def __repr__(self):\n         inherit_parent_priority=Option(False, type='bool'),\n         default_delivery_mode=Option(2, type='string'),\n         default_queue=Option('celery'),\n+        default_queue_type=Option('classic', type='string'),",
      "comment": "I am not sure why you are trying to shut me down but we can do better than this. You don't need respond if you have nothing to share. Thanks for your time tho.\n\n@Nusnus do you have any additional info you can share? Thanks in advance. ",
      "comment_id": 2519107600,
      "user": "ulgens",
      "created_at": "2025-11-12T17:01:10Z",
      "url": "https://github.com/celery/celery/pull/9121#discussion_r2519107600"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9121,
      "file_path": "celery/app/defaults.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -261,6 +261,7 @@ def __repr__(self):\n         inherit_parent_priority=Option(False, type='bool'),\n         default_delivery_mode=Option(2, type='string'),\n         default_queue=Option('celery'),\n+        default_queue_type=Option('classic', type='string'),",
      "comment": "no one is trying to shutting you down. I think you have an understanding problem. or lack of understanding on broader level.",
      "comment_id": 2522381376,
      "user": "auvipy",
      "created_at": "2025-11-13T08:49:43Z",
      "url": "https://github.com/celery/celery/pull/9121#discussion_r2522381376"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -270,6 +286,12 @@ def _log_error(self, task, req, einfo):\n \n \n def traceback_clear(exc=None):",
      "comment": "The `traceback_clear` function initializes `tb` to None and never assigns it. The while loop never executes, so frame clearing never happens. Initialize `tb` to `exc.__traceback__` (or use `sys.exc_info()`) before looping.",
      "comment_id": 2187026346,
      "user": "Copilot",
      "created_at": "2025-07-05T09:42:44Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187026346"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 484,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,18 +480,22 @@ def trace_task(uuid, args, kwargs, request=None):\n                     I, R = Info(REJECTED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_reject(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)",
      "comment": "Calling `traceback_clear(exc)` has no effect because `traceback_clear` doesn\u2019t use the `exc` argument. Fix the helper so it consumes the passed exception or captures its traceback.",
      "comment_id": 2187026347,
      "user": "Copilot",
      "created_at": "2025-07-05T09:42:44Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187026347"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_memory_leak_8882.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,247 @@\n+\"\"\"\n+Integration test for memory leak issue #8882.\n+\n+This test reproduces the memory leak that occurs when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"Get current memory usage in bytes.\"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()",
      "comment": "The fallback to `tracemalloc.get_traced_memory()` may not reflect actual RSS if `psutil` is unavailable. Consider always using `tracemalloc` (with `start`/`clear_traces`) or explicitly documenting this behavior.\n```suggestion\n    \"\"\"Get current memory usage in bytes.\n\n    Uses psutil to get RSS (Resident Set Size) if available.\n    Falls back to tracemalloc for memory tracking if psutil is unavailable.\n    Note: tracemalloc does not provide RSS but tracks Python memory allocations.\n    \"\"\"\n    try:\n        import psutil\n        process = psutil.Process(os.getpid())\n        return process.memory_info().rss\n    except ImportError:\n        # Use tracemalloc for memory tracking\n        tracemalloc.clear_traces()  # Clear previous traces to ensure accurate measurement\n        current, _ = tracemalloc.get_traced_memory()\n```",
      "comment_id": 2187026349,
      "user": "Copilot",
      "created_at": "2025-07-05T09:42:45Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187026349"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_memory_leak_8882.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,247 @@\n+\"\"\"\n+Integration test for memory leak issue #8882.\n+\n+This test reproduces the memory leak that occurs when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"Get current memory usage in bytes.\"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Print memory statistics for debugging\n+    print()  # New line for better readability\n+    print(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"After exceptions: {after_exceptions_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"Final memory: {final_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n+    print(f\"Exceptions processed: {exception_count}\")\n+\n+    # The test should demonstrate a significant memory increase\n+    # This threshold may need adjustment based on the system\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    # Verify the memory leak is fixed - memory increase should be minimal\n+    # Before fix: >70MB for 1000 tasks (~70KB/task)\n+    # After fix: <5MB for 500 tasks (<10KB/task)\n+    assert memory_increase_mb < 5, (\n+        f\"Memory leak still exists! Expected <5MB increase for 500 tasks, \"",
      "comment": "[nitpick] Hardcoded memory thresholds can be flaky across environments. Consider parameterizing or allowing a margin of error (e.g., relative percentage) to reduce test brittleness.\n```suggestion\n    # Parameterized memory threshold and margin of error\n    memory_threshold_mb = float(os.getenv(\"MEMORY_THRESHOLD_MB\", 5))  # Default to 5MB\n    margin_of_error = float(os.getenv(\"MEMORY_MARGIN_PERCENT\", 10)) / 100  # Default to 10%\n    effective_threshold_mb = memory_threshold_mb * (1 + margin_of_error)\n\n    # Verify the memory leak is fixed - memory increase should be minimal\n    assert memory_increase_mb < effective_threshold_mb, (\n        f\"Memory leak still exists! Expected <{effective_threshold_mb:.2f}MB increase for 500 tasks, \"\n```",
      "comment_id": 2187026351,
      "user": "Copilot",
      "created_at": "2025-07-05T09:42:45Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187026351"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -270,6 +286,12 @@ def _log_error(self, task, req, einfo):\n \n \n def traceback_clear(exc=None):",
      "comment": "@jaiganeshs21 what is your thought regarding this suggestion?",
      "comment_id": 2187030554,
      "user": "auvipy",
      "created_at": "2025-07-05T09:51:13Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187030554"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -270,6 +286,12 @@ def _log_error(self, task, req, einfo):\n \n \n def traceback_clear(exc=None):",
      "comment": "The variable `tb` is guaranteed to be assigned before the loop in the conditional at [line 298](https://github.com/celery/celery/pull/9799/files#diff-fb194522c454315cd87ccb1cf4a2a53aafa49124c85abc01dcca4310cf19d6d3R298).\r\n\r\nIf exc has a traceback, we assign it to `tb`; otherwise, we fall back to `sys.exc_info()`. So the loop always has a valid `tb` value.\r\n![image](https://github.com/user-attachments/assets/f405f339-d327-4805-b495-e82d2df5a6ec)\r\n\r\n",
      "comment_id": 2187078854,
      "user": "jaiganeshs21",
      "created_at": "2025-07-05T10:33:12Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187078854"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -270,6 +286,12 @@ def _log_error(self, task, req, einfo):\n \n \n def traceback_clear(exc=None):",
      "comment": "is it possible to increase unit test coverage of this changes as well?",
      "comment_id": 2187083748,
      "user": "auvipy",
      "created_at": "2025-07-05T10:40:14Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187083748"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 484,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,18 +480,22 @@ def trace_task(uuid, args, kwargs, request=None):\n                     I, R = Info(REJECTED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_reject(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)",
      "comment": "Same as this comment https://github.com/celery/celery/pull/9799#discussion_r2187078854:\r\n\r\nThe `traceback_clear` function does use the `exc` argument correctly.  ([traceback_clear fucntion](https://github.com/celery/celery/pull/9799/files#diff-fb194522c454315cd87ccb1cf4a2a53aafa49124c85abc01dcca4310cf19d6d3R298))\r\n\r\nWhen exc is provided, it checks `hasattr(exc, '__traceback__')` and uses `exc.__traceback_`_ if available, otherwise falls back to `sys.exc_info()`.",
      "comment_id": 2187087268,
      "user": "jaiganeshs21",
      "created_at": "2025-07-05T10:44:34Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187087268"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 306,
      "side": "RIGHT",
      "diff_hunk": "@@ -283,8 +305,10 @@ def traceback_clear(exc=None):\n \n     while tb is not None:",
      "comment": "The loop over tb never advances to tb.tb_next, so tb remains unchanged and the loop never terminates. Add `tb = tb.tb_next` at the end of each iteration.",
      "comment_id": 2187103950,
      "user": "Copilot",
      "created_at": "2025-07-05T11:08:27Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187103950"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 229,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,39 +206,54 @@ def handle_retry(self, task, req, store_errors=True, **kwargs):\n                 'name': get_task_name(req, task.name),\n                 'exc': str(reason),\n             })\n+            # Note: We return einfo, so we can't clean it up here\n+            # The calling function is responsible for cleanup\n             return einfo\n         finally:\n-            del tb\n+            # MEMORY LEAK FIX: Clean up direct traceback reference to prevent\n+            # retention of frame objects and their local variables (Issue #8882)\n+            if tb is not None:\n+                del tb\n \n     def handle_failure(self, task, req, store_errors=True, call_errbacks=True):\n         \"\"\"Handle exception.\"\"\"\n         orig_exc = self.retval\n+        tb_ref = None\n \n-        exc = get_pickleable_exception(orig_exc)\n-        if exc.__traceback__ is None:\n-            # `get_pickleable_exception` may have created a new exception without\n-            # a traceback.\n-            _, _, exc.__traceback__ = sys.exc_info()\n-\n-        exc_type = get_pickleable_etype(type(orig_exc))\n-\n-        # make sure we only send pickleable exceptions back to parent.\n-        einfo = ExceptionInfo(exc_info=(exc_type, exc, exc.__traceback__))\n-\n-        task.backend.mark_as_failure(\n-            req.id, exc, einfo.traceback,\n-            request=req, store_result=store_errors,\n-            call_errbacks=call_errbacks,\n-        )\n-\n-        task.on_failure(exc, req.id, req.args, req.kwargs, einfo)\n-        signals.task_failure.send(sender=task, task_id=req.id,\n-                                  exception=exc, args=req.args,\n-                                  kwargs=req.kwargs,\n-                                  traceback=exc.__traceback__,\n-                                  einfo=einfo)\n-        self._log_error(task, req, einfo)\n-        return einfo\n+        try:\n+            exc = get_pickleable_exception(orig_exc)\n+            if exc.__traceback__ is None:\n+                # `get_pickleable_exception` may have created a new exception without\n+                # a traceback.\n+                _, _, tb_ref = sys.exc_info()\n+                exc.__traceback__ = tb_ref",
      "comment": "Deleting the local `tb_ref` does not clear `exc.__traceback__`, so the traceback is still retained. Either set `exc.__traceback__ = None` after use or invoke `traceback_clear(exc.__traceback__)` to fully break the reference cycle.",
      "comment_id": 2187103952,
      "user": "Copilot",
      "created_at": "2025-07-05T11:08:28Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187103952"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 649,
      "side": "RIGHT",
      "diff_hunk": "@@ -607,7 +639,14 @@ def _signal_internal_error(task, uuid, args, kwargs, request, exc):\n             einfo=einfo,\n         )\n     finally:\n-        del tb\n+        # MEMORY LEAK FIX: Clean up local references to prevent memory leaks (Issue #8882)\n+        # Both 'tb' and 'einfo' can hold references to frame objects and their local variables.\n+        # Explicitly clearing these prevents reference cycles that block garbage collection.\n+        if tb is not None:\n+            del tb\n+        if einfo is not None:\n+            # Break potential reference cycles by clearing the einfo object\n+            einfo = None",
      "comment": "Assigning `einfo = None` only rebinds the local name and does not delete the object or its internal references. Use `del einfo` or explicitly clear its attributes to prevent lingering references.\n```suggestion\n            # Break potential reference cycles by deleting the einfo object\n            del einfo\n```",
      "comment_id": 2187103954,
      "user": "Copilot",
      "created_at": "2025-07-05T11:08:28Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187103954"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 306,
      "side": "RIGHT",
      "diff_hunk": "@@ -283,8 +305,10 @@ def traceback_clear(exc=None):\n \n     while tb is not None:",
      "comment": "The code already has` tb = tb.tb_next` at [line 315](https://github.com/jaiganeshs21/celery/blob/fix-memory-leak-issue-8882/celery/app/trace.py#L315), at the end of the while loop. The loop does advance to the next traceback frame and terminates correctly when tb becomes None. \r\n\r\nAlso a test was added to demonstrate this works properly - [Code](https://github.com/jaiganeshs21/celery/blob/fix-memory-leak-issue-8882/t/integration/test_mem_leak_in_exception_handling.py#L139) - process multiple frames (3/3 in our test) ",
      "comment_id": 2187109827,
      "user": "jaiganeshs21",
      "created_at": "2025-07-05T11:21:13Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187109827"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 229,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,39 +206,54 @@ def handle_retry(self, task, req, store_errors=True, **kwargs):\n                 'name': get_task_name(req, task.name),\n                 'exc': str(reason),\n             })\n+            # Note: We return einfo, so we can't clean it up here\n+            # The calling function is responsible for cleanup\n             return einfo\n         finally:\n-            del tb\n+            # MEMORY LEAK FIX: Clean up direct traceback reference to prevent\n+            # retention of frame objects and their local variables (Issue #8882)\n+            if tb is not None:\n+                del tb\n \n     def handle_failure(self, task, req, store_errors=True, call_errbacks=True):\n         \"\"\"Handle exception.\"\"\"\n         orig_exc = self.retval\n+        tb_ref = None\n \n-        exc = get_pickleable_exception(orig_exc)\n-        if exc.__traceback__ is None:\n-            # `get_pickleable_exception` may have created a new exception without\n-            # a traceback.\n-            _, _, exc.__traceback__ = sys.exc_info()\n-\n-        exc_type = get_pickleable_etype(type(orig_exc))\n-\n-        # make sure we only send pickleable exceptions back to parent.\n-        einfo = ExceptionInfo(exc_info=(exc_type, exc, exc.__traceback__))\n-\n-        task.backend.mark_as_failure(\n-            req.id, exc, einfo.traceback,\n-            request=req, store_result=store_errors,\n-            call_errbacks=call_errbacks,\n-        )\n-\n-        task.on_failure(exc, req.id, req.args, req.kwargs, einfo)\n-        signals.task_failure.send(sender=task, task_id=req.id,\n-                                  exception=exc, args=req.args,\n-                                  kwargs=req.kwargs,\n-                                  traceback=exc.__traceback__,\n-                                  einfo=einfo)\n-        self._log_error(task, req, einfo)\n-        return einfo\n+        try:\n+            exc = get_pickleable_exception(orig_exc)\n+            if exc.__traceback__ is None:\n+                # `get_pickleable_exception` may have created a new exception without\n+                # a traceback.\n+                _, _, tb_ref = sys.exc_info()\n+                exc.__traceback__ = tb_ref",
      "comment": "Fixed it - https://github.com/celery/celery/pull/9799/commits/ddf25b8ed7afcca3b2ace2deb038d524485683ed\r\n\r\nAdded `traceback_clear(exc)` to `handle_failure(`), following the same pattern used for `Reject`, `Ignore`, `Retry`, `Exception`, and `EncodeError` handling in the trace module.\r\n\r\nThis works because `traceback_clear(exc`) calls `tb.tb_frame.clear()` on each frame to release local variables while preserving the traceback chain for logging. Tests also cover this.",
      "comment_id": 2187157321,
      "user": "jaiganeshs21",
      "created_at": "2025-07-05T11:57:04Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187157321"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Print memory statistics for debugging\n+    print()  # New line for better readability\n+    print(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"After exceptions: {after_exceptions_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"Final memory: {final_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n+    print(f\"Exceptions processed: {exception_count}\")",
      "comment": "[nitpick] Tests should avoid using `print` for diagnostics; consider using assertions to capture and report relevant memory statistics or a logger configured at debug level.\n```suggestion\n    # Log memory statistics for debugging\n    logger.debug(\"\")  # New line for better readability\n    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n    logger.debug(f\"After exceptions: {after_exceptions_memory / 1024 / 1024:.2f} MB\")\n    logger.debug(f\"Final memory: {final_memory / 1024 / 1024:.2f} MB\")\n    logger.debug(f\"Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n    logger.debug(f\"Exceptions processed: {exception_count}\")\n```",
      "comment_id": 2187339624,
      "user": "Copilot",
      "created_at": "2025-07-05T14:41:11Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187339624"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,39 +206,56 @@ def handle_retry(self, task, req, store_errors=True, **kwargs):\n                 'name': get_task_name(req, task.name),\n                 'exc': str(reason),\n             })\n+            # Note: We return einfo, so we can't clean it up here\n+            # The calling function is responsible for cleanup",
      "comment": "In `handle_retry`, only deleting the local `tb` leaves frame references inside the returned `ExceptionInfo`. To fully prevent leaks, consider calling `traceback_clear(einfo.exception)` before returning so that the frames inside `einfo` are cleared.\n```suggestion\n            # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n            traceback_clear(einfo.exception)\n```",
      "comment_id": 2187339627,
      "user": "Copilot",
      "created_at": "2025-07-05T14:41:11Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187339627"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+",
      "comment": "```suggestion\r\nlogger = logging.getLogger(__name__)\r\n\r\n```",
      "comment_id": 2187347368,
      "user": "auvipy",
      "created_at": "2025-07-05T14:52:25Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187347368"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,254 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"Get current memory usage in bytes.",
      "comment": "```suggestion\r\n    \"\"\"\r\n    Get current memory usage in bytes.\r\n```",
      "comment_id": 2187347849,
      "user": "auvipy",
      "created_at": "2025-07-05T14:53:02Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187347849"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,18 +482,22 @@ def trace_task(uuid, args, kwargs, request=None):\n                     I, R = Info(REJECTED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_reject(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Ignore as exc:\n                     I, R = Info(IGNORED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_ignore(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Retry as exc:\n                     I, R, state, retval = on_error(\n                         task_request, exc, RETRY, call_errbacks=False)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Exception as exc:\n                     I, R, state, retval = on_error(task_request, exc)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)",
      "comment": "Repeated calls to `traceback_clear(exc)` in each exception handler introduce duplication; consider centralizing cleanup logic to reduce code repetition.\n```suggestion\n                    handle_exception_cleanup(exc)\n                except Ignore as exc:\n                    I, R = Info(IGNORED, exc), ExceptionInfo(internal=True)\n                    state, retval = I.state, I.retval\n                    I.handle_ignore(task, task_request)\n                    handle_exception_cleanup(exc)\n                except Retry as exc:\n                    I, R, state, retval = on_error(\n                        task_request, exc, RETRY, call_errbacks=False)\n                    handle_exception_cleanup(exc)\n                except Exception as exc:\n                    I, R, state, retval = on_error(task_request, exc)\n                    handle_exception_cleanup(exc)\n```",
      "comment_id": 2187350584,
      "user": "Copilot",
      "created_at": "2025-07-05T14:57:21Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187350584"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,18 +482,22 @@ def trace_task(uuid, args, kwargs, request=None):\n                     I, R = Info(REJECTED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_reject(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Ignore as exc:\n                     I, R = Info(IGNORED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_ignore(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Retry as exc:\n                     I, R, state, retval = on_error(\n                         task_request, exc, RETRY, call_errbacks=False)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Exception as exc:\n                     I, R, state, retval = on_error(task_request, exc)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)",
      "comment": "There is no code duplication. The current implementation is similar to what Copilot suggested.\r\n\r\nThe traceback_clear function was defined and is called in the exception handler.\r\n\r\nWe have now added a comment in every place where this function is called to explain that it is used to prevent memory retention, making it easier for code contributors to understand.",
      "comment_id": 2187358947,
      "user": "jaiganeshs21",
      "created_at": "2025-07-05T15:10:19Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187358947"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 164,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Log memory statistics for debugging\n+    logger.debug(\"\")  # New line for better readability\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After exceptions: {after_exceptions_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Final memory: {final_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Exceptions processed: {exception_count}\")\n+\n+    # The test should demonstrate a significant memory increase\n+    # This threshold may need adjustment based on the system\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    # Verify the memory leak is fixed - memory increase should be minimal\n+    # Before fix: >70MB for 1000 tasks (~70KB/task)\n+    # After fix: <5MB for 500 tasks (<10KB/task)\n+    assert memory_increase_mb < 5, (\n+        f\"Memory leak still exists! Expected <5MB increase for 500 tasks, \"",
      "comment": "Hard-coded memory thresholds can cause flaky tests on different environments; consider making the threshold configurable or allowing a small variance.\n```suggestion\n    memory_threshold_mb = float(os.getenv(\"MEMORY_LEAK_THRESHOLD_MB\", 5))\n    variance_mb = float(os.getenv(\"MEMORY_LEAK_VARIANCE_MB\", 0.5))\n    assert memory_increase_mb < memory_threshold_mb + variance_mb, (\n        f\"Memory leak still exists! Expected <{memory_threshold_mb + variance_mb}MB increase for 500 tasks, \"\n```",
      "comment_id": 2187359597,
      "user": "Copilot",
      "created_at": "2025-07-05T15:12:00Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187359597"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,258 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Log memory statistics for debugging\n+    logger.debug(\"\")  # New line for better readability\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After exceptions: {after_exceptions_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Final memory: {final_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Exceptions processed: {exception_count}\")\n+\n+    # The test should demonstrate a significant memory increase\n+    # This threshold may need adjustment based on the system\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    # Verify the memory leak is fixed - memory increase should be minimal\n+    # Before fix: >70MB for 1000 tasks (~70KB/task)\n+    # After fix: <5MB for 500 tasks (<10KB/task)\n+    assert memory_increase_mb < 5, (\n+        f\"Memory leak still exists! Expected <5MB increase for 500 tasks, \"\n+        f\"but got {memory_increase_mb:.2f}MB. \"\n+        f\"This indicates the memory leak fix is not working properly.\"\n+    )\n+\n+\n+def test_mem_leak_retry_failures():\n+    \"\"\"Test memory leak with task retry and eventual failure scenarios.\"\"\"\n+\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Get baseline\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run tasks that retry and eventually fail\n+    for _ in range(100):  # Fewer iterations since retries are expensive\n+        try:\n+            test_instance.task_retry_then_fail.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    after_retries_memory = get_memory_usage()\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Calculate memory increase\n+    memory_increase = after_retries_memory - baseline_memory\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    print()  # New line for better readability\n+    print(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"After retries: {after_retries_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"Memory increase: {memory_increase_mb:.2f} MB\")",
      "comment": "[nitpick] Mixing `print()` statements with `logger.debug` is inconsistent; prefer using the logger for all diagnostic output in tests.\n```suggestion\n    logger.debug(\"\")  # New line for better readability\n    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n    logger.debug(f\"After retries: {after_retries_memory / 1024 / 1024:.2f} MB\")\n    logger.debug(f\"Memory increase: {memory_increase_mb:.2f} MB\")\n```",
      "comment_id": 2187359619,
      "user": "Copilot",
      "created_at": "2025-07-05T15:12:01Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187359619"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 649,
      "side": "RIGHT",
      "diff_hunk": "@@ -607,7 +641,14 @@ def _signal_internal_error(task, uuid, args, kwargs, request, exc):\n             einfo=einfo,\n         )\n     finally:\n-        del tb\n+        # MEMORY LEAK FIX: Clean up local references to prevent memory leaks (Issue #8882)\n+        # Both 'tb' and 'einfo' can hold references to frame objects and their local variables.\n+        # Explicitly clearing these prevents reference cycles that block garbage collection.\n+        if tb is not None:\n+            del tb\n+        if einfo is not None:",
      "comment": "In `_signal_internal_error`, consider calling `traceback_clear(einfo.exception)` before deleting `tb` and `einfo` to ensure that frames are cleared consistently across all handlers.\n```suggestion\n        if einfo is not None:\n            # Clear traceback frames to ensure consistent cleanup\n            traceback_clear(einfo.exception)\n```",
      "comment_id": 2187366351,
      "user": "Copilot",
      "created_at": "2025-07-05T15:18:19Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187366351"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 245,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,260 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Log memory statistics for debugging\n+    logger.debug(\"\")  # New line for better readability\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After exceptions: {after_exceptions_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Final memory: {final_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Exceptions processed: {exception_count}\")\n+\n+    # The test should demonstrate a significant memory increase\n+    # This threshold may need adjustment based on the system\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    # Verify the memory leak is fixed - memory increase should be minimal\n+    # Before fix: >70MB for 1000 tasks (~70KB/task)\n+    # After fix: <5MB for 500 tasks (<10KB/task)\n+    memory_threshold_mb = float(os.getenv(\"MEMORY_LEAK_THRESHOLD_MB\", 5))\n+    variance_mb = float(os.getenv(\"MEMORY_LEAK_VARIANCE_MB\", 0.5))\n+    assert memory_increase_mb < memory_threshold_mb + variance_mb, (\n+        f\"Memory leak still exists! Expected <{memory_threshold_mb + variance_mb}MB increase for 500 tasks, \"\n+        f\"but got {memory_increase_mb:.2f}MB. \"\n+        f\"This indicates the memory leak fix is not working properly.\"\n+    )\n+\n+\n+def test_mem_leak_retry_failures():\n+    \"\"\"Test memory leak with task retry and eventual failure scenarios.\"\"\"\n+\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Get baseline\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run tasks that retry and eventually fail\n+    for _ in range(100):  # Fewer iterations since retries are expensive\n+        try:\n+            test_instance.task_retry_then_fail.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    after_retries_memory = get_memory_usage()\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Calculate memory increase\n+    memory_increase = after_retries_memory - baseline_memory\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    logger.debug(\"\")  # New line for better readability\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After retries: {after_retries_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase_mb:.2f} MB\")\n+\n+    # Retries should not show significant memory increase if fix is working\n+    assert memory_increase_mb < 3, (\n+        f\"Memory leak in retry scenarios! Expected <3MB increase for 100 retry tasks, \"\n+        f\"but got {memory_increase_mb:.2f}MB\"\n+    )\n+\n+\n+def test_mem_leak_nested_exception_stacks():\n+    \"\"\"Test memory leak with deeply nested exception stacks and local variables.\"\"\"\n+\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Get baseline\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run tasks with complex exception stacks\n+    for _ in range(200):\n+        try:\n+            test_instance.task_nested_exception_stack.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    after_complex_memory = get_memory_usage()\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Calculate memory increase\n+    memory_increase = after_complex_memory - baseline_memory\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    print()  # New line for better readability\n+    print(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"After complex exceptions: {after_complex_memory / 1024 / 1024:.2f} MB\")\n+    print(f\"Memory increase: {memory_increase_mb:.2f} MB\")",
      "comment": "[nitpick] Replace direct `print` calls with `logger.debug` for consistent logging and remove standalone blank prints to avoid cluttering test output.\n```suggestion\n    logger.debug(\"Memory usage results:\")\n    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n    logger.debug(f\"After complex exceptions: {after_complex_memory / 1024 / 1024:.2f} MB\")\n    logger.debug(f\"Memory increase: {memory_increase_mb:.2f} MB\")\n```",
      "comment_id": 2187371799,
      "user": "Copilot",
      "created_at": "2025-07-05T15:23:27Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187371799"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 216,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,39 +206,56 @@ def handle_retry(self, task, req, store_errors=True, **kwargs):\n                 'name': get_task_name(req, task.name),\n                 'exc': str(reason),\n             })\n+            # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n+            traceback_clear(einfo.exception)\n             return einfo\n         finally:\n-            del tb\n+            # MEMORY LEAK FIX: Clean up direct traceback reference to prevent\n+            # retention of frame objects and their local variables (Issue #8882)\n+            if tb is not None:\n+                del tb",
      "comment": "[nitpick] There are multiple scattered calls to 'traceback_clear' and 'del tb' sequences across this module; consider extracting a reusable cleanup helper or decorator to reduce duplication and simplify maintenance.\n```suggestion\n            # MEMORY LEAK FIX: Perform traceback cleanup using helper function\n            cleanup_traceback(einfo.exception, tb)\n            return einfo\n        finally:\n            # MEMORY LEAK FIX: Ensure cleanup is performed even in case of exceptions\n            cleanup_traceback(None, tb)\n```",
      "comment_id": 2187374134,
      "user": "Copilot",
      "created_at": "2025-07-05T15:26:13Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187374134"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -190,6 +190,7 @@ def handle_retry(self, task, req, store_errors=True, **kwargs):\n         # the exception raised is the Retry semi-predicate,\n         # and it's exc' attribute is the original exception raised (if any).\n         type_, _, tb = sys.exc_info()\n+        einfo = None",
      "comment": "The initial assignment `einfo = None` is redundant because `einfo` is always set in the subsequent try block; consider removing it.\n```suggestion\n\n```",
      "comment_id": 2187375818,
      "user": "Copilot",
      "created_at": "2025-07-05T15:28:42Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187375818"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,260 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Log memory statistics for debugging\n+    logger.debug(\"\")  # New line for better readability",
      "comment": "[nitpick] Logging an empty string adds little value; you can remove this line or replace it with a clearer separator.\n```suggestion\n    logger.debug(\"---\")  # Separator for better readability\n```",
      "comment_id": 2187375819,
      "user": "Copilot",
      "created_at": "2025-07-05T15:28:43Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187375819"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,260 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Log memory statistics for debugging\n+    logger.debug(\"\")  # New line for better readability",
      "comment": "[nitpick] Consider removing or replacing this empty debug log with a clearer separator or message to keep logs meaningful.\n```suggestion\n    logger.debug(\"--- Memory Statistics ---\")  # Separator for better readability\n```",
      "comment_id": 2187376341,
      "user": "Copilot",
      "created_at": "2025-07-05T15:30:35Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187376341"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 216,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,39 +206,56 @@ def handle_retry(self, task, req, store_errors=True, **kwargs):\n                 'name': get_task_name(req, task.name),\n                 'exc': str(reason),\n             })\n+            # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n+            traceback_clear(einfo.exception)\n             return einfo\n         finally:\n-            del tb\n+            # MEMORY LEAK FIX: Clean up direct traceback reference to prevent\n+            # retention of frame objects and their local variables (Issue #8882)\n+            if tb is not None:\n+                del tb",
      "comment": "[nitpick] Cleanup logic for memory-leak fixes (`traceback_clear` calls and `del` statements) is repeated across multiple handlers. Extract a shared helper or decorator to DRY up and centralize this behavior.\n```suggestion\n            # MEMORY LEAK FIX: Perform cleanup using shared helper\n            self._cleanup_traceback(einfo.exception, tb)\n            return einfo\n        finally:\n            # MEMORY LEAK FIX: Perform cleanup using shared helper\n            self._cleanup_traceback(None, tb)\n```",
      "comment_id": 2187378207,
      "user": "Copilot",
      "created_at": "2025-07-05T15:33:13Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187378207"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,18 +482,22 @@ def trace_task(uuid, args, kwargs, request=None):\n                     I, R = Info(REJECTED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_reject(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Ignore as exc:\n                     I, R = Info(IGNORED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_ignore(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Retry as exc:\n                     I, R, state, retval = on_error(\n                         task_request, exc, RETRY, call_errbacks=False)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Exception as exc:\n                     I, R, state, retval = on_error(task_request, exc)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)",
      "comment": "[nitpick] There are repeated `traceback_clear(exc)` calls in each `except` block under `trace_task`; consider centralizing this cleanup in a single `finally` or helper to reduce duplication.\n```suggestion\n                    handle_exception_cleanup(exc)\n                except Ignore as exc:\n                    I, R = Info(IGNORED, exc), ExceptionInfo(internal=True)\n                    state, retval = I.state, I.retval\n                    I.handle_ignore(task, task_request)\n                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                    handle_exception_cleanup(exc)\n                except Retry as exc:\n                    I, R, state, retval = on_error(\n                        task_request, exc, RETRY, call_errbacks=False)\n                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                    handle_exception_cleanup(exc)\n                except Exception as exc:\n                    I, R, state, retval = on_error(task_request, exc)\n                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                    handle_exception_cleanup(exc)\n```",
      "comment_id": 2187378650,
      "user": "Copilot",
      "created_at": "2025-07-05T15:34:52Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187378650"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,260 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Log memory statistics for debugging\n+    logger.debug(\"--- Memory Statistics ---\")  # Separator for better readability\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After exceptions: {after_exceptions_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Final memory: {final_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Exceptions processed: {exception_count}\")\n+\n+    # The test should demonstrate a significant memory increase\n+    # This threshold may need adjustment based on the system\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    # Verify the memory leak is fixed - memory increase should be minimal\n+    # Before fix: >70MB for 1000 tasks (~70KB/task)\n+    # After fix: <5MB for 500 tasks (<10KB/task)\n+    memory_threshold_mb = float(os.getenv(\"MEMORY_LEAK_THRESHOLD_MB\", 5))\n+    variance_mb = float(os.getenv(\"MEMORY_LEAK_VARIANCE_MB\", 0.5))\n+    assert memory_increase_mb < memory_threshold_mb + variance_mb, (\n+        f\"Memory leak still exists! Expected <{memory_threshold_mb + variance_mb}MB increase for 500 tasks, \"\n+        f\"but got {memory_increase_mb:.2f}MB. \"\n+        f\"This indicates the memory leak fix is not working properly.\"\n+    )\n+\n+\n+def test_mem_leak_retry_failures():\n+    \"\"\"Test memory leak with task retry and eventual failure scenarios.\"\"\"\n+\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Get baseline\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run tasks that retry and eventually fail\n+    for _ in range(100):  # Fewer iterations since retries are expensive\n+        try:\n+            test_instance.task_retry_then_fail.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    after_retries_memory = get_memory_usage()\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Calculate memory increase\n+    memory_increase = after_retries_memory - baseline_memory\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    logger.debug(\"\")  # New line for better readability\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After retries: {after_retries_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase_mb:.2f} MB\")\n+\n+    # Retries should not show significant memory increase if fix is working\n+    assert memory_increase_mb < 3, (\n+        f\"Memory leak in retry scenarios! Expected <3MB increase for 100 retry tasks, \"\n+        f\"but got {memory_increase_mb:.2f}MB\"\n+    )\n+\n+\n+def test_mem_leak_nested_exception_stacks():\n+    \"\"\"Test memory leak with deeply nested exception stacks and local variables.\"\"\"\n+\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Get baseline\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run tasks with complex exception stacks\n+    for _ in range(200):\n+        try:\n+            test_instance.task_nested_exception_stack.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    after_complex_memory = get_memory_usage()\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Calculate memory increase\n+    memory_increase = after_complex_memory - baseline_memory\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    logger.debug(\"Memory usage results:\")\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After complex exceptions: {after_complex_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase_mb:.2f} MB\")\n+\n+    # Complex exceptions should not show significant memory increase if fix is working\n+    assert memory_increase_mb < 4, (\n+        f\"Memory leak in nested exception scenarios! Expected <4MB increase for 200 nested tasks, \"\n+        f\"but got {memory_increase_mb:.2f}MB\"\n+    )\n+\n+",
      "comment": "The `test_mem_leak_nested_exception_stacks` test starts `tracemalloc` but doesn\u2019t call `tracemalloc.stop()`. Adding a stop ensures proper cleanup and avoids interfering with other tests.\n```suggestion\n    try:\n        # Get baseline\n        gc.collect()\n        baseline_memory = get_memory_usage()\n\n        # Run tasks with complex exception stacks\n        for _ in range(200):\n            try:\n                test_instance.task_nested_exception_stack.apply()\n            except Exception:\n                pass\n\n        gc.collect()\n        after_complex_memory = get_memory_usage()\n\n        # Calculate memory increase\n        memory_increase = after_complex_memory - baseline_memory\n        memory_increase_mb = memory_increase / 1024 / 1024\n\n        logger.debug(\"Memory usage results:\")\n        logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n        logger.debug(f\"After complex exceptions: {after_complex_memory / 1024 / 1024:.2f} MB\")\n        logger.debug(f\"Memory increase: {memory_increase_mb:.2f} MB\")\n\n        # Complex exceptions should not show significant memory increase if fix is working\n        assert memory_increase_mb < 4, (\n            f\"Memory leak in nested exception scenarios! Expected <4MB increase for 200 nested tasks, \"\n            f\"but got {memory_increase_mb:.2f}MB\"\n        )\n    finally:\n        # Stop tracing\n        tracemalloc.stop()\n```",
      "comment_id": 2187378652,
      "user": "Copilot",
      "created_at": "2025-07-05T15:34:52Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187378652"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,260 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Log memory statistics for debugging\n+    logger.debug(\"--- Memory Statistics ---\")  # Separator for better readability\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After exceptions: {after_exceptions_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Final memory: {final_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Exceptions processed: {exception_count}\")\n+\n+    # The test should demonstrate a significant memory increase\n+    # This threshold may need adjustment based on the system\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    # Verify the memory leak is fixed - memory increase should be minimal\n+    # Before fix: >70MB for 1000 tasks (~70KB/task)\n+    # After fix: <5MB for 500 tasks (<10KB/task)\n+    memory_threshold_mb = float(os.getenv(\"MEMORY_LEAK_THRESHOLD_MB\", 5))\n+    variance_mb = float(os.getenv(\"MEMORY_LEAK_VARIANCE_MB\", 0.5))\n+    assert memory_increase_mb < memory_threshold_mb + variance_mb, (\n+        f\"Memory leak still exists! Expected <{memory_threshold_mb + variance_mb}MB increase for 500 tasks, \"\n+        f\"but got {memory_increase_mb:.2f}MB. \"\n+        f\"This indicates the memory leak fix is not working properly.\"\n+    )\n+\n+\n+def test_mem_leak_retry_failures():\n+    \"\"\"Test memory leak with task retry and eventual failure scenarios.\"\"\"\n+\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Get baseline\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run tasks that retry and eventually fail\n+    for _ in range(100):  # Fewer iterations since retries are expensive\n+        try:\n+            test_instance.task_retry_then_fail.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    after_retries_memory = get_memory_usage()\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Calculate memory increase\n+    memory_increase = after_retries_memory - baseline_memory\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    logger.debug(\"\")  # New line for better readability\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After retries: {after_retries_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase_mb:.2f} MB\")\n+\n+    # Retries should not show significant memory increase if fix is working\n+    assert memory_increase_mb < 3, (\n+        f\"Memory leak in retry scenarios! Expected <3MB increase for 100 retry tasks, \"\n+        f\"but got {memory_increase_mb:.2f}MB\"\n+    )\n+\n+\n+def test_mem_leak_nested_exception_stacks():\n+    \"\"\"Test memory leak with deeply nested exception stacks and local variables.\"\"\"\n+\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Get baseline\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run tasks with complex exception stacks\n+    for _ in range(200):\n+        try:\n+            test_instance.task_nested_exception_stack.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    after_complex_memory = get_memory_usage()\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Calculate memory increase\n+    memory_increase = after_complex_memory - baseline_memory\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    logger.debug(\"Memory usage results:\")\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After complex exceptions: {after_complex_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase_mb:.2f} MB\")\n+\n+    # Complex exceptions should not show significant memory increase if fix is working\n+    assert memory_increase_mb < 4, (\n+        f\"Memory leak in nested exception scenarios! Expected <4MB increase for 200 nested tasks, \"\n+        f\"but got {memory_increase_mb:.2f}MB\"\n+    )\n+\n+",
      "comment": "Here we are calling `tracemalloc.stop` - https://github.com/celery/celery/pull/9799/files/c7913d9741e817956ad3a5e6a8dbee8ac1a15621#diff-4c7d64de199ffd9489e7ebdda34439dea1f07694acaa5c2b406c6652d08378c9R236",
      "comment_id": 2187379509,
      "user": "jaiganeshs21",
      "created_at": "2025-07-05T15:38:00Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187379509"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,18 +482,22 @@ def trace_task(uuid, args, kwargs, request=None):\n                     I, R = Info(REJECTED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_reject(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Ignore as exc:\n                     I, R = Info(IGNORED, exc), ExceptionInfo(internal=True)\n                     state, retval = I.state, I.retval\n                     I.handle_ignore(task, task_request)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Retry as exc:\n                     I, R, state, retval = on_error(\n                         task_request, exc, RETRY, call_errbacks=False)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)\n                 except Exception as exc:\n                     I, R, state, retval = on_error(task_request, exc)\n+                    # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n                     traceback_clear(exc)",
      "comment": "There is no code duplication. The current implementation is similar to what Copilot suggested.\r\n\r\nThe traceback_clear function was defined and is called in the exception handler.\r\n\r\nWe have now added a comment in every place where this function is called to explain that it is used to prevent memory retention, making it easier for code contributors to understand.\r\n\r\n",
      "comment_id": 2187381153,
      "user": "jaiganeshs21",
      "created_at": "2025-07-05T15:38:28Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187381153"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,260 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.",
      "comment": "Mixing RSS (psutil) and tracemalloc metrics may produce inconsistent baselines. Consider standardizing on one memory metric approach to avoid flaky threshold checks.",
      "comment_id": 2187383352,
      "user": "Copilot",
      "created_at": "2025-07-05T15:39:52Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187383352"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 308,
      "side": "RIGHT",
      "diff_hunk": "@@ -283,8 +307,10 @@ def traceback_clear(exc=None):\n \n     while tb is not None:",
      "comment": "After clearing each frame's locals, the traceback chain remains attached to the exception. To fully detach and allow garbage collection of traceback nodes, consider setting `exc.__traceback__ = None` when `exc` is provided.",
      "comment_id": 2187383358,
      "user": "Copilot",
      "created_at": "2025-07-05T15:39:53Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187383358"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 250,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,39 +206,56 @@ def handle_retry(self, task, req, store_errors=True, **kwargs):\n                 'name': get_task_name(req, task.name),\n                 'exc': str(reason),\n             })\n+            # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n+            traceback_clear(einfo.exception)\n             return einfo\n         finally:\n-            del tb\n+            # MEMORY LEAK FIX: Clean up direct traceback reference to prevent\n+            # retention of frame objects and their local variables (Issue #8882)\n+            if tb is not None:\n+                del tb\n \n     def handle_failure(self, task, req, store_errors=True, call_errbacks=True):\n         \"\"\"Handle exception.\"\"\"\n         orig_exc = self.retval\n+        tb_ref = None\n \n-        exc = get_pickleable_exception(orig_exc)\n-        if exc.__traceback__ is None:\n-            # `get_pickleable_exception` may have created a new exception without\n-            # a traceback.\n-            _, _, exc.__traceback__ = sys.exc_info()\n-\n-        exc_type = get_pickleable_etype(type(orig_exc))\n-\n-        # make sure we only send pickleable exceptions back to parent.\n-        einfo = ExceptionInfo(exc_info=(exc_type, exc, exc.__traceback__))\n-\n-        task.backend.mark_as_failure(\n-            req.id, exc, einfo.traceback,\n-            request=req, store_result=store_errors,\n-            call_errbacks=call_errbacks,\n-        )\n-\n-        task.on_failure(exc, req.id, req.args, req.kwargs, einfo)\n-        signals.task_failure.send(sender=task, task_id=req.id,\n-                                  exception=exc, args=req.args,\n-                                  kwargs=req.kwargs,\n-                                  traceback=exc.__traceback__,\n-                                  einfo=einfo)\n-        self._log_error(task, req, einfo)\n-        return einfo\n+        try:\n+            exc = get_pickleable_exception(orig_exc)\n+            if exc.__traceback__ is None:\n+                # `get_pickleable_exception` may have created a new exception without\n+                # a traceback.\n+                _, _, tb_ref = sys.exc_info()\n+                exc.__traceback__ = tb_ref\n+\n+            exc_type = get_pickleable_etype(type(orig_exc))\n+\n+            # make sure we only send pickleable exceptions back to parent.\n+            einfo = ExceptionInfo(exc_info=(exc_type, exc, exc.__traceback__))\n+\n+            task.backend.mark_as_failure(\n+                req.id, exc, einfo.traceback,\n+                request=req, store_result=store_errors,\n+                call_errbacks=call_errbacks,\n+            )\n+\n+            task.on_failure(exc, req.id, req.args, req.kwargs, einfo)\n+            signals.task_failure.send(sender=task, task_id=req.id,\n+                                      exception=exc, args=req.args,\n+                                      kwargs=req.kwargs,\n+                                      traceback=exc.__traceback__,\n+                                      einfo=einfo)\n+            self._log_error(task, req, einfo)\n+            # MEMORY LEAK FIX: Clear traceback frames to prevent memory retention (Issue #8882)\n+            traceback_clear(exc)",
      "comment": "[nitpick] Multiple handlers call `traceback_clear` in each exception branch; consider centralizing cleanup in a shared finally block or helper to reduce duplication.\n```suggestion\n\n```",
      "comment_id": 2187385514,
      "user": "Copilot",
      "created_at": "2025-07-05T15:42:35Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187385514"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 166,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,260 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster\n+        try:\n+            test_instance.task_unhandled_exception.apply()\n+        except Exception:\n+            exception_count += 1\n+\n+    # Force garbage collection\n+    gc.collect()\n+    after_exceptions_memory = get_memory_usage()\n+\n+    # Run successful tasks again to ensure the leak is from exceptions\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    gc.collect()\n+    final_memory = get_memory_usage()\n+\n+    # Calculate memory increase\n+    memory_increase = after_exceptions_memory - baseline_memory\n+\n+    # Stop tracing\n+    tracemalloc.stop()\n+\n+    # Log memory statistics for debugging\n+    logger.debug(\"--- Memory Statistics ---\")  # Separator for better readability\n+    logger.debug(f\"Baseline memory: {baseline_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"After exceptions: {after_exceptions_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Final memory: {final_memory / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Memory increase: {memory_increase / 1024 / 1024:.2f} MB\")\n+    logger.debug(f\"Exceptions processed: {exception_count}\")\n+\n+    # The test should demonstrate a significant memory increase\n+    # This threshold may need adjustment based on the system\n+    memory_increase_mb = memory_increase / 1024 / 1024\n+\n+    # Verify the memory leak is fixed - memory increase should be minimal\n+    # Before fix: >70MB for 1000 tasks (~70KB/task)\n+    # After fix: <5MB for 500 tasks (<10KB/task)\n+    memory_threshold_mb = float(os.getenv(\"MEMORY_LEAK_THRESHOLD_MB\", 5))\n+    variance_mb = float(os.getenv(\"MEMORY_LEAK_VARIANCE_MB\", 0.5))\n+    assert memory_increase_mb < memory_threshold_mb + variance_mb, (\n+        f\"Memory leak still exists! Expected <{memory_threshold_mb + variance_mb}MB increase for 500 tasks, \"",
      "comment": "[nitpick] Using fixed MB thresholds can lead to flaky tests across environments; consider allowing a relative threshold or tuning based on baseline variance.\n```suggestion\n    threshold_percent = float(os.getenv(\"MEMORY_LEAK_THRESHOLD_PERCENT\", 10))  # Default: 10% increase\n    memory_threshold_mb = baseline_memory / 1024 / 1024 * (threshold_percent / 100)\n    assert memory_increase_mb < memory_threshold_mb, (\n        f\"Memory leak still exists! Expected <{memory_threshold_mb:.2f}MB increase (based on {threshold_percent}% of baseline), \"\n```",
      "comment_id": 2187385517,
      "user": "Copilot",
      "created_at": "2025-07-05T15:42:36Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187385517"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 291,
      "side": "RIGHT",
      "diff_hunk": "@@ -270,6 +288,12 @@ def _log_error(self, task, req, einfo):\n \n \n def traceback_clear(exc=None):\n+    \"\"\"Clear traceback frames to prevent memory leaks.",
      "comment": "After clearing frame objects, explicitly set `exc.__traceback__ = None` to fully break references and avoid retaining the traceback on the exception itself.",
      "comment_id": 2187385518,
      "user": "Copilot",
      "created_at": "2025-07-05T15:42:36Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187385518"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "t/integration/test_mem_leak_in_exception_handling.py",
      "line": 122,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+\"\"\"\n+Integration tests for memory leak issue #8882.\n+\n+These tests reproduce memory leak scenarios that occur when Celery tasks\n+raise unhandled exceptions, causing ExceptionInfo objects to not be\n+properly garbage collected.\n+\"\"\"\n+\n+import gc\n+import logging\n+import os\n+import tracemalloc\n+\n+from celery import Celery\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class MemoryLeakUnhandledExceptionsTest:\n+    \"\"\"Test class for memory leak scenarios with unhandled exceptions.\"\"\"\n+\n+    def __init__(self):\n+        self.app = Celery('test_memory_leak')\n+        self.app.conf.update(\n+            broker_url='memory://',\n+            result_backend='cache+memory://',\n+            task_always_eager=True,\n+            task_eager_propagates=True,\n+            task_store_eager_result=True,\n+        )\n+        self.setup_tasks()\n+\n+    def setup_tasks(self):\n+        \"\"\"Setup test tasks.\"\"\"\n+\n+        @self.app.task\n+        def task_success():\n+            \"\"\"Task that completes successfully - baseline for memory comparison.\"\"\"\n+            return \"success\"\n+\n+        @self.app.task\n+        def task_unhandled_exception():\n+            \"\"\"Task that raises an unhandled RuntimeError exception.\"\"\"\n+            raise RuntimeError(\"Unhandled exception for memory leak test\")\n+\n+        @self.app.task(bind=True, max_retries=3)\n+        def task_retry_then_fail(self):\n+            \"\"\"Task that retries multiple times and eventually fails with unhandled exception.\"\"\"\n+            if self.request.retries < self.max_retries:\n+                raise self.retry(countdown=0.001)\n+            raise RuntimeError(\"Final retry failure - unhandled exception\")\n+\n+        @self.app.task\n+        def task_nested_exception_stack():\n+            \"\"\"Task that raises exception through deeply nested function calls.\"\"\"\n+            def deep_level_5():\n+                local_data = {\"level\": 5, \"data\": list(range(100))}  # noqa: F841\n+                raise ValueError(\"Deep nested exception at level 5\")\n+\n+            def deep_level_4():\n+                local_data = {\"level\": 4, \"nested\": {\"data\": list(range(50))}}  # noqa: F841\n+                deep_level_5()\n+\n+            def deep_level_3():\n+                local_data = [1, 2, 3, {\"nested\": True}]  # noqa: F841\n+                deep_level_4()\n+\n+            def deep_level_2():\n+                deep_level_3()\n+\n+            def deep_level_1():\n+                deep_level_2()\n+\n+            deep_level_1()\n+\n+        self.task_success = task_success\n+        self.task_unhandled_exception = task_unhandled_exception\n+        self.task_retry_then_fail = task_retry_then_fail\n+        self.task_nested_exception_stack = task_nested_exception_stack\n+\n+\n+def get_memory_usage():\n+    \"\"\"\n+    Get current memory usage in bytes.\n+\n+    Returns RSS (total process memory) if psutil is available,\n+    otherwise returns Python heap allocations via tracemalloc.\n+    Note: These measurements are not directly comparable.\n+    \"\"\"\n+    try:\n+        import psutil\n+        process = psutil.Process(os.getpid())\n+        return process.memory_info().rss\n+    except ImportError:\n+        # Fallback to tracemalloc if psutil not available\n+        current, peak = tracemalloc.get_traced_memory()\n+        return current\n+\n+\n+def test_mem_leak_unhandled_exceptions():\n+    \"\"\"Test that reproduces the memory leak when tasks raise unhandled exceptions.\"\"\"\n+\n+    # Setup\n+    test_instance = MemoryLeakUnhandledExceptionsTest()\n+\n+    # Enable memory tracing\n+    tracemalloc.start()\n+\n+    # Warm up - run some successful tasks first\n+    for _ in range(50):\n+        try:\n+            test_instance.task_success.apply()\n+        except Exception:\n+            pass\n+\n+    # Force garbage collection and get baseline memory\n+    gc.collect()\n+    baseline_memory = get_memory_usage()\n+\n+    # Run many failing tasks - this should demonstrate the leak\n+    exception_count = 0\n+    for _ in range(500):  # Reduced from 1000 to make test faster",
      "comment": "[nitpick] This loop of 500 iterations may still slow down CI runs; consider parameterizing the test or further reducing the iteration count when only verifying the absence of large leaks.\n```suggestion\n    iteration_count = int(os.getenv(\"MEMORY_LEAK_TEST_ITERATIONS\", 100))  # Default: 100 iterations\n    for _ in range(iteration_count):  # Parameterized iteration count\n```",
      "comment_id": 2187971995,
      "user": "Copilot",
      "created_at": "2025-07-06T04:21:09Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2187971995"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9799,
      "file_path": "celery/app/trace.py",
      "line": 291,
      "side": "RIGHT",
      "diff_hunk": "@@ -270,6 +288,12 @@ def _log_error(self, task, req, einfo):\n \n \n def traceback_clear(exc=None):\n+    \"\"\"Clear traceback frames to prevent memory leaks.",
      "comment": "\r\n-     Calling traceback_clear() clears the references within the traceback objects, but the exception\u2019s __traceback__ attribute may still reference the root traceback object, which can still keep objects alive until the exception itself is collected.\r\n\r\n-     Setting exc.__traceback__ = None after clearing ensures the exception no longer holds any references to the traceback chain.\r\n",
      "comment_id": 2188079945,
      "user": "auvipy",
      "created_at": "2025-07-06T07:24:39Z",
      "url": "https://github.com/celery/celery/pull/9799#discussion_r2188079945"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9784,
      "file_path": "t/integration/test_tasks.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -495,6 +495,86 @@ def test_soft_time_limit_exceeding_time_limit(self):\n             assert result.status == 'FAILURE'\n \n \n+class test_apply_tasks:\n+    \"\"\"Tests for tasks called via apply() method.\"\"\"\n+\n+    def test_apply_single_task_ids(self, manager):",
      "comment": "[nitpick] These integration tests largely duplicate the unit tests; consider extracting shared logic into a helper function or fixture to reduce copy-paste.",
      "comment_id": 2171488125,
      "user": "Copilot",
      "created_at": "2025-06-27T10:06:08Z",
      "url": "https://github.com/celery/celery/pull/9784#discussion_r2171488125"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9784,
      "file_path": "t/integration/test_tasks.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -495,6 +495,86 @@ def test_soft_time_limit_exceeding_time_limit(self):\n             assert result.status == 'FAILURE'\n \n \n+class test_apply_tasks:\n+    \"\"\"Tests for tasks called via apply() method.\"\"\"\n+\n+    def test_apply_single_task_ids(self, manager):",
      "comment": "I quite agree as in the PR description \r\n\r\n> The tests are quite similar between unit and integration - we could avoid the copy-paste with a global conftest, but there isn't one and it's probably not necessary for this simple case.\r\n\r\nIf I'm not missing something, I see that `/unit/` and `/integration/` tests folders are quite \"closed\" between each other, each folder has his own `conftest.py`file...but yes, since tests are pretty equals it would be ideal to have a common place where to have these mock tasks...where do you think it would be better to place these mock tasks, in a global `conftest.py` under `/t/` folder or in a simple common function?",
      "comment_id": 2171562135,
      "user": "dfm88",
      "created_at": "2025-06-27T10:29:06Z",
      "url": "https://github.com/celery/celery/pull/9784#discussion_r2171562135"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9784,
      "file_path": "t/integration/test_tasks.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -495,6 +495,86 @@ def test_soft_time_limit_exceeding_time_limit(self):\n             assert result.status == 'FAILURE'\n \n \n+class test_apply_tasks:\n+    \"\"\"Tests for tasks called via apply() method.\"\"\"\n+\n+    def test_apply_single_task_ids(self, manager):",
      "comment": "or maybe, since `apply()` is sync and tests are actually equals, maybe leave only one between `integration` and `unit` tests",
      "comment_id": 2171582756,
      "user": "dfm88",
      "created_at": "2025-06-27T10:33:21Z",
      "url": "https://github.com/celery/celery/pull/9784#discussion_r2171582756"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9784,
      "file_path": "t/integration/test_tasks.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -495,6 +495,86 @@ def test_soft_time_limit_exceeding_time_limit(self):\n             assert result.status == 'FAILURE'\n \n \n+class test_apply_tasks:\n+    \"\"\"Tests for tasks called via apply() method.\"\"\"\n+\n+    def test_apply_single_task_ids(self, manager):",
      "comment": "yeah right. lets keep them separate. as they are now",
      "comment_id": 2171592974,
      "user": "auvipy",
      "created_at": "2025-06-27T10:37:59Z",
      "url": "https://github.com/celery/celery/pull/9784#discussion_r2171592974"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9770,
      "file_path": "t/integration/test_quorum_queue_qos_cluster_simulation.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,198 @@\n+import io\n+import logging\n+import sys\n+import threading\n+import time\n+\n+import pytest\n+from kombu import Exchange, Queue\n+from kombu.common import maybe_declare as original_maybe_declare\n+\n+from celery import Celery\n+from celery.contrib.testing.worker import start_worker\n+from celery.worker.consumer import tasks as consumer_tasks\n+\n+\n+def delete_queue_amqp(queue_name, broker_url):\n+    \"\"\"\n+    Delete a queue from RabbitMQ using Kombu.\n+    Avoids subprocesses or external tools like rabbitmqadmin.\n+    \"\"\"\n+    from kombu import Connection\n+\n+    with Connection(broker_url) as conn:\n+        try:\n+            channel = conn.channel()\n+            queue = Queue(name=queue_name)\n+            queue(channel).delete(if_unused=False, if_empty=False)\n+            print(f\"Queue '{queue_name}' deleted.\")\n+        except Exception as exc:\n+            print(f\"Queue deletion failed (may not exist yet): {exc}\")\n+\n+\n+@pytest.mark.amqp\n+@pytest.mark.xfail(\n+    reason=(\n+        \"Cluster race visibility test: Expected intermittent AMQP 540 NOT_IMPLEMENTED errors \"\n+        \"may not trigger deterministically in some environments. Test passes only if such an error occurs.\"\n+    ),\n+    strict=True,\n+)\n+def test_simulated_rabbitmq_cluster_visibility_race(monkeypatch, caplog):\n+    \"\"\"\n+    Simulate a RabbitMQ quorum queue cluster propagation race.\n+\n+    Scenario:\n+    - First worker fails quorum detection (simulating cluster lag)\n+    - Other workers succeed\n+    - All workers start concurrently\n+    - Expect at least one RabbitMQ 540 NOT_IMPLEMENTED or connection-level AMQP error\n+      due to global QoS being incorrectly applied on a quorum queue\n+    \"\"\"\n+    # -----------------------------------\n+    # Test App + Queue Setup\n+    # -----------------------------------\n+    app = Celery('test_app')\n+    app.conf.broker_url = 'pyamqp://guest:guest@rabbit:5672//'\n+    app.conf.worker_detect_quorum_queues = True\n+\n+    quorum_queue = Queue(\n+        name='race_quorum_queue',\n+        exchange=Exchange('test_exchange', type='topic'),\n+        routing_key='test.routing.key',\n+        queue_arguments={\"x-queue-type\": \"quorum\"},\n+    )\n+    app.conf.task_queues = [quorum_queue]\n+\n+    @app.task\n+    def dummy_task():\n+        return \"ok\"\n+\n+    # Ensure the target queue doesn't exist before starting\n+    delete_queue_amqp(quorum_queue.name, app.conf.broker_url)\n+\n+    # -----------------------------------\n+    # Fault Injection: Simulate quorum detection failure for first worker\n+    # -----------------------------------\n+    detect_call_count = {\"count\": 0}\n+    original_detect = consumer_tasks.detect_quorum_queues\n+\n+    def flaky_detect_quorum_queues(app_arg, driver_type):\n+        detect_call_count[\"count\"] += 1\n+        if detect_call_count[\"count\"] == 1:\n+            print(\">>> Simulating quorum detection failure for first worker <<<\")\n+            return False, quorum_queue.name\n+        return original_detect(app_arg, driver_type)\n+\n+    monkeypatch.setattr(consumer_tasks, \"detect_quorum_queues\", flaky_detect_quorum_queues)\n+\n+    # -----------------------------------\n+    # Slow down queue declaration to amplify race\n+    # -----------------------------------\n+    def delayed_maybe_declare(entity, channel, **kwargs):\n+        time.sleep(0.2)\n+        return original_maybe_declare(entity, channel, **kwargs)\n+\n+    monkeypatch.setattr(\"kombu.common.maybe_declare\", delayed_maybe_declare)\n+\n+    # Enable detailed AMQP and Kombu debug logging\n+    for logger_name in [\"kombu\", \"amqp\"]:\n+        logging.getLogger(logger_name).setLevel(logging.DEBUG)\n+\n+    # -----------------------------------\n+    # Start multiple workers concurrently\n+    # -----------------------------------\n+    errors = []\n+    worker_count = 3\n+    stderr_capture = io.StringIO()\n+    original_stderr = sys.stderr\n+    sys.stderr = stderr_capture  # Capture stderr globally for all threads",
      "comment": "[nitpick] Overriding sys.stderr globally for multi-threaded tests may lead to unpredictable output when tests run concurrently; consider using a thread-safe logging capture mechanism instead.\n```suggestion\n    log_handler = logging.StreamHandler(stderr_capture)\n    log_handler.setLevel(logging.ERROR)\n    test_logger = logging.getLogger(\"test_logger\")\n    test_logger.setLevel(logging.ERROR)\n    test_logger.addHandler(log_handler)\n```",
      "comment_id": 2156132483,
      "user": "Copilot",
      "created_at": "2025-06-19T05:12:23Z",
      "url": "https://github.com/celery/celery/pull/9770#discussion_r2156132483"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9770,
      "file_path": "t/integration/test_quorum_queue_qos_cluster_simulation.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,198 @@\n+import io\n+import logging\n+import sys\n+import threading\n+import time\n+\n+import pytest\n+from kombu import Exchange, Queue\n+from kombu.common import maybe_declare as original_maybe_declare\n+\n+from celery import Celery\n+from celery.contrib.testing.worker import start_worker\n+from celery.worker.consumer import tasks as consumer_tasks\n+\n+\n+def delete_queue_amqp(queue_name, broker_url):\n+    \"\"\"\n+    Delete a queue from RabbitMQ using Kombu.\n+    Avoids subprocesses or external tools like rabbitmqadmin.\n+    \"\"\"\n+    from kombu import Connection\n+\n+    with Connection(broker_url) as conn:\n+        try:\n+            channel = conn.channel()\n+            queue = Queue(name=queue_name)\n+            queue(channel).delete(if_unused=False, if_empty=False)\n+            print(f\"Queue '{queue_name}' deleted.\")\n+        except Exception as exc:\n+            print(f\"Queue deletion failed (may not exist yet): {exc}\")",
      "comment": "[nitpick] Consider replacing print statements with proper logging (e.g., logging.info) to ensure consistent and configurable diagnostic output within tests.\n```suggestion\n            logging.info(f\"Queue '{queue_name}' deleted.\")\n        except Exception as exc:\n            logging.error(f\"Queue deletion failed (may not exist yet): {exc}\")\n```",
      "comment_id": 2156132490,
      "user": "Copilot",
      "created_at": "2025-06-19T05:12:24Z",
      "url": "https://github.com/celery/celery/pull/9770#discussion_r2156132490"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9770,
      "file_path": "t/integration/test_quorum_queue_qos_cluster_simulation.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,149 @@\n+import gc\n+import logging\n+import multiprocessing\n+import os\n+import pprint\n+import uuid\n+\n+import pytest\n+from kombu import Queue\n+from kombu.pools import connections\n+\n+from celery import Celery, _state\n+from celery.contrib.testing.worker import start_worker\n+\n+logger = logging.getLogger(__name__)\n+logging.basicConfig(level=logging.INFO)\n+\n+\n+def create_app(queue_name: str) -> Celery:\n+    rabbitmq_user = os.environ.get(\"RABBITMQ_DEFAULT_USER\", \"guest\")\n+    rabbitmq_pass = os.environ.get(\"RABBITMQ_DEFAULT_PASS\", \"guest\")\n+    redis_host = os.environ.get(\"REDIS_HOST\", \"localhost\")\n+    redis_port = os.environ.get(\"REDIS_PORT\", \"6379\")\n+\n+    broker_url = os.environ.get(\"TEST_BROKER\", f\"pyamqp://{rabbitmq_user}:{rabbitmq_pass}@localhost:5672//\")\n+    backend_url = os.environ.get(\"TEST_BACKEND\", f\"redis://{redis_host}:{redis_port}/0\")\n+\n+    app = Celery(\"quorum_qos_race\", broker=broker_url, backend=backend_url)\n+\n+    app.conf.task_queues = [\n+        Queue(\n+            name=queue_name,\n+            queue_arguments={\"x-queue-type\": \"quorum\"},\n+        )\n+    ]\n+    app.conf.task_default_queue = queue_name\n+    app.conf.worker_prefetch_multiplier = 1\n+    app.conf.task_acks_late = True\n+    app.conf.task_reject_on_worker_lost = True\n+    app.conf.broker_transport_options = {\"confirm_publish\": True}\n+\n+    return app\n+\n+\n+def dummy_task_factory(app: Celery, simulate_qos_issue: bool):\n+    @app.task(name=\"dummy_task\")\n+    def dummy_task():\n+        if simulate_qos_issue:\n+            raise Exception(\"qos.global not allowed on quorum queues (simulated)\")\n+        return \"ok\"\n+    return dummy_task\n+\n+\n+def run_worker(simulate_qos_issue: bool, result_queue: multiprocessing.Queue):\n+    queue_name = f\"race_quorum_queue_{uuid.uuid4().hex}\"\n+    app = create_app(queue_name)\n+    logger.info(\"[Celery config snapshot]:\\n%s\", pprint.pformat(dict(app.conf)))\n+    task = dummy_task_factory(app, simulate_qos_issue)\n+\n+    try:\n+        with start_worker(\n+            app,\n+            queues=[queue_name],\n+            loglevel=\"INFO\",\n+            perform_ping_check=False,\n+            shutdown_timeout=15,\n+        ):\n+            res = task.delay()\n+            try:\n+                result = res.get(timeout=10)\n+                result_queue.put({\"status\": \"ok\", \"result\": result})\n+            except Exception as e:\n+                result_queue.put({\"status\": \"error\", \"reason\": str(e)})\n+    except Exception as e:\n+        logger.exception(\"[worker %s] external failure\", simulate_qos_issue)\n+        result_queue.put({\"status\": \"external_failure\", \"reason\": str(e)})\n+    finally:\n+        if result_queue.empty():\n+            result_queue.put({\"status\": \"crash\", \"reason\": \"Worker crashed without reporting\"})\n+\n+\n+@pytest.mark.amqp\n+@pytest.mark.timeout(90)\n+def test_rabbitmq_quorum_qos_visibility_race():\n+    try:\n+        multiprocessing.set_start_method(\"spawn\", force=True)\n+    except RuntimeError:\n+        pass\n+\n+    results = []\n+    processes = []\n+    queues = []\n+\n+    for i in range(3):\n+        simulate = (i == 0)\n+        q = multiprocessing.Queue()\n+        queues.append(q)\n+\n+        p = multiprocessing.Process(target=run_worker, args=(simulate, q))\n+        p.daemon = True\n+        processes.append(p)\n+        p.start()\n+\n+    try:\n+        for i, (p, q) in enumerate(zip(processes, queues)):\n+            try:\n+                p.join(timeout=30)\n+                if p.is_alive():\n+                    p.terminate()\n+                    p.join(timeout=10)\n+                    results.append({\"status\": \"timeout\", \"reason\": f\"[worker {i}] timeout\"})\n+                else:\n+                    try:\n+                        results.append(q.get(timeout=5))\n+                    except Exception as e:\n+                        results.append({\"status\": \"error\", \"reason\": f\"Result error: {str(e)}\"})\n+            except Exception:\n+                try:\n+                    results.append(q.get(timeout=5))\n+                except Exception:\n+                    results.append({\"status\": \"crash\", \"reason\": f\"Worker {i} crashed and gave no result\"})\n+\n+        if any(\"qos.global not allowed\" in r.get(\"reason\", \"\").lower() for r in results):",
      "comment": "The error check relies on matching a hardcoded substring, which may be brittle if the error messages change. Consider validating against a specific error code or ensuring that the expected error message substring is clearly documented in the test.\n```suggestion\n        QOS_GLOBAL_ERROR = \"qos.global not allowed\"\n        if any(QOS_GLOBAL_ERROR in r.get(\"reason\", \"\").lower() for r in results):\n```",
      "comment_id": 2172348712,
      "user": "Copilot",
      "created_at": "2025-06-27T16:05:10Z",
      "url": "https://github.com/celery/celery/pull/9770#discussion_r2172348712"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9770,
      "file_path": "t/integration/conftest.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,19 +45,19 @@ def celery_config(request):\n     config = {\n         'broker_url': TEST_BROKER,\n         'result_backend': TEST_BACKEND,\n+        'result_extended': True,\n         'cassandra_servers': ['localhost'],\n         'cassandra_keyspace': 'tests',\n         'cassandra_table': 'tests',\n         'cassandra_read_consistency': 'ONE',\n         'cassandra_write_consistency': 'ONE',\n-        'result_extended': True\n     }\n     try:\n         # To override the default configuration, create the integration-tests-config.json file\n         # in Celery's root directory.\n         # The file must contain a dictionary of valid configuration name/value pairs.\n-        config_overrides = json.load(open(str(request.config.rootdir / \"integration-tests-config.json\")))\n-        config.update(config_overrides)\n+        overrides = json.load(open(str(request.config.rootdir / \"integration-tests-config.json\")))",
      "comment": "Consider using a 'with open(...) as file:' context manager to load the configuration file, which ensures the file is properly closed even if an exception occurs.\n```suggestion\n        with open(str(request.config.rootdir / \"integration-tests-config.json\")) as file:\n            overrides = json.load(file)\n```",
      "comment_id": 2175422763,
      "user": "Copilot",
      "created_at": "2025-06-30T15:59:40Z",
      "url": "https://github.com/celery/celery/pull/9770#discussion_r2175422763"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9770,
      "file_path": "t/integration/test_security.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,5 +107,12 @@ def gen_certificate(self, key, common_name, issuer=None, sign_key=None):\n \n     @pytest.mark.xfail(reason=\"Issue #5269\")\n     def test_security_task_done(self):\n-        t1 = add.delay(1, 1)\n-        assert t1.get() == 2\n+        t1 = add.apply_async((1, 1))\n+        try:\n+            result = t1.get(timeout=10)  # redis backend will timeout\n+            assert result == 2\n+        except (socket.timeout, TimeoutError):\n+            pytest.fail(\n+                \"Timed out waiting for task result. Task was likely dropped by \"\n+                \"worker due to security misconfig.\"",
      "comment": "[nitpick] Consider logging the exception details in the timeout exception block to provide additional context for debugging any intermittent task failures.\n```suggestion\n        except (socket.timeout, TimeoutError) as e:\n            pytest.fail(\n                f\"Timed out waiting for task result. Task was likely dropped by \"\n                f\"worker due to security misconfig. Exception details: {e}\"\n```",
      "comment_id": 2175422772,
      "user": "Copilot",
      "created_at": "2025-06-30T15:59:41Z",
      "url": "https://github.com/celery/celery/pull/9770#discussion_r2175422772"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9765,
      "file_path": "t/integration/test_rabbitmq_default_queue_type_fallback.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,59 @@\n+# t/integration/test_rabbitmq_default_queue_type_fallback.py\n+\n+import time\n+\n+import pytest\n+from kombu import Connection\n+\n+from celery import Celery\n+\n+\n+@pytest.fixture()\n+def app():\n+    return Celery(\n+        \"test_app\",\n+        broker=\"amqp://guest:guest@rabbit:5672//\",\n+        backend=\"redis://redis:6379/0\",\n+        include=[\"t.integration.test_rabbitmq_default_queue_type_fallback\"],\n+    )\n+\n+\n+@pytest.fixture()\n+def ping(app):\n+    @app.task(name=\"ping\")\n+    def ping():\n+        return \"pong\"\n+    return ping\n+\n+\n+@pytest.mark.amqp\n+@pytest.mark.timeout(30)\n+@pytest.mark.xfail(\n+    reason=(\n+        \"Celery does not respect task_default_exchange_type/queue_type \"\n+        \"when using implicit routing to the 'celery' queue. It creates \"\n+        \"a classic queue and direct exchange instead.\"\n+    ),\n+    strict=True,\n+)\n+def test_fallback_to_classic_queue_and_direct_exchange(app, ping):\n+    from celery.contrib.testing.worker import start_worker\n+\n+    # Start worker and submit task\n+    with start_worker(app, queues=[\"celery\"], loglevel=\"info\", perform_ping_check=False):\n+        result = ping.delay()\n+        assert result.get(timeout=10) == \"pong\"\n+        time.sleep(2)\n+\n+        with Connection(app.conf.broker_url) as conn:\n+            channel = conn.channel()\n+            try:\n+                response = channel.exchange_declare(\"celery\", passive=True)\n+                exchange_type = response['type']\n+            except Exception as exc:\n+                exchange_type = f\"error: {exc}\"\n+",
      "comment": "[nitpick] Using a fixed sleep duration might make the test brittle or slower than necessary. Consider replacing the hard-coded sleep with a conditional wait or polling mechanism to confirm that the exchange declaration has propagated.\n```suggestion\n\n        exchange_type = None\n        start_time = time.time()\n        timeout = 10  # Maximum wait time in seconds\n\n        while time.time() - start_time < timeout:\n            with Connection(app.conf.broker_url) as conn:\n                channel = conn.channel()\n                try:\n                    response = channel.exchange_declare(\"celery\", passive=True)\n                    exchange_type = response['type']\n                    break  # Exit loop if successful\n                except Exception:\n                    time.sleep(0.5)  # Wait briefly before retrying\n\n        if exchange_type is None:\n            exchange_type = \"error: Exchange declaration timed out\"\n```",
      "comment_id": 2153835344,
      "user": "Copilot",
      "created_at": "2025-06-18T07:18:05Z",
      "url": "https://github.com/celery/celery/pull/9765#discussion_r2153835344"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9765,
      "file_path": "t/integration/test_rabbitmq_default_queue_type_fallback.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,79 @@\n+import socket\n+import time\n+\n+import pytest\n+from kombu import Connection\n+\n+from celery import Celery\n+\n+\n+def wait_for_port(host, port, timeout=30.0):\n+    \"\"\"Wait for a port to become available.\"\"\"\n+    start = time.time()\n+    while time.time() - start < timeout:\n+        try:\n+            with socket.create_connection((host, port), timeout=2):\n+                return\n+        except OSError:\n+            time.sleep(1)\n+    raise TimeoutError(f\"Timed out waiting for {host}:{port}\")\n+\n+\n+@pytest.fixture()\n+def app(rabbitmq):\n+    wait_for_port(rabbitmq.hostname, rabbitmq.ports[5672])\n+\n+    return Celery(\n+        \"test_app\",\n+        broker=f\"pyamqp://guest:guest@{rabbitmq.hostname}:{rabbitmq.ports[5672]}/\",\n+        backend=\"redis://redis:6379/0\",  # You may also want to make redis dynamic if needed",
      "comment": "[nitpick] Hard-coding the Redis backend URI can make tests brittle. Consider parameterizing the Redis host/port via a fixture or environment variable, similar to the `rabbitmq` fixture, for consistency and flexibility.\n```suggestion\ndef redis():\n    \"\"\"Fixture to provide Redis hostname and port.\"\"\"\n    return {\"hostname\": \"redis\", \"port\": 6379}\n\n@pytest.fixture()\ndef app(rabbitmq, redis):\n    wait_for_port(rabbitmq.hostname, rabbitmq.ports[5672])\n    wait_for_port(redis[\"hostname\"], redis[\"port\"])\n\n    return Celery(\n        \"test_app\",\n        broker=f\"pyamqp://guest:guest@{rabbitmq.hostname}:{rabbitmq.ports[5672]}/\",\n        backend=f\"redis://{redis['hostname']}:{redis['port']}/0\",\n```",
      "comment_id": 2156064001,
      "user": "Copilot",
      "created_at": "2025-06-19T04:17:54Z",
      "url": "https://github.com/celery/celery/pull/9765#discussion_r2156064001"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9765,
      "file_path": "t/integration/test_rabbitmq_default_queue_type_fallback.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,79 @@\n+import socket\n+import time\n+\n+import pytest\n+from kombu import Connection\n+\n+from celery import Celery\n+\n+\n+def wait_for_port(host, port, timeout=30.0):\n+    \"\"\"Wait for a port to become available.\"\"\"\n+    start = time.time()\n+    while time.time() - start < timeout:\n+        try:\n+            with socket.create_connection((host, port), timeout=2):\n+                return\n+        except OSError:\n+            time.sleep(1)\n+    raise TimeoutError(f\"Timed out waiting for {host}:{port}\")\n+\n+\n+@pytest.fixture()\n+def app(rabbitmq):\n+    wait_for_port(rabbitmq.hostname, rabbitmq.ports[5672])\n+\n+    return Celery(\n+        \"test_app\",\n+        broker=f\"pyamqp://guest:guest@{rabbitmq.hostname}:{rabbitmq.ports[5672]}/\",\n+        backend=\"redis://redis:6379/0\",  # You may also want to make redis dynamic if needed\n+        include=[\"t.integration.test_rabbitmq_default_queue_type_fallback\"],\n+    )\n+\n+\n+@pytest.fixture()\n+def ping(app):\n+    @app.task(name=\"ping\")\n+    def ping():\n+        return \"pong\"\n+    return ping\n+\n+\n+@pytest.mark.amqp\n+@pytest.mark.timeout(30)\n+@pytest.mark.xfail(\n+    reason=(\n+        \"Celery does not respect task_default_exchange_type/queue_type \"\n+        \"when using implicit routing to the 'celery' queue. It creates \"\n+        \"a classic queue and direct exchange instead.\"\n+    ),\n+    strict=True,\n+)\n+def test_fallback_to_classic_queue_and_direct_exchange(app, ping):\n+    from celery.contrib.testing.worker import start_worker\n+\n+    # Start worker and submit task\n+    with start_worker(app, queues=[\"celery\"], loglevel=\"info\", perform_ping_check=False):\n+        result = ping.delay()\n+        assert result.get(timeout=10) == \"pong\"\n+\n+        exchange_type = None\n+        start_time = time.time()\n+        timeout = 10  # Maximum wait time in seconds\n+\n+        while time.time() - start_time < timeout:\n+            with Connection(app.conf.broker_url) as conn:\n+                channel = conn.channel()\n+                try:\n+                    response = channel.exchange_declare(\"celery\", passive=True)\n+                    exchange_type = response['type']\n+                    break\n+                except Exception:\n+                    time.sleep(0.5)",
      "comment": "Opening channels in a loop without explicit closure can exhaust resources. Consider using a context manager (e.g., `with conn.channel() as channel:`) so the channel is closed automatically.\n```suggestion\n                with conn.channel() as channel:\n                    try:\n                        response = channel.exchange_declare(\"celery\", passive=True)\n                        exchange_type = response['type']\n                        break\n                    except Exception:\n                        time.sleep(0.5)\n```",
      "comment_id": 2156064003,
      "user": "Copilot",
      "created_at": "2025-06-19T04:17:54Z",
      "url": "https://github.com/celery/celery/pull/9765#discussion_r2156064003"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9765,
      "file_path": "t/integration/test_rabbitmq_default_queue_type_fallback.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,86 @@\n+import socket\n+import time\n+\n+import pytest\n+from kombu import Connection\n+\n+from celery import Celery\n+\n+\n+def wait_for_port(host, port, timeout=30.0):",
      "comment": "```suggestion\r\ndef wait_for_port(host, port, timeout=60.0):\r\n```",
      "comment_id": 2165612296,
      "user": "auvipy",
      "created_at": "2025-06-25T03:51:52Z",
      "url": "https://github.com/celery/celery/pull/9765#discussion_r2165612296"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9766,
      "file_path": "t/integration/test_rabbitmq_chord_unlock_routing.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,136 @@\n+import time\n+from concurrent.futures import ThreadPoolExecutor, as_completed\n+\n+import pytest\n+from kombu import Exchange, Queue\n+\n+from celery import Celery, chord\n+from celery.contrib.testing.worker import start_worker\n+from celery.result import allow_join_result\n+\n+\n+@pytest.fixture(scope=\"function\")\n+def app():\n+    \"\"\"\n+    Celery app configured to:\n+    - Use quorum queues with topic exchanges\n+    - Route chord_unlock to a dedicated quorum queue\n+    \"\"\"\n+    app = Celery(\n+        \"test_app\",\n+        broker=\"pyamqp://guest:guest@rabbit:5672//\",\n+        backend=\"redis://redis/0\",\n+    )\n+\n+    app.conf.task_default_exchange_type = \"topic\"\n+    app.conf.task_default_exchange = \"default_exchange\"\n+    app.conf.task_default_queue = \"default_queue\"\n+    app.conf.task_default_routing_key = \"default\"\n+\n+    app.conf.task_queues = [\n+        Queue(\n+            \"header_queue\",\n+            Exchange(\"header_exchange\", type=\"topic\"),\n+            routing_key=\"header_rk\",\n+            queue_arguments={\"x-queue-type\": \"quorum\"},\n+        ),\n+        Queue(\n+            \"chord_callback_queue\",\n+            Exchange(\"chord_callback_exchange\", type=\"topic\"),\n+            routing_key=\"chord_callback_queue\",\n+            queue_arguments={\"x-queue-type\": \"quorum\"},\n+        ),\n+    ]\n+\n+    app.conf.task_routes = {\n+        \"celery.chord_unlock\": {\n+            \"queue\": \"chord_callback_queue\",\n+            \"exchange\": \"chord_callback_exchange\",\n+            \"routing_key\": \"chord_callback_queue\",\n+            \"exchange_type\": \"topic\",\n+        },\n+    }\n+\n+    return app\n+\n+\n+@pytest.fixture\n+def add(app):\n+    @app.task(bind=True, max_retries=3, default_retry_delay=1)\n+    def add(self, x, y):\n+        time.sleep(0.05)\n+        return x + y\n+    return add\n+\n+\n+@pytest.fixture\n+def summarize(app):\n+    @app.task(bind=True, max_retries=3, default_retry_delay=1)\n+    def summarize(self, results):\n+        return sum(results)\n+    return summarize\n+\n+\n+@pytest.mark.amqp\n+@pytest.mark.timeout(90)\n+@pytest.mark.xfail(reason=\"chord_unlock routed to quorum/topic queue intermittently fails under load\")\n+def test_chord_unlock_stress_routing_to_quorum_queue(app, add, summarize):\n+    \"\"\"\n+    Reproduces Celery Discussion #9742 (intermittently):\n+    When chord_unlock is routed to a quorum queue via topic exchange, it may not be consumed\n+    even if declared and bound, leading to stuck results.\n+\n+    This stress test submits many chords rapidly, each routed explicitly via a topic exchange,\n+    and waits to see how many complete.\n+    \"\"\"\n+    chord_count = 50\n+    header_fanout = 3\n+    failures = []\n+\n+    pending_results = []\n+\n+    with allow_join_result():\n+        # Submit chords BEFORE worker is running\n+        for i in range(chord_count):\n+            header = [\n+                add.s(i, j).set(\n+                    queue=\"header_queue\",\n+                    exchange=\"header_exchange\",\n+                    routing_key=\"header_rk\",\n+                )\n+                for j in range(header_fanout)\n+            ]\n+\n+            callback = summarize.s().set(\n+                queue=\"chord_callback_queue\",\n+                exchange=\"chord_callback_exchange\",\n+                routing_key=\"chord_callback_queue\",\n+            )\n+\n+            result = chord(header)(callback)\n+            pending_results.append((i, result))\n+\n+        time.sleep(3)  # Give chord_unlock time to be dispatched",
      "comment": "[nitpick] Using a fixed `sleep` can make this test flaky; consider polling or event notifications to detect when the `chord_unlock` tasks are actually enqueued instead of relying on a hard timeout.",
      "comment_id": 2153845269,
      "user": "Copilot",
      "created_at": "2025-06-18T07:23:01Z",
      "url": "https://github.com/celery/celery/pull/9766#discussion_r2153845269"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9766,
      "file_path": "t/integration/test_rabbitmq_chord_unlock_routing.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+import time\n+from concurrent.futures import ThreadPoolExecutor, as_completed\n+\n+import pytest\n+from kombu import Exchange, Queue\n+\n+from celery import Celery, chord\n+from celery.contrib.testing.worker import start_worker\n+from celery.result import allow_join_result\n+\n+\n+@pytest.fixture(scope=\"function\")\n+def app():\n+    \"\"\"\n+    Celery app configured to:\n+    - Use quorum queues with topic exchanges\n+    - Route chord_unlock to a dedicated quorum queue\n+    \"\"\"\n+    app = Celery(\n+        \"test_app\",\n+        broker=\"pyamqp://guest:guest@rabbit:5672//\",\n+        backend=\"redis://redis/0\",\n+    )\n+\n+    app.conf.task_default_exchange_type = \"topic\"\n+    app.conf.task_default_exchange = \"default_exchange\"\n+    app.conf.task_default_queue = \"default_queue\"\n+    app.conf.task_default_routing_key = \"default\"\n+\n+    app.conf.task_queues = [\n+        Queue(\n+            \"header_queue\",\n+            Exchange(\"header_exchange\", type=\"topic\"),\n+            routing_key=\"header_rk\",\n+            queue_arguments={\"x-queue-type\": \"quorum\"},\n+        ),\n+        Queue(\n+            \"chord_callback_queue\",\n+            Exchange(\"chord_callback_exchange\", type=\"topic\"),\n+            routing_key=\"chord_callback_queue\",\n+            queue_arguments={\"x-queue-type\": \"quorum\"},\n+        ),\n+    ]\n+\n+    app.conf.task_routes = {\n+        \"celery.chord_unlock\": {\n+            \"queue\": \"chord_callback_queue\",\n+            \"exchange\": \"chord_callback_exchange\",\n+            \"routing_key\": \"chord_callback_queue\",\n+            \"exchange_type\": \"topic\",\n+        },\n+    }\n+\n+    return app\n+\n+\n+@pytest.fixture\n+def add(app):\n+    @app.task(bind=True, max_retries=3, default_retry_delay=1)\n+    def add(self, x, y):\n+        time.sleep(0.05)\n+        return x + y\n+    return add\n+\n+\n+@pytest.fixture\n+def summarize(app):\n+    @app.task(bind=True, max_retries=3, default_retry_delay=1)\n+    def summarize(self, results):\n+        return sum(results)\n+    return summarize\n+\n+\n+def wait_for_chord_unlock(chord_result, timeout=10, interval=0.2):\n+    \"\"\"\n+    Waits for chord_unlock to be enqueued by polling the `parent` of the chord result.\n+    This confirms that the header group finished and the callback is ready to run.\n+    \"\"\"\n+    start = time.monotonic()\n+    while time.monotonic() - start < timeout:\n+        if chord_result.parent and chord_result.parent.ready():\n+            return True\n+        time.sleep(interval)\n+    return False\n+\n+\n+@pytest.mark.amqp\n+@pytest.mark.timeout(90)\n+@pytest.mark.xfail(reason=\"chord_unlock routed to quorum/topic queue intermittently fails under load\")\n+def test_chord_unlock_stress_routing_to_quorum_queue(app, add, summarize):\n+    \"\"\"\n+    Reproduces Celery Discussion #9742 (intermittently):\n+    When chord_unlock is routed to a quorum queue via topic exchange, it may not be consumed\n+    even if declared and bound, leading to stuck results.\n+\n+    This stress test submits many chords rapidly, each routed explicitly via a topic exchange,\n+    and waits to see how many complete.\n+    \"\"\"\n+    chord_count = 50\n+    header_fanout = 3\n+    failures = []\n+\n+    pending_results = []\n+\n+    with allow_join_result():\n+        # Submit chords BEFORE worker is running\n+        for i in range(chord_count):\n+            header = [\n+                add.s(i, j).set(\n+                    queue=\"header_queue\",\n+                    exchange=\"header_exchange\",\n+                    routing_key=\"header_rk\",\n+                )\n+                for j in range(header_fanout)\n+            ]\n+\n+            callback = summarize.s().set(\n+                queue=\"chord_callback_queue\",\n+                exchange=\"chord_callback_exchange\",\n+                routing_key=\"chord_callback_queue\",\n+            )\n+\n+            result = chord(header)(callback)\n+            pending_results.append((i, result))\n+\n+        # Wait for chord_unlock tasks to be dispatched before starting the worker\n+        for i, result in pending_results:\n+            if not wait_for_chord_unlock(result):\n+                print(f\"[!] Chord {i}: unlock was not dispatched within timeout\")",
      "comment": "[nitpick] Consider using a logging library instead of print() for output; this can lead to more robust and configurable test output management.\n```suggestion\n                logging.warning(f\"[!] Chord {i}: unlock was not dispatched within timeout\")\n```",
      "comment_id": 2156068821,
      "user": "Copilot",
      "created_at": "2025-06-19T04:20:38Z",
      "url": "https://github.com/celery/celery/pull/9766#discussion_r2156068821"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9766,
      "file_path": "t/integration/test_rabbitmq_chord_unlock_routing.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+import time\n+from concurrent.futures import ThreadPoolExecutor, as_completed\n+\n+import pytest\n+from kombu import Exchange, Queue\n+\n+from celery import Celery, chord\n+from celery.contrib.testing.worker import start_worker\n+from celery.result import allow_join_result\n+\n+\n+@pytest.fixture(scope=\"function\")\n+def app():\n+    \"\"\"\n+    Celery app configured to:\n+    - Use quorum queues with topic exchanges\n+    - Route chord_unlock to a dedicated quorum queue\n+    \"\"\"\n+    app = Celery(\n+        \"test_app\",\n+        broker=\"pyamqp://guest:guest@rabbit:5672//\",\n+        backend=\"redis://redis/0\",\n+    )\n+\n+    app.conf.task_default_exchange_type = \"topic\"\n+    app.conf.task_default_exchange = \"default_exchange\"\n+    app.conf.task_default_queue = \"default_queue\"\n+    app.conf.task_default_routing_key = \"default\"\n+\n+    app.conf.task_queues = [\n+        Queue(\n+            \"header_queue\",\n+            Exchange(\"header_exchange\", type=\"topic\"),\n+            routing_key=\"header_rk\",\n+            queue_arguments={\"x-queue-type\": \"quorum\"},\n+        ),\n+        Queue(\n+            \"chord_callback_queue\",\n+            Exchange(\"chord_callback_exchange\", type=\"topic\"),\n+            routing_key=\"chord_callback_queue\",\n+            queue_arguments={\"x-queue-type\": \"quorum\"},\n+        ),\n+    ]\n+\n+    app.conf.task_routes = {\n+        \"celery.chord_unlock\": {\n+            \"queue\": \"chord_callback_queue\",\n+            \"exchange\": \"chord_callback_exchange\",\n+            \"routing_key\": \"chord_callback_queue\",\n+            \"exchange_type\": \"topic\",\n+        },\n+    }\n+\n+    return app\n+\n+\n+@pytest.fixture\n+def add(app):\n+    @app.task(bind=True, max_retries=3, default_retry_delay=1)\n+    def add(self, x, y):\n+        time.sleep(0.05)\n+        return x + y\n+    return add\n+\n+\n+@pytest.fixture\n+def summarize(app):\n+    @app.task(bind=True, max_retries=3, default_retry_delay=1)\n+    def summarize(self, results):\n+        return sum(results)\n+    return summarize\n+\n+\n+def wait_for_chord_unlock(chord_result, timeout=10, interval=0.2):\n+    \"\"\"\n+    Waits for chord_unlock to be enqueued by polling the `parent` of the chord result.\n+    This confirms that the header group finished and the callback is ready to run.\n+    \"\"\"\n+    start = time.monotonic()\n+    while time.monotonic() - start < timeout:\n+        if chord_result.parent and chord_result.parent.ready():\n+            return True\n+        time.sleep(interval)\n+    return False\n+\n+\n+@pytest.mark.amqp\n+@pytest.mark.timeout(90)\n+@pytest.mark.xfail(reason=\"chord_unlock routed to quorum/topic queue intermittently fails under load\")\n+def test_chord_unlock_stress_routing_to_quorum_queue(app, add, summarize):\n+    \"\"\"\n+    Reproduces Celery Discussion #9742 (intermittently):\n+    When chord_unlock is routed to a quorum queue via topic exchange, it may not be consumed\n+    even if declared and bound, leading to stuck results.\n+\n+    This stress test submits many chords rapidly, each routed explicitly via a topic exchange,\n+    and waits to see how many complete.\n+    \"\"\"\n+    chord_count = 50\n+    header_fanout = 3\n+    failures = []\n+\n+    pending_results = []\n+\n+    with allow_join_result():\n+        # Submit chords BEFORE worker is running\n+        for i in range(chord_count):\n+            header = [\n+                add.s(i, j).set(\n+                    queue=\"header_queue\",\n+                    exchange=\"header_exchange\",\n+                    routing_key=\"header_rk\",\n+                )\n+                for j in range(header_fanout)\n+            ]\n+\n+            callback = summarize.s().set(\n+                queue=\"chord_callback_queue\",\n+                exchange=\"chord_callback_exchange\",\n+                routing_key=\"chord_callback_queue\",\n+            )\n+\n+            result = chord(header)(callback)\n+            pending_results.append((i, result))\n+\n+        # Wait for chord_unlock tasks to be dispatched before starting the worker\n+        for i, result in pending_results:\n+            if not wait_for_chord_unlock(result):\n+                print(f\"[!] Chord {i}: unlock was not dispatched within timeout\")\n+\n+        # Start worker that consumes both header and callback queues\n+        with start_worker(\n+            app, queues=[\"header_queue\", \"chord_callback_queue\"], loglevel=\"info\", perform_ping_check=False\n+        ):\n+            # Poll all chord results\n+            with ThreadPoolExecutor(max_workers=10) as executor:\n+                futures = {\n+                    executor.submit(result.get, timeout=20): (i, result)\n+                    for i, result in pending_results\n+                }\n+\n+                for future in as_completed(futures):\n+                    i, result = futures[future]\n+                    try:\n+                        res = future.result()\n+                        print(f\"[\u2713] Chord {i} completed: {res}\")\n+                    except Exception as exc:\n+                        print(f\"[\u2717] Chord {i} failed or stuck: {exc}\")",
      "comment": "[nitpick] Consider replacing print() with a logging framework to enable better traceability in concurrent test executions.\n```suggestion\n                        logging.info(f\"[\u2713] Chord {i} completed: {res}\")\n                    except Exception as exc:\n                        logging.error(f\"[\u2717] Chord {i} failed or stuck: {exc}\")\n```",
      "comment_id": 2156068833,
      "user": "Copilot",
      "created_at": "2025-06-19T04:20:39Z",
      "url": "https://github.com/celery/celery/pull/9766#discussion_r2156068833"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9766,
      "file_path": "t/integration/test_rabbitmq_chord_unlock_routing.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,152 @@\n+import time\n+from concurrent.futures import ThreadPoolExecutor, as_completed\n+\n+import pytest\n+from kombu import Exchange, Queue\n+\n+from celery import Celery, chord\n+from celery.contrib.testing.worker import start_worker\n+from celery.result import allow_join_result\n+\n+\n+@pytest.fixture(scope=\"function\")\n+def app():\n+    \"\"\"\n+    Celery app configured to:\n+    - Use quorum queues with topic exchanges\n+    - Route chord_unlock to a dedicated quorum queue\n+    \"\"\"\n+    app = Celery(\n+        \"test_app\",\n+        broker=\"pyamqp://guest:guest@rabbit:5672//\",\n+        backend=\"redis://redis/0\",\n+    )\n+\n+    app.conf.task_default_exchange_type = \"topic\"\n+    app.conf.task_default_exchange = \"default_exchange\"\n+    app.conf.task_default_queue = \"default_queue\"\n+    app.conf.task_default_routing_key = \"default\"\n+\n+    app.conf.task_queues = [\n+        Queue(\n+            \"header_queue\",\n+            Exchange(\"header_exchange\", type=\"topic\"),\n+            routing_key=\"header_rk\",\n+            queue_arguments={\"x-queue-type\": \"quorum\"},\n+        ),\n+        Queue(\n+            \"chord_callback_queue\",\n+            Exchange(\"chord_callback_exchange\", type=\"topic\"),\n+            routing_key=\"chord_callback_queue\",\n+            queue_arguments={\"x-queue-type\": \"quorum\"},\n+        ),\n+    ]\n+\n+    app.conf.task_routes = {\n+        \"celery.chord_unlock\": {\n+            \"queue\": \"chord_callback_queue\",\n+            \"exchange\": \"chord_callback_exchange\",\n+            \"routing_key\": \"chord_callback_queue\",\n+            \"exchange_type\": \"topic\",\n+        },\n+    }\n+\n+    return app\n+\n+\n+@pytest.fixture\n+def add(app):\n+    @app.task(bind=True, max_retries=3, default_retry_delay=1)\n+    def add(self, x, y):\n+        time.sleep(0.05)\n+        return x + y\n+    return add\n+\n+\n+@pytest.fixture\n+def summarize(app):\n+    @app.task(bind=True, max_retries=3, default_retry_delay=1)\n+    def summarize(self, results):\n+        return sum(results)\n+    return summarize\n+\n+\n+def wait_for_chord_unlock(chord_result, timeout=10, interval=0.2):\n+    \"\"\"\n+    Waits for chord_unlock to be enqueued by polling the `parent` of the chord result.\n+    This confirms that the header group finished and the callback is ready to run.\n+    \"\"\"\n+    start = time.monotonic()\n+    while time.monotonic() - start < timeout:\n+        if chord_result.parent and chord_result.parent.ready():\n+            return True\n+        time.sleep(interval)\n+    return False\n+\n+\n+@pytest.mark.amqp\n+@pytest.mark.timeout(90)\n+@pytest.mark.xfail(reason=\"chord_unlock routed to quorum/topic queue intermittently fails under load\")\n+def test_chord_unlock_stress_routing_to_quorum_queue(app, add, summarize):\n+    \"\"\"\n+    Reproduces Celery Discussion #9742 (intermittently):\n+    When chord_unlock is routed to a quorum queue via topic exchange, it may not be consumed\n+    even if declared and bound, leading to stuck results.\n+\n+    This stress test submits many chords rapidly, each routed explicitly via a topic exchange,\n+    and waits to see how many complete.\n+    \"\"\"\n+    chord_count = 50\n+    header_fanout = 3\n+    failures = []\n+\n+    pending_results = []\n+\n+    with allow_join_result():\n+        # Submit chords BEFORE worker is running\n+        for i in range(chord_count):\n+            header = [\n+                add.s(i, j).set(\n+                    queue=\"header_queue\",\n+                    exchange=\"header_exchange\",\n+                    routing_key=\"header_rk\",\n+                )\n+                for j in range(header_fanout)\n+            ]\n+\n+            callback = summarize.s().set(\n+                queue=\"chord_callback_queue\",\n+                exchange=\"chord_callback_exchange\",\n+                routing_key=\"chord_callback_queue\",\n+            )\n+\n+            result = chord(header)(callback)\n+            pending_results.append((i, result))\n+\n+        # Wait for chord_unlock tasks to be dispatched before starting the worker\n+        for i, result in pending_results:\n+            if not wait_for_chord_unlock(result):\n+                print(f\"[!] Chord {i}: unlock was not dispatched within timeout\")\n+\n+        # Start worker that consumes both header and callback queues\n+        with start_worker(\n+            app, queues=[\"header_queue\", \"chord_callback_queue\"], loglevel=\"info\", perform_ping_check=False\n+        ):\n+            # Poll all chord results\n+            with ThreadPoolExecutor(max_workers=10) as executor:\n+                futures = {\n+                    executor.submit(result.get, timeout=20): (i, result)\n+                    for i, result in pending_results\n+                }\n+\n+                for future in as_completed(futures):\n+                    i, result = futures[future]\n+                    try:\n+                        res = future.result()\n+                        print(f\"[\u2713] Chord {i} completed: {res}\")\n+                    except Exception as exc:\n+                        print(f\"[\u2717] Chord {i} failed or stuck: {exc}\")",
      "comment": "[nitpick] Using a logging library instead of print() would enhance uniformity and may provide better control over test output and error reporting.\n```suggestion\n                        logging.info(f\"Chord {i} completed: {res}\")\n                    except Exception as exc:\n                        logging.error(f\"Chord {i} failed or stuck: {exc}\")\n```",
      "comment_id": 2156068839,
      "user": "Copilot",
      "created_at": "2025-06-19T04:20:39Z",
      "url": "https://github.com/celery/celery/pull/9766#discussion_r2156068839"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9774,
      "file_path": "t/unit/tasks/test_canvas.py",
      "line": 1847,
      "side": "RIGHT",
      "diff_hunk": "@@ -1781,7 +1781,71 @@ def test_link_error_on_chord_header(self, header):\n         assert errback == err\n         for header_task in c.tasks:\n             assert header_task.options['link_error'] == [err.clone(immutable=True)]\n-        assert c.body.options['link_error'] == [err]\n+        assert c.body.options[\"link_error\"] == [err]\n+\n+    def test_chord_run_uses_group_id_for_body_freeze(self):\n+        \"\"\"Test that chord.run() uses group_id instead of task_id for body.freeze().\n+\n+        This is the unit test for the fix to issue #8578. The chord body should be\n+        frozen with the group_id to ensure proper error handling and task identification.\n+        \"\"\"\n+        # Create a chord with header group and body chain\n+        header = group([self.add.s(1, 1), self.add.s(2, 2)])\n+        body = chain(self.add.s(10, 10), self.add.s(20, 20))\n+        test_chord = chord(header, body)\n+\n+        # Set up specific IDs for testing\n+        chord_task_id = \"test-chord-id\"\n+        group_task_id = \"test-group-id\"\n+        header.options[\"task_id\"] = group_task_id\n+\n+        # Use patch to spy on body.freeze method\n+        with patch.object(body, \"freeze\", wraps=body.freeze) as mock_freeze:\n+            test_chord.run(header, body, (), task_id=chord_task_id)\n+\n+            # Assert that body.freeze was called with group_id, not chord task_id\n+            mock_freeze.assert_called_once_with(group_task_id, root_id=None)\n+\n+    def test_chord_run_generates_group_id_when_none_provided(self):\n+        \"\"\"Test that chord.run() generates a group_id when header has no task_id.\"\"\"\n+        # Create a chord with header group and body chain (no task_id set)\n+        header = group([self.add.s(1, 1), self.add.s(2, 2)])\n+        body = chain(self.add.s(10, 10), self.add.s(20, 20))\n+        test_chord = chord(header, body)\n+\n+        # Use patch to spy on body.freeze method\n+        with patch.object(body, \"freeze\", wraps=body.freeze) as mock_freeze:\n+            test_chord.run(header, body, (), task_id=None)\n+\n+            # Assert that body.freeze was called with a generated UUID (not None)\n+            mock_freeze.assert_called_once()\n+            args, kwargs = mock_freeze.call_args\n+            task_id = args[0] if args else kwargs.get(\"_id\")\n+            assert task_id is not None\n+\n+    def test_chord_run_body_freeze_prevents_task_id_empty_error(self):\n+        \"\"\"Test that proper body.freeze() call prevents 'task_id must not be empty' error.\n+\n+        This test ensures that when chord body is frozen with group_id, subsequent error\n+        handling won't encounter the \"task_id must not be empty\" error.\n+        \"\"\"\n+        # Create chord components\n+        header = group([self.add.s(1, 1), self.add.s(2, 2)])\n+        body = chain(self.add.s(10, 10), self.add.s(20, 20))\n+        test_chord = chord(header, body)\n+\n+        # Set a group task ID\n+        group_id = \"test-group-12345\"\n+        header.options[\"task_id\"] = group_id\n+\n+        # Run the chord\n+        result = test_chord.run(header, body, (), task_id=\"external-task-id\")\n+\n+        # Verify the body now has a proper ID set (should be the group_id)\n+        # This is checked by accessing the body's ID after freezing\n+        assert body.id == group_id\n+        assert result.id is not None",
      "comment": "This assertion checks the signature's `id` rather than the frozen result's `id`. It should be `assert result.id == group_id` to validate that the body callback result was assigned the correct group ID.\n```suggestion\n        # Verify the frozen result now has a proper ID set (should be the group_id)\n        # This is checked by accessing the result's ID after freezing\n        assert result.id == group_id\n        assert body.id is not None\n```",
      "comment_id": 2159887793,
      "user": "Copilot",
      "created_at": "2025-06-21T06:33:05Z",
      "url": "https://github.com/celery/celery/pull/9774#discussion_r2159887793"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9774,
      "file_path": "t/integration/test_canvas.py",
      "line": 3237,
      "side": "RIGHT",
      "diff_hunk": "@@ -3151,6 +3151,92 @@ def test_upgraded_chord_link_error_with_header_errback_enabled(self, manager, su\n \n         redis_connection.delete(errback_key, body_key)\n \n+    @pytest.mark.parametrize(\n+        \"input_body\",\n+        [\n+            (lambda: add.si(9, 7)),\n+            (\n+                lambda: chain(\n+                    add.si(9, 7),\n+                    add.si(5, 7),\n+                )\n+            ),\n+            pytest.param(\n+                (\n+                    lambda: group(\n+                        [\n+                            add.si(9, 7),\n+                            add.si(5, 7),\n+                        ]\n+                    )\n+                ),\n+                marks=pytest.mark.skip(reason=\"Task times out\"),\n+            ),\n+            (\n+                lambda: chord(\n+                    group(\n+                        [\n+                            add.si(1, 1),\n+                            add.si(2, 2),\n+                        ]\n+                    ),\n+                    add.si(10, 10),\n+                )\n+            ),\n+        ],\n+        ids=[\n+            \"body is a single_task\",\n+            \"body is a chain\",\n+            \"body is a group\",\n+            \"body is a chord\",\n+        ],\n+    )\n+    def test_chord_error_propagation_with_different_body_types(\n+        self, manager, caplog, input_body\n+    ) -> None:\n+        \"\"\"Integration test for issue #9773: task_id must not be empty on chain of groups.\n+\n+        This test reproduces the exact scenario from GitHub issue #9773 where a chord\n+        with a failing group task and a chain body causes a ValueError during error handling.\n+\n+        The test verifies that:\n+        1. The chord executes without the \"task_id must not be empty\" error\n+        2. The failure from the group properly propagates to the chain body\n+        3. Error handling works correctly with proper task IDs\n+\n+        Args:\n+            input_body (callable): A callable that returns a Celery signature for the body of the chord.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        # Create the failing group header (same for all tests)\n+        failing_chord = chain(\n+            group(\n+                [\n+                    add.si(15, 7),\n+                    # failing task\n+                    fail.si(),\n+                ]\n+            ),\n+            # dynamic parametrized body\n+            input_body(),\n+        )\n+\n+        result = failing_chord.apply_async()\n+\n+        # The chain should fail due to the failing task in the group\n+        with pytest.raises(ExpectedException):\n+            result.get(timeout=TIMEOUT)\n+\n+        # Verify that error propagation worked correctly without the task_id error\n+        # This test passes if no \"task_id must not be empty\" error was logged\n+        # wait logs to be processed (wait time might vary)\n+        sleep(1)",
      "comment": "Using sleep(1) to wait for logs to flush can be brittle; consider using a more robust synchronization mechanism to ensure logs are processed before assertions.\n```suggestion\n        # Wait for logs to be processed with a polling loop\n        start_time = monotonic()\n        while \"task_id must not be empty\" in caplog.text:\n            if monotonic() - start_time > TIMEOUT:\n                raise TimeoutError(\"Logs did not flush within the timeout period.\")\n            sleep(0.1)\n```",
      "comment_id": 2160725540,
      "user": "Copilot",
      "created_at": "2025-06-23T05:07:12Z",
      "url": "https://github.com/celery/celery/pull/9774#discussion_r2160725540"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9774,
      "file_path": "t/integration/test_canvas.py",
      "line": 3237,
      "side": "RIGHT",
      "diff_hunk": "@@ -3151,6 +3151,92 @@ def test_upgraded_chord_link_error_with_header_errback_enabled(self, manager, su\n \n         redis_connection.delete(errback_key, body_key)\n \n+    @pytest.mark.parametrize(\n+        \"input_body\",\n+        [\n+            (lambda: add.si(9, 7)),\n+            (\n+                lambda: chain(\n+                    add.si(9, 7),\n+                    add.si(5, 7),\n+                )\n+            ),\n+            pytest.param(\n+                (\n+                    lambda: group(\n+                        [\n+                            add.si(9, 7),\n+                            add.si(5, 7),\n+                        ]\n+                    )\n+                ),\n+                marks=pytest.mark.skip(reason=\"Task times out\"),\n+            ),\n+            (\n+                lambda: chord(\n+                    group(\n+                        [\n+                            add.si(1, 1),\n+                            add.si(2, 2),\n+                        ]\n+                    ),\n+                    add.si(10, 10),\n+                )\n+            ),\n+        ],\n+        ids=[\n+            \"body is a single_task\",\n+            \"body is a chain\",\n+            \"body is a group\",\n+            \"body is a chord\",\n+        ],\n+    )\n+    def test_chord_error_propagation_with_different_body_types(\n+        self, manager, caplog, input_body\n+    ) -> None:\n+        \"\"\"Integration test for issue #9773: task_id must not be empty on chain of groups.\n+\n+        This test reproduces the exact scenario from GitHub issue #9773 where a chord\n+        with a failing group task and a chain body causes a ValueError during error handling.\n+\n+        The test verifies that:\n+        1. The chord executes without the \"task_id must not be empty\" error\n+        2. The failure from the group properly propagates to the chain body\n+        3. Error handling works correctly with proper task IDs\n+\n+        Args:\n+            input_body (callable): A callable that returns a Celery signature for the body of the chord.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        # Create the failing group header (same for all tests)\n+        failing_chord = chain(\n+            group(\n+                [\n+                    add.si(15, 7),\n+                    # failing task\n+                    fail.si(),\n+                ]\n+            ),\n+            # dynamic parametrized body\n+            input_body(),\n+        )\n+\n+        result = failing_chord.apply_async()\n+\n+        # The chain should fail due to the failing task in the group\n+        with pytest.raises(ExpectedException):\n+            result.get(timeout=TIMEOUT)\n+\n+        # Verify that error propagation worked correctly without the task_id error\n+        # This test passes if no \"task_id must not be empty\" error was logged\n+        # wait logs to be processed (wait time might vary)\n+        sleep(1)",
      "comment": "can you please check and consider this review suggestion? @dfm88 ",
      "comment_id": 2160732444,
      "user": "auvipy",
      "created_at": "2025-06-23T05:15:08Z",
      "url": "https://github.com/celery/celery/pull/9774#discussion_r2160732444"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9774,
      "file_path": "t/integration/test_canvas.py",
      "line": 3237,
      "side": "RIGHT",
      "diff_hunk": "@@ -3151,6 +3151,92 @@ def test_upgraded_chord_link_error_with_header_errback_enabled(self, manager, su\n \n         redis_connection.delete(errback_key, body_key)\n \n+    @pytest.mark.parametrize(\n+        \"input_body\",\n+        [\n+            (lambda: add.si(9, 7)),\n+            (\n+                lambda: chain(\n+                    add.si(9, 7),\n+                    add.si(5, 7),\n+                )\n+            ),\n+            pytest.param(\n+                (\n+                    lambda: group(\n+                        [\n+                            add.si(9, 7),\n+                            add.si(5, 7),\n+                        ]\n+                    )\n+                ),\n+                marks=pytest.mark.skip(reason=\"Task times out\"),\n+            ),\n+            (\n+                lambda: chord(\n+                    group(\n+                        [\n+                            add.si(1, 1),\n+                            add.si(2, 2),\n+                        ]\n+                    ),\n+                    add.si(10, 10),\n+                )\n+            ),\n+        ],\n+        ids=[\n+            \"body is a single_task\",\n+            \"body is a chain\",\n+            \"body is a group\",\n+            \"body is a chord\",\n+        ],\n+    )\n+    def test_chord_error_propagation_with_different_body_types(\n+        self, manager, caplog, input_body\n+    ) -> None:\n+        \"\"\"Integration test for issue #9773: task_id must not be empty on chain of groups.\n+\n+        This test reproduces the exact scenario from GitHub issue #9773 where a chord\n+        with a failing group task and a chain body causes a ValueError during error handling.\n+\n+        The test verifies that:\n+        1. The chord executes without the \"task_id must not be empty\" error\n+        2. The failure from the group properly propagates to the chain body\n+        3. Error handling works correctly with proper task IDs\n+\n+        Args:\n+            input_body (callable): A callable that returns a Celery signature for the body of the chord.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        # Create the failing group header (same for all tests)\n+        failing_chord = chain(\n+            group(\n+                [\n+                    add.si(15, 7),\n+                    # failing task\n+                    fail.si(),\n+                ]\n+            ),\n+            # dynamic parametrized body\n+            input_body(),\n+        )\n+\n+        result = failing_chord.apply_async()\n+\n+        # The chain should fail due to the failing task in the group\n+        with pytest.raises(ExpectedException):\n+            result.get(timeout=TIMEOUT)\n+\n+        # Verify that error propagation worked correctly without the task_id error\n+        # This test passes if no \"task_id must not be empty\" error was logged\n+        # wait logs to be processed (wait time might vary)\n+        sleep(1)",
      "comment": "Sure! I took a similar approach by creating a helper function that waits for a log to appear, similar to what was suggested by Copilot and how the smoke tests do it using pytest-celery with celery_setup.worker.assert_log_does_not_exist.\r\nUnfortunately, it's necessary to wait for the worker to flush the logs.\r\nAlternatively, we could rely only on the smoke tests, since they are testing the same thing and use a better-integrated approach to wait for container logs.",
      "comment_id": 2161275234,
      "user": "dfm88",
      "created_at": "2025-06-23T10:35:14Z",
      "url": "https://github.com/celery/celery/pull/9774#discussion_r2161275234"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9806,
      "file_path": "t/smoke/tests/test_canvas.py",
      "line": 191,
      "side": "RIGHT",
      "diff_hunk": "@@ -179,3 +179,15 @@ def test_chord_error_propagation_with_different_body_types(\n         # The chord should fail with the expected exception from the failing task\n         with pytest.raises(ExpectedException):\n             result.get(timeout=RESULT_TIMEOUT)\n+\n+\n+class test_complex_workflow:\n+    def test_pending_tasks_released_on_forget(self, celery_setup: CeleryTestSetup):\n+        sig = add.si(1, 1) | group(\n+            add.s(1) | group(add.si(1, 1), add.si(2, 2)) | add.si(2, 2),\n+            add.s(1) | group(add.si(1, 1), add.si(2, 2)) | add.si(2, 2)\n+        ) | add.si(1, 1)\n+        res = sig.apply_async(queue=celery_setup.worker.worker_queue)\n+        assert not all(len(mapping) == 0 for mapping in res.backend._pending_results)",
      "comment": "[nitpick] This test is accessing the private attribute `_pending_results`. Consider exposing a public API or helper method to verify pending results are cleared, which will make the test less brittle.",
      "comment_id": 2188864133,
      "user": "Copilot",
      "created_at": "2025-07-07T02:49:47Z",
      "url": "https://github.com/celery/celery/pull/9806#discussion_r2188864133"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9806,
      "file_path": "t/smoke/tests/test_canvas.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -179,3 +179,15 @@ def test_chord_error_propagation_with_different_body_types(\n         # The chord should fail with the expected exception from the failing task\n         with pytest.raises(ExpectedException):\n             result.get(timeout=RESULT_TIMEOUT)\n+\n+\n+class test_complex_workflow:\n+    def test_pending_tasks_released_on_forget(self, celery_setup: CeleryTestSetup):\n+        sig = add.si(1, 1) | group(\n+            add.s(1) | group(add.si(1, 1), add.si(2, 2)) | add.si(2, 2),\n+            add.s(1) | group(add.si(1, 1), add.si(2, 2)) | add.si(2, 2)\n+        ) | add.si(1, 1)\n+        res = sig.apply_async(queue=celery_setup.worker.worker_queue)\n+        assert not all(len(mapping) == 0 for mapping in res.backend._pending_results)\n+        res.forget()\n+        assert all(len(mapping) == 0 for mapping in res.backend._pending_results)",
      "comment": "[nitpick] This assertion directly inspects a private attribute (`_pending_results`); consider using a public API or helper method for checking pending results to avoid brittle tests.\n```suggestion\n        assert not all(len(mapping) == 0 for mapping in get_pending_results(res))\n        res.forget()\n        assert all(len(mapping) == 0 for mapping in get_pending_results(res))\n```",
      "comment_id": 2189096980,
      "user": "Copilot",
      "created_at": "2025-07-07T06:33:24Z",
      "url": "https://github.com/celery/celery/pull/9806#discussion_r2189096980"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9806,
      "file_path": "t/smoke/tests/test_canvas.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -179,3 +179,15 @@ def test_chord_error_propagation_with_different_body_types(\n         # The chord should fail with the expected exception from the failing task\n         with pytest.raises(ExpectedException):\n             result.get(timeout=RESULT_TIMEOUT)\n+\n+\n+class test_complex_workflow:\n+    def test_pending_tasks_released_on_forget(self, celery_setup: CeleryTestSetup):\n+        sig = add.si(1, 1) | group(\n+            add.s(1) | group(add.si(1, 1), add.si(2, 2)) | add.si(2, 2),\n+            add.s(1) | group(add.si(1, 1), add.si(2, 2)) | add.si(2, 2)\n+        ) | add.si(1, 1)\n+        res = sig.apply_async(queue=celery_setup.worker.worker_queue)\n+        assert not all(len(mapping) == 0 for mapping in res.backend._pending_results)\n+        res.forget()\n+        assert all(len(mapping) == 0 for mapping in res.backend._pending_results)",
      "comment": "@tsoos99dev what is your opinion about this suggestion, is it valid?",
      "comment_id": 2209194669,
      "user": "auvipy",
      "created_at": "2025-07-16T04:37:47Z",
      "url": "https://github.com/celery/celery/pull/9806#discussion_r2209194669"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9806,
      "file_path": "t/smoke/tests/test_canvas.py",
      "line": 184,
      "side": "RIGHT",
      "diff_hunk": "@@ -179,3 +179,15 @@ def test_chord_error_propagation_with_different_body_types(\n         # The chord should fail with the expected exception from the failing task\n         with pytest.raises(ExpectedException):\n             result.get(timeout=RESULT_TIMEOUT)\n+\n+\n+class test_complex_workflow:",
      "comment": "Pytest only collects test methods in classes named `Test*`. Rename `test_complex_workflow` to `TestComplexWorkflow` to ensure the test is discovered.\n```suggestion\nclass TestComplexWorkflow:\n```",
      "comment_id": 2212233228,
      "user": "Copilot",
      "created_at": "2025-07-17T04:36:24Z",
      "url": "https://github.com/celery/celery/pull/9806#discussion_r2212233228"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9686,
      "file_path": "celery/app/base.py",
      "line": 837,
      "side": "RIGHT",
      "diff_hunk": "@@ -833,30 +833,38 @@ def send_task(self, name, args=None, kwargs=None, countdown=None,\n             options, route_name or name, args, kwargs, task_type)\n \n         driver_type = self.producer_pool.connections.connection.transport.driver_type\n-        is_native_delayed_delivery = detect_quorum_queues(self, driver_type)[0]\n-        if is_native_delayed_delivery and options['queue'].exchange.type != 'direct':\n-            if eta:\n-                if isinstance(eta, str):\n-                    eta = isoparse(eta)\n-                countdown = (maybe_make_aware(eta) - self.now()).total_seconds()\n-\n-            if countdown:\n-                if countdown > 0:\n-                    routing_key = calculate_routing_key(int(countdown), options[\"queue\"].routing_key)\n-                    exchange = Exchange(\n-                        'celery_delayed_27',\n-                        type='topic',\n-                    )\n-                    del options['queue']\n-                    options['routing_key'] = routing_key\n-                    options['exchange'] = exchange\n-        elif is_native_delayed_delivery and options['queue'].exchange.type == 'direct':\n-            logger.warning(\n-                'Direct exchanges are not supported with native delayed delivery.\\n'\n-                f'{options[\"queue\"].exchange.name} is a direct exchange but should be a topic exchange or '\n-                'a fanout exchange in order for native delayed delivery to work properly.\\n'\n-                'If quorum queues are used, this task may block the worker process until the ETA arrives.'\n-            )\n+\n+        if (eta or countdown) and detect_quorum_queues(self, driver_type)[0]:",
      "comment": "To improve clarity and efficiency, consider calling detect_quorum_queues once by assigning its result to a variable instead of calling it multiple times.\n```suggestion\n        quorum_queues_detected = detect_quorum_queues(self, driver_type)\n\n        if (eta or countdown) and quorum_queues_detected[0]:\n```",
      "comment_id": 2072845748,
      "user": "Copilot",
      "created_at": "2025-05-05T05:03:50Z",
      "url": "https://github.com/celery/celery/pull/9686#discussion_r2072845748"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9686,
      "file_path": "celery/app/base.py",
      "line": 837,
      "side": "RIGHT",
      "diff_hunk": "@@ -833,30 +833,38 @@ def send_task(self, name, args=None, kwargs=None, countdown=None,\n             options, route_name or name, args, kwargs, task_type)\n \n         driver_type = self.producer_pool.connections.connection.transport.driver_type\n-        is_native_delayed_delivery = detect_quorum_queues(self, driver_type)[0]\n-        if is_native_delayed_delivery and options['queue'].exchange.type != 'direct':\n-            if eta:\n-                if isinstance(eta, str):\n-                    eta = isoparse(eta)\n-                countdown = (maybe_make_aware(eta) - self.now()).total_seconds()\n-\n-            if countdown:\n-                if countdown > 0:\n-                    routing_key = calculate_routing_key(int(countdown), options[\"queue\"].routing_key)\n-                    exchange = Exchange(\n-                        'celery_delayed_27',\n-                        type='topic',\n-                    )\n-                    del options['queue']\n-                    options['routing_key'] = routing_key\n-                    options['exchange'] = exchange\n-        elif is_native_delayed_delivery and options['queue'].exchange.type == 'direct':\n-            logger.warning(\n-                'Direct exchanges are not supported with native delayed delivery.\\n'\n-                f'{options[\"queue\"].exchange.name} is a direct exchange but should be a topic exchange or '\n-                'a fanout exchange in order for native delayed delivery to work properly.\\n'\n-                'If quorum queues are used, this task may block the worker process until the ETA arrives.'\n-            )\n+\n+        if (eta or countdown) and detect_quorum_queues(self, driver_type)[0]:",
      "comment": "This is wrong suggesstion, `quorum_queues_detected` function is used only once in this module, no need to keep in variable for that\r\n\r\n@auvipy ",
      "comment_id": 2072889465,
      "user": "bityob",
      "created_at": "2025-05-05T06:15:44Z",
      "url": "https://github.com/celery/celery/pull/9686#discussion_r2072889465"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9686,
      "file_path": "celery/app/base.py",
      "line": 837,
      "side": "RIGHT",
      "diff_hunk": "@@ -833,30 +833,38 @@ def send_task(self, name, args=None, kwargs=None, countdown=None,\n             options, route_name or name, args, kwargs, task_type)\n \n         driver_type = self.producer_pool.connections.connection.transport.driver_type\n-        is_native_delayed_delivery = detect_quorum_queues(self, driver_type)[0]\n-        if is_native_delayed_delivery and options['queue'].exchange.type != 'direct':\n-            if eta:\n-                if isinstance(eta, str):\n-                    eta = isoparse(eta)\n-                countdown = (maybe_make_aware(eta) - self.now()).total_seconds()\n-\n-            if countdown:\n-                if countdown > 0:\n-                    routing_key = calculate_routing_key(int(countdown), options[\"queue\"].routing_key)\n-                    exchange = Exchange(\n-                        'celery_delayed_27',\n-                        type='topic',\n-                    )\n-                    del options['queue']\n-                    options['routing_key'] = routing_key\n-                    options['exchange'] = exchange\n-        elif is_native_delayed_delivery and options['queue'].exchange.type == 'direct':\n-            logger.warning(\n-                'Direct exchanges are not supported with native delayed delivery.\\n'\n-                f'{options[\"queue\"].exchange.name} is a direct exchange but should be a topic exchange or '\n-                'a fanout exchange in order for native delayed delivery to work properly.\\n'\n-                'If quorum queues are used, this task may block the worker process until the ETA arrives.'\n-            )\n+\n+        if (eta or countdown) and detect_quorum_queues(self, driver_type)[0]:",
      "comment": "And it was done in purpose only once after the `eta or coundtown` condition, since we don't need to run this `detect_quorum_queues` function at all, if no `eta` and no `countdown` is used. ",
      "comment_id": 2072929901,
      "user": "bityob",
      "created_at": "2025-05-05T07:00:00Z",
      "url": "https://github.com/celery/celery/pull/9686#discussion_r2072929901"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9494,
      "file_path": "celery/utils/term.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -165,7 +167,7 @@ def __add__(self, other: object) -> str:\n \n \n def supports_images() -> bool:\n-    return sys.stdin.isatty() and ITERM_PROFILE is not None\n+    return isatty(sys.stdin) and ITERM_PROFILE is not None",
      "comment": "```suggestion\r\n    \r\n    try:\r\n        return sys.stdin.isatty() and ITERM_PROFILE\r\n    except AttributeError:\r\n        pass\r\n```",
      "comment_id": 1916049255,
      "user": "auvipy",
      "created_at": "2025-01-15T07:20:37Z",
      "url": "https://github.com/celery/celery/pull/9494#discussion_r1916049255"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9494,
      "file_path": "celery/utils/term.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -165,7 +165,11 @@ def __add__(self, other: object) -> str:\n \n \n def supports_images() -> bool:\n-    return sys.stdin.isatty() and ITERM_PROFILE is not None\n+\n+    try:",
      "comment": "@Nusnus except this part was little bit changed from a suggestion in the report for the revert",
      "comment_id": 1953767573,
      "user": "auvipy",
      "created_at": "2025-02-13T03:57:53Z",
      "url": "https://github.com/celery/celery/pull/9494#discussion_r1953767573"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9552,
      "file_path": "celery/app/base.py",
      "line": 835,
      "side": "RIGHT",
      "diff_hunk": "@@ -832,8 +832,8 @@ def send_task(self, name, args=None, kwargs=None, countdown=None,\n         options = router.route(\n             options, route_name or name, args, kwargs, task_type)\n \n-        is_native_delayed_delivery = detect_quorum_queues(self,\n-                                                          self.producer_pool.connections.connection.transport_cls)[0]\n+        driver_type = self.producer_pool.connections.connection.transport.driver_type",
      "comment": "is it possible to add additional Integration tests for the change?",
      "comment_id": 1947463869,
      "user": "auvipy",
      "created_at": "2025-02-08T04:31:22Z",
      "url": "https://github.com/celery/celery/pull/9552#discussion_r1947463869"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9551,
      "file_path": "celery/schedules.py",
      "line": 560,
      "side": "RIGHT",
      "diff_hunk": "@@ -555,7 +557,7 @@ def roll_over() -> None:\n     def __repr__(self) -> str:\n         return CRON_REPR.format(self)\n \n-    def __reduce__(self) -> tuple[type, tuple[str, str, str, str, str], Any]:\n+    def __reduce__(self) -> tuple[type, tuple[Cronspec, Cronspec, Cronspec, Cronspec, Cronspec], Any]:",
      "comment": "should we update/add additional tests to verify this changes?",
      "comment_id": 1947460943,
      "user": "auvipy",
      "created_at": "2025-02-08T04:12:51Z",
      "url": "https://github.com/celery/celery/pull/9551#discussion_r1947460943"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9551,
      "file_path": "celery/schedules.py",
      "line": 560,
      "side": "RIGHT",
      "diff_hunk": "@@ -555,7 +557,7 @@ def roll_over() -> None:\n     def __repr__(self) -> str:\n         return CRON_REPR.format(self)\n \n-    def __reduce__(self) -> tuple[type, tuple[str, str, str, str, str], Any]:\n+    def __reduce__(self) -> tuple[type, tuple[Cronspec, Cronspec, Cronspec, Cronspec, Cronspec], Any]:",
      "comment": "since no actual logic has changed (only type annotations), i personally don't see a reason to change any tests.\r\n\r\nfor what it's worth, i was prompted to change this method signature because mypy failed CI. so in a way, it is already being tested by mypy.",
      "comment_id": 1950347526,
      "user": "pcrock-thmdo",
      "created_at": "2025-02-11T07:19:40Z",
      "url": "https://github.com/celery/celery/pull/9551#discussion_r1950347526"
    },
    {
      "repo": "celery/celery",
      "pr_number": 6298,
      "file_path": "celery/backends/database/session.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +55,26 @@ def create_session(self, dburi, short_lived_sessions=False, **kwargs):\n \n     def prepare_models(self, engine):\n         if not self.prepared:\n-            ResultModelBase.metadata.create_all(engine)\n+            # SQLAlchemy will check if the items exist before trying to\n+            # create them, which is a race condition. If it raises an error\n+            # in one iteration, the next may pass all the existence checks\n+            # and the call will succeed.\n+            max_retries = 10\n+            retries = 0\n+            while True:\n+                try:\n+                    ResultModelBase.metadata.create_all(engine)",
      "comment": "So subsequent calls to `.create_all` will succeed, even if the schema has been already created?",
      "comment_id": 491479502,
      "user": "georgepsarakis",
      "created_at": "2020-09-19T18:14:17Z",
      "url": "https://github.com/celery/celery/pull/6298#discussion_r491479502"
    },
    {
      "repo": "celery/celery",
      "pr_number": 6298,
      "file_path": "celery/backends/database/session.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +55,26 @@ def create_session(self, dburi, short_lived_sessions=False, **kwargs):\n \n     def prepare_models(self, engine):\n         if not self.prepared:\n-            ResultModelBase.metadata.create_all(engine)\n+            # SQLAlchemy will check if the items exist before trying to\n+            # create them, which is a race condition. If it raises an error\n+            # in one iteration, the next may pass all the existence checks\n+            # and the call will succeed.\n+            max_retries = 10\n+            retries = 0\n+            while True:\n+                try:\n+                    ResultModelBase.metadata.create_all(engine)",
      "comment": "Yes, which is currently what happens since each celery worker calls `.create_all` unconditionally. See the checkfirst arg [in the docs](https://docs.sqlalchemy.org/en/13/core/metadata.html#sqlalchemy.schema.MetaData.create_all).",
      "comment_id": 496912749,
      "user": "RazerM",
      "created_at": "2020-09-29T17:25:12Z",
      "url": "https://github.com/celery/celery/pull/6298#discussion_r496912749"
    },
    {
      "repo": "celery/celery",
      "pr_number": 6298,
      "file_path": "celery/backends/database/session.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +55,26 @@ def create_session(self, dburi, short_lived_sessions=False, **kwargs):\n \n     def prepare_models(self, engine):\n         if not self.prepared:\n-            ResultModelBase.metadata.create_all(engine)\n+            # SQLAlchemy will check if the items exist before trying to\n+            # create them, which is a race condition. If it raises an error\n+            # in one iteration, the next may pass all the existence checks\n+            # and the call will succeed.\n+            max_retries = 10",
      "comment": "I've made this a constant so that the test can see it",
      "comment_id": 496940287,
      "user": "RazerM",
      "created_at": "2020-09-29T18:10:20Z",
      "url": "https://github.com/celery/celery/pull/6298#discussion_r496940287"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9302,
      "file_path": "celery/backends/gcs.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -139,3 +155,198 @@ def _params_from_url(self):\n             'gcs_base_path': url_parts.path,\n             **url_parts.query,\n         }\n+\n+\n+class GCSBackend(GCSBackendBase):\n+    \"\"\"Google Cloud Storage task result backend.\n+\n+    Uses Firestore for chord ref count.\n+    \"\"\"\n+\n+    implements_incr = True\n+    supports_native_join = True\n+\n+    # Firestore parameters\n+    _collection_name = 'celery'\n+    _field_count = 'chord_count'\n+    _field_expires = 'expires_at'\n+\n+    def __init__(self, **kwargs):\n+        if not (firestore and firestore_admin_v1):\n+            raise ImproperlyConfigured(\n+                'You must install google-cloud-firestore to use gcs backend'\n+            )\n+        super().__init__(**kwargs)\n+\n+        self._firestore_lock = RLock()\n+        self._firestore_client = None\n+\n+        self.firestore_project = self.app.conf.get(\n+            'firestore_project', self.project\n+        )\n+        if not self._is_firestore_ttl_policy_enabled():",
      "comment": "Why do you assume that a TTL is desired when the user may have set `ttl=0` (like I have done)?",
      "comment_id": 2058646547,
      "user": "benglewis",
      "created_at": "2025-04-24T14:54:51Z",
      "url": "https://github.com/celery/celery/pull/9302#discussion_r2058646547"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9302,
      "file_path": "t/unit/backends/test_gcs.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,13 +1,24 @@\n-from datetime import datetime\n-from unittest.mock import Mock, call, patch\n+import sys\n+from datetime import datetime, timedelta\n+from unittest.mock import MagicMock, Mock, call, patch\n \n import pytest\n from google.cloud.exceptions import NotFound\n \n-from celery.backends.gcs import GCSBackend\n from celery.exceptions import ImproperlyConfigured\n \n+# Workaround until python-firestore is fixed\n+is_py313 = sys.version_info >= (3, 13)\n+if not is_py313:\n+    from celery.backends.gcs import GCSBackend\n+else:\n+    GCSBackend = None\n \n+\n+@pytest.mark.skipif(\n+    is_py313,\n+    reason=\"https://github.com/googleapis/python-firestore/issues/973\",",
      "comment": "Looking at this linked issue, it has now been fixed in the upstream. I would like to be able to upgrade to Python 3.13 without being unable to the GCS backend.\r\n\r\nI would be happy to fix this alongside the other issues that I have noted above",
      "comment_id": 2058651110,
      "user": "benglewis",
      "created_at": "2025-04-24T14:56:53Z",
      "url": "https://github.com/celery/celery/pull/9302#discussion_r2058651110"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9302,
      "file_path": "celery/backends/gcs.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -139,3 +155,198 @@ def _params_from_url(self):\n             'gcs_base_path': url_parts.path,\n             **url_parts.query,\n         }\n+\n+\n+class GCSBackend(GCSBackendBase):\n+    \"\"\"Google Cloud Storage task result backend.\n+\n+    Uses Firestore for chord ref count.\n+    \"\"\"\n+\n+    implements_incr = True\n+    supports_native_join = True\n+\n+    # Firestore parameters\n+    _collection_name = 'celery'\n+    _field_count = 'chord_count'\n+    _field_expires = 'expires_at'\n+\n+    def __init__(self, **kwargs):\n+        if not (firestore and firestore_admin_v1):\n+            raise ImproperlyConfigured(\n+                'You must install google-cloud-firestore to use gcs backend'\n+            )\n+        super().__init__(**kwargs)\n+\n+        self._firestore_lock = RLock()\n+        self._firestore_client = None\n+\n+        self.firestore_project = self.app.conf.get(\n+            'firestore_project', self.project\n+        )\n+        if not self._is_firestore_ttl_policy_enabled():",
      "comment": "this is a Firestore TTL,  not the GCS ttl. If it won't be set - then all chord ref keys will remain and not cleaned up. \r\nthe `ttl` is for the GCS results to expire. See my prev. comment re the native chord implementation",
      "comment_id": 2058848553,
      "user": "haimjether",
      "created_at": "2025-04-24T16:39:58Z",
      "url": "https://github.com/celery/celery/pull/9302#discussion_r2058848553"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9302,
      "file_path": "t/unit/backends/test_gcs.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,13 +1,24 @@\n-from datetime import datetime\n-from unittest.mock import Mock, call, patch\n+import sys\n+from datetime import datetime, timedelta\n+from unittest.mock import MagicMock, Mock, call, patch\n \n import pytest\n from google.cloud.exceptions import NotFound\n \n-from celery.backends.gcs import GCSBackend\n from celery.exceptions import ImproperlyConfigured\n \n+# Workaround until python-firestore is fixed\n+is_py313 = sys.version_info >= (3, 13)\n+if not is_py313:\n+    from celery.backends.gcs import GCSBackend\n+else:\n+    GCSBackend = None\n \n+\n+@pytest.mark.skipif(\n+    is_py313,\n+    reason=\"https://github.com/googleapis/python-firestore/issues/973\",",
      "comment": "You can upgrade to Python 3.13, without the GCS. Does that help ?\n\nOr did you mean that you are  planning to use Celery with GCS and Pub/Sub with Python 3.13 ?",
      "comment_id": 2058860279,
      "user": "haimjether",
      "created_at": "2025-04-24T16:48:26Z",
      "url": "https://github.com/celery/celery/pull/9302#discussion_r2058860279"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9302,
      "file_path": "t/unit/backends/test_gcs.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,13 +1,24 @@\n-from datetime import datetime\n-from unittest.mock import Mock, call, patch\n+import sys\n+from datetime import datetime, timedelta\n+from unittest.mock import MagicMock, Mock, call, patch\n \n import pytest\n from google.cloud.exceptions import NotFound\n \n-from celery.backends.gcs import GCSBackend\n from celery.exceptions import ImproperlyConfigured\n \n+# Workaround until python-firestore is fixed\n+is_py313 = sys.version_info >= (3, 13)\n+if not is_py313:\n+    from celery.backends.gcs import GCSBackend\n+else:\n+    GCSBackend = None\n \n+\n+@pytest.mark.skipif(\n+    is_py313,\n+    reason=\"https://github.com/googleapis/python-firestore/issues/973\",",
      "comment": "I have opened a PR https://github.com/celery/celery/pull/9677 to fix this issue of testing python 3.13",
      "comment_id": 2062570098,
      "user": "auvipy",
      "created_at": "2025-04-27T09:04:55Z",
      "url": "https://github.com/celery/celery/pull/9302#discussion_r2062570098"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9657,
      "file_path": "t/unit/worker/test_native_delayed_delivery.py",
      "line": 90,
      "side": "LEFT",
      "diff_hunk": "@@ -74,26 +74,36 @@ def test_start_native_delayed_delivery_fanout_exchange(self, caplog):\n \n         assert len(caplog.records) == 0\n \n-    def test_validate_broker_urls_empty(self):\n+    @pytest.mark.parametrize(\n+        \"broker_urls, expected_result\",\n+        [\n+            (\"amqp://\", {\"amqp://\"}),\n+            (\"amqp://;redis://\", {\"amqp://\", \"redis://\"}),\n+            (\n+                [\"amqp://\", \"redis://\", \"sqs://\"],\n+                {\"amqp://\", \"redis://\", \"sqs://\"},\n+            ),\n+        ],\n+    )\n+    def test_validate_broker_urls_valid(self, broker_urls, expected_result):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(\"\")\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(None)\n-\n-    def test_validate_broker_urls_invalid(self):\n+        urls = delayed_delivery._validate_broker_urls(broker_urls)\n+        assert urls == expected_result\n+\n+    @pytest.mark.parametrize(\n+        \"broker_urls, exception_type, exception_match\",\n+        [\n+            (\"\", ValueError, \"broker_url configuration is empty\"),\n+            (None, ValueError, \"broker_url configuration is empty\"),\n+            ([], ValueError, \"broker_url configuration is empty\"),\n+            (123, ValueError, \"broker_url must be a string or list\"),\n+            ([\"amqp://\", 123, None, \"amqp://\"], ValueError, \"All broker URLs must be strings\"),\n+        ],\n+    )\n+    def test_validate_broker_urls_invalid(self, broker_urls, exception_type, exception_match):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"No valid broker URLs found in configuration\"):\n-            delayed_delivery._validate_broker_urls(\"  ;  ;  \")",
      "comment": "I think this test case for multiple empty broker URLs would begin failing with the hotfixed code.  Could we retain it in the parametrized tests?",
      "comment_id": 2029010333,
      "user": "jayaddison",
      "created_at": "2025-04-04T15:15:03Z",
      "url": "https://github.com/celery/celery/pull/9657#discussion_r2029010333"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9657,
      "file_path": "t/unit/worker/test_native_delayed_delivery.py",
      "line": 90,
      "side": "LEFT",
      "diff_hunk": "@@ -74,26 +74,36 @@ def test_start_native_delayed_delivery_fanout_exchange(self, caplog):\n \n         assert len(caplog.records) == 0\n \n-    def test_validate_broker_urls_empty(self):\n+    @pytest.mark.parametrize(\n+        \"broker_urls, expected_result\",\n+        [\n+            (\"amqp://\", {\"amqp://\"}),\n+            (\"amqp://;redis://\", {\"amqp://\", \"redis://\"}),\n+            (\n+                [\"amqp://\", \"redis://\", \"sqs://\"],\n+                {\"amqp://\", \"redis://\", \"sqs://\"},\n+            ),\n+        ],\n+    )\n+    def test_validate_broker_urls_valid(self, broker_urls, expected_result):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(\"\")\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(None)\n-\n-    def test_validate_broker_urls_invalid(self):\n+        urls = delayed_delivery._validate_broker_urls(broker_urls)\n+        assert urls == expected_result\n+\n+    @pytest.mark.parametrize(\n+        \"broker_urls, exception_type, exception_match\",\n+        [\n+            (\"\", ValueError, \"broker_url configuration is empty\"),\n+            (None, ValueError, \"broker_url configuration is empty\"),\n+            ([], ValueError, \"broker_url configuration is empty\"),\n+            (123, ValueError, \"broker_url must be a string or list\"),\n+            ([\"amqp://\", 123, None, \"amqp://\"], ValueError, \"All broker URLs must be strings\"),\n+        ],\n+    )\n+    def test_validate_broker_urls_invalid(self, broker_urls, exception_type, exception_match):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"No valid broker URLs found in configuration\"):\n-            delayed_delivery._validate_broker_urls(\"  ;  ;  \")",
      "comment": "I've prepared a branch with a possible fixup - please let me know whether a PR for this would be welcome.",
      "comment_id": 2029049396,
      "user": "jayaddison",
      "created_at": "2025-04-04T15:38:12Z",
      "url": "https://github.com/celery/celery/pull/9657#discussion_r2029049396"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9657,
      "file_path": "t/unit/worker/test_native_delayed_delivery.py",
      "line": 90,
      "side": "LEFT",
      "diff_hunk": "@@ -74,26 +74,36 @@ def test_start_native_delayed_delivery_fanout_exchange(self, caplog):\n \n         assert len(caplog.records) == 0\n \n-    def test_validate_broker_urls_empty(self):\n+    @pytest.mark.parametrize(\n+        \"broker_urls, expected_result\",\n+        [\n+            (\"amqp://\", {\"amqp://\"}),\n+            (\"amqp://;redis://\", {\"amqp://\", \"redis://\"}),\n+            (\n+                [\"amqp://\", \"redis://\", \"sqs://\"],\n+                {\"amqp://\", \"redis://\", \"sqs://\"},\n+            ),\n+        ],\n+    )\n+    def test_validate_broker_urls_valid(self, broker_urls, expected_result):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(\"\")\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(None)\n-\n-    def test_validate_broker_urls_invalid(self):\n+        urls = delayed_delivery._validate_broker_urls(broker_urls)\n+        assert urls == expected_result\n+\n+    @pytest.mark.parametrize(\n+        \"broker_urls, exception_type, exception_match\",\n+        [\n+            (\"\", ValueError, \"broker_url configuration is empty\"),\n+            (None, ValueError, \"broker_url configuration is empty\"),\n+            ([], ValueError, \"broker_url configuration is empty\"),\n+            (123, ValueError, \"broker_url must be a string or list\"),\n+            ([\"amqp://\", 123, None, \"amqp://\"], ValueError, \"All broker URLs must be strings\"),\n+        ],\n+    )\n+    def test_validate_broker_urls_invalid(self, broker_urls, exception_type, exception_match):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"No valid broker URLs found in configuration\"):\n-            delayed_delivery._validate_broker_urls(\"  ;  ;  \")",
      "comment": "@jayaddison \r\n> I think this test case for multiple empty broker URLs would begin failing with the hotfixed code. Could we retain it in the parametrized tests?\r\n\r\nTechnically you\u2019re right. The `\"  ;  ;  \u201c` test case _will_ fail.\r\nThat being said, an empty `broker_url` will default to `amqp` automatically so these cases _should never happen_. I did add some checks because we know that things that shouldn\u2019t happen do happen, but this is a very rare edge case (`\"  ;  ;  \u201c`).\r\n\r\nThese tests ensure that the private helper method covers the basic input cases, but the delayed delivery feature is not responsible for the broker URL\u2019s validity.\r\n\r\nI\u2019ve removed the use of `strip` to make the broker validation just a bit more flexible to balance basic checks with not taking full responsibility over `broker_url`.\r\n\r\n> I've prepared a branch with a possible fixup - please let me know whether a PR for this would be welcome.\r\n\r\nDo you want to share briefly what is your suggested change to make sure we\u2019re aligned before opening a PR?\r\nI don\u2019t mind improving the coverage as long as we keep it simple.\r\n\r\nThank you!",
      "comment_id": 2029122810,
      "user": "Nusnus",
      "created_at": "2025-04-04T16:33:28Z",
      "url": "https://github.com/celery/celery/pull/9657#discussion_r2029122810"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9657,
      "file_path": "t/unit/worker/test_native_delayed_delivery.py",
      "line": 90,
      "side": "LEFT",
      "diff_hunk": "@@ -74,26 +74,36 @@ def test_start_native_delayed_delivery_fanout_exchange(self, caplog):\n \n         assert len(caplog.records) == 0\n \n-    def test_validate_broker_urls_empty(self):\n+    @pytest.mark.parametrize(\n+        \"broker_urls, expected_result\",\n+        [\n+            (\"amqp://\", {\"amqp://\"}),\n+            (\"amqp://;redis://\", {\"amqp://\", \"redis://\"}),\n+            (\n+                [\"amqp://\", \"redis://\", \"sqs://\"],\n+                {\"amqp://\", \"redis://\", \"sqs://\"},\n+            ),\n+        ],\n+    )\n+    def test_validate_broker_urls_valid(self, broker_urls, expected_result):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(\"\")\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(None)\n-\n-    def test_validate_broker_urls_invalid(self):\n+        urls = delayed_delivery._validate_broker_urls(broker_urls)\n+        assert urls == expected_result\n+\n+    @pytest.mark.parametrize(\n+        \"broker_urls, exception_type, exception_match\",\n+        [\n+            (\"\", ValueError, \"broker_url configuration is empty\"),\n+            (None, ValueError, \"broker_url configuration is empty\"),\n+            ([], ValueError, \"broker_url configuration is empty\"),\n+            (123, ValueError, \"broker_url must be a string or list\"),\n+            ([\"amqp://\", 123, None, \"amqp://\"], ValueError, \"All broker URLs must be strings\"),\n+        ],\n+    )\n+    def test_validate_broker_urls_invalid(self, broker_urls, exception_type, exception_match):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"No valid broker URLs found in configuration\"):\n-            delayed_delivery._validate_broker_urls(\"  ;  ;  \")",
      "comment": "Thanks @Nusnus!\r\n\r\n> > I think this test case for multiple empty broker URLs would begin failing with the hotfixed code. Could we retain it in the parametrized tests?\r\n> \r\n> Technically you\u2019re right. The `\" ; ; \u201c` test case _will_ fail. That being said, an empty `broker_url` will default to `amqp` automatically so these cases _should never happen_. I did add some checks because we know that things that shouldn\u2019t happen do happen, but this is a very rare edge case (`\" ; ; \u201c`).\r\n\r\nI mostly agree - my line of thinking is that if there was a form of misconfiguration we could previously detect early, then let's continue to do that.\r\n \r\n> These tests ensure that the private helper method covers the basic input cases, but the delayed delivery feature is not responsible for the broker URL\u2019s validity.\r\n\r\n:+1: \r\n\r\n> I\u2019ve removed the use of `strip` to make the broker validation just a bit more flexible to balance basic checks with not taking full responsibility over `broker_url`.\r\n> \r\n> > I've prepared a branch with a possible fixup - please let me know whether a PR for this would be welcome.\r\n> \r\n> Do you want to share briefly what is your suggested change to make sure we\u2019re aligned before opening a PR? I don\u2019t mind improving the coverage as long as we keep it simple.\r\n\r\nThe two modifications I'd suggest - both small are:\r\n\r\n  * Test coverage: restoring the `\"  ;  ;  \"` case into the parameterized tests (confirming the problem).\r\n  * Code fixup: restoring the `if url.strip()` conditions into the list comprehension (restoring the previous safety mechanism).",
      "comment_id": 2029134571,
      "user": "jayaddison",
      "created_at": "2025-04-04T16:42:48Z",
      "url": "https://github.com/celery/celery/pull/9657#discussion_r2029134571"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9657,
      "file_path": "t/unit/worker/test_native_delayed_delivery.py",
      "line": 90,
      "side": "LEFT",
      "diff_hunk": "@@ -74,26 +74,36 @@ def test_start_native_delayed_delivery_fanout_exchange(self, caplog):\n \n         assert len(caplog.records) == 0\n \n-    def test_validate_broker_urls_empty(self):\n+    @pytest.mark.parametrize(\n+        \"broker_urls, expected_result\",\n+        [\n+            (\"amqp://\", {\"amqp://\"}),\n+            (\"amqp://;redis://\", {\"amqp://\", \"redis://\"}),\n+            (\n+                [\"amqp://\", \"redis://\", \"sqs://\"],\n+                {\"amqp://\", \"redis://\", \"sqs://\"},\n+            ),\n+        ],\n+    )\n+    def test_validate_broker_urls_valid(self, broker_urls, expected_result):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(\"\")\n-\n-        with pytest.raises(ValueError, match=\"broker_url configuration is empty\"):\n-            delayed_delivery._validate_broker_urls(None)\n-\n-    def test_validate_broker_urls_invalid(self):\n+        urls = delayed_delivery._validate_broker_urls(broker_urls)\n+        assert urls == expected_result\n+\n+    @pytest.mark.parametrize(\n+        \"broker_urls, exception_type, exception_match\",\n+        [\n+            (\"\", ValueError, \"broker_url configuration is empty\"),\n+            (None, ValueError, \"broker_url configuration is empty\"),\n+            ([], ValueError, \"broker_url configuration is empty\"),\n+            (123, ValueError, \"broker_url must be a string or list\"),\n+            ([\"amqp://\", 123, None, \"amqp://\"], ValueError, \"All broker URLs must be strings\"),\n+        ],\n+    )\n+    def test_validate_broker_urls_invalid(self, broker_urls, exception_type, exception_match):\n         delayed_delivery = DelayedDelivery(Mock())\n-\n-        with pytest.raises(ValueError, match=\"No valid broker URLs found in configuration\"):\n-            delayed_delivery._validate_broker_urls(\"  ;  ;  \")",
      "comment": "@jayaddison \r\n> The two modifications I'd suggest - both small are:\r\n> \r\n> * Test coverage: restoring the `\"  ;  ;  \"` case into the parameterized tests (confirming the problem).\r\n> * Code fixup: restoring the `if url.strip()` conditions into the list comprehension (restoring the previous safety mechanism).\r\n\r\nI think it\u2019ll be better to have a proper global verification method, maybe in Kombu even, and then make sure it is fully covered for every edge case including the rare and exotics and use it here instead.\r\n\r\nFor now we needed a quick hotfix for the linked bug so I left the `strip`ing issue for another time.",
      "comment_id": 2029215792,
      "user": "Nusnus",
      "created_at": "2025-04-04T17:44:26Z",
      "url": "https://github.com/celery/celery/pull/9657#discussion_r2029215792"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9021,
      "file_path": "celery/canvas.py",
      "line": 977,
      "side": "RIGHT",
      "diff_hunk": "@@ -975,8 +975,7 @@ def __or__(self, other):\n         elif isinstance(other, _chain):\n             # chain | chain -> chain\n             # use type(self) for _chain subclasses",
      "comment": "```suggestion\r\n```\r\n\r\nSeems like this comment is no longer relevant.",
      "comment_id": 1598759485,
      "user": "pencil",
      "created_at": "2024-05-13T16:39:03Z",
      "url": "https://github.com/celery/celery/pull/9021#discussion_r1598759485"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9361,
      "file_path": "celery/bin/celery.py",
      "line": 135,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,7 +130,26 @@ def celery(ctx, app, broker, result_backend, loader, config, workdir,\n         os.environ['CELERY_CONFIG_MODULE'] = config\n     if skip_checks:\n         os.environ['CELERY_SKIP_CHECKS'] = 'true'\n-    ctx.obj = CLIContext(app=app, no_color=no_color, workdir=workdir,\n+\n+    try:\n+        app_object = find_app(app)",
      "comment": "This line crashes in our celery application from `5.5.0rc2`. As our application worked with `rc1` I'm wondering if this is a bug (i.e. worth opening an issue) or some mistake in our startup procedure. What do you think @Nusnus? \r\n\r\n```\r\ncelery_app = Celery(\"modulename\") \r\n...\r\ncelery_app.worker_main(argv)\r\n# calls celery_app.start() > celery.main() > celery(...) > find_app(app)\r\n\r\nTraceback (most recent call last):\r\n  File \".../lib/python3.12/site-packages/celery/bin/celery.py\", line 135, in celery\r\n    app_object = find_app(app)\r\n                 ^^^^^^^^^^^^^\r\n  File \".../lib/python3.12/site-packages/celery/app/utils.py\", line 383, in find_app\r\n    sym = symbol_by_name(app, imp=imp)\r\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../lib/python3.12/site-packages/kombu/utils/imports.py\", line 59, in symbol_by_name\r\n    module = imp(module_name, package=package, **kwargs)\r\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \".../lib/python3.12/site-packages/celery/utils/imports.py\", line 109, in import_from_cwd\r\n    return imp(module, package=package)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/opt/homebrew/Cellar/python@3.12/3.12.7_1/Frameworks/Python.framework/Versions/3.12/lib/python3.12/importlib/__init__.py\", line 90, in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<frozen importlib._bootstrap>\", line 1387, in _gcd_import\r\n  File \"<frozen importlib._bootstrap>\", line 1360, in _find_and_load\r\n  File \"<frozen importlib._bootstrap>\", line 1324, in _find_and_load_unlocked\r\nModuleNotFoundError: No module named '<Celery modulename at 0x...>'\r\n```\r\n",
      "comment_id": 1850451189,
      "user": "david-elias-kuenstle-webcom",
      "created_at": "2024-11-20T14:47:42Z",
      "url": "https://github.com/celery/celery/pull/9361#discussion_r1850451189"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9361,
      "file_path": "celery/bin/celery.py",
      "line": 135,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,7 +130,26 @@ def celery(ctx, app, broker, result_backend, loader, config, workdir,\n         os.environ['CELERY_CONFIG_MODULE'] = config\n     if skip_checks:\n         os.environ['CELERY_SKIP_CHECKS'] = 'true'\n-    ctx.obj = CLIContext(app=app, no_color=no_color, workdir=workdir,\n+\n+    try:\n+        app_object = find_app(app)",
      "comment": "You're absolutely right, @david-elias-kuenstle-webcom! My bad, sorry. \ud83d\ude48 \r\n\r\n* Tentative fix at https://github.com/celery/celery/pull/9426 ",
      "comment_id": 1851284312,
      "user": "0x2b3bfa0",
      "created_at": "2024-11-21T04:05:12Z",
      "url": "https://github.com/celery/celery/pull/9361#discussion_r1851284312"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9271,
      "file_path": "t/smoke/conftest.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,6 +54,7 @@ def default_worker_tasks(default_worker_tasks: set) -> set:\n     network=\"{default_pytest_celery_network.name}\",\n     wrapper_class=RedisContainer,\n     timeout=REDIS_CONTAINER_TIMEOUT,\n+    command=fxtr(\"default_redis_broker_command\"),",
      "comment": "The `default_redis_broker_command` fixture configures Redis to boot with proper configurations.\r\nWithout it, the default config will collapse under the heavy use of the CI",
      "comment_id": 1760062104,
      "user": "Nusnus",
      "created_at": "2024-09-15T14:44:00Z",
      "url": "https://github.com/celery/celery/pull/9271#discussion_r1760062104"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9247,
      "file_path": "t/unit/utils/test_dispatcher.py",
      "line": 188,
      "side": "LEFT",
      "diff_hunk": "@@ -185,7 +183,6 @@ def test_boundmethod(self):\n         garbage_collect()\n         self._testIsClean(a_signal)\n \n-    @pytest.mark.xfail(reason=\"Issue #9119\")",
      "comment": "so the test is passing with the proposed change in this PR?",
      "comment_id": 1751722326,
      "user": "auvipy",
      "created_at": "2024-09-10T10:49:12Z",
      "url": "https://github.com/celery/celery/pull/9247#discussion_r1751722326"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9246,
      "file_path": "celery/app/task.py",
      "line": 546,
      "side": "RIGHT",
      "diff_hunk": "@@ -543,8 +543,8 @@ def apply_async(self, args=None, kwargs=None, task_id=None, producer=None,\n             TypeError: If not enough arguments are passed, or too many\n                 arguments are passed.  Note that signature checks may\n                 be disabled by specifying ``@task(typing=False)``.\n-            ValueError: If soft_time_limit and time_limit are set,\n-                and soft_time_limit is less than time_limit\n+            ValueError: If soft_time_limit and time_limit both set",
      "comment": "```suggestion\r\n            ValueError: If soft_time_limit and time_limit both are set\r\n```",
      "comment_id": 1750241415,
      "user": "auvipy",
      "created_at": "2024-09-09T13:15:59Z",
      "url": "https://github.com/celery/celery/pull/9246#discussion_r1750241415"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9227,
      "file_path": "celery/worker/consumer/consumer.py",
      "line": 511,
      "side": "RIGHT",
      "diff_hunk": "@@ -505,13 +505,14 @@ def _error_handler(exc, interval, next_step=CONNECTION_RETRY_STEP):\n             # to determine whether connection retries are disabled.\n             retry_disabled = not self.app.conf.broker_connection_retry\n \n-            warnings.warn(\n-                CPendingDeprecationWarning(\n-                    f\"The broker_connection_retry configuration setting will no longer determine\\n\"\n-                    f\"whether broker connection retries are made during startup in Celery 6.0 and above.\\n\"\n-                    f\"If you wish to retain the existing behavior for retrying connections on startup,\\n\"\n-                    f\"you should set broker_connection_retry_on_startup to {self.app.conf.broker_connection_retry}.\")\n-            )\n+            if retry_disabled:\n+                warnings.warn(\n+                    CPendingDeprecationWarning(\n+                        \"The broker_connection_retry configuration setting will no longer determine\\n\"",
      "comment": "should we keep using the f\"string\" here as before?",
      "comment_id": 1745017645,
      "user": "auvipy",
      "created_at": "2024-09-05T08:15:23Z",
      "url": "https://github.com/celery/celery/pull/9227#discussion_r1745017645"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9227,
      "file_path": "celery/worker/consumer/consumer.py",
      "line": 511,
      "side": "RIGHT",
      "diff_hunk": "@@ -505,13 +505,14 @@ def _error_handler(exc, interval, next_step=CONNECTION_RETRY_STEP):\n             # to determine whether connection retries are disabled.\n             retry_disabled = not self.app.conf.broker_connection_retry\n \n-            warnings.warn(\n-                CPendingDeprecationWarning(\n-                    f\"The broker_connection_retry configuration setting will no longer determine\\n\"\n-                    f\"whether broker connection retries are made during startup in Celery 6.0 and above.\\n\"\n-                    f\"If you wish to retain the existing behavior for retrying connections on startup,\\n\"\n-                    f\"you should set broker_connection_retry_on_startup to {self.app.conf.broker_connection_retry}.\")\n-            )\n+            if retry_disabled:\n+                warnings.warn(\n+                    CPendingDeprecationWarning(\n+                        \"The broker_connection_retry configuration setting will no longer determine\\n\"",
      "comment": "You mean with the `{self.app.conf.broker_connection_retry}`? I don't think so, given that I also changed \"retain the existing behavior\" to \"refrain from retrying connections\".\r\nActually, I copied the warning in the [doc](https://docs.celeryq.dev/en/stable/userguide/configuration.html#broker-connection-retry), I think having the exact same words here and there make a lot of sense\r\n\r\n(Or if you were just talking about the `f` before the `\"`, the linter complained about it being useless given that there's no variables inside anymore)",
      "comment_id": 1745042188,
      "user": "serl",
      "created_at": "2024-09-05T08:31:55Z",
      "url": "https://github.com/celery/celery/pull/9227#discussion_r1745042188"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9208,
      "file_path": "celery/app/task.py",
      "line": 1116,
      "side": "RIGHT",
      "diff_hunk": "@@ -1113,8 +1113,8 @@ def add_trail(self, result):\n             self.request.children.append(result)\n         return result\n \n-    def push_request(self, *args, **kwargs):\n-        self.request_stack.push(Context(*args, **kwargs))\n+    def push_request(self, **kwargs):",
      "comment": "I restored the args. \r\nIt is a bit misleading since args can only be a single dictionary otherwise it fails. \r\nI did not find any occurence using it like this, but I leave it in any case.",
      "comment_id": 1732395424,
      "user": "nikatlas",
      "created_at": "2024-08-27T08:37:00Z",
      "url": "https://github.com/celery/celery/pull/9208#discussion_r1732395424"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8385,
      "file_path": "celery/backends/base.py",
      "line": 463,
      "side": "RIGHT",
      "diff_hunk": "@@ -460,7 +460,7 @@ def _get_result_meta(self, result,\n                          state, traceback, request, format_date=True,\n                          encode=False):\n         if state in self.READY_STATES:\n-            date_done = datetime.utcnow()\n+            date_done = self.app.now()",
      "comment": "as this is understandable what the change is going to do, it is important to add or change existing tests to pass the test suit pass",
      "comment_id": 1271846939,
      "user": "auvipy",
      "created_at": "2023-07-24T07:18:26Z",
      "url": "https://github.com/celery/celery/pull/8385#discussion_r1271846939"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8385,
      "file_path": "celery/backends/base.py",
      "line": 463,
      "side": "RIGHT",
      "diff_hunk": "@@ -460,7 +460,7 @@ def _get_result_meta(self, result,\n                          state, traceback, request, format_date=True,\n                          encode=False):\n         if state in self.READY_STATES:\n-            date_done = datetime.utcnow()\n+            date_done = self.app.now()",
      "comment": "+1 -- https://docs.python.org/3/library/datetime.html#datetime.datetime.utcnow is deprecated in Python 3.12",
      "comment_id": 1426410379,
      "user": "cclauss",
      "created_at": "2023-12-14T08:45:16Z",
      "url": "https://github.com/celery/celery/pull/8385#discussion_r1426410379"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8385,
      "file_path": "t/unit/tasks/test_result.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,13 +3,15 @@\n import platform\n import traceback\n from contextlib import contextmanager\n+from unittest import mock\n from unittest.mock import Mock, call, patch\n+from zoneinfo import ZoneInfo",
      "comment": "https://docs.python.org/3/library/zoneinfo.html was added to the Standard Library in Python 3.9.\r\n\r\nhttps://pypi.org/project/backports.zoneinfo could be installed ___conditionally___ on Python < v3.9.",
      "comment_id": 1730357954,
      "user": "cclauss",
      "created_at": "2024-08-25T13:50:12Z",
      "url": "https://github.com/celery/celery/pull/8385#discussion_r1730357954"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8385,
      "file_path": "t/unit/tasks/test_result.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,13 +3,15 @@\n import platform\n import traceback\n from contextlib import contextmanager\n+from unittest import mock\n from unittest.mock import Mock, call, patch\n+from zoneinfo import ZoneInfo",
      "comment": "> FAILED t/unit/tasks/test_result.py::test_AsyncResult::test_date_done[utc-2024-08-24T00:00:00+00:00] - zoneinfo._common.ZoneInfoNotFoundError: 'No time zone found with key utc'",
      "comment_id": 1730378612,
      "user": "cclauss",
      "created_at": "2024-08-25T15:09:48Z",
      "url": "https://github.com/celery/celery/pull/8385#discussion_r1730378612"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8385,
      "file_path": "t/unit/tasks/test_result.py",
      "line": 442,
      "side": "RIGHT",
      "diff_hunk": "@@ -434,17 +436,20 @@ def test_get_request_meta(self):\n         result = self.app.AsyncResult(self.task4['id'])\n         assert result.date_done is None\n \n-    @pytest.mark.parametrize('result_dict, date', [\n-        ({'date_done': None}, None),\n-        ({'date_done': '1991-10-05T05:41:06'},\n-         datetime.datetime(1991, 10, 5, 5, 41, 6)),\n-        ({'date_done': datetime.datetime(1991, 10, 5, 5, 41, 6)},\n-         datetime.datetime(1991, 10, 5, 5, 41, 6))\n+    @patch('celery.app.base.to_utc')\n+    @patch('celery.app.base.Celery.timezone', new_callable=mock.PropertyMock)\n+    @pytest.mark.parametrize('timezone, date', [\n+        (\"utc\", \"2024-08-24T00:00:00+00:00\"),",
      "comment": "```suggestion\r\n        (None, \"2024-08-24T00:00:00+00:00\"),\r\n```",
      "comment_id": 1730404735,
      "user": "cclauss",
      "created_at": "2024-08-25T18:03:17Z",
      "url": "https://github.com/celery/celery/pull/8385#discussion_r1730404735"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8385,
      "file_path": "t/unit/tasks/test_result.py",
      "line": 442,
      "side": "RIGHT",
      "diff_hunk": "@@ -434,17 +436,20 @@ def test_get_request_meta(self):\n         result = self.app.AsyncResult(self.task4['id'])\n         assert result.date_done is None\n \n-    @pytest.mark.parametrize('result_dict, date', [\n-        ({'date_done': None}, None),\n-        ({'date_done': '1991-10-05T05:41:06'},\n-         datetime.datetime(1991, 10, 5, 5, 41, 6)),\n-        ({'date_done': datetime.datetime(1991, 10, 5, 5, 41, 6)},\n-         datetime.datetime(1991, 10, 5, 5, 41, 6))\n+    @patch('celery.app.base.to_utc')\n+    @patch('celery.app.base.Celery.timezone', new_callable=mock.PropertyMock)\n+    @pytest.mark.parametrize('timezone, date', [\n+        (\"utc\", \"2024-08-24T00:00:00+00:00\"),",
      "comment": "My suggestion was incorrect.  Reverting.\r\n\r\n`\"UTC\"` or `\"utc\"` are acceptable keys for `zoneinfo.TimeZone(key)` but `None` is not.\r\n```\r\n>>> from zoneinfo import ZoneInfo\r\n>>> for s in (\"UTC\", \"utc\", None):\r\n...     print(ZoneInfo(s))\r\n...\r\nUTC\r\nutc\r\nTraceback (most recent call last):\r\n  ...\r\nTypeError: expected str, bytes or os.PathLike object, not NoneType\r\n```",
      "comment_id": 1732587163,
      "user": "cclauss",
      "created_at": "2024-08-27T10:34:22Z",
      "url": "https://github.com/celery/celery/pull/8385#discussion_r1732587163"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8385,
      "file_path": "t/unit/tasks/test_result.py",
      "line": 442,
      "side": "RIGHT",
      "diff_hunk": "@@ -434,17 +436,20 @@ def test_get_request_meta(self):\n         result = self.app.AsyncResult(self.task4['id'])\n         assert result.date_done is None\n \n-    @pytest.mark.parametrize('result_dict, date', [\n-        ({'date_done': None}, None),\n-        ({'date_done': '1991-10-05T05:41:06'},\n-         datetime.datetime(1991, 10, 5, 5, 41, 6)),\n-        ({'date_done': datetime.datetime(1991, 10, 5, 5, 41, 6)},\n-         datetime.datetime(1991, 10, 5, 5, 41, 6))\n+    @patch('celery.app.base.to_utc')\n+    @patch('celery.app.base.Celery.timezone', new_callable=mock.PropertyMock)\n+    @pytest.mark.parametrize('timezone, date', [\n+        (None, \"2024-08-24T00:00:00+00:00\"),",
      "comment": "```suggestion\r\n        (\"utc\", \"2024-08-24T00:00:00+00:00\"),\r\n```",
      "comment_id": 1732589232,
      "user": "cclauss",
      "created_at": "2024-08-27T10:35:59Z",
      "url": "https://github.com/celery/celery/pull/8385#discussion_r1732589232"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8385,
      "file_path": "t/unit/tasks/test_result.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,13 +3,15 @@\n import platform\n import traceback\n from contextlib import contextmanager\n+from unittest import mock\n from unittest.mock import Mock, call, patch\n+from zoneinfo import ZoneInfo",
      "comment": "In celery.utils.timezone.get_timezone, library branching occurs according to python version\r\nI suggest reseting the cache value of celery.app.base.timezone so that the function can be used",
      "comment_id": 1737267042,
      "user": "FKgk",
      "created_at": "2024-08-29T22:04:02Z",
      "url": "https://github.com/celery/celery/pull/8385#discussion_r1737267042"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9083,
      "file_path": "celery/concurrency/gevent.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,15 +17,22 @@\n # We cache globals and attribute lookups, so disable this warning.\n \n \n+def apply_target(target, args=(), kwargs=None, callback=None,\n+                 accept_callback=None, getpid=None, **_):\n+    kwargs = {} if not kwargs else kwargs\n+    return base.apply_target(target, args, kwargs, callback, accept_callback,\n+                             pid=getpid(), **_)\n+\n+\n def apply_timeout(target, args=(), kwargs=None, callback=None,\n-                  accept_callback=None, pid=None, timeout=None,\n+                  accept_callback=None, getpid=None, timeout=None,",
      "comment": "this will not introduce any breaking change, right?",
      "comment_id": 1703073746,
      "user": "auvipy",
      "created_at": "2024-08-04T06:06:13Z",
      "url": "https://github.com/celery/celery/pull/9083#discussion_r1703073746"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9083,
      "file_path": "celery/concurrency/gevent.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,15 +17,22 @@\n # We cache globals and attribute lookups, so disable this warning.\n \n \n+def apply_target(target, args=(), kwargs=None, callback=None,\n+                 accept_callback=None, getpid=None, **_):\n+    kwargs = {} if not kwargs else kwargs\n+    return base.apply_target(target, args, kwargs, callback, accept_callback,\n+                             pid=getpid(), **_)\n+\n+\n def apply_timeout(target, args=(), kwargs=None, callback=None,\n-                  accept_callback=None, pid=None, timeout=None,\n+                  accept_callback=None, getpid=None, timeout=None,",
      "comment": "`apply_timeout` called in `gevent.TaskPool.on_apply`, when set timeout use `apply_timeout` otherwise `apply_target`.\r\nThis modification keeps the parameters of the two functions consistent.\r\nFind usage did not find any external call.",
      "comment_id": 1703484109,
      "user": "ldsink",
      "created_at": "2024-08-05T02:59:18Z",
      "url": "https://github.com/celery/celery/pull/9083#discussion_r1703484109"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8965,
      "file_path": "celery/backends/dynamodb.py",
      "line": 158,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,6 +154,14 @@ def __init__(self, url=None, table_name=None, *args, **kwargs):\n                 secret_access_key=aws_secret_access_key\n             )\n \n+    @staticmethod\n+    def _is_valid_ip(ip):",
      "comment": "I wonder if that's the best way to check it.. or if it's worth delaying for \ud83e\udd14\n\nAnyway, should not be merged before v5.4 release. We're in RC2 at the moment.",
      "comment_id": 1564814298,
      "user": "Nusnus",
      "created_at": "2024-04-14T17:00:43Z",
      "url": "https://github.com/celery/celery/pull/8965#discussion_r1564814298"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8965,
      "file_path": "celery/backends/dynamodb.py",
      "line": 158,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,6 +154,14 @@ def __init__(self, url=None, table_name=None, *args, **kwargs):\n                 secret_access_key=aws_secret_access_key\n             )\n \n+    @staticmethod\n+    def _is_valid_ip(ip):",
      "comment": "I guess I could do \r\npattern = re.compile(r'^[a-z]{2}-[a-z]+-[0-9]{1}$')\r\n    if pattern.match(input_string):\r\n      do real dynamodb\r\n    else:\r\n      do local dynamodb\r\nif we trust the AWS region names keeps following the current format of xx-yyyy-n\r\nThat would also allow to use non ip hosts names.",
      "comment_id": 1564842863,
      "user": "peerjakobsen",
      "created_at": "2024-04-14T17:54:28Z",
      "url": "https://github.com/celery/celery/pull/8965#discussion_r1564842863"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "celery/backends/database/__init__.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -100,7 +101,15 @@ def __init__(self, dburi=None, engine_options=None, url=None, **kwargs):\n \n         self.session_manager = SessionManager()\n \n-        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\", False)\n+        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\", None)\n+        if create_tables_at_setup is None:\n+            create_tables_at_setup = False\n+            warn(\n+                \"configuration option `database_create_tables_at_setup` is not \"\n+                \"set, defaulting to False. Default value will change to True in \"\n+                \"celery 5.7\",",
      "comment": "```suggestion\r\n                \"celery 6.0 or later\",\r\n```",
      "comment_id": 1753823230,
      "user": "auvipy",
      "created_at": "2024-09-11T09:41:25Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1753823230"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "celery/backends/database/__init__.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,11 +99,31 @@ def __init__(self, dburi=None, engine_options=None, url=None, **kwargs):\n                 'Missing connection string! Do you have the'\n                 ' database_url setting set to a real value?')\n \n+        self.session_manager = SessionManager()\n+\n+        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\", None)",
      "comment": "Shouldn\u2019t there be a new conf in https://github.com/celery/celery/blob/ed546cde241ed2bf236043f0e904482b1f6fa2df/celery/app/defaults.py#L242 ?",
      "comment_id": 1753869245,
      "user": "Nusnus",
      "created_at": "2024-09-11T09:55:41Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1753869245"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "celery/backends/database/__init__.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,11 +99,31 @@ def __init__(self, dburi=None, engine_options=None, url=None, **kwargs):\n                 'Missing connection string! Do you have the'\n                 ' database_url setting set to a real value?')\n \n+        self.session_manager = SessionManager()\n+\n+        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\", None)",
      "comment": "I understand it works because if it doesn\u2019t exist it defaults to `False`.\r\nBut the better practice would be to add a new conf, set it explicitly to `False` in `defaults.py` and then use it here without `get()`.",
      "comment_id": 1753873644,
      "user": "Nusnus",
      "created_at": "2024-09-11T09:57:05Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1753873644"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "t/unit/backends/test_database.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,6 +82,8 @@ def test_table_schema_config(self):\n             'task': 'foo',\n             'group': 'bar',\n         }\n+        # disable table creation because databases foo and bar do not exist\n+        self.app.conf.database_create_tables_at_setup = False",
      "comment": "Per my previous [comment](https://github.com/celery/celery/pull/9228/files#r1753869245), this line will not be needed anymore",
      "comment_id": 1753878332,
      "user": "Nusnus",
      "created_at": "2024-09-11T09:58:29Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1753878332"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "celery/backends/database/__init__.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,11 +99,31 @@ def __init__(self, dburi=None, engine_options=None, url=None, **kwargs):\n                 'Missing connection string! Do you have the'\n                 ' database_url setting set to a real value?')\n \n+        self.session_manager = SessionManager()\n+\n+        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\", None)",
      "comment": "of course, it should definitely be here. I tried to search for places where configuration were defined by running a search against `database_short_lived_sessions` but now that I see how the namespace is defined, I understand why there was no match :)\r\n\r\nI'll do the required change",
      "comment_id": 1756753642,
      "user": "MarcBresson",
      "created_at": "2024-09-12T12:23:04Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1756753642"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "celery/backends/database/__init__.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,11 +99,31 @@ def __init__(self, dburi=None, engine_options=None, url=None, **kwargs):\n                 'Missing connection string! Do you have the'\n                 ' database_url setting set to a real value?')\n \n+        self.session_manager = SessionManager()\n+\n+        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\", None)",
      "comment": "How can I issue the warning now that the option is cast with type bool (in https://github.com/celery/celery/blob/ed546cde241ed2bf236043f0e904482b1f6fa2df/celery/app/defaults.py#L58-L59) ? I cannot use default value=None because its falsy, nor can I use type unions because they are not supported by Option class.\r\n\r\nAny tips ?\r\n\r\nI could raise the warning every time the option is set to False, but that seems quite extreme",
      "comment_id": 1756767757,
      "user": "MarcBresson",
      "created_at": "2024-09-12T12:32:11Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1756767757"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "celery/backends/database/__init__.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,11 +99,31 @@ def __init__(self, dburi=None, engine_options=None, url=None, **kwargs):\n                 'Missing connection string! Do you have the'\n                 ' database_url setting set to a real value?')\n \n+        self.session_manager = SessionManager()\n+\n+        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\", None)",
      "comment": "Let's see.. hmm, why do we even want this warning?\nYeah, we can define v6.0.0 will change defaults, but do we really care to warn the user about it, potentially every time?\n",
      "comment_id": 1759758531,
      "user": "Nusnus",
      "created_at": "2024-09-14T16:01:23Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1759758531"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "celery/backends/database/__init__.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,11 +99,31 @@ def __init__(self, dburi=None, engine_options=None, url=None, **kwargs):\n                 'Missing connection string! Do you have the'\n                 ' database_url setting set to a real value?')\n \n+        self.session_manager = SessionManager()\n+\n+        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\", None)",
      "comment": "- setting this option to False does nothing more compared to previous versions\r\n- we believe the default value should be True so we need to transition from False to True\r\n- to transition there are two ways I see :\r\n  - issue a warning stating the default will change in a future version\r\n  - change the default value to True in this branch and state the change in the change log. Setting this option to True probably has a low impact for users so it is a reasonable way to do it.\r\n\r\nDo you suggest we should follow the second way?",
      "comment_id": 1760653737,
      "user": "MarcBresson",
      "created_at": "2024-09-16T07:24:51Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1760653737"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "celery/backends/database/__init__.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,11 +99,31 @@ def __init__(self, dburi=None, engine_options=None, url=None, **kwargs):\n                 'Missing connection string! Do you have the'\n                 ' database_url setting set to a real value?')\n \n+        self.session_manager = SessionManager()\n+\n+        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\", None)",
      "comment": "> change the default value to True in this branch and state the change in the change log. Setting this option to True probably has a low impact for users so it is a reasonable way to do it.\r\n\r\nMakes sense.\r\nYou may proceed with the changes to the PR then.\r\n\r\nThanks ! @MarcBresson ",
      "comment_id": 1763740880,
      "user": "Nusnus",
      "created_at": "2024-09-17T18:53:41Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1763740880"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9228,
      "file_path": "celery/backends/database/__init__.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,11 +99,23 @@ def __init__(self, dburi=None, engine_options=None, url=None, **kwargs):\n                 'Missing connection string! Do you have the'\n                 ' database_url setting set to a real value?')\n \n+        self.session_manager = SessionManager()\n+\n+        create_tables_at_setup = conf.get(\"database_create_tables_at_setup\")",
      "comment": "Since `database_create_tables_at_setup` is a part of conf object, I don't think a lookup using `get` method is required anymore.\r\nThus the attribute can be accessed directly using `conf.database_create_tables_at_setup` .",
      "comment_id": 1764724412,
      "user": "anushds",
      "created_at": "2024-09-18T09:37:08Z",
      "url": "https://github.com/celery/celery/pull/9228#discussion_r1764724412"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9038,
      "file_path": "celery/app/base.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,7 +240,12 @@ def __init__(self, main=None, loader=None, backend=None,\n         self.loader_cls = loader or self._get_default_loader()\n         self.log_cls = log or self.log_cls\n         self.control_cls = control or self.control_cls\n-        self._custom_task_cls_used = bool(task_cls)\n+        self._custom_task_cls_used = (",
      "comment": "What about dropping the whole attribute here, and instead doing the following comparison in the fixup code:\r\n\r\n```python\r\nfrom celery.app import Celery\r\nif self.task_cls == Celery.task_cls:\r\n    <task cls wasn't overriden, proceed with task override>\r\n```\r\n?\r\n\r\nThis should, I think, significantly simplify the code.",
      "comment_id": 1610026442,
      "user": "maciej-gol",
      "created_at": "2024-05-22T14:02:07Z",
      "url": "https://github.com/celery/celery/pull/9038#discussion_r1610026442"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9038,
      "file_path": "celery/app/base.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,7 +240,12 @@ def __init__(self, main=None, loader=None, backend=None,\n         self.loader_cls = loader or self._get_default_loader()\n         self.log_cls = log or self.log_cls\n         self.control_cls = control or self.control_cls\n-        self._custom_task_cls_used = bool(task_cls)\n+        self._custom_task_cls_used = (",
      "comment": "What if the user wants to override Celery to not use the `DjangoTask`, but the default built-in `Task`?",
      "comment_id": 1610028974,
      "user": "browniebroke",
      "created_at": "2024-05-22T14:03:34Z",
      "url": "https://github.com/celery/celery/pull/9038#discussion_r1610028974"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9038,
      "file_path": "celery/app/base.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,7 +240,12 @@ def __init__(self, main=None, loader=None, backend=None,\n         self.loader_cls = loader or self._get_default_loader()\n         self.log_cls = log or self.log_cls\n         self.control_cls = control or self.control_cls\n-        self._custom_task_cls_used = bool(task_cls)\n+        self._custom_task_cls_used = (",
      "comment": "There is no functional difference between `Task` and `DjangoTask` (DT is a strict functional superset of T), so the only cases where this matters are subclass/instance checks which already sound shady and trying to support these sounds like a can of worms, hm? \r\n\r\nIf they _really_ want `Task` and not `DT`, then maybe they are also considering disabling the whole django fixup.\r\n\r\nAnd if they _really_ _really_ want `Task`, then:\r\n\r\n```python\r\nclass MyTask(Task):\r\n    ...\r\n\r\nclass Celery(app.Celery):\r\n    task_class = 'myapp.celery:MyTask'\r\n```",
      "comment_id": 1610061438,
      "user": "maciej-gol",
      "created_at": "2024-05-22T14:14:29Z",
      "url": "https://github.com/celery/celery/pull/9038#discussion_r1610061438"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9038,
      "file_path": "celery/app/base.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,7 +240,12 @@ def __init__(self, main=None, loader=None, backend=None,\n         self.loader_cls = loader or self._get_default_loader()\n         self.log_cls = log or self.log_cls\n         self.control_cls = control or self.control_cls\n-        self._custom_task_cls_used = bool(task_cls)\n+        self._custom_task_cls_used = (",
      "comment": "Yes it _should_ be fine, and I'm probably being extra careful. \r\n\r\nI'm trying to make a change that has the minimum amount of side effects, as any side effects could be considered a breaking change. With a project the size of Celery, it's hard to know what folks are using and how... As your own use case proves (I didn't forsee it coming).",
      "comment_id": 1610245644,
      "user": "browniebroke",
      "created_at": "2024-05-22T15:51:05Z",
      "url": "https://github.com/celery/celery/pull/9038#discussion_r1610245644"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9038,
      "file_path": "celery/app/base.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,7 +240,12 @@ def __init__(self, main=None, loader=None, backend=None,\n         self.loader_cls = loader or self._get_default_loader()\n         self.log_cls = log or self.log_cls\n         self.control_cls = control or self.control_cls\n-        self._custom_task_cls_used = bool(task_cls)\n+        self._custom_task_cls_used = (",
      "comment": "I agree that its best to avoid breaking changes. Having said that, reducing complexity in a project the size of Celery is something I would also keep in consideration :) Especially when: 1) we don't know at all if there are people that want to opt-out from the DT injection 2) there is an easy workaround, as described above.\r\n\r\nI believe you will choose whatever solution is best for the project, and I don't have any strong opinions here (nor I have any time pressure as I have fixed this issue on my side).",
      "comment_id": 1610458278,
      "user": "maciej-gol",
      "created_at": "2024-05-22T18:26:22Z",
      "url": "https://github.com/celery/celery/pull/9038#discussion_r1610458278"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9038,
      "file_path": "celery/app/base.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,7 +240,12 @@ def __init__(self, main=None, loader=None, backend=None,\n         self.loader_cls = loader or self._get_default_loader()\n         self.log_cls = log or self.log_cls\n         self.control_cls = control or self.control_cls\n-        self._custom_task_cls_used = bool(task_cls)\n+        self._custom_task_cls_used = (",
      "comment": "for v.5.4.x we need to keep the backward compatibility. in future major versions, we can think of improving it and deprecating un needed API.",
      "comment_id": 1611058397,
      "user": "auvipy",
      "created_at": "2024-05-23T06:14:18Z",
      "url": "https://github.com/celery/celery/pull/9038#discussion_r1611058397"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7712,
      "file_path": "celery/app/defaults.py",
      "line": 294,
      "side": "RIGHT",
      "diff_hunk": "@@ -291,6 +291,7 @@ def __repr__(self):\n         ),\n         store_errors_even_if_ignored=Option(False, type='bool'),\n         track_started=Option(False, type='bool'),\n+        allow_error_cb_on_chord_header=Option(False, type='bool'),",
      "comment": "Please review the PR again @auvipy , I've added proper documentation",
      "comment_id": 949544124,
      "user": "Nusnus",
      "created_at": "2022-08-18T20:00:43Z",
      "url": "https://github.com/celery/celery/pull/7712#discussion_r949544124"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7712,
      "file_path": "t/integration/test_canvas.py",
      "line": 2770,
      "side": "RIGHT",
      "diff_hunk": "@@ -2638,6 +2638,140 @@ def test_chord_body_chain_child_replaced_with_chain_last(self, manager):\n         res_obj = orig_sig.delay()\n         assert res_obj.get(timeout=TIMEOUT) == [42]\n \n+    def test_enabling_flag_allow_error_cb_on_chord_header(self, manager, subtests):\n+        \"\"\"\n+        Test that the flag allow_error_callback_on_chord_header works as\n+        expected. To confirm this, we create a chord with a failing header\n+        task, and check that the body does not execute when the header task fails.\n+        This allows preventing the body from executing when the chord header fails\n+        when the flag is turned on. In addition, we make sure the body error callback\n+        is also executed when the header fails and the flag is turned on.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        if not manager.app.conf.result_backend.startswith('redis'):\n+            raise pytest.skip('Requires redis result backend.')\n+        redis_connection = get_redis_connection()\n+\n+        manager.app.conf.task_allow_error_cb_on_chord_header = True\n+\n+        header_errback_msg = 'header errback called'\n+        header_errback_key = 'echo_header_errback'\n+        header_errback_sig = redis_echo.si(header_errback_msg, redis_key=header_errback_key)\n+\n+        body_errback_msg = 'body errback called'\n+        body_errback_key = 'echo_body_errback'\n+        body_errback_sig = redis_echo.si(body_errback_msg, redis_key=body_errback_key)\n+\n+        body_msg = 'chord body called'\n+        body_key = 'echo_body'\n+        body_sig = redis_echo.si(body_msg, redis_key=body_key)\n+\n+        headers = (\n+            (fail.si(),),\n+            (fail.si(), fail.si(), fail.si()),\n+            (fail.si(), identity.si(42)),\n+            (fail.si(), identity.si(42), identity.si(42)),\n+            (fail.si(), identity.si(42), fail.si()),\n+            (fail.si(), identity.si(42), fail.si(), identity.si(42)),\n+            (fail.si(), identity.si(42), fail.si(), identity.si(42), fail.si()),\n+        )\n+\n+        # for some reason using parametrize breaks the test so we do it manually unfortunately\n+        for header in headers:\n+            chord_sig = chord(header, body_sig)\n+            # link error to chord header ONLY\n+            [header_task.link_error(header_errback_sig) for header_task in chord_sig.tasks]\n+            # link error to chord body ONLY\n+            chord_sig.body.link_error(body_errback_sig)\n+            redis_connection.delete(header_errback_key, body_errback_key, body_key)\n+\n+            with subtests.test(msg='Error propagates from failure in header'):\n+                res = chord_sig.delay()\n+                with pytest.raises(ExpectedException):\n+                    res.get(timeout=TIMEOUT)\n+\n+            with subtests.test(msg='Confirm the body was not executed'):\n+                with pytest.raises(TimeoutError):\n+                    # confirm the chord body was not called\n+                    await_redis_echo((body_msg,), redis_key=body_key, timeout=10)\n+                # Double check\n+                assert not redis_connection.exists(body_key), 'Chord body was called when it should have not'\n+\n+            with subtests.test(msg='Confirm the errback was called for each failed header task + body'):\n+                # confirm the errback was called for each task in the chord header\n+                failed_header_tasks_count = len(list(filter(lambda f_sig: f_sig == fail.si(), header)))\n+                expected_header_errbacks = tuple(header_errback_msg for _ in range(failed_header_tasks_count))\n+                await_redis_echo(expected_header_errbacks, redis_key=header_errback_key)\n+\n+                # confirm the errback was called for the chord body\n+                await_redis_echo((body_errback_msg,), redis_key=body_errback_key)\n+\n+            redis_connection.delete(header_errback_key, body_errback_key)\n+\n+    def test_disabling_flag_allow_error_cb_on_chord_header(self, manager, subtests):\n+        \"\"\"\n+        Confirm that when allow_error_callback_on_chord_header is disabled, the default\n+        behavior is kept.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        if not manager.app.conf.result_backend.startswith('redis'):\n+            raise pytest.skip('Requires redis result backend.')\n+        redis_connection = get_redis_connection()\n+\n+        manager.app.conf.task_allow_error_cb_on_chord_header = False\n+\n+        errback_msg = 'errback called'\n+        errback_key = 'echo_errback'\n+        errback_sig = redis_echo.si(errback_msg, redis_key=errback_key)\n+\n+        body_msg = 'chord body called'\n+        body_key = 'echo_body'\n+        body_sig = redis_echo.si(body_msg, redis_key=body_key)\n+\n+        headers = (\n+            (fail.si(),),\n+            (fail.si(), fail.si(), fail.si()),\n+            (fail.si(), identity.si(42)),\n+            (fail.si(), identity.si(42), identity.si(42)),\n+            (fail.si(), identity.si(42), fail.si()),\n+            (fail.si(), identity.si(42), fail.si(), identity.si(42)),\n+            (fail.si(), identity.si(42), fail.si(), identity.si(42), fail.si()),\n+        )\n+\n+        # for some reason using parametrize breaks the test so we do it manually unfortunately\n+        for header in headers:\n+            chord_sig = chord(header, body_sig)\n+            chord_sig.link_error(errback_sig)\n+            redis_connection.delete(errback_key, body_key)\n+\n+            with subtests.test(msg='Error propagates from failure in header'):\n+                res = chord_sig.delay()\n+                with pytest.raises(ExpectedException):\n+                    res.get(timeout=TIMEOUT)\n+\n+            with subtests.test(msg='Confirm the body was not executed'):\n+                with pytest.raises(TimeoutError):\n+                    # confirm the chord body was not called\n+                    await_redis_echo((body_msg,), redis_key=body_key, timeout=10)\n+                # Double check\n+                assert not redis_connection.exists(body_key), 'Chord body was called when it should have not'\n+\n+            with subtests.test(msg='Confirm there only one errback was called'):\n+                await_redis_echo((errback_msg,), redis_key=errback_key, timeout=10)\n+                with pytest.raises(TimeoutError):\n+                    await_redis_echo((errback_msg,), redis_key=errback_key, timeout=10)",
      "comment": "Is this the right way to implement this assertion?",
      "comment_id": 950885631,
      "user": "Nusnus",
      "created_at": "2022-08-21T18:47:56Z",
      "url": "https://github.com/celery/celery/pull/7712#discussion_r950885631"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7712,
      "file_path": "celery/canvas.py",
      "line": 1822,
      "side": "RIGHT",
      "diff_hunk": "@@ -1808,6 +1810,23 @@ def link(self, callback):\n         return callback\n \n     def link_error(self, errback):\n+        if self.app.conf.task_allow_error_cb_on_chord_header:\n+            # self.tasks can be a list of the chord header workflow.\n+            if isinstance(self.tasks, list):\n+                for task in self.tasks:\n+                    task.link_error(errback)\n+            else:\n+                self.tasks.link_error(errback)\n+        else:\n+            warnings.warn(\n+                \"task_allow_error_cb_on_chord_header=False is pending deprecation in \"",
      "comment": "so we are introducing task_allow_error_cb_on_chord_header=False to be removed in a future version? what alternative do we have in mind?",
      "comment_id": 951003530,
      "user": "auvipy",
      "created_at": "2022-08-22T04:30:02Z",
      "url": "https://github.com/celery/celery/pull/7712#discussion_r951003530"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7712,
      "file_path": "celery/canvas.py",
      "line": 1822,
      "side": "RIGHT",
      "diff_hunk": "@@ -1808,6 +1810,23 @@ def link(self, callback):\n         return callback\n \n     def link_error(self, errback):\n+        if self.app.conf.task_allow_error_cb_on_chord_header:\n+            # self.tasks can be a list of the chord header workflow.\n+            if isinstance(self.tasks, list):\n+                for task in self.tasks:\n+                    task.link_error(errback)\n+            else:\n+                self.tasks.link_error(errback)\n+        else:\n+            warnings.warn(\n+                \"task_allow_error_cb_on_chord_header=False is pending deprecation in \"",
      "comment": "Currently to make the Enabled state the default when the previous behavior will be fully deprecated. But this is subject to change.",
      "comment_id": 951333226,
      "user": "Nusnus",
      "created_at": "2022-08-22T11:37:37Z",
      "url": "https://github.com/celery/celery/pull/7712#discussion_r951333226"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/contrib/django/task.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,21 @@\n+import functools\n+\n+from django.db import transaction\n+\n+from celery.app.task import Task as BaseTask\n+\n+\n+class Task(BaseTask):\n+    \"\"\"\n+    Extend the base task to work nicely with Django.\n+\n+    Provide a better API to trigger tasks at the end of the DB transaction.\n+    \"\"\"\n+\n+    def delay_on_commit(self, *args, **kwargs):\n+        \"\"\"Call delay() with Django's on_commit().\"\"\"\n+        return transaction.on_commit(functools.partial(self.delay, *args, **kwargs))\n+\n+    def apply_async_on_commit(self, *args, **kwargs):\n+        \"\"\"Call apply_async() with Django's on_commit().\"\"\"\n+        return transaction.on_commit(functools.partial(self.apply_async, *args, **kwargs))",
      "comment": "I went with some separate methods, to be explicit and in case folks need access to the original ones but maybe it's ok to always do that",
      "comment_id": 1319736035,
      "user": "browniebroke",
      "created_at": "2023-09-08T11:23:56Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1319736035"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/fixups/django.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -77,6 +77,7 @@ def install(self) -> \"DjangoFixup\":\n \n         self._settings = symbol_by_name('django.conf:settings')\n         self.app.loader.now = self.now\n+        self.app.task_cls = 'celery.contrib.django.task:Task'",
      "comment": "One problem at the moment (I think) is that it would override a custom class set by the user. ",
      "comment_id": 1320608991,
      "user": "browniebroke",
      "created_at": "2023-09-09T17:00:37Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1320608991"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/contrib/django/task.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,21 @@\n+import functools\n+\n+from django.db import transaction\n+\n+from celery.app.task import Task as BaseTask\n+\n+\n+class Task(BaseTask):\n+    \"\"\"\n+    Extend the base task to work nicely with Django.\n+\n+    Provide a better API to trigger tasks at the end of the DB transaction.\n+    \"\"\"\n+\n+    def delay_on_commit(self, *args, **kwargs):\n+        \"\"\"Call delay() with Django's on_commit().\"\"\"\n+        return transaction.on_commit(functools.partial(self.delay, *args, **kwargs))\n+\n+    def apply_async_on_commit(self, *args, **kwargs):\n+        \"\"\"Call apply_async() with Django's on_commit().\"\"\"\n+        return transaction.on_commit(functools.partial(self.apply_async, *args, **kwargs))",
      "comment": "I want to be sure that these will work from django 2.2 LTS to 4.2 LTS for a while?",
      "comment_id": 1321158485,
      "user": "auvipy",
      "created_at": "2023-09-11T08:12:46Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1321158485"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/contrib/django/task.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,21 @@\n+import functools\n+\n+from django.db import transaction\n+\n+from celery.app.task import Task as BaseTask\n+\n+\n+class Task(BaseTask):\n+    \"\"\"\n+    Extend the base task to work nicely with Django.\n+\n+    Provide a better API to trigger tasks at the end of the DB transaction.\n+    \"\"\"\n+\n+    def delay_on_commit(self, *args, **kwargs):\n+        \"\"\"Call delay() with Django's on_commit().\"\"\"\n+        return transaction.on_commit(functools.partial(self.delay, *args, **kwargs))\n+\n+    def apply_async_on_commit(self, *args, **kwargs):\n+        \"\"\"Call apply_async() with Django's on_commit().\"\"\"\n+        return transaction.on_commit(functools.partial(self.apply_async, *args, **kwargs))",
      "comment": "I cannot tell 100% sure for long term future plans, but this API hasn't changed in years. It's been documented as far back [as 1.10 (released in August 2016)](https://docs.djangoproject.com/en/1.10/topics/db/transactions/#django.db.transaction.on_commit), and it's the same in [the latest stable version (4.2)](https://docs.djangoproject.com/en/4.2/topics/db/transactions/#django.db.transaction.on_commit)and in the [dev version (which will become 5.0)](https://docs.djangoproject.com/en/dev/topics/db/transactions/#django.db.transaction.on_commit).\r\n\r\nI think that with Django current [deprecation policy](https://docs.djangoproject.com/en/dev/internals/release-process/#internal-release-deprecation-policy), that means it should keep working until the next LTS (5.2) and won't be changed until version 6.0.",
      "comment_id": 1321197975,
      "user": "browniebroke",
      "created_at": "2023-09-11T08:42:26Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1321197975"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/fixups/django.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -77,6 +77,7 @@ def install(self) -> \"DjangoFixup\":\n \n         self._settings = symbol_by_name('django.conf:settings')\n         self.app.loader.now = self.now\n+        self.app.task_cls = 'celery.contrib.django.task:Task'",
      "comment": "Not yet. I'm thinking that, prior to changing it, I could check the current value and don't change it if it's different than the default task. I don't think there is a use case for people overriding this specialised class back to the default one currently.",
      "comment_id": 1322667158,
      "user": "browniebroke",
      "created_at": "2023-09-12T08:44:38Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1322667158"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/contrib/django/task.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,21 @@\n+import functools\n+\n+from django.db import transaction\n+\n+from celery.app.task import Task as BaseTask\n+\n+\n+class Task(BaseTask):",
      "comment": "should we use the name as Task or DjangoTask or anything better?",
      "comment_id": 1328088819,
      "user": "auvipy",
      "created_at": "2023-09-17T12:36:27Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1328088819"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/contrib/django/task.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,21 @@\n+import functools\n+\n+from django.db import transaction\n+\n+from celery.app.task import Task as BaseTask\n+\n+\n+class Task(BaseTask):",
      "comment": "I was asklng myself the same question. \r\n\r\nOne the one hand, this is namespaced into a `contrib.django` package, so one could make the argument that naming the class `DjangoTask` might feel redundant. \r\n\r\nBut on the other hand, this namespace might be glossed over or even not visible in logs/stacktraces. Might also help tooling to have a distinct class name. I'm also already doing some `import Task as DjangoTask` in the tests, so I see that as a signal that a different name might make sense.\r\n\r\nGiven all that, I'm leaning towards the name `DjangoTask`. ",
      "comment_id": 1328092568,
      "user": "browniebroke",
      "created_at": "2023-09-17T13:11:46Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1328092568"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/contrib/django/task.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,24 @@\n+import functools\n+\n+try:\n+    from django.db import transaction\n+except ImportError:\n+    transaction = None",
      "comment": "Added this try/catch to let us generate the API reference page. \r\n\r\nI'm not a big fan of this as it might hide some misconfiguration in the app, the error will happen when the method is called rather than at start-up (I think). \r\n\r\nIs there any pre-existing way of dealing with 3rd party libs that are not present when generating the documentation?",
      "comment_id": 1328639286,
      "user": "browniebroke",
      "created_at": "2023-09-18T12:19:47Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1328639286"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/contrib/django/task.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,24 @@\n+import functools\n+\n+try:\n+    from django.db import transaction\n+except ImportError:\n+    transaction = None\n+\n+from celery.app.task import Task as BaseTask",
      "comment": "```suggestion\r\nfrom celery.app.task import Task\r\n```",
      "comment_id": 1334400874,
      "user": "auvipy",
      "created_at": "2023-09-22T13:42:52Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1334400874"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8491,
      "file_path": "celery/contrib/django/task.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,24 @@\n+import functools\n+\n+try:\n+    from django.db import transaction\n+except ImportError:\n+    transaction = None",
      "comment": "`autodoc_mock_imports` should to the trick:\r\n\r\nhttps://github.com/celery/celery/blob/1683008881717d2f8391264cb2b6177d85ff5ea8/docs/conf.py#L47C16-L49",
      "comment_id": 1338149231,
      "user": "nijel",
      "created_at": "2023-09-27T07:15:12Z",
      "url": "https://github.com/celery/celery/pull/8491#discussion_r1338149231"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9010,
      "file_path": "celery/security/serialization.py",
      "line": 65,
      "side": "LEFT",
      "diff_hunk": "@@ -55,37 +55,20 @@ def deserialize(self, data):\n     def _pack(self, body, content_type, content_encoding, signer, signature,\n               sep=str_to_bytes('\\x00\\x01')):\n         fields = sep.join(\n-            ensure_bytes(s) for s in [signer, signature, content_type,\n-                                      content_encoding, body]\n+            ensure_bytes(s) for s in [b64encode(signer), b64encode(signature),\n+                                      content_type, content_encoding, body]\n         )\n         return b64encode(fields)\n \n     def _unpack(self, payload, sep=str_to_bytes('\\x00\\x01')):\n         raw_payload = b64decode(ensure_bytes(payload))\n-        first_sep = raw_payload.find(sep)",
      "comment": "I would like to know bit more detail about the changes proposed, care to provide bit more?",
      "comment_id": 1595313364,
      "user": "auvipy",
      "created_at": "2024-05-09T11:13:44Z",
      "url": "https://github.com/celery/celery/pull/9010#discussion_r1595313364"
    },
    {
      "repo": "celery/celery",
      "pr_number": 9010,
      "file_path": "celery/security/serialization.py",
      "line": 65,
      "side": "LEFT",
      "diff_hunk": "@@ -55,37 +55,20 @@ def deserialize(self, data):\n     def _pack(self, body, content_type, content_encoding, signer, signature,\n               sep=str_to_bytes('\\x00\\x01')):\n         fields = sep.join(\n-            ensure_bytes(s) for s in [signer, signature, content_type,\n-                                      content_encoding, body]\n+            ensure_bytes(s) for s in [b64encode(signer), b64encode(signature),\n+                                      content_type, content_encoding, body]\n         )\n         return b64encode(fields)\n \n     def _unpack(self, payload, sep=str_to_bytes('\\x00\\x01')):\n         raw_payload = b64decode(ensure_bytes(payload))\n-        first_sep = raw_payload.find(sep)",
      "comment": "Sure @auvipy . This is the logic that we have today for unpacking the serialized data:\r\n1. extract signer and `signature_start_index` using first appearance of `sep`\r\n2. get signature bytes according to `signature_start_index` and signature length. Note, that we assume. here that the signature is decoded as-is in the raw_payload, so we can use the signature length to calculate `signature_end_index`\r\n3. extract all other fields from remaining bytes using split by `sep`\r\n\r\nThe proposed solution simplifies this process, by assuming that the `sep` bytes can be present in the payload only as separators (and not randomly be as part of signature bytes, for example). Since we guarantee that when we encode the binary data using `base64` (which will not contain `\\x00\\x01`).\r\nWith that assumption, we can just split all fields according to `sep` and get all fields at once.\r\nThe only exception here is the `body` itself, which may contain the `sep` bytes inside. Since the body is encoded to the end of the payload, we can limit the number of splits according to `sep`, to prevent more splits in that case.\r\n(We can also encode the body as base64 and then we can assure `sep` will not be in `body` as well, but I like this better since it is more performant).\r\n\r\nMoreover, keeping the current `unpack` process is broken, since the signature is encoded as base64, and it results with a different encoded length then the original signature length",
      "comment_id": 1595339016,
      "user": "shirsa",
      "created_at": "2024-05-09T11:43:06Z",
      "url": "https://github.com/celery/celery/pull/9010#discussion_r1595339016"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8998,
      "file_path": "t/unit/utils/test_platforms.py",
      "line": 691,
      "side": "RIGHT",
      "diff_hunk": "@@ -689,6 +689,15 @@ def test_remove_if_stale_no_pidfile(self):\n         assert p.remove_if_stale()\n         p.remove.assert_called_with()\n ",
      "comment": "is the change of file permission 100644 \u2192 100755  needed here? or it was done by accident?",
      "comment_id": 1589907326,
      "user": "auvipy",
      "created_at": "2024-05-04T06:12:56Z",
      "url": "https://github.com/celery/celery/pull/8998#discussion_r1589907326"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8796,
      "file_path": "celery/app/trace.py",
      "line": 21,
      "side": "LEFT",
      "diff_hunk": "@@ -17,8 +16,6 @@\n from kombu.serialization import prepare_accept_content\n from kombu.utils.encoding import safe_repr, safe_str\n \n-import celery\n-import celery.loaders.app",
      "comment": "i wonder if these imports are what caused the issue, and if putting them behind a `if TYPE_CHECKING:` would fix it",
      "comment_id": 1590018382,
      "user": "oaosman84",
      "created_at": "2024-05-04T16:43:24Z",
      "url": "https://github.com/celery/celery/pull/8796#discussion_r1590018382"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8868,
      "file_path": "celery/app/backends.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,6 +34,7 @@\n     'azureblockblob': 'celery.backends.azureblockblob:AzureBlockBlobBackend',\n     'arangodb': 'celery.backends.arangodb:ArangoDbBackend',\n     's3': 'celery.backends.s3:S3Backend',\n+    'gs': 'celery.backends.gcs:GCSBackend',",
      "comment": "@haimjether @thedrow something I was wondering about during upgrade-review for `celery` - is this meant to be registered as `gs` or is that a typo of `gcs`?",
      "comment_id": 1587482450,
      "user": "jayaddison",
      "created_at": "2024-05-02T11:31:27Z",
      "url": "https://github.com/celery/celery/pull/8868#discussion_r1587482450"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8868,
      "file_path": "celery/app/backends.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,6 +34,7 @@\n     'azureblockblob': 'celery.backends.azureblockblob:AzureBlockBlobBackend',\n     'arangodb': 'celery.backends.arangodb:ArangoDbBackend',\n     's3': 'celery.backends.s3:S3Backend',\n+    'gs': 'celery.backends.gcs:GCSBackend',",
      "comment": "@jayaddison , it was meant to be registered as `gs` , to mimic the blobs path prefix on GCS. E.g \r\n`gs://my-bucket/my-folder` \r\n\r\nThe module path is `gcs.GCSBackend` because Google's commercial product is \"GCS\" , as opposed to \"S3\" in AWS \r\n\r\nIMHO this is similar to AWS `s3` one.",
      "comment_id": 1587545701,
      "user": "haimjether",
      "created_at": "2024-05-02T12:23:15Z",
      "url": "https://github.com/celery/celery/pull/8868#discussion_r1587545701"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8868,
      "file_path": "celery/app/backends.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,6 +34,7 @@\n     'azureblockblob': 'celery.backends.azureblockblob:AzureBlockBlobBackend',\n     'arangodb': 'celery.backends.arangodb:ArangoDbBackend',\n     's3': 'celery.backends.s3:S3Backend',\n+    'gs': 'celery.backends.gcs:GCSBackend',",
      "comment": ":+1: great, glad to know it's as-intended.  Thanks @haimjether!",
      "comment_id": 1587550463,
      "user": "jayaddison",
      "created_at": "2024-05-02T12:27:16Z",
      "url": "https://github.com/celery/celery/pull/8868#discussion_r1587550463"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8984,
      "file_path": "celery/contrib/django/task.py",
      "line": 17,
      "side": "LEFT",
      "diff_hunk": "@@ -12,10 +12,10 @@ class DjangoTask(Task):\n     Provide a nicer API to trigger tasks at the end of the DB transaction.\n     \"\"\"\n \n-    def delay_on_commit(self, *args, **kwargs):\n+    def delay_on_commit(self, *args, **kwargs) -> None:\n         \"\"\"Call :meth:`~celery.app.task.Task.delay` with Django's ``on_commit()``.\"\"\"\n-        return transaction.on_commit(functools.partial(self.delay, *args, **kwargs))",
      "comment": "As we can see [in Django codebase](https://github.com/django/django/blob/ec8552417df51df8482df61b8ad78a7002634011/django/db/backends/base/base.py#L727-L750), `transaction.on_commit()` does not return anything. This `return` statement might mislead the reader in thinking that it will return something. Clearer to not have it in my opinion.",
      "comment_id": 1581817937,
      "user": "browniebroke",
      "created_at": "2024-04-27T11:52:19Z",
      "url": "https://github.com/celery/celery/pull/8984#discussion_r1581817937"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8984,
      "file_path": "celery/contrib/django/task.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,10 +12,10 @@ class DjangoTask(Task):\n     Provide a nicer API to trigger tasks at the end of the DB transaction.\n     \"\"\"\n \n-    def delay_on_commit(self, *args, **kwargs):\n+    def delay_on_commit(self, *args, **kwargs) -> None:",
      "comment": "Not sure what is your policy on type hints, I'm hoping that this might reinforce this fact and perhaps help code editor to spot issues.",
      "comment_id": 1581818079,
      "user": "browniebroke",
      "created_at": "2024-04-27T11:53:22Z",
      "url": "https://github.com/celery/celery/pull/8984#discussion_r1581818079"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 1220,
      "side": "RIGHT",
      "diff_hunk": "@@ -1217,6 +1217,14 @@ def prepare_steps(self, args, kwargs, tasks,\n                         root_id=root_id, app=app,\n                     )\n \n+            if isinstance(task, chord) and prev_task and not isinstance(",
      "comment": "you need to add unit and possibly integration test for verifying this change",
      "comment_id": 1402924553,
      "user": "auvipy",
      "created_at": "2023-11-23T05:17:09Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1402924553"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 984,
      "side": "RIGHT",
      "diff_hunk": "@@ -981,6 +981,11 @@ def __or__(self, other):\n                 sig = self.clone()\n                 sig.tasks[-1] = chord(\n                     sig.tasks[-1], other, app=self._app)\n+                for task_idx in range(len(sig.tasks) - 2, -1, -1):",
      "comment": "Second, this is a much more fit location for the fix!",
      "comment_id": 1403098639,
      "user": "Nusnus",
      "created_at": "2023-11-23T09:11:11Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1403098639"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 984,
      "side": "RIGHT",
      "diff_hunk": "@@ -981,6 +981,11 @@ def __or__(self, other):\n                 sig = self.clone()\n                 sig.tasks[-1] = chord(\n                     sig.tasks[-1], other, app=self._app)\n+                for task_idx in range(len(sig.tasks) - 2, -1, -1):",
      "comment": "Third, this new loop requires a clear comment above that explains what's going on.\r\nAs someone who personally went over `canvas.py` line by line, documenting a major percentage of the module, the `__or__` operator is one of the complicated parts.\r\n\r\nI don't mean writing a story - but `for task_idx in range(len(sig.tasks) - 2, -1, -1):` would be totally cryptic to someone seeing it for the first time.",
      "comment_id": 1403101693,
      "user": "Nusnus",
      "created_at": "2023-11-23T09:14:01Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1403101693"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 984,
      "side": "RIGHT",
      "diff_hunk": "@@ -981,6 +981,11 @@ def __or__(self, other):\n                 sig = self.clone()\n                 sig.tasks[-1] = chord(\n                     sig.tasks[-1], other, app=self._app)\n+                for task_idx in range(len(sig.tasks) - 2, -1, -1):",
      "comment": "If a chain can only end with a single chord, this for loop might be unnecessary. It would suffice to simply check if the last two elements after the upgrade are chords.",
      "comment_id": 1403134254,
      "user": "hann-wang",
      "created_at": "2023-11-23T09:42:30Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1403134254"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 984,
      "side": "RIGHT",
      "diff_hunk": "@@ -981,6 +981,11 @@ def __or__(self, other):\n                 sig = self.clone()\n                 sig.tasks[-1] = chord(\n                     sig.tasks[-1], other, app=self._app)\n+                for task_idx in range(len(sig.tasks) - 2, -1, -1):",
      "comment": "> If a chain can only end with a single chord\r\n\r\nIt can end with a group of chords for example.",
      "comment_id": 1403142650,
      "user": "Nusnus",
      "created_at": "2023-11-23T09:49:16Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1403142650"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 984,
      "side": "RIGHT",
      "diff_hunk": "@@ -981,6 +981,11 @@ def __or__(self, other):\n                 sig = self.clone()\n                 sig.tasks[-1] = chord(\n                     sig.tasks[-1], other, app=self._app)\n+                for task_idx in range(len(sig.tasks) - 2, -1, -1):",
      "comment": "Please correct me if I'm wrong, but I'd like to discuss the behavior of chains in Celery, specifically regarding their ending tasks.\r\n\r\n- ends with group\r\n  -  chain[ends with group] | group -> chain[ends with group]  *In this case, the unrolled group might be a chord or task, but it isn't specially treated.*\r\n  - chain[ends with group] | chain -> chain[ends with any, no extra tail chord]\r\n  - chain[ends with group] | chord or task -> chain[ends with chord(group, task)] *In this case, the type of the last item is changed and an extra tail chord is introduced.*\r\n- ends with chord\r\n  - chain[ends with chord] | group -> chain[ends with chord (body-chained), no extra tail chord]\r\n  - chain[ends with chord] | chain -> chain[ends with any, no extra tail chord]\r\n  - chain[ends with chord] | chord or task -> chain[ends with chord (body-chained), no extra tail chord]\r\n- ends with task\r\n  - chain[ends with task] | group -> chain[ends with group]\r\n  - chain[ends with task] | chain -> chain[ends with any, no extra tail chord]\r\n  - chain[ends with task] | chord or task -> chain[ends with chord or task, no extra tail chord]\r\n\r\nCurrently, there seems to be only one scenario where the number of tail chords in a chain increases, potentially resulting in two consecutive chords: chaining a task to a chain ending with a group. This observation suggests that the loop in the code could be omitted.\r\n\r\nAdditionally, in the case of `chain[ends with group] | group`, if the linked group consists of only a single task, it appears that in the master branch, the unrolled task does not undergo an upgrade process. Is this the intended behavior or should there be a consideration for an upgrade in such scenarios?",
      "comment_id": 1403267057,
      "user": "hann-wang",
      "created_at": "2023-11-23T11:44:15Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1403267057"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 961,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,6 +958,8 @@ def __or__(self, other):\n         if isinstance(other, group):\n             # unroll group with one member\n             other = maybe_unroll_group(other)\n+            if not isinstance(other, group):",
      "comment": "Yes. In `test_chain_of_chord_upgrade_on_chaining__protocol_3` and `test_chaining_upgraded_chords_mixed_canvas_protocol_3`, the last group with only one task is unrolled and `other` is not a group anymore.",
      "comment_id": 1404732945,
      "user": "hann-wang",
      "created_at": "2023-11-25T05:01:55Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1404732945"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 961,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,6 +958,8 @@ def __or__(self, other):\n         if isinstance(other, group):\n             # unroll group with one member\n             other = maybe_unroll_group(other)\n+            if not isinstance(other, group):",
      "comment": "I am curious If we can improve the coverage report?",
      "comment_id": 1404733404,
      "user": "auvipy",
      "created_at": "2023-11-25T05:03:17Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1404733404"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 961,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,6 +958,8 @@ def __or__(self, other):\n         if isinstance(other, group):\n             # unroll group with one member\n             other = maybe_unroll_group(other)\n+            if not isinstance(other, group):",
      "comment": "It appears that some of the code in #7919, which is meant to fix #5958, falls outside the coverage of the existing test cases. To address this, I have added a unit test to verify it.\r\n\r\nHowever, I encountered difficulties in reproducing #5958. Even when I removed the code from PR #7919 and this PR, the `test_chaining_upgraded_chords_mixed_canvas` in the integration tests still passed successfully.",
      "comment_id": 1404794612,
      "user": "hann-wang",
      "created_at": "2023-11-25T08:06:02Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1404794612"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 961,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,6 +958,8 @@ def __or__(self, other):\n         if isinstance(other, group):\n             # unroll group with one member\n             other = maybe_unroll_group(other)\n+            if not isinstance(other, group):",
      "comment": "This change is very interesting; let's see if I get it right.\r\n\r\nAssuming:\r\n```python\r\ndef maybe_unroll_group(group):\r\n    \"\"\"Unroll group with only one member.\r\n    This allows treating a group of a single task as if it\r\n    was a single task without pre-knowledge.\"\"\"\r\n...\r\n    return group.tasks[0] if size == 1 else group\r\n```\r\n\r\nThen if `group.tasks[0]` is **not** a group, the original flow was bugged as it assumed `other` is a group whereas `group.tasks[0]` can be a chain for example, as can be understood from the following lines:\r\n```python\r\n# If the chain is empty, return the group\r\nreturn other\r\n```\r\n\r\nSo, this fix:\r\n```python\r\nif not isinstance(other, group):\r\n    return self.__or__(other)\r\n```\r\nSays, if `other = maybe_unroll_group(other)` is **not** a group, \"try again\" (in simple words).\r\n\r\nDo I understand this change correctly? @hann-wang ",
      "comment_id": 1405142668,
      "user": "Nusnus",
      "created_at": "2023-11-25T15:36:03Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1405142668"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 986,
      "side": "RIGHT",
      "diff_hunk": "@@ -981,6 +983,13 @@ def __or__(self, other):\n                 sig = self.clone()\n                 sig.tasks[-1] = chord(\n                     sig.tasks[-1], other, app=self._app)\n+                # In the scenario where the second-to-last item in a chain is a chord,",
      "comment": "Makes a lot of sense.\r\nI really like this fix - good job \ud83d\udc4f ",
      "comment_id": 1405143755,
      "user": "Nusnus",
      "created_at": "2023-11-25T15:40:39Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1405143755"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "t/integration/test_canvas.py",
      "line": 1079,
      "side": "RIGHT",
      "diff_hunk": "@@ -1030,6 +1030,106 @@ def test_chaining_upgraded_chords_mixed_canvas(self, manager, subtests):\n         # Cleanup\n         redis_connection.delete(redis_key, 'Done')\n \n+    def test_chaining_upgraded_chords_mixed_canvas_protocol_2(self, manager, subtests):\n+        \"\"\" This test is built to reproduce the github issue https://github.com/celery/celery/issues/8662\n+\n+        The issue describes a canvas where a chain of groups are executed multiple times instead of once.\n+        This test is built to reproduce the issue and to verify that the issue is fixed.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        if not manager.app.conf.result_backend.startswith('redis'):\n+            raise pytest.skip('Requires redis result backend.')\n+\n+        redis_connection = get_redis_connection()\n+        redis_key = 'echo_chamber'\n+\n+        c = chain(\n+            group([\n+                redis_echo.si('1', redis_key=redis_key),\n+                redis_echo.si('2', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('3', redis_key=redis_key),\n+                redis_echo.si('4', redis_key=redis_key),\n+                redis_echo.si('5', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('6', redis_key=redis_key),\n+                redis_echo.si('7', redis_key=redis_key),\n+                redis_echo.si('8', redis_key=redis_key),\n+                redis_echo.si('9', redis_key=redis_key)\n+            ]),\n+            redis_echo.si('Done', redis_key='Done'),\n+        )\n+\n+        with subtests.test(msg='Run the chain and wait for completion'):\n+            redis_connection.delete(redis_key, 'Done')\n+            c.delay().get(timeout=TIMEOUT)\n+            await_redis_list_message_length(1, redis_key='Done', timeout=10)\n+\n+        with subtests.test(msg='All tasks are executed once'):\n+            actual = [sig.decode('utf-8') for sig in redis_connection.lrange(redis_key, 0, -1)]\n+            expected = [str(i) for i in range(1, 10)]\n+            with subtests.test(msg='All tasks are executed once'):\n+                assert sorted(actual) == sorted(expected)\n+\n+        # Cleanup\n+        redis_connection.delete(redis_key, 'Done')\n+\n+    def test_chaining_upgraded_chords_mixed_canvas_protocol_3(self, manager, subtests):\n+        \"\"\" This test is built to reproduce the github issue https://github.com/celery/celery/issues/8662\n+\n+        The issue describes a canvas where a chain of groups are executed multiple times instead of once.\n+        This test is built to reproduce the issue and to verify that the issue is fixed.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        if not manager.app.conf.result_backend.startswith('redis'):\n+            raise pytest.skip('Requires redis result backend.')\n+\n+        redis_connection = get_redis_connection()\n+        redis_key = 'echo_chamber'\n+\n+        c = chain(\n+            group([\n+                redis_echo.si('1', redis_key=redis_key),\n+                redis_echo.si('2', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('3', redis_key=redis_key),\n+                redis_echo.si('4', redis_key=redis_key),\n+                redis_echo.si('5', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('6', redis_key=redis_key),\n+                redis_echo.si('7', redis_key=redis_key),\n+                redis_echo.si('8', redis_key=redis_key),\n+                redis_echo.si('9', redis_key=redis_key)\n+            ]),\n+            group(redis_echo.si('Done', redis_key='Done')),",
      "comment": "I had to literally compare `test_chaining_upgraded_chords_mixed_canvas_protocol_2` and `test_chaining_upgraded_chords_mixed_canvas_protocol_3` to find that single difference as it is so small haha.\r\n\r\nYou can use a single test case with `@pytest.mark.parameterize` like this:\r\n```python\r\n\r\n\r\n    @pytest.mark.parametrize(\r\n        \"last_task\",\r\n        [\r\n            redis_echo.si('Done', redis_key='Done'),\r\n            group(redis_echo.si('Done', redis_key='Done')),\r\n        ],\r\n    )\r\n    def test_chaining_upgraded_chords_mixed_canvas_protocol_123(self, manager, subtests, last_task):\r\n        ...\r\n```\r\n\r\nThis will also reduce duplicated code which is generally better.",
      "comment_id": 1405147167,
      "user": "Nusnus",
      "created_at": "2023-11-25T15:53:27Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1405147167"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 984,
      "side": "RIGHT",
      "diff_hunk": "@@ -981,6 +981,11 @@ def __or__(self, other):\n                 sig = self.clone()\n                 sig.tasks[-1] = chord(\n                     sig.tasks[-1], other, app=self._app)\n+                for task_idx in range(len(sig.tasks) - 2, -1, -1):",
      "comment": "> Additionally, in the case of chain[ends with group] | group, if the linked group consists of only a single task, it appears that in the master branch, the unrolled task does not undergo an upgrade process.\r\n\r\nAs this is a detailed subject, I want to confirm I first understand you before I respond.\r\nAre you referring to this:\r\n```python\r\ndef __or__(self, other):\r\n    if isinstance(other, group):\r\n        # unroll group with one member\r\n        other = maybe_unroll_group(other)\r\n        # chain | group() -> chain\r\n        tasks = self.unchain_tasks()\r\n        ...\r\n        # use type(self) for _chain subclasses\r\n        return type(self)(seq_concat_item(tasks, other), app=self._app)\r\n```\r\n\r\n\"the unrolled task does not undergo an upgrade process.\" --> `return type(self)(seq_concat_item(tasks, other), app=self._app)` ?",
      "comment_id": 1405157421,
      "user": "Nusnus",
      "created_at": "2023-11-25T16:07:27Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1405157421"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "celery/canvas.py",
      "line": 961,
      "side": "RIGHT",
      "diff_hunk": "@@ -958,6 +958,8 @@ def __or__(self, other):\n         if isinstance(other, group):\n             # unroll group with one member\n             other = maybe_unroll_group(other)\n+            if not isinstance(other, group):",
      "comment": "Yes. However, there still seems to be an issue with a nested group containing only one task, for example, a structure like group(group(group(task))). I doubt anyone would actually use a group in this manner.",
      "comment_id": 1405557141,
      "user": "hann-wang",
      "created_at": "2023-11-27T02:30:16Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1405557141"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "t/integration/test_canvas.py",
      "line": 1079,
      "side": "RIGHT",
      "diff_hunk": "@@ -1030,6 +1030,106 @@ def test_chaining_upgraded_chords_mixed_canvas(self, manager, subtests):\n         # Cleanup\n         redis_connection.delete(redis_key, 'Done')\n \n+    def test_chaining_upgraded_chords_mixed_canvas_protocol_2(self, manager, subtests):\n+        \"\"\" This test is built to reproduce the github issue https://github.com/celery/celery/issues/8662\n+\n+        The issue describes a canvas where a chain of groups are executed multiple times instead of once.\n+        This test is built to reproduce the issue and to verify that the issue is fixed.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        if not manager.app.conf.result_backend.startswith('redis'):\n+            raise pytest.skip('Requires redis result backend.')\n+\n+        redis_connection = get_redis_connection()\n+        redis_key = 'echo_chamber'\n+\n+        c = chain(\n+            group([\n+                redis_echo.si('1', redis_key=redis_key),\n+                redis_echo.si('2', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('3', redis_key=redis_key),\n+                redis_echo.si('4', redis_key=redis_key),\n+                redis_echo.si('5', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('6', redis_key=redis_key),\n+                redis_echo.si('7', redis_key=redis_key),\n+                redis_echo.si('8', redis_key=redis_key),\n+                redis_echo.si('9', redis_key=redis_key)\n+            ]),\n+            redis_echo.si('Done', redis_key='Done'),\n+        )\n+\n+        with subtests.test(msg='Run the chain and wait for completion'):\n+            redis_connection.delete(redis_key, 'Done')\n+            c.delay().get(timeout=TIMEOUT)\n+            await_redis_list_message_length(1, redis_key='Done', timeout=10)\n+\n+        with subtests.test(msg='All tasks are executed once'):\n+            actual = [sig.decode('utf-8') for sig in redis_connection.lrange(redis_key, 0, -1)]\n+            expected = [str(i) for i in range(1, 10)]\n+            with subtests.test(msg='All tasks are executed once'):\n+                assert sorted(actual) == sorted(expected)\n+\n+        # Cleanup\n+        redis_connection.delete(redis_key, 'Done')\n+\n+    def test_chaining_upgraded_chords_mixed_canvas_protocol_3(self, manager, subtests):\n+        \"\"\" This test is built to reproduce the github issue https://github.com/celery/celery/issues/8662\n+\n+        The issue describes a canvas where a chain of groups are executed multiple times instead of once.\n+        This test is built to reproduce the issue and to verify that the issue is fixed.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        if not manager.app.conf.result_backend.startswith('redis'):\n+            raise pytest.skip('Requires redis result backend.')\n+\n+        redis_connection = get_redis_connection()\n+        redis_key = 'echo_chamber'\n+\n+        c = chain(\n+            group([\n+                redis_echo.si('1', redis_key=redis_key),\n+                redis_echo.si('2', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('3', redis_key=redis_key),\n+                redis_echo.si('4', redis_key=redis_key),\n+                redis_echo.si('5', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('6', redis_key=redis_key),\n+                redis_echo.si('7', redis_key=redis_key),\n+                redis_echo.si('8', redis_key=redis_key),\n+                redis_echo.si('9', redis_key=redis_key)\n+            ]),\n+            group(redis_echo.si('Done', redis_key='Done')),",
      "comment": "Placing `group(redis_echo.si('Done', redis_key='Done'))` directly within `@pytest.mark.parametrize` results in a `NotImplementedError` exception. As a compromise, I have resorted to using a boolean flag.",
      "comment_id": 1405576557,
      "user": "hann-wang",
      "created_at": "2023-11-27T03:19:58Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1405576557"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8663,
      "file_path": "t/integration/test_canvas.py",
      "line": 1079,
      "side": "RIGHT",
      "diff_hunk": "@@ -1030,6 +1030,106 @@ def test_chaining_upgraded_chords_mixed_canvas(self, manager, subtests):\n         # Cleanup\n         redis_connection.delete(redis_key, 'Done')\n \n+    def test_chaining_upgraded_chords_mixed_canvas_protocol_2(self, manager, subtests):\n+        \"\"\" This test is built to reproduce the github issue https://github.com/celery/celery/issues/8662\n+\n+        The issue describes a canvas where a chain of groups are executed multiple times instead of once.\n+        This test is built to reproduce the issue and to verify that the issue is fixed.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        if not manager.app.conf.result_backend.startswith('redis'):\n+            raise pytest.skip('Requires redis result backend.')\n+\n+        redis_connection = get_redis_connection()\n+        redis_key = 'echo_chamber'\n+\n+        c = chain(\n+            group([\n+                redis_echo.si('1', redis_key=redis_key),\n+                redis_echo.si('2', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('3', redis_key=redis_key),\n+                redis_echo.si('4', redis_key=redis_key),\n+                redis_echo.si('5', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('6', redis_key=redis_key),\n+                redis_echo.si('7', redis_key=redis_key),\n+                redis_echo.si('8', redis_key=redis_key),\n+                redis_echo.si('9', redis_key=redis_key)\n+            ]),\n+            redis_echo.si('Done', redis_key='Done'),\n+        )\n+\n+        with subtests.test(msg='Run the chain and wait for completion'):\n+            redis_connection.delete(redis_key, 'Done')\n+            c.delay().get(timeout=TIMEOUT)\n+            await_redis_list_message_length(1, redis_key='Done', timeout=10)\n+\n+        with subtests.test(msg='All tasks are executed once'):\n+            actual = [sig.decode('utf-8') for sig in redis_connection.lrange(redis_key, 0, -1)]\n+            expected = [str(i) for i in range(1, 10)]\n+            with subtests.test(msg='All tasks are executed once'):\n+                assert sorted(actual) == sorted(expected)\n+\n+        # Cleanup\n+        redis_connection.delete(redis_key, 'Done')\n+\n+    def test_chaining_upgraded_chords_mixed_canvas_protocol_3(self, manager, subtests):\n+        \"\"\" This test is built to reproduce the github issue https://github.com/celery/celery/issues/8662\n+\n+        The issue describes a canvas where a chain of groups are executed multiple times instead of once.\n+        This test is built to reproduce the issue and to verify that the issue is fixed.\n+        \"\"\"\n+        try:\n+            manager.app.backend.ensure_chords_allowed()\n+        except NotImplementedError as e:\n+            raise pytest.skip(e.args[0])\n+\n+        if not manager.app.conf.result_backend.startswith('redis'):\n+            raise pytest.skip('Requires redis result backend.')\n+\n+        redis_connection = get_redis_connection()\n+        redis_key = 'echo_chamber'\n+\n+        c = chain(\n+            group([\n+                redis_echo.si('1', redis_key=redis_key),\n+                redis_echo.si('2', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('3', redis_key=redis_key),\n+                redis_echo.si('4', redis_key=redis_key),\n+                redis_echo.si('5', redis_key=redis_key)\n+            ]),\n+            group([\n+                redis_echo.si('6', redis_key=redis_key),\n+                redis_echo.si('7', redis_key=redis_key),\n+                redis_echo.si('8', redis_key=redis_key),\n+                redis_echo.si('9', redis_key=redis_key)\n+            ]),\n+            group(redis_echo.si('Done', redis_key='Done')),",
      "comment": "thanks but I want to wait to know feedback from Nusnus",
      "comment_id": 1406323615,
      "user": "auvipy",
      "created_at": "2023-11-27T15:20:18Z",
      "url": "https://github.com/celery/celery/pull/8663#discussion_r1406323615"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7925,
      "file_path": "celery/app/trace.py",
      "line": 389,
      "side": "RIGHT",
      "diff_hunk": "@@ -369,7 +382,12 @@ def build_tracer(name, task, loader=None, hostname=None, store_errors=True,\n     from celery import canvas\n     signature = canvas.maybe_signature  # maybe_ does not clone if already\n \n-    def on_error(request, exc, state=FAILURE, call_errbacks=True):\n+    def on_error(\n+            request: celery.app.task.Context,\n+            exc: Union[Exception, Type[Exception]],\n+            state: str = FAILURE,\n+            call_errbacks: bool = True) -> tuple[Info, Any, Any, Any]:",
      "comment": "I think you'll want to use `Tuple` from `typing` here to support Python < 3.9 (I think it was 3.9 which added that...)\r\n\r\n```suggestion\r\n            call_errbacks: bool = True) -> Tuple[Info, Any, Any, Any]:\r\n```",
      "comment_id": 1033654938,
      "user": "clokep",
      "created_at": "2022-11-28T15:02:23Z",
      "url": "https://github.com/celery/celery/pull/7925#discussion_r1033654938"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7925,
      "file_path": "celery/app/trace.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -378,7 +396,13 @@ def on_error(request, exc, state=FAILURE, call_errbacks=True):\n         )\n         return I, R, I.state, I.retval\n \n-    def trace_task(uuid, args, kwargs, request=None):\n+    def trace_task(\n+            uuid: str,\n+            args: Sequence[Any],\n+            kwargs: dict[str, Any],\n+            request: Optional[dict[str, Any]] = None) -> trace_ok_t:",
      "comment": "Again, I think you need to use `Dict` here:\r\n\r\n```suggestion\r\n            kwargs: Dict[str, Any],\r\n            request: Optional[Dict[str, Any]] = None) -> trace_ok_t:\r\n```",
      "comment_id": 1033655853,
      "user": "clokep",
      "created_at": "2022-11-28T15:03:12Z",
      "url": "https://github.com/celery/celery/pull/7925#discussion_r1033655853"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7925,
      "file_path": "celery/app/trace.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -378,7 +396,13 @@ def on_error(request, exc, state=FAILURE, call_errbacks=True):\n         )\n         return I, R, I.state, I.retval\n \n-    def trace_task(uuid, args, kwargs, request=None):\n+    def trace_task(\n+            uuid: str,\n+            args: Sequence[Any],\n+            kwargs: dict[str, Any],\n+            request: Optional[dict[str, Any]] = None) -> trace_ok_t:",
      "comment": "And again! Anybody would think I was not paying attention.",
      "comment_id": 1033835688,
      "user": "ShaheedHaque",
      "created_at": "2022-11-28T17:28:29Z",
      "url": "https://github.com/celery/celery/pull/7925#discussion_r1033835688"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7925,
      "file_path": "celery/app/trace.py",
      "line": 389,
      "side": "RIGHT",
      "diff_hunk": "@@ -369,7 +382,12 @@ def build_tracer(name, task, loader=None, hostname=None, store_errors=True,\n     from celery import canvas\n     signature = canvas.maybe_signature  # maybe_ does not clone if already\n \n-    def on_error(request, exc, state=FAILURE, call_errbacks=True):\n+    def on_error(\n+            request: celery.app.task.Context,\n+            exc: Union[Exception, Type[Exception]],\n+            state: str = FAILURE,\n+            call_errbacks: bool = True) -> Tuple[Info, Any, Any, Any]:",
      "comment": "I believe that `I.state` is a string, but that can always be tightened up in the future.\r\n\r\n```suggestion\r\n            call_errbacks: bool = True) -> Tuple[Info, Any, str, Any]:\r\n```",
      "comment_id": 1061424217,
      "user": "clokep",
      "created_at": "2023-01-04T12:18:15Z",
      "url": "https://github.com/celery/celery/pull/7925#discussion_r1061424217"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8793,
      "file_path": "t/smoke/conftest.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,49 @@\n+import os\n+\n+import pytest\n+from pytest_celery import REDIS_CONTAINER_TIMEOUT, REDIS_ENV, REDIS_IMAGE, REDIS_PORTS, RedisContainer\n+from pytest_docker_tools import container, fetch, network\n+\n+from t.smoke.operations.task_termination import TaskTermination\n+from t.smoke.operations.worker_kill import WorkerKill\n+from t.smoke.operations.worker_restart import WorkerRestart\n+from t.smoke.workers.alt import *  # noqa\n+from t.smoke.workers.dev import *  # noqa\n+from t.smoke.workers.latest import *  # noqa\n+from t.smoke.workers.other import *  # noqa",
      "comment": "We can sustain it for the moment. Changes may still occur before the next official release.",
      "comment_id": 1451794563,
      "user": "Nusnus",
      "created_at": "2024-01-14T20:04:24Z",
      "url": "https://github.com/celery/celery/pull/8793#discussion_r1451794563"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8793,
      "file_path": "t/smoke/tasks.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from __future__ import annotations\n+\n+import os\n+import sys\n+from signal import SIGKILL\n+from time import sleep\n+\n+import celery.utils\n+from celery import Task, shared_task, signature\n+from celery.canvas import Signature\n+from t.integration.tasks import *  # noqa",
      "comment": "To allow the smoke tests containers access to all of the codebase of the integration tests tasks.\r\nThis will greatly reduce code duplication",
      "comment_id": 1451794770,
      "user": "Nusnus",
      "created_at": "2024-01-14T20:05:34Z",
      "url": "https://github.com/celery/celery/pull/8793#discussion_r1451794770"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8755,
      "file_path": "celery/utils/term.py",
      "line": 171,
      "side": "LEFT",
      "diff_hunk": "@@ -71,107 +74,107 @@ def _fold_no_color(self, a, b):\n \n         return ''.join((str(A), str(B)))\n \n-    def no_color(self):\n+    def no_color(self) -> str:\n         if self.s:\n             return str(reduce(self._fold_no_color, self.s))\n         return ''\n \n-    def embed(self):\n+    def embed(self) -> str:\n         prefix = ''\n         if self.enabled:\n             prefix = self.op\n         return ''.join((str(prefix), str(reduce(self._add, self.s))))\n \n-    def __str__(self):\n+    def __str__(self) -> str:\n         suffix = ''\n         if self.enabled:\n             suffix = RESET_SEQ\n         return str(''.join((self.embed(), str(suffix))))\n \n-    def node(self, s, op):\n+    def node(self, s: tuple[object, ...], op: str) -> colored:\n         return self.__class__(enabled=self.enabled, op=op, *s)\n \n-    def black(self, *s):\n+    def black(self, *s: object) -> colored:\n         return self.node(s, fg(30 + BLACK))\n \n-    def red(self, *s):\n+    def red(self, *s: object) -> colored:\n         return self.node(s, fg(30 + RED))\n \n-    def green(self, *s):\n+    def green(self, *s: object) -> colored:\n         return self.node(s, fg(30 + GREEN))\n \n-    def yellow(self, *s):\n+    def yellow(self, *s: object) -> colored:\n         return self.node(s, fg(30 + YELLOW))\n \n-    def blue(self, *s):\n+    def blue(self, *s: object) -> colored:\n         return self.node(s, fg(30 + BLUE))\n \n-    def magenta(self, *s):\n+    def magenta(self, *s: object) -> colored:\n         return self.node(s, fg(30 + MAGENTA))\n \n-    def cyan(self, *s):\n+    def cyan(self, *s: object) -> colored:\n         return self.node(s, fg(30 + CYAN))\n \n-    def white(self, *s):\n+    def white(self, *s: object) -> colored:\n         return self.node(s, fg(30 + WHITE))\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return repr(self.no_color())\n \n-    def bold(self, *s):\n+    def bold(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 1)\n \n-    def underline(self, *s):\n+    def underline(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 4)\n \n-    def blink(self, *s):\n+    def blink(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 5)\n \n-    def reverse(self, *s):\n+    def reverse(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 7)\n \n-    def bright(self, *s):\n+    def bright(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 8)\n \n-    def ired(self, *s):\n+    def ired(self, *s: object) -> colored:\n         return self.node(s, fg(40 + RED))\n \n-    def igreen(self, *s):\n+    def igreen(self, *s: object) -> colored:\n         return self.node(s, fg(40 + GREEN))\n \n-    def iyellow(self, *s):\n+    def iyellow(self, *s: object) -> colored:\n         return self.node(s, fg(40 + YELLOW))\n \n-    def iblue(self, *s):\n+    def iblue(self, *s: colored) -> colored:\n         return self.node(s, fg(40 + BLUE))\n \n-    def imagenta(self, *s):\n+    def imagenta(self, *s: object) -> colored:\n         return self.node(s, fg(40 + MAGENTA))\n \n-    def icyan(self, *s):\n+    def icyan(self, *s: object) -> colored:\n         return self.node(s, fg(40 + CYAN))\n \n-    def iwhite(self, *s):\n+    def iwhite(self, *s: object) -> colored:\n         return self.node(s, fg(40 + WHITE))\n \n-    def reset(self, *s):\n-        return self.node(s or [''], RESET_SEQ)\n+    def reset(self, *s: object) -> colored:\n+        return self.node(s or ('',), RESET_SEQ)\n \n-    def __add__(self, other):\n-        return str(self) + str(other)\n+    def __add__(self, other: object) -> str:\n+        return f\"{self}{other}\"\n \n \n-def supports_images():\n-    return sys.stdin.isatty() and ITERM_PROFILE\n+def supports_images() -> bool:\n+    return sys.stdin.isatty() and ITERM_PROFILE is not None\n \n \n-def _read_as_base64(path):\n-    with codecs.open(path, mode='rb') as fh:\n+def _read_as_base64(path: str) -> str:\n+    with open(path, mode='rb') as fh:\n         encoded = base64.b64encode(fh.read())\n-        return encoded if isinstance(encoded, str) else encoded.decode('ascii')",
      "comment": "The return value of b64encode() is bytes thus encoded is bytes. \r\nIf I missed something let me know and i'll set it back\r\n\r\n### Sources\r\n[b64encode() return value](https://docs.python.org/3.7/library/base64.html#base64.b64encode)",
      "comment_id": 1443817885,
      "user": "em1le",
      "created_at": "2024-01-06T18:19:36Z",
      "url": "https://github.com/celery/celery/pull/8755#discussion_r1443817885"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8755,
      "file_path": "celery/utils/term.py",
      "line": 171,
      "side": "LEFT",
      "diff_hunk": "@@ -71,107 +74,107 @@ def _fold_no_color(self, a, b):\n \n         return ''.join((str(A), str(B)))\n \n-    def no_color(self):\n+    def no_color(self) -> str:\n         if self.s:\n             return str(reduce(self._fold_no_color, self.s))\n         return ''\n \n-    def embed(self):\n+    def embed(self) -> str:\n         prefix = ''\n         if self.enabled:\n             prefix = self.op\n         return ''.join((str(prefix), str(reduce(self._add, self.s))))\n \n-    def __str__(self):\n+    def __str__(self) -> str:\n         suffix = ''\n         if self.enabled:\n             suffix = RESET_SEQ\n         return str(''.join((self.embed(), str(suffix))))\n \n-    def node(self, s, op):\n+    def node(self, s: tuple[object, ...], op: str) -> colored:\n         return self.__class__(enabled=self.enabled, op=op, *s)\n \n-    def black(self, *s):\n+    def black(self, *s: object) -> colored:\n         return self.node(s, fg(30 + BLACK))\n \n-    def red(self, *s):\n+    def red(self, *s: object) -> colored:\n         return self.node(s, fg(30 + RED))\n \n-    def green(self, *s):\n+    def green(self, *s: object) -> colored:\n         return self.node(s, fg(30 + GREEN))\n \n-    def yellow(self, *s):\n+    def yellow(self, *s: object) -> colored:\n         return self.node(s, fg(30 + YELLOW))\n \n-    def blue(self, *s):\n+    def blue(self, *s: object) -> colored:\n         return self.node(s, fg(30 + BLUE))\n \n-    def magenta(self, *s):\n+    def magenta(self, *s: object) -> colored:\n         return self.node(s, fg(30 + MAGENTA))\n \n-    def cyan(self, *s):\n+    def cyan(self, *s: object) -> colored:\n         return self.node(s, fg(30 + CYAN))\n \n-    def white(self, *s):\n+    def white(self, *s: object) -> colored:\n         return self.node(s, fg(30 + WHITE))\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return repr(self.no_color())\n \n-    def bold(self, *s):\n+    def bold(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 1)\n \n-    def underline(self, *s):\n+    def underline(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 4)\n \n-    def blink(self, *s):\n+    def blink(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 5)\n \n-    def reverse(self, *s):\n+    def reverse(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 7)\n \n-    def bright(self, *s):\n+    def bright(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 8)\n \n-    def ired(self, *s):\n+    def ired(self, *s: object) -> colored:\n         return self.node(s, fg(40 + RED))\n \n-    def igreen(self, *s):\n+    def igreen(self, *s: object) -> colored:\n         return self.node(s, fg(40 + GREEN))\n \n-    def iyellow(self, *s):\n+    def iyellow(self, *s: object) -> colored:\n         return self.node(s, fg(40 + YELLOW))\n \n-    def iblue(self, *s):\n+    def iblue(self, *s: colored) -> colored:\n         return self.node(s, fg(40 + BLUE))\n \n-    def imagenta(self, *s):\n+    def imagenta(self, *s: object) -> colored:\n         return self.node(s, fg(40 + MAGENTA))\n \n-    def icyan(self, *s):\n+    def icyan(self, *s: object) -> colored:\n         return self.node(s, fg(40 + CYAN))\n \n-    def iwhite(self, *s):\n+    def iwhite(self, *s: object) -> colored:\n         return self.node(s, fg(40 + WHITE))\n \n-    def reset(self, *s):\n-        return self.node(s or [''], RESET_SEQ)\n+    def reset(self, *s: object) -> colored:\n+        return self.node(s or ('',), RESET_SEQ)\n \n-    def __add__(self, other):\n-        return str(self) + str(other)\n+    def __add__(self, other: object) -> str:\n+        return f\"{self}{other}\"\n \n \n-def supports_images():\n-    return sys.stdin.isatty() and ITERM_PROFILE\n+def supports_images() -> bool:\n+    return sys.stdin.isatty() and ITERM_PROFILE is not None\n \n \n-def _read_as_base64(path):\n-    with codecs.open(path, mode='rb') as fh:\n+def _read_as_base64(path: str) -> str:\n+    with open(path, mode='rb') as fh:\n         encoded = base64.b64encode(fh.read())\n-        return encoded if isinstance(encoded, str) else encoded.decode('ascii')",
      "comment": "Awaiting your feedback upon my previous answer and i will split changes accordingly.",
      "comment_id": 1443818050,
      "user": "em1le",
      "created_at": "2024-01-06T18:21:29Z",
      "url": "https://github.com/celery/celery/pull/8755#discussion_r1443818050"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8755,
      "file_path": "celery/utils/term.py",
      "line": 171,
      "side": "LEFT",
      "diff_hunk": "@@ -71,107 +74,107 @@ def _fold_no_color(self, a, b):\n \n         return ''.join((str(A), str(B)))\n \n-    def no_color(self):\n+    def no_color(self) -> str:\n         if self.s:\n             return str(reduce(self._fold_no_color, self.s))\n         return ''\n \n-    def embed(self):\n+    def embed(self) -> str:\n         prefix = ''\n         if self.enabled:\n             prefix = self.op\n         return ''.join((str(prefix), str(reduce(self._add, self.s))))\n \n-    def __str__(self):\n+    def __str__(self) -> str:\n         suffix = ''\n         if self.enabled:\n             suffix = RESET_SEQ\n         return str(''.join((self.embed(), str(suffix))))\n \n-    def node(self, s, op):\n+    def node(self, s: tuple[object, ...], op: str) -> colored:\n         return self.__class__(enabled=self.enabled, op=op, *s)\n \n-    def black(self, *s):\n+    def black(self, *s: object) -> colored:\n         return self.node(s, fg(30 + BLACK))\n \n-    def red(self, *s):\n+    def red(self, *s: object) -> colored:\n         return self.node(s, fg(30 + RED))\n \n-    def green(self, *s):\n+    def green(self, *s: object) -> colored:\n         return self.node(s, fg(30 + GREEN))\n \n-    def yellow(self, *s):\n+    def yellow(self, *s: object) -> colored:\n         return self.node(s, fg(30 + YELLOW))\n \n-    def blue(self, *s):\n+    def blue(self, *s: object) -> colored:\n         return self.node(s, fg(30 + BLUE))\n \n-    def magenta(self, *s):\n+    def magenta(self, *s: object) -> colored:\n         return self.node(s, fg(30 + MAGENTA))\n \n-    def cyan(self, *s):\n+    def cyan(self, *s: object) -> colored:\n         return self.node(s, fg(30 + CYAN))\n \n-    def white(self, *s):\n+    def white(self, *s: object) -> colored:\n         return self.node(s, fg(30 + WHITE))\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return repr(self.no_color())\n \n-    def bold(self, *s):\n+    def bold(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 1)\n \n-    def underline(self, *s):\n+    def underline(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 4)\n \n-    def blink(self, *s):\n+    def blink(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 5)\n \n-    def reverse(self, *s):\n+    def reverse(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 7)\n \n-    def bright(self, *s):\n+    def bright(self, *s: object) -> colored:\n         return self.node(s, OP_SEQ % 8)\n \n-    def ired(self, *s):\n+    def ired(self, *s: object) -> colored:\n         return self.node(s, fg(40 + RED))\n \n-    def igreen(self, *s):\n+    def igreen(self, *s: object) -> colored:\n         return self.node(s, fg(40 + GREEN))\n \n-    def iyellow(self, *s):\n+    def iyellow(self, *s: object) -> colored:\n         return self.node(s, fg(40 + YELLOW))\n \n-    def iblue(self, *s):\n+    def iblue(self, *s: colored) -> colored:\n         return self.node(s, fg(40 + BLUE))\n \n-    def imagenta(self, *s):\n+    def imagenta(self, *s: object) -> colored:\n         return self.node(s, fg(40 + MAGENTA))\n \n-    def icyan(self, *s):\n+    def icyan(self, *s: object) -> colored:\n         return self.node(s, fg(40 + CYAN))\n \n-    def iwhite(self, *s):\n+    def iwhite(self, *s: object) -> colored:\n         return self.node(s, fg(40 + WHITE))\n \n-    def reset(self, *s):\n-        return self.node(s or [''], RESET_SEQ)\n+    def reset(self, *s: object) -> colored:\n+        return self.node(s or ('',), RESET_SEQ)\n \n-    def __add__(self, other):\n-        return str(self) + str(other)\n+    def __add__(self, other: object) -> str:\n+        return f\"{self}{other}\"\n \n \n-def supports_images():\n-    return sys.stdin.isatty() and ITERM_PROFILE\n+def supports_images() -> bool:\n+    return sys.stdin.isatty() and ITERM_PROFILE is not None\n \n \n-def _read_as_base64(path):\n-    with codecs.open(path, mode='rb') as fh:\n+def _read_as_base64(path: str) -> str:\n+    with open(path, mode='rb') as fh:\n         encoded = base64.b64encode(fh.read())\n-        return encoded if isinstance(encoded, str) else encoded.decode('ascii')",
      "comment": "Good catch and thanks for confirming your change!\r\n\r\nPlease do split the changes and consider this line as approved @em1le .\r\nThank you!",
      "comment_id": 1443834780,
      "user": "Nusnus",
      "created_at": "2024-01-06T19:15:50Z",
      "url": "https://github.com/celery/celery/pull/8755#discussion_r1443834780"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8750,
      "file_path": "celery/utils/iso8601.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +50,7 @@\n )\n \n \n-def parse_iso8601(datestring):\n+def parse_iso8601(datestring: str) -> str:",
      "comment": "Why `str`? Doesn't it return a `datetime` instance?",
      "comment_id": 1441679647,
      "user": "lelit",
      "created_at": "2024-01-04T12:14:47Z",
      "url": "https://github.com/celery/celery/pull/8750#discussion_r1441679647"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8750,
      "file_path": "celery/utils/iso8601.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +50,7 @@\n )\n \n \n-def parse_iso8601(datestring):\n+def parse_iso8601(datestring: str) -> str:",
      "comment": "True, nice catch, my bad actually, i'm going to change it right now.\r\nChange available on #8752 ",
      "comment_id": 1441850466,
      "user": "em1le",
      "created_at": "2024-01-04T14:50:30Z",
      "url": "https://github.com/celery/celery/pull/8750#discussion_r1441850466"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8726,
      "file_path": "t/unit/app/test_beat.py",
      "line": 875,
      "side": "RIGHT",
      "diff_hunk": "@@ -863,17 +863,17 @@ class test_schedule:\n     def test_maybe_make_aware(self):\n         x = schedule(10, app=self.app)\n         x.utc_enabled = True\n-        d = x.maybe_make_aware(datetime.utcnow())\n+        d = x.maybe_make_aware(datetime.now(timezone.utc))\n         assert d.tzinfo\n         x.utc_enabled = False\n-        d2 = x.maybe_make_aware(datetime.utcnow())\n+        d2 = x.maybe_make_aware(datetime.now(timezone.utc))\n         assert d2.tzinfo\n \n     def test_to_local(self):\n         x = schedule(10, app=self.app)\n         x.utc_enabled = True\n-        d = x.to_local(datetime.utcnow())\n+        d = x.to_local(datetime.utcnow())  # datetime.utcnow() is deprecated in Python 3.12",
      "comment": "Tests will fail because naive datetime != timezone-aware datetime.\r\n```python\r\ndatetime.datetime(2023, 12, 17, 7, 15, 8, 873338) !=\r\ndatetime.datetime(2023, 12, 17, 7, 15, 8, 873338, tzinfo=datetime.timezone.utc)\r\n ```",
      "comment_id": 1427196454,
      "user": "cclauss",
      "created_at": "2023-12-14T19:47:54Z",
      "url": "https://github.com/celery/celery/pull/8726#discussion_r1427196454"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8667,
      "file_path": "celery/utils/nodenames.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,57 +57,62 @@ def worker_direct(hostname):\n     )\n \n \n-def nodename(name, hostname):\n+def nodename(name: str, hostname: str) -> str:\n     \"\"\"Create node name from name/hostname pair.\"\"\"\n     return NODENAME_SEP.join((name, hostname))\n \n \n-def anon_nodename(hostname=None, prefix='gen'):\n+def anon_nodename(hostname: str | None = None, prefix: str = 'gen') -> str:\n     \"\"\"Return the nodename for this process (not a worker).\n \n     This is used for e.g. the origin task message field.\n     \"\"\"\n-    return nodename(''.join([prefix, str(os.getpid())]),\n-                    hostname or gethostname())\n+    return nodename(''.join([prefix, str(os.getpid())]), hostname or gethostname())\n \n \n-def nodesplit(name):\n+def nodesplit(name: str) -> tuple[None, str] | list[str]:\n     \"\"\"Split node name into tuple of name/hostname.\"\"\"\n-    parts = name.split(NODENAME_SEP, 1)\n+    parts: list[str] = name.split(NODENAME_SEP, 1)\n     if len(parts) == 1:\n         return None, parts[0]\n     return parts\n \n \n-def default_nodename(hostname):\n+def default_nodename(hostname: str) -> str:\n     \"\"\"Return the default nodename for this process.\"\"\"\n     name, host = nodesplit(hostname or '')\n     return nodename(name or NODENAME_DEFAULT, host or gethostname())\n \n \n-def node_format(s, name, **extra):\n+def node_format(s: str, name: str, **extra: Any) -> str:",
      "comment": "```suggestion\r\ndef node_format(s: str, name: str, **extra: dict) -> str:\r\n```",
      "comment_id": 1404137811,
      "user": "Nusnus",
      "created_at": "2023-11-24T09:35:37Z",
      "url": "https://github.com/celery/celery/pull/8667#discussion_r1404137811"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8667,
      "file_path": "celery/utils/nodenames.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,57 +57,62 @@ def worker_direct(hostname):\n     )\n \n \n-def nodename(name, hostname):\n+def nodename(name: str, hostname: str) -> str:\n     \"\"\"Create node name from name/hostname pair.\"\"\"\n     return NODENAME_SEP.join((name, hostname))\n \n \n-def anon_nodename(hostname=None, prefix='gen'):\n+def anon_nodename(hostname: str | None = None, prefix: str = 'gen') -> str:\n     \"\"\"Return the nodename for this process (not a worker).\n \n     This is used for e.g. the origin task message field.\n     \"\"\"\n-    return nodename(''.join([prefix, str(os.getpid())]),\n-                    hostname or gethostname())\n+    return nodename(''.join([prefix, str(os.getpid())]), hostname or gethostname())\n \n \n-def nodesplit(name):\n+def nodesplit(name: str) -> tuple[None, str] | list[str]:\n     \"\"\"Split node name into tuple of name/hostname.\"\"\"\n-    parts = name.split(NODENAME_SEP, 1)\n+    parts: list[str] = name.split(NODENAME_SEP, 1)\n     if len(parts) == 1:\n         return None, parts[0]\n     return parts\n \n \n-def default_nodename(hostname):\n+def default_nodename(hostname: str) -> str:\n     \"\"\"Return the default nodename for this process.\"\"\"\n     name, host = nodesplit(hostname or '')\n     return nodename(name or NODENAME_DEFAULT, host or gethostname())\n \n \n-def node_format(s, name, **extra):\n+def node_format(s: str, name: str, **extra: Any) -> str:\n     \"\"\"Format worker node name (name@host.com).\"\"\"\n     shortname, host = nodesplit(name)\n-    return host_format(\n-        s, host, shortname or NODENAME_DEFAULT, p=name, **extra)\n+    return host_format(s, host, shortname or NODENAME_DEFAULT, p=name, **extra)\n \n \n-def _fmt_process_index(prefix='', default='0'):\n+def _fmt_process_index(prefix: str = '', default: str = '0') -> str:\n     from .log import current_process_index\n+\n     index = current_process_index()\n     return f'{prefix}{index}' if index else default\n \n \n _fmt_process_index_with_prefix = partial(_fmt_process_index, '-', '')\n \n \n-def host_format(s, host=None, name=None, **extra):\n+def host_format(s: str, host: str | None = None, name: str | None = None, **extra: Any) -> str:",
      "comment": "```suggestion\r\ndef host_format(s: str, host: str | None = None, name: str | None = None, **extra: dict) -> str:\r\n```",
      "comment_id": 1404138818,
      "user": "Nusnus",
      "created_at": "2023-11-24T09:36:34Z",
      "url": "https://github.com/celery/celery/pull/8667#discussion_r1404138818"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8667,
      "file_path": "celery/utils/nodenames.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,57 +57,62 @@ def worker_direct(hostname):\n     )\n \n \n-def nodename(name, hostname):\n+def nodename(name: str, hostname: str) -> str:\n     \"\"\"Create node name from name/hostname pair.\"\"\"\n     return NODENAME_SEP.join((name, hostname))\n \n \n-def anon_nodename(hostname=None, prefix='gen'):\n+def anon_nodename(hostname: str | None = None, prefix: str = 'gen') -> str:\n     \"\"\"Return the nodename for this process (not a worker).\n \n     This is used for e.g. the origin task message field.\n     \"\"\"\n-    return nodename(''.join([prefix, str(os.getpid())]),\n-                    hostname or gethostname())\n+    return nodename(''.join([prefix, str(os.getpid())]), hostname or gethostname())\n \n \n-def nodesplit(name):\n+def nodesplit(name: str) -> tuple[None, str] | list[str]:\n     \"\"\"Split node name into tuple of name/hostname.\"\"\"\n-    parts = name.split(NODENAME_SEP, 1)\n+    parts: list[str] = name.split(NODENAME_SEP, 1)",
      "comment": "```suggestion\r\n    parts = name.split(NODENAME_SEP, 1)\r\n```\r\nThis is unnecessary, in general explicitly typing a variable is avoided",
      "comment_id": 1413196409,
      "user": "Viicos",
      "created_at": "2023-12-03T19:55:55Z",
      "url": "https://github.com/celery/celery/pull/8667#discussion_r1413196409"
    },
    {
      "repo": "celery/celery",
      "pr_number": 6917,
      "file_path": "celery/concurrency/eventlet.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,8 +109,9 @@ def __init__(self, *args, **kwargs):\n \n     def on_start(self):\n         self._pool = self.Pool(self.limit)\n+        self._pool_map = {}\n         signals.eventlet_pool_started.send(sender=self)\n-        self._quick_put = self._pool.spawn_n\n+        self._quick_put = self._pool.spawn",
      "comment": "According to [documentation](http://eventlet.net/doc/modules/greenpool.html#eventlet.greenpool.GreenPool.spawn_n) `spawn_n` returns None while `spawn` returns `greenlet`/`greenthread`. \r\n",
      "comment_id": 691388948,
      "user": "idj97",
      "created_at": "2021-08-18T15:54:50Z",
      "url": "https://github.com/celery/celery/pull/6917#discussion_r691388948"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8581,
      "file_path": "celery/app/defaults.py",
      "line": 328,
      "side": "RIGHT",
      "diff_hunk": "@@ -325,6 +325,7 @@ def __repr__(self):\n         pool_restarts=Option(False, type='bool'),\n         proc_alive_timeout=Option(4.0, type='float'),\n         prefetch_multiplier=Option(4, type='int'),\n+        enable_prefetch_count=Option(True, type='bool'),",
      "comment": "`enable_prefetch_count_reduction_on_connection_restart` was too long. Went for:\r\n`enable_prefetch_count_reduction`",
      "comment_id": 1367961236,
      "user": "Nusnus",
      "created_at": "2023-10-22T19:56:04Z",
      "url": "https://github.com/celery/celery/pull/8581#discussion_r1367961236"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8660,
      "file_path": "celery/loaders/base.py",
      "line": 274,
      "side": "RIGHT",
      "diff_hunk": "@@ -271,7 +271,7 @@ def find_related_module(package, related_name):\n     except ModuleNotFoundError as e:\n         import_exc_name = getattr(e, 'name', None)\n         # If candidate does not exist, then return None.\n-        if import_exc_name and module_name.startswith(import_exc_name):\n+        if import_exc_name and module_name == import_exc_name:",
      "comment": "should we adjust the unit tests as well? with this new change?",
      "comment_id": 1401693106,
      "user": "auvipy",
      "created_at": "2023-11-22T08:45:02Z",
      "url": "https://github.com/celery/celery/pull/8660#discussion_r1401693106"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8632,
      "file_path": "celery/loaders/base.py",
      "line": 256,
      "side": "RIGHT",
      "diff_hunk": "@@ -253,20 +253,26 @@ def find_related_module(package, related_name):\n     # Django 1.7 allows for specifying a class name in INSTALLED_APPS.\n     # (Issue #2248).\n     try:\n+        # Return package itself when no related_name.",
      "comment": "I dropped some notes to myself in these comments to try and figure out what each of these conditions was trying to do. Happy to remove if you don't want to clutter the code.",
      "comment_id": 1389977781,
      "user": "johnjameswhitman",
      "created_at": "2023-11-10T22:18:25Z",
      "url": "https://github.com/celery/celery/pull/8632#discussion_r1389977781"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8632,
      "file_path": "t/unit/app/test_loaders.py",
      "line": 284,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,19 +234,74 @@ def test_autodiscover_tasks(self):\n             base.autodiscover_tasks(['foo'])\n             frm.assert_called()\n \n-    def test_find_related_module(self):\n+    # Happy - get something back\n+    def test_find_related_module__when_existent_package_alone(self):\n         with patch('importlib.import_module') as imp:\n             imp.return_value = Mock()\n             imp.return_value.__path__ = 'foo'\n-            assert base.find_related_module('bar', 'tasks').__path__ == 'foo'\n-            imp.assert_any_call('bar')\n-            imp.assert_any_call('bar.tasks')\n+            assert base.find_related_module('foo', None).__path__ == 'foo'\n+            imp.assert_called_once_with('foo')\n \n-            imp.reset_mock()\n-            assert base.find_related_module('bar', None).__path__ == 'foo'\n-            imp.assert_called_once_with('bar')\n+    def test_find_related_module__when_existent_package_and_related_name(self):\n+        with patch('importlib.import_module') as imp:\n+            first_import = Mock()\n+            first_import.__path__ = 'foo'\n+            second_import = Mock()\n+            second_import.__path__ = 'foo/tasks'\n+            imp.side_effect = [first_import, second_import]\n+            assert base.find_related_module('foo', 'tasks').__path__ == 'foo/tasks'\n+            imp.assert_any_call('foo')\n+            imp.assert_any_call('foo.tasks')\n+\n+    def test_find_related_module__when_existent_package_parent_and_related_name(self):\n+        with patch('importlib.import_module') as imp:\n+            first_import = ModuleNotFoundError(name='foo.BarApp')  # Ref issue #2248\n+            second_import = Mock()\n+            second_import.__path__ = 'foo/tasks'\n+            imp.side_effect = [first_import, second_import]\n+            assert base.find_related_module('foo.BarApp', 'tasks').__path__ == 'foo/tasks'\n+            imp.assert_any_call('foo.BarApp')\n+            imp.assert_any_call('foo.tasks')\n+\n+    # Sad - nothing returned\n+    def test_find_related_module__when_package_exists_but_related_name_does_not(self):\n+        with patch('importlib.import_module') as imp:\n+            first_import = Mock()\n+            first_import.__path__ = 'foo'\n+            second_import = ModuleNotFoundError(name='foo.tasks')\n+            imp.side_effect = [first_import, second_import]\n+            assert base.find_related_module('foo', 'tasks') is None\n+            imp.assert_any_call('foo')\n+            imp.assert_any_call('foo.tasks')\n+\n+    def test_find_related_module__when_existent_package_parent_but_not_related_name(self):\n+        with patch('importlib.import_module') as imp:\n+            first_import = ModuleNotFoundError(name='foo.bar')\n+            second_import = ModuleNotFoundError(name='foo.tasks')\n+            imp.side_effect = [first_import, second_import]\n+            assert base.find_related_module('foo.bar', 'tasks') is None\n+            imp.assert_any_call('foo.bar')\n+            imp.assert_any_call('foo.tasks')",
      "comment": "This is a weird case -- I'm not sure if `find_related_module` is actually meant to handle this or not, so can remove it if not.",
      "comment_id": 1389980857,
      "user": "johnjameswhitman",
      "created_at": "2023-11-10T22:23:54Z",
      "url": "https://github.com/celery/celery/pull/8632#discussion_r1389980857"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8632,
      "file_path": "t/unit/app/test_loaders.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,19 +234,74 @@ def test_autodiscover_tasks(self):\n             base.autodiscover_tasks(['foo'])\n             frm.assert_called()\n \n-    def test_find_related_module(self):\n+    # Happy - get something back\n+    def test_find_related_module__when_existent_package_alone(self):\n         with patch('importlib.import_module') as imp:\n             imp.return_value = Mock()\n             imp.return_value.__path__ = 'foo'\n-            assert base.find_related_module('bar', 'tasks').__path__ == 'foo'\n-            imp.assert_any_call('bar')\n-            imp.assert_any_call('bar.tasks')\n+            assert base.find_related_module('foo', None).__path__ == 'foo'\n+            imp.assert_called_once_with('foo')\n \n-            imp.reset_mock()\n-            assert base.find_related_module('bar', None).__path__ == 'foo'\n-            imp.assert_called_once_with('bar')\n+    def test_find_related_module__when_existent_package_and_related_name(self):\n+        with patch('importlib.import_module') as imp:\n+            first_import = Mock()\n+            first_import.__path__ = 'foo'\n+            second_import = Mock()\n+            second_import.__path__ = 'foo/tasks'\n+            imp.side_effect = [first_import, second_import]\n+            assert base.find_related_module('foo', 'tasks').__path__ == 'foo/tasks'\n+            imp.assert_any_call('foo')\n+            imp.assert_any_call('foo.tasks')\n+\n+    def test_find_related_module__when_existent_package_parent_and_related_name(self):\n+        with patch('importlib.import_module') as imp:\n+            first_import = ModuleNotFoundError(name='foo.BarApp')  # Ref issue #2248",
      "comment": "It seems like this behavior was added to match some edge case w/ how Django apps present themselves for auto-discovery (see #2248).",
      "comment_id": 1389981573,
      "user": "johnjameswhitman",
      "created_at": "2023-11-10T22:24:54Z",
      "url": "https://github.com/celery/celery/pull/8632#discussion_r1389981573"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8632,
      "file_path": "celery/loaders/base.py",
      "line": 270,
      "side": "LEFT",
      "diff_hunk": "@@ -253,20 +253,26 @@ def find_related_module(package, related_name):\n     # Django 1.7 allows for specifying a class name in INSTALLED_APPS.\n     # (Issue #2248).\n     try:\n+        # Return package itself when no related_name.\n         module = importlib.import_module(package)\n         if not related_name and module:\n             return module\n-    except ImportError:\n+    except ModuleNotFoundError:\n+        # On import error, try to walk package up one level.\n         package, _, _ = package.rpartition('.')\n         if not package:\n             raise\n \n     module_name = f'{package}.{related_name}'\n \n     try:\n+        # Try to find related_name under package.\n         return importlib.import_module(module_name)\n-    except ImportError as e:\n+    except ModuleNotFoundError as e:\n         import_exc_name = getattr(e, 'name', module_name)\n-        if import_exc_name is not None and import_exc_name != module_name:",
      "comment": "can we make sure this change / removal won't create any regression?",
      "comment_id": 1395364817,
      "user": "auvipy",
      "created_at": "2023-11-16T09:00:53Z",
      "url": "https://github.com/celery/celery/pull/8632#discussion_r1395364817"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8632,
      "file_path": "celery/loaders/base.py",
      "line": 270,
      "side": "LEFT",
      "diff_hunk": "@@ -253,20 +253,26 @@ def find_related_module(package, related_name):\n     # Django 1.7 allows for specifying a class name in INSTALLED_APPS.\n     # (Issue #2248).\n     try:\n+        # Return package itself when no related_name.\n         module = importlib.import_module(package)\n         if not related_name and module:\n             return module\n-    except ImportError:\n+    except ModuleNotFoundError:\n+        # On import error, try to walk package up one level.\n         package, _, _ = package.rpartition('.')\n         if not package:\n             raise\n \n     module_name = f'{package}.{related_name}'\n \n     try:\n+        # Try to find related_name under package.\n         return importlib.import_module(module_name)\n-    except ImportError as e:\n+    except ModuleNotFoundError as e:\n         import_exc_name = getattr(e, 'name', module_name)\n-        if import_exc_name is not None and import_exc_name != module_name:",
      "comment": "Will do -- I should have some more time to look at this next week.",
      "comment_id": 1397583914,
      "user": "johnjameswhitman",
      "created_at": "2023-11-17T16:34:56Z",
      "url": "https://github.com/celery/celery/pull/8632#discussion_r1397583914"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8632,
      "file_path": "celery/loaders/base.py",
      "line": 270,
      "side": "LEFT",
      "diff_hunk": "@@ -253,20 +253,26 @@ def find_related_module(package, related_name):\n     # Django 1.7 allows for specifying a class name in INSTALLED_APPS.\n     # (Issue #2248).\n     try:\n+        # Return package itself when no related_name.\n         module = importlib.import_module(package)\n         if not related_name and module:\n             return module\n-    except ImportError:\n+    except ModuleNotFoundError:\n+        # On import error, try to walk package up one level.\n         package, _, _ = package.rpartition('.')\n         if not package:\n             raise\n \n     module_name = f'{package}.{related_name}'\n \n     try:\n+        # Try to find related_name under package.\n         return importlib.import_module(module_name)\n-    except ImportError as e:\n+    except ModuleNotFoundError as e:\n         import_exc_name = getattr(e, 'name', module_name)\n-        if import_exc_name is not None and import_exc_name != module_name:",
      "comment": "will appreciate this to be done today.... but if you need some more time that is completely fine and we can merge this after 5.3.6 release of celery?",
      "comment_id": 1398832737,
      "user": "auvipy",
      "created_at": "2023-11-20T08:54:30Z",
      "url": "https://github.com/celery/celery/pull/8632#discussion_r1398832737"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8632,
      "file_path": "celery/loaders/base.py",
      "line": 270,
      "side": "LEFT",
      "diff_hunk": "@@ -253,20 +253,26 @@ def find_related_module(package, related_name):\n     # Django 1.7 allows for specifying a class name in INSTALLED_APPS.\n     # (Issue #2248).\n     try:\n+        # Return package itself when no related_name.\n         module = importlib.import_module(package)\n         if not related_name and module:\n             return module\n-    except ImportError:\n+    except ModuleNotFoundError:\n+        # On import error, try to walk package up one level.\n         package, _, _ = package.rpartition('.')\n         if not package:\n             raise\n \n     module_name = f'{package}.{related_name}'\n \n     try:\n+        # Try to find related_name under package.\n         return importlib.import_module(module_name)\n-    except ImportError as e:\n+    except ModuleNotFoundError as e:\n         import_exc_name = getattr(e, 'name', module_name)\n-        if import_exc_name is not None and import_exc_name != module_name:",
      "comment": "Dropped an integration test in -- LMK how that looks :pray:",
      "comment_id": 1399868629,
      "user": "johnjameswhitman",
      "created_at": "2023-11-20T23:38:24Z",
      "url": "https://github.com/celery/celery/pull/8632#discussion_r1399868629"
    },
    {
      "repo": "celery/celery",
      "pr_number": 6566,
      "file_path": "celery/worker/consumer/gossip.py",
      "line": 179,
      "side": "RIGHT",
      "diff_hunk": "@@ -176,6 +176,7 @@ def get_consumers(self, channel):\n             channel,\n             queues=[ev.queue],\n             on_message=partial(self.on_message, ev.event_from_message),\n+            accept=ev.accept,",
      "comment": "hey, thanks for the PR, but this change needs some unit test to get accepted",
      "comment_id": 549355084,
      "user": "auvipy",
      "created_at": "2020-12-28T13:51:46Z",
      "url": "https://github.com/celery/celery/pull/6566#discussion_r549355084"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8619,
      "file_path": "t/unit/app/test_app.py",
      "line": 703,
      "side": "RIGHT",
      "diff_hunk": "@@ -696,6 +696,13 @@ class Config:\n             assert exc.args[0].startswith('task_default_delivery_mode')\n             assert 'CELERY_DEFAULT_DELIVERY_MODE' in exc.args[0]\n \n+    def test_config_form_object__module_attr_does_not_exist(self):\n+        with pytest.raises(ModuleNotFoundError) as exc:\n+            self.app.config_from_object(f'{__name__}.bar')\n+            # the module must exist, but it should not have the config attr\n+            assert self.app.conf.broker_url is None",
      "comment": "Shouldn't this and the next assertion be outside the `with` scope?",
      "comment_id": 1385454219,
      "user": "Nusnus",
      "created_at": "2023-11-07T19:29:21Z",
      "url": "https://github.com/celery/celery/pull/8619#discussion_r1385454219"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8619,
      "file_path": "celery/app/base.py",
      "line": 984,
      "side": "RIGHT",
      "diff_hunk": "@@ -975,7 +975,14 @@ def _finalize_pending_conf(self):\n             This is used by PendingConfiguration:\n                 as soon as you access a key the configuration is read.\n         \"\"\"\n-        conf = self._conf = self._load_config()\n+        try:\n+            conf = self._conf = self._load_config()\n+        except AttributeError as e:\n+            # AttributeError is not propagated, it is \"handled\" by\n+            # PendingConfiguration parent class. This causes\n+            # confusing RecursionError.\n+            raise ModuleNotFoundError(*e.args)",
      "comment": "You can use `raise from` e.g raise Module..() from e",
      "comment_id": 1385457912,
      "user": "Nusnus",
      "created_at": "2023-11-07T19:33:06Z",
      "url": "https://github.com/celery/celery/pull/8619#discussion_r1385457912"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8611,
      "file_path": "t/unit/tasks/test_result.py",
      "line": 395,
      "side": "RIGHT",
      "diff_hunk": "@@ -389,12 +390,17 @@ def test_ready(self):\n \n         assert not self.app.AsyncResult(uuid()).ready()\n \n+    @pytest.mark.skipif(\n+        platform.python_implementation() == \"PyPy\",\n+        reason=\"Mocking here doesn't play well with PyPy\",",
      "comment": "TBH I'm not sure why it fails only with PyPy, but I skip it to allow us to move forward.\r\nNot sure if it's acceptable @auvipy ",
      "comment_id": 1384069944,
      "user": "Nusnus",
      "created_at": "2023-11-06T21:53:53Z",
      "url": "https://github.com/celery/celery/pull/8611#discussion_r1384069944"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8519,
      "file_path": "celery/backends/elasticsearch.py",
      "line": 262,
      "side": "RIGHT",
      "diff_hunk": "@@ -225,21 +249,33 @@ def mget(self, keys):\n         return [self.get(key) for key in keys]\n \n     def delete(self, key):\n-        self.server.delete(index=self.index, doc_type=self.doc_type, id=key)\n+        if self.doc_type:\n+            self.server.delete(index=self.index, id=key, doc_type=self.doc_type)\n+        else:\n+            self.server.delete(index=self.index, id=key)\n \n     def _get_server(self):\n         \"\"\"Connect to the Elasticsearch server.\"\"\"\n         http_auth = None\n         if self.username and self.password:\n             http_auth = (self.username, self.password)\n-        return elasticsearch.Elasticsearch(\n-            f'{self.host}:{self.port}',\n-            retry_on_timeout=self.es_retry_on_timeout,\n-            max_retries=self.es_max_retries,\n-            timeout=self.es_timeout,\n-            scheme=self.scheme,\n-            http_auth=http_auth,\n-        )\n+        if elasticsearch.VERSION[0] <= 7:",
      "comment": "I'll do some digging on the client side to see what specific version they removed the scheme parameter from. But I know the 8.9 client version I installed did not have it where the 7.17 client did. So I assumed that 7.x and below would require the scheme parameter. I'll also check if I supply it as part of the URI with the 7.x client if I can skip the scheme entirely and not have that if check at all. ",
      "comment_id": 1331517120,
      "user": "flipfloptech",
      "created_at": "2023-09-20T11:54:37Z",
      "url": "https://github.com/celery/celery/pull/8519#discussion_r1331517120"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8519,
      "file_path": "celery/backends/elasticsearch.py",
      "line": 262,
      "side": "RIGHT",
      "diff_hunk": "@@ -225,21 +249,33 @@ def mget(self, keys):\n         return [self.get(key) for key in keys]\n \n     def delete(self, key):\n-        self.server.delete(index=self.index, doc_type=self.doc_type, id=key)\n+        if self.doc_type:\n+            self.server.delete(index=self.index, id=key, doc_type=self.doc_type)\n+        else:\n+            self.server.delete(index=self.index, id=key)\n \n     def _get_server(self):\n         \"\"\"Connect to the Elasticsearch server.\"\"\"\n         http_auth = None\n         if self.username and self.password:\n             http_auth = (self.username, self.password)\n-        return elasticsearch.Elasticsearch(\n-            f'{self.host}:{self.port}',\n-            retry_on_timeout=self.es_retry_on_timeout,\n-            max_retries=self.es_max_retries,\n-            timeout=self.es_timeout,\n-            scheme=self.scheme,\n-            http_auth=http_auth,\n-        )\n+        if elasticsearch.VERSION[0] <= 7:",
      "comment": "we can try keep support of both 7.x and 8.x for better upgrade ability ",
      "comment_id": 1331895314,
      "user": "auvipy",
      "created_at": "2023-09-20T16:21:50Z",
      "url": "https://github.com/celery/celery/pull/8519#discussion_r1331895314"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8498,
      "file_path": "t/integration/test_canvas.py",
      "line": 3140,
      "side": "RIGHT",
      "diff_hunk": "@@ -3132,12 +3132,12 @@ def task_received_handler(request=None, **kwargs):\n                     [\n                         stamped_header in link.options\n                         for stamped_header in link.options[\"stamped_headers\"]\n-                        if link  # the link itself doensn't have a link\n+                        if link  # the link itself doesn't have a link\n                     ],\n                     [\n                         stamped_header in link_error.options\n                         for stamped_header in link_error.options[\"stamped_headers\"]\n-                        if link_error  # the link_error itself doensn't have a link\n+                        if link_error  # the link_error itself doesn't have a link",
      "comment": "```suggestion\r\n                        if link_error  # the link_error itself doesn't have a link_error\r\n```\r\nThis might also be a copy past typo, but since I'm still trying to understand the code I didn't change it.",
      "comment_id": 1323394698,
      "user": "monteiro-renato",
      "created_at": "2023-09-12T18:08:11Z",
      "url": "https://github.com/celery/celery/pull/8498#discussion_r1323394698"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8498,
      "file_path": "t/integration/test_canvas.py",
      "line": 1880,
      "side": "RIGHT",
      "diff_hunk": "@@ -1877,7 +1877,7 @@ def test_chord_on_error(self, manager):\n         backend = fail.app.backend\n         j_key = backend.get_key_for_group(original_group_id, '.j')\n         redis_connection = get_redis_connection()\n-        # The redis key is either a list or zset depending on configuration\n+        # The redis key is either a list or a set depending on configuration",
      "comment": "```suggestion\r\n        # The redis key is either a list or zset depending on configuration\r\n```",
      "comment_id": 1323998973,
      "user": "auvipy",
      "created_at": "2023-09-13T05:45:58Z",
      "url": "https://github.com/celery/celery/pull/8498#discussion_r1323998973"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8498,
      "file_path": "t/integration/test_canvas.py",
      "line": 1880,
      "side": "RIGHT",
      "diff_hunk": "@@ -1877,7 +1877,7 @@ def test_chord_on_error(self, manager):\n         backend = fail.app.backend\n         j_key = backend.get_key_for_group(original_group_id, '.j')\n         redis_connection = get_redis_connection()\n-        # The redis key is either a list or zset depending on configuration\n+        # The redis key is either a list or a set depending on configuration",
      "comment": "from search: The Redis zset function is used to store the key type and value. In a redis, zset keys are unique, and values are limited by the number of floating point operations. The unique property in it is used to access the members. We can also access the items by using sorted orders and order score values.",
      "comment_id": 1323999175,
      "user": "auvipy",
      "created_at": "2023-09-13T05:46:15Z",
      "url": "https://github.com/celery/celery/pull/8498#discussion_r1323999175"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8498,
      "file_path": "t/integration/test_canvas.py",
      "line": 1880,
      "side": "RIGHT",
      "diff_hunk": "@@ -1877,7 +1877,7 @@ def test_chord_on_error(self, manager):\n         backend = fail.app.backend\n         j_key = backend.get_key_for_group(original_group_id, '.j')\n         redis_connection = get_redis_connection()\n-        # The redis key is either a list or zset depending on configuration\n+        # The redis key is either a list or a set depending on configuration",
      "comment": "I've pushed a new commit adding more context as to what a zset is.\r\nThere was an issue on the Redis project Github (# 4024) asking why the sorted set commands had the z prefix.\r\n\r\nI can revert back to what is used to be if you want.",
      "comment_id": 1324524896,
      "user": "monteiro-renato",
      "created_at": "2023-09-13T13:33:59Z",
      "url": "https://github.com/celery/celery/pull/8498#discussion_r1324524896"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8498,
      "file_path": "t/integration/test_canvas.py",
      "line": 1880,
      "side": "RIGHT",
      "diff_hunk": "@@ -1877,7 +1877,7 @@ def test_chord_on_error(self, manager):\n         backend = fail.app.backend\n         j_key = backend.get_key_for_group(original_group_id, '.j')\n         redis_connection = get_redis_connection()\n-        # The redis key is either a list or zset depending on configuration\n+        # The redis key is either a list or a set depending on configuration",
      "comment": "I struggled to find references to \"zset\" in the Redis documentation. Not sure if it has fallen into disuse (the term itself).\r\n\r\nIt's used extensively in this book tho > https://redis.com/ebook/part-2-core-concepts/chapter-3-commands-in-redis/3-5-sorted-sets/",
      "comment_id": 1324532236,
      "user": "monteiro-renato",
      "created_at": "2023-09-13T13:39:25Z",
      "url": "https://github.com/celery/celery/pull/8498#discussion_r1324532236"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8498,
      "file_path": "t/integration/test_canvas.py",
      "line": 1880,
      "side": "RIGHT",
      "diff_hunk": "@@ -1877,7 +1877,7 @@ def test_chord_on_error(self, manager):\n         backend = fail.app.backend\n         j_key = backend.get_key_for_group(original_group_id, '.j')\n         redis_connection = get_redis_connection()\n-        # The redis key is either a list or zset depending on configuration\n+        # The redis key is either a list or a set depending on configuration",
      "comment": "I got this \r\nZADD zset 10 a\r\nZADD zset 5 b\r\nZADD zset 12.55 c\r\nZRANGE zset 0 -1 => b,a,c\r\n\r\nfrom https://redis.io/docs/manual/patterns/twitter-clone/",
      "comment_id": 1324661427,
      "user": "auvipy",
      "created_at": "2023-09-13T15:00:25Z",
      "url": "https://github.com/celery/celery/pull/8498#discussion_r1324661427"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8098,
      "file_path": "celery/utils/iso8601.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +55,7 @@\n \n def parse_iso8601(datestring):\n     \"\"\"Parse and convert ISO-8601 string to datetime.\"\"\"\n+    warn(\"parse_iso8601\", \"v5.3\", \"v6\", \"datetime.datetime.fromisoformat\")",
      "comment": "In used what I found [built in](https://github.com/celery/celery/blob/3bff3f06740a0d509f807e14702f7144b043ae54/celery/utils/deprecated.py#L23).  The parameter `depracation` is provided, so the final result is a `warnings.warn` with a CDeprecationWarning.  So yes, I believe so.",
      "comment_id": 1123912764,
      "user": "stumpylog",
      "created_at": "2023-03-03T00:34:02Z",
      "url": "https://github.com/celery/celery/pull/8098#discussion_r1123912764"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8448,
      "file_path": "celery/utils/imports.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,8 +51,13 @@ def instantiate(name, *args, **kwargs):\n @contextmanager\n def cwd_in_path():\n     \"\"\"Context adding the current working directory to sys.path.\"\"\"\n-    cwd = os.getcwd()\n-    if cwd in sys.path:\n+    try:",
      "comment": "could you please add some unit test to verify the change?",
      "comment_id": 1299564454,
      "user": "auvipy",
      "created_at": "2023-08-21T03:41:08Z",
      "url": "https://github.com/celery/celery/pull/8448#discussion_r1299564454"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8428,
      "file_path": "t/unit/app/test_beat.py",
      "line": 315,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,6 +301,24 @@ def test_info(self):\n         scheduler = mScheduler(app=self.app)\n         assert isinstance(scheduler.info, str)\n \n+    def test_apply_entry_handles_empty_result(self):\n+        s = mScheduler(app=self.app)\n+        entry = s.Entry(name='a name', task='foo', app=self.app)\n+        with (patch.object(s, 'apply_async') as mock_apply_async,\n+              patch(\"celery.beat.debug\") as mock_debug):\n+            mock_apply_async.return_value = None\n+            s.apply_entry(entry)\n+        mock_debug.assert_called_once_with('%s sent.', entry.task)\n+\n+        task_id = 'taskId123456'\n+        with (patch.object(s, 'apply_async') as mock_apply_async,\n+              patch(\"celery.beat.debug\") as mock_debug):",
      "comment": "oh woops - this syntax (parenthesized context managers) was not available in older python versions. fixing now...",
      "comment_id": 1287242542,
      "user": "bmrobin",
      "created_at": "2023-08-08T14:51:41Z",
      "url": "https://github.com/celery/celery/pull/8428#discussion_r1287242542"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8374,
      "file_path": "celery/bin/purge.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,7 +28,7 @@\n               help=\"Comma separated list of queues names not to purge.\")\n @click.pass_context\n @handle_preload_options\n-def purge(ctx, force, queues, exclude_queues):\n+def purge(ctx, force, queues, exclude_queues, **kwargs):",
      "comment": "The **kwargs aspect of this seems to be also required and related to #8049 ",
      "comment_id": 1264011081,
      "user": "dpdoughe",
      "created_at": "2023-07-14T18:10:20Z",
      "url": "https://github.com/celery/celery/pull/8374#discussion_r1264011081"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8374,
      "file_path": "celery/bin/shell.py",
      "line": 122,
      "side": "RIGHT",
      "diff_hunk": "@@ -117,7 +119,7 @@ def _invoke_default_shell(locals):\n @handle_preload_options\n def shell(ctx, ipython=False, bpython=False,\n           python=False, without_tasks=False, eventlet=False,\n-          gevent=False):\n+          gevent=False, **kwargs):",
      "comment": "The **kwargs aspect of this seems to be also required and related to https://github.com/celery/celery/pull/8049",
      "comment_id": 1264011256,
      "user": "dpdoughe",
      "created_at": "2023-07-14T18:10:33Z",
      "url": "https://github.com/celery/celery/pull/8374#discussion_r1264011256"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8374,
      "file_path": "t/unit/app/test_preload_cli.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,55 @@\n+import sys\n+from click.testing import CliRunner\n+from celery.bin.celery import celery\n+\n+\n+def test_preload_options(isolated_cli_runner: CliRunner):\n+    # Verify commands like shell and purge can accept preload options.\n+    # Projects like Pyramid-Celery's ini option should be valid preload\n+    # options.\n+\n+    res_without_preload = isolated_cli_runner.invoke(\n+        celery,\n+        [\"-A\", \"t.unit.bin.proj.app\", \"purge\", \"-f\", \"--ini\", \"some_ini.ini\"],\n+        catch_exceptions=True,\n+    )\n+\n+    assert \"No such option: --ini\" in res_without_preload.stdout\n+    assert res_without_preload.exit_code == 2\n+\n+    res_without_preload = isolated_cli_runner.invoke(\n+        celery,\n+        [\"-A\", \"t.unit.bin.proj.app\", \"shell\", \"--ini\", \"some_ini.ini\"],\n+        catch_exceptions=True,\n+    )\n+\n+    assert \"No such option: --ini\" in res_without_preload.stdout\n+    assert res_without_preload.exit_code == 2\n+\n+    res_with_preload = isolated_cli_runner.invoke(\n+        celery,\n+        [\n+            \"-A\",\n+            \"t.unit.bin.proj.pyramid_celery_app\",\n+            \"purge\",\n+            \"-f\",\n+            \"--ini\",\n+            \"some_ini.ini\",\n+        ],\n+        catch_exceptions=True,\n+    )\n+",
      "comment": "Is there a recommended way to fully clean/reset the applications called by the isolated_cli_runner? I noticed that if I run the `t.unit.bin.proj.pyramid_celery_app`  cases first then the --ini option seems to be defined even when running the `t.unit.bin.proj.app`. I'm guessing that Celery has a global or some other persistence that I am not aware of that needs to get reset or added to the tear-down of  the tests. I've also tried running these as separate tests and even in separate test files and there still seems to be some persistence or leakage of the user_options. Basically I want two separate and independent Celery processes to test and configure here.",
      "comment_id": 1264016657,
      "user": "dpdoughe",
      "created_at": "2023-07-14T18:16:58Z",
      "url": "https://github.com/celery/celery/pull/8374#discussion_r1264016657"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8374,
      "file_path": "t/unit/bin/proj/pyramid_celery_app.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+from unittest.mock import MagicMock, Mock\n+\n+from click import Option\n+\n+from celery import Celery\n+\n+# This module defines a mocked Celery application to replicate\n+# the behavior of Pyramid-Celery's configuration by preload options.\n+# Preload options should propagate to commands like shell and purge etc.\n+#\n+# The Pyramid-Celery project https://github.com/sontek/pyramid_celery\n+# assumes that you want to configure Celery via an ini settings file.\n+# The .ini files are the standard configuration file for Pyramid\n+# applications.\n+# See https://docs.pylonsproject.org/projects/pyramid/en/latest/quick_tutorial/ini.html\n+#\n+\n+app = Celery(set_as_current=False)\n+app.config_from_object(\"t.integration.test_worker_config\")\n+\n+class PurgeMock:\n+    def queue_purge(self, queue):\n+        return 0\n+\n+class ConnMock:\n+    default_channel = PurgeMock()\n+    channel_errors = KeyError\n+\n+mock = Mock()\n+mock.__enter__ = Mock(return_value=ConnMock())\n+mock.__exit__ = Mock(return_value=False)\n+\n+app.connection_for_write = MagicMock(return_value=mock)",
      "comment": "I use this Mock to prevent hanging of execution and get immediate return during the test. If there is a more standard way to mock the purge functionality in the context of tests let me know.",
      "comment_id": 1264041812,
      "user": "dpdoughe",
      "created_at": "2023-07-14T18:47:01Z",
      "url": "https://github.com/celery/celery/pull/8374#discussion_r1264041812"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8374,
      "file_path": "t/unit/app/test_preload_cli.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,55 @@\n+import sys\n+from click.testing import CliRunner\n+from celery.bin.celery import celery\n+\n+\n+def test_preload_options(isolated_cli_runner: CliRunner):\n+    # Verify commands like shell and purge can accept preload options.\n+    # Projects like Pyramid-Celery's ini option should be valid preload\n+    # options.\n+\n+    res_without_preload = isolated_cli_runner.invoke(\n+        celery,\n+        [\"-A\", \"t.unit.bin.proj.app\", \"purge\", \"-f\", \"--ini\", \"some_ini.ini\"],\n+        catch_exceptions=True,\n+    )\n+\n+    assert \"No such option: --ini\" in res_without_preload.stdout\n+    assert res_without_preload.exit_code == 2\n+\n+    res_without_preload = isolated_cli_runner.invoke(\n+        celery,\n+        [\"-A\", \"t.unit.bin.proj.app\", \"shell\", \"--ini\", \"some_ini.ini\"],\n+        catch_exceptions=True,\n+    )\n+\n+    assert \"No such option: --ini\" in res_without_preload.stdout\n+    assert res_without_preload.exit_code == 2\n+\n+    res_with_preload = isolated_cli_runner.invoke(\n+        celery,\n+        [\n+            \"-A\",\n+            \"t.unit.bin.proj.pyramid_celery_app\",\n+            \"purge\",\n+            \"-f\",\n+            \"--ini\",\n+            \"some_ini.ini\",\n+        ],\n+        catch_exceptions=True,\n+    )\n+",
      "comment": "I left a TODO in the code with the issue laid out. I'm fine leaving as it is since I believe it will address the underlying options support.",
      "comment_id": 1276955783,
      "user": "dpdoughe",
      "created_at": "2023-07-28T00:25:30Z",
      "url": "https://github.com/celery/celery/pull/8374#discussion_r1276955783"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8391,
      "file_path": "celery/backends/mongodb.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,21 @@ def _get_task_meta_for(self, task_id):\n         \"\"\"Get task meta-data for a task by id.\"\"\"\n         obj = self.collection.find_one({'_id': task_id})\n         if obj:\n+            if self.app.conf.find_value_for_key('extended', 'result'):\n+                return self.meta_from_decoded({",
      "comment": "we will need full unit test coverage for this change",
      "comment_id": 1273497383,
      "user": "auvipy",
      "created_at": "2023-07-25T12:53:52Z",
      "url": "https://github.com/celery/celery/pull/8391#discussion_r1273497383"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8391,
      "file_path": "celery/backends/mongodb.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,21 @@ def _get_task_meta_for(self, task_id):\n         \"\"\"Get task meta-data for a task by id.\"\"\"\n         obj = self.collection.find_one({'_id': task_id})\n         if obj:\n+            if self.app.conf.find_value_for_key('extended', 'result'):\n+                return self.meta_from_decoded({",
      "comment": "Ok. Being a newbie here I have no idea how to write a unit test for this. The only tests that I could find was in the pytest-celery repo but I could not figure out where to do a pull request for the test coverage.",
      "comment_id": 1273648477,
      "user": "ycc140",
      "created_at": "2023-07-25T14:36:28Z",
      "url": "https://github.com/celery/celery/pull/8391#discussion_r1273648477"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8391,
      "file_path": "celery/backends/mongodb.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,21 @@ def _get_task_meta_for(self, task_id):\n         \"\"\"Get task meta-data for a task by id.\"\"\"\n         obj = self.collection.find_one({'_id': task_id})\n         if obj:\n+            if self.app.conf.find_value_for_key('extended', 'result'):\n+                return self.meta_from_decoded({",
      "comment": "you can check this file https://github.com/celery/celery/blob/main/t/unit/backends/test_mongodb.py and other back end tests in https://github.com/celery/celery/blob/main/t/unit/backends/ folder",
      "comment_id": 1274349991,
      "user": "auvipy",
      "created_at": "2023-07-26T04:02:07Z",
      "url": "https://github.com/celery/celery/pull/8391#discussion_r1274349991"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8391,
      "file_path": "celery/backends/mongodb.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +197,21 @@ def _get_task_meta_for(self, task_id):\n         \"\"\"Get task meta-data for a task by id.\"\"\"\n         obj = self.collection.find_one({'_id': task_id})\n         if obj:\n+            if self.app.conf.find_value_for_key('extended', 'result'):\n+                return self.meta_from_decoded({",
      "comment": "Thanks for the pointers. I have added a new test case, It works on my laptop :-)",
      "comment_id": 1274554059,
      "user": "ycc140",
      "created_at": "2023-07-26T08:22:02Z",
      "url": "https://github.com/celery/celery/pull/8391#discussion_r1274554059"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8301,
      "file_path": "celery/contrib/testing/worker.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,11 +30,48 @@\n class TestWorkController(worker.WorkController):\n     \"\"\"Worker that can synchronize on being fully started.\"\"\"\n \n+    logger_queue = None\n+\n     def __init__(self, *args, **kwargs):\n         # type: (*Any, **Any) -> None\n         self._on_started = threading.Event()\n+\n         super().__init__(*args, **kwargs)\n \n+        if self.pool_cls.__module__.split('.')[-1] == 'prefork':\n+            from multiprocessing import Queue",
      "comment": "```suggestion\r\n            from billiard import Queue\r\n```",
      "comment_id": 1256917307,
      "user": "auvipy",
      "created_at": "2023-07-08T04:06:02Z",
      "url": "https://github.com/celery/celery/pull/8301#discussion_r1256917307"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8295,
      "file_path": "celery/app/autoretry.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,7 +48,7 @@ def run(*args, **kwargs):\n                 if retry_backoff:\n                     retry_kwargs['countdown'] = \\\n                         get_exponential_backoff_interval(\n-                            factor=retry_backoff,\n+                            factor=int(max(1.0, retry_backoff)),",
      "comment": "are we going to turn everything into 1 only or multiple of 1.0?",
      "comment_id": 1233044571,
      "user": "auvipy",
      "created_at": "2023-06-17T13:01:18Z",
      "url": "https://github.com/celery/celery/pull/8295#discussion_r1233044571"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8295,
      "file_path": "celery/app/autoretry.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,7 +48,7 @@ def run(*args, **kwargs):\n                 if retry_backoff:\n                     retry_kwargs['countdown'] = \\\n                         get_exponential_backoff_interval(\n-                            factor=retry_backoff,\n+                            factor=int(max(1.0, retry_backoff)),",
      "comment": "All values less then 1 turn into 1 (except zero). For the other values, the behavior remains the same. I'm using 1.0 (not 1) just for linter.",
      "comment_id": 1233123779,
      "user": "ipakeev",
      "created_at": "2023-06-17T20:15:19Z",
      "url": "https://github.com/celery/celery/pull/8295#discussion_r1233123779"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8312,
      "file_path": "celery/bin/worker.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,8 +166,8 @@ def detach(path, argv, logfile=None, pidfile=None, uid=None,\n               type=LOG_LEVEL,\n               help_group=\"Worker Options\",\n               help=\"Logging level.\")\n-@click.option('optimization',\n-              '-O',\n+@click.option('-O',",
      "comment": "See code above/below, the pattern is consistent being first `-O`, then `--optimization`",
      "comment_id": 1230157814,
      "user": "Nusnus",
      "created_at": "2023-06-14T20:52:44Z",
      "url": "https://github.com/celery/celery/pull/8312#discussion_r1230157814"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8305,
      "file_path": "t/unit/utils/test_collections.py",
      "line": 462,
      "side": "RIGHT",
      "diff_hunk": "@@ -448,3 +449,16 @@ def test_pop_empty_no_default(self):\n \n     def test_repr(self):\n         assert repr(Messagebuffer(10, [1, 2, 3]))\n+\n+\n+class test_ChainMap:\n+\n+    def test_observers_not_shared(self):\n+        a = ChainMap()\n+        b = ChainMap()\n+        callback = Mock()\n+        a.bind_to(callback)\n+        b.update(x=1)\n+        callback.assert_not_called()",
      "comment": "is there an alternative to `assert_not_called` and `assert_called_once_with` in pytest?\r\nI see they are used extensively in celery unit tests. ",
      "comment_id": 1224498460,
      "user": "shahar-lev",
      "created_at": "2023-06-09T16:09:37Z",
      "url": "https://github.com/celery/celery/pull/8305#discussion_r1224498460"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8305,
      "file_path": "t/unit/utils/test_collections.py",
      "line": 462,
      "side": "RIGHT",
      "diff_hunk": "@@ -448,3 +449,16 @@ def test_pop_empty_no_default(self):\n \n     def test_repr(self):\n         assert repr(Messagebuffer(10, [1, 2, 3]))\n+\n+\n+class test_ChainMap:\n+\n+    def test_observers_not_shared(self):\n+        a = ChainMap()\n+        b = ChainMap()\n+        callback = Mock()\n+        a.bind_to(callback)\n+        b.update(x=1)\n+        callback.assert_not_called()",
      "comment": "is it possible to increase test coverage and if possible to add integration tests as well?",
      "comment_id": 1229070134,
      "user": "auvipy",
      "created_at": "2023-06-14T06:22:37Z",
      "url": "https://github.com/celery/celery/pull/8305#discussion_r1229070134"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8305,
      "file_path": "t/unit/utils/test_collections.py",
      "line": 462,
      "side": "RIGHT",
      "diff_hunk": "@@ -448,3 +449,16 @@ def test_pop_empty_no_default(self):\n \n     def test_repr(self):\n         assert repr(Messagebuffer(10, [1, 2, 3]))\n+\n+\n+class test_ChainMap:\n+\n+    def test_observers_not_shared(self):\n+        a = ChainMap()\n+        b = ChainMap()\n+        callback = Mock()\n+        a.bind_to(callback)\n+        b.update(x=1)\n+        callback.assert_not_called()",
      "comment": "It's weird that I reduced coverage by this commit - It's just a bugfix with a new unit test that checks it actually fixed the bug (I didn't add any new \"logic\" to the code itself).\r\nIt also feels like a low-level bug that doesn't suit an integration test.\r\nWDYT?",
      "comment_id": 1229078208,
      "user": "shahar-lev",
      "created_at": "2023-06-14T06:29:55Z",
      "url": "https://github.com/celery/celery/pull/8305#discussion_r1229078208"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8134,
      "file_path": "celery/app/base.py",
      "line": 741,
      "side": "RIGHT",
      "diff_hunk": "@@ -738,6 +738,9 @@ def send_task(self, name, args=None, kwargs=None, countdown=None,\n             if isinstance(expires, datetime):\n                 expires_s = (maybe_make_aware(\n                     expires) - self.now()).total_seconds()\n+            if isinstance(expires, str):",
      "comment": "> please also validate the change with tests\r\n\r\nTests have been added in t/unit/app/test_app.py",
      "comment_id": 1145131543,
      "user": "Bidaya0",
      "created_at": "2023-03-22T16:47:03Z",
      "url": "https://github.com/celery/celery/pull/8134#discussion_r1145131543"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7945,
      "file_path": "celery/app/defaults.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +78,7 @@ def __repr__(self):\n         scheduler=Option('celery.beat:PersistentScheduler'),\n         schedule_filename=Option('celerybeat-schedule'),\n         sync_every=Option(0, type='int'),\n+        cron_starting_deadline_seconds=Option(None, type=int)",
      "comment": "Kubernetes has a similar option which follows this naming scheme, but I am open to other ideas.\r\n\r\nhttps://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#cron-job-limitations",
      "comment_id": 1041194424,
      "user": "asnoeyink",
      "created_at": "2022-12-06T16:29:27Z",
      "url": "https://github.com/celery/celery/pull/7945#discussion_r1041194424"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7945,
      "file_path": "celery/app/defaults.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +78,7 @@ def __repr__(self):\n         scheduler=Option('celery.beat:PersistentScheduler'),\n         schedule_filename=Option('celerybeat-schedule'),\n         sync_every=Option(0, type='int'),\n+        cron_starting_deadline_seconds=Option(None, type=int)",
      "comment": "what about cron_starting_deadline instead of seconds?",
      "comment_id": 1043394481,
      "user": "auvipy",
      "created_at": "2022-12-08T14:08:06Z",
      "url": "https://github.com/celery/celery/pull/7945#discussion_r1043394481"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7945,
      "file_path": "celery/app/defaults.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +78,7 @@ def __repr__(self):\n         scheduler=Option('celery.beat:PersistentScheduler'),\n         schedule_filename=Option('celerybeat-schedule'),\n         sync_every=Option(0, type='int'),\n+        cron_starting_deadline=Option(None, type=int)",
      "comment": "Should be the `'int'` string instead of the `int`class",
      "comment_id": 1222252803,
      "user": "nagareproject",
      "created_at": "2023-06-07T22:43:12Z",
      "url": "https://github.com/celery/celery/pull/7945#discussion_r1222252803"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8159,
      "file_path": "t/unit/utils/test_time.py",
      "line": 274,
      "side": "RIGHT",
      "diff_hunk": "@@ -278,7 +271,7 @@ def test_localize_aware_dt_idempotent(self):\n         assert localized_utc_offset == local_zone.utcoffset(local_time)\n \n \n-@pytest.mark.parametrize('s,expected', [\n+@ pytest.mark.parametrize('s,expected', [",
      "comment": "There are a few spaces that sneaked into this file :)\r\nCheck below as well",
      "comment_id": 1149720188,
      "user": "Nusnus",
      "created_at": "2023-03-27T19:45:43Z",
      "url": "https://github.com/celery/celery/pull/8159#discussion_r1149720188"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8159,
      "file_path": "celery/utils/time.py",
      "line": 306,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,52 +291,58 @@ def maybe_iso8601(dt):\n     return datetime.fromisoformat(dt)\n \n \n-def is_naive(dt):\n-    \"\"\"Return :const:`True` if :class:`~datetime.datetime` is naive.\"\"\"\n+def is_naive(dt: datetime) -> bool:\n+    \"\"\"Return True if :class:`~datetime.datetime` is naive, meaning it doesn't have timezone info set.\"\"\"\n     return dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None\n \n \n-def make_aware(dt, tz):\n+def _can_detect_ambiguous(tz: tzinfo) -> bool:\n+    \"\"\"Helper function to determine if a timezone can detect ambiguous times using dateutil.\"\"\"\n+\n+    return isinstance(tz, ZoneInfo) or hasattr(tz, \"is_ambiguous\")\n+\n+\n+def _is_ambigious(dt: datetime, tz: tzinfo) -> bool:\n+    \"\"\"Helper function to determine if a timezone is ambigious using dateutil.",
      "comment": "```suggestion\r\n    \"\"\"Helper function to determine if a timezone is ambiguous using python-dateutil.\r\n```",
      "comment_id": 1161245328,
      "user": "auvipy",
      "created_at": "2023-04-09T08:15:39Z",
      "url": "https://github.com/celery/celery/pull/8159#discussion_r1161245328"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8159,
      "file_path": "celery/utils/time.py",
      "line": 308,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,52 +291,58 @@ def maybe_iso8601(dt):\n     return datetime.fromisoformat(dt)\n \n \n-def is_naive(dt):\n-    \"\"\"Return :const:`True` if :class:`~datetime.datetime` is naive.\"\"\"\n+def is_naive(dt: datetime) -> bool:\n+    \"\"\"Return True if :class:`~datetime.datetime` is naive, meaning it doesn't have timezone info set.\"\"\"\n     return dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None\n \n \n-def make_aware(dt, tz):\n+def _can_detect_ambiguous(tz: tzinfo) -> bool:\n+    \"\"\"Helper function to determine if a timezone can detect ambiguous times using dateutil.\"\"\"\n+\n+    return isinstance(tz, ZoneInfo) or hasattr(tz, \"is_ambiguous\")\n+\n+\n+def _is_ambigious(dt: datetime, tz: tzinfo) -> bool:\n+    \"\"\"Helper function to determine if a timezone is ambigious using dateutil.\n+\n+    Returns False if the timezone cannot detect ambiguity, or if there is no abiguity, otherwise True.",
      "comment": "```suggestion\r\n    Returns False if the timezone cannot detect ambiguity, or if there is no ambiguity, otherwise True.\r\n```",
      "comment_id": 1161245470,
      "user": "auvipy",
      "created_at": "2023-04-09T08:16:35Z",
      "url": "https://github.com/celery/celery/pull/8159#discussion_r1161245470"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8159,
      "file_path": "celery/utils/time.py",
      "line": 311,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,52 +291,58 @@ def maybe_iso8601(dt):\n     return datetime.fromisoformat(dt)\n \n \n-def is_naive(dt):\n-    \"\"\"Return :const:`True` if :class:`~datetime.datetime` is naive.\"\"\"\n+def is_naive(dt: datetime) -> bool:\n+    \"\"\"Return True if :class:`~datetime.datetime` is naive, meaning it doesn't have timezone info set.\"\"\"\n     return dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None\n \n \n-def make_aware(dt, tz):\n+def _can_detect_ambiguous(tz: tzinfo) -> bool:\n+    \"\"\"Helper function to determine if a timezone can detect ambiguous times using dateutil.\"\"\"\n+\n+    return isinstance(tz, ZoneInfo) or hasattr(tz, \"is_ambiguous\")\n+\n+\n+def _is_ambigious(dt: datetime, tz: tzinfo) -> bool:\n+    \"\"\"Helper function to determine if a timezone is ambigious using dateutil.\n+\n+    Returns False if the timezone cannot detect ambiguity, or if there is no abiguity, otherwise True.\n+\n+    In order to detect ambiguous datetimes, the timezone must be built using ZoneInfo, or have an is_ambiguous\n+    method. Previously, pytz timezones would throw an AmbiguousTimeError if the localized dt was ambigious,",
      "comment": "```suggestion\r\n    method. Previously, pytz timezones would throw an AmbiguousTimeError if the localized dt was ambiguous,\r\n```",
      "comment_id": 1161245605,
      "user": "auvipy",
      "created_at": "2023-04-09T08:17:40Z",
      "url": "https://github.com/celery/celery/pull/8159#discussion_r1161245605"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8159,
      "file_path": "celery/utils/time.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,53 +112,69 @@ def _isdst(self, dt):\n \n \n class _Zone:\n+    \"\"\"Timezone class that provides the timezone for the application.\n+    If `enable_utc` is disabled, LocalTimezone is provided as the timezone provider through local().\n+    Otherwise, this class provides UTC ZoneInfo instance as the timezone provider for the application.",
      "comment": "```suggestion\r\n    Otherwise, this class provides a UTC ZoneInfo instance as the timezone provider for the application.\r\n```",
      "comment_id": 1161246539,
      "user": "auvipy",
      "created_at": "2023-04-09T08:24:17Z",
      "url": "https://github.com/celery/celery/pull/8159#discussion_r1161246539"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8159,
      "file_path": "celery/utils/time.py",
      "line": 306,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,52 +291,58 @@ def maybe_iso8601(dt):\n     return datetime.fromisoformat(dt)\n \n \n-def is_naive(dt):\n-    \"\"\"Return :const:`True` if :class:`~datetime.datetime` is naive.\"\"\"\n+def is_naive(dt: datetime) -> bool:\n+    \"\"\"Return True if :class:`~datetime.datetime` is naive, meaning it doesn't have timezone info set.\"\"\"\n     return dt.tzinfo is None or dt.tzinfo.utcoffset(dt) is None\n \n \n-def make_aware(dt, tz):\n+def _can_detect_ambiguous(tz: tzinfo) -> bool:\n+    \"\"\"Helper function to determine if a timezone can detect ambiguous times using dateutil.\"\"\"\n+\n+    return isinstance(tz, ZoneInfo) or hasattr(tz, \"is_ambiguous\")\n+\n+\n+def _is_ambigious(dt: datetime, tz: tzinfo) -> bool:\n+    \"\"\"Helper function to determine if a timezone is ambiguous using python-dateutil.",
      "comment": "```suggestion\r\n    \"\"\"Helper function to determine if a timezone is ambiguous using python's dateutil module.\r\n```",
      "comment_id": 1161247070,
      "user": "auvipy",
      "created_at": "2023-04-09T08:28:33Z",
      "url": "https://github.com/celery/celery/pull/8159#discussion_r1161247070"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7873,
      "file_path": "celery/result.py",
      "line": 658,
      "side": "RIGHT",
      "diff_hunk": "@@ -651,8 +651,11 @@ def ready(self):\n     def completed_count(self):\n         \"\"\"Task completion count.\n \n+        Note that `complete` means `successful` in this context. In other words, the\n+        return value of this method is the number of ``successful`` tasks.\n+\n         Returns:\n-            int: the number of tasks completed.\n+            int: the number of complete (i.e. successful) tasks.",
      "comment": "<img width=\"677\" alt=\"Screenshot 2022-11-02 at 7 46 18\" src=\"https://user-images.githubusercontent.com/11639738/199493487-972a3155-8064-4eca-a8fc-d3ffb4beb8ea.png\">",
      "comment_id": 1011708255,
      "user": "hankehly",
      "created_at": "2022-11-02T12:47:46Z",
      "url": "https://github.com/celery/celery/pull/7873#discussion_r1011708255"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7339,
      "file_path": "celery/apps/worker.py",
      "line": 22,
      "side": "LEFT",
      "diff_hunk": "@@ -19,7 +19,6 @@\n \n from celery import VERSION_BANNER, platforms, signals\n from celery.app import trace\n-from celery.exceptions import WorkerShutdown, WorkerTerminate",
      "comment": "The two exception types aren't used in this module anymore, and `__all__` prevents them from being cross imported. The exceptions themselves are still used at a higher level (e.g. by `maybe_shutdown()`), and there's no new additional untested code paths. Unless there's a unit test or a mystery edge case that medically needs the signal handler to throw an exception, I think it's okay.",
      "comment_id": 822276781,
      "user": "scottp-dpaw",
      "created_at": "2022-03-09T04:28:37Z",
      "url": "https://github.com/celery/celery/pull/7339#discussion_r822276781"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8177,
      "file_path": "celery/signals.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -105,6 +106,7 @@\n # - Worker\n import_modules = Signal(name='import_modules')\n worker_init = Signal(name='worker_init')\n+worker_before_create_process = Signal(name=\"worker_before_create_process\")",
      "comment": "would like to have some unit/integration tests to see its working well and won't create any regression",
      "comment_id": 1156882743,
      "user": "auvipy",
      "created_at": "2023-04-04T08:06:27Z",
      "url": "https://github.com/celery/celery/pull/8177#discussion_r1156882743"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8143,
      "file_path": "celery/app/base.py",
      "line": 1052,
      "side": "RIGHT",
      "diff_hunk": "@@ -1045,7 +1046,13 @@ def _sig_to_periodic_task_entry(self, schedule, sig,\n             'options': dict(sig.options, **opts),\n         }\n \n-    def _add_periodic_task(self, key, entry):\n+    def _add_periodic_task(self, key, entry, name=None):\n+        if name is None and key in self._conf.beat_schedule:\n+            logger.warning(\n+                f\"Periodic task key='{key}' shadowed a previous unnamed periodic task.\"",
      "comment": "is it possible that we could add something like this to docs as well? if thats not needed we can go with this as well",
      "comment_id": 1146011399,
      "user": "auvipy",
      "created_at": "2023-03-23T10:58:17Z",
      "url": "https://github.com/celery/celery/pull/8143#discussion_r1146011399"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8143,
      "file_path": "celery/app/base.py",
      "line": 1052,
      "side": "RIGHT",
      "diff_hunk": "@@ -1045,7 +1046,13 @@ def _sig_to_periodic_task_entry(self, schedule, sig,\n             'options': dict(sig.options, **opts),\n         }\n \n-    def _add_periodic_task(self, key, entry):\n+    def _add_periodic_task(self, key, entry, name=None):\n+        if name is None and key in self._conf.beat_schedule:\n+            logger.warning(\n+                f\"Periodic task key='{key}' shadowed a previous unnamed periodic task.\"",
      "comment": "Sure! The `add_periodic_task` has no docs, I wrote a first version of it.",
      "comment_id": 1146062124,
      "user": "iurisilvio",
      "created_at": "2023-03-23T11:46:29Z",
      "url": "https://github.com/celery/celery/pull/8143#discussion_r1146062124"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8114,
      "file_path": "celery/schedules.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -428,14 +436,14 @@ def _expand_cronspec(cronspec, max_, min_=0):\n         day of month or month of year.  The default is sufficient for minute,\n         hour, and day of week.\n         \"\"\"\n-        if isinstance(cronspec, numbers.Integral):\n+        if isinstance(cronspec, int):\n             result = {cronspec}\n         elif isinstance(cronspec, str):\n             result = crontab_parser(max_, min_).parse(cronspec)\n         elif isinstance(cronspec, set):\n             result = cronspec\n         elif isinstance(cronspec, Iterable):\n-            result = set(cronspec)\n+            result = set(cronspec)  # type: ignore",
      "comment": "This line was especially problematic to `mpy` for some reason, so set it as ignore. For some reason it didn't want `cronspec` to be able to be a `str` here, even though you can convert a string to a set.",
      "comment_id": 1129025561,
      "user": "max-muoto",
      "created_at": "2023-03-08T06:34:31Z",
      "url": "https://github.com/celery/celery/pull/8114#discussion_r1129025561"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8114,
      "file_path": "celery/schedules.py",
      "line": 718,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,8 +715,8 @@ class solar(BaseSchedule):\n     Arguments:\n         event (str): Solar event that triggers this task.\n             See note for available values.\n-        lat (int): The latitude of the observer.\n-        lon (int): The longitude of the observer.\n+        lat (Union[int, float]): The latitude of the observer.",
      "comment": "Just float is enough: https://stackoverflow.com/questions/50928592/mypy-type-hint-unionfloat-int-is-there-a-number-type",
      "comment_id": 1129102526,
      "user": "Kaju-Bubanja",
      "created_at": "2023-03-08T08:22:18Z",
      "url": "https://github.com/celery/celery/pull/8114#discussion_r1129102526"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8114,
      "file_path": "celery/schedules.py",
      "line": 718,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,8 +715,8 @@ class solar(BaseSchedule):\n     Arguments:\n         event (str): Solar event that triggers this task.\n             See note for available values.\n-        lat (int): The latitude of the observer.\n-        lon (int): The longitude of the observer.\n+        lat (Union[int, float]): The latitude of the observer.",
      "comment": "```suggestion\r\n        lat (Union[float]): The latitude of the observer.\r\n```",
      "comment_id": 1129169228,
      "user": "auvipy",
      "created_at": "2023-03-08T09:28:08Z",
      "url": "https://github.com/celery/celery/pull/8114#discussion_r1129169228"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8114,
      "file_path": "celery/schedules.py",
      "line": 719,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,8 +715,8 @@ class solar(BaseSchedule):\n     Arguments:\n         event (str): Solar event that triggers this task.\n             See note for available values.\n-        lat (int): The latitude of the observer.\n-        lon (int): The longitude of the observer.\n+        lat (Union[int, float]): The latitude of the observer.\n+        lon (Union[int, float]): The longitude of the observer.",
      "comment": "```suggestion\r\n        lon (Union[float]): The longitude of the observer.\r\n```",
      "comment_id": 1129169624,
      "user": "auvipy",
      "created_at": "2023-03-08T09:28:30Z",
      "url": "https://github.com/celery/celery/pull/8114#discussion_r1129169624"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8120,
      "file_path": "celery/app/task.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -145,6 +145,11 @@ def as_execution_options(self):\n             'replaced_task_nesting': self.replaced_task_nesting,\n             'origin': self.origin,\n         }\n+        if hasattr(self, 'stamps') and hasattr(self, 'stamped_headers'):",
      "comment": "after the integration tests, can some unit tests added here?",
      "comment_id": 1133114888,
      "user": "auvipy",
      "created_at": "2023-03-11T16:15:30Z",
      "url": "https://github.com/celery/celery/pull/8120#discussion_r1133114888"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8120,
      "file_path": "celery/app/task.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -145,6 +145,11 @@ def as_execution_options(self):\n             'replaced_task_nesting': self.replaced_task_nesting,\n             'origin': self.origin,\n         }\n+        if hasattr(self, 'stamps') and hasattr(self, 'stamped_headers'):",
      "comment": "Done - unit test pushed.\r\nThanks for reviewing quickly! \u2764\ufe0f ",
      "comment_id": 1133115097,
      "user": "Nusnus",
      "created_at": "2023-03-11T16:17:04Z",
      "url": "https://github.com/celery/celery/pull/8120#discussion_r1133115097"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,25 +76,35 @@ def __init__(self, max_interval=None, app=None,\n         if not isinstance(self.loglevel, numbers.Integral):\n             self.loglevel = LOG_LEVELS[self.loglevel.upper()]\n \n-    def run(self):\n+    @property",
      "comment": "Using this pattern to accommodate the required type safety from MyPy (obviously this doesn't really provide type safety). Would you prefer that I refactor the class to ensure actual type safety?",
      "comment_id": 1125717091,
      "user": "max-muoto",
      "created_at": "2023-03-05T19:04:10Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1125717091"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 166,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,15 +157,15 @@ def startup_info(self, service):\n             max_interval=scheduler.max_interval,\n         )\n \n-    def set_process_title(self):\n+    def set_process_title(self) -> None:\n         arg_start = 'manage' in sys.argv[0] and 2 or 1\n         platforms.set_process_title(\n             'celery beat', info=' '.join(sys.argv[arg_start:]),\n         )\n \n-    def install_sync_handler(self, service):\n+    def install_sync_handler(self, service: Service) -> None:",
      "comment": "Pre-commit was replacing quoted type hints. Is this intended? I think it would be useful to allow them, so that I could conditionally import types with `if TYPE_CHECKING`.",
      "comment_id": 1125717196,
      "user": "max-muoto",
      "created_at": "2023-03-05T19:05:00Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1125717196"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,25 +76,35 @@ def __init__(self, max_interval=None, app=None,\n         if not isinstance(self.loglevel, numbers.Integral):\n             self.loglevel = LOG_LEVELS[self.loglevel.upper()]\n \n-    def run(self):\n+    @property",
      "comment": "This appears to be out of scope so you can leave it like that for now.\r\nMaybe in a different PR if you wish.\r\n\r\nNice idea though!",
      "comment_id": 1125738543,
      "user": "Nusnus",
      "created_at": "2023-03-05T21:36:21Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1125738543"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,22 +77,32 @@ def __init__(self, max_interval=None, app=None,\n         if not isinstance(self.loglevel, numbers.Integral):\n             self.loglevel = LOG_LEVELS[self.loglevel.upper()]\n \n-    def run(self):\n+    @property\n+    def app(self) -> Celery:\n+        if self._app:\n+            return self._app\n+        raise ValueError(\"Beat must provided a Celery app.\")",
      "comment": "> Added lines #L83 - L84 were not covered by tests\r\n\r\nCan you add a unit test for this please?",
      "comment_id": 1125738702,
      "user": "Nusnus",
      "created_at": "2023-03-05T21:37:04Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1125738702"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,22 +77,32 @@ def __init__(self, max_interval=None, app=None,\n         if not isinstance(self.loglevel, numbers.Integral):\n             self.loglevel = LOG_LEVELS[self.loglevel.upper()]\n \n-    def run(self):\n+    @property\n+    def app(self) -> Celery:\n+        if self._app:\n+            return self._app\n+        raise ValueError(\"Beat must provided a Celery app.\")\n+\n+    @app.setter\n+    def app(self, app: Celery) -> None:\n+        self._app = app",
      "comment": "> Added line #L88 was not covered by tests\r\n\r\nCan you add a unit test for this please?",
      "comment_id": 1125738726,
      "user": "Nusnus",
      "created_at": "2023-03-05T21:37:21Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1125738726"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,22 +77,32 @@ def __init__(self, max_interval=None, app=None,\n         if not isinstance(self.loglevel, numbers.Integral):\n             self.loglevel = LOG_LEVELS[self.loglevel.upper()]\n \n-    def run(self):\n+    @property\n+    def app(self) -> Celery:\n+        if self._app:\n+            return self._app\n+        raise ValueError(\"Beat must provided a Celery app.\")",
      "comment": "Fixed a type hint (`scheduler`/`scheduler_cls`), and added a test that covers both.",
      "comment_id": 1125743861,
      "user": "max-muoto",
      "created_at": "2023-03-05T22:14:13Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1125743861"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,22 +77,32 @@ def __init__(self, max_interval=None, app=None,\n         if not isinstance(self.loglevel, numbers.Integral):\n             self.loglevel = LOG_LEVELS[self.loglevel.upper()]\n \n-    def run(self):\n+    @property\n+    def app(self) -> Celery:\n+        if self._app:\n+            return self._app\n+        raise ValueError(\"Beat must provided a Celery app.\")",
      "comment": "I seem to have some trouble running unit tests locally, pytest must be caching (or something else, not sure) as the new field on the `Beat` class isn't even picked up when inspecting with `pdb`. Do you have any ideas here?",
      "comment_id": 1125745483,
      "user": "max-muoto",
      "created_at": "2023-03-05T22:25:21Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1125745483"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,16 +41,16 @@ class Beat:\n     \"\"\"Beat as a service.\"\"\"\n \n     Service = beat.Service\n-    app = None\n-\n-    def __init__(self, max_interval=None, app=None,\n-                 socket_timeout=30, pidfile=None, no_color=None,\n-                 loglevel='WARN', logfile=None, schedule=None,\n-                 scheduler=None,\n-                 scheduler_cls=None,  # XXX use scheduler\n-                 redirect_stdouts=None,\n-                 redirect_stdouts_level=None,\n-                 quiet=False, **kwargs):\n+    app: Celery",
      "comment": "I need to know, why should be remove app = None while trying to add type hints",
      "comment_id": 1129010077,
      "user": "auvipy",
      "created_at": "2023-03-08T06:05:24Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1129010077"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,16 +41,16 @@ class Beat:\n     \"\"\"Beat as a service.\"\"\"\n \n     Service = beat.Service\n-    app = None\n-\n-    def __init__(self, max_interval=None, app=None,\n-                 socket_timeout=30, pidfile=None, no_color=None,\n-                 loglevel='WARN', logfile=None, schedule=None,\n-                 scheduler=None,\n-                 scheduler_cls=None,  # XXX use scheduler\n-                 redirect_stdouts=None,\n-                 redirect_stdouts_level=None,\n-                 quiet=False, **kwargs):\n+    app: Celery",
      "comment": "The reason why we need to remove `None` is to make the methods in the class type safe for mypy. As if it can be `None` here, and it can be `None` in the `init` method, then you can't call a single method on app without first checking if exists without the static analysis complaining.",
      "comment_id": 1129027756,
      "user": "max-muoto",
      "created_at": "2023-03-08T06:38:49Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1129027756"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8108,
      "file_path": "celery/apps/beat.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,16 +41,16 @@ class Beat:\n     \"\"\"Beat as a service.\"\"\"\n \n     Service = beat.Service\n-    app = None\n-\n-    def __init__(self, max_interval=None, app=None,\n-                 socket_timeout=30, pidfile=None, no_color=None,\n-                 loglevel='WARN', logfile=None, schedule=None,\n-                 scheduler=None,\n-                 scheduler_cls=None,  # XXX use scheduler\n-                 redirect_stdouts=None,\n-                 redirect_stdouts_level=None,\n-                 quiet=False, **kwargs):\n+    app: Celery",
      "comment": "App gets overridden anyway when grabbing it from the app. If it isn't set, and no app was provided for the init, then it doesn't make a difference since it would have run into an attribute error trying to call a method on app in the `init` method anyway.",
      "comment_id": 1129028353,
      "user": "max-muoto",
      "created_at": "2023-03-08T06:40:02Z",
      "url": "https://github.com/celery/celery/pull/8108#discussion_r1129028353"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8107,
      "file_path": "celery/utils/text.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,11 +1,13 @@\n \"\"\"Text formatting utilities.\"\"\"",
      "comment": "```suggestion\r\n\"\"\"Text formatting utilities.\"\"\"\r\nfrom __future__ import annotations\r\n```",
      "comment_id": 1125603930,
      "user": "auvipy",
      "created_at": "2023-03-05T06:09:08Z",
      "url": "https://github.com/celery/celery/pull/8107#discussion_r1125603930"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7398,
      "file_path": "celery/security/certificate.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,6 +2,7 @@\n import datetime",
      "comment": "That's not quite what is written on that answer... That's only about postponed evaluation of annotations.\r\n\r\nSo instead of:\r\n```python\r\n    def verify(self, data: bytes, signature: bytes, digest: Union[\"HashAlgorithm\", \"Prehashed\"]) -> None:\r\n```\r\nI would write:\r\n```python\r\n    def verify(self, data: bytes, signature: bytes, digest: Union[HashAlgorithm, Prehashed]) -> None:\r\n```\r\nThe latter would need `__future__`.",
      "comment_id": 844101116,
      "user": "Kludex",
      "created_at": "2022-04-06T15:40:23Z",
      "url": "https://github.com/celery/celery/pull/7398#discussion_r844101116"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7398,
      "file_path": "celery/security/certificate.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,6 +2,7 @@\n import datetime",
      "comment": "I see the benefits now: https://lukasz.langa.pl/61df599c-d9d8-4938-868b-36b67fdb4448/",
      "comment_id": 850586229,
      "user": "Kludex",
      "created_at": "2022-04-14T15:56:48Z",
      "url": "https://github.com/celery/celery/pull/7398#discussion_r850586229"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8064,
      "file_path": "t/unit/tasks/test_stamping.py",
      "line": 1231,
      "side": "LEFT",
      "diff_hunk": "@@ -1227,81 +1221,3 @@ def test_chord_stamping_one_level(self, subtests):\n \n         with subtests.test(\"sig_2_res has stamped_headers\", stamped_headers=[\"stamp\"]):\n             assert sorted(sig_2_res._get_task_meta()[\"stamped_headers\"]) == sorted([\"stamp\"])\n-\n-    @pytest.mark.usefixtures(\"depends_on_current_app\")",
      "comment": "No - I implemented it based on a wrong understanding of what is `Task.replace()` thus adding a behavior that does not make sense.\r\nSo I'm removing some of the recently developed code I added (even though it works, it's not needed because its not correct that the replace will stamp the replaced task implicitly). ",
      "comment_id": 1106294877,
      "user": "Nusnus",
      "created_at": "2023-02-14T19:41:43Z",
      "url": "https://github.com/celery/celery/pull/8064#discussion_r1106294877"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8064,
      "file_path": "examples/stamping/myapp.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,14 +16,15 @@\n    # The shell service is used to run the example.\n     (window2)$ celery -A myapp shell\n \n-   # Use (copy) the content of shell.py to run the workflow via the\n+   # Use (copy) the content of the examples modules to run the workflow via the\n    # shell service.\n \n-   # Use one of two demo runs via the shell service:\n+   # Use one of demo runs via the shell service:",
      "comment": "```suggestion\r\n   # Use one of the 3 demo runs via the shell service:\r\n```",
      "comment_id": 1107020511,
      "user": "auvipy",
      "created_at": "2023-02-15T11:45:53Z",
      "url": "https://github.com/celery/celery/pull/8064#discussion_r1107020511"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8064,
      "file_path": "examples/stamping/myapp.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,14 +16,15 @@\n    # The shell service is used to run the example.\n     (window2)$ celery -A myapp shell\n \n-   # Use (copy) the content of shell.py to run the workflow via the\n+   # Use (copy) the content of the examples modules to run the workflow via the\n    # shell service.\n \n-   # Use one of two demo runs via the shell service:\n+   # Use one of demo runs via the shell service:",
      "comment": "The `examples.py` has 3 demos, the revoke example has 2 demos, so I don't want to commit to a number in the docs and just say \"one of the demo runs\"",
      "comment_id": 1107071033,
      "user": "Nusnus",
      "created_at": "2023-02-15T12:37:41Z",
      "url": "https://github.com/celery/celery/pull/8064#discussion_r1107071033"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8064,
      "file_path": "celery/canvas.py",
      "line": 604,
      "side": "RIGHT",
      "diff_hunk": "@@ -550,86 +550,97 @@ def set(self, immutable=None, **options):\n     def set_immutable(self, immutable):\n         self.immutable = immutable\n \n-    def stamp(self, visitor=None, **headers):\n-        \"\"\"Stamp this signature with additional custom headers.\n-        Using a visitor will pass on responsibility for the stamping\n-        to the visitor.\n-\n-        .. versionadded:: 5.3\n-\n-        Arguments:\n-            visitor (StampingVisitor): Visitor API object.\n-            headers (Dict): Stamps that should be added to headers.\n-        \"\"\"\n-        self.stamp_links(visitor, **headers)\n-        headers = headers.copy()\n-        visitor_headers = None\n-        if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers) or {}\n-        headers = self._stamp_headers(visitor_headers, **headers)\n-        return self.set(**headers)\n-\n-    def _stamp_headers(self, visitor_headers=None, **headers):\n-        \"\"\" Collect all stamps from visitor, headers and self,\n+    def _stamp_headers(self, visitor_headers=None, append_stamps=True, self_headers=True, **headers):\n+        \"\"\"Collect all stamps from visitor, headers and self,\n         and return an idempotent dictionary of stamps.\n \n         .. versionadded:: 5.3\n \n         Arguments:\n             visitor_headers (Dict): Stamps from a visitor method.\n+            append_stamps (bool):\n+                If True, duplicated stamps will be appended to a list.\n+                If False, duplicated stamps will be replaced by the last stamp.\n+            self_headers (bool):\n+                If True, stamps from self.options will be added.\n+                If False, stamps from self.options will be ignored.\n             headers (Dict): Stamps that should be added to headers.\n \n         Returns:\n             Dict: Merged stamps.\n         \"\"\"\n-        # Use aggregate_duplicates=False to prioritize visitor_headers over headers in case of duplicated stamps.\n+        # Use append_stamps=True to prioritize visitor_headers over headers in case of duplicated stamps.\n         # This will lose duplicated headers from the headers argument, but that is the best effort solution\n         # to avoid implicitly casting the duplicated stamp into a list of both stamps from headers and\n         # visitor_headers of the same key.\n         # Example:\n         #   headers = {\"foo\": \"bar1\"}\n         #   visitor_headers = {\"foo\": \"bar2\"}\n-        #   _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=True)\n+        #   _merge_dictionaries(headers, visitor_headers, append_stamps=True)\n         #   headers[\"foo\"] == [\"bar1\", \"bar2\"] -> The stamp is now a list\n-        #   _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+        #   _merge_dictionaries(headers, visitor_headers, append_stamps=False)\n         #   headers[\"foo\"] == \"bar2\" -> \"bar1\" is lost, but the stamp is according to the visitor\n-        aggregate_duplicates = False\n \n         headers = headers.copy()\n+\n+        if \"stamped_headers\" not in headers:\n+            headers[\"stamped_headers\"] = list(headers.keys())\n+\n         # Merge headers with visitor headers\n         if visitor_headers is not None:\n             visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            # Prioritize visitor_headers over headers\n-            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=aggregate_duplicates)\n+\n+            # Sync from visitor\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=append_stamps)\n             headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n+\n         # Merge headers with self.options\n-        else:\n-            headers[\"stamped_headers\"] = [\n-                header for header in headers.keys()\n-                if header not in self.options and header != \"stamped_headers\"\n-            ]\n-\n-            # Prioritize self.options over headers\n-            _merge_dictionaries(headers, self.options, aggregate_duplicates=aggregate_duplicates)\n-\n-        # Sync missing stamps from self.options (relevant for stamping during task replacement)\n-        stamped_headers = set(headers.get(\"stamped_headers\", []))\n-        stamped_headers.update(self.options.get(\"stamped_headers\", []))\n-        headers[\"stamped_headers\"] = list(stamped_headers)\n-        for previous_header in stamped_headers:\n-            if previous_header not in headers and previous_header in self.options:\n-                headers[previous_header] = self.options[previous_header]\n+        if self_headers:\n+            stamped_headers = set(headers.get(\"stamped_headers\", []))\n+            stamped_headers.update(self.options.get(\"stamped_headers\", []))\n+            headers[\"stamped_headers\"] = list(stamped_headers)\n+            reducted_options = {k: v for k, v in self.options.items() if k in headers[\"stamped_headers\"]}",
      "comment": "> Did you mean `redacted_options`?\r\n\r\nLate night typos :)\r\nWill fix.",
      "comment_id": 1107074977,
      "user": "Nusnus",
      "created_at": "2023-02-15T12:41:42Z",
      "url": "https://github.com/celery/celery/pull/8064#discussion_r1107074977"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8064,
      "file_path": "celery/canvas.py",
      "line": 604,
      "side": "RIGHT",
      "diff_hunk": "@@ -550,86 +550,97 @@ def set(self, immutable=None, **options):\n     def set_immutable(self, immutable):\n         self.immutable = immutable\n \n-    def stamp(self, visitor=None, **headers):\n-        \"\"\"Stamp this signature with additional custom headers.\n-        Using a visitor will pass on responsibility for the stamping\n-        to the visitor.\n-\n-        .. versionadded:: 5.3\n-\n-        Arguments:\n-            visitor (StampingVisitor): Visitor API object.\n-            headers (Dict): Stamps that should be added to headers.\n-        \"\"\"\n-        self.stamp_links(visitor, **headers)\n-        headers = headers.copy()\n-        visitor_headers = None\n-        if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers) or {}\n-        headers = self._stamp_headers(visitor_headers, **headers)\n-        return self.set(**headers)\n-\n-    def _stamp_headers(self, visitor_headers=None, **headers):\n-        \"\"\" Collect all stamps from visitor, headers and self,\n+    def _stamp_headers(self, visitor_headers=None, append_stamps=True, self_headers=True, **headers):\n+        \"\"\"Collect all stamps from visitor, headers and self,\n         and return an idempotent dictionary of stamps.\n \n         .. versionadded:: 5.3\n \n         Arguments:\n             visitor_headers (Dict): Stamps from a visitor method.\n+            append_stamps (bool):\n+                If True, duplicated stamps will be appended to a list.\n+                If False, duplicated stamps will be replaced by the last stamp.\n+            self_headers (bool):\n+                If True, stamps from self.options will be added.\n+                If False, stamps from self.options will be ignored.\n             headers (Dict): Stamps that should be added to headers.\n \n         Returns:\n             Dict: Merged stamps.\n         \"\"\"\n-        # Use aggregate_duplicates=False to prioritize visitor_headers over headers in case of duplicated stamps.\n+        # Use append_stamps=True to prioritize visitor_headers over headers in case of duplicated stamps.\n         # This will lose duplicated headers from the headers argument, but that is the best effort solution\n         # to avoid implicitly casting the duplicated stamp into a list of both stamps from headers and\n         # visitor_headers of the same key.\n         # Example:\n         #   headers = {\"foo\": \"bar1\"}\n         #   visitor_headers = {\"foo\": \"bar2\"}\n-        #   _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=True)\n+        #   _merge_dictionaries(headers, visitor_headers, append_stamps=True)\n         #   headers[\"foo\"] == [\"bar1\", \"bar2\"] -> The stamp is now a list\n-        #   _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+        #   _merge_dictionaries(headers, visitor_headers, append_stamps=False)\n         #   headers[\"foo\"] == \"bar2\" -> \"bar1\" is lost, but the stamp is according to the visitor\n-        aggregate_duplicates = False\n \n         headers = headers.copy()\n+\n+        if \"stamped_headers\" not in headers:\n+            headers[\"stamped_headers\"] = list(headers.keys())\n+\n         # Merge headers with visitor headers\n         if visitor_headers is not None:\n             visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            # Prioritize visitor_headers over headers\n-            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=aggregate_duplicates)\n+\n+            # Sync from visitor\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=append_stamps)\n             headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n+\n         # Merge headers with self.options\n-        else:\n-            headers[\"stamped_headers\"] = [\n-                header for header in headers.keys()\n-                if header not in self.options and header != \"stamped_headers\"\n-            ]\n-\n-            # Prioritize self.options over headers\n-            _merge_dictionaries(headers, self.options, aggregate_duplicates=aggregate_duplicates)\n-\n-        # Sync missing stamps from self.options (relevant for stamping during task replacement)\n-        stamped_headers = set(headers.get(\"stamped_headers\", []))\n-        stamped_headers.update(self.options.get(\"stamped_headers\", []))\n-        headers[\"stamped_headers\"] = list(stamped_headers)\n-        for previous_header in stamped_headers:\n-            if previous_header not in headers and previous_header in self.options:\n-                headers[previous_header] = self.options[previous_header]\n+        if self_headers:\n+            stamped_headers = set(headers.get(\"stamped_headers\", []))\n+            stamped_headers.update(self.options.get(\"stamped_headers\", []))\n+            headers[\"stamped_headers\"] = list(stamped_headers)\n+            reducted_options = {k: v for k, v in self.options.items() if k in headers[\"stamped_headers\"]}",
      "comment": "> Also, why are they redacted? What do you mean by that?\r\n\r\n`{k: v for k, v in self.options.items() if k in headers[\"stamped_headers\"]}`\r\nMeaning `self.options` fields which are stamps.",
      "comment_id": 1107075772,
      "user": "Nusnus",
      "created_at": "2023-02-15T12:42:30Z",
      "url": "https://github.com/celery/celery/pull/8064#discussion_r1107075772"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8064,
      "file_path": "celery/canvas.py",
      "line": 600,
      "side": "RIGHT",
      "diff_hunk": "@@ -550,86 +550,97 @@ def set(self, immutable=None, **options):\n     def set_immutable(self, immutable):\n         self.immutable = immutable\n \n-    def stamp(self, visitor=None, **headers):\n-        \"\"\"Stamp this signature with additional custom headers.\n-        Using a visitor will pass on responsibility for the stamping\n-        to the visitor.\n-\n-        .. versionadded:: 5.3\n-\n-        Arguments:\n-            visitor (StampingVisitor): Visitor API object.\n-            headers (Dict): Stamps that should be added to headers.\n-        \"\"\"\n-        self.stamp_links(visitor, **headers)\n-        headers = headers.copy()\n-        visitor_headers = None\n-        if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers) or {}\n-        headers = self._stamp_headers(visitor_headers, **headers)\n-        return self.set(**headers)\n-\n-    def _stamp_headers(self, visitor_headers=None, **headers):\n-        \"\"\" Collect all stamps from visitor, headers and self,\n+    def _stamp_headers(self, visitor_headers=None, append_stamps=True, self_headers=True, **headers):\n+        \"\"\"Collect all stamps from visitor, headers and self,\n         and return an idempotent dictionary of stamps.\n \n         .. versionadded:: 5.3\n \n         Arguments:\n             visitor_headers (Dict): Stamps from a visitor method.\n+            append_stamps (bool):\n+                If True, duplicated stamps will be appended to a list.\n+                If False, duplicated stamps will be replaced by the last stamp.\n+            self_headers (bool):\n+                If True, stamps from self.options will be added.\n+                If False, stamps from self.options will be ignored.\n             headers (Dict): Stamps that should be added to headers.\n \n         Returns:\n             Dict: Merged stamps.\n         \"\"\"\n-        # Use aggregate_duplicates=False to prioritize visitor_headers over headers in case of duplicated stamps.\n+        # Use append_stamps=True to prioritize visitor_headers over headers in case of duplicated stamps.\n         # This will lose duplicated headers from the headers argument, but that is the best effort solution\n         # to avoid implicitly casting the duplicated stamp into a list of both stamps from headers and\n         # visitor_headers of the same key.\n         # Example:\n         #   headers = {\"foo\": \"bar1\"}\n         #   visitor_headers = {\"foo\": \"bar2\"}\n-        #   _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=True)\n+        #   _merge_dictionaries(headers, visitor_headers, append_stamps=True)\n         #   headers[\"foo\"] == [\"bar1\", \"bar2\"] -> The stamp is now a list\n-        #   _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+        #   _merge_dictionaries(headers, visitor_headers, append_stamps=False)\n         #   headers[\"foo\"] == \"bar2\" -> \"bar1\" is lost, but the stamp is according to the visitor\n-        aggregate_duplicates = False\n \n         headers = headers.copy()\n+\n+        if \"stamped_headers\" not in headers:\n+            headers[\"stamped_headers\"] = list(headers.keys())\n+\n         # Merge headers with visitor headers\n         if visitor_headers is not None:\n             visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            # Prioritize visitor_headers over headers\n-            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=aggregate_duplicates)\n+\n+            # Sync from visitor\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=append_stamps)\n             headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n+\n         # Merge headers with self.options\n-        else:\n-            headers[\"stamped_headers\"] = [\n-                header for header in headers.keys()\n-                if header not in self.options and header != \"stamped_headers\"\n-            ]\n-\n-            # Prioritize self.options over headers\n-            _merge_dictionaries(headers, self.options, aggregate_duplicates=aggregate_duplicates)\n-\n-        # Sync missing stamps from self.options (relevant for stamping during task replacement)\n-        stamped_headers = set(headers.get(\"stamped_headers\", []))\n-        stamped_headers.update(self.options.get(\"stamped_headers\", []))\n-        headers[\"stamped_headers\"] = list(stamped_headers)\n-        for previous_header in stamped_headers:\n-            if previous_header not in headers and previous_header in self.options:\n-                headers[previous_header] = self.options[previous_header]\n+        if self_headers:",
      "comment": "It is not optional, the `self_headers` isn't an external param but an internal flag to use.\r\nThe behavior has not changed in regard to how the stamping works, just the code readability and organization in this case.",
      "comment_id": 1107077652,
      "user": "Nusnus",
      "created_at": "2023-02-15T12:44:19Z",
      "url": "https://github.com/celery/celery/pull/8064#discussion_r1107077652"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8064,
      "file_path": "celery/canvas.py",
      "line": 604,
      "side": "RIGHT",
      "diff_hunk": "@@ -550,86 +550,97 @@ def set(self, immutable=None, **options):\n     def set_immutable(self, immutable):\n         self.immutable = immutable\n \n-    def stamp(self, visitor=None, **headers):\n-        \"\"\"Stamp this signature with additional custom headers.\n-        Using a visitor will pass on responsibility for the stamping\n-        to the visitor.\n-\n-        .. versionadded:: 5.3\n-\n-        Arguments:\n-            visitor (StampingVisitor): Visitor API object.\n-            headers (Dict): Stamps that should be added to headers.\n-        \"\"\"\n-        self.stamp_links(visitor, **headers)\n-        headers = headers.copy()\n-        visitor_headers = None\n-        if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers) or {}\n-        headers = self._stamp_headers(visitor_headers, **headers)\n-        return self.set(**headers)\n-\n-    def _stamp_headers(self, visitor_headers=None, **headers):\n-        \"\"\" Collect all stamps from visitor, headers and self,\n+    def _stamp_headers(self, visitor_headers=None, append_stamps=True, self_headers=True, **headers):\n+        \"\"\"Collect all stamps from visitor, headers and self,\n         and return an idempotent dictionary of stamps.\n \n         .. versionadded:: 5.3\n \n         Arguments:\n             visitor_headers (Dict): Stamps from a visitor method.\n+            append_stamps (bool):\n+                If True, duplicated stamps will be appended to a list.\n+                If False, duplicated stamps will be replaced by the last stamp.\n+            self_headers (bool):\n+                If True, stamps from self.options will be added.\n+                If False, stamps from self.options will be ignored.\n             headers (Dict): Stamps that should be added to headers.\n \n         Returns:\n             Dict: Merged stamps.\n         \"\"\"\n-        # Use aggregate_duplicates=False to prioritize visitor_headers over headers in case of duplicated stamps.\n+        # Use append_stamps=True to prioritize visitor_headers over headers in case of duplicated stamps.\n         # This will lose duplicated headers from the headers argument, but that is the best effort solution\n         # to avoid implicitly casting the duplicated stamp into a list of both stamps from headers and\n         # visitor_headers of the same key.\n         # Example:\n         #   headers = {\"foo\": \"bar1\"}\n         #   visitor_headers = {\"foo\": \"bar2\"}\n-        #   _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=True)\n+        #   _merge_dictionaries(headers, visitor_headers, append_stamps=True)\n         #   headers[\"foo\"] == [\"bar1\", \"bar2\"] -> The stamp is now a list\n-        #   _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+        #   _merge_dictionaries(headers, visitor_headers, append_stamps=False)\n         #   headers[\"foo\"] == \"bar2\" -> \"bar1\" is lost, but the stamp is according to the visitor\n-        aggregate_duplicates = False\n \n         headers = headers.copy()\n+\n+        if \"stamped_headers\" not in headers:\n+            headers[\"stamped_headers\"] = list(headers.keys())\n+\n         # Merge headers with visitor headers\n         if visitor_headers is not None:\n             visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            # Prioritize visitor_headers over headers\n-            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=aggregate_duplicates)\n+\n+            # Sync from visitor\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=append_stamps)\n             headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n+\n         # Merge headers with self.options\n-        else:\n-            headers[\"stamped_headers\"] = [\n-                header for header in headers.keys()\n-                if header not in self.options and header != \"stamped_headers\"\n-            ]\n-\n-            # Prioritize self.options over headers\n-            _merge_dictionaries(headers, self.options, aggregate_duplicates=aggregate_duplicates)\n-\n-        # Sync missing stamps from self.options (relevant for stamping during task replacement)\n-        stamped_headers = set(headers.get(\"stamped_headers\", []))\n-        stamped_headers.update(self.options.get(\"stamped_headers\", []))\n-        headers[\"stamped_headers\"] = list(stamped_headers)\n-        for previous_header in stamped_headers:\n-            if previous_header not in headers and previous_header in self.options:\n-                headers[previous_header] = self.options[previous_header]\n+        if self_headers:\n+            stamped_headers = set(headers.get(\"stamped_headers\", []))\n+            stamped_headers.update(self.options.get(\"stamped_headers\", []))\n+            headers[\"stamped_headers\"] = list(stamped_headers)\n+            reducted_options = {k: v for k, v in self.options.items() if k in headers[\"stamped_headers\"]}",
      "comment": "Added a comment to clarify + fixed typo - fix pushed",
      "comment_id": 1107210025,
      "user": "Nusnus",
      "created_at": "2023-02-15T14:37:44Z",
      "url": "https://github.com/celery/celery/pull/8064#discussion_r1107210025"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8053,
      "file_path": "celery/schedules.py",
      "line": 471,
      "side": "LEFT",
      "diff_hunk": "@@ -468,9 +468,9 @@ def day_out_of_range(year, month, day):\n             return False\n \n         def is_before_last_run(year, month, day):\n-            return self.maybe_make_aware(datetime(year,",
      "comment": "can we make sure that maybe_make_aware removal won't create any other consequences?",
      "comment_id": 1096624958,
      "user": "auvipy",
      "created_at": "2023-02-05T05:18:32Z",
      "url": "https://github.com/celery/celery/pull/8053#discussion_r1096624958"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/canvas.py",
      "line": 165,
      "side": "LEFT",
      "diff_hunk": "@@ -162,33 +165,33 @@ def on_signature(self, sig, **headers) -> dict:\n              Dict: headers to update.\n          \"\"\"\n \n-    def on_chord_header_start(self, chord, **header) -> dict:",
      "comment": "This caused a very annoying bug where `headers` had a key named `chord` and this caused an exception to be raised.",
      "comment_id": 1096605015,
      "user": "Nusnus",
      "created_at": "2023-02-05T00:46:14Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1096605015"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "t/unit/tasks/test_canvas.py",
      "line": 1023,
      "side": "LEFT",
      "diff_hunk": "@@ -1019,15 +585,11 @@ def s(*args, **kwargs):\n         assert c.tasks[-1].options['chord'] == 'some_chord_id'\n \n         c.apply_async(link=[s(32)])\n-        expected_sig = s(32)\n-        expected_sig.stamp(visitor=GroupStampingVisitor())",
      "comment": "This was an API breaking change the `GroupStampingVisitor` introduced that could have broken prod systems post 5.3 release...",
      "comment_id": 1096605652,
      "user": "Nusnus",
      "created_at": "2023-02-05T00:55:27Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1096605652"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/canvas.py",
      "line": 586,
      "side": "RIGHT",
      "diff_hunk": "@@ -582,22 +553,47 @@ def stamp(self, visitor=None, **headers):\n             headers (Dict): Stamps that should be added to headers.\n         \"\"\"\n         self.stamp_links(visitor, **headers)\n-\n-        headers = headers.copy()\n+        headers = deepcopy(headers)\n+        visitor_headers = None\n         if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers)\n+            visitor_headers = visitor.on_signature(self, **headers) or {}\n+        headers = self._stamp_headers(visitor_headers, **headers)\n+        return self.set(**headers)\n+\n+    def _stamp_headers(self, visitor_headers=None, **headers):\n+        headers = deepcopy(headers)\n+        if visitor_headers is not None:\n+            visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            _merge_dictionaries(headers, visitor_headers)\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n         else:\n-            headers[\"stamped_headers\"] = [header for header in headers.keys() if header not in self.options]\n-            _merge_dictionaries(headers, self.options)\n+            stamped_headers = [\n+                header for header in headers.keys()\n+                if all([\n+                    header != \"stamped_headers\",\n+                    header in self.options.get(\"stamped_headers\", [])\n+                ])\n+            ]\n+            if \"stamped_headers\" in headers:\n+                headers[\"stamped_headers\"].extend(stamped_headers)\n+            else:\n+                headers[\"stamped_headers\"] = stamped_headers\n+            for stamp in headers.keys():\n+                if stamp != \"stamped_headers\" and stamp not in headers[\"stamped_headers\"]:\n+                    headers[\"stamped_headers\"].append(stamp)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))",
      "comment": "I agree. Thank's for the code snippet.\r\nFix pushed.",
      "comment_id": 1097992136,
      "user": "Nusnus",
      "created_at": "2023-02-06T22:38:19Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1097992136"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/canvas.py",
      "line": 596,
      "side": "RIGHT",
      "diff_hunk": "@@ -582,22 +553,47 @@ def stamp(self, visitor=None, **headers):\n             headers (Dict): Stamps that should be added to headers.\n         \"\"\"\n         self.stamp_links(visitor, **headers)\n-\n-        headers = headers.copy()\n+        headers = deepcopy(headers)\n+        visitor_headers = None\n         if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers)\n+            visitor_headers = visitor.on_signature(self, **headers) or {}\n+        headers = self._stamp_headers(visitor_headers, **headers)\n+        return self.set(**headers)\n+\n+    def _stamp_headers(self, visitor_headers=None, **headers):\n+        headers = deepcopy(headers)\n+        if visitor_headers is not None:\n+            visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            _merge_dictionaries(headers, visitor_headers)\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n         else:\n-            headers[\"stamped_headers\"] = [header for header in headers.keys() if header not in self.options]\n-            _merge_dictionaries(headers, self.options)\n+            stamped_headers = [\n+                header for header in headers.keys()\n+                if all([\n+                    header != \"stamped_headers\",\n+                    header in self.options.get(\"stamped_headers\", [])\n+                ])\n+            ]\n+            if \"stamped_headers\" in headers:\n+                headers[\"stamped_headers\"].extend(stamped_headers)\n+            else:\n+                headers[\"stamped_headers\"] = stamped_headers\n+            for stamp in headers.keys():\n+                if stamp != \"stamped_headers\" and stamp not in headers[\"stamped_headers\"]:\n+                    headers[\"stamped_headers\"].append(stamp)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n+            _merge_dictionaries(headers, self.options, aggregate_duplicates=False)\n \n         # Preserve previous stamped headers\n         stamped_headers = set(self.options.get(\"stamped_headers\", []))\n-        stamped_headers.update(headers[\"stamped_headers\"])\n+        stamped_headers.update(headers.get(\"stamped_headers\", []))\n         headers[\"stamped_headers\"] = list(stamped_headers)\n-        return self.set(**headers)\n+        for previous_header in stamped_headers:\n+            if previous_header not in headers and previous_header in self.options:\n+                headers[previous_header] = self.options[previous_header]\n+        return headers",
      "comment": "I'm not sure I understand your comment, can you please explain \ud83d\ude4f\r\nAlso, please notice the diff between `stamp()` and `_stamp_headers()`, the github diff view might make it look confusing, because I'm not fully sure why you say:\r\n> So now we set all headers every time we stamp? Even the non-stamped headers?\r\n\r\nAnd what difference do you see from the previous implementation logic-wise?",
      "comment_id": 1097998577,
      "user": "Nusnus",
      "created_at": "2023-02-06T22:47:26Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1097998577"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "t/integration/test_stamping.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,425 @@\n+import collections\n+import uuid\n+from time import sleep\n+\n+import pytest\n+import pytest_subtests  # noqa\n+\n+from celery import chain, chord, group\n+from celery.canvas import StampingVisitor\n+from celery.exceptions import TimeoutError\n+from celery.signals import before_task_publish, task_received\n+\n+from . import tasks  # noqa\n+from .conftest import get_redis_connection\n+from .tasks import ExpectedException, StampOnReplace, add, fail, identity, mul, replace_with_stamped_task, xsum\n+\n+RETRYABLE_EXCEPTIONS = (OSError, ConnectionError, TimeoutError)\n+\n+\n+def is_retryable_exception(exc):\n+    return isinstance(exc, RETRYABLE_EXCEPTIONS)\n+\n+\n+TIMEOUT = 60\n+\n+_flaky = pytest.mark.flaky(reruns=5, reruns_delay=1, cause=is_retryable_exception)\n+_timeout = pytest.mark.timeout(timeout=300)\n+\n+\n+def flaky(fn):\n+    return _timeout(_flaky(fn))\n+\n+\n+def await_redis_echo(expected_msgs, redis_key=\"redis-echo\", timeout=TIMEOUT):\n+    \"\"\"\n+    Helper to wait for a specified or well-known redis key to contain a string.\n+    \"\"\"\n+    redis_connection = get_redis_connection()\n+\n+    if isinstance(expected_msgs, (str, bytes, bytearray)):\n+        expected_msgs = (expected_msgs,)\n+    expected_msgs = collections.Counter(\n+        e if not isinstance(e, str) else e.encode(\"utf-8\") for e in expected_msgs\n+    )\n+\n+    # This can technically wait for `len(expected_msg_or_msgs) * timeout` :/\n+    while +expected_msgs:\n+        maybe_key_msg = redis_connection.blpop(redis_key, timeout)\n+        if maybe_key_msg is None:\n+            raise TimeoutError(\n+                \"Fetching from {!r} timed out - still awaiting {!r}\".format(\n+                    redis_key, dict(+expected_msgs)\n+                )\n+            )\n+        retrieved_key, msg = maybe_key_msg\n+        assert retrieved_key.decode(\"utf-8\") == redis_key\n+        expected_msgs[msg] -= 1  # silently accepts unexpected messages\n+\n+    # There should be no more elements - block momentarily\n+    assert redis_connection.blpop(redis_key, min(1, timeout)) is None\n+\n+\n+def await_redis_list_message_length(\n+    expected_length, redis_key=\"redis-group-ids\", timeout=TIMEOUT\n+):\n+    \"\"\"\n+    Helper to wait for a specified or well-known redis key to contain a string.\n+    \"\"\"\n+    sleep(1)\n+    redis_connection = get_redis_connection()\n+\n+    check_interval = 0.1\n+    check_max = int(timeout / check_interval)\n+\n+    for i in range(check_max + 1):\n+        length = redis_connection.llen(redis_key)\n+\n+        if length == expected_length:\n+            break\n+\n+        sleep(check_interval)\n+    else:\n+        raise TimeoutError(\n+            f\"{redis_key!r} has length of {length}, but expected to be of length {expected_length}\"\n+        )\n+\n+    sleep(min(1, timeout))\n+    assert redis_connection.llen(redis_key) == expected_length\n+\n+\n+def await_redis_count(expected_count, redis_key=\"redis-count\", timeout=TIMEOUT):\n+    \"\"\"\n+    Helper to wait for a specified or well-known redis key to count to a value.\n+    \"\"\"\n+    redis_connection = get_redis_connection()\n+\n+    check_interval = 0.1\n+    check_max = int(timeout / check_interval)\n+    for i in range(check_max + 1):\n+        maybe_count = redis_connection.get(redis_key)\n+        # It's either `None` or a base-10 integer\n+        if maybe_count is not None:\n+            count = int(maybe_count)\n+            if count == expected_count:\n+                break\n+            elif i >= check_max:\n+                assert count == expected_count\n+        # try again later\n+        sleep(check_interval)\n+    else:\n+        raise TimeoutError(f\"{redis_key!r} was never incremented\")\n+\n+    # There should be no more increments - block momentarily\n+    sleep(min(1, timeout))\n+    assert int(redis_connection.get(redis_key)) == expected_count",
      "comment": "@thedrow I did not work at all in this PR on the integration tests besides moving it to an external file, so I will address this only after I finish working on the integration tests.\r\nFor now I need to close open ends before the integration tests at all so you'll have to review it again when I'll be done \ud83d\ude4f",
      "comment_id": 1098003503,
      "user": "Nusnus",
      "created_at": "2023-02-06T22:54:46Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1098003503"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/canvas.py",
      "line": 610,
      "side": "RIGHT",
      "diff_hunk": "@@ -608,40 +604,37 @@ def stamp_links(self, visitor, **headers):\n             visitor (StampingVisitor): Visitor API object.\n             headers (Dict): Stamps that should be added to headers.\n         \"\"\"\n-        if not visitor:\n-            return\n-\n-        non_visitor_headers = headers.copy()\n+        non_visitor_headers = deepcopy(headers)\n \n         # Stamp all of the callbacks of this signature\n-        headers = non_visitor_headers.copy()\n+        headers = deepcopy(non_visitor_headers)",
      "comment": "TBH I don't have a clear explanation.\r\nIf I use `.copy()` the unit tests are failing (some).\r\nIf I use `deepcopy()`, it works as expected.\r\n\r\nI've replaced all other instances with `.copy()`, but here with `non_visitor_headers` we do need `deepcopy()` or the feature breaks.\r\n\r\nI'm not sure why but there are much bigger issues at hand, so I didn't invest a lot investigating this. ",
      "comment_id": 1098015359,
      "user": "Nusnus",
      "created_at": "2023-02-06T23:14:02Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1098015359"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/app/task.py",
      "line": 956,
      "side": "RIGHT",
      "diff_hunk": "@@ -953,41 +953,7 @@ def replace(self, sig):\n         for t in reversed(self.request.chain or []):\n             sig |= signature(t, app=self.app)\n         # Stamping sig with parents groups\n-        if self.request.stamps:\n-            groups = self.request.stamps.get(\"groups\")\n-            sig.stamp(visitor=GroupStampingVisitor(groups=groups, stamped_headers=self.request.stamped_headers))\n-            stamped_headers = self.request.stamped_headers.copy()\n-            stamps = self.request.stamps.copy()\n-            stamped_headers.extend(sig.options.get('stamped_headers', []))\n-            stamped_headers = list(set(stamped_headers))\n-            stamps.update({\n-                stamp: value\n-                for stamp, value in sig.options.items() if stamp in sig.options.get('stamped_headers', [])\n-            })\n-            sig.options['stamped_headers'] = stamped_headers\n-            sig.options.update(stamps)\n-\n-            # Collecting all of the links (callback/errback) to stamp them\n-            links = sig.options['link'] if 'link' in sig.options else []\n-            links.extend(sig.options['link_error'] if 'link_error' in sig.options else [])\n-\n-            if hasattr(sig, \"tasks\"):\n-                tasks = sig.tasks\n-                if isinstance(tasks, group):\n-                    tasks = tasks.tasks\n-                for task in tasks:\n-                    task.options['stamped_headers'] = stamped_headers\n-                    task.options.update(stamps)\n-                    links.extend(task.options['link'] if 'link' in task.options else [])\n-                    links.extend(task.options['link_error'] if 'link_error' in task.options else [])\n-\n-            for link in links:\n-                link_stamped_headers = stamped_headers.copy()\n-                link_stamped_headers.extend(link['options'].get('stamped_headers', []))\n-                link_stamped_headers = list(set(link_stamped_headers))\n-                link['options']['stamped_headers'] = link_stamped_headers\n-                link['options'].update(stamps)\n-\n+        self.on_replace_stamping(sig)",
      "comment": "Sure np.\r\nPlease notice Sphinx doc will be the last step after everything is working and the code is cleaned and fixed \ud83d\ude42",
      "comment_id": 1098044483,
      "user": "Nusnus",
      "created_at": "2023-02-07T00:08:12Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1098044483"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/canvas.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,7 +70,7 @@ def _stamp_regen_task(task, visitor, **headers):\n     return task\n \n \n-def _merge_dictionaries(d1, d2):\n+def _merge_dictionaries(d1, d2, aggregate_duplicates=True):",
      "comment": "Fix pushed\r\n\r\n> Can you please explain what we use aggregate_duplicates for?\r\n\r\nRead both (new) doc in `_merge_dictionaries` and in `_stamp_headers`",
      "comment_id": 1098078564,
      "user": "Nusnus",
      "created_at": "2023-02-07T01:18:10Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1098078564"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/canvas.py",
      "line": 596,
      "side": "RIGHT",
      "diff_hunk": "@@ -582,22 +553,47 @@ def stamp(self, visitor=None, **headers):\n             headers (Dict): Stamps that should be added to headers.\n         \"\"\"\n         self.stamp_links(visitor, **headers)\n-\n-        headers = headers.copy()\n+        headers = deepcopy(headers)\n+        visitor_headers = None\n         if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers)\n+            visitor_headers = visitor.on_signature(self, **headers) or {}\n+        headers = self._stamp_headers(visitor_headers, **headers)\n+        return self.set(**headers)\n+\n+    def _stamp_headers(self, visitor_headers=None, **headers):\n+        headers = deepcopy(headers)\n+        if visitor_headers is not None:\n+            visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            _merge_dictionaries(headers, visitor_headers)\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n         else:\n-            headers[\"stamped_headers\"] = [header for header in headers.keys() if header not in self.options]\n-            _merge_dictionaries(headers, self.options)\n+            stamped_headers = [\n+                header for header in headers.keys()\n+                if all([\n+                    header != \"stamped_headers\",\n+                    header in self.options.get(\"stamped_headers\", [])\n+                ])\n+            ]\n+            if \"stamped_headers\" in headers:\n+                headers[\"stamped_headers\"].extend(stamped_headers)\n+            else:\n+                headers[\"stamped_headers\"] = stamped_headers\n+            for stamp in headers.keys():\n+                if stamp != \"stamped_headers\" and stamp not in headers[\"stamped_headers\"]:\n+                    headers[\"stamped_headers\"].append(stamp)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n+            _merge_dictionaries(headers, self.options, aggregate_duplicates=False)\n \n         # Preserve previous stamped headers\n         stamped_headers = set(self.options.get(\"stamped_headers\", []))\n-        stamped_headers.update(headers[\"stamped_headers\"])\n+        stamped_headers.update(headers.get(\"stamped_headers\", []))\n         headers[\"stamped_headers\"] = list(stamped_headers)\n-        return self.set(**headers)\n+        for previous_header in stamped_headers:\n+            if previous_header not in headers and previous_header in self.options:\n+                headers[previous_header] = self.options[previous_header]\n+        return headers",
      "comment": "Please review again @thedrow , I've refactored the code to fix the previous comments so it might be easier to understand now",
      "comment_id": 1098079685,
      "user": "Nusnus",
      "created_at": "2023-02-07T01:20:26Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1098079685"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/canvas.py",
      "line": 583,
      "side": "RIGHT",
      "diff_hunk": "@@ -582,22 +553,47 @@ def stamp(self, visitor=None, **headers):\n             headers (Dict): Stamps that should be added to headers.\n         \"\"\"\n         self.stamp_links(visitor, **headers)\n-\n-        headers = headers.copy()\n+        headers = deepcopy(headers)\n+        visitor_headers = None\n         if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers)\n+            visitor_headers = visitor.on_signature(self, **headers) or {}\n+        headers = self._stamp_headers(visitor_headers, **headers)\n+        return self.set(**headers)\n+\n+    def _stamp_headers(self, visitor_headers=None, **headers):\n+        headers = deepcopy(headers)\n+        if visitor_headers is not None:\n+            visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            _merge_dictionaries(headers, visitor_headers)\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n         else:\n-            headers[\"stamped_headers\"] = [header for header in headers.keys() if header not in self.options]\n-            _merge_dictionaries(headers, self.options)\n+            stamped_headers = [\n+                header for header in headers.keys()\n+                if all([\n+                    header != \"stamped_headers\",\n+                    header in self.options.get(\"stamped_headers\", [])\n+                ])\n+            ]\n+            if \"stamped_headers\" in headers:\n+                headers[\"stamped_headers\"].extend(stamped_headers)\n+            else:\n+                headers[\"stamped_headers\"] = stamped_headers\n+            for stamp in headers.keys():",
      "comment": "I'm not sure what comment you want for `result_extended`.\r\nCan you please review it again (the code was fixed and changed a lot) and suggest a comment to add? \ud83d\ude4f\r\n\r\nThanks!",
      "comment_id": 1098081893,
      "user": "Nusnus",
      "created_at": "2023-02-07T01:24:57Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1098081893"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/canvas.py",
      "line": 586,
      "side": "RIGHT",
      "diff_hunk": "@@ -582,22 +553,47 @@ def stamp(self, visitor=None, **headers):\n             headers (Dict): Stamps that should be added to headers.\n         \"\"\"\n         self.stamp_links(visitor, **headers)\n-\n-        headers = headers.copy()\n+        headers = deepcopy(headers)\n+        visitor_headers = None\n         if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers)\n+            visitor_headers = visitor.on_signature(self, **headers) or {}\n+        headers = self._stamp_headers(visitor_headers, **headers)\n+        return self.set(**headers)\n+\n+    def _stamp_headers(self, visitor_headers=None, **headers):\n+        headers = deepcopy(headers)\n+        if visitor_headers is not None:\n+            visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            _merge_dictionaries(headers, visitor_headers)\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n         else:\n-            headers[\"stamped_headers\"] = [header for header in headers.keys() if header not in self.options]\n-            _merge_dictionaries(headers, self.options)\n+            stamped_headers = [\n+                header for header in headers.keys()\n+                if all([\n+                    header != \"stamped_headers\",\n+                    header in self.options.get(\"stamped_headers\", [])\n+                ])\n+            ]\n+            if \"stamped_headers\" in headers:\n+                headers[\"stamped_headers\"].extend(stamped_headers)\n+            else:\n+                headers[\"stamped_headers\"] = stamped_headers\n+            for stamp in headers.keys():\n+                if stamp != \"stamped_headers\" and stamp not in headers[\"stamped_headers\"]:\n+                    headers[\"stamped_headers\"].append(stamp)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))",
      "comment": "In the last version of this code it was completely removed so please review it again and ignore:\r\n> I agree. Thank's for the code snippet.\r\n> Fix pushed.\r\n\r\n@thedrow ",
      "comment_id": 1098082823,
      "user": "Nusnus",
      "created_at": "2023-02-07T01:26:43Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1098082823"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8045,
      "file_path": "celery/canvas.py",
      "line": 596,
      "side": "RIGHT",
      "diff_hunk": "@@ -582,22 +553,47 @@ def stamp(self, visitor=None, **headers):\n             headers (Dict): Stamps that should be added to headers.\n         \"\"\"\n         self.stamp_links(visitor, **headers)\n-\n-        headers = headers.copy()\n+        headers = deepcopy(headers)\n+        visitor_headers = None\n         if visitor is not None:\n-            visitor_headers = visitor.on_signature(self, **headers)\n+            visitor_headers = visitor.on_signature(self, **headers) or {}\n+        headers = self._stamp_headers(visitor_headers, **headers)\n+        return self.set(**headers)\n+\n+    def _stamp_headers(self, visitor_headers=None, **headers):\n+        headers = deepcopy(headers)\n+        if visitor_headers is not None:\n+            visitor_headers = visitor_headers or {}\n             if \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            _merge_dictionaries(headers, visitor_headers)\n+            _merge_dictionaries(headers, visitor_headers, aggregate_duplicates=False)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n         else:\n-            headers[\"stamped_headers\"] = [header for header in headers.keys() if header not in self.options]\n-            _merge_dictionaries(headers, self.options)\n+            stamped_headers = [\n+                header for header in headers.keys()\n+                if all([\n+                    header != \"stamped_headers\",\n+                    header in self.options.get(\"stamped_headers\", [])\n+                ])\n+            ]\n+            if \"stamped_headers\" in headers:\n+                headers[\"stamped_headers\"].extend(stamped_headers)\n+            else:\n+                headers[\"stamped_headers\"] = stamped_headers\n+            for stamp in headers.keys():\n+                if stamp != \"stamped_headers\" and stamp not in headers[\"stamped_headers\"]:\n+                    headers[\"stamped_headers\"].append(stamp)\n+            headers[\"stamped_headers\"] = list(set(headers[\"stamped_headers\"]))\n+            _merge_dictionaries(headers, self.options, aggregate_duplicates=False)\n \n         # Preserve previous stamped headers\n         stamped_headers = set(self.options.get(\"stamped_headers\", []))\n-        stamped_headers.update(headers[\"stamped_headers\"])\n+        stamped_headers.update(headers.get(\"stamped_headers\", []))\n         headers[\"stamped_headers\"] = list(stamped_headers)\n-        return self.set(**headers)\n+        for previous_header in stamped_headers:\n+            if previous_header not in headers and previous_header in self.options:\n+                headers[previous_header] = self.options[previous_header]\n+        return headers",
      "comment": "@thedrow \r\n> I guess your comment should explain what happens during replacing that requires us to always set all stamped headers even if they were not touched by the visitor or by the kwargs.\r\n\r\nTBH I don't know. The new test cases are checking so many new edge cases that in the case of stamping with task replacement, this happened.\r\n\r\nIt is not perfect but it will require a lot of time investigating it just for the comment whereas the feature is still not completed, so if it's acceptable, I'd prefer to leave this code with the comment referencing the replace, but not investigate more at the moment as its too expensive for the sake of having a more detailed comment.",
      "comment_id": 1098868959,
      "user": "Nusnus",
      "created_at": "2023-02-07T16:05:40Z",
      "url": "https://github.com/celery/celery/pull/8045#discussion_r1098868959"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8034,
      "file_path": "celery/app/task.py",
      "line": 975,
      "side": "RIGHT",
      "diff_hunk": "@@ -959,13 +959,34 @@ def replace(self, sig):\n             stamped_headers = self.request.stamped_headers.copy()\n             stamps = self.request.stamps.copy()\n             stamped_headers.extend(sig.options.get('stamped_headers', []))\n+            stamped_headers = list(set(stamped_headers))\n             stamps.update({\n                 stamp: value\n                 for stamp, value in sig.options.items() if stamp in sig.options.get('stamped_headers', [])\n             })\n             sig.options['stamped_headers'] = stamped_headers\n             sig.options.update(stamps)\n \n+            links = sig.options['link'] if 'link' in sig.options else []\n+            links.extend(sig.options['link_error'] if 'link_error' in sig.options else [])\n+\n+            if hasattr(sig, \"tasks\"):\n+                tasks = sig.tasks\n+                if isinstance(tasks, group):",
      "comment": "Your new test cases should cover this. Let's see if the PR tests pass with the new edge cases.",
      "comment_id": 1090859492,
      "user": "Nusnus",
      "created_at": "2023-01-30T16:27:49Z",
      "url": "https://github.com/celery/celery/pull/8034#discussion_r1090859492"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8034,
      "file_path": "celery/app/task.py",
      "line": 975,
      "side": "RIGHT",
      "diff_hunk": "@@ -959,13 +959,34 @@ def replace(self, sig):\n             stamped_headers = self.request.stamped_headers.copy()\n             stamps = self.request.stamps.copy()\n             stamped_headers.extend(sig.options.get('stamped_headers', []))\n+            stamped_headers = list(set(stamped_headers))\n             stamps.update({\n                 stamp: value\n                 for stamp, value in sig.options.items() if stamp in sig.options.get('stamped_headers', [])\n             })\n             sig.options['stamped_headers'] = stamped_headers\n             sig.options.update(stamps)\n \n+            links = sig.options['link'] if 'link' in sig.options else []\n+            links.extend(sig.options['link_error'] if 'link_error' in sig.options else [])\n+\n+            if hasattr(sig, \"tasks\"):\n+                tasks = sig.tasks\n+                if isinstance(tasks, group):",
      "comment": "But it should also work as the canvas primitive already handles the `tuple` and `regen` cases itself (before we get here), but the added matrix for the test will cover this 100%",
      "comment_id": 1090860288,
      "user": "Nusnus",
      "created_at": "2023-01-30T16:28:28Z",
      "url": "https://github.com/celery/celery/pull/8034#discussion_r1090860288"
    },
    {
      "repo": "celery/celery",
      "pr_number": 8034,
      "file_path": "celery/app/task.py",
      "line": 975,
      "side": "RIGHT",
      "diff_hunk": "@@ -959,13 +959,34 @@ def replace(self, sig):\n             stamped_headers = self.request.stamped_headers.copy()\n             stamps = self.request.stamps.copy()\n             stamped_headers.extend(sig.options.get('stamped_headers', []))\n+            stamped_headers = list(set(stamped_headers))\n             stamps.update({\n                 stamp: value\n                 for stamp, value in sig.options.items() if stamp in sig.options.get('stamped_headers', [])\n             })\n             sig.options['stamped_headers'] = stamped_headers\n             sig.options.update(stamps)\n \n+            links = sig.options['link'] if 'link' in sig.options else []\n+            links.extend(sig.options['link_error'] if 'link_error' in sig.options else [])\n+\n+            if hasattr(sig, \"tasks\"):\n+                tasks = sig.tasks\n+                if isinstance(tasks, group):",
      "comment": "@thedrow Yes, the new test cases are passing with this code which confirms your original question is resolved.\r\n> What happens if tasks is a list or a tuple?\r\n\r\nIt works.\r\n\r\n> What happens if it is a regen?\r\n\r\nIt works.\r\n\r\n> We shouldn't ignore such cases.\r\n\r\nWe do not :) ",
      "comment_id": 1091812624,
      "user": "Nusnus",
      "created_at": "2023-01-31T11:44:20Z",
      "url": "https://github.com/celery/celery/pull/8034#discussion_r1091812624"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7942,
      "file_path": "t/unit/tasks/test_canvas.py",
      "line": 2451,
      "side": "RIGHT",
      "diff_hunk": "@@ -2386,3 +2395,63 @@ def test_is_dict(self):\n     def test_when_sig(self):\n         s = self.add.s()\n         assert maybe_signature(s, app=self.app) is s\n+\n+\n+class test_merge_dictionaries(CanvasCase):\n+\n+    def test_docstring_example(self):\n+        d1 = {'dict': {'a': 1}, 'list': [1, 2], 'tuple': (1, 2)}\n+        d2 = {'dict': {'b': 2}, 'list': [3, 4], 'set': {'a', 'b'}}\n+        _merge_dictionaries(d1, d2)\n+        assert d1 == {\n+            'dict': {'a': 1, 'b': 2},\n+            'list': [1, 2, 3, 4],\n+            'tuple': (1, 2),\n+            'set': {'a', 'b'}\n+        }\n+\n+    @pytest.mark.parametrize('d1,d2,expected_result', [",
      "comment": "@thedrow @auvipy can you guys please review this specifically?\r\nThere are lots of \"None\" symbols there so >2 eyes reviewing it would be awesome.\r\nThanks \ud83d\ude4f ",
      "comment_id": 1039712073,
      "user": "Nusnus",
      "created_at": "2022-12-05T15:03:02Z",
      "url": "https://github.com/celery/celery/pull/7942#discussion_r1039712073"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7942,
      "file_path": "celery/canvas.py",
      "line": 2251,
      "side": "RIGHT",
      "diff_hunk": "@@ -2248,13 +2247,14 @@ def link_error(self, errback):\n             applied to the body.\n         \"\"\"\n         if self.app.conf.task_allow_error_cb_on_chord_header:\n-            # self.tasks can be a list of the chord header workflow.\n-            if isinstance(self.tasks, (list, tuple)):\n-                for task in self.tasks:\n-                    task.link_error(errback)\n-            else:\n-                self.tasks.link_error(errback)\n+            for task in self.tasks:\n+                task.link_error(errback)",
      "comment": "There's no problem with that, `self.tasks` is accessed correctly with both examples.\r\nTo prove it, I've added the PR a test case with your both examples: `test_link_error_on_chord_header()`\r\nCheck it out to confirm and resolve conversation if you're satisfied @thedrow ",
      "comment_id": 1043443321,
      "user": "Nusnus",
      "created_at": "2022-12-08T14:52:28Z",
      "url": "https://github.com/celery/celery/pull/7942#discussion_r1043443321"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7919,
      "file_path": "celery/canvas.py",
      "line": 920,
      "side": "RIGHT",
      "diff_hunk": "@@ -916,6 +916,10 @@ def __or__(self, other):\n             if not tasks:\n                 # If the chain is empty, return the group\n                 return other\n+            if isinstance(tasks[-1], chord):\n+                # CHAIN [last item is chord] | GROUP -> chain with chord body.",
      "comment": "please chec if you can add some additional unit tests for this part",
      "comment_id": 1031057653,
      "user": "auvipy",
      "created_at": "2022-11-24T04:58:43Z",
      "url": "https://github.com/celery/celery/pull/7919#discussion_r1031057653"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7919,
      "file_path": "celery/canvas.py",
      "line": 920,
      "side": "RIGHT",
      "diff_hunk": "@@ -916,6 +916,10 @@ def __or__(self, other):\n             if not tasks:\n                 # If the chain is empty, return the group\n                 return other\n+            if isinstance(tasks[-1], chord):\n+                # CHAIN [last item is chord] | GROUP -> chain with chord body.",
      "comment": "Done, added 4 new unit tests for all of the changes of this PR",
      "comment_id": 1032913329,
      "user": "Nusnus",
      "created_at": "2022-11-27T11:26:22Z",
      "url": "https://github.com/celery/celery/pull/7919#discussion_r1032913329"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7919,
      "file_path": "t/integration/test_canvas.py",
      "line": 863,
      "side": "RIGHT",
      "diff_hunk": "@@ -859,6 +859,154 @@ def before_task_publish_handler(sender=None, body=None, exchange=None, routing_k\n         redis_connection = get_redis_connection()\n         redis_connection.delete(redis_key)\n \n+    def test_chaining_upgraded_chords_pure_groups(self, manager, subtests):\n+        \"\"\" This test is built to reproduce the github issue https://github.com/celery/celery/issues/5958",
      "comment": "Thanks!\r\nThese tests cover:\r\n1. Fix in chord.__or__.\r\n2. Fix in chain.__or__.\r\n3. Make sure the workaround from the last 2 years is not broken from this change.",
      "comment_id": 1032913525,
      "user": "Nusnus",
      "created_at": "2022-11-27T11:27:26Z",
      "url": "https://github.com/celery/celery/pull/7919#discussion_r1032913525"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7916,
      "file_path": "celery/app/base.py",
      "line": 781,
      "side": "RIGHT",
      "diff_hunk": "@@ -778,6 +778,10 @@ def send_task(self, name, args=None, kwargs=None, countdown=None,\n             **options\n         )\n \n+        stamped_headers = options.pop('stamped_headers', [])",
      "comment": "do we need additional unit tests for this part? or they are already covered? the Integration tests are good",
      "comment_id": 1028802860,
      "user": "auvipy",
      "created_at": "2022-11-22T03:54:41Z",
      "url": "https://github.com/celery/celery/pull/7916#discussion_r1028802860"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7916,
      "file_path": "celery/app/base.py",
      "line": 781,
      "side": "RIGHT",
      "diff_hunk": "@@ -778,6 +778,10 @@ def send_task(self, name, args=None, kwargs=None, countdown=None,\n             **options\n         )\n \n+        stamped_headers = options.pop('stamped_headers', [])",
      "comment": "The codecov marks these lines as covered, although I didn't add anything specific (makes sense though). I think the current tests for this PR should be enough, but I'll keep it in mind.",
      "comment_id": 1029001741,
      "user": "Nusnus",
      "created_at": "2022-11-22T08:21:32Z",
      "url": "https://github.com/celery/celery/pull/7916#discussion_r1029001741"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7897,
      "file_path": "celery/canvas.py",
      "line": 1076,
      "side": "RIGHT",
      "diff_hunk": "@@ -1046,6 +1062,38 @@ def prepare_steps(self, args, kwargs, tasks,\n                       last_task_id=None, group_id=None, chord_body=None,\n                       clone=True, from_dict=Signature.from_dict,\n                       group_index=None):\n+        \"\"\"Prepare the chain for execution.\n+\n+        To execute a chain, we first need to unpack it correctly.\n+        During the unpacking, we might encounter other chains, groups, or chords,\n+        which we need to unpack as well.\n+\n+        For example:\n+        chain(signature1, chain(signature2, signature3)) --> Upgrades to chain(signature1, signature2, signature3)\n+        chain(group(signature1, signature2), signature3) --> Upgrades to chord([signature1, signature2], signature3)\n+\n+        The responsibility of this method is to assure that the chain is\n+        correctly unpacked, and that the correct callbacks are set up along the way.",
      "comment": "```suggestion\r\n        correctly unpacked, and then the correct callbacks are set up along the way.\r\n```",
      "comment_id": 1019135225,
      "user": "auvipy",
      "created_at": "2022-11-10T13:39:42Z",
      "url": "https://github.com/celery/celery/pull/7897#discussion_r1019135225"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7897,
      "file_path": "celery/canvas.py",
      "line": 1068,
      "side": "RIGHT",
      "diff_hunk": "@@ -1046,6 +1062,38 @@ def prepare_steps(self, args, kwargs, tasks,\n                       last_task_id=None, group_id=None, chord_body=None,\n                       clone=True, from_dict=Signature.from_dict,\n                       group_index=None):\n+        \"\"\"Prepare the chain for execution.\n+\n+        To execute a chain, we first need to unpack it correctly.\n+        During the unpacking, we might encounter other chains, groups, or chords,",
      "comment": "```suggestion\r\n        During the unpacking, we might encounter other chains, groups, or chords\r\n```",
      "comment_id": 1019135499,
      "user": "auvipy",
      "created_at": "2022-11-10T13:39:53Z",
      "url": "https://github.com/celery/celery/pull/7897#discussion_r1019135499"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7897,
      "file_path": "celery/canvas.py",
      "line": 1075,
      "side": "RIGHT",
      "diff_hunk": "@@ -1046,6 +1062,38 @@ def prepare_steps(self, args, kwargs, tasks,\n                       last_task_id=None, group_id=None, chord_body=None,\n                       clone=True, from_dict=Signature.from_dict,\n                       group_index=None):\n+        \"\"\"Prepare the chain for execution.\n+\n+        To execute a chain, we first need to unpack it correctly.\n+        During the unpacking, we might encounter other chains, groups, or chords,\n+        which we need to unpack as well.\n+\n+        For example:\n+        chain(signature1, chain(signature2, signature3)) --> Upgrades to chain(signature1, signature2, signature3)\n+        chain(group(signature1, signature2), signature3) --> Upgrades to chord([signature1, signature2], signature3)\n+\n+        The responsibility of this method is to assure that the chain is",
      "comment": "```suggestion\r\n        The responsibility of this method is to ensure that the chain is\r\n```",
      "comment_id": 1019136591,
      "user": "auvipy",
      "created_at": "2022-11-10T13:40:38Z",
      "url": "https://github.com/celery/celery/pull/7897#discussion_r1019136591"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7876,
      "file_path": "t/unit/backends/test_cache.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -143,7 +143,7 @@ def test_as_uri_multiple_servers(self):\n         assert b.as_uri() == backend\n \n     def test_regression_worker_startup_info(self):\n-        pytest.importorskip('memcached')\n+        pytest.importorskip('memcache')",
      "comment": "```suggestion\r\n        pytest.importorskip('memcached')\r\n```",
      "comment_id": 1012471846,
      "user": "auvipy",
      "created_at": "2022-11-03T03:46:59Z",
      "url": "https://github.com/celery/celery/pull/7876#discussion_r1012471846"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7876,
      "file_path": "t/unit/backends/test_cache.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -143,7 +143,7 @@ def test_as_uri_multiple_servers(self):\n         assert b.as_uri() == backend\n \n     def test_regression_worker_startup_info(self):\n-        pytest.importorskip('memcached')\n+        pytest.importorskip('memcache')",
      "comment": "no, the to-be-imported python module is named \"memcache\", see my comment below",
      "comment_id": 1016964583,
      "user": "hsk17",
      "created_at": "2022-11-08T18:08:43Z",
      "url": "https://github.com/celery/celery/pull/7876#discussion_r1016964583"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7879,
      "file_path": "celery/contrib/sphinx.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,7 +30,7 @@\n \n Use ``.. autotask::`` to alternatively manually document a task.\n \"\"\"\n-from inspect import formatargspec, getfullargspec\n+from inspect import signature",
      "comment": "https://docs.python.org/3/library/inspect.html#introspecting-callables-with-the-signature-object",
      "comment_id": 1016358977,
      "user": "auvipy",
      "created_at": "2022-11-08T09:36:33Z",
      "url": "https://github.com/celery/celery/pull/7879#discussion_r1016358977"
    },
    {
      "repo": "celery/celery",
      "pr_number": 4240,
      "file_path": "celery/canvas.py",
      "line": 400,
      "side": "RIGHT",
      "diff_hunk": "@@ -395,23 +395,41 @@ def __or__(self, other):\n             other = maybe_unroll_group(other)\n             if isinstance(self, _chain):\n                 # chain | group() -> chain\n-                sig = self.clone()\n-                sig.tasks.append(other)\n-                return sig\n+                return _chain(\n+                    seq_concat_item([\n+                        reduce(",
      "comment": "Can you please explain the logic here? I cannot figure out the use of `reduce`. It seems that the concept is to have the next task signature become the error callback?",
      "comment_id": 138412963,
      "user": "georgepsarakis",
      "created_at": "2017-09-12T17:19:04Z",
      "url": "https://github.com/celery/celery/pull/4240#discussion_r138412963"
    },
    {
      "repo": "celery/celery",
      "pr_number": 4240,
      "file_path": "celery/canvas.py",
      "line": 400,
      "side": "RIGHT",
      "diff_hunk": "@@ -395,23 +395,41 @@ def __or__(self, other):\n             other = maybe_unroll_group(other)\n             if isinstance(self, _chain):\n                 # chain | group() -> chain\n-                sig = self.clone()\n-                sig.tasks.append(other)\n-                return sig\n+                return _chain(\n+                    seq_concat_item([\n+                        reduce(",
      "comment": "With `reduce` I'm assigning tasks from `link_error` of current chain to individual tasks with respect to their order.\r\nThis code equals to:\r\n\r\n    new_tasks = []\r\n    for task in self.tasks:\r\n      new_task = task.clone()\r\n      new_tasks.append(new_task)\r\n      for error_handler in self._with_list_option('link_error'):\r\n        new_task.on_error(error_handler)\r\n    return _chain(seq_concat_item(new_tasks, other), app=self._app)`",
      "comment_id": 138437103,
      "user": "atn18",
      "created_at": "2017-09-12T18:58:48Z",
      "url": "https://github.com/celery/celery/pull/4240#discussion_r138437103"
    },
    {
      "repo": "celery/celery",
      "pr_number": 4240,
      "file_path": "celery/canvas.py",
      "line": 400,
      "side": "RIGHT",
      "diff_hunk": "@@ -395,23 +395,41 @@ def __or__(self, other):\n             other = maybe_unroll_group(other)\n             if isinstance(self, _chain):\n                 # chain | group() -> chain\n-                sig = self.clone()\n-                sig.tasks.append(other)\n-                return sig\n+                return _chain(\n+                    seq_concat_item([\n+                        reduce(",
      "comment": "I would go with this version since it is far more readable. Also, I think that using `_with_list_option` is not required.\r\n\r\n```\r\ntasks = [task.clone() for task in self.tasks]\r\nerror_handler = self.options.get('link_error')\r\nif error_handler is not None:   \r\n    for task in tasks:\r\n        task.on_error(error_handler)\r\n```\r\n\r\nWhat do you think?",
      "comment_id": 138696570,
      "user": "georgepsarakis",
      "created_at": "2017-09-13T18:08:53Z",
      "url": "https://github.com/celery/celery/pull/4240#discussion_r138696570"
    },
    {
      "repo": "celery/celery",
      "pr_number": 4240,
      "file_path": "celery/canvas.py",
      "line": 400,
      "side": "RIGHT",
      "diff_hunk": "@@ -395,23 +395,41 @@ def __or__(self, other):\n             other = maybe_unroll_group(other)\n             if isinstance(self, _chain):\n                 # chain | group() -> chain\n-                sig = self.clone()\n-                sig.tasks.append(other)\n-                return sig\n+                return _chain(\n+                    seq_concat_item([\n+                        reduce(",
      "comment": "OK, I'll update my branch.\r\nI've used `_with_list_option` because `link_error` is a list of tasks and there are some logic on setting it in case of `MutableSequence`.\r\nBut here we just reading it, so I can use `.options.get('link_error', [])`",
      "comment_id": 138715053,
      "user": "atn18",
      "created_at": "2017-09-13T19:22:41Z",
      "url": "https://github.com/celery/celery/pull/4240#discussion_r138715053"
    },
    {
      "repo": "celery/celery",
      "pr_number": 4240,
      "file_path": "celery/canvas.py",
      "line": 399,
      "side": "RIGHT",
      "diff_hunk": "@@ -395,23 +395,37 @@ def __or__(self, other):\n             other = maybe_unroll_group(other)\n             if isinstance(self, _chain):\n                 # chain | group() -> chain\n-                sig = self.clone()\n-                sig.tasks.append(other)\n-                return sig\n+                tasks = [t.clone() for t in self.tasks]\n+                link_error = self.options.get('link_error', [])",
      "comment": "Glad you agreed with the suggestions :smile: ! One question here, is `link_error` a list of functions? ",
      "comment_id": 138798420,
      "user": "georgepsarakis",
      "created_at": "2017-09-14T05:11:50Z",
      "url": "https://github.com/celery/celery/pull/4240#discussion_r138798420"
    },
    {
      "repo": "celery/celery",
      "pr_number": 4240,
      "file_path": "celery/canvas.py",
      "line": 399,
      "side": "RIGHT",
      "diff_hunk": "@@ -395,23 +395,37 @@ def __or__(self, other):\n             other = maybe_unroll_group(other)\n             if isinstance(self, _chain):\n                 # chain | group() -> chain\n-                sig = self.clone()\n-                sig.tasks.append(other)\n-                return sig\n+                tasks = [t.clone() for t in self.tasks]\n+                link_error = self.options.get('link_error', [])",
      "comment": "Yes, `link_error` is list of signatures.\r\nI've wrote it on your code suggestion ;)",
      "comment_id": 138799247,
      "user": "atn18",
      "created_at": "2017-09-14T05:21:33Z",
      "url": "https://github.com/celery/celery/pull/4240#discussion_r138799247"
    },
    {
      "repo": "celery/celery",
      "pr_number": 4240,
      "file_path": "celery/canvas.py",
      "line": 423,
      "side": "RIGHT",
      "diff_hunk": "@@ -395,23 +395,37 @@ def __or__(self, other):\n             other = maybe_unroll_group(other)\n             if isinstance(self, _chain):\n                 # chain | group() -> chain\n-                sig = self.clone()\n-                sig.tasks.append(other)\n-                return sig\n+                tasks = [t.clone() for t in self.tasks]\n+                link_error = self.options.get('link_error', [])\n+                for sig in link_error:\n+                    for task in tasks:\n+                        task.on_error(sig)\n+                return _chain(seq_concat_item(tasks, other), app=self._app)\n             # task | group() -> chain\n             return _chain(self, other, app=self.app)\n \n         if not isinstance(self, _chain) and isinstance(other, _chain):\n             # task | chain -> chain\n-            return _chain(\n-                seq_concat_seq((self,), other.tasks), app=self._app)\n+            tasks = [t.clone() for t in other.tasks]\n+            link_error = other.options.get('link_error', [])\n+            for sig in link_error:\n+                for task in tasks:\n+                    task.on_error(sig)\n+            return _chain(seq_concat_seq((self,), tasks), app=self._app)\n         elif isinstance(other, _chain):\n             # chain | chain -> chain\n-            sig = self.clone()\n-            if isinstance(sig.tasks, tuple):\n-                sig.tasks = list(sig.tasks)\n-            sig.tasks.extend(other.tasks)\n-            return sig\n+            # assign chain's link_error sugnatures to each chain's task\n+            tasks = [t.clone() for t in self.tasks]\n+            link_error = self.options.get('link_error', [])\n+            for sig in link_error:\n+                for task in tasks:\n+                    task.on_error(sig)\n+            other_tasks = [t.clone() for t in other.tasks]",
      "comment": "Seems this is a repeated pattern, the more DRY approach would be to use a function for these 5 occurrences.",
      "comment_id": 139233910,
      "user": "georgepsarakis",
      "created_at": "2017-09-15T19:41:08Z",
      "url": "https://github.com/celery/celery/pull/4240#discussion_r139233910"
    },
    {
      "repo": "celery/celery",
      "pr_number": 4240,
      "file_path": "celery/canvas.py",
      "line": 423,
      "side": "RIGHT",
      "diff_hunk": "@@ -395,23 +395,37 @@ def __or__(self, other):\n             other = maybe_unroll_group(other)\n             if isinstance(self, _chain):\n                 # chain | group() -> chain\n-                sig = self.clone()\n-                sig.tasks.append(other)\n-                return sig\n+                tasks = [t.clone() for t in self.tasks]\n+                link_error = self.options.get('link_error', [])\n+                for sig in link_error:\n+                    for task in tasks:\n+                        task.on_error(sig)\n+                return _chain(seq_concat_item(tasks, other), app=self._app)\n             # task | group() -> chain\n             return _chain(self, other, app=self.app)\n \n         if not isinstance(self, _chain) and isinstance(other, _chain):\n             # task | chain -> chain\n-            return _chain(\n-                seq_concat_seq((self,), other.tasks), app=self._app)\n+            tasks = [t.clone() for t in other.tasks]\n+            link_error = other.options.get('link_error', [])\n+            for sig in link_error:\n+                for task in tasks:\n+                    task.on_error(sig)\n+            return _chain(seq_concat_seq((self,), tasks), app=self._app)\n         elif isinstance(other, _chain):\n             # chain | chain -> chain\n-            sig = self.clone()\n-            if isinstance(sig.tasks, tuple):\n-                sig.tasks = list(sig.tasks)\n-            sig.tasks.extend(other.tasks)\n-            return sig\n+            # assign chain's link_error sugnatures to each chain's task\n+            tasks = [t.clone() for t in self.tasks]\n+            link_error = self.options.get('link_error', [])\n+            for sig in link_error:\n+                for task in tasks:\n+                    task.on_error(sig)\n+            other_tasks = [t.clone() for t in other.tasks]",
      "comment": "I've though about it when applying your suggestion :)\r\nWait for one more commit.\r\n",
      "comment_id": 139240270,
      "user": "atn18",
      "created_at": "2017-09-15T20:15:03Z",
      "url": "https://github.com/celery/celery/pull/4240#discussion_r139240270"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7867,
      "file_path": "t/unit/tasks/test_canvas.py",
      "line": 639,
      "side": "RIGHT",
      "diff_hunk": "@@ -636,10 +636,12 @@ def s(*args, **kwargs):\n         assert c.tasks[-1].options['chord'] == 'some_chord_id'\n \n         c.apply_async(link=[s(32)])\n+        c.tasks[-1].options['link'][0].options.clear()  # remove stamped headers from link",
      "comment": "Remains of a debug session. I will push now a final version of the modifications for this test so you can review it again, sorry.",
      "comment_id": 1011894839,
      "user": "Nusnus",
      "created_at": "2022-11-02T15:00:45Z",
      "url": "https://github.com/celery/celery/pull/7867#discussion_r1011894839"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7867,
      "file_path": "celery/canvas.py",
      "line": 550,
      "side": "RIGHT",
      "diff_hunk": "@@ -502,18 +525,50 @@ def stamp(self, visitor=None, **headers):\n         headers = headers.copy()\n         if visitor is not None:\n             visitor_headers = visitor.on_signature(self, **headers)\n-            if \"stamped_headers\" not in visitor_headers:\n+            if visitor_headers and \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            headers.update(visitor_headers)\n+            _merge_dictionaries(headers, visitor_headers or {})\n         else:\n             headers[\"stamped_headers\"] = [header for header in headers.keys() if header not in self.options]\n             _merge_dictionaries(headers, self.options)\n \n+        # Preserve previous stamped headers\n         stamped_headers = set(self.options.get(\"stamped_headers\", []))\n         stamped_headers.update(headers[\"stamped_headers\"])\n         headers[\"stamped_headers\"] = list(stamped_headers)\n         return self.set(**headers)\n \n+    def stamp_links(self, visitor, **headers):\n+        \"\"\"Stamp this signature links (callbacks and errbacks).\n+        Using a visitor will pass on responsibility for the stamping\n+        to the visitor.\n+\n+        Arguments:\n+            visitor (StampingVisitor): Visitor API object.\n+            headers (Dict): Stamps that should be added to headers.\n+        \"\"\"\n+        additional_headers = headers.copy()",
      "comment": "The name `headers` will be used like before this PR.\r\nThe name `additional_headers` which is a copy of `headers` was renamed to `non_visitor_headers`.\r\nThe name `visitor_headers` is used to describe the headers that came just from the visitor.\r\nSo now the names should make sense @thedrow ",
      "comment_id": 1011908102,
      "user": "Nusnus",
      "created_at": "2022-11-02T15:07:54Z",
      "url": "https://github.com/celery/celery/pull/7867#discussion_r1011908102"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7867,
      "file_path": "celery/canvas.py",
      "line": 531,
      "side": "RIGHT",
      "diff_hunk": "@@ -502,18 +525,48 @@ def stamp(self, visitor=None, **headers):\n         headers = headers.copy()\n         if visitor is not None:\n             visitor_headers = visitor.on_signature(self, **headers)\n-            if \"stamped_headers\" not in visitor_headers:\n+            if visitor_headers and \"stamped_headers\" not in visitor_headers:\n                 visitor_headers[\"stamped_headers\"] = list(visitor_headers.keys())\n-            headers.update(visitor_headers)\n+            _merge_dictionaries(headers, visitor_headers or {})",
      "comment": "You are right. This is a result of a copy&paste I forgot to clean up.\r\nFix will be pushed in a few minutes.",
      "comment_id": 1011958530,
      "user": "Nusnus",
      "created_at": "2022-11-02T15:37:30Z",
      "url": "https://github.com/celery/celery/pull/7867#discussion_r1011958530"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7856,
      "file_path": "celery/canvas.py",
      "line": 505,
      "side": "RIGHT",
      "diff_hunk": "@@ -501,7 +501,10 @@ def stamp(self, visitor=None, **headers):\n         \"\"\"\n         headers = headers.copy()\n         if visitor is not None:\n-            headers.update(visitor.on_signature(self, **headers))\n+            visitor_headers = visitor.on_signature(self, **headers)\n+            if \"stamped_headers\" not in visitor_headers:",
      "comment": "Feel free to merge if it passes your code review @auvipy ",
      "comment_id": 1008843342,
      "user": "Nusnus",
      "created_at": "2022-10-30T12:10:30Z",
      "url": "https://github.com/celery/celery/pull/7856#discussion_r1008843342"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7785,
      "file_path": "celery/bin/celery.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -75,7 +76,16 @@ def convert(self, value, param, ctx):\n APP = App()\n \n \n-@with_plugins(entry_points().get('celery.commands', []))\n+if sys.version_info >= (3, 10):\n+    _PLUGINS = entry_points(group='celery.commands')\n+else:\n+    try:\n+        _PLUGINS = entry_points().get('celery.commands', [])\n+    except AttributeError:\n+        _PLUGINS = entry_points().select(group='celery.commands')",
      "comment": "This will fail on `importlib_metadata<3.6`, so I suggest bumping to `importlib_metadata>=3.6` or use [backports.entry_points_selectable](https://pypi.org/project/backports.entry_points_selectable).",
      "comment_id": 987112083,
      "user": "jaraco",
      "created_at": "2022-10-04T16:40:07Z",
      "url": "https://github.com/celery/celery/pull/7785#discussion_r987112083"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7808,
      "file_path": "celery/concurrency/thread.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,45 +1,67 @@\n \"\"\"Thread execution pool.\"\"\"\n+from __future__ import annotations\n \n-from concurrent.futures import ThreadPoolExecutor, wait\n+from concurrent.futures import Future, ThreadPoolExecutor, wait\n+from typing import TYPE_CHECKING, Any, Callable\n \n from .base import BasePool, apply_target\n \n __all__ = ('TaskPool',)\n \n+if TYPE_CHECKING:\n+    import sys\n+\n+    if sys.version_info >= (3, 8):\n+        from typing import TypedDict\n+    else:\n+        from typing_extensions import TypedDict\n+\n+    PoolInfo = TypedDict('PoolInfo', {'max-concurrency': int, 'threads': int})\n+\n+    # `TargetFunction` should be a Protocol that represents fast_trace_task and\n+    # trace_task_ret.\n+    TargetFunction = Callable[..., Any]\n+\n \n class ApplyResult:\n-    def __init__(self, future):\n+    def __init__(self, future: Future) -> None:\n         self.f = future\n         self.get = self.f.result\n \n-    def wait(self, timeout=None):\n+    def wait(self, timeout: float | None = None) -> None:\n         wait([self.f], timeout)\n \n \n class TaskPool(BasePool):\n     \"\"\"Thread Task Pool.\"\"\"\n+    limit: int\n \n     body_can_be_buffer = True\n     signal_safe = False\n \n-    def __init__(self, *args, **kwargs):\n+    def __init__(self, *args: Any, **kwargs: Any) -> None:\n         super().__init__(*args, **kwargs)\n         self.executor = ThreadPoolExecutor(max_workers=self.limit)\n \n-    def on_stop(self):\n+    def on_stop(self) -> None:\n         self.executor.shutdown()\n         super().on_stop()\n \n-    def on_apply(self, target, args=None, kwargs=None, callback=None,\n-                 accept_callback=None, **_):\n+    def on_apply(\n+        self,\n+        target: TargetFunction,\n+        args: tuple | None = None,",
      "comment": "```suggestion\r\n        args: tuple[Any, ...] | None = None,\r\n```",
      "comment_id": 996333747,
      "user": "Kludex",
      "created_at": "2022-10-15T17:30:55Z",
      "url": "https://github.com/celery/celery/pull/7808#discussion_r996333747"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7808,
      "file_path": "celery/concurrency/thread.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,45 +1,67 @@\n \"\"\"Thread execution pool.\"\"\"\n+from __future__ import annotations\n \n-from concurrent.futures import ThreadPoolExecutor, wait\n+from concurrent.futures import Future, ThreadPoolExecutor, wait\n+from typing import TYPE_CHECKING, Any, Callable\n \n from .base import BasePool, apply_target\n \n __all__ = ('TaskPool',)\n \n+if TYPE_CHECKING:",
      "comment": "Everything inside this block should have been ignored by codecov, according to https://github.com/celery/celery/blob/651095e3602756237920f4fa7ac170e1322c1939/pyproject.toml#L25\r\n\r\nWhy isn't?",
      "comment_id": 996411963,
      "user": "Kludex",
      "created_at": "2022-10-16T08:55:06Z",
      "url": "https://github.com/celery/celery/pull/7808#discussion_r996411963"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7808,
      "file_path": "celery/concurrency/thread.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,45 +1,67 @@\n \"\"\"Thread execution pool.\"\"\"\n+from __future__ import annotations\n \n-from concurrent.futures import ThreadPoolExecutor, wait\n+from concurrent.futures import Future, ThreadPoolExecutor, wait\n+from typing import TYPE_CHECKING, Any, Callable\n \n from .base import BasePool, apply_target\n \n __all__ = ('TaskPool',)\n \n+if TYPE_CHECKING:",
      "comment": "the config is of pre mypy era of celery, so we can adjust that",
      "comment_id": 996412903,
      "user": "auvipy",
      "created_at": "2022-10-16T09:03:20Z",
      "url": "https://github.com/celery/celery/pull/7808#discussion_r996412903"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7808,
      "file_path": "celery/concurrency/thread.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,45 +1,67 @@\n \"\"\"Thread execution pool.\"\"\"\n+from __future__ import annotations\n \n-from concurrent.futures import ThreadPoolExecutor, wait\n+from concurrent.futures import Future, ThreadPoolExecutor, wait\n+from typing import TYPE_CHECKING, Any, Callable\n \n from .base import BasePool, apply_target\n \n __all__ = ('TaskPool',)\n \n+if TYPE_CHECKING:",
      "comment": "I don't know what needs to be adjusted on codecov. :eyes: ",
      "comment_id": 996413786,
      "user": "Kludex",
      "created_at": "2022-10-16T09:10:35Z",
      "url": "https://github.com/celery/celery/pull/7808#discussion_r996413786"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7808,
      "file_path": "celery/concurrency/thread.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,45 +1,67 @@\n \"\"\"Thread execution pool.\"\"\"\n+from __future__ import annotations\n \n-from concurrent.futures import ThreadPoolExecutor, wait\n+from concurrent.futures import Future, ThreadPoolExecutor, wait\n+from typing import TYPE_CHECKING, Any, Callable\n \n from .base import BasePool, apply_target\n \n __all__ = ('TaskPool',)\n \n+if TYPE_CHECKING:",
      "comment": "Do you want me to open a PR removing it, and calculate the coverage exclusively with `coverage`?",
      "comment_id": 996478407,
      "user": "Kludex",
      "created_at": "2022-10-16T18:40:18Z",
      "url": "https://github.com/celery/celery/pull/7808#discussion_r996478407"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7808,
      "file_path": "celery/concurrency/thread.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,45 +1,67 @@\n \"\"\"Thread execution pool.\"\"\"\n+from __future__ import annotations\n \n-from concurrent.futures import ThreadPoolExecutor, wait\n+from concurrent.futures import Future, ThreadPoolExecutor, wait\n+from typing import TYPE_CHECKING, Any, Callable\n \n from .base import BasePool, apply_target\n \n __all__ = ('TaskPool',)\n \n+if TYPE_CHECKING:",
      "comment": "I saw some projects moved to that, you can come with that",
      "comment_id": 996609949,
      "user": "auvipy",
      "created_at": "2022-10-17T04:49:49Z",
      "url": "https://github.com/celery/celery/pull/7808#discussion_r996609949"
    },
    {
      "repo": "celery/celery",
      "pr_number": 5759,
      "file_path": "celery/canvas.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,6 +193,8 @@ def apply(self, args=None, kwargs=None, **options):\n         \"\"\"\n         args = args if args else ()\n         kwargs = kwargs if kwargs else {}\n+        # Extra options set to None are dismissed\n+        options = {k: v for k, v in options.items() if v is not None}",
      "comment": "yep, you want apply an apply_async to have the same behavior ?",
      "comment_id": 331005962,
      "user": "ptitpoulpe",
      "created_at": "2019-10-03T12:14:38Z",
      "url": "https://github.com/celery/celery/pull/5759#discussion_r331005962"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7609,
      "file_path": "celery/worker/state.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,18 +32,18 @@\n }\n \n #: maximum number of revokes to keep in memory.\n-REVOKES_MAX = 50000\n+REVOKES_MAX = int(os.environ.get('CELERY_WORKER_REVOKES_MAX', 50000))",
      "comment": "btw, as per deprecation timeline, shoudn't we use lower case settings now?",
      "comment_id": 915440953,
      "user": "auvipy",
      "created_at": "2022-07-07T04:09:15Z",
      "url": "https://github.com/celery/celery/pull/7609#discussion_r915440953"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7609,
      "file_path": "t/unit/worker/test_state.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,3 +190,32 @@ def test_ready(self, requests=[SimpleReq('foo'),\n         for request in requests:\n             state.task_ready(request)\n         assert len(state.active_requests) == 0\n+\n+\n+class test_state_configuration():\n+\n+    @staticmethod\n+    def import_state():\n+        with patch.dict(sys.modules):\n+            del sys.modules['celery.worker.state']\n+            return import_module('celery.worker.state')\n+\n+    @patch.dict(os.environ, {\n+        'CELERY_WORKER_REVOKES_MAX': '50001',",
      "comment": "as per deprecation timeline, shoudn't we use lower case settings now?",
      "comment_id": 915441175,
      "user": "auvipy",
      "created_at": "2022-07-07T04:09:58Z",
      "url": "https://github.com/celery/celery/pull/7609#discussion_r915441175"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7680,
      "file_path": "t/unit/security/__init__.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -105,3 +105,33 @@\n e+zYdEdkFCd8rp568Eiwkq/553uy4rlE927/AEqs/+KGYmAtibk/9vmi+/+iZXyS\n WWZybzzDZFncq1/N1C3Y/hrCBNDFO4TsnTLAhWtZ4c0vDAiacw==\n -----END CERTIFICATE-----\"\"\"\n+\n+CERT_ECDSA = \"\"\"-----BEGIN CERTIFICATE-----\n+MIIDTTCCATWgAwIBAgIBCTANBgkqhkiG9w0BAQsFADANMQswCQYDVQQGEwJGSTAe\n+Fw0yMjA4MDQwOTA5MDlaFw0yNTA0MzAwOTA5MDlaMCMxCzAJBgNVBAYTAkZJMRQw\n+EgYDVQQDDAtUZXN0IFNlcnZlcjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABIZV\n+GFM0uPbXehT55s2yq3Zd7tCvN6GMGpE2+KSZqTtDP5c7x23QvBYF6q/T8MLNWCSB\n+TxaERpvt8XL+ksOZ8vSjbTBrMB0GA1UdDgQWBBRiY7qDBo7KAYJIn3qTMGAkPimO\n+6TAyBgNVHSMEKzApoRGkDzANMQswCQYDVQQGEwJGSYIUN/TljutVzZQ8GAMSX8yl\n+Fy9dO/8wCQYDVR0TBAIwADALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIB\n+AKADv8zZvq8TWtvEZSmf476u+sdxs1hROqqSSJ0M3ePJq2lJ+MGI60eeU/0AyDRt\n+Q5XAjr2g9wGY3sbA9uYmsIc2kaF+urrUbeoGB1JstALoxviGuM0EzEf+wK5/EbyA\n+DDMg9j7b51CBMb3FjkiUQgOjM/u5neYpFxF0awXm4khThdOKTFd0FLVX+mcaKPZ4\n+dkLcM/0NL25896DBPN982ObHOVqQjtY3sunXVuyeky8rhKmDvpasYu9xRkzSJBp7\n+sCPnY6nsCexVICbuI+Q9oNT98YjHipDHQU0U/k/MvK7K/UCY2esKAnxzcOqoMQhi\n+UjsKddXQ29GUEA9Btn9QB1sp39cR75S8/mFN2f2k/LhNm8j6QeHB4MhZ5L2H68f3\n+K2wjzQHMZUrKXf3UM00VbT8E9j0FQ7qjYa7ZnQScvhTqsak2e0um8tqcPyk4WD6l\n+/gRrLpk8l4x/Qg6F16hdj1p5xOsCUcVDkhIdKf8q3ZXjU2OECYPCFVOwiDQ2ngTf\n+Se/bcjxgYXBQ99rkEf0vxk47KqC2ZBJy5enUxqUeVbbqho46vJagMzJoAmzp7yFP\n+c1g8aazOWLD2kUxcqkUn8nv2HqApfycddz2O7OJ5Hl8e4vf+nVliuauGzImo0fiK\n+VOL9+/r5Kek0fATRWdL4xtbB7zlk+EuoP9T5ZoTYlf14\n+-----END CERTIFICATE-----\"\"\"\n+\n+KEY_ECDSA = \"\"\"-----BEGIN EC PARAMETERS-----\n+BggqhkjOPQMBBw==\n+-----END EC PARAMETERS-----\n+-----BEGIN EC PRIVATE KEY-----\n+MHcCAQEEIOj98rAhc4ToQkHby+Iegvhm3UBx+3TwpfNza+2Vn8d7oAoGCCqGSM49\n+AwEHoUQDQgAEhlUYUzS49td6FPnmzbKrdl3u0K83oYwakTb4pJmpO0M/lzvHbdC8\n+FgXqr9Pwws1YJIFPFoRGm+3xcv6Sw5ny9A==\n+-----END EC PRIVATE KEY-----\"\"\"",
      "comment": "```suggestion\r\n-----END EC PRIVATE KEY-----\"\"\"\r\n\r\n```",
      "comment_id": 937912231,
      "user": "auvipy",
      "created_at": "2022-08-04T15:10:07Z",
      "url": "https://github.com/celery/celery/pull/7680#discussion_r937912231"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7597,
      "file_path": "celery/canvas.py",
      "line": 1490,
      "side": "RIGHT",
      "diff_hunk": "@@ -1487,14 +1487,16 @@ def __length_hint__(self):\n \n     def run(self, header, body, partial_args, app=None, interval=None,\n             countdown=1, max_retries=None, eager=False,\n-            task_id=None, **options):\n+            task_id=None, partial_kwargs=None, **options):",
      "comment": "The short answer is I think it will be ok to rename it to `kwargs`. I initially called it`partial_kwargs` to keep to the same naming converting with `partial_args` as I didn't fully grasp why `partial_args` was called `partial_args` and not just `args`, but I think I understand it now. It makes sense that `partial_args` is called partial because the results from the tasks will be the last arg.\r\n\r\nIf I missed your point and the real question is why do we even need the kwargs argument, it's because this is the async equivalent of [this](https://github.com/celery/celery/blob/59263b0409e3f02dc16ca8a3bd1e42b5a3eba36d/celery/canvas.py#L1435): when we eagerly apply the chord, the `apply` gets  both the `args` and `kwargs` while the true async call does not receive the kwargs. It is needed to fix the omission in the api. \r\n\r\nAt the moment, I just pushed an updated commit that addresses the tests failing with the redis backend. If that's ok, then I'll update this PR with renaming `partial_kwargs` to `kwargs`",
      "comment_id": 909178937,
      "user": "EricAtORS",
      "created_at": "2022-06-29T04:10:04Z",
      "url": "https://github.com/celery/celery/pull/7597#discussion_r909178937"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7587,
      "file_path": "celery/app/trace.py",
      "line": 372,
      "side": "LEFT",
      "diff_hunk": "@@ -369,7 +369,7 @@ def build_tracer(name, task, loader=None, hostname=None, store_errors=True,\n     from celery import canvas\n     signature = canvas.maybe_signature  # maybe_ does not clone if already\n \n-    def on_error(request, exc, uuid, state=FAILURE, call_errbacks=True):",
      "comment": "can you please verify this removal won't create any regression?",
      "comment_id": 901687632,
      "user": "auvipy",
      "created_at": "2022-06-20T13:53:43Z",
      "url": "https://github.com/celery/celery/pull/7587#discussion_r901687632"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7587,
      "file_path": "celery/backends/filesystem.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,10 +53,9 @@ def __init__(self, url=None, open=open, unlink=os.unlink, sep=os.sep,\n         # Lets verify that we've everything setup right\n         self._do_directory_test(b'.fs-backend-' + uuid().encode(encoding))\n \n-    def __reduce__(self, args=(), kwargs={}):\n-        kwargs.update(\n-            dict(url=self.url))\n-        return super().__reduce__(args, kwargs)\n+    def __reduce__(self, args=(), kwargs=None):\n+        kwargs = {} if not kwargs else kwargs\n+        return super().__reduce__(args, dict(kwargs, url=self.url))",
      "comment": "```suggestion\r\n        return super().__reduce__(args, {kwargs, url=self.url})\r\n```",
      "comment_id": 901689610,
      "user": "auvipy",
      "created_at": "2022-06-20T13:55:36Z",
      "url": "https://github.com/celery/celery/pull/7587#discussion_r901689610"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7587,
      "file_path": "celery/backends/filesystem.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,10 +53,9 @@ def __init__(self, url=None, open=open, unlink=os.unlink, sep=os.sep,\n         # Lets verify that we've everything setup right\n         self._do_directory_test(b'.fs-backend-' + uuid().encode(encoding))\n \n-    def __reduce__(self, args=(), kwargs={}):\n-        kwargs.update(\n-            dict(url=self.url))\n-        return super().__reduce__(args, kwargs)\n+    def __reduce__(self, args=(), kwargs=None):\n+        kwargs = {} if not kwargs else kwargs\n+        return super().__reduce__(args, dict(kwargs, url=self.url))",
      "comment": "can you please check if {} notation work here instead?",
      "comment_id": 901690650,
      "user": "auvipy",
      "created_at": "2022-06-20T13:56:38Z",
      "url": "https://github.com/celery/celery/pull/7587#discussion_r901690650"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7587,
      "file_path": "celery/local.py",
      "line": 151,
      "side": "LEFT",
      "diff_hunk": "@@ -148,12 +148,6 @@ def __setitem__(self, key, value):\n     def __delitem__(self, key):\n         del self._get_current_object()[key]\n \n-    def __setslice__(self, i, j, seq):",
      "comment": "can you please verify this removals won't create any regression in the code?",
      "comment_id": 901695047,
      "user": "auvipy",
      "created_at": "2022-06-20T14:00:09Z",
      "url": "https://github.com/celery/celery/pull/7587#discussion_r901695047"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7587,
      "file_path": "celery/backends/filesystem.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,10 +53,9 @@ def __init__(self, url=None, open=open, unlink=os.unlink, sep=os.sep,\n         # Lets verify that we've everything setup right\n         self._do_directory_test(b'.fs-backend-' + uuid().encode(encoding))\n \n-    def __reduce__(self, args=(), kwargs={}):\n-        kwargs.update(\n-            dict(url=self.url))\n-        return super().__reduce__(args, kwargs)\n+    def __reduce__(self, args=(), kwargs=None):\n+        kwargs = {} if not kwargs else kwargs\n+        return super().__reduce__(args, dict(kwargs, url=self.url))",
      "comment": "```suggestion\r\n        return super().__reduce__(args, {**kwargs, 'url': self.url})\r\n```\r\n\r\nWith this change it works. Is this preferable or should I go with the first option? I usually prefer avoiding a string literal if possible.",
      "comment_id": 906714495,
      "user": "gabrielsoldani",
      "created_at": "2022-06-25T19:04:15Z",
      "url": "https://github.com/celery/celery/pull/7587#discussion_r906714495"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7587,
      "file_path": "celery/local.py",
      "line": 151,
      "side": "LEFT",
      "diff_hunk": "@@ -148,12 +148,6 @@ def __setitem__(self, key, value):\n     def __delitem__(self, key):\n         del self._get_current_object()[key]\n \n-    def __setslice__(self, i, j, seq):",
      "comment": "These were [deprecated back in the Python 2 days](https://docs.python.org/2.7/reference/datamodel.html#additional-methods-for-emulation-of-sequence-types) and were removed in Python 3, which [passes `slice` objects to the `__getitem__`, `__setitem__` and `__delitem__` methods instead](https://docs.python.org/3/reference/datamodel.html?highlight=__getitem__#object.__getitem__).\r\n\r\nI can confirm they are not being used at the moment:\r\n\r\n```\r\n>>> from celery.local import Proxy\r\n>>> a = list(range(10))\r\n>>> proxy = Proxy(lambda: a)\r\n>>> print(proxy)\r\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\r\n>>> print(proxy[2:])\r\n[2, 3, 4, 5, 6, 7, 8, 9]\r\n>>> proxy[2:] = [0]\r\n>>> print(proxy)\r\n[0, 1, 0]\r\n>>> del proxy[2:]\r\n>>> print(proxy)\r\n[0, 1]\r\n```",
      "comment_id": 906715822,
      "user": "gabrielsoldani",
      "created_at": "2022-06-25T19:21:10Z",
      "url": "https://github.com/celery/celery/pull/7587#discussion_r906715822"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7587,
      "file_path": "celery/app/trace.py",
      "line": 372,
      "side": "LEFT",
      "diff_hunk": "@@ -369,7 +369,7 @@ def build_tracer(name, task, loader=None, hostname=None, store_errors=True,\n     from celery import canvas\n     signature = canvas.maybe_signature  # maybe_ does not clone if already\n \n-    def on_error(request, exc, uuid, state=FAILURE, call_errbacks=True):",
      "comment": "Yes, static analysis showed the parameter was unused and this function is in the local scope of the `build_tracer` function, so the function signature isn't part of a public API.\r\n\r\nIt also passes the relevant integration tests.",
      "comment_id": 906719345,
      "user": "gabrielsoldani",
      "created_at": "2022-06-25T20:05:10Z",
      "url": "https://github.com/celery/celery/pull/7587#discussion_r906719345"
    },
    {
      "repo": "celery/celery",
      "pr_number": 7268,
      "file_path": "celery/backends/base.py",
      "line": 572,
      "side": "RIGHT",
      "diff_hunk": "@@ -569,9 +569,10 @@ def get_children(self, task_id):\n             pass\n \n     def _ensure_not_eager(self):\n-        if self.app.conf.task_always_eager:\n+        if self.app.conf.task_always_eager and not self.app.conf.task_store_eager_result:",
      "comment": "would you mind adding some unit tests for this small but important changes?",
      "comment_id": 794174661,
      "user": "auvipy",
      "created_at": "2022-01-28T03:17:31Z",
      "url": "https://github.com/celery/celery/pull/7268#discussion_r794174661"
    }
  ]
}