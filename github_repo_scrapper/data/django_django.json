{
  "repo": "django/django",
  "scraped_at": "2026-02-03T11:00:01.920625",
  "stats": {
    "total_comments": 1689,
    "filtered": {
      "too_short": 330,
      "not_python": 493,
      "too_long": 22,
      "no_diff_hunk": 13,
      "skip_pattern:thank you": 4,
      "skip_pattern:thanks!": 2,
      "skip_pattern:nit:": 1
    },
    "kept": 824
  },
  "examples": [
    {
      "repo": "django/django",
      "pr_number": 20614,
      "file_path": "tests/migrations/test_operations.py",
      "line": 5615,
      "side": "RIGHT",
      "diff_hunk": "@@ -5605,6 +5605,15 @@ def test_run_sql_params(self):\n             )\n         self.assertTableNotExists(\"i_love_ponies\")\n \n+    def test_run_sql_elidable(self):\n+        operation = migrations.RunSQL(migrations.RunSQL.noop, elidable=True)\n+        self.assertEqual(operation.describe(), \"Raw SQL operation\")\n+        definition = operation.deconstruct()\n+        self.assertEqual(definition[0], \"RunSQL\")\n+        self.assertEqual(definition[1], [])\n+        self.assertEqual(sorted(definition[2]), [\"elidable\", \"sql\"])\n+        self.assertTrue(definition[2][\"elidable\"])",
      "comment": "Probs don't need an explicit test for just `elidable` param.\r\nIs there already a test somewhere that checks _all_ serialized params for RunSQL? I'd probs ensure we have one that does that, and include elidable as part of its check.",
      "comment_id": 2744906431,
      "user": "jarekwg",
      "created_at": "2026-01-30T06:51:36Z",
      "url": "https://github.com/django/django/pull/20614#discussion_r2744906431"
    },
    {
      "repo": "django/django",
      "pr_number": 20614,
      "file_path": "tests/migrations/test_operations.py",
      "line": 5615,
      "side": "RIGHT",
      "diff_hunk": "@@ -5605,6 +5605,15 @@ def test_run_sql_params(self):\n             )\n         self.assertTableNotExists(\"i_love_ponies\")\n \n+    def test_run_sql_elidable(self):\n+        operation = migrations.RunSQL(migrations.RunSQL.noop, elidable=True)\n+        self.assertEqual(operation.describe(), \"Raw SQL operation\")\n+        definition = operation.deconstruct()\n+        self.assertEqual(definition[0], \"RunSQL\")\n+        self.assertEqual(definition[1], [])\n+        self.assertEqual(sorted(definition[2]), [\"elidable\", \"sql\"])\n+        self.assertTrue(definition[2][\"elidable\"])",
      "comment": "Thanks for the feedback! I've updated the PR to remove the separate test case. I found that test_run_sqland and test_run_python\r\nwere already creating elidable operations for reduction testing, so I added assertions there to verify they also deconstruct correctly with the elidable keyword.",
      "comment_id": 2744939359,
      "user": "SnippyCodes",
      "created_at": "2026-01-30T07:01:14Z",
      "url": "https://github.com/django/django/pull/20614#discussion_r2744939359"
    },
    {
      "repo": "django/django",
      "pr_number": 20614,
      "file_path": "tests/migrations/test_operations.py",
      "line": 5544,
      "side": "RIGHT",
      "diff_hunk": "@@ -5543,6 +5536,13 @@ def test_run_sql(self):\n         elidable_operation = migrations.RunSQL(\"SELECT 1 FROM void;\", elidable=True)\n         self.assertEqual(elidable_operation.reduce(operation, []), [operation])\n \n+        # Test elidable deconstruction\n+        definition = elidable_operation.deconstruct()\n+        self.assertEqual(definition[0], \"RunSQL\")\n+        self.assertEqual(definition[1], [])\n+        self.assertEqual(sorted(definition[2]), [\"elidable\", \"sql\"])\n+        self.assertTrue(definition[2][\"elidable\"])",
      "comment": "One assertion for this is fine, also please use `assertIs` for first-party values:\n```suggestion\n        self.assertIs(definition[2][\"elidable\"], True)\n```",
      "comment_id": 2746661936,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-30T14:51:21Z",
      "url": "https://github.com/django/django/pull/20614#discussion_r2746661936"
    },
    {
      "repo": "django/django",
      "pr_number": 20576,
      "file_path": "tests/admin_views/models.py",
      "line": 859,
      "side": "RIGHT",
      "diff_hunk": "@@ -856,7 +856,7 @@ def __str__(self):\n \n class MainPrepopulated(models.Model):\n     name = models.CharField(max_length=100)\n-    pubdate = models.DateField()\n+    pubdate = models.DateTimeField()  # DateTimeField will render a <fieldset>.",
      "comment": "It seems like the existing tests are failing(`admin_views.tests.SeleniumTests.test_populate_existing_object`) due to changing the field type. \r\nOf course, we could fix the tests, but instead of changing the field type, what do you think about using the `Course` model that was previously created for the fieldsets tests?\r\nI think we would just need to add `fieldsets` to the `ModelAdmin`.\r\n\r\nhttps://github.com/django/django/blob/68d110f1fe593b7a368486c41cd062563a74fe0a/tests/admin_views/models.py#L626-L639",
      "comment_id": 2723411328,
      "user": "Antoliny0919",
      "created_at": "2026-01-24T01:46:50Z",
      "url": "https://github.com/django/django/pull/20576#discussion_r2723411328"
    },
    {
      "repo": "django/django",
      "pr_number": 20576,
      "file_path": "tests/admin_views/tests.py",
      "line": 7083,
      "side": "RIGHT",
      "diff_hunk": "@@ -7079,6 +7079,16 @@ def test_use_fieldset_fields_render(self):\n             legend = fieldset.find_element(By.TAG_NAME, \"legend\")\n             self.assertEqual(legend.text, expected_legend_tags_text[index])\n \n+    @screenshot_cases([\"desktop_size\", \"mobile_size\", \"rtl\", \"dark\", \"high_contrast\"])\n+    def test_use_fieldset_fields_horizontal(self):",
      "comment": "What do you think about including something that conveys \"multiple fields\"? \ud83e\udd14 I think it would be a bit clearer (like the \"multiline\" being added in CSS).",
      "comment_id": 2723428257,
      "user": "Antoliny0919",
      "created_at": "2026-01-24T02:07:31Z",
      "url": "https://github.com/django/django/pull/20576#discussion_r2723428257"
    },
    {
      "repo": "django/django",
      "pr_number": 20576,
      "file_path": "tests/admin_views/models.py",
      "line": 859,
      "side": "RIGHT",
      "diff_hunk": "@@ -856,7 +856,7 @@ def __str__(self):\n \n class MainPrepopulated(models.Model):\n     name = models.CharField(max_length=100)\n-    pubdate = models.DateField()\n+    pubdate = models.DateTimeField()  # DateTimeField will render a <fieldset>.",
      "comment": "Sure thing. I was taking a shortcut and figured I'd hear a better idea :)",
      "comment_id": 2723572133,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-24T04:02:36Z",
      "url": "https://github.com/django/django/pull/20576#discussion_r2723572133"
    },
    {
      "repo": "django/django",
      "pr_number": 20576,
      "file_path": "tests/admin_views/tests.py",
      "line": 7103,
      "side": "RIGHT",
      "diff_hunk": "@@ -7079,6 +7079,16 @@ def test_use_fieldset_fields_render(self):\n             legend = fieldset.find_element(By.TAG_NAME, \"legend\")\n             self.assertEqual(legend.text, expected_legend_tags_text[index])\n \n+    @screenshot_cases([\"desktop_size\", \"mobile_size\", \"rtl\", \"dark\", \"high_contrast\"])\n+    def test_use_fieldset_fields_horizontal(self):\n+        self.admin_login(\n+            username=\"super\", password=\"secret\", login_url=reverse(\"admin:index\")\n+        )\n+        self.selenium.get(\n+            self.live_server_url + reverse(\"admin:admin_views_mainprepopulated_add\")\n+        )\n+        self.take_screenshot(\"horizontal_fieldset\")",
      "comment": "I think we should verify that the multiline container contains fieldset tags and at least 2 fields before taking the screenshot :)\r\n```diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\r\nindex 8ac5571f9d..8290c56138 100644\r\n--- a/tests/admin_views/tests.py\r\n+++ b/tests/admin_views/tests.py\r\n@@ -7081,12 +7081,23 @@ class SeleniumTests(AdminSeleniumTestCase):\r\n \r\n     @screenshot_cases([\"desktop_size\", \"mobile_size\", \"rtl\", \"dark\", \"high_contrast\"])\r\n     def test_use_fieldset_fields_horizontal(self):\r\n+        from selenium.webdriver.common.by import By\r\n+\r\n         self.admin_login(\r\n             username=\"super\", password=\"secret\", login_url=reverse(\"admin:index\")\r\n         )\r\n         self.selenium.get(\r\n             self.live_server_url + reverse(\"admin:admin_views_mainprepopulated_add\")\r\n         )\r\n+        multiline = self.selenium.find_element(\r\n+            By.CSS_SELECTOR, \"#content-main .field-pubdate .form-multiline\",\r\n+        )\r\n+        # Get direct children (div, fieldset) of multiline\r\n+        divs = multiline.find_elements(By.CSS_SELECTOR, \":scope > div\")\r\n+        fieldsets = multiline.find_elements(By.CSS_SELECTOR, \":scope > fieldset\")\r\n+        fields = divs + fieldsets\r\n+        self.assertGreater(len(fields), 1)\r\n+        self.assertGreater(len(fieldsets), 0)\r\n         self.take_screenshot(\"horizontal_fieldset\")\r\n \r\n     @screenshot_cases([\"desktop_size\", \"mobile_size\", \"rtl\", \"dark\", \"high_contrast\"])\r\n```\r\nI'm not sure if using `:scope` is the best approach here \ud83e\udd72",
      "comment_id": 2724089473,
      "user": "Antoliny0919",
      "created_at": "2026-01-24T12:18:11Z",
      "url": "https://github.com/django/django/pull/20576#discussion_r2724089473"
    },
    {
      "repo": "django/django",
      "pr_number": 20346,
      "file_path": "tests/model_fields/test_decimalfield.py",
      "line": 145,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,3 +140,12 @@ def test_roundtrip_with_trailing_zeros(self):\n         obj = Foo.objects.create(a=\"bar\", d=Decimal(\"8.320\"))\n         obj.refresh_from_db()\n         self.assertEqual(obj.d.compare_total(Decimal(\"8.320\")), Decimal(\"0\"))\n+\n+    def test_sqlite_integer_precision_bypass(self):\n+        if connection.vendor != \"sqlite\":",
      "comment": "Thanks for the review.\r\n1- I removed that block so the test runs for all backends.\r\n2- I added Simon as co-author since I took his fix from the discussions under the ticket \r\n3- I also added another test for the else block ",
      "comment_id": 2705970001,
      "user": "Samriddha9619",
      "created_at": "2026-01-19T20:14:02Z",
      "url": "https://github.com/django/django/pull/20346#discussion_r2705970001"
    },
    {
      "repo": "django/django",
      "pr_number": 20346,
      "file_path": "django/db/backends/sqlite3/operations.py",
      "line": 334,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,15 +330,21 @@ def get_decimalfield_converter(self, expression):\n             )\n \n             def converter(value, expression, connection):\n-                if value is not None:\n+                if isinstance(value, int):\n+                    return decimal.Decimal(value)",
      "comment": "I don't think it's acceptable to skip the `quantize()` call. This test passes on main and fails on your branch:\n\n```py\n    def test_roundtrip_integer_with_trailing_zeros(self):\n        obj = Foo.objects.create(a=\"bar\", d=Decimal(\"8\"))\n        obj.refresh_from_db()\n        self.assertEqual(obj.d.compare_total(Decimal(\"8.000\")), Decimal(\"0\"))\n```\n\n```py\n======================================================================\nFAIL: test_roundtrip_integer_with_trailing_zeros (model_fields.test_decimalfield.DecimalFieldTests.test_roundtrip_integer_with_trailing_zeros)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/Users/jwalls/django/tests/model_fields/test_decimalfield.py\", line 148, in test_roundtrip_integer_with_trailing_zeros\n    self.assertEqual(obj.d.compare_total(Decimal(\"8.000\")), Decimal(\"0\"))\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Decimal('1') != Decimal('0')\n\n----------------------------------------------------------------------\n```",
      "comment_id": 2709057178,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-20T16:11:26Z",
      "url": "https://github.com/django/django/pull/20346#discussion_r2709057178"
    },
    {
      "repo": "django/django",
      "pr_number": 20346,
      "file_path": "tests/model_fields/models.py",
      "line": 720,
      "side": "RIGHT",
      "diff_hunk": "@@ -728,3 +714,7 @@ class Meta:\n                 F(\"a\"), name=\"Generated model unique constraint virtual a\"\n             ),\n         ]\n+\n+\n+class HighPrecision(models.Model):\n+    d = models.DecimalField(max_digits=16, decimal_places=0)",
      "comment": "Please remove this model and reuse `BigD`. We can't add 1x model per test due to the overhead of creating tables.",
      "comment_id": 2709059049,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-20T16:11:54Z",
      "url": "https://github.com/django/django/pull/20346#discussion_r2709059049"
    },
    {
      "repo": "django/django",
      "pr_number": 20346,
      "file_path": "django/db/backends/sqlite3/operations.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,15 +330,21 @@ def get_decimalfield_converter(self, expression):\n             )\n \n             def converter(value, expression, connection):\n-                if value is not None:\n+                if isinstance(value, int):\n+                    return decimal.Decimal(value)\n+\n+                elif value is not None:\n                     return create_decimal(value).quantize(\n                         quantize_value, context=expression.output_field.context\n                     )\n \n         else:\n \n             def converter(value, expression, connection):\n-                if value is not None:\n+                if isinstance(value, int):\n+                    return decimal.Decimal(value)\n+\n+                elif value is not None:",
      "comment": "We try to make surgical edits when touching longstanding code. Removing the newline and changing `elif` -> `if` will create a smaller diff.",
      "comment_id": 2709062650,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-20T16:12:48Z",
      "url": "https://github.com/django/django/pull/20346#discussion_r2709062650"
    },
    {
      "repo": "django/django",
      "pr_number": 20346,
      "file_path": "tests/model_fields/test_decimalfield.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,3 +141,20 @@ def test_roundtrip_with_trailing_zeros(self):\n         obj = Foo.objects.create(a=\"bar\", d=Decimal(\"8.320\"))\n         obj.refresh_from_db()\n         self.assertEqual(obj.d.compare_total(Decimal(\"8.320\")), Decimal(\"0\"))\n+\n+    def test_large_integer_precision(self):\n+        large_int_val = Decimal(\"9999999999999999\")\n+        obj = BigD.objects.create(large_int=large_int_val, d=Decimal(\"0\"))\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.large_int, large_int_val)\n+\n+    def test_large_integer_precision_aggregation(self):\n+        large_int_val = Decimal(\"9999999999999999\")\n+        BigD.objects.create(large_int=large_int_val, d=Decimal(\"0\"))\n+        result = BigD.objects.aggregate(max_val=Max(\"large_int\"))\n+        self.assertEqual(result[\"max_val\"], large_int_val)\n+\n+    def test_roundtrip_integer_with_trailing_zeros(self):\n+        obj = Foo.objects.create(a=\"bar\", d=Decimal(\"8\"))\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.d.compare_total(Decimal(\"8.000\")), Decimal(\"0\"))",
      "comment": "SQL databases usually have a NUMERIC type with (max_digits, and decimal_places) which takes care of adding the missing precision to `Decimal(\"8\")`. This isn't the case on MongoDB, and similar to SQLite, manual quantizing is necessary to make this test pass:\n```diff\ndiff --git a/django_mongodb_backend/operations.py b/django_mongodb_backend/operations.py\nindex e446e2c4..f4b0857f 100644\n--- a/django_mongodb_backend/operations.py\n+++ b/django_mongodb_backend/operations.py\n@@ -171,18 +171,20 @@ class DatabaseOperations(GISOperations, BaseDatabaseOperations):\n     def convert_decimalfield_value(self, value, expression, connection):\n         if value is not None:\n             # from Decimal128 to decimal.Decimal()\n             try:\n                 value = value.to_decimal()\n             except AttributeError:\n                 # `value` could be an integer in the case of an annotation\n                 # like ExpressionWrapper(Value(1), output_field=DecimalField().\n                 return Decimal(value)\n+            quantize_value = Decimal(1).scaleb(-expression.output_field.decimal_places)\n+            value = value.quantize(quantize_value, context=expression.output_field.context)\n         return value\n```\nI tend to think this is unnecessary overhead and this test (which bypasses validation anyway) should be skipped on MongoDB. Raising the issue here in case any patch authors have thoughts. Thanks!",
      "comment_id": 2750110696,
      "user": "timgraham",
      "created_at": "2026-01-31T22:12:44Z",
      "url": "https://github.com/django/django/pull/20346#discussion_r2750110696"
    },
    {
      "repo": "django/django",
      "pr_number": 19923,
      "file_path": "tests/admin_views/models.py",
      "line": 1200,
      "side": "RIGHT",
      "diff_hunk": "@@ -1190,3 +1190,7 @@ def __str__(self):\n class CamelCaseRelatedModel(models.Model):\n     m2m = models.ManyToManyField(CamelCaseModel, related_name=\"m2m\")\n     fk = models.ForeignKey(CamelCaseModel, on_delete=models.CASCADE, related_name=\"fk\")\n+    # Add another relation for ticket #36468\n+    fk2 = models.ForeignKey(",
      "comment": "We need an additional relation, because the select which triggered the popup is already [ignored](https://github.com/django/django/pull/19923/files#diff-e01b712e0ef2ea7a3d38e6482034814eef4dea24166eb6484b5d1ce204980d27R104) and updated [elsewhere](https://github.com/django/django/pull/19923/files#diff-e01b712e0ef2ea7a3d38e6482034814eef4dea24166eb6484b5d1ce204980d27L132) in the RelatedObjectLookup.js.",
      "comment_id": 2410029612,
      "user": "maqnius",
      "created_at": "2025-10-07T09:39:43Z",
      "url": "https://github.com/django/django/pull/19923#discussion_r2410029612"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1162,
      "side": "RIGHT",
      "diff_hunk": "@@ -1154,8 +1154,12 @@ def construct_search(field_name):\n                 except FieldDoesNotExist:\n                     # Use valid query lookups.\n                     if prev_field and prev_field.get_lookup(path_part):\n-                        if path_part == \"exact\" and not isinstance(\n-                            prev_field, (models.CharField, models.TextField)\n+                        if (\n+                            path_part == \"exact\"\n+                            and not isinstance(\n+                                prev_field, (models.CharField, models.TextField)\n+                            )\n+                            and not prev_field.primary_key",
      "comment": "I think the problem has little to do with whether or not a primary key is targeted. The cast will be harmful in all case where the field is indexed for example.\r\n\r\nA better solution here would likely be to attempt `prev_field.to_python(...)` with the search term an in cases where the value is valid (no exception is raised) then don't perform a `Cast`.\r\n\r\nIn other words, `prev_field.to_python(\"123\")` (assuming it's an `IntegerField` instance) passes and returns `123` so we know that `field__exact=\"123\"` doesn't require a cast while `prev_field.to_python(\"foo\")` raises a `ValueError` so we know we must cast.",
      "comment_id": 2692557078,
      "user": "charettes",
      "created_at": "2026-01-15T00:46:41Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2692557078"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "tests/admin_changelist/tests.py",
      "line": 866,
      "side": "RIGHT",
      "diff_hunk": "@@ -856,6 +856,25 @@ def test_custom_lookup_with_pk_shortcut(self):\n         cl = m.get_changelist_instance(request)\n         self.assertCountEqual(cl.queryset, [abcd])\n \n+    def test_pk_exact_lookup_does_not_use_cast(self):\n+        \"\"\"Primary key exact lookups should not use Cast to preserve index usage.\"\"\"\n+        child = Child.objects.create(name=\"Test\", age=10)\n+        m = admin.ModelAdmin(Child, custom_site)\n+        m.search_fields = [\"pk__exact\"]\n+\n+        request = self.factory.get(\"/\", data={SEARCH_VAR: str(child.pk)})",
      "comment": "This is re-introducing the admin crash problem ticket-26001 fixed which you can demonstrate by doing\n\n\n```suggestion\n        request = self.factory.get(\"/\", data={SEARCH_VAR: \"foo\"})\n```\n\nA cast (or an exclusion of terms) is necessary when dealing with string that are not string representation of integers.",
      "comment_id": 2692575770,
      "user": "charettes",
      "created_at": "2026-01-15T00:57:41Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2692575770"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1162,
      "side": "RIGHT",
      "diff_hunk": "@@ -1154,8 +1154,12 @@ def construct_search(field_name):\n                 except FieldDoesNotExist:\n                     # Use valid query lookups.\n                     if prev_field and prev_field.get_lookup(path_part):\n-                        if path_part == \"exact\" and not isinstance(\n-                            prev_field, (models.CharField, models.TextField)\n+                        if (\n+                            path_part == \"exact\"\n+                            and not isinstance(\n+                                prev_field, (models.CharField, models.TextField)\n+                            )\n+                            and not prev_field.primary_key",
      "comment": "Thanks. I was trying to keep things narrow and I've never messed around at this level of admin. I just pushed a tweak that uses `to_python`. I'm a bit over my head, but hopefully this addresses your concern.",
      "comment_id": 2692610146,
      "user": "mlissner",
      "created_at": "2026-01-15T01:19:16Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2692610146"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1166,
      "side": "RIGHT",
      "diff_hunk": "@@ -1157,6 +1157,13 @@ def construct_search(field_name):\n                         if path_part == \"exact\" and not isinstance(\n                             prev_field, (models.CharField, models.TextField)\n                         ):\n+                            # Skip Cast if search_term is valid for this field\n+                            # to preserve index usage.\n+                            try:\n+                                prev_field.to_python(search_term)\n+                                return field_name, None\n+                            except ValidationError:\n+                                pass",
      "comment": "This doesn't account for multiple search terms (see `smart_split(search_term)` below) where some might need cast and others don't.\n\nFor example, if your search for `foo 123` the resulting query should be\n\n```python\nalias(\n    int_field_str=Cast(\"int_field\", TextField())\n).filter(\n    Q(int_field_str=\"foo\") | Q(int_field=\"123\")\n)\n```\n\nwith your current path it'll be doing\n\n```python\nalias(\n    int_field_str=Cast(\"int_field\", TextField())\n).filter(\n    Q(int_field_str=\"foo\") | Q(int_field_str=123)\n)\n```\n\nSee how #18765 changed the logic to no longer be search term `bit` specific and how we might need to restore it.",
      "comment_id": 2694820830,
      "user": "charettes",
      "created_at": "2026-01-15T15:21:46Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2694820830"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1166,
      "side": "RIGHT",
      "diff_hunk": "@@ -1157,6 +1157,13 @@ def construct_search(field_name):\n                         if path_part == \"exact\" and not isinstance(\n                             prev_field, (models.CharField, models.TextField)\n                         ):\n+                            # Skip Cast if search_term is valid for this field\n+                            # to preserve index usage.\n+                            try:\n+                                prev_field.to_python(search_term)\n+                                return field_name, None\n+                            except ValidationError:\n+                                pass",
      "comment": "Got it. You know, Claude suggested this yesterday and I thought it would be too invasive, but your suggestion on code.djangoproject.org is even better, and I've just pushed that, including another test to prevent regression.\r\n\r\nThank you again.",
      "comment_id": 2695860117,
      "user": "mlissner",
      "created_at": "2026-01-15T20:32:03Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2695860117"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1166,
      "side": "RIGHT",
      "diff_hunk": "@@ -1157,6 +1157,13 @@ def construct_search(field_name):\n                         if path_part == \"exact\" and not isinstance(\n                             prev_field, (models.CharField, models.TextField)\n                         ):\n+                            # Skip Cast if search_term is valid for this field\n+                            # to preserve index usage.\n+                            try:\n+                                prev_field.to_python(search_term)\n+                                return field_name, None\n+                            except ValidationError:\n+                                pass",
      "comment": "Given that, could I ask you to update the PR body \"solution\" part?",
      "comment_id": 2698951633,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-16T15:26:44Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2698951633"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1194,
      "side": "RIGHT",
      "diff_hunk": "@@ -1177,30 +1177,37 @@ def construct_search(field_name):\n         may_have_duplicates = False\n         search_fields = self.get_search_fields(request)\n         if search_fields and search_term:\n-            str_aliases = {}\n             orm_lookups = []\n             for field in search_fields:\n-                lookup, str_alias = construct_search(str(field))\n-                orm_lookups.append(lookup)\n-                if str_alias:\n-                    str_aliases[lookup] = str_alias\n-\n-            if str_aliases:\n-                queryset = queryset.alias(**str_aliases)\n+                orm_lookups.append(construct_search(str(field)))\n \n             term_queries = []\n             for bit in smart_split(search_term):\n                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                     bit = unescape_string_literal(bit)\n-                or_queries = models.Q.create(\n-                    [(orm_lookup, bit) for orm_lookup in orm_lookups],\n-                    connector=models.Q.OR,\n-                )\n-                term_queries.append(or_queries)\n-            queryset = queryset.filter(models.Q.create(term_queries))\n+                # Build lookups for this term, skipping invalid field/value\n+                # combinations to preserve index usage.\n+                bit_lookups = []\n+                for orm_lookup, validate_field in orm_lookups:\n+                    if validate_field is not None:\n+                        try:\n+                            validate_field.to_python(bit)",
      "comment": "You could re-assign `bit` here to use the proper expected type\n\n\n```suggestion\n                            but = validate_field.to_python(bit)\n```",
      "comment_id": 2723384880,
      "user": "charettes",
      "created_at": "2026-01-24T01:27:20Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2723384880"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1194,
      "side": "RIGHT",
      "diff_hunk": "@@ -1179,30 +1177,37 @@ def construct_search(field_name):\n         may_have_duplicates = False\n         search_fields = self.get_search_fields(request)\n         if search_fields and search_term:\n-            str_aliases = {}\n             orm_lookups = []\n             for field in search_fields:\n-                lookup, str_alias = construct_search(str(field))\n-                orm_lookups.append(lookup)\n-                if str_alias:\n-                    str_aliases[lookup] = str_alias\n-\n-            if str_aliases:\n-                queryset = queryset.alias(**str_aliases)\n+                orm_lookups.append(construct_search(str(field)))\n \n             term_queries = []\n             for bit in smart_split(search_term):\n                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                     bit = unescape_string_literal(bit)\n-                or_queries = models.Q.create(\n-                    [(orm_lookup, bit) for orm_lookup in orm_lookups],\n-                    connector=models.Q.OR,\n-                )\n-                term_queries.append(or_queries)\n-            queryset = queryset.filter(models.Q.create(term_queries))\n+                # Build lookups for this term, skipping invalid field/value\n+                # combinations to preserve index usage.\n+                bit_lookups = []\n+                for orm_lookup, validate_field in orm_lookups:\n+                    if validate_field is not None:\n+                        try:\n+                            bit = validate_field.to_python(bit)",
      "comment": "Did you give some thought to Simon's suggestion to use `.formfield()`? I expect some behavior differences, e.g.:\n\n```py\nIn [1]: from django.db.models.fields import BooleanField\n\nIn [2]: f = BooleanField()\n\nIn [3]: f.to_python('false')\n---------------------------------------------------------------------------\nValidationError                           Traceback (most recent call last)\nCell In[3], line 1\n----> 1 f.to_python('false')\n\nFile ~/django/django/db/models/fields/__init__.py:1179, in BooleanField.to_python(self, value)\n   1177 if value in (\"f\", \"False\", \"0\"):\n   1178     return False\n-> 1179 raise exceptions.ValidationError(\n   1180     self.error_messages[\"invalid_nullable\" if self.null else \"invalid\"],\n   1181     code=\"invalid\",\n   1182     params={\"value\": value},\n   1183 )\n\nValidationError: ['\u201cfalse\u201d value must be either True or False.']\n\nIn [4]: ff = f.formfield()\n\nIn [5]: ff.to_python('false')\nOut[5]: False\n\nIn [6]: ff.to_python('garbage')\nOut[6]: True\n```\n\nCan you look into this and add a test that will fail if the model field is used instead of the form field?",
      "comment_id": 2737719890,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-28T17:26:01Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2737719890"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1194,
      "side": "RIGHT",
      "diff_hunk": "@@ -1179,30 +1177,37 @@ def construct_search(field_name):\n         may_have_duplicates = False\n         search_fields = self.get_search_fields(request)\n         if search_fields and search_term:\n-            str_aliases = {}\n             orm_lookups = []\n             for field in search_fields:\n-                lookup, str_alias = construct_search(str(field))\n-                orm_lookups.append(lookup)\n-                if str_alias:\n-                    str_aliases[lookup] = str_alias\n-\n-            if str_aliases:\n-                queryset = queryset.alias(**str_aliases)\n+                orm_lookups.append(construct_search(str(field)))\n \n             term_queries = []\n             for bit in smart_split(search_term):\n                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                     bit = unescape_string_literal(bit)\n-                or_queries = models.Q.create(\n-                    [(orm_lookup, bit) for orm_lookup in orm_lookups],\n-                    connector=models.Q.OR,\n-                )\n-                term_queries.append(or_queries)\n-            queryset = queryset.filter(models.Q.create(term_queries))\n+                # Build lookups for this term, skipping invalid field/value\n+                # combinations to preserve index usage.\n+                bit_lookups = []\n+                for orm_lookup, validate_field in orm_lookups:\n+                    if validate_field is not None:\n+                        try:\n+                            bit = validate_field.to_python(bit)",
      "comment": "Sorry, I missed their comment about this (and, again, I'm trying not to make many changes).\r\n\r\nI think it makes sense to be more lenient here and use formfields instead of model fields. I just pushed a tweak and a test accordingly. I don't have tests working locally, so I'll update Track once tests are set to go.\r\n\r\nThanks for the review.",
      "comment_id": 2739394523,
      "user": "mlissner",
      "created_at": "2026-01-29T01:45:37Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2739394523"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1196,
      "side": "RIGHT",
      "diff_hunk": "@@ -1179,30 +1177,43 @@ def construct_search(field_name):\n         may_have_duplicates = False\n         search_fields = self.get_search_fields(request)\n         if search_fields and search_term:\n-            str_aliases = {}\n             orm_lookups = []\n             for field in search_fields:\n-                lookup, str_alias = construct_search(str(field))\n-                orm_lookups.append(lookup)\n-                if str_alias:\n-                    str_aliases[lookup] = str_alias\n-\n-            if str_aliases:\n-                queryset = queryset.alias(**str_aliases)\n+                orm_lookups.append(construct_search(str(field)))\n \n             term_queries = []\n             for bit in smart_split(search_term):\n                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                     bit = unescape_string_literal(bit)\n-                or_queries = models.Q.create(\n-                    [(orm_lookup, bit) for orm_lookup in orm_lookups],\n-                    connector=models.Q.OR,\n-                )\n-                term_queries.append(or_queries)\n-            queryset = queryset.filter(models.Q.create(term_queries))\n+                # Build lookups for this term, skipping invalid field/value\n+                # combinations to preserve index usage.\n+                bit_lookups = []\n+                for orm_lookup, validate_field in orm_lookups:\n+                    if validate_field is not None:\n+                        formfield = validate_field.formfield()\n+                        try:\n+                            if formfield is not None:\n+                                bit = formfield.to_python(bit)",
      "comment": "I think we shouldn't shadow the outer loop variable.\n\nI found that with two fields, e.g. IntegerField and JSONField (and with search fields `[\"int__exact\", \"json__exact\"]`), a bit that was only valid as an int but not as json (e.g. \"3.\"), translated into valid `Q` objects for both fields instead of only the int field.\n\nThe `bit` from the `IntegerField.to_python()` result was still `3` on the second loop iteration, which became a valid input to `JSONField.to_python()`.\n\nCan you address & add a test?",
      "comment_id": 2742232366,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-29T15:30:27Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2742232366"
    },
    {
      "repo": "django/django",
      "pr_number": 20538,
      "file_path": "django/contrib/admin/options.py",
      "line": 1202,
      "side": "RIGHT",
      "diff_hunk": "@@ -1179,30 +1177,45 @@ def construct_search(field_name):\n         may_have_duplicates = False\n         search_fields = self.get_search_fields(request)\n         if search_fields and search_term:\n-            str_aliases = {}\n             orm_lookups = []\n             for field in search_fields:\n-                lookup, str_alias = construct_search(str(field))\n-                orm_lookups.append(lookup)\n-                if str_alias:\n-                    str_aliases[lookup] = str_alias\n-\n-            if str_aliases:\n-                queryset = queryset.alias(**str_aliases)\n+                orm_lookups.append(construct_search(str(field)))\n \n             term_queries = []\n             for bit in smart_split(search_term):\n                 if bit.startswith(('\"', \"'\")) and bit[0] == bit[-1]:\n                     bit = unescape_string_literal(bit)\n-                or_queries = models.Q.create(\n-                    [(orm_lookup, bit) for orm_lookup in orm_lookups],\n-                    connector=models.Q.OR,\n-                )\n-                term_queries.append(or_queries)\n-            queryset = queryset.filter(models.Q.create(term_queries))\n+                # Build lookups for this term, skipping invalid field/value\n+                # combinations to preserve index usage.\n+                bit_lookups = []\n+                for orm_lookup, validate_field in orm_lookups:\n+                    if validate_field is not None:\n+                        formfield = validate_field.formfield()\n+                        try:\n+                            if formfield is not None:\n+                                value = formfield.to_python(bit)\n+                            else:\n+                                # Fallback for fields without form fields (e.g.\n+                                # AutoField).\n+                                value = validate_field.to_python(bit)\n+                        except ValidationError:\n+                            # Skip this lookup for invalid values.\n+                            continue",
      "comment": "We could return some some sort of sentinel here that signals it's okay to skip this `orm_lookup` when calculating `may_have_duplicates` below, but this is just a subtle optimization opportunity to avoid a `distinct()` later on, and I'm comfortable leaving it for someone else in a follow-up \ud83d\udc4d .",
      "comment_id": 2742731412,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-29T17:24:03Z",
      "url": "https://github.com/django/django/pull/20538#discussion_r2742731412"
    },
    {
      "repo": "django/django",
      "pr_number": 20608,
      "file_path": "tests/utils_tests/test_html.py",
      "line": 104,
      "side": "LEFT",
      "diff_hunk": "@@ -100,10 +100,9 @@ def test_strip_tags(self):\n             (3, 11): (3, 11, 14),\n             (3, 10): (3, 10, 19),\n             (3, 9): (3, 9, 24),\n+            # Not fixed in 3.8.\n+            (3, 8): (3, 8, math.inf),\n         }\n-        htmlparser_fixed_security = (",
      "comment": "This is defined below (conflict incorrectly resolved?)",
      "comment_id": 2738790009,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-28T21:58:32Z",
      "url": "https://github.com/django/django/pull/20608#discussion_r2738790009"
    },
    {
      "repo": "django/django",
      "pr_number": 20574,
      "file_path": "django/db/migrations/state.py",
      "line": 195,
      "side": "RIGHT",
      "diff_hunk": "@@ -192,9 +192,10 @@ def alter_model_options(self, app_label, model_name, options, option_keys=None):\n     def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n         model_state = self.models[app_label, model_name]\n         if objs := model_state.options.get(option_name):\n-            model_state.options[option_name] = [\n-                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n-            ]\n+            new_value = [obj for obj in objs if tuple(obj) != tuple(value_to_remove)]",
      "comment": "I haven't been able to come up with a test triggering the same problem as reported, but there is a type inconsistency here.",
      "comment_id": 2721704994,
      "user": "MarkusH",
      "created_at": "2026-01-23T15:30:31Z",
      "url": "https://github.com/django/django/pull/20574#discussion_r2721704994"
    },
    {
      "repo": "django/django",
      "pr_number": 20574,
      "file_path": "django/db/migrations/state.py",
      "line": 343,
      "side": "RIGHT",
      "diff_hunk": "@@ -339,10 +340,10 @@ def rename_field(self, app_label, model_name, old_name, new_name):\n         options = model_state.options\n         for option in (\"index_together\", \"unique_together\"):\n             if option in options:\n-                options[option] = [\n-                    [new_name if n == old_name else n for n in together]\n+                options[option] = set(",
      "comment": "```suggestion\n                options[option] = {\n```",
      "comment_id": 2721706428,
      "user": "MarkusH",
      "created_at": "2026-01-23T15:30:51Z",
      "url": "https://github.com/django/django/pull/20574#discussion_r2721706428"
    },
    {
      "repo": "django/django",
      "pr_number": 20574,
      "file_path": "django/db/migrations/state.py",
      "line": 195,
      "side": "RIGHT",
      "diff_hunk": "@@ -192,9 +192,10 @@ def alter_model_options(self, app_label, model_name, options, option_keys=None):\n     def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n         model_state = self.models[app_label, model_name]\n         if objs := model_state.options.get(option_name):\n-            model_state.options[option_name] = [\n-                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n-            ]\n+            new_value = [obj for obj in objs if tuple(obj) != tuple(value_to_remove)]",
      "comment": "I added some minimal coverage like this:\n```diff\ndiff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 28d65a7ecf..d3a2f732f2 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -3974,6 +3974,7 @@ class OperationTests(OperationTestBase):\n         )\n         new_state = project_state.clone()\n         operation.state_forwards(app_label, new_state)\n+        self.assertIsInstance(new_state.models[app_label, \"pony\"].options[\"index_together\"], set)\n         # Rename index.\n         with connection.schema_editor() as editor:\n             operation.database_forwards(app_label, editor, project_state, new_state)\n```\n\nUnless you think that's testing an implementation detail? Poking around, we have other assertions against `new_state.models`.",
      "comment_id": 2737017476,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-28T14:53:53Z",
      "url": "https://github.com/django/django/pull/20574#discussion_r2737017476"
    },
    {
      "repo": "django/django",
      "pr_number": 20574,
      "file_path": "tests/migrations/test_autodetector.py",
      "line": 5596,
      "side": "RIGHT",
      "diff_hunk": "@@ -5590,6 +5590,54 @@ def test_remove_composite_pk(self):\n             preserve_default=True,\n         )\n \n+    def test_does_not_crash_after_rename_on_unique_together(self):\n+        \"\"\"\n+        Regression test for https://code.djangoproject.com/ticket/36878\n+        \"\"\"",
      "comment": "You can chop, we just leave ticket references in the blame these days.",
      "comment_id": 2737019284,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-28T14:54:19Z",
      "url": "https://github.com/django/django/pull/20574#discussion_r2737019284"
    },
    {
      "repo": "django/django",
      "pr_number": 20574,
      "file_path": "django/db/migrations/state.py",
      "line": 195,
      "side": "RIGHT",
      "diff_hunk": "@@ -192,9 +192,10 @@ def alter_model_options(self, app_label, model_name, options, option_keys=None):\n     def remove_model_options(self, app_label, model_name, option_name, value_to_remove):\n         model_state = self.models[app_label, model_name]\n         if objs := model_state.options.get(option_name):\n-            model_state.options[option_name] = [\n-                obj for obj in objs if tuple(obj) != tuple(value_to_remove)\n-            ]\n+            new_value = [obj for obj in objs if tuple(obj) != tuple(value_to_remove)]",
      "comment": "If this assertion feels like a non sequitur, we could pull it out into a new test method.",
      "comment_id": 2737068892,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-28T15:04:51Z",
      "url": "https://github.com/django/django/pull/20574#discussion_r2737068892"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 304,
      "side": "RIGHT",
      "diff_hunk": "@@ -298,6 +298,11 @@ def create_parser(self, prog_name, subcommand, **kwargs):\n         parse the arguments to this command.\n         \"\"\"\n         kwargs.setdefault(\"formatter_class\", DjangoHelpFormatter)\n+        \n+        # Enable suggest_on_error for Python 3.14+\n+        if sys.version_info >= (3, 14):\n+            kwargs.setdefault(\"suggest_on_error\", True)",
      "comment": "Use `PY314` from `django.utils.version`\r\n```suggestion\r\n        if PY314:\r\n            kwargs.setdefault(\"suggest_on_error\", True)\r\n```",
      "comment_id": 2476883281,
      "user": "felixxm",
      "created_at": "2025-10-30T08:40:07Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2476883281"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/commands/makemessages.py",
      "line": 393,
      "side": "RIGHT",
      "diff_hunk": "@@ -382,10 +383,15 @@ def handle(self, *args, **options):\n             self.invoked_for_django = True\n         else:\n             if self.settings_available:\n-                self.locale_paths.extend(settings.LOCALE_PATHS)\n+                for path in settings.LOCALE_PATHS:\n+                    locale_path = os.path.abspath(path)\n+                    if locale_path not in self.locale_paths:\n+                        self.locale_paths.append(locale_path)\n             # Allow to run makemessages inside an app dir\n             if os.path.isdir(\"locale\"):\n-                self.locale_paths.append(os.path.abspath(\"locale\"))\n+                locale_path = os.path.abspath(\"locale\")\n+                if locale_path not in self.locale_paths:\n+                    self.locale_paths.append(locale_path)",
      "comment": "I think you mixed this patch with some unrelated changes in `makemessages`, please remove them.",
      "comment_id": 2476889835,
      "user": "felixxm",
      "created_at": "2025-10-30T08:42:03Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2476889835"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,9 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        # Enable suggest_on_error for Python 3.14+\n+        if PY314 and called_from_command_line:",
      "comment": "I just spotted that the default has flipped to `True` on Python 3.15: https://github.com/python/cpython/commit/d2f3cfd38457204a2c47162de6f89ee3dd22fa99\n\nTherefore, let's change the check to:\n```suggestion\n        if PY314 and not PY315 and called_from_command_line:\n            # Adopt Python 3.15 default early.\n```\n\nThis way, when we drop Python 3.14 support, it should be clear that we can remove this block.",
      "comment_id": 2485983581,
      "user": "adamchainz",
      "created_at": "2025-11-03T10:21:17Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2485983581"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "tests/user_commands/tests.py",
      "line": 463,
      "side": "RIGHT",
      "diff_hunk": "@@ -455,6 +457,80 @@ def test_outputwrapper_flush(self):\n         self.assertIs(mocked_flush.called, True)\n \n \n+class SuggestOnErrorTests(SimpleTestCase):\n+    \"\"\"\n+    Tests for argparse suggest_on_error feature on Python 3.14+.\n+    \"\"\"",
      "comment": "These tests do not need a dedicated test case and can be placed at the end of `CommandTests`",
      "comment_id": 2485988570,
      "user": "adamchainz",
      "created_at": "2025-11-03T10:23:18Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2485988570"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "tests/user_commands/tests.py",
      "line": 531,
      "side": "RIGHT",
      "diff_hunk": "@@ -455,6 +457,80 @@ def test_outputwrapper_flush(self):\n         self.assertIs(mocked_flush.called, True)\n \n \n+class SuggestOnErrorTests(SimpleTestCase):\n+    \"\"\"\n+    Tests for argparse suggest_on_error feature on Python 3.14+.\n+    \"\"\"\n+\n+    def test_parser_kwargs_suggest_on_error_on_python_314_plus(self):\n+        \"\"\"\n+        CommandParser sets suggest_on_error=True on Python 3.14+.\n+        \"\"\"\n+        command = BaseCommand()\n+        command._called_from_command_line = True  # ADD THIS LINE\n+        parser = command.create_parser(\"prog_name\", \"subcommand\")\n+\n+        if PY314:\n+            self.assertTrue(\n+                getattr(parser, \"suggest_on_error\", False),\n+                \"Parser should have suggest_on_error=True on Python 3.14+\",\n+            )\n+\n+    @unittest.skipUnless(PY314, \"Requires Python 3.14+\")\n+    def test_custom_suggest_on_error_respected(self):\n+        \"\"\"\n+        Explicit suggest_on_error=False is respected.\n+        \"\"\"\n+        command = BaseCommand()\n+        command._called_from_command_line = True  # ADD THIS LINE\n+        parser = command.create_parser(\n+            \"prog_name\", \"subcommand\", suggest_on_error=False\n+        )\n+        self.assertFalse(\n+            parser.suggest_on_error,\n+            \"Explicit suggest_on_error=False is respected\",\n+        )\n+\n+    @unittest.skipUnless(PY314, \"Requires Python 3.14+\")\n+    def test_misspelled_option_suggests_correct_option(self):\n+        \"\"\"\n+        On Python 3.14+, misspelled options trigger suggestions when available.\n+        \"\"\"\n+        command = BaseCommand()\n+        command._called_from_command_line = True\n+        parser = command.create_parser(\"django-admin\", \"test\")\n+\n+        err = StringIO()\n+        with mock.patch(\"sys.stderr\", err):\n+            with self.assertRaises(SystemExit) as cm:\n+                parser.parse_args([\"--verbositty\", \"2\"])\n+        self.assertEqual(cm.exception.code, 2)\n+\n+        error_output = err.getvalue().lower()\n+        # Ensure it failed for the right reason\n+        self.assertIn(\"unrecognized arguments\", error_output)\n+\n+        # On Python 3.14+, suggestions *may* appear depending on environment\n+        if \"did you mean\" in error_output:\n+            self.assertIn(\"--verbosity\", error_output)\n+\n+    def test_suggest_on_error_works_with_management_commands(self):\n+        \"\"\"\n+        Management commands have suggest_on_error on Python 3.14+.\n+        \"\"\"\n+        from .management.commands.dance import Command as DanceCommand\n+\n+        dance_cmd = DanceCommand()\n+        dance_cmd._called_from_command_line = True  # ADD THIS LINE\n+        parser = dance_cmd.create_parser(\"django-admin\", \"dance\")\n+\n+        if PY314:\n+            self.assertTrue(\n+                getattr(parser, \"suggest_on_error\", False),\n+                \"Management command parsers should have suggest_on_error=True\",\n+            )",
      "comment": "Some fixes for your tests:\n\n1. Use `unittest.skipUnless` on all tests.\n2. Use `not PY315` per the above comments about the default chanigng on Python 3.15.\n3. Drop the `# ADD THIS LINE` comments, which look like they came from someone's review?\n4. Drop the behaviour tests - they are not valuable, as they only test argparse's behaviour, which we can depend on.\n\n```suggestion\n    @unittest.skipUnless(PY314 and not PY315, \"Requires Python 3.14\")\n    def test_suggest_on_error_defaults_true(self):\n        \"\"\"\n        CommandParser sets suggest_on_error=True on Python 3.14+.\n        \"\"\"\n        command = BaseCommand()\n        command._called_from_command_line = True\n        parser = command.create_parser(\"prog_name\", \"subcommand\")\n\n        self.assertTrue(parser.suggest_on_error)\n\n    @unittest.skipUnless(PY314 and not PY315, \"Requires Python 3.14+\")\n    def test_suggest_on_error_custom(self):\n        \"\"\"\n        Explicit suggest_on_error=False is respected.\n        \"\"\"\n        command = BaseCommand()\n        command._called_from_command_line = True\n        parser = command.create_parser(\n            \"prog_name\", \"subcommand\", suggest_on_error=False\n        )\n        self.assertFalse(parser.suggest_on_error)\n```",
      "comment_id": 2485998264,
      "user": "adamchainz",
      "created_at": "2025-11-03T10:27:03Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2485998264"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "tests/user_commands/tests.py",
      "line": 515,
      "side": "RIGHT",
      "diff_hunk": "@@ -455,6 +457,80 @@ def test_outputwrapper_flush(self):\n         self.assertIs(mocked_flush.called, True)\n \n \n+class SuggestOnErrorTests(SimpleTestCase):\n+    \"\"\"\n+    Tests for argparse suggest_on_error feature on Python 3.14+.\n+    \"\"\"\n+\n+    def test_parser_kwargs_suggest_on_error_on_python_314_plus(self):\n+        \"\"\"\n+        CommandParser sets suggest_on_error=True on Python 3.14+.\n+        \"\"\"\n+        command = BaseCommand()\n+        command._called_from_command_line = True  # ADD THIS LINE\n+        parser = command.create_parser(\"prog_name\", \"subcommand\")\n+\n+        if PY314:\n+            self.assertTrue(\n+                getattr(parser, \"suggest_on_error\", False),\n+                \"Parser should have suggest_on_error=True on Python 3.14+\",\n+            )\n+\n+    @unittest.skipUnless(PY314, \"Requires Python 3.14+\")\n+    def test_custom_suggest_on_error_respected(self):\n+        \"\"\"\n+        Explicit suggest_on_error=False is respected.\n+        \"\"\"\n+        command = BaseCommand()\n+        command._called_from_command_line = True  # ADD THIS LINE\n+        parser = command.create_parser(\n+            \"prog_name\", \"subcommand\", suggest_on_error=False\n+        )\n+        self.assertFalse(\n+            parser.suggest_on_error,\n+            \"Explicit suggest_on_error=False is respected\",\n+        )\n+\n+    @unittest.skipUnless(PY314, \"Requires Python 3.14+\")\n+    def test_misspelled_option_suggests_correct_option(self):\n+        \"\"\"\n+        On Python 3.14+, misspelled options trigger suggestions when available.\n+        \"\"\"\n+        command = BaseCommand()\n+        command._called_from_command_line = True\n+        parser = command.create_parser(\"django-admin\", \"test\")\n+\n+        err = StringIO()\n+        with mock.patch(\"sys.stderr\", err):\n+            with self.assertRaises(SystemExit) as cm:\n+                parser.parse_args([\"--verbositty\", \"2\"])\n+        self.assertEqual(cm.exception.code, 2)\n+\n+        error_output = err.getvalue().lower()\n+        # Ensure it failed for the right reason\n+        self.assertIn(\"unrecognized arguments\", error_output)\n+\n+        # On Python 3.14+, suggestions *may* appear depending on environment\n+        if \"did you mean\" in error_output:\n+            self.assertIn(\"--verbosity\", error_output)",
      "comment": "This test was not testing the correct output, or expecting the right correction. `suggest_on_error` does not affect mistyped options. It affects mistyped option *choices* and subparser names.\n\nThe way I'm testing it manually is:\n\n```\n$ python -m django check --fail-level EROR\n...\n__main__.py check: error: argument --fail-level: invalid choice: 'EROR', maybe you meant 'ERROR'? (choose from CRITICAL, ERROR, WARNING, INFO, DEBUG)\n```\n\nNote the \"maybe you meant 'ERROR'?\"\n\nI don't think argparse *has* any feature to suggest for mistyped options at current. Did you see this assertion pass on any environment?",
      "comment_id": 2486050288,
      "user": "adamchainz",
      "created_at": "2025-11-03T10:46:47Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2486050288"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "tests/user_commands/tests.py",
      "line": 515,
      "side": "RIGHT",
      "diff_hunk": "@@ -455,6 +457,80 @@ def test_outputwrapper_flush(self):\n         self.assertIs(mocked_flush.called, True)\n \n \n+class SuggestOnErrorTests(SimpleTestCase):\n+    \"\"\"\n+    Tests for argparse suggest_on_error feature on Python 3.14+.\n+    \"\"\"\n+\n+    def test_parser_kwargs_suggest_on_error_on_python_314_plus(self):\n+        \"\"\"\n+        CommandParser sets suggest_on_error=True on Python 3.14+.\n+        \"\"\"\n+        command = BaseCommand()\n+        command._called_from_command_line = True  # ADD THIS LINE\n+        parser = command.create_parser(\"prog_name\", \"subcommand\")\n+\n+        if PY314:\n+            self.assertTrue(\n+                getattr(parser, \"suggest_on_error\", False),\n+                \"Parser should have suggest_on_error=True on Python 3.14+\",\n+            )\n+\n+    @unittest.skipUnless(PY314, \"Requires Python 3.14+\")\n+    def test_custom_suggest_on_error_respected(self):\n+        \"\"\"\n+        Explicit suggest_on_error=False is respected.\n+        \"\"\"\n+        command = BaseCommand()\n+        command._called_from_command_line = True  # ADD THIS LINE\n+        parser = command.create_parser(\n+            \"prog_name\", \"subcommand\", suggest_on_error=False\n+        )\n+        self.assertFalse(\n+            parser.suggest_on_error,\n+            \"Explicit suggest_on_error=False is respected\",\n+        )\n+\n+    @unittest.skipUnless(PY314, \"Requires Python 3.14+\")\n+    def test_misspelled_option_suggests_correct_option(self):\n+        \"\"\"\n+        On Python 3.14+, misspelled options trigger suggestions when available.\n+        \"\"\"\n+        command = BaseCommand()\n+        command._called_from_command_line = True\n+        parser = command.create_parser(\"django-admin\", \"test\")\n+\n+        err = StringIO()\n+        with mock.patch(\"sys.stderr\", err):\n+            with self.assertRaises(SystemExit) as cm:\n+                parser.parse_args([\"--verbositty\", \"2\"])\n+        self.assertEqual(cm.exception.code, 2)\n+\n+        error_output = err.getvalue().lower()\n+        # Ensure it failed for the right reason\n+        self.assertIn(\"unrecognized arguments\", error_output)\n+\n+        # On Python 3.14+, suggestions *may* appear depending on environment\n+        if \"did you mean\" in error_output:\n+            self.assertIn(\"--verbosity\", error_output)",
      "comment": "You're right @adamchainz,  I apologize for the confusion. I did not actually test this on Python 3.14+. I was working on Python 3.12 and wrote tests based on the ticket description, which turned out to be incorrect about what `suggest_on_error` does.\r\n\r\nThank you for the clarification that it only affects:\r\n- Mistyped argument **choices** (like `--fail-level EROR` \u2192 `ERROR`)  \r\n- Mistyped **subparser names** (like `python manage.py chek` \u2192 `check`)\r\n\r\nAnd NOT mistyped option flags (like `--verbositty`).\r\n\r\nI've removed the incorrect behavioral test. The remaining two tests just verify that the setting is applied correctly, which is appropriate since we're relying on argparse's implementation.\r\n\r\nThe ticket description should probably be updated to reflect the actual behavior of this feature.",
      "comment_id": 2496146732,
      "user": "kihuni",
      "created_at": "2025-11-05T21:00:55Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2496146732"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314 and not PY315 and called_from_command_line:",
      "comment": "Curious why you decided to add `and called_from_command_line` here, couldn't we opt in everywhere?",
      "comment_id": 2499714689,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-06T16:14:50Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2499714689"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314 and not PY315 and called_from_command_line:",
      "comment": "Hi @jacobtylerwalls, I added the `called_from_command_line` check because I hit a pickling error in CI on Python 3.14:\r\n```\r\nPicklingError(\"Can't pickle local object <function ArgumentParser.__init__.<locals>.identity>\")\r\n```\r\n\r\nThis broke the parallel test runner. I thought limiting it to command-line usage would avoid the issue.\r\n\r\nI see the issues persist after removing `called_from_command_line`.\r\n\r\nI would really appreciate your guidance on this one.",
      "comment_id": 2500426927,
      "user": "kihuni",
      "created_at": "2025-11-06T18:59:13Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2500426927"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314 and not PY315 and called_from_command_line:",
      "comment": "I don't see the error, but I'm happy to look into it if you have steps to reproduce. Sometimes the parallel test runner spews irrelevant information underneath advice like:\r\n```\r\nIn order to see the traceback, you should install tblib:\r\n\r\n    python -m pip install tblib\r\n```",
      "comment_id": 2500531071,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-06T19:30:11Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2500531071"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314 and not PY315 and called_from_command_line:",
      "comment": "Can you update the failing test? (test_invalid_choice_db_option)",
      "comment_id": 2500531932,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-06T19:30:27Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2500531932"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314 and not PY315 and called_from_command_line:",
      "comment": "Here's the full traceback from the Windows Python 3.14 CI run:\r\n```\r\nmultiprocessing.pool.MaybeEncodingError: Error sending result: '<multiprocessing.pool.ExceptionWithTraceback object at 0x000002587F365940>'. \r\nReason: 'PicklingError(\"Can't pickle local object <function ArgumentParser.__init__.<locals>.identity at 0x000002587F4075E0>\")'\r\n```\r\n\r\nThis is happening in Django's parallel test runner when it tries to pickle test objects that contain `ArgumentParser` instances with `suggest_on_error=True`.\r\n\r\nThe error occurs consistently on Python 3.14 when `suggest_on_error=True` is enabled unconditionally. That's why I limited it to `called_from_command_line`. It still provides the feature to end users while avoiding the multiprocessing issue in tests.\r\n\r\nIs there a better approach to handle this?",
      "comment_id": 2501696847,
      "user": "kihuni",
      "created_at": "2025-11-07T05:05:12Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2501696847"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314 and not PY315 and called_from_command_line:",
      "comment": "I'm not convinced that's relevant yet. I think we should start with fixing the test failure in `test_invalid_choice_db_option`.",
      "comment_id": 2503793045,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-07T14:20:34Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2503793045"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314 and not PY315 and called_from_command_line:",
      "comment": "Hi @jacobtylerwalls, could you help me understand which specific test failure I should focus on? The CI logs show pickling errors, but I'm not seeing a clear test failure message.\r\n\r\nCause when I enable `suggest_on_error` everywhere, i get \r\n<img width=\"758\" height=\"871\" alt=\"Screenshot from 2025-11-14 11-54-28\" src=\"https://github.com/user-attachments/assets/46d4ae55-b7d1-472d-a915-0ff5db338e70\" />     But when i limit to when `called_from_command_line=True` when user runs command in the command line, the tests passes.\r\n",
      "comment_id": 2529500850,
      "user": "kihuni",
      "created_at": "2025-11-15T03:24:07Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2529500850"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314 and not PY315 and called_from_command_line:",
      "comment": "It's possible you haven't scrolled up far enough, I can't tell.\r\n\r\nHere's the error, it's just an update needed for the expected string (based on the python version):\r\n\r\n```\r\nTraceback (most recent call last):\r\n  File \"/Users/jwalls/django/tests/admin_scripts/tests.py\", line 2490, in test_invalid_choice_db_option\r\n    with self.assertRaisesRegex(CommandError, expected_error):\r\n         ~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nAssertionError: \"Error: argument --database: invalid choice: 'deflaut' \\(choose from '?default'?, '?other'?\\)\" does not match \"Error: argument --database: invalid choice: 'deflaut', maybe you meant 'default'? (choose from default, other)\"\r\n\r\n----------------------------------------------------------------------\r\n```",
      "comment_id": 2529885390,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-15T13:22:42Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2529885390"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314 and not PY315 and called_from_command_line:",
      "comment": "@jacobtylerwalls Thank you for pinpointing the exact issue! \r\n\r\nThe test `test_invalid_choice_db_option` expects the error message format without suggestions, but on Python 3.14 with `suggest_on_error=True`, argparse now adds `\", maybe you meant 'default'?\"` to the message.\r\n\r\nI've updated the test to use a conditional regex pattern based on Python versions:\r\n- **Python 3.14**: Expects `\"invalid choice: 'deflaut', maybe you meant 'default'? (choose from default, other)\"`\r\n- **Other versions**: Expects `\"invalid choice: 'deflaut' (choose from 'default', 'other')\"`\r\n\r\nI added `PY314` and `PY315` imports to `tests/admin_scripts/tests.py`, updated `expected_error` to be conditional based on Python version, and adjusted the regex to match the new format on Python 3.14.\r\n\r\nDoes this approach look good, or would you prefer a different way to handle version differences?",
      "comment_id": 2531737909,
      "user": "kihuni",
      "created_at": "2025-11-16T08:27:28Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2531737909"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 2450,
      "side": "RIGHT",
      "diff_hunk": "@@ -2446,10 +2446,19 @@ def test_precedence(self):\n \n class CommandDBOptionChoiceTests(SimpleTestCase):\n     def test_invalid_choice_db_option(self):\n-        expected_error = (\n-            r\"Error: argument --database: invalid choice: 'deflaut' \"\n-            r\"\\(choose from '?default'?, '?other'?\\)\"\n-        )\n+        # Update expected error based on Python version\n+        if PY314 and not PY315:",
      "comment": "We're expecting this change in all versions after 3.14. 3.15 alpha 2 comes out tomorrow and should have this change. So please go ahead and update this.\n```suggestion\n        if PY314:\n```",
      "comment_id": 2534568137,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-17T15:38:46Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2534568137"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 2457,
      "side": "RIGHT",
      "diff_hunk": "@@ -2446,10 +2446,19 @@ def test_precedence(self):\n \n class CommandDBOptionChoiceTests(SimpleTestCase):\n     def test_invalid_choice_db_option(self):\n-        expected_error = (\n-            r\"Error: argument --database: invalid choice: 'deflaut' \"\n-            r\"\\(choose from '?default'?, '?other'?\\)\"\n-        )\n+        # Update expected error based on Python version\n+        if PY314 and not PY315:\n+            # Python 3.14 includes suggestions\n+            expected_error = (\n+                r\"Error: argument --database: invalid choice: 'deflaut', \"\n+                r\"maybe you meant 'default'\\? \\(choose from default, other\\)\"\n+            )\n+        else:\n+            # Python < 3.14 or >= 3.15",
      "comment": "Thank you @jacobtylerwalls \ud83d\ude4f\r\n\r\nI\u2019ve updated the condition to use only if `PY314:` as suggested, and removed the outdated comments. Please let me know if you'd like me to make any other adjustments.",
      "comment_id": 2534894303,
      "user": "kihuni",
      "created_at": "2025-11-17T17:09:23Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2534894303"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314:\n+            kwargs.setdefault(\"suggest_on_error\", True)",
      "comment": "Hey @kihuni. My idea here was to keep the `and not PY315` but just lose the called from command line bit. The idea being that when we eventually drop python 3.14, we will know this code is _only_ needed on 3.14, and we can just remove the code instead of deindenting it at the time. Does that make sense?",
      "comment_id": 2535161483,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-17T18:44:52Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2535161483"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "tests/user_commands/tests.py",
      "line": 459,
      "side": "RIGHT",
      "diff_hunk": "@@ -454,6 +456,28 @@ def test_outputwrapper_flush(self):\n         self.assertIn(\"Working...\", out.getvalue())\n         self.assertIs(mocked_flush.called, True)\n \n+    @unittest.skipUnless(PY314, \"Requires Python 3.14\")",
      "comment": "That means adding `and not PY315` here again as well (and below)",
      "comment_id": 2535162362,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-17T18:45:15Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2535162362"
    },
    {
      "repo": "django/django",
      "pr_number": 20021,
      "file_path": "django/core/management/base.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,8 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n+        if PY314:\n+            kwargs.setdefault(\"suggest_on_error\", True)",
      "comment": "Hey @jacobtylerwalls, I see the confusion now! I misunderstood your earlier comment about changing to `if PY314:`. I thought you meant it should apply everywhere.\r\n\r\n**In `base.py`:**\r\n```python\r\nif PY314 and not PY315:\r\n    kwargs.setdefault(\"suggest_on_error\", True)\r\n```\r\n\r\nThis way, when Django drops Python 3.14 support, we know to remove this entire block (since 3.15+ has it as default).\r\n\r\n**Regarding `command._called_from_command_line = True`:**\r\n\r\nI had added the `called_from_command_line` check in `base.py` because I was getting an `error message format`  from the `test_invalid_choice_db_option`. After fixing the `admin_scripts` test expectations, those errors were resolved. I'll now remove the `command._called_from_command_line = True` lines from the tests.\r\n\r\nLet me update this now. Thanks for your patience in clarifying!",
      "comment_id": 2544605469,
      "user": "kihuni",
      "created_at": "2025-11-20T07:06:18Z",
      "url": "https://github.com/django/django/pull/20021#discussion_r2544605469"
    },
    {
      "repo": "django/django",
      "pr_number": 18555,
      "file_path": "tests/queries/test_qs_combinators.py",
      "line": 478,
      "side": "RIGHT",
      "diff_hunk": "@@ -450,6 +459,27 @@ def test_union_in_subquery(self):\n             [8, 1],\n         )\n \n+    @skipUnlessDBFeature(\"supports_select_intersection\")\n+    def test_intersection_in_nested_subquery(self):\n+        tag = Tag.objects.create(name=\"tag\")\n+        note = Note.objects.create(tag=tag)\n+        annotation = Annotation.objects.create(tag=tag)\n+        tags = Tag.objects.order_by()\n+        tags = tags.filter(id=OuterRef(\"tag_id\")).intersection(\n+            tags.filter(id=OuterRef(OuterRef(\"tag_id\")))\n+        )\n+        qs = Note.objects.filter(\n+            Exists(\n+                Annotation.objects.filter(\n+                    Exists(tags),\n+                    notes__in=OuterRef(\"pk\"),\n+                )\n+            )\n+        )",
      "comment": "Spent 90% of the time trying to come up with a semi-realistic use case with the currently existing models.\r\n\r\nReviewers might find [this real-life example easier to grok](https://forum.djangoproject.com/t/filtering-model-instances-m2m-field-to-exactly-match-another-m2m-field-or-list/34533/5)",
      "comment_id": 1749434671,
      "user": "charettes",
      "created_at": "2024-09-09T01:21:45Z",
      "url": "https://github.com/django/django/pull/18555#discussion_r1749434671"
    },
    {
      "repo": "django/django",
      "pr_number": 18555,
      "file_path": "tests/queries/test_qs_combinators.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -450,6 +459,27 @@ def test_union_in_subquery(self):\n             [8, 1],\n         )\n \n+    @skipUnlessDBFeature(\"supports_select_intersection\")\n+    def test_intersection_in_nested_subquery(self):\n+        tag = Tag.objects.create(name=\"tag\")\n+        note = Note.objects.create(tag=tag)\n+        annotation = Annotation.objects.create(tag=tag)\n+        tags = Tag.objects.order_by()\n+        tags = tags.filter(id=OuterRef(\"tag_id\")).intersection(\n+            tags.filter(id=OuterRef(OuterRef(\"tag_id\")))\n+        )",
      "comment": "Previously the SQL would be\r\n\r\n```sql\r\nSELECT *\r\nFROM \"queries_note\"\r\nWHERE EXISTS\r\n    (SELECT 1 AS \"a\"\r\n     FROM \"queries_annotation\" V0\r\n     INNER JOIN \"queries_annotation_notes\" V2 ON (V0.\"id\" = V2.\"annotation_id\")\r\n     WHERE (EXISTS\r\n              (SELECT U0.\"id\"\r\n               FROM \"queries_tag\" U0\r\n               WHERE U0.\"id\" = (\"queries_annotation\".\"tag_id\") INTERSECT\r\n                 SELECT U0.\"id\"\r\n                 FROM \"queries_tag\" U0 WHERE U0.\"id\" = (\"queries_note\".\"tag_id\")\r\n               LIMIT 1)\r\n            AND V2.\"note_id\" IN (\"queries_note\".\"id\"))\r\n     LIMIT 1)\r\n```\r\n\r\nWhich would crash because of the `U0.\"id\" = (\"queries_annotation\".\"tag_id\")` part.\r\n\r\nThis was due to the `tags.filter(id=OuterRef(\"tag_id\"))` part resolving to `\"queries_annotation\".\"tag_id\"` before `\"queries_annotation\"` was re-labelled to `V0` when the `Exists(Annotation...)` annotation was resolved in the `Note.objects.filter` clause.\r\n\r\nThe changes to `sql.Query.change_aliases` make sure that when this happens the re-label of `{\"queries_annotation\": \"V0\"}` percolate all the way to `tags` in order to replace the `WHERE` clause to `U0.\"id\" = (\"V0\".\"tag_id\")`.",
      "comment_id": 1749438173,
      "user": "charettes",
      "created_at": "2024-09-09T01:29:17Z",
      "url": "https://github.com/django/django/pull/18555#discussion_r1749438173"
    },
    {
      "repo": "django/django",
      "pr_number": 18555,
      "file_path": "django/db/models/sql/query.py",
      "line": 1025,
      "side": "RIGHT",
      "diff_hunk": "@@ -1021,6 +1021,17 @@ def change_aliases(self, change_map):\n                 if alias == old_alias:\n                     table_aliases[pos] = new_alias\n                     break\n+\n+        # 3. Rename the external aliases of combined queries.",
      "comment": "I guess the comment here could be adjusted to mention that we're doing that both for direct and combined queries external aliases.",
      "comment_id": 1750891809,
      "user": "charettes",
      "created_at": "2024-09-09T20:28:28Z",
      "url": "https://github.com/django/django/pull/18555#discussion_r1750891809"
    },
    {
      "repo": "django/django",
      "pr_number": 18555,
      "file_path": "django/db/models/sql/query.py",
      "line": 1033,
      "side": "RIGHT",
      "diff_hunk": "@@ -1021,6 +1021,17 @@ def change_aliases(self, change_map):\n                 if alias == old_alias:\n                     table_aliases[pos] = new_alias\n                     break\n+\n+        # 3. Rename the external aliases of combined queries.\n+        for combined_query in self.combined_queries:\n+            external_change_map = {\n+                alias: aliased\n+                for alias, aliased in change_map.items()\n+                if alias in combined_query.external_aliases\n+            }\n+            if external_change_map:\n+                combined_query.change_aliases(external_change_map)",
      "comment": "`change_aliases()` is already no-op for empty maps, so I would skip this check:\r\n```suggestion\r\n            combined_query.change_aliases(external_change_map)\r\n```",
      "comment_id": 1798298343,
      "user": "felixxm",
      "created_at": "2024-10-13T12:21:01Z",
      "url": "https://github.com/django/django/pull/18555#discussion_r1798298343"
    },
    {
      "repo": "django/django",
      "pr_number": 18555,
      "file_path": "django/db/models/sql/query.py",
      "line": 1033,
      "side": "RIGHT",
      "diff_hunk": "@@ -1021,6 +1021,17 @@ def change_aliases(self, change_map):\n                 if alias == old_alias:\n                     table_aliases[pos] = new_alias\n                     break\n+\n+        # 3. Rename the external aliases of combined queries.\n+        for combined_query in self.combined_queries:\n+            external_change_map = {\n+                alias: aliased\n+                for alias, aliased in change_map.items()\n+                if alias in combined_query.external_aliases\n+            }\n+            if external_change_map:\n+                combined_query.change_aliases(external_change_map)",
      "comment": "Thanks for the review @felixxm as usual \ud83d\ude47 \ud83c\udfc5 I forgot about f3d10546a850df4fe3796f972d5b7e16adf52f54.",
      "comment_id": 1798332490,
      "user": "charettes",
      "created_at": "2024-10-13T13:19:20Z",
      "url": "https://github.com/django/django/pull/18555#discussion_r1798332490"
    },
    {
      "repo": "django/django",
      "pr_number": 18555,
      "file_path": "tests/queries/test_qs_combinators.py",
      "line": 475,
      "side": "RIGHT",
      "diff_hunk": "@@ -450,6 +459,27 @@ def test_union_in_subquery(self):\n             [8, 1],\n         )\n \n+    @skipUnlessDBFeature(\"supports_select_intersection\")\n+    def test_intersection_in_nested_subquery(self):\n+        tag = Tag.objects.create(name=\"tag\")\n+        note = Note.objects.create(tag=tag)\n+        annotation = Annotation.objects.create(tag=tag)\n+        tags = Tag.objects.order_by()\n+        tags = tags.filter(id=OuterRef(\"tag_id\")).intersection(\n+            tags.filter(id=OuterRef(OuterRef(\"tag_id\")))\n+        )\n+        qs = Note.objects.filter(\n+            Exists(\n+                Annotation.objects.filter(\n+                    Exists(tags),\n+                    notes__in=OuterRef(\"pk\"),",
      "comment": "@charettes Is `notes__in=OuterRef(\"pk\")` correct here? I believe `notes=OuterRef(\"pk\"),` works just as well. Emanuel found that we'd need to special case this on MongoDB: https://github.com/mongodb/django-mongodb-backend/pull/474#discussion_r2728665613.",
      "comment_id": 2729349464,
      "user": "timgraham",
      "created_at": "2026-01-26T21:36:29Z",
      "url": "https://github.com/django/django/pull/18555#discussion_r2729349464"
    },
    {
      "repo": "django/django",
      "pr_number": 18555,
      "file_path": "tests/queries/test_qs_combinators.py",
      "line": 475,
      "side": "RIGHT",
      "diff_hunk": "@@ -450,6 +459,27 @@ def test_union_in_subquery(self):\n             [8, 1],\n         )\n \n+    @skipUnlessDBFeature(\"supports_select_intersection\")\n+    def test_intersection_in_nested_subquery(self):\n+        tag = Tag.objects.create(name=\"tag\")\n+        note = Note.objects.create(tag=tag)\n+        annotation = Annotation.objects.create(tag=tag)\n+        tags = Tag.objects.order_by()\n+        tags = tags.filter(id=OuterRef(\"tag_id\")).intersection(\n+            tags.filter(id=OuterRef(OuterRef(\"tag_id\")))\n+        )\n+        qs = Note.objects.filter(\n+            Exists(\n+                Annotation.objects.filter(\n+                    Exists(tags),\n+                    notes__in=OuterRef(\"pk\"),",
      "comment": "@timgraham It seems odd that we'd use `notes__in=OuterRef(\"pk\")` over `notes__in=[OuterRef(\"pk\")]` or `notes=OuterRef(\"pk\")`, its very much a SQL'ism that likely only works because we wrap the right-hand-side with `(...)` and that it's interpreted as a singleton tuple which is allowed with `IN`.\r\n\r\nI've tested that\r\n\r\n```diff\r\ndiff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\r\nindex e329d0c4f0..6866d07d03 100644\r\n--- a/tests/queries/test_qs_combinators.py\r\n+++ b/tests/queries/test_qs_combinators.py\r\n@@ -515,7 +515,7 @@ class QuerySetSetOperationTests(TestCase):\r\n             Exists(\r\n                 Annotation.objects.filter(\r\n                     Exists(tags),\r\n-                    notes__in=OuterRef(\"pk\"),\r\n+                    notes=OuterRef(\"pk\"),\r\n                 )\r\n             )\r\n         )\r\n```\r\n\r\npasses and remains a valid regression test so we just likely adjust it.",
      "comment_id": 2729774278,
      "user": "charettes",
      "created_at": "2026-01-27T00:24:16Z",
      "url": "https://github.com/django/django/pull/18555#discussion_r2729774278"
    },
    {
      "repo": "django/django",
      "pr_number": 18555,
      "file_path": "tests/queries/test_qs_combinators.py",
      "line": 475,
      "side": "RIGHT",
      "diff_hunk": "@@ -450,6 +459,27 @@ def test_union_in_subquery(self):\n             [8, 1],\n         )\n \n+    @skipUnlessDBFeature(\"supports_select_intersection\")\n+    def test_intersection_in_nested_subquery(self):\n+        tag = Tag.objects.create(name=\"tag\")\n+        note = Note.objects.create(tag=tag)\n+        annotation = Annotation.objects.create(tag=tag)\n+        tags = Tag.objects.order_by()\n+        tags = tags.filter(id=OuterRef(\"tag_id\")).intersection(\n+            tags.filter(id=OuterRef(OuterRef(\"tag_id\")))\n+        )\n+        qs = Note.objects.filter(\n+            Exists(\n+                Annotation.objects.filter(\n+                    Exists(tags),\n+                    notes__in=OuterRef(\"pk\"),",
      "comment": "Thanks for confirming: https://github.com/django/django/pull/20592.",
      "comment_id": 2729916772,
      "user": "timgraham",
      "created_at": "2026-01-27T01:45:48Z",
      "url": "https://github.com/django/django/pull/18555#discussion_r2729916772"
    },
    {
      "repo": "django/django",
      "pr_number": 20528,
      "file_path": "tests/admin_views/tests.py",
      "line": 7099,
      "side": "RIGHT",
      "diff_hunk": "@@ -7085,6 +7085,25 @@ def test_pagination_layout(self):\n         self.assertTrue(show_all.is_displayed())\n         self.take_screenshot(\"pagination\")\n \n+    @screenshot_cases([\"desktop_size\", \"mobile_size\", \"rtl\", \"dark\", \"high_contrast\"])\n+    def test_changelist_filter_sidebar_with_long_verbose_fields(self):\n+        from selenium.webdriver.common.by import By\n+\n+        self.admin_login(\n+            username=\"super\", password=\"secret\", login_url=reverse(\"admin:index\")\n+        )\n+        Person.objects.create(\n+            name=\"very very very very very very very very very \"\n+            \"loooooooooooooooooooooooooooooooooooooooooong name\",\n+            gender=2,\n+        )",
      "comment": "I seem to be failing to reproduce the issue \ud83e\udd72\r\nThe filter sidebar size should increase.",
      "comment_id": 2723442809,
      "user": "Antoliny0919",
      "created_at": "2026-01-24T02:22:53Z",
      "url": "https://github.com/django/django/pull/20528#discussion_r2723442809"
    },
    {
      "repo": "django/django",
      "pr_number": 19840,
      "file_path": "tests/cache/tests.py",
      "line": 1195,
      "side": "RIGHT",
      "diff_hunk": "@@ -1165,6 +1165,14 @@ def test_get_or_set_racing(self):\n             cache_add.return_value = False\n             self.assertEqual(cache.get_or_set(\"key\", \"default\"), \"default\")\n \n+    async def test_async_impl(self):\n+        if hasattr(cache, \"get_many\"):\n+            self.assertTrue(hasattr(cache, \"aget_many\"))\n+        if hasattr(cache, \"set_many\"):\n+            self.assertTrue(hasattr(cache, \"aset_many\"))\n+        if hasattr(cache, \"delete_many\"):\n+            self.assertTrue(hasattr(cache, \"adelete_many\"))\n+",
      "comment": "These tests will pass even without your changes applied as these methods are always present they were just the wrong implementations. You could assert against their nature instead and the test doesn't need to be `async`\r\n\r\n```suggestion\r\n    def test_async_impl(self):\r\n        if cache.get_many is not BaseCache.get_many:\r\n            self.assertIs(cache.aget_many, aget_many)\r\n        ...\r\n```",
      "comment_id": 2337540430,
      "user": "charettes",
      "created_at": "2025-09-10T18:09:21Z",
      "url": "https://github.com/django/django/pull/19840#discussion_r2337540430"
    },
    {
      "repo": "django/django",
      "pr_number": 19840,
      "file_path": "django/core/cache/backends/db.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +53,18 @@ class CacheEntry:\n \n         self.cache_model_class = CacheEntry\n \n+    def __init_subclass__(cls, **kwargs):\n+        # If a subclass implements a specialized *_many method,\n+        # it should use that method for the async implementation,\n+        # vs the version inherited from BaseCache.",
      "comment": "This should be defined on `BaseCache` and not `BaseDatabaseCache`. As pointed out in the ticket the memcached and redis backend are also affected.",
      "comment_id": 2337545639,
      "user": "charettes",
      "created_at": "2025-09-10T18:11:43Z",
      "url": "https://github.com/django/django/pull/19840#discussion_r2337545639"
    },
    {
      "repo": "django/django",
      "pr_number": 19840,
      "file_path": "django/core/cache/backends/db.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +53,18 @@ class CacheEntry:\n \n         self.cache_model_class = CacheEntry\n \n+    def __init_subclass__(cls, **kwargs):\n+        # If a subclass implements a specialized *_many method,\n+        # it should use that method for the async implementation,\n+        # vs the version inherited from BaseCache.\n+        super().__init_subclass__(**kwargs)\n+        if hasattr(cls, \"get_many\"):\n+            setattr(cls, \"aget_many\", aget_impl)",
      "comment": "This should not add anything if the subclass has its own specialized `aget_many`",
      "comment_id": 2337547753,
      "user": "charettes",
      "created_at": "2025-09-10T18:12:45Z",
      "url": "https://github.com/django/django/pull/19840#discussion_r2337547753"
    },
    {
      "repo": "django/django",
      "pr_number": 19840,
      "file_path": "django/core/cache/backends/db.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +53,18 @@ class CacheEntry:\n \n         self.cache_model_class = CacheEntry\n \n+    def __init_subclass__(cls, **kwargs):\n+        # If a subclass implements a specialized *_many method,\n+        # it should use that method for the async implementation,\n+        # vs the version inherited from BaseCache.",
      "comment": "Based on ticket comments, I had thought the goal was to only apply this change to subclasses of BaseDatabaseCache.  Moving these to BaseCache is ultimately cleaner. ",
      "comment_id": 2341904537,
      "user": "eevelweezel",
      "created_at": "2025-09-11T17:43:41Z",
      "url": "https://github.com/django/django/pull/19840#discussion_r2341904537"
    },
    {
      "repo": "django/django",
      "pr_number": 19840,
      "file_path": "django/core/cache/backends/db.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +53,18 @@ class CacheEntry:\n \n         self.cache_model_class = CacheEntry\n \n+    def __init_subclass__(cls, **kwargs):\n+        # If a subclass implements a specialized *_many method,\n+        # it should use that method for the async implementation,\n+        # vs the version inherited from BaseCache.\n+        super().__init_subclass__(**kwargs)\n+        if hasattr(cls, \"get_many\"):\n+            setattr(cls, \"aget_many\", aget_impl)",
      "comment": "Adding these directly to BaseCache vs trying to apply them conditionally via __init_subclass__ is ultimately cleaner. ",
      "comment_id": 2341910418,
      "user": "eevelweezel",
      "created_at": "2025-09-11T17:45:30Z",
      "url": "https://github.com/django/django/pull/19840#discussion_r2341910418"
    },
    {
      "repo": "django/django",
      "pr_number": 19840,
      "file_path": "tests/cache/tests.py",
      "line": 1195,
      "side": "RIGHT",
      "diff_hunk": "@@ -1165,6 +1165,14 @@ def test_get_or_set_racing(self):\n             cache_add.return_value = False\n             self.assertEqual(cache.get_or_set(\"key\", \"default\"), \"default\")\n \n+    async def test_async_impl(self):\n+        if hasattr(cache, \"get_many\"):\n+            self.assertTrue(hasattr(cache, \"aget_many\"))\n+        if hasattr(cache, \"set_many\"):\n+            self.assertTrue(hasattr(cache, \"aset_many\"))\n+        if hasattr(cache, \"delete_many\"):\n+            self.assertTrue(hasattr(cache, \"adelete_many\"))\n+",
      "comment": "The object ID ultimately doesn't match, so an is comparison fails.  I've settled on comparing pickles of the methods and asserting that calling the async method calls the sync version.   ",
      "comment_id": 2342346623,
      "user": "eevelweezel",
      "created_at": "2025-09-11T21:08:45Z",
      "url": "https://github.com/django/django/pull/19840#discussion_r2342346623"
    },
    {
      "repo": "django/django",
      "pr_number": 19840,
      "file_path": "tests/cache/tests.py",
      "line": 1168,
      "side": "RIGHT",
      "diff_hunk": "@@ -1165,6 +1165,16 @@ def test_get_or_set_racing(self):\n             cache_add.return_value = False\n             self.assertEqual(cache.get_or_set(\"key\", \"default\"), \"default\")\n \n+    def test_async_impl(self):",
      "comment": "I would suggest a more verbose test method name. You could do away with the comment in that case.",
      "comment_id": 2500125796,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-06T17:47:14Z",
      "url": "https://github.com/django/django/pull/19840#discussion_r2500125796"
    },
    {
      "repo": "django/django",
      "pr_number": 19840,
      "file_path": "tests/cache/tests.py",
      "line": 1172,
      "side": "RIGHT",
      "diff_hunk": "@@ -1165,6 +1165,16 @@ def test_get_or_set_racing(self):\n             cache_add.return_value = False\n             self.assertEqual(cache.get_or_set(\"key\", \"default\"), \"default\")\n \n+    def test_async_impl(self):\n+        # Assert that the inherited method matches the BaseCache\n+        # implementation.\n+        methods = [\"aget_many\", \"aset_many\", \"adelete_many\"]\n+        if isinstance(cache, BaseCache):",
      "comment": "This is always False, so the assertions aren't running.",
      "comment_id": 2500132376,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-06T17:48:56Z",
      "url": "https://github.com/django/django/pull/19840#discussion_r2500132376"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "tests/admin_views/tests.py",
      "line": 6370,
      "side": "RIGHT",
      "diff_hunk": "@@ -6366,6 +6367,7 @@ def test_list_editable_popups(self):\n         self.wait_for_text(\"#content h1\", \"Add section\")\n         self.selenium.find_element(By.ID, \"id_name\").send_keys(\"new section\")\n         self.selenium.find_element(By.XPATH, '//input[@value=\"Save\"]').click()\n+",
      "comment": "```suggestion\r\n```\r\n(revert any unrelated changes)",
      "comment_id": 2048692595,
      "user": "sarahboyce",
      "created_at": "2025-04-17T10:40:50Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2048692595"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1412,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,39 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:",
      "comment": "I can remove this whole `if` block without any test failures.",
      "comment_id": 2524979779,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-13T21:24:19Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2524979779"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1422,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,39 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    form_class = self.admin_site._registry[source_model].form\n+                    if (\n+                        hasattr(form_class, \"_meta\")",
      "comment": "For the `ModelForm` I was working with, it was a bare `ModelForm`, so it didn't have `_meta`, but rather the admin had `opts`. I don't think we can depend on having a `_meta`, although I'm not so familiar with this part of the framework.\r\n\r\n```py\r\n(Pdb) self.admin_site._registry[source_model].form\r\n<class 'django.forms.models.ModelForm'>\r\n(Pdb) self.admin_site._registry[source_model].form._meta\r\n*** AttributeError: type object 'ModelForm' has no attribute '_meta'\r\n(Pdb) self.admin_site._registry[source_model].opts.fields\r\n(<django.db.models.fields.AutoField: id>, <django.db.models.fields.CharField: name>)\r\n```\r\n\r\nFor reference, I was applying Sarah's earlier example with the `Group` model like this, without declaring a form:\r\n```py\r\n@admin.register(Group)\r\nclass GroupAdmin(admin.ModelAdmin):\r\n    search_fields = (\"name\",)\r\n    ordering = (\"name\",)\r\n    filter_horizontal = (\"permissions\",)\r\n\r\n    def formfield_for_manytomany(self, db_field, request=None, **kwargs):\r\n        if db_field.name == \"permissions\":\r\n            qs = kwargs.get(\"queryset\", db_field.remote_field.model.objects)\r\n            # Avoid a major performance hit resolving permission names which\r\n            # triggers a content_type load:\r\n            kwargs[\"queryset\"] = qs.select_related(\"content_type\")\r\n            return GroupedModelChoiceField(\r\n                queryset=kwargs[\"queryset\"],\r\n                choices_groupby='content_type',\r\n                widget=FilteredSelectMultiple(verbose_name=\"User permissions\", is_stacked=False),\r\n            )\r\n        return super().formfield_for_manytomany(db_field, request=request, **kwargs)\r\n```\r\n\r\n",
      "comment_id": 2673740455,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-08T20:13:33Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2673740455"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "tests/admin_widgets/tests.py",
      "line": 1365,
      "side": "RIGHT",
      "diff_hunk": "@@ -1354,14 +1355,14 @@ def execute_basic_operations(self, mode, field_name):\n         self.assertSelectOptions(\n             to_box,\n             [\n-                str(self.lisa.id),\n-                str(self.peter.id),\n                 str(self.arthur.id),\n                 str(self.bob.id),\n                 str(self.cliff.id),\n                 str(self.jason.id),\n                 str(self.jenny.id),\n                 str(self.john.id),\n+                str(self.lisa.id),\n+                str(self.peter.id),",
      "comment": "Can you tell me a little bit about why these are moving?",
      "comment_id": 2673834553,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-08T20:42:59Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2673834553"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "tests/admin_widgets/tests.py",
      "line": 1365,
      "side": "RIGHT",
      "diff_hunk": "@@ -1354,14 +1355,14 @@ def execute_basic_operations(self, mode, field_name):\n         self.assertSelectOptions(\n             to_box,\n             [\n-                str(self.lisa.id),\n-                str(self.peter.id),\n                 str(self.arthur.id),\n                 str(self.bob.id),\n                 str(self.cliff.id),\n                 str(self.jason.id),\n                 str(self.jenny.id),\n                 str(self.john.id),\n+                str(self.lisa.id),\n+                str(self.peter.id),",
      "comment": "I believe SelectBox sorts items by optgroup first, then alphabetically within each group. These test updates reflect that sorted order.",
      "comment_id": 2701363408,
      "user": "seanhelvey",
      "created_at": "2026-01-17T19:14:55Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2701363408"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1422,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,39 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    form_class = self.admin_site._registry[source_model].form\n+                    if (\n+                        hasattr(form_class, \"_meta\")",
      "comment": "Awesome. So further up in response_add we're operating on a model instance, and _meta is guaranteed. Here though the admin's form_class doesn't reliably expose _meta. Reworked to check form.fields directly instead. Also added isinstance() to detect optgroups vs flat choices (the original assumed all choices were optgroups). Added a test that should cover the bare ModelAdmin case.",
      "comment_id": 2701366559,
      "user": "seanhelvey",
      "created_at": "2026-01-17T19:21:00Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2701366559"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1422,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,39 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    form_class = self.admin_site._registry[source_model].form\n+                    if (\n+                        hasattr(form_class, \"_meta\")",
      "comment": "This still didn't work for me. I found success with `get_form(request)()`:\r\n\r\n```py\r\n                    form = self.admin_site._registry[source_model].get_form(request)()\r\n                    field = form.fields[self.opts.verbose_name_plural]\r\n                    if hasattr(field, \"choices\"):\r\n...\r\n\r\n```",
      "comment_id": 2705304857,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T15:53:41Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2705304857"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1436,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,43 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    form_class = self.admin_site._registry[source_model].form\n+                    try:\n+                        form = form_class()\n+                    except (AttributeError, TypeError):\n+                        form = None\n+                    if form and self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):\n+                            for option_value, option_label in field.choices:\n+                                # Check if this is an optgroup\n+                                # (label is a list/tuple of choices)\n+                                if isinstance(option_label, (list, tuple)):\n+                                    # It's an optgroup:\n+                                    # (group_name, [(value, label), ...])\n+                                    optgroup_label = option_value\n+                                    for choice_value, choice_display in option_label:\n+                                        if choice_display == str(obj):\n+                                            popup_response[\"optgroup\"] = optgroup_label\n+                                            break\n+\n+            popup_response_data = json.dumps(popup_response)",
      "comment": "With the GroupAdmin I was testing with [earlier](https://github.com/django/django/pull/18934#discussion_r2673740455), and with the fix from [comment](https://github.com/django/django/pull/18934#discussion_r2705304857), I was able to reach this line with a matched `popup_response[\"optgroup\"]`, but then `dumps()` failed with:\r\n\r\n```py\r\n(Pdb) option_value\r\n<ContentType: Myapp | song>\r\n\r\nTypeError: Object of type ContentType is not JSON serializable\r\n```",
      "comment_id": 2705316314,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T15:57:01Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2705316314"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1422,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,39 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    form_class = self.admin_site._registry[source_model].form\n+                    if (\n+                        hasattr(form_class, \"_meta\")",
      "comment": "Ah ok thank you. I applied the patch in the example / demo project here for easy reference it seems to be working for me now but let me know if I am still missing something. https://github.com/seanhelvey/ticket_13883",
      "comment_id": 2705397046,
      "user": "seanhelvey",
      "created_at": "2026-01-19T16:22:19Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2705397046"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1436,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,43 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    form_class = self.admin_site._registry[source_model].form\n+                    try:\n+                        form = form_class()\n+                    except (AttributeError, TypeError):\n+                        form = None\n+                    if form and self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):\n+                            for option_value, option_label in field.choices:\n+                                # Check if this is an optgroup\n+                                # (label is a list/tuple of choices)\n+                                if isinstance(option_label, (list, tuple)):\n+                                    # It's an optgroup:\n+                                    # (group_name, [(value, label), ...])\n+                                    optgroup_label = option_value\n+                                    for choice_value, choice_display in option_label:\n+                                        if choice_display == str(obj):\n+                                            popup_response[\"optgroup\"] = optgroup_label\n+                                            break\n+\n+            popup_response_data = json.dumps(popup_response)",
      "comment": "Pushed a commit to add the fix from the linked comment above and the failure here before seeing the suggestion to avoid using dumps entirely. Hopefully this will get it into a working state and then I am open to any changes :)",
      "comment_id": 2705399122,
      "user": "seanhelvey",
      "created_at": "2026-01-19T16:23:01Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2705399122"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1424,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,45 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    try:\n+                        form = source_admin.get_form(request)()\n+                    except (AttributeError, TypeError):\n+                        form = None",
      "comment": "This is uncovered, I think we can chop it and avoid testing `if form` below.",
      "comment_id": 2705475114,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T16:39:51Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2705475114"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1436,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,43 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    form_class = self.admin_site._registry[source_model].form\n+                    try:\n+                        form = form_class()\n+                    except (AttributeError, TypeError):\n+                        form = None\n+                    if form and self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):\n+                            for option_value, option_label in field.choices:\n+                                # Check if this is an optgroup\n+                                # (label is a list/tuple of choices)\n+                                if isinstance(option_label, (list, tuple)):\n+                                    # It's an optgroup:\n+                                    # (group_name, [(value, label), ...])\n+                                    optgroup_label = option_value\n+                                    for choice_value, choice_display in option_label:\n+                                        if choice_display == str(obj):\n+                                            popup_response[\"optgroup\"] = optgroup_label\n+                                            break\n+\n+            popup_response_data = json.dumps(popup_response)",
      "comment": "It works! \ud83c\udf89\n\nMy bad, I didn't notice we were using `dumps()` before (never mind!)\n\nA test case to cover this bare `ModelForm` case would be grand.",
      "comment_id": 2705505873,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T16:45:30Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2705505873"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1424,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,45 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    try:\n+                        form = source_admin.get_form(request)()\n+                    except (AttributeError, TypeError):\n+                        form = None",
      "comment": "Thanks! Removed the try/except. Regarding your bare ModelForm test comment below - test_popup_add_POST_without_optgroups should cover the bare ModelForm case (uses default admin without custom optgroups form). Did you have a specific scenario in mind that's not covered?",
      "comment_id": 2705536514,
      "user": "seanhelvey",
      "created_at": "2026-01-19T16:55:23Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2705536514"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1424,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,45 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    try:\n+                        form = source_admin.get_form(request)()\n+                    except (AttributeError, TypeError):\n+                        form = None",
      "comment": "Yeah, I was imagining a test case that did have custom optgroups, along the lines of my example that overrode `formfield_for_manytomany`: https://github.com/django/django/pull/18934#discussion_r2673740455.",
      "comment_id": 2705626533,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T17:30:47Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2705626533"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1427,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,42 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    form = source_admin.get_form(request)()\n+                    if self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):\n+                            for option_value, option_label in field.choices:\n+                                # Check if this is an optgroup\n+                                # (label is a list/tuple of choices)",
      "comment": "Do we have this usage documented anywhere nearby `ModelChoiceIterator` or `ChoiceField.choices`? Poking around, all I see is that `choices` yields 2-tuples.\n\nI'm feeling like we might want a release note & treat this as a new feature.\n\nSarah's example from the ticket looks like it was riffing on Simon's comment here: https://code.djangoproject.com/ticket/27331#comment:7",
      "comment_id": 2706159390,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T21:43:42Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2706159390"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1424,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,45 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    try:\n+                        form = source_admin.get_form(request)()\n+                    except (AttributeError, TypeError):\n+                        form = None",
      "comment": "I see. Nope the opposite of hazy! Ok that test has been added running through CI now.",
      "comment_id": 2706173846,
      "user": "seanhelvey",
      "created_at": "2026-01-19T21:52:30Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2706173846"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1427,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,42 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    form = source_admin.get_form(request)()\n+                    if self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):\n+                            for option_value, option_label in field.choices:\n+                                # Check if this is an optgroup\n+                                # (label is a list/tuple of choices)",
      "comment": "Interesting ok I made an attempt at a release note let me know what you think!",
      "comment_id": 2706203425,
      "user": "seanhelvey",
      "created_at": "2026-01-19T22:11:19Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2706203425"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1430,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,42 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    form = source_admin.get_form(request)()\n+                    if self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):\n+                            for option_value, option_label in field.choices:\n+                                # Check if this is an optgroup\n+                                # (label is a list/tuple of choices)\n+                                if isinstance(option_label, (list, tuple)):",
      "comment": "The doc you linked says any sequence is accepted, so I think we can use `not field._choices_is_value()` instead.",
      "comment_id": 2709139905,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-20T16:30:31Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2709139905"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "tests/admin_widgets/tests.py",
      "line": 1365,
      "side": "RIGHT",
      "diff_hunk": "@@ -1354,14 +1355,14 @@ def execute_basic_operations(self, mode, field_name):\n         self.assertSelectOptions(\n             to_box,\n             [\n-                str(self.lisa.id),\n-                str(self.peter.id),\n                 str(self.arthur.id),\n                 str(self.bob.id),\n                 str(self.cliff.id),\n                 str(self.jason.id),\n                 str(self.jenny.id),\n                 str(self.john.id),\n+                str(self.lisa.id),\n+                str(self.peter.id),",
      "comment": "I looked a little closer -- this test doesn't involve optgroups, so I wouldn't really expect it to change. I traced it to the new calls to `sort()`. What do you think, should we gate the new `sort()` calls only if there are any groups?",
      "comment_id": 2709285985,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-20T17:09:09Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2709285985"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1430,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,42 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    form = source_admin.get_form(request)()\n+                    if self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):\n+                            for option_value, option_label in field.choices:\n+                                # Check if this is an optgroup\n+                                # (label is a list/tuple of choices)\n+                                if isinstance(option_label, (list, tuple)):",
      "comment": "Isn't field._choices_is_value() only on model fields, not form fields? ",
      "comment_id": 2713653472,
      "user": "seanhelvey",
      "created_at": "2026-01-21T17:40:03Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2713653472"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1430,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,42 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    form = source_admin.get_form(request)()\n+                    if self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):\n+                            for option_value, option_label in field.choices:\n+                                # Check if this is an optgroup\n+                                # (label is a list/tuple of choices)\n+                                if isinstance(option_label, (list, tuple)):",
      "comment": "Good call. How about:\n```suggestion\n                                if isinstance(option_label, Iterable) and not isinstance(\n                                    option_label, str\n                                ):\n```",
      "comment_id": 2713783710,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-21T18:15:28Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2713783710"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1424,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,44 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    form = source_admin.get_form(request)()\n+                    if self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):",
      "comment": "I don't think this attr is ever missing, so I think you can remove that and deindent (and reflow the lines so that `optgroup_label` isn't all by itself).",
      "comment_id": 2713822416,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-21T18:25:56Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2713822416"
    },
    {
      "repo": "django/django",
      "pr_number": 18934,
      "file_path": "django/contrib/admin/options.py",
      "line": 1430,
      "side": "RIGHT",
      "diff_hunk": "@@ -1398,12 +1401,42 @@ def response_add(self, request, obj, post_url_continue=None):\n             else:\n                 attr = obj._meta.pk.attname\n             value = obj.serializable_value(attr)\n-            popup_response_data = json.dumps(\n-                {\n-                    \"value\": str(value),\n-                    \"obj\": str(obj),\n-                }\n-            )\n+            popup_response = {\n+                \"value\": str(value),\n+                \"obj\": str(obj),\n+            }\n+\n+            # Find the optgroup for the new item, if available\n+            source_model_name = request.POST.get(SOURCE_MODEL_VAR)\n+\n+            if source_model_name:\n+                app_label, model_name = source_model_name.split(\".\", 1)\n+                try:\n+                    source_model = apps.get_model(app_label, model_name)\n+                except LookupError:\n+                    msg = _('The app \"%s\" could not be found.') % source_model_name\n+                    self.message_user(request, msg, messages.ERROR)\n+                else:\n+                    source_admin = self.admin_site._registry[source_model]\n+                    form = source_admin.get_form(request)()\n+                    if self.opts.verbose_name_plural in form.fields:\n+                        field = form.fields[self.opts.verbose_name_plural]\n+                        if hasattr(field, \"choices\"):\n+                            for option_value, option_label in field.choices:\n+                                # Check if this is an optgroup\n+                                # (label is a list/tuple of choices)\n+                                if isinstance(option_label, (list, tuple)):",
      "comment": "I rechecked, and it looks like these get normalized to 2-tuples somewhere no matter how they're initially coded up, so we can leave this as is. \ud83d\udc4d ",
      "comment_id": 2715148391,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-22T03:15:13Z",
      "url": "https://github.com/django/django/pull/18934#discussion_r2715148391"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 315,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,9 +306,11 @@ def _nodes_and_edges(self):\n \n     def _generate_plan(self, nodes, at_end):\n         plan = []\n+        seen = set()  # Use set for O(1) membership testing instead of O(n)\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n+                if migration not in seen and (at_end or migration not in nodes):\n+                    seen.add(migration)\n                     plan.append(migration)\n         return plan",
      "comment": "How does it compare to using `django.utils.datastructures.OrderedSet`?\r\n\r\n```python\r\n    def _generate_plan(self, nodes, at_end):\r\n        plan = OrderedSet()\r\n        for node in nodes:\r\n            for migration in self.forwards_plan(node):\r\n                if migration not in plan and (at_end or migration not in nodes):\r\n                    plan.append(migration)\r\n        return list(plan)\r\n```\r\n\r\nIt's backed by using a dictionary where both `key in d` and `d[key] = value` are O(1), but then we do need to convert to a list at the end.",
      "comment_id": 2697815979,
      "user": "ngnpope",
      "created_at": "2026-01-16T10:02:02Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2697815979"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 312,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,9 +306,11 @@ def _nodes_and_edges(self):\n \n     def _generate_plan(self, nodes, at_end):\n         plan = []\n+        seen = set()  # Use set for O(1) membership testing instead of O(n)\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n+                if migration not in seen and (at_end or migration not in nodes):",
      "comment": "How big does `nodes` typically get? I wonder if we can also optimise the `migration not in nodes` check?\r\n\r\nNot a blocker for this PR.",
      "comment_id": 2698958376,
      "user": "LilyFirefly",
      "created_at": "2026-01-16T15:28:07Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2698958376"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 315,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,9 +306,11 @@ def _nodes_and_edges(self):\n \n     def _generate_plan(self, nodes, at_end):\n         plan = []\n+        seen = set()  # Use set for O(1) membership testing instead of O(n)\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n+                if migration not in seen and (at_end or migration not in nodes):\n+                    seen.add(migration)\n                     plan.append(migration)\n         return plan",
      "comment": "Thank you @ngnpope for this idea. I created a minimal benchmark script and added the results in the ticket: https://code.djangoproject.com/ticket/36869\n\ntl;dr your proposal performs as well as the proposed changed.",
      "comment_id": 2699241200,
      "user": "nessita",
      "created_at": "2026-01-16T16:48:25Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2699241200"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 315,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,9 +306,11 @@ def _nodes_and_edges(self):\n \n     def _generate_plan(self, nodes, at_end):\n         plan = []\n+        seen = set()  # Use set for O(1) membership testing instead of O(n)\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n+                if migration not in seen and (at_end or migration not in nodes):\n+                    seen.add(migration)\n                     plan.append(migration)\n         return plan",
      "comment": "Great idea @ngnpope!  It feels like a much cleaner approach only having to maintain a single collection.  And thanks @nessita for benchmarking to validate that performance remains equivalent \ud83d\ude4f \r\n\r\nI'll update the PR with this suggestion",
      "comment_id": 2699470655,
      "user": "jfysh-kraken",
      "created_at": "2026-01-16T18:00:14Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2699470655"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 312,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,9 +306,11 @@ def _nodes_and_edges(self):\n \n     def _generate_plan(self, nodes, at_end):\n         plan = []\n+        seen = set()  # Use set for O(1) membership testing instead of O(n)\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n+                if migration not in seen and (at_end or migration not in nodes):",
      "comment": "If I understand the code correctly, `nodes` should be the total number of migrations across all apps in `INSTALLED_APPS`.  And you are absolutely correct, `nodes` appears to be a list (looking at `make_state`) and there would be benefit to switching this out for a data structure that supports constant-time membership testing.\r\n\r\nI have made a small change to address this.",
      "comment_id": 2699544169,
      "user": "jfysh-kraken",
      "created_at": "2026-01-16T18:25:03Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2699544169"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,12 +306,13 @@ def _nodes_and_edges(self):\n         )\n \n     def _generate_plan(self, nodes, at_end):\n-        plan = []\n+        plan = OrderedSet()\n+        nodes_set = set(nodes)  # Convert to set for O(1) membership testing\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n-                    plan.append(migration)\n-        return plan\n+                if migration not in plan and (at_end or migration not in nodes_set):\n+                    plan.add(migration)\n+        return list(plan)",
      "comment": "My Opinion: I think no need to covert to list here . in `make_state` we are iterating over plan. I don't know but this may reduce some overhead",
      "comment_id": 2702410193,
      "user": "p-r-a-v-i-n",
      "created_at": "2026-01-18T13:22:59Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2702410193"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,12 +306,13 @@ def _nodes_and_edges(self):\n         )\n \n     def _generate_plan(self, nodes, at_end):\n-        plan = []\n+        plan = OrderedSet()\n+        nodes_set = set(nodes)  # Convert to set for O(1) membership testing\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n-                    plan.append(migration)\n-        return plan\n+                if migration not in plan and (at_end or migration not in nodes_set):\n+                    plan.add(migration)\n+        return list(plan)",
      "comment": "Maybe I'm being overly risk-averse, but I would prefer to maintain the same interface - a function that returns a `list`.  I don't think the cost to convert from OrderedSet to list is likely to be material enough to worry about?",
      "comment_id": 2702890311,
      "user": "jfysh-kraken",
      "created_at": "2026-01-19T00:11:01Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2702890311"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,12 +306,13 @@ def _nodes_and_edges(self):\n         )\n \n     def _generate_plan(self, nodes, at_end):\n-        plan = []\n+        plan = OrderedSet()\n+        nodes_set = set(nodes)  # Convert to set for O(1) membership testing\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n-                    plan.append(migration)\n-        return plan\n+                if migration not in plan and (at_end or migration not in nodes_set):\n+                    plan.add(migration)\n+        return list(plan)",
      "comment": "if i understand correctly , `list` take O(n). if there is large plan then converting it list might add some overhead. Although this is just my assumptions , i might be totally wrong here.",
      "comment_id": 2703521706,
      "user": "p-r-a-v-i-n",
      "created_at": "2026-01-19T07:24:00Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2703521706"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,12 +306,13 @@ def _nodes_and_edges(self):\n         )\n \n     def _generate_plan(self, nodes, at_end):\n-        plan = []\n+        plan = OrderedSet()\n+        nodes_set = set(nodes)  # Convert to set for O(1) membership testing\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n-                    plan.append(migration)\n-        return plan\n+                if migration not in plan and (at_end or migration not in nodes_set):\n+                    plan.add(migration)\n+        return list(plan)",
      "comment": "It's a private method only used in one place, so agreed that we could just change this to return the `OrderedSet` directly. I'd only suggested the making it a list again to maintain the existing return type, but it's not compulsory - I just hadn't looked.",
      "comment_id": 2704257088,
      "user": "ngnpope",
      "created_at": "2026-01-19T10:56:28Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2704257088"
    },
    {
      "repo": "django/django",
      "pr_number": 20543,
      "file_path": "django/db/migrations/graph.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,12 +306,13 @@ def _nodes_and_edges(self):\n         )\n \n     def _generate_plan(self, nodes, at_end):\n-        plan = []\n+        plan = OrderedSet()\n+        nodes_set = set(nodes)  # Convert to set for O(1) membership testing\n         for node in nodes:\n             for migration in self.forwards_plan(node):\n-                if migration not in plan and (at_end or migration not in nodes):\n-                    plan.append(migration)\n-        return plan\n+                if migration not in plan and (at_end or migration not in nodes_set):\n+                    plan.add(migration)\n+        return list(plan)",
      "comment": "If we were to go down this path, `_generate_plan` is already so narrowly scoped that we could inline it into `make_state` and avoid the extra method call altogether. That said, this is starting to feel like yak shaving.\r\n\r\nI think we should merge the changes that demonstrate a clear and measurable performance improvement, and avoid those that do not move the benchmark numbers. This is consistent with Django's general practice of avoiding optimization-driven code changes unless the gains are documented and significant.",
      "comment_id": 2705540449,
      "user": "nessita",
      "created_at": "2026-01-19T16:56:31Z",
      "url": "https://github.com/django/django/pull/20543#discussion_r2705540449"
    },
    {
      "repo": "django/django",
      "pr_number": 20309,
      "file_path": "django/db/models/expressions.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,7 +29,10 @@ def as_sqlite(self, compiler, connection, **extra_context):\n         sql, params = self.as_sql(compiler, connection, **extra_context)\n         try:\n             if self.output_field.get_internal_type() == \"DecimalField\":\n-                sql = \"(CAST(%s AS NUMERIC))\" % sql\n+                if isinstance(self, Value) and isinstance(self.value, Decimal):",
      "comment": "Instead of adding an if/else switch here, did you consider just implementing `Value.as_sqlite()` and removing this mixin from that class?",
      "comment_id": 2698862894,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-16T15:03:45Z",
      "url": "https://github.com/django/django/pull/20309#discussion_r2698862894"
    },
    {
      "repo": "django/django",
      "pr_number": 20309,
      "file_path": "tests/expressions/test_sqlite.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from decimal import Decimal\n+from unittest import skipUnless\n+\n+from django.db import connection\n+from django.db.models import DecimalField, F, Value\n+from django.db.models.sql import Query\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class SQLiteDecimalExpressionsTests(TestCase):\n+    # Ensures the test only runs on SQLite.\n+    @skipUnless(connection.vendor == \"sqlite\", \"SQLite-only test\")\n+    def test_literal_value_decimal_cast_to_real(self):\n+        expr = Value(Decimal(\"3.0\"), output_field=DecimalField())\n+\n+        # We must use compiler.compile() so that Django looks for 'as_sqlite'\n+        compiler = connection.ops.compiler(\"SQLCompiler\")(Query(None), connection, None)\n+        sql, params = compiler.compile(expr.resolve_expression(Query(None)))\n+\n+        # Verify that the SQL is generated with CAST(... AS REAL)\n+        self.assertIn(\"CAST(\", sql)\n+        self.assertIn(\"AS REAL)\", sql)\n+        self.assertNotIn(\"AS NUMERIC\", sql)\n+\n+    def test_decimal_division_behavior(self):\n+        \"\"\"\n+        Verify that division with a literal Decimal value preserves precision",
      "comment": "We avoid preambles like \"verify\" in test docstrings.",
      "comment_id": 2698880947,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-16T15:08:01Z",
      "url": "https://github.com/django/django/pull/20309#discussion_r2698880947"
    },
    {
      "repo": "django/django",
      "pr_number": 20309,
      "file_path": "tests/expressions/test_sqlite.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from decimal import Decimal\n+from unittest import skipUnless\n+\n+from django.db import connection\n+from django.db.models import DecimalField, F, Value\n+from django.db.models.sql import Query\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class SQLiteDecimalExpressionsTests(TestCase):\n+    # Ensures the test only runs on SQLite.\n+    @skipUnless(connection.vendor == \"sqlite\", \"SQLite-only test\")\n+    def test_literal_value_decimal_cast_to_real(self):\n+        expr = Value(Decimal(\"3.0\"), output_field=DecimalField())\n+\n+        # We must use compiler.compile() so that Django looks for 'as_sqlite'\n+        compiler = connection.ops.compiler(\"SQLCompiler\")(Query(None), connection, None)\n+        sql, params = compiler.compile(expr.resolve_expression(Query(None)))\n+\n+        # Verify that the SQL is generated with CAST(... AS REAL)\n+        self.assertIn(\"CAST(\", sql)\n+        self.assertIn(\"AS REAL)\", sql)\n+        self.assertNotIn(\"AS NUMERIC\", sql)",
      "comment": "As @bkline mentioned, we usually avoid asserting over the underlying SQL. The other test should be sufficient.",
      "comment_id": 2698885469,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-16T15:09:08Z",
      "url": "https://github.com/django/django/pull/20309#discussion_r2698885469"
    },
    {
      "repo": "django/django",
      "pr_number": 20309,
      "file_path": "tests/expressions/test_sqlite.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from decimal import Decimal\n+from unittest import skipUnless\n+\n+from django.db import connection\n+from django.db.models import DecimalField, F, Value\n+from django.db.models.sql import Query\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class SQLiteDecimalExpressionsTests(TestCase):\n+    # Ensures the test only runs on SQLite.\n+    @skipUnless(connection.vendor == \"sqlite\", \"SQLite-only test\")\n+    def test_literal_value_decimal_cast_to_real(self):\n+        expr = Value(Decimal(\"3.0\"), output_field=DecimalField())\n+\n+        # We must use compiler.compile() so that Django looks for 'as_sqlite'\n+        compiler = connection.ops.compiler(\"SQLCompiler\")(Query(None), connection, None)\n+        sql, params = compiler.compile(expr.resolve_expression(Query(None)))\n+\n+        # Verify that the SQL is generated with CAST(... AS REAL)\n+        self.assertIn(\"CAST(\", sql)\n+        self.assertIn(\"AS REAL)\", sql)\n+        self.assertNotIn(\"AS NUMERIC\", sql)\n+\n+    def test_decimal_division_behavior(self):\n+        \"\"\"\n+        Verify that division with a literal Decimal value preserves precision\n+        on SQLite (i.e., it behaves like float division, not integer division).",
      "comment": "I think we want this test to run on all backends. So instead of placing it in a `test_sqlite` file, can you place it right after the test that was added for this casting behavior in the first place, i.e. right after `test_filter_decimal_annotation()`?",
      "comment_id": 2698895065,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-16T15:11:40Z",
      "url": "https://github.com/django/django/pull/20309#discussion_r2698895065"
    },
    {
      "repo": "django/django",
      "pr_number": 20309,
      "file_path": "tests/expressions/test_sqlite.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from decimal import Decimal\n+from unittest import skipUnless\n+\n+from django.db import connection\n+from django.db.models import DecimalField, F, Value\n+from django.db.models.sql import Query\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class SQLiteDecimalExpressionsTests(TestCase):\n+    # Ensures the test only runs on SQLite.\n+    @skipUnless(connection.vendor == \"sqlite\", \"SQLite-only test\")\n+    def test_literal_value_decimal_cast_to_real(self):\n+        expr = Value(Decimal(\"3.0\"), output_field=DecimalField())\n+\n+        # We must use compiler.compile() so that Django looks for 'as_sqlite'\n+        compiler = connection.ops.compiler(\"SQLCompiler\")(Query(None), connection, None)\n+        sql, params = compiler.compile(expr.resolve_expression(Query(None)))\n+\n+        # Verify that the SQL is generated with CAST(... AS REAL)\n+        self.assertIn(\"CAST(\", sql)\n+        self.assertIn(\"AS REAL)\", sql)\n+        self.assertNotIn(\"AS NUMERIC\", sql)\n+\n+    def test_decimal_division_behavior(self):\n+        \"\"\"\n+        Verify that division with a literal Decimal value preserves precision\n+        on SQLite (i.e., it behaves like float division, not integer division).\n+        \"\"\"\n+        Number.objects.create(integer=2)\n+        # Expected behavior: Result is ~0.6667 (float/real division)\n+        obj = Number.objects.annotate(\n+            val=F(\"integer\") / Value(Decimal(\"3.0\"), output_field=DecimalField())\n+        ).first()\n+        self.assertAlmostEqual(obj.val, Decimal(\"0.6666666666666667\"), places=4)",
      "comment": "If we're only comparing four places, I'd adjust the second arg to use four places.",
      "comment_id": 2698915464,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-16T15:17:03Z",
      "url": "https://github.com/django/django/pull/20309#discussion_r2698915464"
    },
    {
      "repo": "django/django",
      "pr_number": 20309,
      "file_path": "tests/expressions/test_sqlite.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from decimal import Decimal\n+from unittest import skipUnless\n+\n+from django.db import connection\n+from django.db.models import DecimalField, F, Value\n+from django.db.models.sql import Query\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class SQLiteDecimalExpressionsTests(TestCase):\n+    # Ensures the test only runs on SQLite.\n+    @skipUnless(connection.vendor == \"sqlite\", \"SQLite-only test\")\n+    def test_literal_value_decimal_cast_to_real(self):\n+        expr = Value(Decimal(\"3.0\"), output_field=DecimalField())\n+\n+        # We must use compiler.compile() so that Django looks for 'as_sqlite'\n+        compiler = connection.ops.compiler(\"SQLCompiler\")(Query(None), connection, None)\n+        sql, params = compiler.compile(expr.resolve_expression(Query(None)))\n+\n+        # Verify that the SQL is generated with CAST(... AS REAL)\n+        self.assertIn(\"CAST(\", sql)\n+        self.assertIn(\"AS REAL)\", sql)\n+        self.assertNotIn(\"AS NUMERIC\", sql)\n+\n+    def test_decimal_division_behavior(self):\n+        \"\"\"\n+        Verify that division with a literal Decimal value preserves precision\n+        on SQLite (i.e., it behaves like float division, not integer division).",
      "comment": "Hi, @jacobtylerwalls. The original ticket was not specific to SQLite (the original reporter was using PostgreSQL), but the ticket was repurposed (based on an interpretation of what @sarahboyce intended in the comment she posted December 20, 2024 when the ticket was accepted) narrowing it to the SQLite back end. Should we restore the broader focus of the ticket? I don't believe the new test will pass with PostgreSQL unless the PR is expanded (in the direction of the previous PR which was rejected).",
      "comment_id": 2699035518,
      "user": "bkline",
      "created_at": "2026-01-16T15:48:22Z",
      "url": "https://github.com/django/django/pull/20309#discussion_r2699035518"
    },
    {
      "repo": "django/django",
      "pr_number": 20309,
      "file_path": "tests/expressions/test_sqlite.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from decimal import Decimal\n+from unittest import skipUnless\n+\n+from django.db import connection\n+from django.db.models import DecimalField, F, Value\n+from django.db.models.sql import Query\n+from django.test import TestCase\n+\n+from .models import Number\n+\n+\n+class SQLiteDecimalExpressionsTests(TestCase):\n+    # Ensures the test only runs on SQLite.\n+    @skipUnless(connection.vendor == \"sqlite\", \"SQLite-only test\")\n+    def test_literal_value_decimal_cast_to_real(self):\n+        expr = Value(Decimal(\"3.0\"), output_field=DecimalField())\n+\n+        # We must use compiler.compile() so that Django looks for 'as_sqlite'\n+        compiler = connection.ops.compiler(\"SQLCompiler\")(Query(None), connection, None)\n+        sql, params = compiler.compile(expr.resolve_expression(Query(None)))\n+\n+        # Verify that the SQL is generated with CAST(... AS REAL)\n+        self.assertIn(\"CAST(\", sql)\n+        self.assertIn(\"AS REAL)\", sql)\n+        self.assertNotIn(\"AS NUMERIC\", sql)\n+\n+    def test_decimal_division_behavior(self):\n+        \"\"\"\n+        Verify that division with a literal Decimal value preserves precision\n+        on SQLite (i.e., it behaves like float division, not integer division).",
      "comment": "This test as written passes on postgres (and currently runs on postgres; there is no skip decorator on it).",
      "comment_id": 2699104906,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-16T16:07:05Z",
      "url": "https://github.com/django/django/pull/20309#discussion_r2699104906"
    },
    {
      "repo": "django/django",
      "pr_number": 20309,
      "file_path": "django/db/models/expressions.py",
      "line": 1185,
      "side": "RIGHT",
      "diff_hunk": "@@ -1182,6 +1182,18 @@ def as_sql(self, compiler, connection):\n             return \"NULL\", []\n         return \"%s\", [val]\n \n+    def as_sqlite(self, compiler, connection, **extra_context):",
      "comment": "Thanks, I think this is a good idea for now given that we are checking `self.value` below. We may find similar edge cases with the other expressions that would involve different kinds of introspection `self.cases`, `self.source_expressions`, etc., but we can cross that bridge later.",
      "comment_id": 2704961829,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T14:18:05Z",
      "url": "https://github.com/django/django/pull/20309#discussion_r2704961829"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "tests/sites_framework/migrations/0002_alter_customarticle_managers_and_more.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+# Generated by Django 6.1.dev20251225180557 on 2025-12-25 18:51",
      "comment": "Since these are tests, instead of adding new migration files, you can just edit the prior migrations.",
      "comment_id": 2682732352,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-12T15:19:39Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2682732352"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "scripts/check_migrations.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+import sys\n+from pathlib import Path\n+\n+import django\n+from django.apps import apps\n+from django.conf import settings\n+from django.core.management import call_command\n+\n+\n+def main():\n+    repo_root = Path(__file__).resolve().parent.parent\n+    sys.path[:0] = [str(repo_root / \"tests\"), str(repo_root)]\n+    from runtests import ALWAYS_INSTALLED_APPS, get_apps_to_install, get_test_modules\n+\n+    if not settings.configured:\n+        settings.configure(\n+            INSTALLED_APPS=ALWAYS_INSTALLED_APPS,\n+            MIGRATION_MODULES={},\n+        )\n+        django.setup()\n+\n+    test_modules = list(get_test_modules(gis_enabled=False))\n+    installed_apps = list(ALWAYS_INSTALLED_APPS)\n+    for app in get_apps_to_install(test_modules):\n+        # Check against the list to prevent duplicate error\n+        if app not in installed_apps:\n+            installed_apps.append(app)\n+    apps.set_installed_apps(installed_apps)\n+\n+    try:\n+        call_command(\"makemigrations\", \"--check\", verbosity=1)",
      "comment": "Running this locally I got unexpected success because the database was `django.db.backends.dummy`.",
      "comment_id": 2682775826,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-12T15:29:37Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2682775826"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "scripts/check_migrations.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+import sys\n+from pathlib import Path\n+\n+import django\n+from django.apps import apps\n+from django.conf import settings\n+from django.core.management import call_command\n+\n+\n+def main():\n+    repo_root = Path(__file__).resolve().parent.parent\n+    sys.path[:0] = [str(repo_root / \"tests\"), str(repo_root)]\n+    from runtests import ALWAYS_INSTALLED_APPS, get_apps_to_install, get_test_modules\n+\n+    if not settings.configured:\n+        settings.configure(\n+            INSTALLED_APPS=ALWAYS_INSTALLED_APPS,\n+            MIGRATION_MODULES={},\n+        )\n+        django.setup()\n+\n+    test_modules = list(get_test_modules(gis_enabled=False))\n+    installed_apps = list(ALWAYS_INSTALLED_APPS)\n+    for app in get_apps_to_install(test_modules):\n+        # Check against the list to prevent duplicate error\n+        if app not in installed_apps:\n+            installed_apps.append(app)\n+    apps.set_installed_apps(installed_apps)\n+\n+    try:\n+        call_command(\"makemigrations\", \"--check\", verbosity=1)",
      "comment": "I'd add a comment that the reason we aren't using `check=True` is that `--check` directly calls `sys.exit(1)` instead of raising `CommandError`, which was a little unintuitive for me.",
      "comment_id": 2682825236,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-12T15:40:48Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2682825236"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "scripts/check_migrations.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import sys\n+from pathlib import Path\n+\n+\n+def main():\n+    repo_root = Path(__file__).resolve().parent.parent\n+    sys.path[:0] = [str(repo_root / \"tests\"), str(repo_root)]\n+\n+    from runtests import ALWAYS_INSTALLED_APPS, get_apps_to_install, get_test_modules\n+\n+    import django\n+    from django.apps import apps\n+    from django.core.management import call_command\n+\n+    django.setup()\n+\n+    test_modules = list(get_test_modules(gis_enabled=False))",
      "comment": "I think we should run with `gis_enabled=True`, as I have several more failures:\n\n```py\nMigrations for 'gis_migrations':\n  tests/gis_tests/gis_migrations/migrations/0003_remove_household_family_delete_heatmap_and_more.py\n    - Remove field family from household\n    - Delete model Heatmap\n    - Remove field neighborhood from household\n    - Delete model Family\n    - Delete model Household\n    - Delete model Neighborhood\nMigrations for 'rasterapp':\n  tests/gis_tests/rasterapp/migrations/0003_alter_rastermodel_id_alter_rasterrelatedmodel_id.py\n    ~ Alter field id on rastermodel\n    ~ Alter field id on rasterrelatedmodel\n```\n\nYou could borrow the CI config in the `postgis.yml`.",
      "comment_id": 2704899086,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T14:02:54Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2704899086"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "scripts/check_migrations.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import sys\n+from pathlib import Path\n+\n+\n+def main():\n+    repo_root = Path(__file__).resolve().parent.parent\n+    sys.path[:0] = [str(repo_root / \"tests\"), str(repo_root)]\n+\n+    from runtests import ALWAYS_INSTALLED_APPS, get_apps_to_install, get_test_modules\n+\n+    import django\n+    from django.apps import apps\n+    from django.core.management import call_command\n+\n+    django.setup()\n+\n+    test_modules = list(get_test_modules(gis_enabled=False))\n+    installed_apps = list(ALWAYS_INSTALLED_APPS)\n+    for app in get_apps_to_install(test_modules):\n+        # Check against the list to prevent duplicate error\n+        if app not in installed_apps:\n+            installed_apps.append(app)\n+    apps.set_installed_apps(installed_apps)\n+\n+    # Note: We don't use check=True here because --check calls sys.exit(1)\n+    # instead of raising CommandError when migrations are missing\n+    call_command(\"makemigrations\", \"--check\", verbosity=1)",
      "comment": "verbosity=3 would be a nice convenience, so that when this fails on CI you don't have to re-run it manually to get the changes.",
      "comment_id": 2704904951,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T14:04:20Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2704904951"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "scripts/check_migrations.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import sys\n+from pathlib import Path\n+\n+\n+def main():\n+    repo_root = Path(__file__).resolve().parent.parent\n+    sys.path[:0] = [str(repo_root / \"tests\"), str(repo_root)]\n+\n+    from runtests import ALWAYS_INSTALLED_APPS, get_apps_to_install, get_test_modules\n+\n+    import django\n+    from django.apps import apps\n+    from django.core.management import call_command\n+\n+    django.setup()\n+\n+    test_modules = list(get_test_modules(gis_enabled=False))",
      "comment": "Ah, well, on second look it looks like for the `gis_migrations` case there might be too much variance between GIS backends, plus the dynamic way the tests in `test_operations.py` are written. So maybe it's okay to leave this as is.\n\nWe could still fold in the fixes for `rasterapp`, though? \ud83e\udd14 ",
      "comment_id": 2704922159,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T14:08:33Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2704922159"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "scripts/check_migrations.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import sys\n+from pathlib import Path\n+\n+\n+def main():\n+    repo_root = Path(__file__).resolve().parent.parent\n+    sys.path[:0] = [str(repo_root / \"tests\"), str(repo_root)]\n+\n+    from runtests import ALWAYS_INSTALLED_APPS, get_apps_to_install, get_test_modules\n+\n+    import django\n+    from django.apps import apps\n+    from django.core.management import call_command\n+\n+    django.setup()\n+\n+    test_modules = list(get_test_modules(gis_enabled=True))",
      "comment": "Looks like we can't do this, see https://github.com/django/django/pull/20466#discussion_r2704922159.",
      "comment_id": 2705421314,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T16:29:53Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2705421314"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "scripts/check_migrations.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import sys\n+from pathlib import Path\n+\n+\n+def main():\n+    repo_root = Path(__file__).resolve().parent.parent\n+    sys.path[:0] = [str(repo_root / \"tests\"), str(repo_root)]\n+\n+    from runtests import ALWAYS_INSTALLED_APPS, get_apps_to_install, get_test_modules\n+\n+    import django\n+    from django.apps import apps\n+    from django.core.management import call_command\n+\n+    django.setup()\n+\n+    test_modules = list(get_test_modules(gis_enabled=True))",
      "comment": "Yes , I was trying if this is possible . Migrations can be fixed by adding \r\n\r\n```\r\n\r\nif connection.features.supports_raster:\r\n    ops.insert(1, migrations.DeleteModel(name=\"Heatmap\"))\r\n\r\n```\r\n\r\nas Heatmap has \"supports_raster\"  in 0002 migration file \r\nand changing a test case (checking the deleted model) . \r\n\r\nShould I add this or let ``` gis_enabled = False ``` ?",
      "comment_id": 2705445137,
      "user": "Skyiesac",
      "created_at": "2026-01-19T16:34:22Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2705445137"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "scripts/check_migrations.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import sys\n+from pathlib import Path\n+\n+\n+def main():\n+    repo_root = Path(__file__).resolve().parent.parent\n+    sys.path[:0] = [str(repo_root / \"tests\"), str(repo_root)]\n+\n+    from runtests import ALWAYS_INSTALLED_APPS, get_apps_to_install, get_test_modules\n+\n+    import django\n+    from django.apps import apps\n+    from django.core.management import call_command\n+\n+    django.setup()\n+\n+    test_modules = list(get_test_modules(gis_enabled=True))",
      "comment": "Can you tell me a little more about that idea? My understanding was that we don't have a python model for `Neighborhood` anywhere, so I would expect the `makemigrations --check` to be a poor fit for that test paradigm.",
      "comment_id": 2705526307,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T16:51:44Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2705526307"
    },
    {
      "repo": "django/django",
      "pr_number": 20466,
      "file_path": "scripts/check_migrations.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,31 @@\n+import sys\n+from pathlib import Path\n+\n+\n+def main():\n+    repo_root = Path(__file__).resolve().parent.parent\n+    sys.path[:0] = [str(repo_root / \"tests\"), str(repo_root)]\n+\n+    from runtests import ALWAYS_INSTALLED_APPS, get_apps_to_install, get_test_modules\n+\n+    import django\n+    from django.apps import apps\n+    from django.core.management import call_command\n+\n+    django.setup()\n+\n+    test_modules = list(get_test_modules(gis_enabled=True))",
      "comment": "Oh, my bad , Got it ! I've removed gis tests entirely . Thankyou for clarity .",
      "comment_id": 2705568329,
      "user": "Skyiesac",
      "created_at": "2026-01-19T17:06:47Z",
      "url": "https://github.com/django/django/pull/20466#discussion_r2705568329"
    },
    {
      "repo": "django/django",
      "pr_number": 20515,
      "file_path": "tests/gis_tests/gdal_tests/test_driver.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,7 +9,7 @@\n     \"MapInfo File\",\n     \"S57\",\n     \"DGN\",\n-    \"Memory\",\n+    \"Memory\" if GDAL_VERSION <= (3, 10) else \"MEM\",",
      "comment": "@smithdc1 do you know what GDAL 3.10.3 returns, is it `(3, 10)` or `(3, 10, 3)`?",
      "comment_id": 2699531729,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-16T18:20:02Z",
      "url": "https://github.com/django/django/pull/20515#discussion_r2699531729"
    },
    {
      "repo": "django/django",
      "pr_number": 20515,
      "file_path": "tests/gis_tests/gdal_tests/test_driver.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,7 +9,7 @@\n     \"MapInfo File\",\n     \"S57\",\n     \"DGN\",\n-    \"Memory\",\n+    \"Memory\" if GDAL_VERSION <= (3, 10) else \"MEM\",",
      "comment": "Ah. Well, 3.11.3 returns `(3, 11, 3)` so I'm going to take a punt that the 3.10 series does the same thing. \r\n\r\nHappy to provide a fix but I'm wondering if it is worth it? It's only deprecated, not removed. So anyone running 3.10 will still see the tests pass but may notice a log. But given logs are silenced by default, most folk will have trouble spotting it. \r\n\r\n",
      "comment_id": 2701111277,
      "user": "smithdc1",
      "created_at": "2026-01-17T13:34:19Z",
      "url": "https://github.com/django/django/pull/20515#discussion_r2701111277"
    },
    {
      "repo": "django/django",
      "pr_number": 20515,
      "file_path": "tests/gis_tests/gdal_tests/test_driver.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,7 +9,7 @@\n     \"MapInfo File\",\n     \"S57\",\n     \"DGN\",\n-    \"Memory\",\n+    \"Memory\" if GDAL_VERSION <= (3, 10) else \"MEM\",",
      "comment": "I'm not so concerned about unnecessary use of `Memory`, I'm moreso wondering about too early use of `MEM` on 3.10.x. Does it still work on 3.10.x? From your link, it looks like not.",
      "comment_id": 2703121789,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-19T03:46:28Z",
      "url": "https://github.com/django/django/pull/20515#discussion_r2703121789"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_state/test_memory_leak.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,33 @@\n+import gc\n+import weakref\n+\n+from django.db import models\n+from django.test import SimpleTestCase\n+\n+\n+class CycleParent(models.Model):\n+    pass\n+\n+\n+class CycleChild(models.Model):\n+    parent = models.OneToOneField(CycleParent, on_delete=models.CASCADE)\n+\n+\n+class ModelStateMemoryTests(SimpleTestCase):\n+    def test_cycle_collection(self):\n+        \"\"\"\n+        Ensure that OneToOneField cycles are collected by the GC.\n+        \"\"\"",
      "comment": "You can remove this in favor of a more descriptive method title mentioning one_to_one (or o2o) fields.",
      "comment_id": 2599623908,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-08T18:11:52Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2599623908"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_state/test_memory_leak.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,33 @@\n+import gc\n+import weakref\n+\n+from django.db import models\n+from django.test import SimpleTestCase\n+\n+\n+class CycleParent(models.Model):\n+    pass\n+\n+\n+class CycleChild(models.Model):\n+    parent = models.OneToOneField(CycleParent, on_delete=models.CASCADE)\n+\n+\n+class ModelStateMemoryTests(SimpleTestCase):\n+    def test_cycle_collection(self):\n+        \"\"\"\n+        Ensure that OneToOneField cycles are collected by the GC.\n+        \"\"\"\n+        p = CycleParent()\n+        c = CycleChild(parent=p)\n+\n+        p_ref = weakref.ref(p)\n+        c_ref = weakref.ref(c)\n+\n+        del p\n+        del c\n+\n+        gc.collect()\n+\n+        self.assertIsNone(p_ref(), \"Parent should be garbage collected\")",
      "comment": "This test doesn't fail when I revert your changes. You might be able to draw inspiration from this:\n\nhttps://github.com/django/django/blob/334308efae8e0c7b1523d5583af32b674a098eba/tests/select_related/tests.py#L63-L72",
      "comment_id": 2599634613,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-08T18:16:11Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2599634613"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_state/test_memory_leak.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,33 @@\n+import gc\n+import weakref\n+\n+from django.db import models\n+from django.test import SimpleTestCase\n+\n+\n+class CycleParent(models.Model):\n+    pass\n+\n+\n+class CycleChild(models.Model):\n+    parent = models.OneToOneField(CycleParent, on_delete=models.CASCADE)\n+\n+\n+class ModelStateMemoryTests(SimpleTestCase):",
      "comment": "Please move this test to tests/model_regress/test_state.py",
      "comment_id": 2599643979,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-08T18:18:46Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2599643979"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_state/test_memory_leak.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,33 @@\n+import gc\n+import weakref\n+\n+from django.db import models\n+from django.test import SimpleTestCase\n+\n+\n+class CycleParent(models.Model):\n+    pass\n+\n+\n+class CycleChild(models.Model):\n+    parent = models.OneToOneField(CycleParent, on_delete=models.CASCADE)\n+\n+\n+class ModelStateMemoryTests(SimpleTestCase):\n+    def test_cycle_collection(self):\n+        \"\"\"\n+        Ensure that OneToOneField cycles are collected by the GC.\n+        \"\"\"\n+        p = CycleParent()\n+        c = CycleChild(parent=p)\n+\n+        p_ref = weakref.ref(p)\n+        c_ref = weakref.ref(c)\n+\n+        del p\n+        del c\n+\n+        gc.collect()\n+\n+        self.assertIsNone(p_ref(), \"Parent should be garbage collected\")",
      "comment": "I am really sorry, I saw the test passing and got excited and forgot to check for the main scenario I was writing the test.\r\nI have written the test again and verified it is failing now before the fix and passing after the fix ",
      "comment_id": 2599764195,
      "user": "Samriddha9619",
      "created_at": "2025-12-08T18:53:04Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2599764195"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_regress/test_state.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,36 @@\n+import gc\n+\n from django.db.models.base import ModelState, ModelStateFieldsCacheDescriptor\n from django.test import SimpleTestCase\n \n+from .models import CycleChild, CycleParent\n+\n \n class ModelStateTests(SimpleTestCase):\n     def test_fields_cache_descriptor(self):\n         self.assertIsInstance(ModelState.fields_cache, ModelStateFieldsCacheDescriptor)\n+\n+    def test_one_to_one_field_cycle_collection(self):\n+        \"\"\"\n+        Ensure OneToOneField intermediate state does not create reference\n+        cycles during model initialization.\n+        \"\"\"\n+        self.addCleanup(gc.set_debug, gc.get_debug())\n+        gc.set_debug(gc.DEBUG_SAVEALL)\n+\n+        gc.collect()",
      "comment": "Please use the `garbage_collect()` helper from `django.test.utils`.",
      "comment_id": 2600172943,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-08T21:17:48Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2600172943"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_regress/test_state.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,36 @@\n+import gc\n+\n from django.db.models.base import ModelState, ModelStateFieldsCacheDescriptor\n from django.test import SimpleTestCase\n \n+from .models import CycleChild, CycleParent\n+\n \n class ModelStateTests(SimpleTestCase):\n     def test_fields_cache_descriptor(self):\n         self.assertIsInstance(ModelState.fields_cache, ModelStateFieldsCacheDescriptor)\n+\n+    def test_one_to_one_field_cycle_collection(self):\n+        \"\"\"\n+        Ensure OneToOneField intermediate state does not create reference\n+        cycles during model initialization.\n+        \"\"\"",
      "comment": "```suggestion\n```\nThanks for the method name change. Now we can lose the docstring (we avoid \"Ensure ...\" preambles anyway.)",
      "comment_id": 2600180316,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-08T21:21:01Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2600180316"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_regress/test_state.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,36 @@\n+import gc\n+\n from django.db.models.base import ModelState, ModelStateFieldsCacheDescriptor\n from django.test import SimpleTestCase\n \n+from .models import CycleChild, CycleParent\n+\n \n class ModelStateTests(SimpleTestCase):\n     def test_fields_cache_descriptor(self):\n         self.assertIsInstance(ModelState.fields_cache, ModelStateFieldsCacheDescriptor)\n+\n+    def test_one_to_one_field_cycle_collection(self):\n+        \"\"\"\n+        Ensure OneToOneField intermediate state does not create reference\n+        cycles during model initialization.\n+        \"\"\"\n+        self.addCleanup(gc.set_debug, gc.get_debug())\n+        gc.set_debug(gc.DEBUG_SAVEALL)\n+\n+        gc.collect()\n+        del gc.garbage[:]\n+\n+        p = CycleParent()\n+        c = CycleChild(parent=p)\n+\n+        p_id = id(p)\n+\n+        del p\n+        del c\n+\n+        gc.collect()\n+\n+        leaked = [obj for obj in gc.garbage if id(obj) == p_id]\n+\n+        self.assertEqual(leaked, [])",
      "comment": "After this test I get this warning:\n```py\nException ignored in GC shutdown:\nResourceWarning: gc: 7995 uncollectable objects at shutdown; use gc.set_debug(gc.DEBUG_UNCOLLECTABLE) to list them\n```",
      "comment_id": 2600197392,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-08T21:28:08Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2600197392"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "django/db/models/base.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -494,6 +494,10 @@ def __getstate__(self):\n         state.pop(\"peers\", None)\n         return state\n \n+    def __del__(self):\n+        if hasattr(self, \"_fields_cache\"):\n+            del self._fields_cache",
      "comment": "My question was getting at, under what conditions would `_fields_cache` be missing?",
      "comment_id": 2602570060,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-09T13:04:39Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2602570060"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_regress/test_state.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,3 +5,15 @@\n class ModelStateTests(SimpleTestCase):\n     def test_fields_cache_descriptor(self):\n         self.assertIsInstance(ModelState.fields_cache, ModelStateFieldsCacheDescriptor)\n+\n+    def test_model_state_del_clears_cache(self):",
      "comment": "This test is testing the implementation instead of the underlying issue. It would be better to polish the test you had before.",
      "comment_id": 2602572322,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-09T13:05:13Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2602572322"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "django/db/models/base.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -494,6 +494,12 @@ def __getstate__(self):\n         state.pop(\"peers\", None)\n         return state\n \n+    def __del__(self):\n+        try:\n+            self.fields_cache.clear()\n+        except AttributeError:\n+            pass",
      "comment": "Thanks for explaining -- in that case these lines are reachable, so we need a test to cover them.",
      "comment_id": 2608258954,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T21:24:50Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2608258954"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_regress/test_state.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,36 @@\n+import gc\n+\n from django.db.models.base import ModelState, ModelStateFieldsCacheDescriptor\n from django.test import SimpleTestCase\n \n+from .models import CycleChild, CycleParent\n+\n \n class ModelStateTests(SimpleTestCase):\n     def test_fields_cache_descriptor(self):\n         self.assertIsInstance(ModelState.fields_cache, ModelStateFieldsCacheDescriptor)\n+\n+    def test_one_to_one_field_cycle_collection(self):\n+        \"\"\"\n+        Ensure OneToOneField intermediate state does not create reference\n+        cycles during model initialization.\n+        \"\"\"\n+        self.addCleanup(gc.set_debug, gc.get_debug())\n+        gc.set_debug(gc.DEBUG_SAVEALL)\n+\n+        gc.collect()\n+        del gc.garbage[:]\n+\n+        p = CycleParent()\n+        c = CycleChild(parent=p)\n+\n+        p_id = id(p)\n+\n+        del p\n+        del c\n+\n+        gc.collect()\n+\n+        leaked = [obj for obj in gc.garbage if id(obj) == p_id]\n+\n+        self.assertEqual(leaked, [])",
      "comment": "Again, thanks very much for explaining. Now we need to register this as a cleanup earlier (right after garbage_collect, with `self.addCleanup`) because if the assertion fails for some reason I get the warning again.",
      "comment_id": 2608269458,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T21:27:57Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2608269458"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_regress/test_state.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,38 @@\n+import gc\n+\n from django.db.models.base import ModelState, ModelStateFieldsCacheDescriptor\n from django.test import SimpleTestCase\n+from django.test.utils import garbage_collect\n+\n+from .models import Worker, WorkerProfile\n \n \n class ModelStateTests(SimpleTestCase):\n     def test_fields_cache_descriptor(self):\n         self.assertIsInstance(ModelState.fields_cache, ModelStateFieldsCacheDescriptor)\n+\n+    def test_model_state_del_no_cache(self):\n+        state = ModelState()\n+        self.assertFalse(hasattr(state, \"_fields_cache\"))",
      "comment": "@jacobtylerwalls\r\n\r\nRegarding `_fields_cache` assignment: That was an error in my test code. The internal storage key is actually `fields_cache` . I have corrected the test to check state.`__dict__` for the correct key `(\"fields_cache\")`.\r\n\r\nReliance on `del state` alone was causing coverage gaps. I have updated the test to explicitly call state.`__del__()`. This forces the execution of the except AttributeError: pass block, ensuring 100% coverage for the teardown logic.",
      "comment_id": 2622977356,
      "user": "Samriddha9619",
      "created_at": "2025-12-16T11:55:39Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2622977356"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_regress/test_state.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,38 @@\n+import gc\n+\n from django.db.models.base import ModelState, ModelStateFieldsCacheDescriptor\n from django.test import SimpleTestCase\n+from django.test.utils import garbage_collect\n+\n+from .models import Worker, WorkerProfile\n \n \n class ModelStateTests(SimpleTestCase):\n     def test_fields_cache_descriptor(self):\n         self.assertIsInstance(ModelState.fields_cache, ModelStateFieldsCacheDescriptor)\n+\n+    def test_model_state_del_no_cache(self):\n+        state = ModelState()\n+        self.assertFalse(hasattr(state, \"_fields_cache\"))",
      "comment": "The except is still not covered. Also, please fetch the changes I pushed to your branch; you've force-pushed over them. TIP: you can use `--force-with-lease` when force pushing to ensure you get an error if there are missing changes to fetch first.",
      "comment_id": 2623360618,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T13:49:42Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2623360618"
    },
    {
      "repo": "django/django",
      "pr_number": 20380,
      "file_path": "tests/model_regress/test_state.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,37 @@\n+import gc\n+\n from django.db.models.base import ModelState, ModelStateFieldsCacheDescriptor\n from django.test import SimpleTestCase\n+from django.test.utils import garbage_collect\n+\n+from .models import Worker, WorkerProfile\n \n \n class ModelStateTests(SimpleTestCase):\n     def test_fields_cache_descriptor(self):\n         self.assertIsInstance(ModelState.fields_cache, ModelStateFieldsCacheDescriptor)\n+\n+    def test_model_state_del_no_cache(self):\n+        state = ModelState()\n+        del state",
      "comment": "Sorry, I guess this whole test method can go now, now that we're not trying to exercise some separate code path.",
      "comment_id": 2632529639,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-18T20:27:59Z",
      "url": "https://github.com/django/django/pull/20380#discussion_r2632529639"
    },
    {
      "repo": "django/django",
      "pr_number": 20524,
      "file_path": "django/contrib/admin/utils.py",
      "line": 572,
      "side": "RIGHT",
      "diff_hunk": "@@ -552,21 +552,21 @@ def construct_change_message(form, formsets, add):\n     Translations are deactivated so that strings are stored untranslated.\n     Translation happens later on LogEntry access.\n     \"\"\"\n+    change_message = []\n+    if add:\n+        change_message.append({\"added\": {}})\n     # Evaluating `form.changed_data` prior to disabling translations is\n     # required to avoid fields affected by localization from being included\n     # incorrectly, e.g. where date formats differ such as MM/DD/YYYY vs\n     # DD/MM/YYYY.\n-    changed_data = form.changed_data\n-    with translation_override(None):\n-        # Deactivate translations while fetching verbose_name for form\n-        # field labels and using `field_name`, if verbose_name is not provided.\n-        # Translations will happen later on LogEntry access.\n-        changed_field_labels = _get_changed_field_labels_from_form(form, changed_data)\n-\n-    change_message = []\n-    if add:\n-        change_message.append({\"added\": {}})\n-    elif form.changed_data:\n+    elif changed_data := form.changed_data:\n+        with translation_override(None):\n+            # Deactivate translations while fetching verbose_name for form\n+            # field labels and using `field_name`, if verbose_name is not\n+            # provided. Translations will happen later on LogEntry access.\n+            changed_field_labels = _get_changed_field_labels_from_form(\n+                form, changed_data\n+            )\n         change_message.append({\"changed\": {\"fields\": changed_field_labels}})\n     if formsets:\n         with translation_override(None):",
      "comment": "Thought: Given you mention `translation_override` is expensive, is there any way to combine these calls? It'd be nice to avoid needing to call it twice in the same call to `construct_change_message`.\n\nIt might end up being far more complex than is useful - just a thought.",
      "comment_id": 2691385394,
      "user": "RealOrangeOne",
      "created_at": "2026-01-14T17:31:03Z",
      "url": "https://github.com/django/django/pull/20524#discussion_r2691385394"
    },
    {
      "repo": "django/django",
      "pr_number": 20524,
      "file_path": "django/contrib/admin/utils.py",
      "line": 572,
      "side": "RIGHT",
      "diff_hunk": "@@ -552,21 +552,21 @@ def construct_change_message(form, formsets, add):\n     Translations are deactivated so that strings are stored untranslated.\n     Translation happens later on LogEntry access.\n     \"\"\"\n+    change_message = []\n+    if add:\n+        change_message.append({\"added\": {}})\n     # Evaluating `form.changed_data` prior to disabling translations is\n     # required to avoid fields affected by localization from being included\n     # incorrectly, e.g. where date formats differ such as MM/DD/YYYY vs\n     # DD/MM/YYYY.\n-    changed_data = form.changed_data\n-    with translation_override(None):\n-        # Deactivate translations while fetching verbose_name for form\n-        # field labels and using `field_name`, if verbose_name is not provided.\n-        # Translations will happen later on LogEntry access.\n-        changed_field_labels = _get_changed_field_labels_from_form(form, changed_data)\n-\n-    change_message = []\n-    if add:\n-        change_message.append({\"added\": {}})\n-    elif form.changed_data:\n+    elif changed_data := form.changed_data:\n+        with translation_override(None):\n+            # Deactivate translations while fetching verbose_name for form\n+            # field labels and using `field_name`, if verbose_name is not\n+            # provided. Translations will happen later on LogEntry access.\n+            changed_field_labels = _get_changed_field_labels_from_form(\n+                form, changed_data\n+            )\n         change_message.append({\"changed\": {\"fields\": changed_field_labels}})\n     if formsets:\n         with translation_override(None):",
      "comment": "I can't see a way of doing that which isn't more complex than I think it's worth\u2026",
      "comment_id": 2696443224,
      "user": "adamchainz",
      "created_at": "2026-01-16T00:31:53Z",
      "url": "https://github.com/django/django/pull/20524#discussion_r2696443224"
    },
    {
      "repo": "django/django",
      "pr_number": 19478,
      "file_path": "django/db/models/sql/query.py",
      "line": 2526,
      "side": "RIGHT",
      "diff_hunk": "@@ -2519,10 +2519,13 @@ def set_values(self, fields):\n                         annotation_names.append(f)\n                         selected[f] = f\n                     elif f in self.annotations:\n-                        raise FieldError(\n-                            f\"Cannot select the '{f}' alias. Use annotate() to \"\n-                            \"promote it.\"\n-                        )\n+                        if f not in self.annotation_select:\n+                            raise FieldError(\n+                                f\"Cannot select the '{f}' alias. Use annotate() to \"\n+                                \"promote it.\"\n+                            )",
      "comment": "Does it need to have the guard on line 2522? If it gets into the block of code in lines 2521-2526, would the guard always evaluate to true, because the condition on line 2518 has already evaluated to false?",
      "comment_id": 2118815930,
      "user": "ontowhee",
      "created_at": "2025-06-01T07:02:29Z",
      "url": "https://github.com/django/django/pull/19478#discussion_r2118815930"
    },
    {
      "repo": "django/django",
      "pr_number": 19478,
      "file_path": "django/db/models/sql/query.py",
      "line": 2526,
      "side": "RIGHT",
      "diff_hunk": "@@ -2519,10 +2519,13 @@ def set_values(self, fields):\n                         annotation_names.append(f)\n                         selected[f] = f\n                     elif f in self.annotations:\n-                        raise FieldError(\n-                            f\"Cannot select the '{f}' alias. Use annotate() to \"\n-                            \"promote it.\"\n-                        )\n+                        if f not in self.annotation_select:\n+                            raise FieldError(\n+                                f\"Cannot select the '{f}' alias. Use annotate() to \"\n+                                \"promote it.\"\n+                            )",
      "comment": "I initially misunderstood the context and ended up heading in the wrong direction. I updated it by improving the error message instead.",
      "comment_id": 2694959382,
      "user": "JaeHyuckSa",
      "created_at": "2026-01-15T15:55:50Z",
      "url": "https://github.com/django/django/pull/19478#discussion_r2694959382"
    },
    {
      "repo": "django/django",
      "pr_number": 19478,
      "file_path": "django/db/models/sql/query.py",
      "line": 2526,
      "side": "RIGHT",
      "diff_hunk": "@@ -2519,10 +2519,13 @@ def set_values(self, fields):\n                         annotation_names.append(f)\n                         selected[f] = f\n                     elif f in self.annotations:\n-                        raise FieldError(\n-                            f\"Cannot select the '{f}' alias. Use annotate() to \"\n-                            \"promote it.\"\n-                        )\n+                        if f not in self.annotation_select:\n+                            raise FieldError(\n+                                f\"Cannot select the '{f}' alias. Use annotate() to \"\n+                                \"promote it.\"\n+                            )",
      "comment": "> Is the desired solution for the ticket to have a [more helpful error message](https://code.djangoproject.com/ticket/36352#comment:11)? Or is it to allow the annotation to be referenced without raising the FieldError?\r\n> Does this require a release note for the bug fix?\r\n\r\nI\u2019ve improved the error message, and I don\u2019t think this needs a documentation update, so I left that out. (It\u2019s categorized as Cleanup/optimization, not a bug.)\r\n\r\nRef. \r\n- https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/submitting-patches/#:~:text=If%20the%20code%20adds%20a%20new%20feature%2C%20or%20modifies%20the%20behavior%20of%20an%20existing%20feature%2C%20the%20change%20should%20also%20contain%20documentation.\r\n- https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/submitting-patches/#:~:text=If%20it%E2%80%99s%20a%20bug%20that%20qualifies%20for%20a%20backport%20to%20the%20stable%20version%20of%20Django%2C%20is%20there%20a%20release%20note%20in%20docs/releases/A.B.C.txt%3F%20Bug%20fixes%20that%20will%20be%20applied%20only%20to%20the%20main%20branch%20don%E2%80%99t%20need%20a%20release%20note.",
      "comment_id": 2694989640,
      "user": "JaeHyuckSa",
      "created_at": "2026-01-15T16:00:33Z",
      "url": "https://github.com/django/django/pull/19478#discussion_r2694989640"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "django/db/backends/postgresql/features.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,6 +8,7 @@\n \n class DatabaseFeatures(BaseDatabaseFeatures):\n     minimum_database_version = (15,)\n+    max_query_params = 2**16 - 1",
      "comment": "Since the limit is only present when server-side cursors are used we should make this value a `cached_property`  that introspects `self.connection.settings_dict[\"OPTIONS\"].get(\"server_side_binding\")` and return this value if its enabled and `None` otherwise.",
      "comment_id": 2647115752,
      "user": "charettes",
      "created_at": "2025-12-25T15:21:16Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2647115752"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/backends/postgresql/test_operations.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,3 +78,26 @@ def test_prepare_join_on_clause_different_types(self):\n         self.assertEqual(\n             rhs_expr, Cast(Col(book_table, book_fk_field), author_id_field)\n         )\n+\n+    def test_bulk_batch_size(self):",
      "comment": "And then we should add a test with and without server-side cursors enabled.",
      "comment_id": 2647116043,
      "user": "charettes",
      "created_at": "2025-12-25T15:21:51Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2647116043"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "django/db/backends/postgresql/features.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,6 +8,7 @@\n \n class DatabaseFeatures(BaseDatabaseFeatures):\n     minimum_database_version = (15,)\n+    max_query_params = 2**16 - 1",
      "comment": "@charettes Thanks for the review! I've updated `max_query_params` to a `cached_property` that returns the limit only when `server_side_binding` is enabled.",
      "comment_id": 2648167464,
      "user": "JaeHyuckSa",
      "created_at": "2025-12-26T13:08:49Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2648167464"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/backends/postgresql/test_operations.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,3 +78,26 @@ def test_prepare_join_on_clause_different_types(self):\n         self.assertEqual(\n             rhs_expr, Cast(Col(book_table, book_fk_field), author_id_field)\n         )\n+\n+    def test_bulk_batch_size(self):",
      "comment": "I've updated the test to cover both cases (with and without server-side binding).",
      "comment_id": 2648171063,
      "user": "JaeHyuckSa",
      "created_at": "2025-12-26T13:10:43Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2648171063"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "django/db/backends/postgresql/operations.py",
      "line": 408,
      "side": "RIGHT",
      "diff_hunk": "@@ -403,3 +404,16 @@ def prepare_join_on_clause(self, lhs_table, lhs_field, rhs_table, rhs_field):\n             rhs_expr = Cast(rhs_expr, lhs_field)\n \n         return lhs_expr, rhs_expr\n+\n+    def bulk_batch_size(self, fields, objs):",
      "comment": "We have similar code for oracle & sqlite. I wonder if we should hoist all 3 implementations up to a single implementation on the superclass.\n\nWe might then one day implement a sane default for MySQL, which surely won't let you send a query of unbounded size even if the parameters have no strict upper limit.",
      "comment_id": 2651096279,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-29T14:28:51Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2651096279"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "django/db/backends/postgresql/operations.py",
      "line": 408,
      "side": "RIGHT",
      "diff_hunk": "@@ -403,3 +404,16 @@ def prepare_join_on_clause(self, lhs_table, lhs_field, rhs_table, rhs_field):\n             rhs_expr = Cast(rhs_expr, lhs_field)\n \n         return lhs_expr, rhs_expr\n+\n+    def bulk_batch_size(self, fields, objs):",
      "comment": "I didn\u2019t realize this code was shared across backends. Refactoring it as you suggested does make things cleaner. Thanks , @jacobtylerwalls ",
      "comment_id": 2653106577,
      "user": "JaeHyuckSa",
      "created_at": "2025-12-30T14:19:10Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2653106577"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "django/db/backends/postgresql/features.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -151,6 +151,12 @@ def uses_server_side_binding(self):\n         options = self.connection.settings_dict[\"OPTIONS\"]\n         return is_psycopg3 and options.get(\"server_side_binding\") is True\n \n+    @cached_property\n+    def max_query_params(self):\n+        if self.connection.settings_dict[\"OPTIONS\"].get(\"server_side_binding\"):",
      "comment": "I would just delegate to `uses_server_side_binding` since the added logic is slightly different.",
      "comment_id": 2653120083,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-30T14:26:02Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2653120083"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/backends/postgresql/test_operations.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,3 +79,49 @@ def test_prepare_join_on_clause_different_types(self):\n         self.assertEqual(\n             rhs_expr, Cast(Col(book_table, book_fk_field), author_id_field)\n         )\n+\n+    def test_bulk_batch_size(self):\n+        objects = range(2**16)\n+        max_query_params = 2**16 - 1\n+        first_name_field = Person._meta.get_field(\"first_name\")\n+        last_name_field = Person._meta.get_field(\"last_name\")\n+        composite_pk = models.CompositePrimaryKey(\"first_name\", \"last_name\")\n+        composite_pk.fields = [first_name_field, last_name_field]\n+\n+        self.assertEqual(connection.ops.bulk_batch_size([], objects), len(objects))\n+\n+        # Without server-side binding.\n+        with mock.patch.object(\n+            type(connection.features),\n+            \"max_query_params\",\n+            new_callable=mock.PropertyMock,\n+            return_value=None,\n+        ):",
      "comment": "Then we could just mock `uses_server_side_binding`, which I think would improve the test a little bit.",
      "comment_id": 2653134752,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-30T14:33:04Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2653134752"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/backends/postgresql/test_operations.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,3 +79,49 @@ def test_prepare_join_on_clause_different_types(self):\n         self.assertEqual(\n             rhs_expr, Cast(Col(book_table, book_fk_field), author_id_field)\n         )\n+\n+    def test_bulk_batch_size(self):\n+        objects = range(2**16)\n+        max_query_params = 2**16 - 1\n+        first_name_field = Person._meta.get_field(\"first_name\")\n+        last_name_field = Person._meta.get_field(\"last_name\")\n+        composite_pk = models.CompositePrimaryKey(\"first_name\", \"last_name\")\n+        composite_pk.fields = [first_name_field, last_name_field]",
      "comment": "I'm starting to wonder if we should hoist these tests out of the oracle & sqlite tests and just have one base test. Then the postgres specific test only needs to test the postgres-specific part where we switch on server-side binding...",
      "comment_id": 2653144535,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-30T14:38:04Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2653144535"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/backends/postgresql/test_operations.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,3 +79,49 @@ def test_prepare_join_on_clause_different_types(self):\n         self.assertEqual(\n             rhs_expr, Cast(Col(book_table, book_fk_field), author_id_field)\n         )\n+\n+    def test_bulk_batch_size(self):\n+        objects = range(2**16)\n+        max_query_params = 2**16 - 1\n+        first_name_field = Person._meta.get_field(\"first_name\")\n+        last_name_field = Person._meta.get_field(\"last_name\")\n+        composite_pk = models.CompositePrimaryKey(\"first_name\", \"last_name\")\n+        composite_pk.fields = [first_name_field, last_name_field]\n+\n+        self.assertEqual(connection.ops.bulk_batch_size([], objects), len(objects))\n+\n+        # Without server-side binding.\n+        with mock.patch.object(\n+            type(connection.features),\n+            \"max_query_params\",\n+            new_callable=mock.PropertyMock,\n+            return_value=None,\n+        ):\n+            self.assertEqual(\n+                connection.ops.bulk_batch_size([first_name_field], objects),\n+                len(objects),\n+            )\n+\n+        # With server-side binding.\n+        with mock.patch.object(\n+            type(connection.features),\n+            \"max_query_params\",\n+            new_callable=mock.PropertyMock,\n+            return_value=max_query_params,\n+        ):\n+            self.assertEqual(\n+                connection.ops.bulk_batch_size([first_name_field], objects),\n+                max_query_params,\n+            )\n+            self.assertEqual(\n+                connection.ops.bulk_batch_size(\n+                    [first_name_field, last_name_field], objects\n+                ),\n+                max_query_params // 2,\n+            )\n+            self.assertEqual(\n+                connection.ops.bulk_batch_size(\n+                    [composite_pk, first_name_field], objects\n+                ),\n+                max_query_params // 3,\n+            )",
      "comment": "... rather than reiterate all of these assertions.",
      "comment_id": 2653145712,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-30T14:38:46Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2653145712"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "django/db/backends/base/operations.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,7 +79,19 @@ def bulk_batch_size(self, fields, objs):\n         are the fields going to be inserted in the batch, the objs contains\n         all the objects to be inserted.\n         \"\"\"\n-        return len(objs)\n+        if self.connection.features.max_query_params is None or not fields:\n+            return len(objs)\n+\n+        from django.db.models import CompositePrimaryKey",
      "comment": "I initially added this because I thought it was causing a circular import, but I had mixed it up with another file. I\u2019ve now moved the import to the top.",
      "comment_id": 2653163511,
      "user": "JaeHyuckSa",
      "created_at": "2025-12-30T14:48:22Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2653163511"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/composite_pk/tests.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -149,14 +149,14 @@ def test_in_bulk(self):\n \n     def test_in_bulk_batching(self):\n         Comment.objects.all().delete()\n-        batching_required = connection.features.max_query_params is not None\n-        expected_queries = 2 if batching_required else 1\n+        connection.features.__dict__.pop(\"max_query_params\", None)",
      "comment": "Can you tell me a little bit about this change? Was there a test isolation problem? What is the state of `connection.features` after this test?",
      "comment_id": 2653168624,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-30T14:51:01Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2653168624"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/composite_pk/tests.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -149,14 +149,14 @@ def test_in_bulk(self):\n \n     def test_in_bulk_batching(self):\n         Comment.objects.all().delete()\n-        batching_required = connection.features.max_query_params is not None\n-        expected_queries = 2 if batching_required else 1\n+        connection.features.__dict__.pop(\"max_query_params\", None)",
      "comment": "This came up because `max_query_params` was changed to a `cached_property`. Once it calculates a value, it stores it in `__dict__` and just uses that stored value from then on. So when you try to mock the value in tests, if there's already a cached value, the mock won't take effect. You need to clear the cache with `.pop()` before applying the mock for it to work properly, which is why I made that change",
      "comment_id": 2691162416,
      "user": "JaeHyuckSa",
      "created_at": "2026-01-14T16:27:29Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2691162416"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/backends/base/test_operations.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,3 +222,38 @@ def test_execute_sql_flush_statements(self):\n                 self.assertEqual(author.pk, 1)\n                 book = Book.objects.create(author=author)\n                 self.assertEqual(book.pk, 1)\n+\n+\n+class BulkBatchSizeMixin:",
      "comment": "I tweaked the test so it could still run on MySQL, allowing me to move this test into one of the above test cases and remove the mixin \ud83d\udc4d ",
      "comment_id": 2694225682,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-15T12:39:20Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2694225682"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/backends/postgresql/test_operations.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,3 +79,49 @@ def test_prepare_join_on_clause_different_types(self):\n         self.assertEqual(\n             rhs_expr, Cast(Col(book_table, book_fk_field), author_id_field)\n         )\n+\n+    def test_bulk_batch_size(self):\n+        objects = range(2**16)\n+        max_query_params = 2**16 - 1\n+        first_name_field = Person._meta.get_field(\"first_name\")\n+        last_name_field = Person._meta.get_field(\"last_name\")\n+        composite_pk = models.CompositePrimaryKey(\"first_name\", \"last_name\")\n+        composite_pk.fields = [first_name_field, last_name_field]\n+\n+        self.assertEqual(connection.ops.bulk_batch_size([], objects), len(objects))\n+\n+        # Without server-side binding.\n+        with mock.patch.object(\n+            type(connection.features),\n+            \"max_query_params\",\n+            new_callable=mock.PropertyMock,\n+            return_value=None,\n+        ):",
      "comment": "Now that the tests run on all backends, I think we no longer need this test.",
      "comment_id": 2694263000,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-15T12:50:31Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2694263000"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/backends/postgresql/test_operations.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,3 +79,49 @@ def test_prepare_join_on_clause_different_types(self):\n         self.assertEqual(\n             rhs_expr, Cast(Col(book_table, book_fk_field), author_id_field)\n         )\n+\n+    def test_bulk_batch_size(self):\n+        objects = range(2**16)\n+        max_query_params = 2**16 - 1\n+        first_name_field = Person._meta.get_field(\"first_name\")\n+        last_name_field = Person._meta.get_field(\"last_name\")\n+        composite_pk = models.CompositePrimaryKey(\"first_name\", \"last_name\")\n+        composite_pk.fields = [first_name_field, last_name_field]\n+\n+        self.assertEqual(connection.ops.bulk_batch_size([], objects), len(objects))\n+\n+        # Without server-side binding.\n+        with mock.patch.object(\n+            type(connection.features),\n+            \"max_query_params\",\n+            new_callable=mock.PropertyMock,\n+            return_value=None,\n+        ):",
      "comment": "(Actually, just to ensure we had _something_ I replaced it with a simpler one. Our CI configuration tests with server side params enabled & not enabled.)",
      "comment_id": 2694443445,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-15T13:42:35Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2694443445"
    },
    {
      "repo": "django/django",
      "pr_number": 20461,
      "file_path": "tests/backends/base/test_operations.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,3 +222,38 @@ def test_execute_sql_flush_statements(self):\n                 self.assertEqual(author.pk, 1)\n                 book = Book.objects.create(author=author)\n                 self.assertEqual(book.pk, 1)\n+\n+\n+class BulkBatchSizeMixin:",
      "comment": "Thank you for letting me know. I didn\u2019t realize there was a way to do that. I hadn\u2019t thought of writing it in SimpleDatabaseOperationTests.",
      "comment_id": 2694499746,
      "user": "JaeHyuckSa",
      "created_at": "2026-01-15T13:58:02Z",
      "url": "https://github.com/django/django/pull/20461#discussion_r2694499746"
    },
    {
      "repo": "django/django",
      "pr_number": 20460,
      "file_path": "tests/queries/tests.py",
      "line": 2284,
      "side": "RIGHT",
      "diff_hunk": "@@ -2280,6 +2280,17 @@ def test_ticket8597(self):\n             [item_ab],\n         )\n \n+    @skipUnlessDBFeature(\"interprets_empty_strings_as_nulls\")\n+    def test_empty_string_iexact_lookup(self):",
      "comment": "Thanks, this location next to case-insensitive tests makes sense, but we could also move it to `NullQueriesTests`. What do you prefer?",
      "comment_id": 2683458860,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-12T18:41:26Z",
      "url": "https://github.com/django/django/pull/20460#discussion_r2683458860"
    },
    {
      "repo": "django/django",
      "pr_number": 20460,
      "file_path": "tests/queries/tests.py",
      "line": 2284,
      "side": "RIGHT",
      "diff_hunk": "@@ -2280,6 +2280,17 @@ def test_ticket8597(self):\n             [item_ab],\n         )\n \n+    @skipUnlessDBFeature(\"interprets_empty_strings_as_nulls\")\n+    def test_empty_string_iexact_lookup(self):",
      "comment": "Thanks for the suggestion! I'll move it to `NullQueriesTests`.  Since both `None` and empty strings are converted to `IS NULL`,  it makes sense to keep them together.",
      "comment_id": 2690832225,
      "user": "JaeHyuckSa",
      "created_at": "2026-01-14T15:05:08Z",
      "url": "https://github.com/django/django/pull/20460#discussion_r2690832225"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 364,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,43 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):",
      "comment": "There is no memory leak when using an inline method in this case?",
      "comment_id": 2677999156,
      "user": "timgraham",
      "created_at": "2026-01-10T00:20:18Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2677999156"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "tests/backends/base/test_creation.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -333,6 +334,13 @@ def test_mark_expected_failures_and_skips(self):\n                 \"backends.base.test_creation.skip_test_function\",\n             },\n         }\n+",
      "comment": "I prefer not to add blank lines under the guideline that comments are better to separate any blocks that would otherwise seem to need blank lines.",
      "comment_id": 2678002877,
      "user": "timgraham",
      "created_at": "2026-01-10T00:24:21Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2678002877"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "tests/backends/base/test_creation.py",
      "line": 340,
      "side": "RIGHT",
      "diff_hunk": "@@ -333,6 +334,13 @@ def test_mark_expected_failures_and_skips(self):\n                 \"backends.base.test_creation.skip_test_function\",\n             },\n         }\n+\n+        # Emulate the scenario where the parent module for\n+        # backends.base.test_creation has not been imported yet.\n+        # This case has been problematic.",
      "comment": "As all bugs are ;-) (I think this sentence isn't needed.)",
      "comment_id": 2678003330,
      "user": "timgraham",
      "created_at": "2026-01-10T00:24:53Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2678003330"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,43 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_case = import_string(module_or_class)\n+            except ImportError:\n+                # If import_string couldn't chop the rightmost term",
      "comment": "I think it's more important to say something high-level like \"When running a subset of tests in a module, tests in that module's other submodules won't be imported by the test runner and must be manually imported to avoid a crash. The ImportError could be ignored but the second import catches nonexistent tests.\" I leave it to you about whether or not to include the implementation details you've described but it seems like it may be uneeded archaic details (about the implementation of `import_string()`, for example). ",
      "comment_id": 2678004314,
      "user": "timgraham",
      "created_at": "2026-01-10T00:26:03Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2678004314"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 369,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,43 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_case = import_string(module_or_class)\n+            except ImportError:\n+                # If import_string couldn't chop the rightmost term\n+                # and getattr() it from the remainder, it's likely that",
      "comment": "The comment wrapping looks too short to me (less than 79 characters.)",
      "comment_id": 2678010177,
      "user": "timgraham",
      "created_at": "2026-01-10T00:32:11Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2678010177"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 374,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,43 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_case = import_string(module_or_class)\n+            except ImportError:\n+                # If import_string couldn't chop the rightmost term\n+                # and getattr() it from the remainder, it's likely that\n+                # the rightmost term was a submodule, and the remainder\n+                # is a module that hasn't been imported yet.\n+                # Import the test_method by importing test_name.\n+                test_method = import_string(test_name)\n+                test_case = sys.modules.get(test_method.__module__)",
      "comment": "Oh good point. Let me look a little closer next week.",
      "comment_id": 2678202475,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-10T02:18:40Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2678202475"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 364,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,43 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):",
      "comment": "This gets called only once per test worker, so I don't think it's a meaningful number of objects. I just didn't want to clutter the module scope. Maybe I'll end up needing to hoist it up to the module to target it in a test.\r\n\r\nIt was a little early to request your review, but I'm glad I did as I need to look into your comment about unnecessary decoration.",
      "comment_id": 2678210208,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-10T02:23:34Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2678210208"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,43 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_case = import_string(module_or_class)\n+            except ImportError:\n+                # If import_string couldn't chop the rightmost term",
      "comment": "You wrote \"import_string() sometimes raises ImportError given a module.\" However, I think the comment should give an example of what \"sometimes\" means.",
      "comment_id": 2683850272,
      "user": "timgraham",
      "created_at": "2026-01-12T20:44:09Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2683850272"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,43 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_case = import_string(module_or_class)\n+            except ImportError:\n+                # If import_string couldn't chop the rightmost term",
      "comment": "Ah right. Let me know if [eff69c8](https://github.com/django/django/pull/20519/commits/eff69c8fdf351ef4612cbc1782e01be274176d25) still doesn't strike the right balance.",
      "comment_id": 2684060029,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-12T22:03:09Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2684060029"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 371,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,46 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_frame = import_string(module_or_class)\n+            except ImportError:\n+                # When given a submodule, import_string() can raise ImportError\n+                # if its parent module has not been already imported during\n+                # test discovery. Since the parallel test runner spawns workers\n+                # with a fresh import cache and then applies these skips, do",
      "comment": "\"do not expect\" seems like a verbiage change from the previous sentence. Here's my suggestion:\r\n\r\nimport_string() can raise ImportError if a submodule's parent module hasn't already been imported during test discovery. This can happen in at least two cases:\r\n1. When running a subset of tests in a module, tests in that module's other submodules won't be imported by the test runner.\r\n2. When the parallel test runner spawns workers with an empty import cache.\r\n\r\nPlease correct any details that I got wrong.\r\n",
      "comment_id": 2684070759,
      "user": "timgraham",
      "created_at": "2026-01-12T22:07:39Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2684070759"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 370,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,46 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_frame = import_string(module_or_class)\n+            except ImportError:\n+                # When given a submodule, import_string() can raise ImportError\n+                # if its parent module has not been already imported during\n+                # test discovery. Since the parallel test runner spawns workers",
      "comment": "I didn't know about the problem for the parallel test runner, and I think it's important to also describe the case I mentioned where it's not involved.",
      "comment_id": 2684073892,
      "user": "timgraham",
      "created_at": "2026-01-12T22:08:53Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2684073892"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 393,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,46 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_frame = import_string(module_or_class)\n+            except ImportError:\n+                # When given a submodule, import_string() can raise ImportError\n+                # if its parent module has not been already imported during\n+                # test discovery. Since the parallel test runner spawns workers\n+                # with a fresh import cache and then applies these skips, do\n+                # not expect import_string() to succeed for submodules.\n+                # test_name is likely a class, so import that instead.\n+                test_to_skip = import_string(test_name)\n+                test_frame = sys.modules.get(test_to_skip.__module__)\n+            else:\n+                test_to_skip = getattr(test_frame, class_or_method)\n+            return test_frame, test_to_skip\n+\n         for test_name in self.connection.features.django_test_expected_failures:\n-            test_case_name, _, test_method_name = test_name.rpartition(\".\")\n+            module_or_class_name, _, class_or_method_name = test_name.rpartition(\".\")\n             test_app = test_name.split(\".\")[0]\n             # Importing a test app that isn't installed raises RuntimeError.\n             if test_app in settings.INSTALLED_APPS:\n-                test_case = import_string(test_case_name)\n-                test_method = getattr(test_case, test_method_name)\n-                setattr(test_case, test_method_name, expectedFailure(test_method))\n+                test_frame, test_to_skip = get_test(\n+                    module_or_class_name, class_or_method_name, test_name\n+                )\n+                setattr(test_frame, class_or_method_name, expectedFailure(test_to_skip))\n         for reason, tests in self.connection.features.django_test_skips.items():\n             for test_name in tests:\n-                test_case_name, _, test_method_name = test_name.rpartition(\".\")\n+                module_or_class_name, _, class_or_method_name = test_name.rpartition(\n+                    \".\"\n+                )",
      "comment": "I hate this formatting and how other lines have to be multi-lined. I don't normally advocate for abbreviations, but I'm a bit tempted to abbreviate \"class\" -> \"cls\" if it avoids that.",
      "comment_id": 2684105502,
      "user": "timgraham",
      "created_at": "2026-01-12T22:21:54Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2684105502"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 393,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,46 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_frame = import_string(module_or_class)\n+            except ImportError:\n+                # When given a submodule, import_string() can raise ImportError\n+                # if its parent module has not been already imported during\n+                # test discovery. Since the parallel test runner spawns workers\n+                # with a fresh import cache and then applies these skips, do\n+                # not expect import_string() to succeed for submodules.\n+                # test_name is likely a class, so import that instead.\n+                test_to_skip = import_string(test_name)\n+                test_frame = sys.modules.get(test_to_skip.__module__)\n+            else:\n+                test_to_skip = getattr(test_frame, class_or_method)\n+            return test_frame, test_to_skip\n+\n         for test_name in self.connection.features.django_test_expected_failures:\n-            test_case_name, _, test_method_name = test_name.rpartition(\".\")\n+            module_or_class_name, _, class_or_method_name = test_name.rpartition(\".\")\n             test_app = test_name.split(\".\")[0]\n             # Importing a test app that isn't installed raises RuntimeError.\n             if test_app in settings.INSTALLED_APPS:\n-                test_case = import_string(test_case_name)\n-                test_method = getattr(test_case, test_method_name)\n-                setattr(test_case, test_method_name, expectedFailure(test_method))\n+                test_frame, test_to_skip = get_test(\n+                    module_or_class_name, class_or_method_name, test_name\n+                )\n+                setattr(test_frame, class_or_method_name, expectedFailure(test_to_skip))\n         for reason, tests in self.connection.features.django_test_skips.items():\n             for test_name in tests:\n-                test_case_name, _, test_method_name = test_name.rpartition(\".\")\n+                module_or_class_name, _, class_or_method_name = test_name.rpartition(\n+                    \".\"\n+                )",
      "comment": "I could also parenthesize the left-hand side. Fully agree about the lonely `\".\"`",
      "comment_id": 2684338072,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-13T00:16:14Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2684338072"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 371,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,46 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_frame = import_string(module_or_class)\n+            except ImportError:\n+                # When given a submodule, import_string() can raise ImportError\n+                # if its parent module has not been already imported during\n+                # test discovery. Since the parallel test runner spawns workers\n+                # with a fresh import cache and then applies these skips, do",
      "comment": "I like this. I applied your suggestion and removed the passive voice to fit on one fewer line.",
      "comment_id": 2687229683,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-13T16:45:13Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2687229683"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 393,
      "side": "RIGHT",
      "diff_hunk": "@@ -361,24 +361,46 @@ def mark_expected_failures_and_skips(self):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        def get_test(module_or_class, class_or_method, test_name):\n+            try:\n+                test_frame = import_string(module_or_class)\n+            except ImportError:\n+                # When given a submodule, import_string() can raise ImportError\n+                # if its parent module has not been already imported during\n+                # test discovery. Since the parallel test runner spawns workers\n+                # with a fresh import cache and then applies these skips, do\n+                # not expect import_string() to succeed for submodules.\n+                # test_name is likely a class, so import that instead.\n+                test_to_skip = import_string(test_name)\n+                test_frame = sys.modules.get(test_to_skip.__module__)\n+            else:\n+                test_to_skip = getattr(test_frame, class_or_method)\n+            return test_frame, test_to_skip\n+\n         for test_name in self.connection.features.django_test_expected_failures:\n-            test_case_name, _, test_method_name = test_name.rpartition(\".\")\n+            module_or_class_name, _, class_or_method_name = test_name.rpartition(\".\")\n             test_app = test_name.split(\".\")[0]\n             # Importing a test app that isn't installed raises RuntimeError.\n             if test_app in settings.INSTALLED_APPS:\n-                test_case = import_string(test_case_name)\n-                test_method = getattr(test_case, test_method_name)\n-                setattr(test_case, test_method_name, expectedFailure(test_method))\n+                test_frame, test_to_skip = get_test(\n+                    module_or_class_name, class_or_method_name, test_name\n+                )\n+                setattr(test_frame, class_or_method_name, expectedFailure(test_to_skip))\n         for reason, tests in self.connection.features.django_test_skips.items():\n             for test_name in tests:\n-                test_case_name, _, test_method_name = test_name.rpartition(\".\")\n+                module_or_class_name, _, class_or_method_name = test_name.rpartition(\n+                    \".\"\n+                )",
      "comment": "Took the opportunity to factor out helper methods to address this and also remove nested functions at the same time \ud83d\udc4d ",
      "comment_id": 2687231817,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-13T16:45:48Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2687231817"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 377,
      "side": "RIGHT",
      "diff_hunk": "@@ -353,32 +353,53 @@ def _destroy_test_db(self, test_database_name, verbosity):\n                 \"DROP DATABASE %s\" % self.connection.ops.quote_name(test_database_name)\n             )\n \n-    def mark_expected_failures_and_skips(self):\n+    @staticmethod\n+    def _get_test_and_frame(module_or_class, class_or_method, test_name):\n         \"\"\"\n-        Mark tests in Django's test suite which are expected failures on this\n-        database and test which should be skipped on this database.\n+        Import and return a test to skip and the module or class containing it.\n         \"\"\"\n+        try:\n+            test_frame = import_string(module_or_class)\n+        except ImportError:\n+            # import_string() can raise ImportError if a submodule's parent\n+            # module hasn't already been imported during test discovery.\n+            # This can happen in at least two cases:\n+            # 1. When running a subset of tests in a module, the test runner\n+            #    won't import tests in that module's other submodules.\n+            # 2. When the parallel test runner spawns workers with an empty\n+            #    import cache.\n+            test_to_skip = import_string(test_name)\n+            test_frame = sys.modules.get(test_to_skip.__module__)\n+        else:\n+            test_to_skip = getattr(test_frame, class_or_method)\n+        return test_frame, test_to_skip\n+\n+    def _skip_test(self, test_name, reason=None):",
      "comment": "skip -> mark (since \"mark\" could be skip or expected failure)\r\nreason -> skip_reason",
      "comment_id": 2687727509,
      "user": "timgraham",
      "created_at": "2026-01-13T19:08:52Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2687727509"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 393,
      "side": "RIGHT",
      "diff_hunk": "@@ -353,32 +353,53 @@ def _destroy_test_db(self, test_database_name, verbosity):\n                 \"DROP DATABASE %s\" % self.connection.ops.quote_name(test_database_name)\n             )\n \n-    def mark_expected_failures_and_skips(self):\n+    @staticmethod\n+    def _get_test_and_frame(module_or_class, class_or_method, test_name):\n         \"\"\"\n-        Mark tests in Django's test suite which are expected failures on this\n-        database and test which should be skipped on this database.\n+        Import and return a test to skip and the module or class containing it.\n         \"\"\"\n+        try:\n+            test_frame = import_string(module_or_class)\n+        except ImportError:\n+            # import_string() can raise ImportError if a submodule's parent\n+            # module hasn't already been imported during test discovery.\n+            # This can happen in at least two cases:\n+            # 1. When running a subset of tests in a module, the test runner\n+            #    won't import tests in that module's other submodules.\n+            # 2. When the parallel test runner spawns workers with an empty\n+            #    import cache.\n+            test_to_skip = import_string(test_name)\n+            test_frame = sys.modules.get(test_to_skip.__module__)\n+        else:\n+            test_to_skip = getattr(test_frame, class_or_method)\n+        return test_frame, test_to_skip\n+\n+    def _skip_test(self, test_name, reason=None):\n         # Only load unittest if we're actually testing.\n         from unittest import expectedFailure, skip\n \n+        module_or_class_name, _, name_to_skip = test_name.rpartition(\".\")\n+        test_app = test_name.split(\".\")[0]\n+        # Importing a test app that isn't installed raises RuntimeError.\n+        if test_app in settings.INSTALLED_APPS:\n+            test_frame, test_to_skip = self._get_test_and_frame(\n+                module_or_class_name, name_to_skip, test_name\n+            )\n+            if reason:\n+                setattr(test_frame, name_to_skip, skip(reason)(test_to_skip))\n+            else:\n+                setattr(test_frame, name_to_skip, expectedFailure(test_to_skip))\n+\n+    def mark_expected_failures_and_skips(self):",
      "comment": "Perhaps it's better to follow the pattern in the rest of this file (at least with destroy_test_db/_destroy_test_db) and put the helper methods after the method that calls them. Otherwise, it seems to give more prominence to the helpers.",
      "comment_id": 2687750804,
      "user": "timgraham",
      "created_at": "2026-01-13T19:13:42Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2687750804"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,27 +358,48 @@ def mark_expected_failures_and_skips(self):\n         Mark tests in Django's test suite which are expected failures on this\n         database and test which should be skipped on this database.\n         \"\"\"\n-        # Only load unittest if we're actually testing.\n-        from unittest import expectedFailure, skip\n-\n         for test_name in self.connection.features.django_test_expected_failures:\n-            test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-            test_app = test_name.split(\".\")[0]\n-            # Importing a test app that isn't installed raises RuntimeError.\n-            if test_app in settings.INSTALLED_APPS:\n-                test_case = import_string(test_case_name)\n-                test_method = getattr(test_case, test_method_name)\n-                setattr(test_case, test_method_name, expectedFailure(test_method))\n+            self._mark_test(test_name)\n         for reason, tests in self.connection.features.django_test_skips.items():\n             for test_name in tests:\n-                test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-                test_app = test_name.split(\".\")[0]\n-                # Importing a test app that isn't installed raises\n-                # RuntimeError.\n-                if test_app in settings.INSTALLED_APPS:\n-                    test_case = import_string(test_case_name)\n-                    test_method = getattr(test_case, test_method_name)\n-                    setattr(test_case, test_method_name, skip(reason)(test_method))\n+                self._mark_test(test_name, reason)\n+\n+    def _mark_test(self, test_name, skip_reason=None):\n+        # Only load unittest if we're actually testing.",
      "comment": "We could clean this up to follow comment guidelines (no \"we\"):  \"if we're actually\" -> \"during\"",
      "comment_id": 2688397807,
      "user": "timgraham",
      "created_at": "2026-01-13T23:03:09Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2688397807"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 377,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,27 +358,48 @@ def mark_expected_failures_and_skips(self):\n         Mark tests in Django's test suite which are expected failures on this\n         database and test which should be skipped on this database.\n         \"\"\"\n-        # Only load unittest if we're actually testing.\n-        from unittest import expectedFailure, skip\n-\n         for test_name in self.connection.features.django_test_expected_failures:\n-            test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-            test_app = test_name.split(\".\")[0]\n-            # Importing a test app that isn't installed raises RuntimeError.\n-            if test_app in settings.INSTALLED_APPS:\n-                test_case = import_string(test_case_name)\n-                test_method = getattr(test_case, test_method_name)\n-                setattr(test_case, test_method_name, expectedFailure(test_method))\n+            self._mark_test(test_name)\n         for reason, tests in self.connection.features.django_test_skips.items():\n             for test_name in tests:\n-                test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-                test_app = test_name.split(\".\")[0]\n-                # Importing a test app that isn't installed raises\n-                # RuntimeError.\n-                if test_app in settings.INSTALLED_APPS:\n-                    test_case = import_string(test_case_name)\n-                    test_method = getattr(test_case, test_method_name)\n-                    setattr(test_case, test_method_name, skip(reason)(test_method))\n+                self._mark_test(test_name, reason)\n+\n+    def _mark_test(self, test_name, skip_reason=None):\n+        # Only load unittest if we're actually testing.\n+        from unittest import expectedFailure, skip\n+\n+        module_or_class_name, _, name_to_mark = test_name.rpartition(\".\")\n+        test_app = test_name.split(\".\")[0]\n+        # Importing a test app that isn't installed raises RuntimeError.\n+        if test_app in settings.INSTALLED_APPS:\n+            test_frame, test_to_mark = self._get_test_and_frame(\n+                module_or_class_name, name_to_mark, test_name\n+            )",
      "comment": "Does it still make sense to make this a method (vs. inline the logic) even though it's only called in one place?",
      "comment_id": 2688401895,
      "user": "timgraham",
      "created_at": "2026-01-13T23:05:22Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2688401895"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 377,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,27 +358,48 @@ def mark_expected_failures_and_skips(self):\n         Mark tests in Django's test suite which are expected failures on this\n         database and test which should be skipped on this database.\n         \"\"\"\n-        # Only load unittest if we're actually testing.\n-        from unittest import expectedFailure, skip\n-\n         for test_name in self.connection.features.django_test_expected_failures:\n-            test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-            test_app = test_name.split(\".\")[0]\n-            # Importing a test app that isn't installed raises RuntimeError.\n-            if test_app in settings.INSTALLED_APPS:\n-                test_case = import_string(test_case_name)\n-                test_method = getattr(test_case, test_method_name)\n-                setattr(test_case, test_method_name, expectedFailure(test_method))\n+            self._mark_test(test_name)\n         for reason, tests in self.connection.features.django_test_skips.items():\n             for test_name in tests:\n-                test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-                test_app = test_name.split(\".\")[0]\n-                # Importing a test app that isn't installed raises\n-                # RuntimeError.\n-                if test_app in settings.INSTALLED_APPS:\n-                    test_case = import_string(test_case_name)\n-                    test_method = getattr(test_case, test_method_name)\n-                    setattr(test_case, test_method_name, skip(reason)(test_method))\n+                self._mark_test(test_name, reason)\n+\n+    def _mark_test(self, test_name, skip_reason=None):\n+        # Only load unittest if we're actually testing.\n+        from unittest import expectedFailure, skip\n+\n+        module_or_class_name, _, name_to_mark = test_name.rpartition(\".\")\n+        test_app = test_name.split(\".\")[0]\n+        # Importing a test app that isn't installed raises RuntimeError.\n+        if test_app in settings.INSTALLED_APPS:\n+            test_frame, test_to_mark = self._get_test_and_frame(\n+                module_or_class_name, name_to_mark, test_name\n+            )",
      "comment": "Ah, good point! Didn't notice that opportunity after the latest refactor \ud83d\udc4d ",
      "comment_id": 2688503727,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-14T00:06:46Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2688503727"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,27 +358,48 @@ def mark_expected_failures_and_skips(self):\n         Mark tests in Django's test suite which are expected failures on this\n         database and test which should be skipped on this database.\n         \"\"\"\n-        # Only load unittest if we're actually testing.\n-        from unittest import expectedFailure, skip\n-\n         for test_name in self.connection.features.django_test_expected_failures:\n-            test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-            test_app = test_name.split(\".\")[0]\n-            # Importing a test app that isn't installed raises RuntimeError.\n-            if test_app in settings.INSTALLED_APPS:\n-                test_case = import_string(test_case_name)\n-                test_method = getattr(test_case, test_method_name)\n-                setattr(test_case, test_method_name, expectedFailure(test_method))\n+            self._mark_test(test_name)\n         for reason, tests in self.connection.features.django_test_skips.items():\n             for test_name in tests:\n-                test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-                test_app = test_name.split(\".\")[0]\n-                # Importing a test app that isn't installed raises\n-                # RuntimeError.\n-                if test_app in settings.INSTALLED_APPS:\n-                    test_case = import_string(test_case_name)\n-                    test_method = getattr(test_case, test_method_name)\n-                    setattr(test_case, test_method_name, skip(reason)(test_method))\n+                self._mark_test(test_name, reason)\n+\n+    def _mark_test(self, test_name, skip_reason=None):\n+        # Only load unittest if we're actually testing.",
      "comment": "Yeah, I undid some edits that were no longer opportunistic once lines started moving around again, but now this is opportunistic \ud83d\udc4d ",
      "comment_id": 2688505614,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-14T00:08:03Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2688505614"
    },
    {
      "repo": "django/django",
      "pr_number": 20519,
      "file_path": "django/db/backends/base/creation.py",
      "line": 376,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,27 +358,39 @@ def mark_expected_failures_and_skips(self):\n         Mark tests in Django's test suite which are expected failures on this\n         database and test which should be skipped on this database.\n         \"\"\"\n-        # Only load unittest if we're actually testing.\n-        from unittest import expectedFailure, skip\n-\n         for test_name in self.connection.features.django_test_expected_failures:\n-            test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-            test_app = test_name.split(\".\")[0]\n-            # Importing a test app that isn't installed raises RuntimeError.\n-            if test_app in settings.INSTALLED_APPS:\n-                test_case = import_string(test_case_name)\n-                test_method = getattr(test_case, test_method_name)\n-                setattr(test_case, test_method_name, expectedFailure(test_method))\n+            self._mark_test(test_name)\n         for reason, tests in self.connection.features.django_test_skips.items():\n             for test_name in tests:\n-                test_case_name, _, test_method_name = test_name.rpartition(\".\")\n-                test_app = test_name.split(\".\")[0]\n-                # Importing a test app that isn't installed raises\n-                # RuntimeError.\n-                if test_app in settings.INSTALLED_APPS:\n-                    test_case = import_string(test_case_name)\n-                    test_method = getattr(test_case, test_method_name)\n-                    setattr(test_case, test_method_name, skip(reason)(test_method))\n+                self._mark_test(test_name, reason)\n+\n+    def _mark_test(self, test_name, skip_reason=None):\n+        # Only load unittest if we're actually testing.\n+        from unittest import expectedFailure, skip\n+\n+        module_or_class_name, _, name_to_mark = test_name.rpartition(\".\")\n+        test_app = test_name.split(\".\")[0]\n+        # Importing a test app that isn't installed raises RuntimeError.\n+        if test_app in settings.INSTALLED_APPS:\n+            try:\n+                test_frame = import_string(module_or_class_name)",
      "comment": "Now that we lost the other helper's docstring suggesting what a \"frame\" is, I'm hoping this is sort of self-explanatory if in the 1-helper version you see it's the thing having `setattr()` run on it. (?)",
      "comment_id": 2688517458,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-14T00:16:02Z",
      "url": "https://github.com/django/django/pull/20519#discussion_r2688517458"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 398,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,6 +394,8 @@ def m2m_convert(n):\n         try:\n             for c in node.getElementsByTagName(\"object\"):\n                 values.append(m2m_convert(c))\n+        except UnexpectedNode:\n+            raise",
      "comment": "There might be another one of these to filter out and raise, e.g. in `save_deferred_fields()`.",
      "comment_id": 2621138310,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-15T23:05:33Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2621138310"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,6 +35,10 @@ def fast_cache_clearing():\n             minidom._in_document = original_fn\n \n \n+class UnexpectedNode(SuspiciousOperation):",
      "comment": "I'd be more general, `SuspiciousXML` or even `SuspiciousSerialization`.\r\n\r\nBut note that, currently, AFAICT, all `SuspiciousOperation` child classes in the Django source are defined in `exceptions.py` files -- and except for those in `contrib` apps, all are in `django.core.exceptions`. I suspect we could do without a child class at all.",
      "comment_id": 2637307610,
      "user": "shaib",
      "created_at": "2025-12-20T20:12:11Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2637307610"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,7 +305,10 @@ def _handle_object(self, node):\n                 if field_node.getElementsByTagName(\"None\"):\n                     value = None\n                 else:\n-                    value = field.to_python(getInnerText(field_node).strip())\n+                    if natural_nodes := field_node.getElementsByTagName(\"natural\"):\n+                        value = field.to_python(getInnerText(natural_nodes[0]).strip())\n+                    else:\n+                        value = field.to_python(getInnerText(field_node).strip())",
      "comment": "Why give special treatment to `natural` nodes inside fields which aren't relation fields?",
      "comment_id": 2637316329,
      "user": "shaib",
      "created_at": "2025-12-20T20:24:01Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2637316329"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 397,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,6 +394,8 @@ def m2m_convert(n):\n         try:\n             for c in node.getElementsByTagName(\"object\"):\n                 values.append(m2m_convert(c))\n+        except UnexpectedNode:",
      "comment": "This is a good idea IMO, but, regardless of whether we need a specific exception subclass for this fix, I'd go with\r\n```suggestion\r\n        except SuspiciousOperation:\r\n```",
      "comment_id": 2637380214,
      "user": "shaib",
      "created_at": "2025-12-20T21:34:57Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2637380214"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 452,
      "side": "RIGHT",
      "diff_hunk": "@@ -415,17 +424,15 @@ def _get_model_from_node(self, node, attr):\n             )\n \n \n+def check_element_type(element):\n+    if element.childNodes:\n+        raise UnexpectedNode\n+    return element.nodeType in (element.TEXT_NODE, element.CDATA_SECTION_NODE)\n+\n+\n def getInnerText(node):\n-    \"\"\"Get the inner text of a DOM node and any children one level deep.\"\"\"\n-    # inspired by\n-    # https://mail.python.org/pipermail/xml-sig/2005-March/011022.html\n     return \"\".join(\n-        [\n-            element.data\n-            for child in node.childNodes\n-            for element in (child, *child.childNodes)\n-            if element.nodeType in (element.TEXT_NODE, element.CDATA_SECTION_NODE)\n-        ]\n+        [child.data for child in node.childNodes if check_element_type(child)]",
      "comment": "This doesn't look equivalent... the original took children and grandchildren, this drops grandchildren.",
      "comment_id": 2637385012,
      "user": "shaib",
      "created_at": "2025-12-20T21:41:38Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2637385012"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "tests/serializers/test_deserialization.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,35 +153,6 @@ def build_crafted_xml(depth, leaf_text_len):\n                 </django-objects>\n             \"\"\"\n \n-        def deserialize(crafted_xml):\n-            iterator = XMLDeserializer(crafted_xml)\n-            garbage_collect()\n-\n-            start_time = time.perf_counter()\n-            result = list(iterator)\n-            end_time = time.perf_counter()\n-\n-            self.assertEqual(len(result), 1)\n-            self.assertIsInstance(result[0].object, models.Model)\n-            return end_time - start_time\n-\n-        def assertFactor(label, params, factor=2):\n-            factors = []\n-            prev_time = None\n-            for depth, length in params:\n-                crafted_xml = build_crafted_xml(depth, length)\n-                elapsed = deserialize(crafted_xml)\n-                if prev_time is not None:\n-                    factors.append(elapsed / prev_time)\n-                prev_time = elapsed\n-\n-            with self.subTest(label):\n-                # Assert based on the average factor to reduce test flakiness.\n-                self.assertLessEqual(sum(factors) / len(factors), factor)\n-\n-        assertFactor(\n-            \"varying depth, varying length\",\n-            [(50, 2000), (100, 4000), (200, 8000), (400, 16000), (800, 32000)],\n-            2,\n-        )\n-        assertFactor(\"constant depth, varying length\", [(100, 1), (100, 1000)], 2)\n+        crafted_xml = build_crafted_xml(100, 1000)",
      "comment": "`build_crafted_xml` seems redundant as a function if it only gets called once. I'd simplify it away.",
      "comment_id": 2637387739,
      "user": "shaib",
      "created_at": "2025-12-20T21:46:15Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2637387739"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 452,
      "side": "RIGHT",
      "diff_hunk": "@@ -415,17 +424,15 @@ def _get_model_from_node(self, node, attr):\n             )\n \n \n+def check_element_type(element):\n+    if element.childNodes:\n+        raise UnexpectedNode\n+    return element.nodeType in (element.TEXT_NODE, element.CDATA_SECTION_NODE)\n+\n+\n def getInnerText(node):\n-    \"\"\"Get the inner text of a DOM node and any children one level deep.\"\"\"\n-    # inspired by\n-    # https://mail.python.org/pipermail/xml-sig/2005-March/011022.html\n     return \"\".join(\n-        [\n-            element.data\n-            for child in node.childNodes\n-            for element in (child, *child.childNodes)\n-            if element.nodeType in (element.TEXT_NODE, element.CDATA_SECTION_NODE)\n-        ]\n+        [child.data for child in node.childNodes if check_element_type(child)]",
      "comment": "Right, I should have left notes about this to aid the review. This change is possible _only_ in virtue of the other change you noticed, where I'm specializing `<natural>` nodes.\r\n\r\nThat's the only location where we need to drill two levels deep, e.g. from:\r\n\r\n```\r\n<field>\r\n    <natural> <!-- child -->\r\n        some content <!-- grandchild text node -->\r\n```\r\n\r\nGrandchild text nodes don't need to be visited if I instead call the helper on `<natural>` nodes. That dramatically simplifies checking for unexpected children.",
      "comment_id": 2637409898,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-20T22:23:01Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2637409898"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 452,
      "side": "RIGHT",
      "diff_hunk": "@@ -415,17 +424,15 @@ def _get_model_from_node(self, node, attr):\n             )\n \n \n+def check_element_type(element):\n+    if element.childNodes:\n+        raise UnexpectedNode\n+    return element.nodeType in (element.TEXT_NODE, element.CDATA_SECTION_NODE)\n+\n+\n def getInnerText(node):\n-    \"\"\"Get the inner text of a DOM node and any children one level deep.\"\"\"\n-    # inspired by\n-    # https://mail.python.org/pipermail/xml-sig/2005-March/011022.html\n     return \"\".join(\n-        [\n-            element.data\n-            for child in node.childNodes\n-            for element in (child, *child.childNodes)\n-            if element.nodeType in (element.TEXT_NODE, element.CDATA_SECTION_NODE)\n-        ]\n+        [child.data for child in node.childNodes if check_element_type(child)]",
      "comment": "Elsewhere, `<field>` nodes are interrogated when we _don't_ expect `<natural>` serialization, e.g.\r\n\r\n```\r\n<field>\r\n    some content <!-- child text node -->\r\n```",
      "comment_id": 2637410265,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-20T22:24:05Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2637410265"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,7 +305,10 @@ def _handle_object(self, node):\n                 if field_node.getElementsByTagName(\"None\"):\n                     value = None\n                 else:\n-                    value = field.to_python(getInnerText(field_node).strip())\n+                    if natural_nodes := field_node.getElementsByTagName(\"natural\"):\n+                        value = field.to_python(getInnerText(natural_nodes[0]).strip())\n+                    else:\n+                        value = field.to_python(getInnerText(field_node).strip())",
      "comment": "Thanks for the review. Sorry I didn't share more of my findings. I think throughout the serializer natural nodes are specialized. The ones that are relations, in the branches just before this, are specialized inside `_handle_m2m_field_node`. Unless I'm missing your meaning.",
      "comment_id": 2637410877,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-20T22:25:14Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2637410877"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 398,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,6 +394,8 @@ def m2m_convert(n):\n         try:\n             for c in node.getElementsByTagName(\"object\"):\n                 values.append(m2m_convert(c))\n+        except UnexpectedNode:\n+            raise",
      "comment": "I checked again and couldn't find any other places to update.",
      "comment_id": 2640284799,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-22T15:36:18Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2640284799"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,7 +305,10 @@ def _handle_object(self, node):\n                 if field_node.getElementsByTagName(\"None\"):\n                     value = None\n                 else:\n-                    value = field.to_python(getInnerText(field_node).strip())\n+                    if natural_nodes := field_node.getElementsByTagName(\"natural\"):\n+                        value = field.to_python(getInnerText(natural_nodes[0]).strip())\n+                    else:\n+                        value = field.to_python(getInnerText(field_node).strip())",
      "comment": "@shaib I think the key point here is that `<natural>` is not limited to FK or M2M values. It can also appear on direct fields when those fields participate in the object's own natural key (e.g. fixtures produced with `dumpdata --natural-primary`, as Jacob patiently explained to me when we chatted). In that sense, handling `<natural>` outside the relation branches is expected, not special-casing.\n\nWith that understanding, the change looks good to me. The only remaining concern is test coverage: reverting this change (but leaving `getInnerText` as modified in this commit) would not currently cause any serializer tests to fail, so it would be good to see a few targeted tests added to lock this behavior in.",
      "comment_id": 2669527349,
      "user": "nessita",
      "created_at": "2026-01-07T17:57:58Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2669527349"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,7 +305,10 @@ def _handle_object(self, node):\n                 if field_node.getElementsByTagName(\"None\"):\n                     value = None\n                 else:\n-                    value = field.to_python(getInnerText(field_node).strip())\n+                    if natural_nodes := field_node.getElementsByTagName(\"natural\"):\n+                        value = field.to_python(getInnerText(natural_nodes[0]).strip())\n+                    else:\n+                        value = field.to_python(getInnerText(field_node).strip())",
      "comment": "@shaib @nessita Thanks for pushing me to test my understanding here. I tried dumping fixture9, and noticed it was different from the `fixture9.xml` in the repo. Ouch.\r\n\r\nI think this all boils down to an invalid fixture. Upon correcting the fixture, I was able to remove this specialization.\r\n\r\n> In that sense, handling <natural> outside the relation branches is expected, not special-casing.\r\n\r\nI managed to talk @nessita into this when we we chatted, but it was wrong -- I think I was not prepared for the fixture to turn out to be invalid in *two* ways, not only whether or not `<natural>` should be present, but whether the definitions of the fields were to be trusted (missing `rel=ManyToOne...`).\r\n\r\nI wonder if it was just a copy-paste mistake in 35cc439.",
      "comment_id": 2670043573,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-07T20:54:01Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2670043573"
    },
    {
      "repo": "django/django",
      "pr_number": 20409,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -439,17 +441,15 @@ def _get_model_from_node(self, node, attr):\n             )\n \n \n+def check_element_type(element):\n+    if element.childNodes:\n+        raise SuspiciousOperation",
      "comment": "Could we perhaps add a message to this exception, since we are re-raising it in `_handle_m2m_field_node`? To aid debugging/understanding the error.",
      "comment_id": 2683642861,
      "user": "nessita",
      "created_at": "2026-01-12T19:40:04Z",
      "url": "https://github.com/django/django/pull/20409#discussion_r2683642861"
    },
    {
      "repo": "django/django",
      "pr_number": 20526,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1037,
      "side": "RIGHT",
      "diff_hunk": "@@ -1032,9 +1032,9 @@ def _get_default(self):\n         if self.has_db_default():\n             from django.db.models.expressions import DatabaseDefault\n \n-            return lambda: DatabaseDefault(\n-                self._db_default_expression, output_field=self\n-            )\n+            default = DatabaseDefault(self._db_default_expression, output_field=self)\n+\n+            return lambda: default",
      "comment": "This is safe to do as these are always resolved at query time and `resolve_expression` returns a resolved copy already.",
      "comment_id": 2680539696,
      "user": "charettes",
      "created_at": "2026-01-11T23:50:25Z",
      "url": "https://github.com/django/django/pull/20526#discussion_r2680539696"
    },
    {
      "repo": "django/django",
      "pr_number": 20526,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1037,
      "side": "RIGHT",
      "diff_hunk": "@@ -1032,9 +1032,9 @@ def _get_default(self):\n         if self.has_db_default():\n             from django.db.models.expressions import DatabaseDefault\n \n-            return lambda: DatabaseDefault(\n-                self._db_default_expression, output_field=self\n-            )\n+            default = DatabaseDefault(self._db_default_expression, output_field=self)\n+\n+            return lambda: default",
      "comment": "Thanks. Just checking: \"always resolved\" meaning if they can't be replaced by the `DEFAULT` keyword, right? I think we optimized out some resolving in #20493.",
      "comment_id": 2682688701,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-12T15:09:59Z",
      "url": "https://github.com/django/django/pull/20526#discussion_r2682688701"
    },
    {
      "repo": "django/django",
      "pr_number": 20526,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1037,
      "side": "RIGHT",
      "diff_hunk": "@@ -1032,9 +1032,9 @@ def _get_default(self):\n         if self.has_db_default():\n             from django.db.models.expressions import DatabaseDefault\n \n-            return lambda: DatabaseDefault(\n-                self._db_default_expression, output_field=self\n-            )\n+            default = DatabaseDefault(self._db_default_expression, output_field=self)\n+\n+            return lambda: default",
      "comment": "@jacobtylerwalls The optimization made in https://github.com/django/django/pull/20493 assume that `DatabaseDefault.resolve_expression` will never have to be called during `bulk_create` which seems safe as all databases we support require that a _pure_ expression (most of the time a constant) be used as `db_default` and resolving mainly turns field references to `Col` objects.\r\n\r\nI assume folks would get a weird crash if they try doing something like `db_default=F(\"other_field\")` after https://github.com/django/django/pull/20493 as you'll try a compile an unresolved expression but that seems expected.\r\n\r\nGiven `DatabaseDefault.as_sql` is idempotent the cloning that `resolve_expression` performs is not  necessary in fact I'm not sure what calls `DatabaseDefault.resolve_expression` anymore to be honest, maybe some logic in `Model.save` prior to calling `sql.Query._insert`? [The coverage report](https://djangoci.com/view/%C2%ADCoverage/job/django-coverage/HTML_20Coverage_20Report/z_d81526da7cfdb7e4_expressions_py.html#t1295) points at the `not for_save` branch being completely dead so I guess we could prune it and raise a `ValueError` if `not for_save`?",
      "comment_id": 2682809720,
      "user": "charettes",
      "created_at": "2026-01-12T15:36:44Z",
      "url": "https://github.com/django/django/pull/20526#discussion_r2682809720"
    },
    {
      "repo": "django/django",
      "pr_number": 20526,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1037,
      "side": "RIGHT",
      "diff_hunk": "@@ -1032,9 +1032,9 @@ def _get_default(self):\n         if self.has_db_default():\n             from django.db.models.expressions import DatabaseDefault\n \n-            return lambda: DatabaseDefault(\n-                self._db_default_expression, output_field=self\n-            )\n+            default = DatabaseDefault(self._db_default_expression, output_field=self)\n+\n+            return lambda: default",
      "comment": "> I assume folks would get a weird crash if they try doing something like db_default=F(\"other_field\")\r\n\r\nWe have a system check covering that \ud83d\udc4d \r\n\r\n> ERRORS:\r\napp.Person.name: (fields.E012) F(pk) cannot be used in db_default.",
      "comment_id": 2682841250,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-12T15:44:46Z",
      "url": "https://github.com/django/django/pull/20526#discussion_r2682841250"
    },
    {
      "repo": "django/django",
      "pr_number": 20526,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1037,
      "side": "RIGHT",
      "diff_hunk": "@@ -1032,9 +1032,9 @@ def _get_default(self):\n         if self.has_db_default():\n             from django.db.models.expressions import DatabaseDefault\n \n-            return lambda: DatabaseDefault(\n-                self._db_default_expression, output_field=self\n-            )\n+            default = DatabaseDefault(self._db_default_expression, output_field=self)\n+\n+            return lambda: default",
      "comment": "FWIW the only remaining `DatabaseDefault.resolve_expression` calls are coming from constraint validation.\r\n\r\nIn light of ticket-36847 this made me realize that expression resolving during constraint validation should potentially pass `for_save=True` as well \ud83e\udd14 ?",
      "comment_id": 2683039063,
      "user": "charettes",
      "created_at": "2026-01-12T16:35:31Z",
      "url": "https://github.com/django/django/pull/20526#discussion_r2683039063"
    },
    {
      "repo": "django/django",
      "pr_number": 20526,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1037,
      "side": "RIGHT",
      "diff_hunk": "@@ -1032,9 +1032,9 @@ def _get_default(self):\n         if self.has_db_default():\n             from django.db.models.expressions import DatabaseDefault\n \n-            return lambda: DatabaseDefault(\n-                self._db_default_expression, output_field=self\n-            )\n+            default = DatabaseDefault(self._db_default_expression, output_field=self)\n+\n+            return lambda: default",
      "comment": "Hm, I haven't dealt with an expression cloning / for_save ticket, so unfortunately I'd probably need a bit more context.",
      "comment_id": 2683520085,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-12T19:02:48Z",
      "url": "https://github.com/django/django/pull/20526#discussion_r2683520085"
    },
    {
      "repo": "django/django",
      "pr_number": 20184,
      "file_path": "django/contrib/admin/options.py",
      "line": 2053,
      "side": "RIGHT",
      "diff_hunk": "@@ -2050,10 +2050,7 @@ def changelist_view(self, request, extra_context=None):\n             # me back\" button on the action confirmation page.\n             return HttpResponseRedirect(request.get_full_path())\n \n-        # If we're allowing changelist editing, we need to construct a formset\n-        # for the changelist given all the fields to be edited. Then we'll\n-        # use the formset to validate/process POSTed data.\n-        formset = cl.formset = None\n+        formset = None",
      "comment": "It looks like the lint issue is occurring in this part.\r\nRemoving that line should resolve it!",
      "comment_id": 2539961196,
      "user": "Antoliny0919",
      "created_at": "2025-11-18T23:39:05Z",
      "url": "https://github.com/django/django/pull/20184#discussion_r2539961196"
    },
    {
      "repo": "django/django",
      "pr_number": 20184,
      "file_path": "django/contrib/admin/options.py",
      "line": 2053,
      "side": "RIGHT",
      "diff_hunk": "@@ -2050,10 +2050,7 @@ def changelist_view(self, request, extra_context=None):\n             # me back\" button on the action confirmation page.\n             return HttpResponseRedirect(request.get_full_path())\n \n-        # If we're allowing changelist editing, we need to construct a formset\n-        # for the changelist given all the fields to be edited. Then we'll\n-        # use the formset to validate/process POSTed data.\n-        formset = cl.formset = None\n+        formset = None",
      "comment": "oh boy! that was a stupid oversight sorry \ud83d\ude05\r\ni mistook options for main ig ",
      "comment_id": 2540434159,
      "user": "Rudraksha-007",
      "created_at": "2025-11-19T03:55:35Z",
      "url": "https://github.com/django/django/pull/20184#discussion_r2540434159"
    },
    {
      "repo": "django/django",
      "pr_number": 20184,
      "file_path": "django/contrib/admin/views/main.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -64,6 +64,7 @@ def __init__(self, *args, **kwargs):\n \n class ChangeList:\n     search_form_class = ChangeListSearchForm\n+    formset = None  # noqa: F841",
      "comment": "yep, i thought that snakeoil fix (#type:ignore) would work here \r\ni have removed this \u2705\r\nit passes the test now ",
      "comment_id": 2540435119,
      "user": "Rudraksha-007",
      "created_at": "2025-11-19T03:56:20Z",
      "url": "https://github.com/django/django/pull/20184#discussion_r2540435119"
    },
    {
      "repo": "django/django",
      "pr_number": 20184,
      "file_path": "django/contrib/admin/options.py",
      "line": 2056,
      "side": "LEFT",
      "diff_hunk": "@@ -2050,11 +2050,6 @@ def changelist_view(self, request, extra_context=None):\n             # me back\" button on the action confirmation page.\n             return HttpResponseRedirect(request.get_full_path())\n \n-        # If we're allowing changelist editing, we need to construct a formset\n-        # for the changelist given all the fields to be edited. Then we'll\n-        # use the formset to validate/process POSTed data.\n-        formset = cl.formset = None",
      "comment": "I could see value in leaving `cl.formset = None` here to just avoid any pollution from prior calls. @Antoliny0919 wdyt?",
      "comment_id": 2624610523,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T20:17:09Z",
      "url": "https://github.com/django/django/pull/20184#discussion_r2624610523"
    },
    {
      "repo": "django/django",
      "pr_number": 20184,
      "file_path": "django/contrib/admin/options.py",
      "line": 2056,
      "side": "LEFT",
      "diff_hunk": "@@ -2050,11 +2050,6 @@ def changelist_view(self, request, extra_context=None):\n             # me back\" button on the action confirmation page.\n             return HttpResponseRedirect(request.get_full_path())\n \n-        # If we're allowing changelist editing, we need to construct a formset\n-        # for the changelist given all the fields to be edited. Then we'll\n-        # use the formset to validate/process POSTed data.\n-        formset = cl.formset = None",
      "comment": "Never mind -- `cl` is an instance. `cl` meaning \"changelist\", who knew? \ud83d\ude04 ",
      "comment_id": 2624645464,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T20:31:27Z",
      "url": "https://github.com/django/django/pull/20184#discussion_r2624645464"
    },
    {
      "repo": "django/django",
      "pr_number": 20416,
      "file_path": "django/contrib/admin/sites.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,6 +170,8 @@ def get_model_admin(self, model):\n         try:\n             return self._registry[model]\n         except KeyError:\n+            if isinstance(model, str):\n+                raise NotRegistered(f\"The model {model!r} is not registered.\")",
      "comment": "Sorry, looking more closely I see that `get_model_admin` is documented to take a class, not a string. It might be better to solve this closer to the source of the erroring check, by checking `isinstance(..., str)` before calling `get_model_admin()`.",
      "comment_id": 2624299381,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T18:25:24Z",
      "url": "https://github.com/django/django/pull/20416#discussion_r2624299381"
    },
    {
      "repo": "django/django",
      "pr_number": 20416,
      "file_path": "django/contrib/admin/sites.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,6 +170,8 @@ def get_model_admin(self, model):\n         try:\n             return self._registry[model]\n         except KeyError:\n+            if isinstance(model, str):\n+                raise NotRegistered(f\"The model {model!r} is not registered.\")",
      "comment": "The error came up when the `ForeignKey`'s `to` field was defined as a string, and the app was not registered. I have pushed a fix that checks the type before `get_model_admin` is called. I found that a similar call was made in `options.py`. Please let me know if it looks okay, will add regression tests if it does. Thanks!",
      "comment_id": 2649177008,
      "user": "parth-paradkar",
      "created_at": "2025-12-27T14:59:37Z",
      "url": "https://github.com/django/django/pull/20416#discussion_r2649177008"
    },
    {
      "repo": "django/django",
      "pr_number": 20416,
      "file_path": "django/contrib/admin/checks.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,6 +236,19 @@ def _check_autocomplete_fields_item(self, obj, field_name, label):\n                     id=\"admin.E038\",\n                 )\n             try:\n+                if isinstance(field.remote_field.model, str):\n+                    return [\n+                        checks.Error(\n+                            'An admin for model \"%s\" has to be registered '\n+                            \"to be referenced by %s.autocomplete_fields.\"\n+                            % (\n+                                field.remote_field.model,\n+                                type(obj).__name__,\n+                            ),\n+                            obj=obj.__class__,\n+                            id=\"admin.E039\",\n+                        )\n+                    ]",
      "comment": "```suggestion\n                    raise NotRegistered\n```",
      "comment_id": 2651524728,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-29T18:30:42Z",
      "url": "https://github.com/django/django/pull/20416#discussion_r2651524728"
    },
    {
      "repo": "django/django",
      "pr_number": 20416,
      "file_path": "django/contrib/admin/options.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -254,6 +254,8 @@ def get_field_queryset(self, db, db_field, request):\n         (return None in that case).\n         \"\"\"\n         try:\n+            if isinstance(db_field.remote_field.model, str):\n+                return None",
      "comment": "I'm not sure this is realistic, wouldn't we have failed well before this?",
      "comment_id": 2651533053,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-29T18:36:07Z",
      "url": "https://github.com/django/django/pull/20416#discussion_r2651533053"
    },
    {
      "repo": "django/django",
      "pr_number": 20416,
      "file_path": "django/contrib/admin/options.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -254,6 +254,8 @@ def get_field_queryset(self, db, db_field, request):\n         (return None in that case).\n         \"\"\"\n         try:\n+            if isinstance(db_field.remote_field.model, str):\n+                return None",
      "comment": "Hmm ok. I'll remove the change in this PR and check separately.",
      "comment_id": 2652607799,
      "user": "parth-paradkar",
      "created_at": "2025-12-30T09:35:45Z",
      "url": "https://github.com/django/django/pull/20416#discussion_r2652607799"
    },
    {
      "repo": "django/django",
      "pr_number": 20416,
      "file_path": "django/contrib/admin/sites.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,6 +170,8 @@ def get_model_admin(self, model):\n         try:\n             return self._registry[model]\n         except KeyError:\n+            if isinstance(model, str):\n+                raise NotRegistered(f\"The model {model!r} is not registered.\")",
      "comment": "Yep, looks great! I pushed minor formatting edits to reduce space. Be sure to do a hard reset back several commits and then pull my latest changes.\r\n\r\nA regression test would be great, thanks.",
      "comment_id": 2673927890,
      "user": "jacobtylerwalls",
      "created_at": "2026-01-08T21:14:10Z",
      "url": "https://github.com/django/django/pull/20416#discussion_r2673927890"
    },
    {
      "repo": "django/django",
      "pr_number": 20462,
      "file_path": "django/contrib/postgres/constraints.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -131,6 +133,28 @@ def remove_sql(self, model, schema_editor):\n             schema_editor.quote_name(self.name),\n         )\n \n+    def check_supported(self, schema_editor):\n+        if self.include and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Covering exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if len(self.expressions) > 1 and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Composite exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if (\n+            self.index_type.lower() == \"hash\"\n+            and self.expressions[0][1] != RangeOperators.EQUAL\n+        ):\n+            raise NotSupportedError(\n+                \"Exclusion constraints using an Hash index only \"\n+                \"supports the EQUAL operator.\"\n+            )\n+",
      "comment": "Why not do all of this validation up in `__init__` ? It seems weird to validate the type there, but then delay this extra validation until SQL creation.",
      "comment_id": 2651856092,
      "user": "adamchainz",
      "created_at": "2025-12-29T22:10:26Z",
      "url": "https://github.com/django/django/pull/20462#discussion_r2651856092"
    },
    {
      "repo": "django/django",
      "pr_number": 20462,
      "file_path": "django/contrib/postgres/constraints.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -131,6 +133,28 @@ def remove_sql(self, model, schema_editor):\n             schema_editor.quote_name(self.name),\n         )\n \n+    def check_supported(self, schema_editor):\n+        if self.include and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Covering exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if len(self.expressions) > 1 and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Composite exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if (\n+            self.index_type.lower() == \"hash\"\n+            and self.expressions[0][1] != RangeOperators.EQUAL\n+        ):\n+            raise NotSupportedError(\n+                \"Exclusion constraints using an Hash index only \"\n+                \"supports the EQUAL operator.\"\n+            )\n+",
      "comment": "Hi Adam, I added it like that because this is how it was done before support for PostgreSQL 14 was dropped:\r\n\r\nhttps://github.com/django/django/commit/b049bec7cfe9b5854584d240addb44fa1e9375a5#diff-a4e33792faf48c1d998ea65d49b65a6ab695efad8c2b74891180e055342e92eeL117-L141\r\n\r\nLooking at other constraints (such as UniqueConstraint) I think the checks in `__init__` are focusing more on types rather then database support or potential runtime errors so I don't this is the right place for these types of checks.\r\n\r\nIt seems like these checks are better off as Django checks. See for example similar checks in `UniqueConstraint`:\r\n\r\nhttps://github.com/django/django/blob/ccf74f7dc771313b41e7c2912a71f9c5b0ae5e1d/django/db/models/constraints.py#L338\r\n\r\nTo recap the options here:\r\n\r\n1. No checks (there are currently no checks for the other index types)\r\n2. Raise `ValueError` in `__init__`\r\n3. Issue Django checks in `check()` (consistent with other constraints)\r\n4. Check at runtime when producing the SQL (as it used to be, and how it's currently implemented in this PR)",
      "comment_id": 2652498439,
      "user": "hakib",
      "created_at": "2025-12-30T08:26:49Z",
      "url": "https://github.com/django/django/pull/20462#discussion_r2652498439"
    },
    {
      "repo": "django/django",
      "pr_number": 20462,
      "file_path": "django/contrib/postgres/constraints.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -131,6 +133,28 @@ def remove_sql(self, model, schema_editor):\n             schema_editor.quote_name(self.name),\n         )\n \n+    def check_supported(self, schema_editor):\n+        if self.include and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Covering exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if len(self.expressions) > 1 and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Composite exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if (\n+            self.index_type.lower() == \"hash\"\n+            and self.expressions[0][1] != RangeOperators.EQUAL\n+        ):\n+            raise NotSupportedError(\n+                \"Exclusion constraints using an Hash index only \"\n+                \"supports the EQUAL operator.\"\n+            )\n+",
      "comment": "I'd prefer the 2nd option (`ValueError` in `__init__()`) previous checks were implemented in `check_support()` because they required database connection to check feature flags (`schema_editor.connection`). New checks are not database dependent.",
      "comment_id": 2659676600,
      "user": "felixxm",
      "created_at": "2026-01-04T13:44:01Z",
      "url": "https://github.com/django/django/pull/20462#discussion_r2659676600"
    },
    {
      "repo": "django/django",
      "pr_number": 20462,
      "file_path": "django/contrib/postgres/constraints.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -131,6 +133,28 @@ def remove_sql(self, model, schema_editor):\n             schema_editor.quote_name(self.name),\n         )\n \n+    def check_supported(self, schema_editor):\n+        if self.include and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Covering exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if len(self.expressions) > 1 and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Composite exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if (\n+            self.index_type.lower() == \"hash\"\n+            and self.expressions[0][1] != RangeOperators.EQUAL\n+        ):\n+            raise NotSupportedError(\n+                \"Exclusion constraints using an Hash index only \"\n+                \"supports the EQUAL operator.\"\n+            )\n+",
      "comment": "I've added a commit to move the checks to `__init__.py` as `ValueError` + updated the tests. \r\n\r\nLet me know if we are good to go and I'll squash.",
      "comment_id": 2661652476,
      "user": "hakib",
      "created_at": "2026-01-05T14:13:58Z",
      "url": "https://github.com/django/django/pull/20462#discussion_r2661652476"
    },
    {
      "repo": "django/django",
      "pr_number": 20462,
      "file_path": "django/contrib/postgres/constraints.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -131,6 +133,28 @@ def remove_sql(self, model, schema_editor):\n             schema_editor.quote_name(self.name),\n         )\n \n+    def check_supported(self, schema_editor):\n+        if self.include and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Covering exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if len(self.expressions) > 1 and self.index_type.lower() == \"hash\":\n+            raise NotSupportedError(\n+                \"Composite exclusion constraints using an Hash index \"\n+                \"are not supported.\"\n+            )\n+\n+        if (\n+            self.index_type.lower() == \"hash\"\n+            and self.expressions[0][1] != RangeOperators.EQUAL\n+        ):\n+            raise NotSupportedError(\n+                \"Exclusion constraints using an Hash index only \"\n+                \"supports the EQUAL operator.\"\n+            )\n+",
      "comment": "@hakib Thanks for updates :+1: I will move it forward during the weekend.",
      "comment_id": 2669546431,
      "user": "felixxm",
      "created_at": "2026-01-07T18:02:35Z",
      "url": "https://github.com/django/django/pull/20462#discussion_r2669546431"
    },
    {
      "repo": "django/django",
      "pr_number": 20462,
      "file_path": "django/contrib/postgres/constraints.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,7 +37,7 @@ def __init__(\n         violation_error_code=None,\n         violation_error_message=None,\n     ):\n-        if index_type and index_type.lower() not in {\"gist\", \"spgist\"}:\n+        if index_type and index_type.lower() not in {\"gist\", \"spgist\", \"hash\"}:",
      "comment": "```suggestion\n        if index_type and index_type.lower() not in {\"gist\", \"hash\", \"spgist\"}:\n```\nI suggest to preserve the alphabetic order for code readability.",
      "comment_id": 2672447704,
      "user": "pauloxnet",
      "created_at": "2026-01-08T13:52:46Z",
      "url": "https://github.com/django/django/pull/20462#discussion_r2672447704"
    },
    {
      "repo": "django/django",
      "pr_number": 20462,
      "file_path": "django/contrib/postgres/constraints.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,7 +37,7 @@ def __init__(\n         violation_error_code=None,\n         violation_error_message=None,\n     ):\n-        if index_type and index_type.lower() not in {\"gist\", \"spgist\"}:\n+        if index_type and index_type.lower() not in {\"gist\", \"spgist\", \"hash\"}:\n             raise ValueError(\n                 \"Exclusion constraints only support GiST or SP-GiST indexes.\"",
      "comment": "```suggestion\n                \"Exclusion constraints only support GiST, Hash or SP-GiST indexes.\"\n```",
      "comment_id": 2672464036,
      "user": "pauloxnet",
      "created_at": "2026-01-08T13:57:26Z",
      "url": "https://github.com/django/django/pull/20462#discussion_r2672464036"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -224,6 +236,7 @@ def test_null(self):\n         self.assertIsNone(obj.value)\n \n     @skipUnlessDBFeature(\"supports_primitives_in_json_field\")\n+    @ignore_warnings(category=RemovedInDjango70Warning)",
      "comment": "```suggestion\n    # RemovedInDjango70Warning.\n    @ignore_warnings(category=RemovedInDjango70Warning)\n```",
      "comment_id": 2383012280,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:23:46Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383012280"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -224,6 +236,7 @@ def test_null(self):\n         self.assertIsNone(obj.value)\n \n     @skipUnlessDBFeature(\"supports_primitives_in_json_field\")\n+    @ignore_warnings(category=RemovedInDjango70Warning)\n     def test_json_null_different_from_sql_null(self):\n         json_null = NullableJSONModel.objects.create(value=Value(None, JSONField()))",
      "comment": "I take it you intentionally left this as `Value(None, JSONField()` rather than `JSONNull()` to ensure we still had some coverage?",
      "comment_id": 2383014941,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:25:14Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383014941"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1263,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()",
      "comment": "Thanks to #19285 we can drop these calls, at least for the top level.\n\n```suggestion\n```",
      "comment_id": 2383026088,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:31:10Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383026088"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1272,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())",
      "comment": "Would it be better to write these tests with `JSONModel` or `JSONNullDefaultModel`? These tests would pass if the `JSONNull()` got dropped somewhere and a row got created anyway.",
      "comment_id": 2383031239,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:33:16Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383031239"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1280,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_update(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+        NullableJSONModel.objects.update(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_filter(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        found = NullableJSONModel.objects.get(value=JSONNull())\n+        self.assertEqual(obj, found)",
      "comment": "I'm not sure what this assertion is testing.\n```suggestion\n```",
      "comment_id": 2383045557,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:38:40Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383045557"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1286,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_update(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+        NullableJSONModel.objects.update(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_filter(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        found = NullableJSONModel.objects.get(value=JSONNull())\n+        self.assertEqual(obj, found)\n+        self.assertSequenceEqual(",
      "comment": "Can we add examples that return results? Especially if we end up avoiding using `JSONNull()` in `test_json_null_different_from_sql_null`.",
      "comment_id": 2383049416,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:40:01Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383049416"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1289,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_update(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+        NullableJSONModel.objects.update(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_filter(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        found = NullableJSONModel.objects.get(value=JSONNull())\n+        self.assertEqual(obj, found)\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.exclude(value=JSONNull()), []\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True), []\n+        )\n+\n+    def test_case_expression(self):\n+        with self.subTest(\"JSONNull() in When.then\"):",
      "comment": "I would just explode these out into separate test methods, since the tests don't share state.",
      "comment_id": 2383050855,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:40:39Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383050855"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1288,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_update(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+        NullableJSONModel.objects.update(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_filter(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        found = NullableJSONModel.objects.get(value=JSONNull())\n+        self.assertEqual(obj, found)\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.exclude(value=JSONNull()), []\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True), []\n+        )\n+\n+    def test_case_expression(self):",
      "comment": "I think a couple tests with a custom encoder that can serialize `JSONNull` would be good.",
      "comment_id": 2383077021,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:48:15Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383077021"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1332,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_update(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+        NullableJSONModel.objects.update(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_filter(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        found = NullableJSONModel.objects.get(value=JSONNull())\n+        self.assertEqual(obj, found)\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.exclude(value=JSONNull()), []\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True), []\n+        )\n+\n+    def test_case_expression(self):\n+        with self.subTest(\"JSONNull() in When.then\"):\n+            obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+            NullableJSONModel.objects.filter(pk=obj.pk).update(\n+                value=Case(\n+                    When(value={\"key\": \"value\"}, then=JSONNull()),\n+                )\n+            )\n+            obj.refresh_from_db()\n+            self.assertIsNone(obj.value)\n+        with self.subTest(\"JSONNull() in When.condition\"):\n+            obj = NullableJSONModel.objects.create(value=JSONNull())\n+            NullableJSONModel.objects.filter(pk=obj.pk).update(\n+                value=Case(\n+                    When(\n+                        value=JSONNull(),\n+                        then=Value({\"key\": \"replaced\"}, output_field=JSONField()),\n+                    )\n+                ),\n+            )\n+            obj.refresh_from_db()\n+            self.assertEqual(obj.value, {\"key\": \"replaced\"})\n+\n+    def test_key_transform_exact_filter(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": None})\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__key=JSONNull()),\n+            [obj],\n+        )",
      "comment": "Do we want to show here that `=None` behaves the same?",
      "comment_id": 2383081074,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:49:20Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383081074"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 343,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,14 +334,27 @@ def process_rhs(self, compiler, connection):\n \n \n class JSONExact(lookups.Exact):\n+    # RemovedInDjango70Warning: When the deprecation period is over, remove\n+    # the following line.\n     can_use_none_as_rhs = True\n \n     def process_rhs(self, compiler, connection):\n+        if self.rhs is None and isinstance(self.lhs, expressions.Col):\n+            warnings.warn(\n+                \"Using None as the right-hand side of an exact lookup on JSONField \"\n+                \"to mean JSON scalar 'null' is deprecated. Use JSONNull() instead.\",",
      "comment": "I think there will be enough unsuspecting users that weren't trying to select on top-level scalar null that we could also point users toward `__isnull=True` for key or index absence.",
      "comment_id": 2383094898,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:53:16Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383094898"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1384,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_update(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+        NullableJSONModel.objects.update(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_filter(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        found = NullableJSONModel.objects.get(value=JSONNull())\n+        self.assertEqual(obj, found)\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.exclude(value=JSONNull()), []\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True), []\n+        )\n+\n+    def test_case_expression(self):\n+        with self.subTest(\"JSONNull() in When.then\"):\n+            obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+            NullableJSONModel.objects.filter(pk=obj.pk).update(\n+                value=Case(\n+                    When(value={\"key\": \"value\"}, then=JSONNull()),\n+                )\n+            )\n+            obj.refresh_from_db()\n+            self.assertIsNone(obj.value)\n+        with self.subTest(\"JSONNull() in When.condition\"):\n+            obj = NullableJSONModel.objects.create(value=JSONNull())\n+            NullableJSONModel.objects.filter(pk=obj.pk).update(\n+                value=Case(\n+                    When(\n+                        value=JSONNull(),\n+                        then=Value({\"key\": \"replaced\"}, output_field=JSONField()),\n+                    )\n+                ),\n+            )\n+            obj.refresh_from_db()\n+            self.assertEqual(obj.value, {\"key\": \"replaced\"})\n+\n+    def test_key_transform_exact_filter(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": None})\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__key=JSONNull()),\n+            [obj],\n+        )\n+\n+    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n+    def test_constraint_validation(self):\n+        constraint = CheckConstraint(\n+            condition=~Q(value=JSONNull()), name=\"check_not_json_null\"\n+        )\n+        constraint.validate(NullableJSONModel, NullableJSONModel(value={\"key\": None}))\n+        msg = f\"Constraint \u201c{constraint.name}\u201d is violated.\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(NullableJSONModel, NullableJSONModel(value=JSONNull()))\n+\n+    def test_constraint_validation_key_transform(self):\n+        constraint = CheckConstraint(\n+            condition=Q(value__has_key=\"name\") & ~Q(value__name=JSONNull()),\n+            name=\"check_value_name_not_json_null\",\n+        )\n+        constraint.validate(\n+            NullableJSONModel, NullableJSONModel(value={\"name\": \"Django\"})\n+        )\n+        msg = f\"Constraint \u201c{constraint.name}\u201d is violated.\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(\n+                NullableJSONModel, NullableJSONModel(value={\"name\": None})\n+            )\n+\n+    def test_default(self):\n+        obj = JSONNullDefaultModel.objects.create()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+        self.assertSequenceEqual(\n+            JSONNullDefaultModel.objects.filter(value__isnull=True), []\n+        )\n+\n+\n+class JSONExactNoneDeprecationTests(TestCase):",
      "comment": "```suggestion\n# RemovedInDjango70Warning.\nclass JSONExactNoneDeprecationTests(TestCase):\n```",
      "comment_id": 2383102668,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T17:56:14Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383102668"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,6 +150,27 @@ def formfield(self, **kwargs):\n         )\n \n \n+class JSONNull(expressions.Expression):",
      "comment": "@charettes can you advise on why we wouldn't subclass `Value`?\n\nIt makes me wonder about auditing all the places we do `isinstance(..., Value)`. This site seems like something we'd need to teach about `JSONNull`:\n\nhttps://github.com/django/django/blob/be581ff473e8ade6365975db2df602f295a4cb4b/django/db/backends/sqlite3/schema.py#L321-L323",
      "comment_id": 2383179163,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T18:33:08Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383179163"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,6 +150,27 @@ def formfield(self, **kwargs):\n         )\n \n \n+class JSONNull(expressions.Expression):\n+    \"\"\"Represent JSON `null` primitive.\"\"\"\n+\n+    allowed_default = True\n+\n+    def __init__(self):\n+        super().__init__(output_field=JSONField())",
      "comment": "More subclass friendly?\n```suggestion\n    output_field = JSONField()\n```",
      "comment_id": 2383191955,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-26T18:38:18Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2383191955"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,14 +334,27 @@ def process_rhs(self, compiler, connection):\n \n \n class JSONExact(lookups.Exact):\n+    # RemovedInDjango70Warning: When the deprecation period is over, remove\n+    # the following line.\n     can_use_none_as_rhs = True\n \n     def process_rhs(self, compiler, connection):\n+        if self.rhs is None and isinstance(self.lhs, expressions.Col):",
      "comment": "Hey @jacobtylerwalls! Thanks for the thorough review! Concerning `ArrayField(JSONField(), ...)`, the problem is: Top level `None` in `ArrayField(JSONField())` saves as JSON `null` instead of SQL `NULL` (which is the case for top-level None in standalone `JSONField`s). Deprecating `json__0=None` without changing how `[None]` saves in `ArrayField(JSONField(), ...)` would introduce an asymmetry.\r\n\r\n```diff\r\ndiff --git a/tests/postgres_tests/test_array.py b/tests/postgres_tests/test_array.py\r\nindex 392b8f946c..0cb6a223a7 100644\r\n--- a/tests/postgres_tests/test_array.py\r\n+++ b/tests/postgres_tests/test_array.py\r\n@@ -203,6 +203,23 @@ class TestSaveLoad(PostgreSQLTestCase):\r\n         )\r\n         self.assertEqual(instance.field_nested, [[None, None], [None, None]])\r\n \r\n+    def test_top_level_none_for_json_base_field(self):\r\n+        obj = OtherTypesArrayModel.objects.create(json=[None, None])\r\n+        # Current behaviour (bug or design?): JSON null is always saved and\r\n+        # queried for, instead of SQL, as one might expect from the docs at\r\n+        # https://docs.djangoproject.com/en/6.0/topics/db/queries/#storing-and-querying-for-none.\r\n+        # Not sure if this should change, but changing the filter case without\r\n+        # changing how None saves would result in an assymetry: None\r\n+        # would be saved as one value (JSON null) and queried as a different\r\n+        # value (SQL NULL).\r\n+        self.assertSequenceEqual(\r\n+            OtherTypesArrayModel.objects.filter(json__0=None), [obj]\r\n+        )\r\n+        # This fails because json=[None, None] does not map to [NULL, NULL].\r\n+        self.assertSequenceEqual(\r\n+            OtherTypesArrayModel.objects.filter(json__0__isnull=True), [obj]\r\n+        )\r\n+\r\n ```\r\nHow should I proceed?",
      "comment_id": 2414255848,
      "user": "cliffordgama",
      "created_at": "2025-10-08T15:26:40Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2414255848"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,6 +150,27 @@ def formfield(self, **kwargs):\n         )\n \n \n+class JSONNull(expressions.Expression):",
      "comment": "Caught up with Simon at Django on the Med and he confirmed that we want `Value` because `JSONNull` is acting like a literal value here.",
      "comment_id": 2415745393,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-09T06:54:52Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2415745393"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,14 +334,27 @@ def process_rhs(self, compiler, connection):\n \n \n class JSONExact(lookups.Exact):\n+    # RemovedInDjango70Warning: When the deprecation period is over, remove\n+    # the following line.\n     can_use_none_as_rhs = True\n \n     def process_rhs(self, compiler, connection):\n+        if self.rhs is None and isinstance(self.lhs, expressions.Col):",
      "comment": "1. Re: emitting the warning, catching up with Simon he also suggested removing the `and isinstance(self.lhs, expressions.Col)`, since other left-hand-sides are possible that might yield `JSONNull`,  like a `Case` expression. This makes sure the warning appears before the behavior changes.\n\n2. Re your test: I'm understanding that you're asking whether we should change the current patch, which does have a behavior change in Django 7 for filtering, to *not* have that change so that we keep the symmetry with saving. But as you point out, the current Django 6 behavior for saving JSON subfields in ArrayField contradicts the docs. I chatted with Simon and we agreed we should consider the status quo behavior for saving as a bug, since it doesn't match the docs and what standalone JSONField does. We could fix that in a distinct commit here (with a deprecation cycle).",
      "comment_id": 2415808000,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-09T07:21:07Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2415808000"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1288,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_update(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+        NullableJSONModel.objects.update(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_filter(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        found = NullableJSONModel.objects.get(value=JSONNull())\n+        self.assertEqual(obj, found)\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.exclude(value=JSONNull()), []\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True), []\n+        )\n+\n+    def test_case_expression(self):",
      "comment": "I added a test with a custom encoder. Let me know if it suffices.",
      "comment_id": 2455255484,
      "user": "cliffordgama",
      "created_at": "2025-10-23T14:01:21Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2455255484"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1272,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())",
      "comment": "I'm not sure that I understand the rationale for the proposal very well.",
      "comment_id": 2455264929,
      "user": "cliffordgama",
      "created_at": "2025-10-23T14:04:12Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2455264929"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,6 +150,27 @@ def formfield(self, **kwargs):\n         )\n \n \n+class JSONNull(expressions.Expression):",
      "comment": "Hey @jacobtylerwalls, please advise on how I can subclass `Value` without making `JSONNull()` a mere alias of `Value(None, JSONField())`, since the latter still has bugs like ticket-36445, which was closed in favour of introducing `JSONNull()` and under-promoting `Value(None, JSONField())`.\r\n\r\n(I added `model_fields.test_jsonfield.JSONNullTests.test_bulk_update` to ensure the bug isn't carried over to `JSONNull()` as well.)",
      "comment_id": 2455306538,
      "user": "cliffordgama",
      "created_at": "2025-10-23T14:16:45Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2455306538"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1272,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())",
      "comment": "Sorry for the shorthand. Consider if I changed the first line of this test to:\r\n```py\r\nobj = NullableJSONModel.objects.create()\r\n```\r\nThe test would still pass, since both SQL NULL and json null load into python as `None`, meaning we didn't really test that json null got persisted.\r\n\r\nIf we use a model that doesn't allow SQL NULL, that wouldn't be possible.",
      "comment_id": 2461662841,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-24T18:48:47Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2461662841"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,6 +150,27 @@ def formfield(self, **kwargs):\n         )\n \n \n+class JSONNull(expressions.Expression):",
      "comment": "Thanks for reminding me about that ticket. When I retested the test you supplied there against this branch, it still passes (when rewriting it to use JSONNull) even when JSONNull subclasses `Value`.",
      "comment_id": 2461714448,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-24T19:09:50Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2461714448"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/postgres_tests/test_array.py",
      "line": 1600,
      "side": "RIGHT",
      "diff_hunk": "@@ -1577,3 +1578,30 @@ def test_array_with_choices_display_for_field(self):\n             self.empty_value,\n         )\n         self.assertEqual(display_value, self.empty_value)\n+\n+\n+class TestJSONFieldQuerying(PostgreSQLTestCase):\n+    def test_saving_and_querying_for_sql_null(self):\n+        obj = OtherTypesArrayModel.objects.create(json=[None, None])\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__isnull=True), [obj]\n+        )\n+\n+    def test_saving_and_querying_for_nested_none(self):\n+        obj = OtherTypesArrayModel.objects.create(json=[[None, 1], [None, 2]])\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__0=None), [obj]\n+        )\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__0__isnull=True), []\n+        )\n+\n+    # RemovedInDjango70Warning.\n+    def test_exact_none_deprecation_warning(self):",
      "comment": "Might be nice to rewrite this slightly to assert against the query result so we can keep the test after we remove the deprecation warning.\n\nWhen playing with that locally, I noticed that the behavior of this query already changes in this PR, when I would have expected it to change only in the future/django 7 like JSONField. Do you know why this is?\n\nI don't have an opinion yet if we have to have a deprecation period for this kind of change, if it turns out to be more of a bugfix.",
      "comment_id": 2461791260,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-24T19:44:51Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2461791260"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1355,
      "side": "RIGHT",
      "diff_hunk": "@@ -1241,3 +1257,166 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_update(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+        NullableJSONModel.objects.update(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_filter(self):\n+        json_null = NullableJSONModel.objects.create(value=JSONNull())\n+        sql_null = NullableJSONModel.objects.create(value=None)\n+        self.assertSequenceEqual(\n+            [json_null], NullableJSONModel.objects.filter(value=JSONNull())\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True), [sql_null]\n+        )\n+\n+    def test_bulk_update(self):\n+        obj1 = NullableJSONModel.objects.create(value={\"k\": \"1st\"})\n+        obj2 = NullableJSONModel.objects.create(value={\"k\": \"2nd\"})\n+        obj1.value = JSONNull()\n+        obj2.value = JSONNull()\n+        NullableJSONModel.objects.bulk_update([obj1, obj2], fields=[\"value\"])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value=JSONNull()),\n+            [obj1, obj2],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True), []\n+        )\n+\n+    def test_case_expression_with_jsonnull_then(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": \"value\"})\n+        NullableJSONModel.objects.filter(pk=obj.pk).update(\n+            value=Case(\n+                When(value={\"key\": \"value\"}, then=JSONNull()),\n+            )\n+        )\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_case_expr_with_jsonnull_condition(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        NullableJSONModel.objects.filter(pk=obj.pk).update(\n+            value=Case(\n+                When(\n+                    value=JSONNull(),\n+                    then=Value({\"key\": \"replaced\"}, output_field=JSONField()),\n+                )\n+            ),\n+        )\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.value, {\"key\": \"replaced\"})\n+\n+    def test_key_transform_exact_filter(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": None})\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__key=JSONNull()),\n+            [obj],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__key=None), [obj]\n+        )\n+\n+    def test_index_lookup(self):\n+        obj = NullableJSONModel.objects.create(value=[\"a\", \"b\", None, 3])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__2=JSONNull()), [obj]\n+        )\n+        self.assertSequenceEqual(NullableJSONModel.objects.filter(value__2=None), [obj])\n+\n+    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n+    def test_constraint_validation(self):\n+        constraint = CheckConstraint(\n+            condition=~Q(value=JSONNull()), name=\"check_not_json_null\"\n+        )\n+        constraint.validate(NullableJSONModel, NullableJSONModel(value={\"key\": None}))\n+        msg = f\"Constraint \u201c{constraint.name}\u201d is violated.\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(NullableJSONModel, NullableJSONModel(value=JSONNull()))\n+\n+    def test_constraint_validation_key_transform(self):",
      "comment": "```suggestion\n    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n    def test_constraint_validation_key_transform(self):\n```",
      "comment_id": 2461815733,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-24T19:49:37Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2461815733"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/postgres_tests/test_array.py",
      "line": 1600,
      "side": "RIGHT",
      "diff_hunk": "@@ -1577,3 +1578,30 @@ def test_array_with_choices_display_for_field(self):\n             self.empty_value,\n         )\n         self.assertEqual(display_value, self.empty_value)\n+\n+\n+class TestJSONFieldQuerying(PostgreSQLTestCase):\n+    def test_saving_and_querying_for_sql_null(self):\n+        obj = OtherTypesArrayModel.objects.create(json=[None, None])\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__isnull=True), [obj]\n+        )\n+\n+    def test_saving_and_querying_for_nested_none(self):\n+        obj = OtherTypesArrayModel.objects.create(json=[[None, 1], [None, 2]])\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__0=None), [obj]\n+        )\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__0__isnull=True), []\n+        )\n+\n+    # RemovedInDjango70Warning.\n+    def test_exact_none_deprecation_warning(self):",
      "comment": "The behaviour is changing per 7165ee4f8970886251f6061b4ff05a1e1f452c51, and I changed it now as a breaking change, instead of introducing a deprecation, because I couldn't see a deprecation path.",
      "comment_id": 2461846389,
      "user": "cliffordgama",
      "created_at": "2025-10-24T20:02:25Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2461846389"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/postgres_tests/test_array.py",
      "line": 1600,
      "side": "RIGHT",
      "diff_hunk": "@@ -1577,3 +1578,30 @@ def test_array_with_choices_display_for_field(self):\n             self.empty_value,\n         )\n         self.assertEqual(display_value, self.empty_value)\n+\n+\n+class TestJSONFieldQuerying(PostgreSQLTestCase):\n+    def test_saving_and_querying_for_sql_null(self):\n+        obj = OtherTypesArrayModel.objects.create(json=[None, None])\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__isnull=True), [obj]\n+        )\n+\n+    def test_saving_and_querying_for_nested_none(self):\n+        obj = OtherTypesArrayModel.objects.create(json=[[None, 1], [None, 2]])\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__0=None), [obj]\n+        )\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__0__isnull=True), []\n+        )\n+\n+    # RemovedInDjango70Warning.\n+    def test_exact_none_deprecation_warning(self):",
      "comment": " I only made the change for array=[None, ...] when saving, so if it seems that it has also changed for selects, then that was unintentional and I'd have to investigate.",
      "comment_id": 2461854843,
      "user": "cliffordgama",
      "created_at": "2025-10-24T20:05:22Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2461854843"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/postgres_tests/test_array.py",
      "line": 1600,
      "side": "RIGHT",
      "diff_hunk": "@@ -1577,3 +1578,30 @@ def test_array_with_choices_display_for_field(self):\n             self.empty_value,\n         )\n         self.assertEqual(display_value, self.empty_value)\n+\n+\n+class TestJSONFieldQuerying(PostgreSQLTestCase):\n+    def test_saving_and_querying_for_sql_null(self):\n+        obj = OtherTypesArrayModel.objects.create(json=[None, None])\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__isnull=True), [obj]\n+        )\n+\n+    def test_saving_and_querying_for_nested_none(self):\n+        obj = OtherTypesArrayModel.objects.create(json=[[None, 1], [None, 2]])\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__0=None), [obj]\n+        )\n+        self.assertSequenceEqual(\n+            OtherTypesArrayModel.objects.filter(json__1__0__isnull=True), []\n+        )\n+\n+    # RemovedInDjango70Warning.\n+    def test_exact_none_deprecation_warning(self):",
      "comment": "> Might be nice to rewrite this slightly to assert against the query result so we can keep the test after we remove the deprecation warning.\r\n\r\nYes, I agree. It is only like that is because `None` should be matching JSON `null` in the query, but there is currently no way to store a JSON `null` top-level element of an array per[ this thread](https://github.com/django/django/pull/19794#issuecomment-3437321628).",
      "comment_id": 2461865802,
      "user": "cliffordgama",
      "created_at": "2025-10-24T20:11:32Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2461865802"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,6 +150,27 @@ def formfield(self, **kwargs):\n         )\n \n \n+class JSONNull(expressions.Expression):",
      "comment": "Thanks :+1:, I managed to get it passing locally as well by keeping the `as_sql()` override.",
      "comment_id": 2461895360,
      "user": "cliffordgama",
      "created_at": "2025-10-24T20:27:48Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2461895360"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,6 +150,27 @@ def formfield(self, **kwargs):\n         )\n \n \n+class JSONNull(expressions.Value):\n+    \"\"\"Represent JSON `null` primitive.\"\"\"\n+\n+    def __repr__(self):\n+        return f\"{self.__class__.__name__}()\"\n+\n+    def __init__(self):",
      "comment": "(Sorry to bikeshed here, but I'd place `__init__` first.)",
      "comment_id": 2462868721,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-25T14:41:53Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2462868721"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "django/db/models/fields/json.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -552,7 +594,7 @@ def process_rhs(self, compiler, connection):\n \n     def as_oracle(self, compiler, connection):\n         rhs, rhs_params = super().process_rhs(compiler, connection)\n-        if rhs_params == [\"null\"]:\n+        if tuple(rhs_params) == (\"null\",):",
      "comment": "This seems like it was missed in ticket-35972, I'll open a PR against main if so.",
      "comment_id": 2466256686,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-27T16:08:57Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2466256686"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1392,
      "side": "RIGHT",
      "diff_hunk": "@@ -1241,3 +1258,162 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+@skipUnlessDBFeature(\"supports_primitives_in_json_field\")\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = JSONModel(value=JSONNull())\n+        obj.save()\n+        self.assertIsNone(obj.value)\n+\n+    def test_create(self):\n+        obj = JSONModel.objects.create(value=JSONNull())\n+        self.assertIsNone(obj.value)\n+\n+    def test_update(self):\n+        obj = JSONModel.objects.create(value={\"key\": \"value\"})\n+        JSONModel.objects.update(value=JSONNull())\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_filter(self):\n+        json_null = NullableJSONModel.objects.create(value=JSONNull())\n+        sql_null = NullableJSONModel.objects.create(value=None)\n+        self.assertSequenceEqual(\n+            [json_null], NullableJSONModel.objects.filter(value=JSONNull())\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__isnull=True), [sql_null]\n+        )\n+\n+    def test_bulk_update(self):\n+        obj1 = NullableJSONModel.objects.create(value={\"k\": \"1st\"})\n+        obj2 = NullableJSONModel.objects.create(value={\"k\": \"2nd\"})\n+        obj1.value = JSONNull()\n+        obj2.value = JSONNull()\n+        NullableJSONModel.objects.bulk_update([obj1, obj2], fields=[\"value\"])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value=JSONNull()),\n+            [obj1, obj2],\n+        )\n+\n+    def test_case_expression_with_jsonnull_then(self):\n+        obj = JSONModel.objects.create(value={\"key\": \"value\"})\n+        JSONModel.objects.filter(pk=obj.pk).update(\n+            value=Case(\n+                When(value={\"key\": \"value\"}, then=JSONNull()),\n+            )\n+        )\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value)\n+\n+    def test_case_expr_with_jsonnull_condition(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        NullableJSONModel.objects.filter(pk=obj.pk).update(\n+            value=Case(\n+                When(\n+                    value=JSONNull(),\n+                    then=Value({\"key\": \"replaced\"}, output_field=JSONField()),\n+                )\n+            ),\n+        )\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.value, {\"key\": \"replaced\"})\n+\n+    def test_key_transform_exact_filter(self):\n+        obj = NullableJSONModel.objects.create(value={\"key\": None})\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__key=JSONNull()),\n+            [obj],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__key=None), [obj]\n+        )\n+\n+    def test_index_lookup(self):\n+        obj = NullableJSONModel.objects.create(value=[\"a\", \"b\", None, 3])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__2=JSONNull()), [obj]\n+        )\n+        self.assertSequenceEqual(NullableJSONModel.objects.filter(value__2=None), [obj])\n+\n+    def test_filter_in(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__in=[JSONNull()]),\n+            [obj],\n+        )\n+\n+    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n+    def test_constraint_validation(self):\n+        constraint = CheckConstraint(\n+            condition=~Q(value=JSONNull()), name=\"check_not_json_null\"\n+        )\n+        constraint.validate(NullableJSONModel, NullableJSONModel(value={\"key\": None}))\n+        msg = f\"Constraint \u201c{constraint.name}\u201d is violated.\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(NullableJSONModel, NullableJSONModel(value=JSONNull()))\n+\n+    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n+    def test_constraint_validation_key_transform(self):\n+        constraint = CheckConstraint(\n+            condition=Q(value__has_key=\"name\") & ~Q(value__name=JSONNull()),\n+            name=\"check_value_name_not_json_null\",\n+        )\n+        constraint.validate(\n+            NullableJSONModel, NullableJSONModel(value={\"name\": \"Django\"})\n+        )\n+        msg = f\"Constraint \u201c{constraint.name}\u201d is violated.\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n+            constraint.validate(\n+                NullableJSONModel, NullableJSONModel(value={\"name\": None})\n+            )\n+\n+    def test_default(self):\n+        obj = JSONNullDefaultModel.objects.create()\n+        self.assertIsNone(obj.value)\n+\n+    def test_custom_jsonnull_encoder(self):\n+        obj = JSONNullDefaultModel.objects.create(\n+            value={\"name\": JSONNull(), \"array\": [1, JSONNull()]}\n+        )\n+        obj.refresh_from_db()\n+        self.assertIsNone(obj.value[\"name\"])\n+        self.assertEqual(obj.value[\"array\"], [1, None])\n+\n+\n+# RemovedInDjango70Warning.\n+@skipUnlessDBFeature(\"supports_primitives_in_json_field\")\n+class JSONExactNoneDeprecationTests(TestCase):\n+    def setUp(self):",
      "comment": "We usually use `setUpTestData` to avoid recreating an object every time.",
      "comment_id": 2469220343,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-28T11:40:43Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2469220343"
    },
    {
      "repo": "django/django",
      "pr_number": 19794,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1263,
      "side": "RIGHT",
      "diff_hunk": "@@ -1235,3 +1251,112 @@ def test_literal_annotation_filtering(self):\n             data__foo=\"bar\"\n         )\n         self.assertQuerySetEqual(qs, all_objects)\n+\n+\n+class JSONNullTests(TestCase):\n+    def test_repr(self):\n+        self.assertEqual(repr(JSONNull()), \"JSONNull()\")\n+\n+    def test_save_load(self):\n+        obj = NullableJSONModel(value=JSONNull())\n+        obj.save()\n+        obj.refresh_from_db()",
      "comment": "Spotted this pattern elsewhere and realized why it's here, it's testing the \"load\" of the save/load cycle. So we could have left it in.",
      "comment_id": 2499754162,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-06T16:23:12Z",
      "url": "https://github.com/django/django/pull/19794#discussion_r2499754162"
    },
    {
      "repo": "django/django",
      "pr_number": 19440,
      "file_path": "django/contrib/admin/checks.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -333,9 +333,13 @@ def _check_fields(self, obj):\n             ]\n         fields = flatten(obj.fields)\n         if len(fields) != len(set(fields)):\n+            duplicated_fields = list(\n+                sorted({field for field in fields if fields.count(field) > 1})\n+            )\n             return [\n                 checks.Error(\n                     \"The value of 'fields' contains duplicate field(s).\",\n+                    hint=\"Remove duplicates of these field(s): %s.\" % duplicated_fields,",
      "comment": "Favor the usage of a `collections.Counter` for these kind of things to avoid scanning `fields` multiple times\r\n\r\n```suggestion\r\n        fields = Counter(flatten(obj.fields))\r\n        if duplicate_fields := [field for field, count in fields.items() if count > 1]:\r\n            return [\r\n                checks.Error(\r\n                    \"The value of 'fields' contains duplicate field(s).\",\r\n                    hint=\"Remove duplicates of these field(s): %s.\" % duplicated_fields,\r\n```",
      "comment_id": 2070838534,
      "user": "charettes",
      "created_at": "2025-05-01T21:35:00Z",
      "url": "https://github.com/django/django/pull/19440#discussion_r2070838534"
    },
    {
      "repo": "django/django",
      "pr_number": 19440,
      "file_path": "django/contrib/admin/checks.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,11 +331,14 @@ def _check_fields(self, obj):\n                     id=\"admin.E005\",\n                 )\n             ]\n-        fields = flatten(obj.fields)\n-        if len(fields) != len(set(fields)):\n+        field_counts = collections.Counter(flatten(obj.fields))\n+        if duplicate_fields := sorted(\n+            [field for field, count in field_counts.items() if count > 1]\n+        ):",
      "comment": "You can do without the list comprehension here:\r\n```suggestion\r\n        if duplicate_fields := sorted(\r\n            field for field, count in field_counts.items() if count > 1\r\n        ):\r\n```",
      "comment_id": 2072438910,
      "user": "g-nie",
      "created_at": "2025-05-03T17:56:36Z",
      "url": "https://github.com/django/django/pull/19440#discussion_r2072438910"
    },
    {
      "repo": "django/django",
      "pr_number": 19440,
      "file_path": "django/contrib/admin/checks.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,11 +331,14 @@ def _check_fields(self, obj):\n                     id=\"admin.E005\",\n                 )\n             ]\n-        fields = flatten(obj.fields)\n-        if len(fields) != len(set(fields)):\n+        field_counts = collections.Counter(flatten(obj.fields))\n+        if duplicate_fields := sorted(\n+            [field for field, count in field_counts.items() if count > 1]\n+        ):",
      "comment": "One more thought, do we need the sorting? If you find it useful for displaying purposes, maybe an idea is to do it only when there are duplicated fields, which has the benefit of not doing extra work when there's no error, i.e:\r\n\r\n```python\r\nif duplicate_fields := [field for field, count in field_counts.items() if count > 1]:\r\n    return [\r\n        checks.Error(\r\n            \"The value of 'fields' contains duplicate field(s).\",\r\n            hint=\"Remove duplicates of these field(s): %s.\" % sorted(duplicate_fields),\r\n            obj=obj.__class__,\r\n            id=\"admin.E006\",\r\n        )\r\n    ]\r\n```",
      "comment_id": 2072441042,
      "user": "g-nie",
      "created_at": "2025-05-03T18:11:03Z",
      "url": "https://github.com/django/django/pull/19440#discussion_r2072441042"
    },
    {
      "repo": "django/django",
      "pr_number": 19440,
      "file_path": "django/contrib/admin/checks.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,11 +331,14 @@ def _check_fields(self, obj):\n                     id=\"admin.E005\",\n                 )\n             ]\n-        fields = flatten(obj.fields)\n-        if len(fields) != len(set(fields)):\n+        field_counts = collections.Counter(flatten(obj.fields))\n+        if duplicate_fields := sorted(\n+            [field for field, count in field_counts.items() if count > 1]\n+        ):",
      "comment": "@g-nie yeah it was partly just for consistent ordering for the sake of the tests but sorting can happen only on errors to reduce possibly unneeded work, thanks for the suggestion",
      "comment_id": 2072474080,
      "user": "Safrone",
      "created_at": "2025-05-03T22:05:14Z",
      "url": "https://github.com/django/django/pull/19440#discussion_r2072474080"
    },
    {
      "repo": "django/django",
      "pr_number": 19440,
      "file_path": "django/contrib/admin/checks.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,11 +331,15 @@ def _check_fields(self, obj):\n                     id=\"admin.E005\",\n                 )\n             ]\n-        fields = flatten(obj.fields)\n-        if len(fields) != len(set(fields)):\n+        field_counts = collections.Counter(flatten(obj.fields))\n+        if duplicate_fields := [\n+            field for field, count in field_counts.items() if count > 1\n+        ]:\n             return [\n                 checks.Error(\n                     \"The value of 'fields' contains duplicate field(s).\",\n+                    hint=\"Remove duplicates of these field(s): %s.\"\n+                    % sorted(duplicate_fields),",
      "comment": "I'm not sure it's worth calling `sorted`\r\nI also think I would prefer the hint to say `\"Remove duplicates of 'example_field_1', 'example_field_2'.\"`",
      "comment_id": 2077742615,
      "user": "sarahboyce",
      "created_at": "2025-05-07T14:17:13Z",
      "url": "https://github.com/django/django/pull/19440#discussion_r2077742615"
    },
    {
      "repo": "django/django",
      "pr_number": 19440,
      "file_path": "django/contrib/admin/checks.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,11 +331,15 @@ def _check_fields(self, obj):\n                     id=\"admin.E005\",\n                 )\n             ]\n-        fields = flatten(obj.fields)\n-        if len(fields) != len(set(fields)):\n+        field_counts = collections.Counter(flatten(obj.fields))\n+        if duplicate_fields := [\n+            field for field, count in field_counts.items() if count > 1\n+        ]:\n             return [\n                 checks.Error(\n                     \"The value of 'fields' contains duplicate field(s).\",\n+                    hint=\"Remove duplicates of these field(s): %s.\"\n+                    % sorted(duplicate_fields),",
      "comment": "Removed the sorting, though I found a slight inaccuracy in the messaging when there are multiple duplicates across fieldsets so I added extra checks to only raise the error for the fields in the current fieldset and added a test for that",
      "comment_id": 2078747195,
      "user": "Safrone",
      "created_at": "2025-05-08T01:29:23Z",
      "url": "https://github.com/django/django/pull/19440#discussion_r2078747195"
    },
    {
      "repo": "django/django",
      "pr_number": 20496,
      "file_path": "django/tasks/base.py",
      "line": 190,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,7 +187,7 @@ class TaskResult:\n     # Time the task was last attempted to be run.\n     last_attempted_at: Optional[datetime]\n \n-    args: list  # Arguments to pass to the task function.\n+    args: list[Any]  # Arguments to pass to the task function.",
      "comment": "Question: is `list` not just a shorthand for `list[Any]`? Does this improve the type signature at all?",
      "comment_id": 2661333487,
      "user": "RealOrangeOne",
      "created_at": "2026-01-05T12:27:40Z",
      "url": "https://github.com/django/django/pull/20496#discussion_r2661333487"
    },
    {
      "repo": "django/django",
      "pr_number": 20496,
      "file_path": "django/tasks/base.py",
      "line": 190,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,7 +187,7 @@ class TaskResult:\n     # Time the task was last attempted to be run.\n     last_attempted_at: Optional[datetime]\n \n-    args: list  # Arguments to pass to the task function.\n+    args: list[Any]  # Arguments to pass to the task function.",
      "comment": "Implicitly, yes, but it's often helpful to be explicit.\n\nIn addition, when enabling mypy's [`--disallow-any-generics`](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-disallow-any-generics), which is included when using the [`--strict`](https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-strict) flag, implicit type parameters will error.",
      "comment_id": 2662329817,
      "user": "ngnpope",
      "created_at": "2026-01-05T17:50:24Z",
      "url": "https://github.com/django/django/pull/20496#discussion_r2662329817"
    },
    {
      "repo": "django/django",
      "pr_number": 20321,
      "file_path": "django/db/models/sql/compiler.py",
      "line": 1628,
      "side": "RIGHT",
      "diff_hunk": "@@ -1621,9 +1621,15 @@ def execute_sql(\n             cursor = self.connection.cursor()\n         try:\n             cursor.execute(sql, params)\n-        except Exception:\n+        except Exception as e:\n             # Might fail for server-side cursors (e.g. connection closed)\n-            cursor.close()\n+            try:\n+                cursor.close()\n+            except Exception:",
      "comment": "```suggestion\n            except DatabaseError:\n```",
      "comment_id": 2624538705,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T19:49:43Z",
      "url": "https://github.com/django/django/pull/20321#discussion_r2624538705"
    },
    {
      "repo": "django/django",
      "pr_number": 20321,
      "file_path": "django/db/models/sql/compiler.py",
      "line": 1633,
      "side": "RIGHT",
      "diff_hunk": "@@ -1621,9 +1621,15 @@ def execute_sql(\n             cursor = self.connection.cursor()\n         try:\n             cursor.execute(sql, params)\n-        except Exception:\n+        except Exception as e:\n             # Might fail for server-side cursors (e.g. connection closed)",
      "comment": "Please move this comment into the new inner except.",
      "comment_id": 2624540432,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T19:50:24Z",
      "url": "https://github.com/django/django/pull/20321#discussion_r2624540432"
    },
    {
      "repo": "django/django",
      "pr_number": 20321,
      "file_path": "tests/queries/test_execute_sql.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from unittest import mock\n+\n+from django.db import DatabaseError, connection, models\n+from django.db.models.sql.compiler import SQLCompiler\n+from django.db.models.sql.query import Query\n+from django.test import TestCase\n+\n+\n+class DummyModel(models.Model):\n+    class Meta:\n+        app_label = \"tests\"\n+        managed = False\n+\n+\n+class ExecuteSqlCursorCloseErrorTests(TestCase):\n+    def test_execute_sql_raises_original_exception_when_close_fails(self):\n+        # Build compiler\n+        query = Query(DummyModel)\n+        compiler = SQLCompiler(query, connection, None)\n+\n+        # Fake cursor\n+        cursor = mock.MagicMock()\n+\n+        # Step 1: execution fails\n+        execute_err = DatabaseError(\"execute failed\")\n+        cursor.execute.side_effect = execute_err\n+\n+        # Step 2: closing fails\n+        cursor.close.side_effect = DatabaseError(\"close failed\")\n+\n+        # Patch connection.cursor() to use our fake cursor\n+        with mock.patch.object(connection, \"cursor\", return_value=cursor):\n+            with self.assertRaises(DatabaseError) as ctx:\n+                compiler.execute_sql(\"SELECT 1\", [])\n+\n+        # Must be *execute* error, not close error\n+        assert str(ctx.exception) == \"execute failed\"",
      "comment": "Assert against `ctx.exception.__cause__` and `__suppress_context__` similar to `test_fetch_mode_raise_forward` and others.",
      "comment_id": 2624545645,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T19:52:12Z",
      "url": "https://github.com/django/django/pull/20321#discussion_r2624545645"
    },
    {
      "repo": "django/django",
      "pr_number": 20321,
      "file_path": "tests/queries/test_execute_sql.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from unittest import mock\n+\n+from django.db import DatabaseError, connection, models\n+from django.db.models.sql.compiler import SQLCompiler\n+from django.db.models.sql.query import Query\n+from django.test import TestCase\n+\n+\n+class DummyModel(models.Model):\n+    class Meta:\n+        app_label = \"tests\"\n+        managed = False\n+\n+\n+class ExecuteSqlCursorCloseErrorTests(TestCase):\n+    def test_execute_sql_raises_original_exception_when_close_fails(self):\n+        # Build compiler",
      "comment": "You can remove most of these comments. You can leave the execution fails & closing fails comments if you like, as that's the interesting part -- the fact that we need nested failures.",
      "comment_id": 2624547551,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T19:52:53Z",
      "url": "https://github.com/django/django/pull/20321#discussion_r2624547551"
    },
    {
      "repo": "django/django",
      "pr_number": 20321,
      "file_path": "tests/queries/test_execute_sql.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from unittest import mock\n+\n+from django.db import DatabaseError, connection, models\n+from django.db.models.sql.compiler import SQLCompiler\n+from django.db.models.sql.query import Query\n+from django.test import TestCase\n+\n+\n+class DummyModel(models.Model):\n+    class Meta:\n+        app_label = \"tests\"\n+        managed = False\n+\n+\n+class ExecuteSqlCursorCloseErrorTests(TestCase):\n+    def test_execute_sql_raises_original_exception_when_close_fails(self):",
      "comment": "The original exception was already raised, it just had extra context, so I'd suggest tweaking this title.",
      "comment_id": 2624566342,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T20:00:04Z",
      "url": "https://github.com/django/django/pull/20321#discussion_r2624566342"
    },
    {
      "repo": "django/django",
      "pr_number": 20321,
      "file_path": "tests/queries/test_execute_sql.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,37 @@\n+from unittest import mock\n+\n+from django.db import DatabaseError, connection, models\n+from django.db.models.sql.compiler import SQLCompiler\n+from django.db.models.sql.query import Query\n+from django.test import TestCase\n+\n+\n+class DummyModel(models.Model):\n+    class Meta:\n+        app_label = \"tests\"\n+        managed = False",
      "comment": "You can remove the model:\n\n```diff\ndiff --git a/tests/queries/test_execute_sql.py b/tests/queries/test_execute_sql.py\nindex 6e9e578093..213ac21f53 100644\n--- a/tests/queries/test_execute_sql.py\n+++ b/tests/queries/test_execute_sql.py\n@@ -1,21 +1,15 @@\n from unittest import mock\n \n-from django.db import DatabaseError, connection, models\n+from django.db import DatabaseError, connection\n from django.db.models.sql.compiler import SQLCompiler\n from django.db.models.sql.query import Query\n from django.test import TestCase\n \n \n-class DummyModel(models.Model):\n-    class Meta:\n-        app_label = \"tests\"\n-        managed = False\n-\n-\n class ExecuteSqlCursorCloseErrorTests(TestCase):\n     def test_execute_sql_raises_original_exception_when_close_fails(self):\n         # Build compiler\n-        query = Query(DummyModel)\n+        query = Query(None)\n         compiler = SQLCompiler(query, connection, None)\n \n         # Fake cursor\n```",
      "comment_id": 2624575895,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T20:03:33Z",
      "url": "https://github.com/django/django/pull/20321#discussion_r2624575895"
    },
    {
      "repo": "django/django",
      "pr_number": 20471,
      "file_path": "django/contrib/admin/widgets.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -122,6 +122,7 @@ class AdminRadioSelect(forms.RadioSelect):\n \n class AdminFileWidget(forms.ClearableFileInput):\n     template_name = \"admin/widgets/clearable_file_input.html\"\n+    use_fieldset = True",
      "comment": "The AdminFileWidget class now explicitly sets use_fieldset to True, but there's no test coverage to verify this attribute value. Since the base ClearableFileInput has test coverage for use_fieldset in test_clearablefileinput.py, consider adding a similar test for AdminFileWidget to prevent future regressions of this attribute.",
      "comment_id": 2649172415,
      "user": "Copilot",
      "created_at": "2025-12-27T14:49:03Z",
      "url": "https://github.com/django/django/pull/20471#discussion_r2649172415"
    },
    {
      "repo": "django/django",
      "pr_number": 20471,
      "file_path": "tests/admin_widgets/tests.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -582,6 +594,9 @@ def test_attrs(self):\n \n @override_settings(ROOT_URLCONF=\"admin_widgets.urls\")\n class AdminFileWidgetTests(TestDataMixin, TestCase):\n+    def setUp(self):",
      "comment": "I'll revert the changes to this file, as the admin's rendering of file fields with a `<fieldset>` was already covered in `test_use_fieldset_fields_render()`:\n```py\n======================================================================\nFAIL: test_use_fieldset_fields_render (admin_views.tests.SeleniumTests.test_use_fieldset_fields_render)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File \"/Users/jwalls/django/tests/admin_views/tests.py\", line 6960, in test_use_fieldset_fields_render\n    self.assertEqual(legend.text, expected_legend_tags_text[index])\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: 'Difficulty:' != 'Materials:'\n- Difficulty:\n+ Materials:\n\n\n----------------------------------------------------------------------\nRan 1 test in 10.571s\n```",
      "comment_id": 2655423077,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-31T13:43:04Z",
      "url": "https://github.com/django/django/pull/20471#discussion_r2655423077"
    },
    {
      "repo": "django/django",
      "pr_number": 20288,
      "file_path": "tests/signals/tests.py",
      "line": 681,
      "side": "RIGHT",
      "diff_hunk": "@@ -645,3 +646,238 @@ async def test_asend_robust_only_async_receivers(self):\n \n         result = await signal.asend_robust(self.__class__)\n         self.assertEqual(result, [(async_handler, 1)])\n+\n+\n+class TestReceiversContextVarsSharing(SimpleTestCase):\n+    def setUp(self):\n+        self.ctx_var = contextvars.ContextVar(\"test_var\", default=0)\n+\n+        class CtxSyncHandler:\n+            def __init__(self, ctx_var):\n+                self.ctx_var = ctx_var\n+                self.values = []\n+\n+            def __call__(self, **kwargs):\n+                val = self.ctx_var.get()\n+                self.ctx_var.set(val + 1)\n+                self.values.append(self.ctx_var.get())\n+                return self.ctx_var.get()\n+\n+        class CtxAsyncHandler:\n+            def __init__(self, ctx_var):\n+                self.ctx_var = ctx_var\n+                self.values = []\n+                markcoroutinefunction(self)\n+\n+            async def __call__(self, **kwargs):\n+                val = self.ctx_var.get()\n+                self.ctx_var.set(val + 1)\n+                self.values.append(self.ctx_var.get())\n+                return self.ctx_var.get()\n+\n+        self.CtxSyncHandler = CtxSyncHandler\n+        self.CtxAsyncHandler = CtxAsyncHandler\n+\n+    async def test_asend_correct_contextvars_sharing_async_receivers(self):",
      "comment": "I tried using `.subTest` to reduce the number of tests for `asend/asend_robust` and `send/send_robust`, but the error output became unreadable.\r\n\r\n```\r\n  File \"/Users/m.havelya/work/django/django/test/testcases.py\", line 87, in is_pickable\r\n    pickle.loads(pickle.dumps(obj))\r\n    ^^^^^^^^^^^^^^^\r\n\r\n   ....\r\n\r\n  File \"/Users/m.havelya/work/django/django/test/testcases.py\", line 325, in __getstate__\r\n    if key in pickable_state or not is_pickable(value):\r\n    ^^^^^^^\r\n  File \"/Users/m.havelya/work/django/django/test/testcases.py\", line 87, in is_pickable\r\n    pickle.loads(pickle.dumps(obj))\r\n    ^^^^^^^^^^^^^^^\r\n  File \"/Users/m.havelya/work/django/django/test/testcases.py\", line 325, in __getstate__\r\n    if key in pickable_state or not is_pickable(value):\r\n    ^^^^^^^\r\nRecursionError: maximum recursion depth exceeded\r\n\r\n----------------------------------------------------------------------\r\nRan 31 tests in 0.439s\r\n\r\nFAILED (errors=1)\r\n```\r\n\r\nSo I dropped the idea. Using separate tests is more readable.",
      "comment_id": 2549721274,
      "user": "Arfey",
      "created_at": "2025-11-21T13:12:05Z",
      "url": "https://github.com/django/django/pull/20288#discussion_r2549721274"
    },
    {
      "repo": "django/django",
      "pr_number": 20288,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,26 +23,41 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n-async def _gather(*coros):\n-    if len(coros) == 0:\n-        return []\n+async def _run_parallel(*coroutines):",
      "comment": "Summary:\r\n\r\n- Removed the `len(coros) == 1` optimization. It doesn\u2019t appear to provide any real benefit.\r\n\r\n```\r\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\r\n\u2503                        Benchmark \u2503 Min     \u2503 Max     \u2503 Mean    \u2503 Min (+)         \u2503 Max (+)         \u2503 Mean (+)        \u2503\r\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\r\n\u2502 TaskGroup instead of create_task \u2502 0.001   \u2502 0.001   \u2502 0.001   \u2502 0.001 (1.1x)    \u2502 0.002 (-1.1x)   \u2502 0.001 (1.1x)    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n- All coroutines now share the same context, which is restored to the current context after completion.\r\n\r\n\r\nbtw:\r\n\r\n- `_restore_context` is just a copy-paste from the `asgiref` library",
      "comment_id": 2589828115,
      "user": "Arfey",
      "created_at": "2025-12-04T16:48:06Z",
      "url": "https://github.com/django/django/pull/20288#discussion_r2589828115"
    },
    {
      "repo": "django/django",
      "pr_number": 20288,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 319,
      "side": "RIGHT",
      "diff_hunk": "@@ -290,14 +308,12 @@ def sync_send():\n             async def sync_send():\n                 return []\n \n-        responses, async_responses = await _gather(\n-            sync_send(),\n-            _gather(\n-                *(\n-                    receiver(signal=self, sender=sender, **named)\n-                    for receiver in async_receivers\n-                )\n-            ),\n+        responses = await sync_send()\n+        async_responses = await _run_parallel(\n+            *(\n+                receiver(signal=self, sender=sender, **named)\n+                for receiver in async_receivers\n+            )",
      "comment": "Should we update the docstrings for `asend()`/`asend_robust()` now? It reads, \"If any receivers are asynchronous, they are grouped and executed concurrently...\", which is a little bit ambiguous, but if \"they\" is \"all the receivers\", then they're not all concurrent anymore.",
      "comment_id": 2627697128,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-17T16:17:01Z",
      "url": "https://github.com/django/django/pull/20288#discussion_r2627697128"
    },
    {
      "repo": "django/django",
      "pr_number": 20288,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,26 +23,42 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n-async def _gather(*coros):\n+async def _run_parallel(*coros):\n+    \"\"\"\n+    Execute multiple asynchronous coroutines in parallel,\n+    sharing the current context between them.\n+    \"\"\"\n+    context = contextvars.copy_context()\n+\n+    def _restore_context(context):",
      "comment": "I see we're coping this from `asgiref`. Is that only because it's marked as private? We could ask Carlton if he minds us importing it and/or if he wants to make it public in the next release.",
      "comment_id": 2627755315,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-17T16:31:33Z",
      "url": "https://github.com/django/django/pull/20288#discussion_r2627755315"
    },
    {
      "repo": "django/django",
      "pr_number": 20288,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,26 +23,42 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n-async def _gather(*coros):\n+async def _run_parallel(*coros):\n+    \"\"\"\n+    Execute multiple asynchronous coroutines in parallel,\n+    sharing the current context between them.\n+    \"\"\"\n+    context = contextvars.copy_context()\n+\n+    def _restore_context(context):",
      "comment": "Also, it would be nice to lift this up out of the function definition.",
      "comment_id": 2627809498,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-17T16:47:28Z",
      "url": "https://github.com/django/django/pull/20288#discussion_r2627809498"
    },
    {
      "repo": "django/django",
      "pr_number": 20288,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 319,
      "side": "RIGHT",
      "diff_hunk": "@@ -290,14 +308,12 @@ def sync_send():\n             async def sync_send():\n                 return []\n \n-        responses, async_responses = await _gather(\n-            sync_send(),\n-            _gather(\n-                *(\n-                    receiver(signal=self, sender=sender, **named)\n-                    for receiver in async_receivers\n-                )\n-            ),\n+        responses = await sync_send()\n+        async_responses = await _run_parallel(\n+            *(\n+                receiver(signal=self, sender=sender, **named)\n+                for receiver in async_receivers\n+            )",
      "comment": "Never mind, looking at the context right before this, I guess \"they\" means the asynchronous ones, so this should be fine.",
      "comment_id": 2633063601,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-18T23:57:19Z",
      "url": "https://github.com/django/django/pull/20288#discussion_r2633063601"
    },
    {
      "repo": "django/django",
      "pr_number": 20288,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,26 +23,42 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n-async def _gather(*coros):\n+async def _run_parallel(*coros):\n+    \"\"\"\n+    Execute multiple asynchronous coroutines in parallel,\n+    sharing the current context between them.\n+    \"\"\"\n+    context = contextvars.copy_context()\n+\n+    def _restore_context(context):",
      "comment": "- Is that only because it's marked as private? - yes \ud83d\ude0c\r\n\r\n- We could ask Carlton if he minds us importing it and/or if he wants to make it public in the next release - it's much more robust to keep them separate\r\n",
      "comment_id": 2640493507,
      "user": "Arfey",
      "created_at": "2025-12-22T16:40:43Z",
      "url": "https://github.com/django/django/pull/20288#discussion_r2640493507"
    },
    {
      "repo": "django/django",
      "pr_number": 20288,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,26 +23,42 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n-async def _gather(*coros):\n+async def _run_parallel(*coros):\n+    \"\"\"\n+    Execute multiple asynchronous coroutines in parallel,\n+    sharing the current context between them.\n+    \"\"\"\n+    context = contextvars.copy_context()\n+\n+    def _restore_context(context):",
      "comment": "- Also, it would be nice to lift this up out of the function definition.\r\n\r\ndone \ud83d\ude42",
      "comment_id": 2640505886,
      "user": "Arfey",
      "created_at": "2025-12-22T16:45:53Z",
      "url": "https://github.com/django/django/pull/20288#discussion_r2640505886"
    },
    {
      "repo": "django/django",
      "pr_number": 20445,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1734,
      "side": "RIGHT",
      "diff_hunk": "@@ -1715,40 +1715,46 @@ def __init__(\n \n     def check(self, **kwargs):\n         errors = super().check(**kwargs)\n+        databases = kwargs.get(\"databases\") or []\n \n         digits_errors = [\n-            *self._check_decimal_places(),\n-            *self._check_max_digits(),\n+            *self._check_decimal_places(databases),\n+            *self._check_max_digits(databases),\n         ]\n         if not digits_errors:\n             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))\n         else:\n             errors.extend(digits_errors)\n         return errors\n \n-    def _check_decimal_places(self):\n+    def _check_decimal_places(self, databases):\n         if self.decimal_places is None:\n-            if (\n-                not connection.features.supports_no_precision_decimalfield\n-                and \"supports_no_precision_decimalfield\"\n-                not in self.model._meta.required_db_features\n-            ):\n-                return [\n-                    checks.Error(\n-                        \"DecimalFields must define a 'decimal_places' attribute.\",\n-                        obj=self,\n-                        id=\"fields.E130\",\n-                    )\n-                ]\n-            elif self.max_digits is not None:\n-                return [\n-                    checks.Error(\n-                        \"DecimalField\u2019s max_digits and decimal_places must both \"\n-                        \"be defined or both omitted.\",\n-                        obj=self,\n-                        id=\"fields.E135\",\n-                    ),\n-                ]\n+            for db in databases:\n+                if not router.allow_migrate_model(db, self.model):\n+                    continue",
      "comment": "Any thoughts about moving this skip to `check`? I wonder if it might be worth adjusting `Model.check` to eventually skip delegation when `not router.allow_migrate_model(db, self.model)`.",
      "comment_id": 2644234920,
      "user": "charettes",
      "created_at": "2025-12-23T20:49:33Z",
      "url": "https://github.com/django/django/pull/20445#discussion_r2644234920"
    },
    {
      "repo": "django/django",
      "pr_number": 20445,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1777,
      "side": "RIGHT",
      "diff_hunk": "@@ -1764,29 +1770,32 @@ def _check_decimal_places(self):\n                 ]\n         return []\n \n-    def _check_max_digits(self):\n+    def _check_max_digits(self, databases):\n         if self.max_digits is None:\n-            if (\n-                not connection.features.supports_no_precision_decimalfield\n-                and \"supports_no_precision_decimalfield\"\n-                not in self.model._meta.required_db_features\n-            ):\n-                return [\n-                    checks.Error(\n-                        \"DecimalFields must define a 'max_digits' attribute.\",\n-                        obj=self,\n-                        id=\"fields.E132\",\n-                    )\n-                ]\n-            elif self.decimal_places is not None:\n-                return [\n-                    checks.Error(\n-                        \"DecimalField\u2019s max_digits and decimal_places must both \"\n-                        \"be defined or both omitted.\",\n-                        obj=self,\n-                        id=\"fields.E135\",\n-                    ),\n-                ]\n+            for db in databases:\n+                if not router.allow_migrate_model(db, self.model):\n+                    continue",
      "comment": "I think you're missing `connection = connections[db]` here?",
      "comment_id": 2644235375,
      "user": "charettes",
      "created_at": "2025-12-23T20:49:50Z",
      "url": "https://github.com/django/django/pull/20445#discussion_r2644235375"
    },
    {
      "repo": "django/django",
      "pr_number": 20445,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1734,
      "side": "RIGHT",
      "diff_hunk": "@@ -1715,40 +1715,46 @@ def __init__(\n \n     def check(self, **kwargs):\n         errors = super().check(**kwargs)\n+        databases = kwargs.get(\"databases\") or []\n \n         digits_errors = [\n-            *self._check_decimal_places(),\n-            *self._check_max_digits(),\n+            *self._check_decimal_places(databases),\n+            *self._check_max_digits(databases),\n         ]\n         if not digits_errors:\n             errors.extend(self._check_decimal_places_and_max_digits(**kwargs))\n         else:\n             errors.extend(digits_errors)\n         return errors\n \n-    def _check_decimal_places(self):\n+    def _check_decimal_places(self, databases):\n         if self.decimal_places is None:\n-            if (\n-                not connection.features.supports_no_precision_decimalfield\n-                and \"supports_no_precision_decimalfield\"\n-                not in self.model._meta.required_db_features\n-            ):\n-                return [\n-                    checks.Error(\n-                        \"DecimalFields must define a 'decimal_places' attribute.\",\n-                        obj=self,\n-                        id=\"fields.E130\",\n-                    )\n-                ]\n-            elif self.max_digits is not None:\n-                return [\n-                    checks.Error(\n-                        \"DecimalField\u2019s max_digits and decimal_places must both \"\n-                        \"be defined or both omitted.\",\n-                        obj=self,\n-                        id=\"fields.E135\",\n-                    ),\n-                ]\n+            for db in databases:\n+                if not router.allow_migrate_model(db, self.model):\n+                    continue",
      "comment": "The second branch (when `decimal_places` is not `None`) should always run, that's why I put it here.",
      "comment_id": 2644249178,
      "user": "felixxm",
      "created_at": "2025-12-23T20:58:21Z",
      "url": "https://github.com/django/django/pull/20445#discussion_r2644249178"
    },
    {
      "repo": "django/django",
      "pr_number": 20312,
      "file_path": "tests/backends/base/test_base.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -436,3 +437,34 @@ def test_multi_database_init_connection_state_called_once(self):\n                             len(mocked_check_database_version_supported.mock_calls),\n                             after_first_calls,\n                         )\n+\n+\n+class DummyCursor:\n+    def __init__(self, statement=None):\n+        self.statement = statement\n+\n+\n+class DummyConnection:\n+    vendor = \"sqlite\"\n+    alias = \"default\"\n+    features = MagicMock()\n+    settings_dict = {}\n+\n+    def __init__(self):\n+        self.ops = DummyBackendOperations(self)\n+        self.queries_log = []\n+\n+\n+class DummyBackendOperations(BaseDatabaseOperations):\n+    \"\"\"\n+    Simulates a backend with the fallback behavior implemented in the patch:\n+    - If cursor.statement is truthy, return it.\n+    - If cursor.statement is None, fallback to the base implementation.\n+    \"\"\"\n+\n+    def __init__(self, connection):\n+        super().__init__(connection)\n+\n+    def last_executed_query(self, cursor, sql, params):\n+        statement = getattr(cursor, \"statement\", None)\n+        return statement or super().last_executed_query(cursor, sql, params)",
      "comment": "This is not a regression test. TBH it is not a test at all.",
      "comment_id": 2566338258,
      "user": "felixxm",
      "created_at": "2025-11-26T19:57:10Z",
      "url": "https://github.com/django/django/pull/20312#discussion_r2566338258"
    },
    {
      "repo": "django/django",
      "pr_number": 20312,
      "file_path": "tests/backends/oracle/test_last_executed_query.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,35 @@\n+from unittest import skipUnless\n+\n+from django.db import connection\n+from django.db.backends.base.operations import BaseDatabaseOperations\n+from django.test import TestCase\n+\n+# Oracle backend import guard.\n+# Importing oracle.operations will fail on\n+# environments without the oracledb driver.\n+try:\n+    from django.db.backends.oracle.operations import DatabaseOperations\n+except Exception:\n+    DatabaseOperations = None\n+\n+\n+@skipUnless(connection.vendor == \"oracle\", \"Oracle-specific tests\")\n+class TestLastExecutedQueryFallback(TestCase):\n+    def test_last_executed_query_fallback(self):\n+        if DatabaseOperations is None:\n+            self.skipTest(\"Oracle backend not available\")\n+\n+        class FakeCursor:\n+            # Simulates a cursor lacking the `statement` attribute\n+            pass\n+\n+        cursor = FakeCursor()\n+        sql = \"SELECT 1\"\n+        params = []\n+\n+        ops = DatabaseOperations(None)\n+\n+        # Expected fallback from BaseDatabaseOperations\n+        expected = BaseDatabaseOperations(None).last_executed_query(cursor, sql, params)\n+\n+        self.assertEqual(ops.last_executed_query(cursor, sql, params), expected)",
      "comment": "Why do you need a new instance of `DatabaseOperations`? Also it should be enough to check that result of `last_executed_query()` is not `None`.\r\n```suggestion\r\n\r\n@skipUnless(connection.vendor == \"oracle\", \"Oracle specific tests\")\r\nclass TestLastExecutedQueryFallback(TestCase):\r\n    def test_last_executed_query_fallback(self):\r\n        class FakeCursor:\r\n            # Simulates a cursor lacking the `statement` attribute\r\n            pass\r\n\r\n        cursor = FakeCursor()\r\n        sql = \"SELECT 1\"\r\n        params = []\r\n\r\n        self.assertIsNotNone(connection.ops.last_executed_query(cursor, sql, params))\r\n```\r\n\r\nWe could also use a real cursor with an invalid SQL statement, e.g.\r\n```\r\nwith connection.cursor() as cursor:\r\n    sql = \"INVALID SQL\"\r\n    params = []\r\n    cursor.execute(sql, params)\r\n    self.assertEqual(connection.ops.last_executed_query(cursor, sql, params), sql)\r\n```",
      "comment_id": 2567491066,
      "user": "felixxm",
      "created_at": "2025-11-27T07:52:28Z",
      "url": "https://github.com/django/django/pull/20312#discussion_r2567491066"
    },
    {
      "repo": "django/django",
      "pr_number": 20312,
      "file_path": "tests/backends/oracle/test_last_executed_query.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,21 @@\n+from django.db import connection\n+from django.test import TestCase\n+from django.test.utils import skipUnless\n+\n+\n+@skipUnless(connection.vendor == \"oracle\", \"Oracle-specific tests\")\n+class TestLastExecutedQueryFallback(TestCase):\n+    def test_last_executed_query_fallback(self):\n+        # Use a real Oracle cursor and force an error\n+        with connection.cursor() as cursor:\n+            sql = \"INVALID SQL\"\n+            params = []\n+            try:\n+                cursor.execute(sql, params)\n+            except Exception:\n+                pass\n+\n+            # The result MUST NOT be None and MUST fall back to the SQL string\n+            result = connection.ops.last_executed_query(cursor, sql, params)\n+            self.assertIsNotNone(result)\n+            self.assertEqual(result, sql)",
      "comment": "`assertIsNotNone` is redundant\r\n```suggestion\r\n            self.assertEqual(result, sql)\r\n```",
      "comment_id": 2580489793,
      "user": "felixxm",
      "created_at": "2025-12-02T10:06:22Z",
      "url": "https://github.com/django/django/pull/20312#discussion_r2580489793"
    },
    {
      "repo": "django/django",
      "pr_number": 20312,
      "file_path": "tests/backends/oracle/test_last_executed_query.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,21 @@\n+from django.db import connection\n+from django.test import TestCase\n+from django.test.utils import skipUnless\n+\n+\n+@skipUnless(connection.vendor == \"oracle\", \"Oracle-specific tests\")\n+class TestLastExecutedQueryFallback(TestCase):\n+    def test_last_executed_query_fallback(self):",
      "comment": "As far as I'm aware, this test should pass for all database backends, so we can move it to the \r\n`tests.backends.base.test_operations.DatabaseOperationTests` class.",
      "comment_id": 2580496057,
      "user": "felixxm",
      "created_at": "2025-12-02T10:08:10Z",
      "url": "https://github.com/django/django/pull/20312#discussion_r2580496057"
    },
    {
      "repo": "django/django",
      "pr_number": 20312,
      "file_path": "django/db/backends/oracle/operations.py",
      "line": 355,
      "side": "RIGHT",
      "diff_hunk": "@@ -352,7 +352,7 @@ def last_executed_query(self, cursor, sql, params):\n                 statement = statement.replace(\n                     key, force_str(params[key], errors=\"replace\")\n                 )\n-        return statement\n+        return statement or super().last_executed_query(cursor, sql, params)",
      "comment": "I think we should use `super().last_executed_query()` only when `statement` is None\r\n```suggestion\r\n        return super().last_executed_query(cursor, sql, params) if statement is None else statement \r\n```",
      "comment_id": 2580501766,
      "user": "felixxm",
      "created_at": "2025-12-02T10:09:38Z",
      "url": "https://github.com/django/django/pull/20312#discussion_r2580501766"
    },
    {
      "repo": "django/django",
      "pr_number": 20312,
      "file_path": "tests/backends/base/test_operations.py",
      "line": 180,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,20 @@ class DatabaseOperationTests(TestCase):\n     def setUp(self):\n         self.ops = BaseDatabaseOperations(connection=connection)\n \n+    def test_last_executed_query_fallback(self):\n+        with connection.cursor() as cursor:\n+            sql = \"INVALID SQL\"\n+            params = []\n+\n+            try:\n+                cursor.execute(sql, params)",
      "comment": "This test pass even without a fix, you need to `close()` the cursor to have a proper regression test.\r\n```suggestion\r\n                cursor.close()\r\n                cursor.execute(sql, params)\r\n```",
      "comment_id": 2648658295,
      "user": "felixxm",
      "created_at": "2025-12-26T20:51:17Z",
      "url": "https://github.com/django/django/pull/20312#discussion_r2648658295"
    },
    {
      "repo": "django/django",
      "pr_number": 20437,
      "file_path": "tests/lookup/tests.py",
      "line": 1864,
      "side": "RIGHT",
      "diff_hunk": "@@ -1855,6 +1855,14 @@ def test_in_lookup_in_filter(self):\n                     Season.objects.filter(In(F(\"year\"), years)).order_by(\"pk\"), seasons\n                 )\n \n+    def test_in_lookup_in_filter_text_field(self):\n+        self.assertSequenceEqual(\n+            Season.objects.filter(\n+                In(F(\"nulled_text_field\"), [F(\"nulled_text_field\"), \"special_value\"])\n+            ),\n+            [self.s2],\n+        )",
      "comment": "This test crashes on Oracle because blob fields (e.g. `NCLOB`) are not allowed in the `IN()` clause. As far as I'm aware `TextFields` are unnecessary here, see #20453.",
      "comment_id": 2644244696,
      "user": "felixxm",
      "created_at": "2025-12-23T20:55:32Z",
      "url": "https://github.com/django/django/pull/20437#discussion_r2644244696"
    },
    {
      "repo": "django/django",
      "pr_number": 19793,
      "file_path": "django/db/models/sql/query.py",
      "line": 1442,
      "side": "RIGHT",
      "diff_hunk": "@@ -1430,11 +1431,15 @@ def build_lookup(self, lookups, lhs, rhs):\n                 return\n \n         lookup = lookup_class(lhs, rhs)\n-        # Interpret '__exact=None' as the sql 'is NULL'; otherwise, reject all\n-        # uses of None as a query value unless the lookup supports it.\n+        # Interpret '__exact=None' as the SQL 'IS NULL'. For '__iexact=None' on\n+        # KeyTransform, interpret it as '__exact=None' instead of 'IS NULL'\n+        # (#36508). For all other cases, reject the use of None as a query\n+        # value unless the lookup explicitly supports it.\n         if lookup.rhs is None and not lookup.can_use_none_as_rhs:\n             if lookup_name not in (\"exact\", \"iexact\"):\n                 raise ValueError(\"Cannot use None as a query value\")\n+            if lookup_name == \"iexact\" and isinstance(lhs, KeyTransform):\n+                return lhs.get_lookup(\"exact\")(lhs, None)",
      "comment": "Having had another think, it would be preferable if we don't add json specific logic here\r\nCan we not update `django.db.models.fields.json.KeyTransformIExact` somehow?",
      "comment_id": 2379114138,
      "user": "sarahboyce",
      "created_at": "2025-09-25T13:32:35Z",
      "url": "https://github.com/django/django/pull/19793#discussion_r2379114138"
    },
    {
      "repo": "django/django",
      "pr_number": 19793,
      "file_path": "django/db/models/sql/query.py",
      "line": 1442,
      "side": "RIGHT",
      "diff_hunk": "@@ -1430,11 +1431,15 @@ def build_lookup(self, lookups, lhs, rhs):\n                 return\n \n         lookup = lookup_class(lhs, rhs)\n-        # Interpret '__exact=None' as the sql 'is NULL'; otherwise, reject all\n-        # uses of None as a query value unless the lookup supports it.\n+        # Interpret '__exact=None' as the SQL 'IS NULL'. For '__iexact=None' on\n+        # KeyTransform, interpret it as '__exact=None' instead of 'IS NULL'\n+        # (#36508). For all other cases, reject the use of None as a query\n+        # value unless the lookup explicitly supports it.\n         if lookup.rhs is None and not lookup.can_use_none_as_rhs:\n             if lookup_name not in (\"exact\", \"iexact\"):\n                 raise ValueError(\"Cannot use None as a query value\")\n+            if lookup_name == \"iexact\" and isinstance(lhs, KeyTransform):\n+                return lhs.get_lookup(\"exact\")(lhs, None)",
      "comment": "I share your sentiment @sarahboyce, this should be implemented at the `KeyTransformIExact` level and not hardcoded here. The reason why `exact` and `iexact` are here today is due to how they must span `OUTER JOIN` when targeting a reverse relationship, I hope to remove it entirely with #16817.",
      "comment_id": 2379578552,
      "user": "charettes",
      "created_at": "2025-09-25T15:37:16Z",
      "url": "https://github.com/django/django/pull/19793#discussion_r2379578552"
    },
    {
      "repo": "django/django",
      "pr_number": 19793,
      "file_path": "django/db/models/fields/json.py",
      "line": 668,
      "side": "RIGHT",
      "diff_hunk": "@@ -665,7 +665,19 @@ def as_oracle(self, compiler, connection):\n class KeyTransformIExact(\n     CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact\n ):\n-    pass\n+    can_use_none_as_rhs = True",
      "comment": "I'm interested if you can tell me a little bit about this part. I see `KeyTransformExact` doesn't have it (at least not until Django 7.)\n\nI also see this logic that doesn't treat `exact` and `iexact` equivalently:\n\nhttps://github.com/django/django/blob/e49e14fd9032feb7a8cf254658ac4e74a4ffb712/django/db/models/sql/query.py#L1442-L1451",
      "comment_id": 2636417393,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T22:00:12Z",
      "url": "https://github.com/django/django/pull/19793#discussion_r2636417393"
    },
    {
      "repo": "django/django",
      "pr_number": 19793,
      "file_path": "django/db/models/fields/json.py",
      "line": 668,
      "side": "RIGHT",
      "diff_hunk": "@@ -665,7 +665,19 @@ def as_oracle(self, compiler, connection):\n class KeyTransformIExact(\n     CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact\n ):\n-    pass\n+    can_use_none_as_rhs = True",
      "comment": "> I see KeyTransformExact doesn't have it (at least not until Django 7.)\r\n\r\n`KeyTransformExact` does have the flag set to `True`; it is defined in `JSONExact` which `KeyTransformExact` subclasses. The change in Django 7 will remove the flag from `JSONExact` but keep it in `KeyTransformExact`, i.e. move it from the superclass to the subclass.\r\n\r\n> I also see this logic that doesn't treat `exact` and `iexact` equivalently:\r\n\r\nGood catch, seems like a bug? Test failure for iexact:\r\n```diff\r\ndiff --git a/tests/queries/tests.py b/tests/queries/tests.py\r\nindex 51d1915c97..24e9c51593 100644\r\n--- a/tests/queries/tests.py\r\n+++ b/tests/queries/tests.py\r\n@@ -2280,6 +2280,17 @@ class ComparisonTests(TestCase):\r\n            [item_ab],\r\n        )\r\n\r\n+    @skipUnlessDBFeature(\"interprets_empty_strings_as_nulls\")\r\n+    def test_empty_string_is_null(self):\r\n+        obj = NullableName.objects.create(name=None)\r\n+        obj1 = NullableName.objects.create(name=\"\")\r\n+        cases = [{\"name__exact\": \"\"}, {\"name__iexact\": \"\"}]\r\n+        for lookup in cases:\r\n+            with self.subTest(lookup):\r\n+                self.assertSequenceEqual(\r\n+                    NullableName.objects.filter(**lookup), [obj, obj1]\r\n+                )\r\n+\r\n\r\nclass ExistsSql(TestCase):\r\n    def test_exists(self):\r\n```\r\nThe queries are:\r\n```sql\r\nSELECT \"queries_nullablename\".\"id\",\r\n       \"queries_nullablename\".\"name\"\r\nFROM   \"queries_nullablename\"\r\nWHERE  \"queries_nullablename\".\"name\" IS NULL\r\nORDER  BY \"queries_nullablename\".\"id\" ASC;\r\n\r\nSELECT \"queries_nullablename\".\"id\",\r\n       \"queries_nullablename\".\"name\"\r\nFROM   \"queries_nullablename\"\r\nWHERE  Upper(\"queries_nullablename\".\"name\") = Upper()\r\nORDER  BY \"queries_nullablename\".\"id\" ASC;  \r\n```",
      "comment_id": 2637064874,
      "user": "cliffordgama",
      "created_at": "2025-12-20T11:42:39Z",
      "url": "https://github.com/django/django/pull/19793#discussion_r2637064874"
    },
    {
      "repo": "django/django",
      "pr_number": 19793,
      "file_path": "django/db/models/fields/json.py",
      "line": 668,
      "side": "RIGHT",
      "diff_hunk": "@@ -665,7 +665,19 @@ def as_oracle(self, compiler, connection):\n class KeyTransformIExact(\n     CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact\n ):\n-    pass\n+    can_use_none_as_rhs = True",
      "comment": "Re: empty strings as null: https://code.djangoproject.com/ticket/29222#comment:7 seems relevant.",
      "comment_id": 2637685073,
      "user": "cliffordgama",
      "created_at": "2025-12-21T08:47:03Z",
      "url": "https://github.com/django/django/pull/19793#discussion_r2637685073"
    },
    {
      "repo": "django/django",
      "pr_number": 19793,
      "file_path": "django/db/models/fields/json.py",
      "line": 668,
      "side": "RIGHT",
      "diff_hunk": "@@ -665,7 +665,19 @@ def as_oracle(self, compiler, connection):\n class KeyTransformIExact(\n     CaseInsensitiveMixin, KeyTransformTextLookupMixin, lookups.IExact\n ):\n-    pass\n+    can_use_none_as_rhs = True",
      "comment": "Super helpful. Could I interest you in filing a Trac ticket with your findings?",
      "comment_id": 2640666900,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-22T17:34:19Z",
      "url": "https://github.com/django/django/pull/19793#discussion_r2640666900"
    },
    {
      "repo": "django/django",
      "pr_number": 20443,
      "file_path": "tests/backends/tests.py",
      "line": 1023,
      "side": "RIGHT",
      "diff_hunk": "@@ -1017,3 +1018,19 @@ def test_many_to_many(self):\n         intermediary_model.objects.create(from_object_id=obj.id, to_object_id=12345)\n         self.assertEqual(obj.related_objects.count(), 1)\n         self.assertEqual(intermediary_model.objects.count(), 2)\n+\n+\n+class SQLiteMaxQueryParamsTests(TestCase):",
      "comment": "Refer to 358fd21c47cdf7bda520ce73c5cfd82bba57827b and where the original test was added in `tests/backends/sqlite/test_features.py`.\r\n\r\nThe way this is currently defined the test is running on all backend when it should be SQLite specific.\r\n\r\nhttps://github.com/django/django/commit/358fd21c47cdf7bda520ce73c5cfd82bba57827b#diff-bcc4842c09fdfbe9666b5d295f56846226e72148b015e0c19d4fc4ebd570b202R14-R22",
      "comment_id": 2640428474,
      "user": "charettes",
      "created_at": "2025-12-22T16:16:00Z",
      "url": "https://github.com/django/django/pull/20443#discussion_r2640428474"
    },
    {
      "repo": "django/django",
      "pr_number": 20443,
      "file_path": "tests/backends/sqlite/test_features.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,3 +30,13 @@ def test_max_query_params_respects_variable_limit(self):\n         finally:\n             connection.connection.setlimit(limit_name, current_limit)\n         self.assertEqual(connection.features.max_query_params, current_limit)\n+\n+    def test_max_query_params_without_established_connection(self):\n+        new_connection = connection.copy()\n+        new_connection.settings_dict = copy.deepcopy(connection.settings_dict)\n+        self.assertIsNone(new_connection.connection)\n+        try:\n+            result = new_connection.features.max_query_params\n+            self.assertIsInstance(result, int)\n+        finally:\n+            new_connection.close()",
      "comment": "I'm getting the following, when using an in-memory database:\n\n```py\nResourceWarning: unclosed database in <sqlite3.Connection object at 0x10c710f40>\n```\nIt goes away with:\n```suggestion\n            new_connection._close()\n```",
      "comment_id": 2641021306,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-22T19:36:54Z",
      "url": "https://github.com/django/django/pull/20443#discussion_r2641021306"
    },
    {
      "repo": "django/django",
      "pr_number": 20443,
      "file_path": "tests/backends/sqlite/test_features.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,3 +30,13 @@ def test_max_query_params_respects_variable_limit(self):\n         finally:\n             connection.connection.setlimit(limit_name, current_limit)\n         self.assertEqual(connection.features.max_query_params, current_limit)\n+\n+    def test_max_query_params_without_established_connection(self):\n+        new_connection = connection.copy()\n+        new_connection.settings_dict = copy.deepcopy(connection.settings_dict)\n+        self.assertIsNone(new_connection.connection)\n+        try:\n+            result = new_connection.features.max_query_params\n+            self.assertIsInstance(result, int)\n+        finally:\n+            new_connection.close()",
      "comment": "Thanks for the suggestion. I've updated the code to use `_close()` to ensure the underlying connection is properly closed in all environments.",
      "comment_id": 2641632711,
      "user": "guro-Ishiguro",
      "created_at": "2025-12-23T01:03:10Z",
      "url": "https://github.com/django/django/pull/20443#discussion_r2641632711"
    },
    {
      "repo": "django/django",
      "pr_number": 20055,
      "file_path": "django/core/management/commands/inspectdb.py",
      "line": 370,
      "side": "RIGHT",
      "diff_hunk": "@@ -359,21 +359,11 @@ def get_field_type(self, connection, table_name, row):\n         if field_type in {\"CharField\", \"TextField\"} and row.collation:\n             field_params[\"db_collation\"] = row.collation\n \n-        if field_type == \"DecimalField\":\n-            if row.precision is None or row.scale is None:\n-                field_notes.append(\n-                    \"max_digits and decimal_places have been guessed, as this \"\n-                    \"database handles decimal fields as float\"\n-                )\n-                field_params[\"max_digits\"] = (\n-                    row.precision if row.precision is not None else 10\n-                )\n-                field_params[\"decimal_places\"] = (\n-                    row.scale if row.scale is not None else 5\n-                )\n-            else:\n-                field_params[\"max_digits\"] = row.precision\n-                field_params[\"decimal_places\"] = row.scale\n+        if field_type == \"DecimalField\" and (\n+            row.precision is not None or row.scale is not None\n+        ):\n+            field_params[\"max_digits\"] = row.precision\n+            field_params[\"decimal_places\"] = row.scale",
      "comment": "I see below that we have a check to ensure that we don't have one of `max_digits` and `decimal_places` set to `None` when the other is not `None`. I think it's worth at least a comment here that we're OK with generating such an invalid field, since there's nothing more correct we can do. Alternatively we could raise a warning or an error here, but maybe that's excessive for something that might never happen.",
      "comment_id": 2530196486,
      "user": "LilyFirefly",
      "created_at": "2025-11-15T21:48:14Z",
      "url": "https://github.com/django/django/pull/20055#discussion_r2530196486"
    },
    {
      "repo": "django/django",
      "pr_number": 20055,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1804,
      "side": "RIGHT",
      "diff_hunk": "@@ -1725,54 +1725,84 @@ def check(self, **kwargs):\n         return errors\n \n     def _check_decimal_places(self):\n-        try:\n-            decimal_places = int(self.decimal_places)\n-            if decimal_places < 0:\n-                raise ValueError()\n-        except TypeError:\n-            return [\n-                checks.Error(\n-                    \"DecimalFields must define a 'decimal_places' attribute.\",\n-                    obj=self,\n-                    id=\"fields.E130\",\n-                )\n-            ]\n-        except ValueError:\n-            return [\n-                checks.Error(\n-                    \"'decimal_places' must be a non-negative integer.\",\n-                    obj=self,\n-                    id=\"fields.E131\",\n-                )\n-            ]\n+        if self.decimal_places is None:\n+            if not (\n+                connection.features.supports_no_precision_decimalfield\n+                or \"supports_no_precision_decimalfield\"\n+                in self.model._meta.required_db_features\n+            ):\n+                return [\n+                    checks.Error(\n+                        \"DecimalFields must define a 'decimal_places' attribute.\",\n+                        obj=self,\n+                        id=\"fields.E130\",\n+                    )\n+                ]\n+            elif self.max_digits is not None:\n+                return [\n+                    checks.Error(\n+                        \"DecimalField\u2019s max_digits and decimal_places must both \"\n+                        \"be defined or both omitted.\",\n+                        obj=self,\n+                        id=\"fields.E135\",\n+                    ),\n+                ]\n         else:\n-            return []\n+            try:\n+                decimal_places = int(self.decimal_places)\n+                if decimal_places < 0:\n+                    raise ValueError()\n+            except ValueError:\n+                return [\n+                    checks.Error(\n+                        \"'decimal_places' must be a non-negative integer.\",\n+                        obj=self,\n+                        id=\"fields.E131\",\n+                    )\n+                ]\n+        return []\n \n     def _check_max_digits(self):\n-        try:\n-            max_digits = int(self.max_digits)\n-            if max_digits <= 0:\n-                raise ValueError()\n-        except TypeError:\n-            return [\n-                checks.Error(\n-                    \"DecimalFields must define a 'max_digits' attribute.\",\n-                    obj=self,\n-                    id=\"fields.E132\",\n-                )\n-            ]\n-        except ValueError:\n-            return [\n-                checks.Error(\n-                    \"'max_digits' must be a positive integer.\",\n-                    obj=self,\n-                    id=\"fields.E133\",\n-                )\n-            ]\n+        if self.max_digits is None:\n+            if not (\n+                connection.features.supports_no_precision_decimalfield\n+                or \"supports_no_precision_decimalfield\"\n+                in self.model._meta.required_db_features\n+            ):\n+                return [\n+                    checks.Error(\n+                        \"DecimalFields must define a 'max_digits' attribute.\",\n+                        obj=self,\n+                        id=\"fields.E132\",\n+                    )\n+                ]\n+            elif self.decimal_places is not None:\n+                return [\n+                    checks.Error(\n+                        \"DecimalField\u2019s max_digits and decimal_places must both \"\n+                        \"be defined or both omitted.\",\n+                        obj=self,\n+                        id=\"fields.E135\",\n+                    ),\n+                ]\n         else:\n-            return []\n+            try:\n+                max_digits = int(self.max_digits)\n+                if max_digits <= 0:\n+                    raise ValueError()\n+            except ValueError:\n+                return [\n+                    checks.Error(\n+                        \"'max_digits' must be a positive integer.\",\n+                        obj=self,\n+                        id=\"fields.E133\",\n+                    )\n+                ]\n+        return []\n \n     def _check_decimal_places_and_max_digits(self, **kwargs):\n+        if self.decimal_places is None and self.max_digits is None:",
      "comment": "If only one of these was `None`, this check would raise a `TypeError`. Maybe this code isn't reachable in that case, but this version is safe even if it becomes reachable:\r\n\r\n```suggestion\r\n        if self.decimal_places is None or self.max_digits is None:\r\n```",
      "comment_id": 2530212189,
      "user": "LilyFirefly",
      "created_at": "2025-11-15T21:53:13Z",
      "url": "https://github.com/django/django/pull/20055#discussion_r2530212189"
    },
    {
      "repo": "django/django",
      "pr_number": 20055,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1733,
      "side": "RIGHT",
      "diff_hunk": "@@ -1725,54 +1725,84 @@ def check(self, **kwargs):\n         return errors\n \n     def _check_decimal_places(self):\n-        try:\n-            decimal_places = int(self.decimal_places)\n-            if decimal_places < 0:\n-                raise ValueError()\n-        except TypeError:\n-            return [\n-                checks.Error(\n-                    \"DecimalFields must define a 'decimal_places' attribute.\",\n-                    obj=self,\n-                    id=\"fields.E130\",\n-                )\n-            ]\n-        except ValueError:\n-            return [\n-                checks.Error(\n-                    \"'decimal_places' must be a non-negative integer.\",\n-                    obj=self,\n-                    id=\"fields.E131\",\n-                )\n-            ]\n+        if self.decimal_places is None:\n+            if not (\n+                connection.features.supports_no_precision_decimalfield\n+                or \"supports_no_precision_decimalfield\"\n+                in self.model._meta.required_db_features\n+            ):",
      "comment": "I think it's a bit clearer to distribute the `not` here:\r\n\r\n```suggestion\r\n            if (\r\n                not connection.features.supports_no_precision_decimalfield\r\n                and \"supports_no_precision_decimalfield\"\r\n                not in self.model._meta.required_db_features\r\n            ):\r\n```",
      "comment_id": 2533683815,
      "user": "LilyFirefly",
      "created_at": "2025-11-17T11:19:50Z",
      "url": "https://github.com/django/django/pull/20055#discussion_r2533683815"
    },
    {
      "repo": "django/django",
      "pr_number": 20055,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1771,
      "side": "RIGHT",
      "diff_hunk": "@@ -1725,54 +1725,84 @@ def check(self, **kwargs):\n         return errors\n \n     def _check_decimal_places(self):\n-        try:\n-            decimal_places = int(self.decimal_places)\n-            if decimal_places < 0:\n-                raise ValueError()\n-        except TypeError:\n-            return [\n-                checks.Error(\n-                    \"DecimalFields must define a 'decimal_places' attribute.\",\n-                    obj=self,\n-                    id=\"fields.E130\",\n-                )\n-            ]\n-        except ValueError:\n-            return [\n-                checks.Error(\n-                    \"'decimal_places' must be a non-negative integer.\",\n-                    obj=self,\n-                    id=\"fields.E131\",\n-                )\n-            ]\n+        if self.decimal_places is None:\n+            if not (\n+                connection.features.supports_no_precision_decimalfield\n+                or \"supports_no_precision_decimalfield\"\n+                in self.model._meta.required_db_features\n+            ):\n+                return [\n+                    checks.Error(\n+                        \"DecimalFields must define a 'decimal_places' attribute.\",\n+                        obj=self,\n+                        id=\"fields.E130\",\n+                    )\n+                ]\n+            elif self.max_digits is not None:\n+                return [\n+                    checks.Error(\n+                        \"DecimalField\u2019s max_digits and decimal_places must both \"\n+                        \"be defined or both omitted.\",\n+                        obj=self,\n+                        id=\"fields.E135\",\n+                    ),\n+                ]\n         else:\n-            return []\n+            try:\n+                decimal_places = int(self.decimal_places)\n+                if decimal_places < 0:\n+                    raise ValueError()\n+            except ValueError:\n+                return [\n+                    checks.Error(\n+                        \"'decimal_places' must be a non-negative integer.\",\n+                        obj=self,\n+                        id=\"fields.E131\",\n+                    )\n+                ]\n+        return []\n \n     def _check_max_digits(self):\n-        try:\n-            max_digits = int(self.max_digits)\n-            if max_digits <= 0:\n-                raise ValueError()\n-        except TypeError:\n-            return [\n-                checks.Error(\n-                    \"DecimalFields must define a 'max_digits' attribute.\",\n-                    obj=self,\n-                    id=\"fields.E132\",\n-                )\n-            ]\n-        except ValueError:\n-            return [\n-                checks.Error(\n-                    \"'max_digits' must be a positive integer.\",\n-                    obj=self,\n-                    id=\"fields.E133\",\n-                )\n-            ]\n+        if self.max_digits is None:\n+            if not (\n+                connection.features.supports_no_precision_decimalfield\n+                or \"supports_no_precision_decimalfield\"\n+                in self.model._meta.required_db_features\n+            ):",
      "comment": "And here:\r\n\r\n```suggestion\r\n            if (\r\n                not connection.features.supports_no_precision_decimalfield\r\n                and \"supports_no_precision_decimalfield\"\r\n                not in self.model._meta.required_db_features\r\n            ):\r\n```",
      "comment_id": 2533688406,
      "user": "LilyFirefly",
      "created_at": "2025-11-17T11:21:23Z",
      "url": "https://github.com/django/django/pull/20055#discussion_r2533688406"
    },
    {
      "repo": "django/django",
      "pr_number": 20055,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1740,
      "side": "RIGHT",
      "diff_hunk": "@@ -1725,54 +1725,84 @@ def check(self, **kwargs):\n         return errors\n \n     def _check_decimal_places(self):\n-        try:\n-            decimal_places = int(self.decimal_places)\n-            if decimal_places < 0:\n-                raise ValueError()\n-        except TypeError:\n-            return [\n-                checks.Error(\n-                    \"DecimalFields must define a 'decimal_places' attribute.\",\n-                    obj=self,\n-                    id=\"fields.E130\",\n-                )\n-            ]\n-        except ValueError:\n-            return [\n-                checks.Error(\n-                    \"'decimal_places' must be a non-negative integer.\",\n-                    obj=self,\n-                    id=\"fields.E131\",\n-                )\n-            ]\n+        if self.decimal_places is None:\n+            if (\n+                not connection.features.supports_no_precision_decimalfield\n+                and \"supports_no_precision_decimalfield\"\n+                not in self.model._meta.required_db_features\n+            ):\n+                return [\n+                    checks.Error(\n+                        \"DecimalFields must define a 'decimal_places' attribute.\",\n+                        obj=self,\n+                        id=\"fields.E130\",\n+                    )\n+                ]",
      "comment": "I believe this should be a database dependent check similar to `_check_db_collation()`, not only examining the default database.",
      "comment_id": 2640150213,
      "user": "timgraham",
      "created_at": "2025-12-22T15:01:31Z",
      "url": "https://github.com/django/django/pull/20055#discussion_r2640150213"
    },
    {
      "repo": "django/django",
      "pr_number": 20055,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 1740,
      "side": "RIGHT",
      "diff_hunk": "@@ -1725,54 +1725,84 @@ def check(self, **kwargs):\n         return errors\n \n     def _check_decimal_places(self):\n-        try:\n-            decimal_places = int(self.decimal_places)\n-            if decimal_places < 0:\n-                raise ValueError()\n-        except TypeError:\n-            return [\n-                checks.Error(\n-                    \"DecimalFields must define a 'decimal_places' attribute.\",\n-                    obj=self,\n-                    id=\"fields.E130\",\n-                )\n-            ]\n-        except ValueError:\n-            return [\n-                checks.Error(\n-                    \"'decimal_places' must be a non-negative integer.\",\n-                    obj=self,\n-                    id=\"fields.E131\",\n-                )\n-            ]\n+        if self.decimal_places is None:\n+            if (\n+                not connection.features.supports_no_precision_decimalfield\n+                and \"supports_no_precision_decimalfield\"\n+                not in self.model._meta.required_db_features\n+            ):\n+                return [\n+                    checks.Error(\n+                        \"DecimalFields must define a 'decimal_places' attribute.\",\n+                        obj=self,\n+                        id=\"fields.E130\",\n+                    )\n+                ]",
      "comment": "Agreed, checking `connection` directly prevents mixing different database backends.",
      "comment_id": 2640161406,
      "user": "charettes",
      "created_at": "2025-12-22T15:04:22Z",
      "url": "https://github.com/django/django/pull/20055#discussion_r2640161406"
    },
    {
      "repo": "django/django",
      "pr_number": 20420,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 323,
      "side": "LEFT",
      "diff_hunk": "@@ -316,43 +330,41 @@ def _handle_fk_field_node(self, node, field):\n         \"\"\"\n         Handle a <field> node for a ForeignKey\n         \"\"\"\n+        model = field.remote_field.model\n+        if hasattr(model._default_manager, \"get_by_natural_key\"):\n+            keys = node.getElementsByTagName(\"natural\")\n+            if keys:\n+                # If there are 'natural' subelements, it must be a natural\n+                # key\n+                field_value = [\n+                    None if k.getElementsByTagName(\"None\") else getInnerText(k).strip()\n+                    for k in keys\n+                ]\n+                try:\n+                    obj = model._default_manager.db_manager(self.db).get_by_natural_key(\n+                        *field_value\n+                    )\n+                except ObjectDoesNotExist:\n+                    if self.handle_forward_references:\n+                        return base.DEFER_FIELD\n+                    else:\n+                        raise\n+                obj_pk = getattr(obj, field.remote_field.field_name)\n+                # If this is a natural foreign key to an object that\n+                # has a FK/O2O as the foreign key, use the FK value\n+                if field.remote_field.model._meta.pk.remote_field:\n+                    obj_pk = obj_pk.pk\n+                return obj_pk\n+\n         # Check if there is a child node named 'None', returning None if so.\n         if node.getElementsByTagName(\"None\"):\n             return None\n-        else:\n-            model = field.remote_field.model",
      "comment": "For the sake of having a much smaller diff, I would suggest leaving most of this where it was and just fix the condition. (e.g. lift up `keys = ...` and then check `... and not keys: return None`, perhaps improving the variable name `keys`).\n\nYour version has a terser if condition, but this code is touched so infrequently that I think we should prioritize a smaller diff and more understandable blames over more readable if conditions.",
      "comment_id": 2636251555,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T20:41:23Z",
      "url": "https://github.com/django/django/pull/20420#discussion_r2636251555"
    },
    {
      "repo": "django/django",
      "pr_number": 20420,
      "file_path": "tests/serializers/models/natural.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,3 +91,28 @@ class PostToOptOutSubclassUser(models.Model):\n     subscribers = models.ManyToManyField(\n         SubclassNaturalKeyOptOutUser, related_name=\"subscribed_posts\", blank=True\n     )\n+\n+\n+class NaturalKeyWithNullableFieldManager(models.Manager):\n+    def get_by_natural_key(self, name, optional_id):\n+        return self.get(name=name, optional_id=optional_id)\n+\n+\n+class NaturalKeyWithNullableField(models.Model):\n+    name = models.CharField(max_length=100)\n+    optional_id = models.UUIDField(null=True, blank=True)",
      "comment": "So my example of `UUIDField` on the ticket was just what I happened to be working with (and show a really nice validation problem when attempting the roundtrip). However, it's not very realistic as a member of a natural key (and doesn't work well with the yaml serializer). Could I ask you to try another field type?",
      "comment_id": 2636265959,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T20:47:16Z",
      "url": "https://github.com/django/django/pull/20420#discussion_r2636265959"
    },
    {
      "repo": "django/django",
      "pr_number": 20420,
      "file_path": "tests/serializers/test_natural.py",
      "line": 324,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,6 +282,48 @@ def natural_key_opt_out_test(self, format):\n     )\n \n \n+def nullable_natural_key_fk_test(self, format):\n+    # Create objects with None in natural key\n+    target_with_none = NaturalKeyWithNullableField.objects.create(\n+        name=\"test_none\",\n+        optional_id=None,\n+    )\n+    target_with_uuid = NaturalKeyWithNullableField.objects.create(\n+        name=\"test_uuid\",\n+        optional_id=\"12345678-1234-5678-1234-567812345678\",\n+    )\n+    fk_to_none = FKToNaturalKeyWithNullable.objects.create(\n+        ref=target_with_none,\n+        data=\"points_to_none\",\n+    )\n+    fk_to_uuid = FKToNaturalKeyWithNullable.objects.create(\n+        ref=target_with_uuid,\n+        data=\"points_to_uuid\",\n+    )\n+    # Serialize\n+    objects = [target_with_none, target_with_uuid, fk_to_none, fk_to_uuid]\n+    serialized = serializers.serialize(\n+        format,\n+        objects,\n+        use_natural_foreign_keys=True,\n+        use_natural_primary_keys=True,\n+    )\n+    # Delete and deserialize\n+    FKToNaturalKeyWithNullable.objects.all().delete()\n+    NaturalKeyWithNullableField.objects.all().delete()\n+    for obj in serializers.deserialize(format, serialized):\n+        obj.save()\n+    # Verify\n+    restored_fk_none = FKToNaturalKeyWithNullable.objects.get(data=\"points_to_none\")\n+    restored_fk_uuid = FKToNaturalKeyWithNullable.objects.get(data=\"points_to_uuid\")\n+    self.assertIsNone(restored_fk_none.ref.optional_id)\n+    self.assertEqual(restored_fk_none.ref.name, \"test_none\")\n+    self.assertEqual(\n+        str(restored_fk_uuid.ref.optional_id),\n+        \"12345678-1234-5678-1234-567812345678\",\n+    )",
      "comment": "Do we need the saving part, or can we just assert against the unsaved object and still capture the underlying issue?",
      "comment_id": 2636273458,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T20:50:17Z",
      "url": "https://github.com/django/django/pull/20420#discussion_r2636273458"
    },
    {
      "repo": "django/django",
      "pr_number": 20420,
      "file_path": "tests/serializers/test_natural.py",
      "line": 286,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,6 +282,48 @@ def natural_key_opt_out_test(self, format):\n     )\n \n \n+def nullable_natural_key_fk_test(self, format):\n+    # Create objects with None in natural key",
      "comment": "You can remove these comments to blend in with the surrounding style.",
      "comment_id": 2636274402,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T20:50:42Z",
      "url": "https://github.com/django/django/pull/20420#discussion_r2636274402"
    },
    {
      "repo": "django/django",
      "pr_number": 20420,
      "file_path": "tests/serializers/models/natural.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,3 +91,28 @@ class PostToOptOutSubclassUser(models.Model):\n     subscribers = models.ManyToManyField(\n         SubclassNaturalKeyOptOutUser, related_name=\"subscribed_posts\", blank=True\n     )\n+\n+\n+class NaturalKeyWithNullableFieldManager(models.Manager):\n+    def get_by_natural_key(self, name, optional_id):\n+        return self.get(name=name, optional_id=optional_id)\n+\n+\n+class NaturalKeyWithNullableField(models.Model):\n+    name = models.CharField(max_length=100)\n+    optional_id = models.UUIDField(null=True, blank=True)\n+\n+    objects = NaturalKeyWithNullableFieldManager()\n+\n+    class Meta:\n+        unique_together = [[\"name\", \"optional_id\"]]\n+\n+    def natural_key(self):\n+        return (self.name, self.optional_id)\n+\n+\n+class FKToNaturalKeyWithNullable(models.Model):",
      "comment": "Great models -- trying your tests against main shows all kinds of nasty failures \ud83d\udc4d ",
      "comment_id": 2636293382,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T20:59:48Z",
      "url": "https://github.com/django/django/pull/20420#discussion_r2636293382"
    },
    {
      "repo": "django/django",
      "pr_number": 20420,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 323,
      "side": "LEFT",
      "diff_hunk": "@@ -316,43 +330,41 @@ def _handle_fk_field_node(self, node, field):\n         \"\"\"\n         Handle a <field> node for a ForeignKey\n         \"\"\"\n+        model = field.remote_field.model\n+        if hasattr(model._default_manager, \"get_by_natural_key\"):\n+            keys = node.getElementsByTagName(\"natural\")\n+            if keys:\n+                # If there are 'natural' subelements, it must be a natural\n+                # key\n+                field_value = [\n+                    None if k.getElementsByTagName(\"None\") else getInnerText(k).strip()\n+                    for k in keys\n+                ]\n+                try:\n+                    obj = model._default_manager.db_manager(self.db).get_by_natural_key(\n+                        *field_value\n+                    )\n+                except ObjectDoesNotExist:\n+                    if self.handle_forward_references:\n+                        return base.DEFER_FIELD\n+                    else:\n+                        raise\n+                obj_pk = getattr(obj, field.remote_field.field_name)\n+                # If this is a natural foreign key to an object that\n+                # has a FK/O2O as the foreign key, use the FK value\n+                if field.remote_field.model._meta.pk.remote_field:\n+                    obj_pk = obj_pk.pk\n+                return obj_pk\n+\n         # Check if there is a child node named 'None', returning None if so.\n         if node.getElementsByTagName(\"None\"):\n             return None\n-        else:\n-            model = field.remote_field.model",
      "comment": "I tried to simplify the logic, but ended up making a bigger diff than needed. Your suggestion is the better approach.\r\nI've updated it.",
      "comment_id": 2636857798,
      "user": "2ykwang",
      "created_at": "2025-12-20T06:31:34Z",
      "url": "https://github.com/django/django/pull/20420#discussion_r2636857798"
    },
    {
      "repo": "django/django",
      "pr_number": 20420,
      "file_path": "tests/serializers/models/natural.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,3 +91,28 @@ class PostToOptOutSubclassUser(models.Model):\n     subscribers = models.ManyToManyField(\n         SubclassNaturalKeyOptOutUser, related_name=\"subscribed_posts\", blank=True\n     )\n+\n+\n+class NaturalKeyWithNullableFieldManager(models.Manager):\n+    def get_by_natural_key(self, name, optional_id):\n+        return self.get(name=name, optional_id=optional_id)\n+\n+\n+class NaturalKeyWithNullableField(models.Model):\n+    name = models.CharField(max_length=100)\n+    optional_id = models.UUIDField(null=True, blank=True)",
      "comment": "Agreed. Changed to `CharField` it's more generalizable across all serializers and aligns with other natural key fields in the test suite.\r\ne.g. (`NaturalKeyAnchor.data`, `NaturalKeyThing.key`).",
      "comment_id": 2636857867,
      "user": "2ykwang",
      "created_at": "2025-12-20T06:31:45Z",
      "url": "https://github.com/django/django/pull/20420#discussion_r2636857867"
    },
    {
      "repo": "django/django",
      "pr_number": 20420,
      "file_path": "tests/serializers/test_natural.py",
      "line": 324,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,6 +282,48 @@ def natural_key_opt_out_test(self, format):\n     )\n \n \n+def nullable_natural_key_fk_test(self, format):\n+    # Create objects with None in natural key\n+    target_with_none = NaturalKeyWithNullableField.objects.create(\n+        name=\"test_none\",\n+        optional_id=None,\n+    )\n+    target_with_uuid = NaturalKeyWithNullableField.objects.create(\n+        name=\"test_uuid\",\n+        optional_id=\"12345678-1234-5678-1234-567812345678\",\n+    )\n+    fk_to_none = FKToNaturalKeyWithNullable.objects.create(\n+        ref=target_with_none,\n+        data=\"points_to_none\",\n+    )\n+    fk_to_uuid = FKToNaturalKeyWithNullable.objects.create(\n+        ref=target_with_uuid,\n+        data=\"points_to_uuid\",\n+    )\n+    # Serialize\n+    objects = [target_with_none, target_with_uuid, fk_to_none, fk_to_uuid]\n+    serialized = serializers.serialize(\n+        format,\n+        objects,\n+        use_natural_foreign_keys=True,\n+        use_natural_primary_keys=True,\n+    )\n+    # Delete and deserialize\n+    FKToNaturalKeyWithNullable.objects.all().delete()\n+    NaturalKeyWithNullableField.objects.all().delete()\n+    for obj in serializers.deserialize(format, serialized):\n+        obj.save()\n+    # Verify\n+    restored_fk_none = FKToNaturalKeyWithNullable.objects.get(data=\"points_to_none\")\n+    restored_fk_uuid = FKToNaturalKeyWithNullable.objects.get(data=\"points_to_uuid\")\n+    self.assertIsNone(restored_fk_none.ref.optional_id)\n+    self.assertEqual(restored_fk_none.ref.name, \"test_none\")\n+    self.assertEqual(\n+        str(restored_fk_uuid.ref.optional_id),\n+        \"12345678-1234-5678-1234-567812345678\",\n+    )",
      "comment": "From a serialization perspective, the responsibility is data transformation `save()` is a separate concern. I'll simplify the test. Thanks!",
      "comment_id": 2636857926,
      "user": "2ykwang",
      "created_at": "2025-12-20T06:31:51Z",
      "url": "https://github.com/django/django/pull/20420#discussion_r2636857926"
    },
    {
      "repo": "django/django",
      "pr_number": 20422,
      "file_path": "tests/user_commands/tests.py",
      "line": 475,
      "side": "RIGHT",
      "diff_hunk": "@@ -470,6 +470,38 @@ def test_suggest_on_error_explicit_false(self):\n         )\n         self.assertFalse(parser.suggest_on_error)\n \n+    @unittest.skipUnless(PY314, \"Only relevant for Python 3.14+\")\n+    def test_color_enabled_by_default(self):\n+        \"\"\"Argparse color should be enabled by default.\"\"\"",
      "comment": "When the docstrings communicate the same information as the method names we chop them.",
      "comment_id": 2636058702,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T19:25:31Z",
      "url": "https://github.com/django/django/pull/20422#discussion_r2636058702"
    },
    {
      "repo": "django/django",
      "pr_number": 20422,
      "file_path": "django/core/management/base.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,8 +58,16 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n-        if PY314 and not PY315:\n-            kwargs.setdefault(\"suggest_on_error\", True)\n+        if PY314:\n+            if not PY315:\n+                kwargs.setdefault(\"suggest_on_error\", True)\n+            if (\n+                os.environ.get(\"NO_COLOR\")\n+                or os.environ.get(\"DJANGO_COLORS\") == \"nocolor\"\n+            ):\n+                kwargs.setdefault(\"color\", False)\n+            else:\n+                kwargs.setdefault(\"color\", True)",
      "comment": "```suggestion\n```\nI don't think we need to bother; color is already True by default since https://github.com/python/cpython/pull/136809 (3.14)",
      "comment_id": 2636073803,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T19:31:45Z",
      "url": "https://github.com/django/django/pull/20422#discussion_r2636073803"
    },
    {
      "repo": "django/django",
      "pr_number": 20422,
      "file_path": "django/core/management/base.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,8 +58,16 @@ def __init__(\n     ):\n         self.missing_args_message = missing_args_message\n         self.called_from_command_line = called_from_command_line\n-        if PY314 and not PY315:\n-            kwargs.setdefault(\"suggest_on_error\", True)\n+        if PY314:\n+            if not PY315:\n+                kwargs.setdefault(\"suggest_on_error\", True)\n+            if (\n+                os.environ.get(\"NO_COLOR\")",
      "comment": "This environment variable hasn't been set yet; we also need to check for an incoming ``--no-color`` argument instead. Please add a test.",
      "comment_id": 2636085507,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T19:35:45Z",
      "url": "https://github.com/django/django/pull/20422#discussion_r2636085507"
    },
    {
      "repo": "django/django",
      "pr_number": 20422,
      "file_path": "tests/user_commands/tests.py",
      "line": 498,
      "side": "RIGHT",
      "diff_hunk": "@@ -470,6 +470,34 @@ def test_suggest_on_error_explicit_false(self):\n         )\n         self.assertFalse(parser.suggest_on_error)\n \n+    @unittest.skipUnless(PY314, \"Only relevant for Python 3.14+\")\n+    def test_color_enabled_by_default(self):\n+        with mock.patch.dict(os.environ, {}, clear=True):\n+            command = BaseCommand()\n+            parser = command.create_parser(\"prog_name\", \"subcommand\")\n+            self.assertTrue(parser.color)\n+\n+    @unittest.skipUnless(PY314, \"Only relevant for Python 3.14+\")\n+    def test_color_disabled_with_django_colors_nocolor(self):\n+        with mock.patch.dict(os.environ, {\"DJANGO_COLORS\": \"nocolor\"}):\n+            command = BaseCommand()\n+            parser = command.create_parser(\"prog_name\", \"subcommand\")\n+            self.assertFalse(parser.color)\n+\n+    @unittest.skipUnless(PY314, \"Only relevant for Python 3.14+\")\n+    def test_force_color_does_not_affect_argparse_color(self):\n+        with mock.patch.dict(os.environ, {}, clear=True):\n+            command = BaseCommand(force_color=True)\n+            parser = command.create_parser(\"prog_name\", \"subcommand\")\n+            self.assertTrue(parser.color)\n+\n+    @unittest.skipUnless(PY314, \"Only relevant for Python 3.14+\")\n+    def test_no_color_flag_disables_color(self):\n+        with mock.patch.object(sys, \"argv\", [\"manage.py\", \"mycommand\", \"--no-color\"]):\n+            command = BaseCommand()\n+            parser = command.create_parser(\"prog\", \"sub\")",
      "comment": "Very minor: I'd use \"manage.py\" and \"mycommand\" to match the mock.",
      "comment_id": 2640394776,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-22T16:02:55Z",
      "url": "https://github.com/django/django/pull/20422#discussion_r2640394776"
    },
    {
      "repo": "django/django",
      "pr_number": 20422,
      "file_path": "tests/user_commands/tests.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -470,6 +470,34 @@ def test_suggest_on_error_explicit_false(self):\n         )\n         self.assertFalse(parser.suggest_on_error)\n \n+    @unittest.skipUnless(PY314, \"Only relevant for Python 3.14+\")\n+    def test_color_enabled_by_default(self):\n+        with mock.patch.dict(os.environ, {}, clear=True):\n+            command = BaseCommand()\n+            parser = command.create_parser(\"prog_name\", \"subcommand\")\n+            self.assertTrue(parser.color)\n+\n+    @unittest.skipUnless(PY314, \"Only relevant for Python 3.14+\")\n+    def test_color_disabled_with_django_colors_nocolor(self):\n+        with mock.patch.dict(os.environ, {\"DJANGO_COLORS\": \"nocolor\"}):\n+            command = BaseCommand()\n+            parser = command.create_parser(\"prog_name\", \"subcommand\")\n+            self.assertFalse(parser.color)\n+\n+    @unittest.skipUnless(PY314, \"Only relevant for Python 3.14+\")\n+    def test_force_color_does_not_affect_argparse_color(self):\n+        with mock.patch.dict(os.environ, {}, clear=True):\n+            command = BaseCommand(force_color=True)\n+            parser = command.create_parser(\"prog_name\", \"subcommand\")\n+            self.assertTrue(parser.color)\n+\n+    @unittest.skipUnless(PY314, \"Only relevant for Python 3.14+\")\n+    def test_no_color_flag_disables_color(self):\n+        with mock.patch.object(sys, \"argv\", [\"manage.py\", \"mycommand\", \"--no-color\"]):\n+            command = BaseCommand()\n+            parser = command.create_parser(\"prog\", \"sub\")\n+            self.assertIs(parser.color, False)",
      "comment": "I'd make all 4 assertions use either assertIs or not.",
      "comment_id": 2640395530,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-22T16:03:12Z",
      "url": "https://github.com/django/django/pull/20422#discussion_r2640395530"
    },
    {
      "repo": "django/django",
      "pr_number": 19938,
      "file_path": "tests/file_storage/models.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +38,14 @@ def __call__(self):\n         return self\n \n \n+class LazyTempStorage(LazyObject):\n+    def _setup(self):\n+        self._wrapped = temp_storage\n+\n+\n+lazy_temp_storage = LazyTempStorage()",
      "comment": "Do we need this module level definition? Could we instead just instantiate in the usage below?\n```python\nlazy_storage = models.FileField(storage=LazyTempStorage(), upload_to=\"tests\")\n```",
      "comment_id": 2432832589,
      "user": "nessita",
      "created_at": "2025-10-15T14:38:27Z",
      "url": "https://github.com/django/django/pull/19938#discussion_r2432832589"
    },
    {
      "repo": "django/django",
      "pr_number": 19938,
      "file_path": "tests/file_storage/tests.py",
      "line": 1273,
      "side": "RIGHT",
      "diff_hunk": "@@ -1267,3 +1268,11 @@ def test_nonexistent_backend(self):\n         )\n         with self.assertRaisesMessage(InvalidStorageError, msg):\n             test_storages[\"invalid_backend\"]\n+\n+\n+class LazyObjectHandlingTests(SimpleTestCase):",
      "comment": "Small nitpick:\n```suggestion\nclass StorageLazyObjectTests(SimpleTestCase):\n```",
      "comment_id": 2432842254,
      "user": "nessita",
      "created_at": "2025-10-15T14:41:04Z",
      "url": "https://github.com/django/django/pull/19938#discussion_r2432842254"
    },
    {
      "repo": "django/django",
      "pr_number": 19480,
      "file_path": "tests/postgres_tests/test_dependency_checks.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,177 @@\n+from django.core import checks",
      "comment": "Not sure `test_dependency_check` is the most adequate name here. Maybe `test_installed_app_checks`?",
      "comment_id": 2094674654,
      "user": "charettes",
      "created_at": "2025-05-19T00:32:42Z",
      "url": "https://github.com/django/django/pull/19480#discussion_r2094674654"
    },
    {
      "repo": "django/django",
      "pr_number": 19480,
      "file_path": "django/contrib/postgres/search.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,7 +31,7 @@ def as_sql(self, qn, connection):\n         return \"%s @@ %s\" % (lhs, rhs), params\n \n \n-class SearchVectorField(Field):\n+class SearchVectorField(CheckPostgresInstalledMixin, Field):",
      "comment": "Was wondering if we should add to the check `SearchQueryField`. I know it's not documented but is used within `SearchQuery` which is documented?",
      "comment_id": 2140419548,
      "user": "sarahboyce",
      "created_at": "2025-06-11T14:55:43Z",
      "url": "https://github.com/django/django/pull/19480#discussion_r2140419548"
    },
    {
      "repo": "django/django",
      "pr_number": 19480,
      "file_path": "django/contrib/postgres/search.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,7 +31,7 @@ def as_sql(self, qn, connection):\n         return \"%s @@ %s\" % (lhs, rhs), params\n \n \n-class SearchVectorField(Field):\n+class SearchVectorField(CheckPostgresInstalledMixin, Field):",
      "comment": "Thanks for the review! Makes sense \ud83d\udc4d\ud83c\udffe. I'll add the check accordingly",
      "comment_id": 2142572357,
      "user": "cliffordgama",
      "created_at": "2025-06-12T12:10:24Z",
      "url": "https://github.com/django/django/pull/19480#discussion_r2142572357"
    },
    {
      "repo": "django/django",
      "pr_number": 20426,
      "file_path": "tests/forms_tests/tests/test_forms.py",
      "line": 5353,
      "side": "RIGHT",
      "diff_hunk": "@@ -5343,10 +5350,7 @@ def my_function(method, post_data):\n                 return \"VALID: %r\" % sorted(form.cleaned_data.items())\n \n             t = Template(\n-                '<form method=\"post\">'\n-                \"{{ form }}\"\n-                '<input type=\"submit\" required>'\n-                \"</form>\"\n+                '<form method=\"post\">{{ form }}<input type=\"submit\" required></form>'",
      "comment": "Please revert -- we don't mix in unrelated refactors.",
      "comment_id": 2636040965,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-19T19:18:21Z",
      "url": "https://github.com/django/django/pull/20426#discussion_r2636040965"
    },
    {
      "repo": "django/django",
      "pr_number": 20395,
      "file_path": "tests/migrations/test_autodetector.py",
      "line": 5595,
      "side": "RIGHT",
      "diff_hunk": "@@ -5543,6 +5543,78 @@ def test_remove_composite_pk(self):\n             preserve_default=True,\n         )\n \n+    def test_m2m_target_change_generates_remove_and_add(self):\n+        # Initial state: Author has M2M to Book\n+        before = [\n+            ModelState(\n+                \"testapp\",\n+                \"Book\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Magazine\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"readings\", models.ManyToManyField(\"testapp.Book\")),\n+                ],\n+            ),\n+        ]\n+\n+        # After state: Author has M2M to Magazine (same field name 'readings')\n+        after = [\n+            ModelState(\n+                \"testapp\",\n+                \"Book\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Magazine\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"readings\", models.ManyToManyField(\"testapp.Magazine\")),\n+                ],\n+            ),\n+        ]\n+\n+        changes = self.get_changes(before, after)\n+\n+        # We expect 1 migration for testapp\n+        self.assertIn(\"testapp\", changes)\n+        self.assertEqual(len(changes[\"testapp\"]), 1)",
      "comment": "use `assertNumberMigrations()` (see surrounding tests)",
      "comment_id": 2616891657,
      "user": "cliffordgama",
      "created_at": "2025-12-14T10:05:11Z",
      "url": "https://github.com/django/django/pull/20395#discussion_r2616891657"
    },
    {
      "repo": "django/django",
      "pr_number": 20395,
      "file_path": "tests/migrations/test_autodetector.py",
      "line": 5581,
      "side": "RIGHT",
      "diff_hunk": "@@ -5543,6 +5543,75 @@ def test_remove_composite_pk(self):\n             preserve_default=True,\n         )\n \n+    def test_m2m_target_change_generates_remove_and_add(self):\n+        # Initial state: Author has M2M to Book\n+        before = [\n+            ModelState(\n+                \"testapp\",\n+                \"Book\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Magazine\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"readings\", models.ManyToManyField(\"testapp.Book\")),\n+                ],\n+            ),\n+        ]\n+\n+        # After state: Author has M2M to Magazine (same field name 'readings')\n+        after = [\n+            ModelState(\n+                \"testapp\",\n+                \"Book\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Magazine\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"readings\", models.ManyToManyField(\"testapp.Magazine\")),\n+                ],\n+            ),\n+        ]\n+\n+        changes = self.get_changes(before, after)\n+\n+        self.assertNumberMigrations(changes, \"testapp\", 1)\n+\n+        self.assertOperationTypes(changes, \"testapp\", 0, [\"RemoveField\", \"AddField\"])\n+\n+        self.assertOperationAttributes(\n+            changes,\n+            \"testapp\",\n+            0,\n+            0,\n+            name=\"readings\",\n+            model_name=\"author\",\n+        )\n+\n+        self.assertOperationAttributes(",
      "comment": "Nit: I'd remove the blank lines; the file is already too long as it is \n```suggestion\n        changes = self.get_changes(before, after)\n        self.assertNumberMigrations(changes, \"testapp\", 1)\n        self.assertOperationTypes(changes, \"testapp\", 0, [\"RemoveField\", \"AddField\"])\n        self.assertOperationAttributes(\n            changes,\n            \"testapp\",\n            0,\n            0,\n            name=\"readings\",\n            model_name=\"author\",\n        )\n        self.assertOperationAttributes(\n```",
      "comment_id": 2617252239,
      "user": "cliffordgama",
      "created_at": "2025-12-14T15:31:41Z",
      "url": "https://github.com/django/django/pull/20395#discussion_r2617252239"
    },
    {
      "repo": "django/django",
      "pr_number": 20395,
      "file_path": "tests/migrations/test_autodetector.py",
      "line": 5567,
      "side": "RIGHT",
      "diff_hunk": "@@ -5543,6 +5543,69 @@ def test_remove_composite_pk(self):\n             preserve_default=True,\n         )\n \n+    def test_m2m_target_change_generates_remove_and_add(self):\n+        # Initial state: Author has M2M to Book\n+        before = [\n+            ModelState(\n+                \"testapp\",\n+                \"Book\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Magazine\",\n+                [(\"id\", models.AutoField(primary_key=True))],\n+            ),\n+            ModelState(\n+                \"testapp\",\n+                \"Author\",\n+                [\n+                    (\"id\", models.AutoField(primary_key=True)),\n+                    (\"readings\", models.ManyToManyField(\"testapp.Book\")),\n+                ],\n+            ),\n+        ]",
      "comment": "I've just discovered these model states or similar are predefined, e.g. `self.author_with_m2m`. Can you switch to those here and, where appropriate, in `after` as well.",
      "comment_id": 2619428551,
      "user": "cliffordgama",
      "created_at": "2025-12-15T13:24:47Z",
      "url": "https://github.com/django/django/pull/20395#discussion_r2619428551"
    },
    {
      "repo": "django/django",
      "pr_number": 20395,
      "file_path": "tests/migrations/test_autodetector.py",
      "line": 5562,
      "side": "RIGHT",
      "diff_hunk": "@@ -5543,6 +5554,39 @@ def test_remove_composite_pk(self):\n             preserve_default=True,\n         )\n \n+    def test_m2m_target_change_generates_remove_and_add(self):\n+        # Initial state: Author has M2M to Publisher\n+        before = [\n+            self.publisher,\n+            self.magazine,\n+            self.author_with_m2m,",
      "comment": "```suggestion\n        before = [\n            self.publisher,\n            self.other_publisher,\n            self.author_with_m2m,  # m2m to self.publisher.\n```",
      "comment_id": 2630938677,
      "user": "cliffordgama",
      "created_at": "2025-12-18T12:49:00Z",
      "url": "https://github.com/django/django/pull/20395#discussion_r2630938677"
    },
    {
      "repo": "django/django",
      "pr_number": 20395,
      "file_path": "tests/migrations/test_autodetector.py",
      "line": 754,
      "side": "RIGHT",
      "diff_hunk": "@@ -741,6 +741,17 @@ class AutodetectorTests(BaseAutodetectorTests):\n             (\"publishers\", models.ManyToManyField(\"testapp.Publisher\", blank=True)),\n         ],\n     )\n+    magazine = ModelState(\n+        \"testapp\", \"Magazine\", [(\"id\", models.AutoField(primary_key=True))]\n+    )\n+    author_with_m2m_magazine = ModelState(\n+        \"testapp\",\n+        \"Author\",\n+        [\n+            (\"id\", models.AutoField(primary_key=True)),\n+            (\"publishers\", models.ManyToManyField(\"testapp.Magazine\")),\n+        ],\n+    )",
      "comment": "\nI think we only need a variable for something we need to use more than once.\n```suggestion\n    other_publisher = ModelState(\n        \"testapp\",\n        \"OtherPublisher\",\n        [\n            (\"id\", models.AutoField(primary_key=True)),\n        ],\n    )\n```",
      "comment_id": 2630966200,
      "user": "cliffordgama",
      "created_at": "2025-12-18T12:55:15Z",
      "url": "https://github.com/django/django/pull/20395#discussion_r2630966200"
    },
    {
      "repo": "django/django",
      "pr_number": 20395,
      "file_path": "tests/migrations/test_autodetector.py",
      "line": 5569,
      "side": "RIGHT",
      "diff_hunk": "@@ -5543,6 +5554,39 @@ def test_remove_composite_pk(self):\n             preserve_default=True,\n         )\n \n+    def test_m2m_target_change_generates_remove_and_add(self):\n+        # Initial state: Author has M2M to Publisher\n+        before = [\n+            self.publisher,\n+            self.magazine,\n+            self.author_with_m2m,\n+        ]\n+        # After state: Author has M2M to Magazine\n+        after = [\n+            self.publisher,\n+            self.magazine,\n+            self.author_with_m2m_magazine,\n+        ]",
      "comment": "```suggestion\n        after = [\n            self.publisher,\n            self.other_publisher,\n            ModelState(\n                \"testapp\",\n                \"Author\",\n                [\n                    (\"id\", models.AutoField(primary_key=True)),\n                    # Repoint m2m to self.other_publisher.\n                    (\"publishers\", models.ManyToManyField(\"testapp.OtherPublisher\")),\n                ],\n            ),\n        ]\n```",
      "comment_id": 2630975903,
      "user": "cliffordgama",
      "created_at": "2025-12-18T12:57:20Z",
      "url": "https://github.com/django/django/pull/20395#discussion_r2630975903"
    },
    {
      "repo": "django/django",
      "pr_number": 20395,
      "file_path": "tests/migrations/test_autodetector.py",
      "line": 5559,
      "side": "RIGHT",
      "diff_hunk": "@@ -5543,6 +5550,46 @@ def test_remove_composite_pk(self):\n             preserve_default=True,\n         )\n \n+    def test_m2m_target_change_generates_remove_and_add(self):\n+        before = [\n+            self.publisher,\n+            self.other_publisher,\n+            self.author_with_m2m,  # m2m to self.publisher.\n+        ]\n+        # After state: Author has M2M to Magazine",
      "comment": "And also if I could bother you to move the test, as suggested [here](https://github.com/django/django/pull/20395#pullrequestreview-3592776256).\r\n\r\nOtherwise this should be good to go.",
      "comment_id": 2632590554,
      "user": "cliffordgama",
      "created_at": "2025-12-18T20:52:41Z",
      "url": "https://github.com/django/django/pull/20395#discussion_r2632590554"
    },
    {
      "repo": "django/django",
      "pr_number": 20423,
      "file_path": "django/db/models/constraints.py",
      "line": 278,
      "side": "LEFT",
      "diff_hunk": "@@ -274,8 +274,6 @@ def __init__(\n         violation_error_code=None,\n         violation_error_message=None,\n     ):\n-        if not name:\n-            raise ValueError(\"A unique constraint must be named.\")",
      "comment": "This change also means that passing any falsey values to `name` may not raise an error. Notably, it now accepts a blank string (`\"\"`).",
      "comment_id": 2631199687,
      "user": "jonbiemond",
      "created_at": "2025-12-18T13:55:47Z",
      "url": "https://github.com/django/django/pull/20423#discussion_r2631199687"
    },
    {
      "repo": "django/django",
      "pr_number": 20423,
      "file_path": "django/db/models/constraints.py",
      "line": 278,
      "side": "LEFT",
      "diff_hunk": "@@ -274,8 +274,6 @@ def __init__(\n         violation_error_code=None,\n         violation_error_message=None,\n     ):\n-        if not name:\n-            raise ValueError(\"A unique constraint must be named.\")",
      "comment": "SQLite doesn't mind an empty string, but PostgreSQL does.",
      "comment_id": 2631364049,
      "user": "jonbiemond",
      "created_at": "2025-12-18T14:41:35Z",
      "url": "https://github.com/django/django/pull/20423#discussion_r2631364049"
    },
    {
      "repo": "django/django",
      "pr_number": 20423,
      "file_path": "django/db/models/constraints.py",
      "line": 278,
      "side": "LEFT",
      "diff_hunk": "@@ -274,8 +274,6 @@ def __init__(\n         violation_error_code=None,\n         violation_error_message=None,\n     ):\n-        if not name:\n-            raise ValueError(\"A unique constraint must be named.\")",
      "comment": "Why not leave this as `if not name` to continue raising helpful errors if `None` is explicitly passed?",
      "comment_id": 2631597896,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-18T15:42:19Z",
      "url": "https://github.com/django/django/pull/20423#discussion_r2631597896"
    },
    {
      "repo": "django/django",
      "pr_number": 20423,
      "file_path": "django/db/models/constraints.py",
      "line": 278,
      "side": "LEFT",
      "diff_hunk": "@@ -274,8 +274,6 @@ def __init__(\n         violation_error_code=None,\n         violation_error_message=None,\n     ):\n-        if not name:\n-            raise ValueError(\"A unique constraint must be named.\")",
      "comment": "Thanks for the speedy review! I think that's a good idea! (I just checked what we were doing in other classes.) I'll change it back. How do you feel about the new error message?\r\n> A unique constraint name must not be blank.",
      "comment_id": 2631888378,
      "user": "jonbiemond",
      "created_at": "2025-12-18T17:10:01Z",
      "url": "https://github.com/django/django/pull/20423#discussion_r2631888378"
    },
    {
      "repo": "django/django",
      "pr_number": 20423,
      "file_path": "django/db/models/constraints.py",
      "line": 278,
      "side": "LEFT",
      "diff_hunk": "@@ -274,8 +274,6 @@ def __init__(\n         violation_error_code=None,\n         violation_error_message=None,\n     ):\n-        if not name:\n-            raise ValueError(\"A unique constraint must be named.\")",
      "comment": "That said, we do tend to avoid changes unless it's clearly better. This one's borderline for me, since blank is still \"not named\" \ud83e\udd14 ",
      "comment_id": 2631925837,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-18T17:21:49Z",
      "url": "https://github.com/django/django/pull/20423#discussion_r2631925837"
    },
    {
      "repo": "django/django",
      "pr_number": 19609,
      "file_path": "tests/test_utils/tests.py",
      "line": 2093,
      "side": "RIGHT",
      "diff_hunk": "@@ -2145,6 +2090,35 @@ def hook():\n         self.assertIsInstance(raised_exception, MyException)\n         self.assertEqual(str(raised_exception), \"robust callback\")\n \n+    def test_execute_robust_with_callback_as_partial(self):",
      "comment": "Thanks. Just leaving a note that I had a small look at reducing duplication with the above test via `subTest`, and it wasn't a great fit given the need to pop from `run_on_commit` managed via the `captureOnCommitCallbacks` context manager. So nothing to change as far as I'm concerned.",
      "comment_id": 2624847233,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T21:44:55Z",
      "url": "https://github.com/django/django/pull/19609#discussion_r2624847233"
    },
    {
      "repo": "django/django",
      "pr_number": 19609,
      "file_path": "tests/test_utils/tests.py",
      "line": 2116,
      "side": "RIGHT",
      "diff_hunk": "@@ -2145,6 +2090,35 @@ def hook():\n         self.assertIsInstance(raised_exception, MyException)\n         self.assertEqual(str(raised_exception), \"robust callback\")\n \n+    def test_execute_robust_with_callback_as_partial(self):\n+        class MyException(Exception):\n+            pass\n+\n+        def hook():\n+            self.callback_called = True\n+            raise MyException(\"robust callback\")\n+\n+        hook_partial = partial(hook)\n+\n+        with self.assertLogs(\"django.test\", \"ERROR\") as cm:\n+            with self.captureOnCommitCallbacks(execute=True) as callbacks:\n+                transaction.on_commit(hook_partial, robust=True)\n+\n+        self.assertEqual(len(callbacks), 1)\n+        self.assertIs(self.callback_called, True)\n+\n+        log_record = cm.records[0]\n+        self.assertRegex(\n+            log_record.getMessage(),\n+            r\"Error calling functools\\.partial\\(<function CaptureOnCommitCallbacksTests\"\n+            r\"\\.test_execute_robust_with_callback_as_partial\\.<locals>\\.hook\"\n+            r\" at .+>\\) in on_commit\\(\\) \\(robust callback\\)\\.\",\n+        )",
      "comment": "Django tends to assert very precisely on exception messages (for [another view](https://github.com/python/cpython/pull/98100#discussion_r1759570358), see Brett Cannon) -- but here I  think with so much escaping readability suffers. I would suggest:\n\n```suggestion\n        self.assertEqual(\n            log_record.getMessage(),\n            f\"Error calling {hook_partial} in on_commit() (robust callback).\",\n        )\n```\nand similar for the other test.",
      "comment_id": 2624857552,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T21:48:16Z",
      "url": "https://github.com/django/django/pull/19609#discussion_r2624857552"
    },
    {
      "repo": "django/django",
      "pr_number": 19609,
      "file_path": "django/db/backends/base/base.py",
      "line": 745,
      "side": "RIGHT",
      "diff_hunk": "@@ -741,11 +741,8 @@ def on_commit(self, func, robust=False):\n                 try:\n                     func()\n                 except Exception as e:\n-                    logger.error(\n-                        f\"Error calling {func.__qualname__} in on_commit() (%s).\",\n-                        e,\n-                        exc_info=True,\n-                    )\n+                    name = getattr(func, \"__qualname__\", func)\n+                    logger.exception(\"Error calling %s in on_commit() (%s).\", name, e)",
      "comment": "Updated the tests, `test_robust_if_no_transaction_with_callback_as_partial` should cover this",
      "comment_id": 2635026410,
      "user": "krishna-holvi",
      "created_at": "2025-12-19T12:58:53Z",
      "url": "https://github.com/django/django/pull/19609#discussion_r2635026410"
    },
    {
      "repo": "django/django",
      "pr_number": 20411,
      "file_path": "django/db/backends/base/schema.py",
      "line": 1676,
      "side": "RIGHT",
      "diff_hunk": "@@ -1669,8 +1669,11 @@ def _field_indexes_sql(self, model, field):\n         return output\n \n     def _field_should_be_altered(self, old_field, new_field, ignore=None):\n-        if (not (old_field.concrete or old_field.many_to_many)) and (\n-            not (new_field.concrete or new_field.many_to_many)\n+        if (\n+            not old_field.concrete\n+            and not new_field.concrete\n+            and not old_field.many_to_many\n+            and not new_field.many_to_many",
      "comment": "Reverted \ud83d\udc4d\ud83c\udffe. I'd changed it so it's easier to read.",
      "comment_id": 2621047456,
      "user": "cliffordgama",
      "created_at": "2025-12-15T22:18:44Z",
      "url": "https://github.com/django/django/pull/20411#discussion_r2621047456"
    },
    {
      "repo": "django/django",
      "pr_number": 20411,
      "file_path": "django/db/backends/base/schema.py",
      "line": 1716,
      "side": "RIGHT",
      "diff_hunk": "@@ -1708,19 +1695,28 @@ def _field_should_be_altered(self, old_field, new_field, ignore=None):\n         ):\n             old_kwargs.pop(\"to\", None)\n             new_kwargs.pop(\"to\", None)\n-        # db_default can take many form but result in the same SQL.\n+        # db_default can take many forms but result in the same SQL.\n         if (\n             old_kwargs.get(\"db_default\")\n             and new_kwargs.get(\"db_default\")\n             and self.db_default_sql(old_field) == self.db_default_sql(new_field)\n         ):\n             old_kwargs.pop(\"db_default\")\n             new_kwargs.pop(\"db_default\")\n-        return (\n-            old_field.concrete\n-            and new_field.concrete\n-            and (self.quote_name(old_field.column) != self.quote_name(new_field.column))\n-        ) or (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)\n+\n+        old_schema_name = (\n+            self.quote_name(old_field.column)\n+            if not old_field.many_to_many\n+            else old_field.attname\n+        )\n+        new_schema_name = (\n+            self.quote_name(new_field.column)\n+            if not new_field.many_to_many\n+            else new_field.attname\n+        )",
      "comment": "@cliffordgama After having a look at #20412, do you have an opinion about how to factor this? I think the multiple returns helps readability.",
      "comment_id": 2621146065,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-15T23:10:08Z",
      "url": "https://github.com/django/django/pull/20411#discussion_r2621146065"
    },
    {
      "repo": "django/django",
      "pr_number": 20287,
      "file_path": "django/contrib/admindocs/utils.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,4 +265,4 @@ def remove_non_capturing_groups(pattern):\n \n \n def strip_p_tags(value):\n-    return mark_safe(value.replace(\"<p>\", \"\").replace(\"</p>\", \"\"))\n+    return SafeString(value.replace(\"<p>\", \"\").replace(\"</p>\", \"\"))",
      "comment": "On second thought, can you revert this also? It's the only one that's not a a literal string (in other words, where we can't guarantee the type is exactly `str`. There could be a lazy object with a custom `replace` method that relies on this somehow.",
      "comment_id": 2627620439,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-17T15:55:48Z",
      "url": "https://github.com/django/django/pull/20287#discussion_r2627620439"
    },
    {
      "repo": "django/django",
      "pr_number": 20287,
      "file_path": "django/contrib/admindocs/utils.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,4 +265,4 @@ def remove_non_capturing_groups(pattern):\n \n \n def strip_p_tags(value):\n-    return mark_safe(value.replace(\"<p>\", \"\").replace(\"</p>\", \"\"))\n+    return SafeString(value.replace(\"<p>\", \"\").replace(\"</p>\", \"\"))",
      "comment": "thanks for catching this.  Yes there might case where title(value) could be None or ",
      "comment_id": 2627702376,
      "user": "p-r-a-v-i-n",
      "created_at": "2025-12-17T16:18:21Z",
      "url": "https://github.com/django/django/pull/20287#discussion_r2627702376"
    },
    {
      "repo": "django/django",
      "pr_number": 20287,
      "file_path": "django/contrib/admindocs/utils.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -265,4 +265,4 @@ def remove_non_capturing_groups(pattern):\n \n \n def strip_p_tags(value):\n-    return mark_safe(value.replace(\"<p>\", \"\").replace(\"</p>\", \"\"))\n+    return SafeString(value.replace(\"<p>\", \"\").replace(\"</p>\", \"\"))",
      "comment": "something could have been done but i'm not confident\r\n```\r\ndef strip_p_tags(value):\r\n    if value is None:\r\n        return \"\"\r\n    return SafeString(str(value).replace(\"<p>\", \"\").replace(\"</p>\", \"\"))\r\n```",
      "comment_id": 2627725051,
      "user": "p-r-a-v-i-n",
      "created_at": "2025-12-17T16:23:07Z",
      "url": "https://github.com/django/django/pull/20287#discussion_r2627725051"
    },
    {
      "repo": "django/django",
      "pr_number": 20067,
      "file_path": "django/db/models/fields/related_descriptors.py",
      "line": 1290,
      "side": "RIGHT",
      "diff_hunk": "@@ -1280,8 +1281,15 @@ def add(self, *objs, through_defaults=None):\n                         self.source_field_name,\n                         *objs,\n                         through_defaults=through_defaults,\n+                        using=db,\n+                        raw=raw,\n                     )\n \n+        def add(self, *objs, through_defaults=None):\n+            self._remove_prefetched_objects()\n+            db = router.db_for_write(self.through, instance=self.instance)",
      "comment": "I take it you prefer the explicitness of doing this here versus relying on the `or ...` in `_add_base()`?",
      "comment_id": 2624700249,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-16T20:53:09Z",
      "url": "https://github.com/django/django/pull/20067#discussion_r2624700249"
    },
    {
      "repo": "django/django",
      "pr_number": 20067,
      "file_path": "django/db/models/fields/related_descriptors.py",
      "line": 1290,
      "side": "RIGHT",
      "diff_hunk": "@@ -1280,8 +1281,15 @@ def add(self, *objs, through_defaults=None):\n                         self.source_field_name,\n                         *objs,\n                         through_defaults=through_defaults,\n+                        using=db,\n+                        raw=raw,\n                     )\n \n+        def add(self, *objs, through_defaults=None):\n+            self._remove_prefetched_objects()\n+            db = router.db_for_write(self.through, instance=self.instance)",
      "comment": "I wanted to keep all hook consistent also with other related descriptors.",
      "comment_id": 2627751636,
      "user": "felixxm",
      "created_at": "2025-12-17T16:30:21Z",
      "url": "https://github.com/django/django/pull/20067#discussion_r2627751636"
    },
    {
      "repo": "django/django",
      "pr_number": 19870,
      "file_path": "django/db/models/constraints.py",
      "line": 410,
      "side": "RIGHT",
      "diff_hunk": "@@ -406,7 +406,8 @@ def check(self, model, connection):\n             errors.append(\n                 checks.Warning(\n                     f\"{connection.display_name} does not support unique constraints \"\n-                    \"with nulls distinct.\",\n+                    \"with nulls distinct. They are ignored for databases besides \"\n+                    \"PostgreSQL 15+.\",",
      "comment": "I would maybe have:\r\n```python\r\n                    f\"{connection.display_name} does not support the \"\r\n                    \"'nulls_distinct' parameter for unique constraints.\",\r\n```\r\nAs I think we want to emphasizing that having values for `nulls_distinct` set is not supported (rather than this being interpreted that nulls_distinct=False might be valid \r\n\r\nNote that any changes to the warning needs to be updated in the system check docs:\r\n```diff\r\n--- a/docs/ref/checks.txt\r\n+++ b/docs/ref/checks.txt\r\n@@ -438,8 +438,8 @@ Models\r\n   expression and won't be validated during the model ``full_clean()``.\r\n * **models.W046**: ``<database>`` does not support comments on tables\r\n   (``db_table_comment``).\r\n-* **models.W047**: ``<database>`` does not support unique constraints with\r\n-  nulls distinct.\r\n+* **models.W047**: ``<database>`` does not support the 'nulls_distinct'\r\n+  parameter for unique constraints.\r\n * **models.E048**: ``constraints/indexes/unique_together`` refers to a\r\n   ``CompositePrimaryKey`` ``<field name>``, but ``CompositePrimaryKey``\\s are\r\n   not supported for that option.\r\n```\r\n",
      "comment_id": 2362529323,
      "user": "sarahboyce",
      "created_at": "2025-09-19T10:56:05Z",
      "url": "https://github.com/django/django/pull/19870#discussion_r2362529323"
    },
    {
      "repo": "django/django",
      "pr_number": 19870,
      "file_path": "django/db/models/constraints.py",
      "line": 410,
      "side": "RIGHT",
      "diff_hunk": "@@ -406,7 +406,8 @@ def check(self, model, connection):\n             errors.append(\n                 checks.Warning(\n                     f\"{connection.display_name} does not support unique constraints \"\n-                    \"with nulls distinct.\",\n+                    \"with nulls distinct. They are ignored for databases besides \"\n+                    \"PostgreSQL 15+.\",",
      "comment": "parameter -> argument\r\nor perhaps \"does not support UniqueConstraint.nulls_distinct.\"",
      "comment_id": 2362588094,
      "user": "timgraham",
      "created_at": "2025-09-19T11:26:22Z",
      "url": "https://github.com/django/django/pull/19870#discussion_r2362588094"
    },
    {
      "repo": "django/django",
      "pr_number": 20377,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 424,
      "side": "RIGHT",
      "diff_hunk": "@@ -421,7 +421,7 @@ def getInnerText(node):\n     return \"\".join(inner_text_list)\n \n \n-def getInnerTextList(node):\n+def getInnerTextList(node, max_depth=1, _depth=0):",
      "comment": "Limit max recursion depth to 1 level because fixtures only need text one level deep",
      "comment_id": 2594826777,
      "user": "p-r-a-v-i-n",
      "created_at": "2025-12-06T12:52:05Z",
      "url": "https://github.com/django/django/pull/20377#discussion_r2594826777"
    },
    {
      "repo": "django/django",
      "pr_number": 20377,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 427,
      "side": "RIGHT",
      "diff_hunk": "@@ -421,8 +421,11 @@ def getInnerText(node):\n     return \"\".join(inner_text_list)\n \n \n-def getInnerTextList(node):\n-    \"\"\"Return a list of the inner texts of a DOM node (recursively).\"\"\"\n+def getInnerTextList(node, max_depth=1, _depth=0):\n+    \"\"\"\n+    Return inner text from a DOM node, limited by max_depth.\n+    This avoids collecting deeply nested text.",
      "comment": "Thanks, but `getInnerText()` is still not correct.",
      "comment_id": 2602644048,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-09T13:22:33Z",
      "url": "https://github.com/django/django/pull/20377#discussion_r2602644048"
    },
    {
      "repo": "django/django",
      "pr_number": 20377,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 427,
      "side": "RIGHT",
      "diff_hunk": "@@ -421,8 +421,11 @@ def getInnerText(node):\n     return \"\".join(inner_text_list)\n \n \n-def getInnerTextList(node):\n-    \"\"\"Return a list of the inner texts of a DOM node (recursively).\"\"\"\n+def getInnerTextList(node, max_depth=1, _depth=0):\n+    \"\"\"\n+    Return inner text from a DOM node, limited by max_depth.\n+    This avoids collecting deeply nested text.",
      "comment": "my bad, i missed it. thank for catching it. I have updated now",
      "comment_id": 2602717132,
      "user": "p-r-a-v-i-n",
      "created_at": "2025-12-09T13:38:45Z",
      "url": "https://github.com/django/django/pull/20377#discussion_r2602717132"
    },
    {
      "repo": "django/django",
      "pr_number": 20377,
      "file_path": "tests/fixtures/tests.py",
      "line": 530,
      "side": "RIGHT",
      "diff_hunk": "@@ -520,6 +521,14 @@ def test_loading_and_dumping(self):\n             natural_foreign_keys=True,\n         )\n \n+    def test_deeply_nested_elements(self):\n+        \"\"\"Text inside deeply-nested tags is skipped.\"\"\"\n+        management.call_command(\n+            \"loaddata\", \"invalid_deeply_nested_elements.xml\", verbosity=0\n+        )\n+        person = Person.objects.get(pk=1)\n+        self.assertEqual(person.name, \"Django\")  # not \"Django pony\"",
      "comment": "I find that surprising. I'd expect `Django <em>pony</em>` or a `SuspiciousOperation`.",
      "comment_id": 2616789793,
      "user": "shaib",
      "created_at": "2025-12-14T07:14:56Z",
      "url": "https://github.com/django/django/pull/20377#discussion_r2616789793"
    },
    {
      "repo": "django/django",
      "pr_number": 20281,
      "file_path": "tests/migrations/test_loader.py",
      "line": 687,
      "side": "RIGHT",
      "diff_hunk": "@@ -682,8 +682,10 @@ def test_loading_order_does_not_create_circular_dependency(self):\n         with tempfile.NamedTemporaryFile(\n             mode=\"w\", encoding=\"utf-8\", suffix=\".py\", dir=tests_dir, delete=False\n         ) as test_settings:\n+            self.addCleanup(os.remove, test_settings.name)\n             for attr, value in settings._wrapped.__dict__.items():\n-                if attr.isupper():\n+                # Only write literal values.",
      "comment": "\"... so that any settings that reference a value that needs an import are omitted.\"",
      "comment_id": 2548187936,
      "user": "timgraham",
      "created_at": "2025-11-21T01:00:43Z",
      "url": "https://github.com/django/django/pull/20281#discussion_r2548187936"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2362,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2345,34 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        # we don't want to harm original query, so we need to clone it\n+        q = self.clone()\n+        if q.group_by is False:\n+            # there is no use case for that, but we need to be sure\n+            return False\n+        if q.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all required groupbies(True) generated automatically\n+            # from models fields - so, it is safe to clear ordering\n+            return True",
      "comment": "No need to clone immediately for these two check as it's a potentially costly operation.\r\n\r\n```suggestion\r\n        if self.group_by is False:\r\n            # there is no use case for that, but we need to be sure\r\n            return False\r\n        if self.group_by in (None, True):\r\n            # it seems like there is no aggregation at all (None)\r\n            # or there are all required groupbies(True) generated automatically\r\n            # from models fields - so, it is safe to clear ordering\r\n            return True\r\n        q = self.clone()\r\n```",
      "comment_id": 2593529018,
      "user": "charettes",
      "created_at": "2025-12-05T18:11:52Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2593529018"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2372,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2345,34 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        # we don't want to harm original query, so we need to clone it\n+        q = self.clone()\n+        if q.group_by is False:\n+            # there is no use case for that, but we need to be sure\n+            return False\n+        if q.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all required groupbies(True) generated automatically\n+            # from models fields - so, it is safe to clear ordering\n+            return True\n+        order_by_set = set(\n+            [\n+                (\n+                    order_by.resolve_expression(q)\n+                    if hasattr(order_by, \"resolve_expression\")\n+                    else F(order_by).resolve_expression(q)\n+                )\n+                for order_by in q.order_by\n+            ]\n+        ).union(q.extra_order_by)",
      "comment": "You can also avoid the clone if `not (q.order_by or q.extra_order_by)` I believe as an empty set is necessarily a subset of the group by.",
      "comment_id": 2593533846,
      "user": "charettes",
      "created_at": "2025-12-05T18:13:47Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2593533846"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 544,
      "side": "RIGHT",
      "diff_hunk": "@@ -534,7 +534,14 @@ def get_aggregation(self, using, aggregate_exprs):\n             # Queries with distinct_fields need ordering and when a limit is\n             # applied we must take the slice from the ordered query. Otherwise\n             # no need for ordering.\n-            inner_query.clear_ordering(force=False)\n+            if (\n+                not inner_query.is_sliced\n+                and not inner_query.distinct_fields\n+                and inner_query.orderby_issubset_groupby\n+            ):\n+                inner_query.order_by = ()\n+                inner_query.extra_order_by = ()\n+                inner_query.default_ordering = False",
      "comment": "Should we still delegate to `clear_ordering` with `force=True` instead?\r\n\r\n```suggestion\r\n            if (\r\n                not inner_query.is_sliced\r\n                and not inner_query.distinct_fields\r\n                and inner_query.orderby_issubset_groupby\r\n            ):\r\n                inner_query.clear_ordering(force=True)\r\n```",
      "comment_id": 2594028927,
      "user": "charettes",
      "created_at": "2025-12-05T21:26:04Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2594028927"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2374,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2345,34 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        # we don't want to harm original query, so we need to clone it\n+        q = self.clone()\n+        if q.group_by is False:\n+            # there is no use case for that, but we need to be sure\n+            return False\n+        if q.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all required groupbies(True) generated automatically\n+            # from models fields - so, it is safe to clear ordering\n+            return True\n+        order_by_set = set(\n+            [\n+                (\n+                    order_by.resolve_expression(q)\n+                    if hasattr(order_by, \"resolve_expression\")\n+                    else F(order_by).resolve_expression(q)\n+                )\n+                for order_by in q.order_by\n+            ]\n+        ).union(q.extra_order_by)\n+        group_by_set = set([group_by.resolve_expression(q) for group_by in q.group_by])\n+        return order_by_set.issubset(group_by_set)",
      "comment": "Do we have members of `group_by` which are not already resolved? I thought they must be already resolved since they are plucked from `Query.select` and `annotations`.\r\n\r\nhttps://github.com/django/django/blob/020e5799ad74cfafd469f032cd05767c9d670a16/django/db/models/sql/query.py#L2383-L2391\r\n\r\nassuming this is the case it means it could be reduced to\r\n\r\n```suggestion\r\n        return order_by_set.issubset(self.group_by)\r\n```",
      "comment_id": 2594039459,
      "user": "charettes",
      "created_at": "2025-12-05T21:31:57Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2594039459"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "tests/aggregation_regress/tests.py",
      "line": 194,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,56 @@ def assertObjectAttrs(self, obj, **kwargs):\n         for attr, value in kwargs.items():\n             self.assertEqual(getattr(obj, attr), value)\n \n+    def test_count_preserve_group_by(self):\n+        # new release of the same book\n+        Book.objects.create(\n+            isbn=\"113235613\",\n+            name=self.b4.name,\n+            pages=self.b4.pages,\n+            rating=4.0,\n+            price=Decimal(\"39.69\"),\n+            contact=self.a5,\n+            publisher=self.p3,\n+            pubdate=datetime.date(2018, 11, 3),\n+        )\n+        qs = Book.objects.values(\"contact__name\", \"publisher__name\").annotate(\n+            publications=Count(\"id\")\n+        )\n+        self.assertEqual(qs.count(), 6)\n+        self.assertEqual(qs.count(), len(qs))\n+        # before ticket 26434 had been solved .count() was returning also 6\n+        self.assertEqual(qs.order_by(\"id\").count(), 7)\n+        # before ticket 26434 had been solved .count() was not equal to len(qs)\n+        self.assertEqual(qs.order_by(\"id\").count(), len(qs.order_by(\"id\")))",
      "comment": "I feel like the last assertion is enough as it keeps the ticket focused on the problem at play (mismatch in length between count and `len`) but mergers will\r\n\r\n```suggestion\r\n        self.assertEqual(qs.order_by(\"id\").count(), len(qs.order_by(\"id\")))\r\n```\r\n\r\n",
      "comment_id": 2596683385,
      "user": "charettes",
      "created_at": "2025-12-07T23:07:09Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2596683385"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "tests/aggregation_regress/tests.py",
      "line": 223,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,56 @@ def assertObjectAttrs(self, obj, **kwargs):\n         for attr, value in kwargs.items():\n             self.assertEqual(getattr(obj, attr), value)\n \n+    def test_count_preserve_group_by(self):\n+        # new release of the same book\n+        Book.objects.create(\n+            isbn=\"113235613\",\n+            name=self.b4.name,\n+            pages=self.b4.pages,\n+            rating=4.0,\n+            price=Decimal(\"39.69\"),\n+            contact=self.a5,\n+            publisher=self.p3,\n+            pubdate=datetime.date(2018, 11, 3),\n+        )\n+        qs = Book.objects.values(\"contact__name\", \"publisher__name\").annotate(\n+            publications=Count(\"id\")\n+        )\n+        self.assertEqual(qs.count(), 6)\n+        self.assertEqual(qs.count(), len(qs))\n+        # before ticket 26434 had been solved .count() was returning also 6\n+        self.assertEqual(qs.order_by(\"id\").count(), 7)\n+        # before ticket 26434 had been solved .count() was not equal to len(qs)\n+        self.assertEqual(qs.order_by(\"id\").count(), len(qs.order_by(\"id\")))\n+\n+    def test_aggregate_preserve_group_by(self):\n+        # new release of the same book\n+        Book.objects.create(\n+            isbn=\"113235613\",\n+            name=self.b4.name,\n+            pages=self.b4.pages,\n+            rating=4.0,\n+            price=Decimal(\"39.69\"),\n+            contact=self.a5,\n+            publisher=self.p3,\n+            pubdate=datetime.date(2018, 11, 3),\n+        )\n+        qs = Book.objects.values(\"contact__name\", \"publisher__name\").annotate(\n+            publications=Count(\"id\")\n+        )\n+        self.assertEqual(qs.count(), 6)\n+        self.assertEqual(\n+            qs.aggregate(Avg(\"rating\"))[\"rating__avg\"], (12.5 + 3 * 4.0) / 6\n+        )\n+        # before ticket 26434 had been solved .count() was returning also 6\n+        self.assertEqual(qs.order_by(\"id\").count(), 7)\n+        # before ticket 26434 had been solved .aggregate(Avg(...))\n+        # was returning also (12.5 + 3 * 4.0) / 6)\n+        self.assertEqual(\n+            qs.order_by(\"id\").aggregate(Avg(\"rating\"))[\"rating__avg\"],\n+            (12.5 + 4 * 4.0) / 7,\n+        )\n+",
      "comment": "Similar story here and you can drop the ticket reference as it's _baked_ into the commit message and easily referenceable through blame.\r\n\r\n```suggestion\r\n        self.assertEqual(\r\n            qs.order_by(\"id\").aggregate(Avg(\"rating\"))[\"rating__avg\"],\r\n            (12.5 + 4 * 4.0) / 7,\r\n        )\r\n\r\n```",
      "comment_id": 2596684186,
      "user": "charettes",
      "created_at": "2025-12-07T23:08:41Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2596684186"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2362,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,34 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            # there is no use case for that, but we need to be sure\n+            return False\n+        if self.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all required groupbies(True) generated automatically\n+            # from models fields - so, it is safe to clear ordering\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # empty set is necessarily a subset of the group by\n+            return True\n+        # we don't want to harm original query, so we need to clone it",
      "comment": "Maybe harm is too harsh and we want to use _pollute_ but I'm not native speaker ",
      "comment_id": 2596684991,
      "user": "charettes",
      "created_at": "2025-12-07T23:09:32Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2596684991"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2353,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,34 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            # there is no use case for that, but we need to be sure\n+            return False",
      "comment": "If there is no use case it means it's dead code from its inception and thus and it can be removed.\r\n\r\n`Query.group_by` appears to be `None | True | tuple[Compilable]`",
      "comment_id": 2596686043,
      "user": "charettes",
      "created_at": "2025-12-07T23:10:54Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2596686043"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2357,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,34 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            # there is no use case for that, but we need to be sure\n+            return False\n+        if self.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all required groupbies(True) generated automatically\n+            # from models fields - so, it is safe to clear ordering",
      "comment": "Minor but the _it is safe to clear ordering_ assumes the sole caller will always be for order clearing purpose.\r\n\r\nMaybe something along the lines of \r\n\r\n```\r\nWhen grouping by all fields the order by is necessarily a subset of the group by.\r\n```",
      "comment_id": 2596689748,
      "user": "charettes",
      "created_at": "2025-12-07T23:15:31Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2596689748"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2353,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,34 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            # there is no use case for that, but we need to be sure\n+            return False",
      "comment": "That's an [unrelated flaky test that we're addressing](https://code.djangoproject.com/ticket/36769#comment:9) as soon as Python issues a patch release of 3.12.",
      "comment_id": 2615132395,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T18:05:54Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615132395"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2370,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,33 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            return False\n+        if self.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all groupbies(True) generated automatically from\n+            # models fields - the order by is necessarilly a subset of them\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # empty set is necessarily a subset of the group by\n+            return True\n+        # we don't want to pollute original query(joins)\n+        q = self.clone()\n+        order_by_set = {\n+            (\n+                order_by.resolve_expression(q)\n+                if hasattr(order_by, \"resolve_expression\")\n+                else F(order_by).resolve_expression(q)\n+            )\n+            for order_by in q.order_by\n+        }.union(q.extra_order_by)",
      "comment": "`extra_order_by` is composed of strings, don't we need to resolve them to `Col`s as well?",
      "comment_id": 2615244857,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T18:50:47Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615244857"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2370,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,33 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            return False\n+        if self.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all groupbies(True) generated automatically from\n+            # models fields - the order by is necessarilly a subset of them\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # empty set is necessarily a subset of the group by\n+            return True\n+        # we don't want to pollute original query(joins)\n+        q = self.clone()\n+        order_by_set = {\n+            (\n+                order_by.resolve_expression(q)\n+                if hasattr(order_by, \"resolve_expression\")\n+                else F(order_by).resolve_expression(q)\n+            )\n+            for order_by in q.order_by\n+        }.union(q.extra_order_by)",
      "comment": "@jacobtylerwalls they can't; `extra_order_by` is this weird thing coming from `extra(order_by)` which is raw SQL.\r\n\r\nI've been trying to kill it #16681 for reference.",
      "comment_id": 2615249469,
      "user": "charettes",
      "created_at": "2025-12-12T18:52:41Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615249469"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2370,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,33 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            return False\n+        if self.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all groupbies(True) generated automatically from\n+            # models fields - the order by is necessarilly a subset of them\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # empty set is necessarily a subset of the group by\n+            return True\n+        # we don't want to pollute original query(joins)\n+        q = self.clone()\n+        order_by_set = {\n+            (\n+                order_by.resolve_expression(q)\n+                if hasattr(order_by, \"resolve_expression\")\n+                else F(order_by).resolve_expression(q)\n+            )\n+            for order_by in q.order_by\n+        }.union(q.extra_order_by)",
      "comment": "Not sure if `extra(select)` ever end up in `group_by` but we are definitely more interested in `q.extra_order_by.values()` here.\r\n\r\nMaybe we could return `False` the moment `bool(q.extra_order_by)` until we finally kill it?",
      "comment_id": 2615262628,
      "user": "charettes",
      "created_at": "2025-12-12T18:57:15Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615262628"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2370,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,33 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            return False\n+        if self.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all groupbies(True) generated automatically from\n+            # models fields - the order by is necessarilly a subset of them\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # empty set is necessarily a subset of the group by\n+            return True\n+        # we don't want to pollute original query(joins)\n+        q = self.clone()\n+        order_by_set = {\n+            (\n+                order_by.resolve_expression(q)\n+                if hasattr(order_by, \"resolve_expression\")\n+                else F(order_by).resolve_expression(q)\n+            )\n+            for order_by in q.order_by\n+        }.union(q.extra_order_by)",
      "comment": "Yes, makes sense. extra(order_by) is just the weird legacy case we need to account for. I'll update the patch accordingly.",
      "comment_id": 2615276838,
      "user": "michalnik",
      "created_at": "2025-12-12T19:03:08Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615276838"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2370,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,33 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            return False\n+        if self.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all groupbies(True) generated automatically from\n+            # models fields - the order by is necessarilly a subset of them\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # empty set is necessarily a subset of the group by\n+            return True\n+        # we don't want to pollute original query(joins)\n+        q = self.clone()\n+        order_by_set = {\n+            (\n+                order_by.resolve_expression(q)\n+                if hasattr(order_by, \"resolve_expression\")\n+                else F(order_by).resolve_expression(q)\n+            )\n+            for order_by in q.order_by\n+        }.union(q.extra_order_by)",
      "comment": "The test case I just pushed gives me this:\r\n```py\r\n(Pdb) print(q.extra_order_by)\r\n['id']\r\n```",
      "comment_id": 2615277284,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T19:03:20Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615277284"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2370,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,33 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            return False\n+        if self.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all groupbies(True) generated automatically from\n+            # models fields - the order by is necessarilly a subset of them\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # empty set is necessarily a subset of the group by\n+            return True\n+        # we don't want to pollute original query(joins)\n+        q = self.clone()\n+        order_by_set = {\n+            (\n+                order_by.resolve_expression(q)\n+                if hasattr(order_by, \"resolve_expression\")\n+                else F(order_by).resolve_expression(q)\n+            )\n+            for order_by in q.order_by\n+        }.union(q.extra_order_by)",
      "comment": "> this weird thing coming from extra(order_by) which is raw SQL.\r\n\r\nOh, then I guess my test isn't realistic.",
      "comment_id": 2615290542,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T19:08:49Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615290542"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2370,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,33 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        \"\"\"\n+        Return true if order_by of query is subset of group_by.\n+        \"\"\"\n+        if self.group_by is False:\n+            return False\n+        if self.group_by in (None, True):\n+            # it seems like there is no aggregation at all (None)\n+            # or there are all groupbies(True) generated automatically from\n+            # models fields - the order by is necessarilly a subset of them\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # empty set is necessarily a subset of the group by\n+            return True\n+        # we don't want to pollute original query(joins)\n+        q = self.clone()\n+        order_by_set = {\n+            (\n+                order_by.resolve_expression(q)\n+                if hasattr(order_by, \"resolve_expression\")\n+                else F(order_by).resolve_expression(q)\n+            )\n+            for order_by in q.order_by\n+        }.union(q.extra_order_by)",
      "comment": "You're completely right, it's a not a `dict` at all, it's a collection of raw SQL (I got confused with `extra_select`)\r\n\r\nIn this case the `.values()` doesn't make sense but unless we want to invest time in enabling this optimization in the presence of `extra(order_by)` (which is documented to be deprecated) it might be better to opt-out by returning `False` immediately in its presence.",
      "comment_id": 2615293375,
      "user": "charettes",
      "created_at": "2025-12-12T19:09:48Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615293375"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2371,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2343,32 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        if self.extra_order_by:\n+            # Raw SQL from extra(order_by=...) can't be reliably compared\n+            # against resolved OrderBy/Col expressions. Treat as not a subset.\n+            return False\n+        if self.group_by in (None, True):\n+            # There is either no aggregation at all (None), or the group by\n+            # is generated automatically from model fields (True), in which\n+            # case the order by is necessarily a subset of them.\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # An empty set is always a subset of something.\n+            return True\n+        # Don't pollute the original query (might disrupt joins).\n+        q = self.clone()\n+        order_by_set = {\n+            (\n+                order_by.resolve_expression(q)\n+                if hasattr(order_by, \"resolve_expression\")\n+                else F(order_by).resolve_expression(q)\n+            )\n+            for order_by in q.order_by\n+        }\n+        return order_by_set.issubset(self.group_by)\n+\n     def clear_ordering(self, force=False, clear_default=True):\n         \"\"\"\n         Remove any ordering settings if the current query allows it without",
      "comment": "Is there a reason you didn't opt for:\n```suggestion\n            if inner_query.orderby_issubset_groupby:\n                inner_query.clear_ordering(force=False)\n```",
      "comment_id": 2615411906,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T19:56:47Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615411906"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 542,
      "side": "RIGHT",
      "diff_hunk": "@@ -534,7 +534,12 @@ def get_aggregation(self, using, aggregate_exprs):\n             # Queries with distinct_fields need ordering and when a limit is\n             # applied we must take the slice from the ordered query. Otherwise\n             # no need for ordering.\n-            inner_query.clear_ordering(force=False)\n+            if (\n+                not inner_query.is_sliced\n+                and not inner_query.distinct_fields\n+                and inner_query.orderby_issubset_groupby\n+            ):\n+                inner_query.clear_ordering(force=True)",
      "comment": "Github chewed up my last comment, leaving it again.\n\nIs there reason you didn't opt for:\n```suggestion\n            if inner_query.orderby_issubset_groupby:\n                inner_query.clear_ordering(force=False)\n```\n",
      "comment_id": 2615415580,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T19:58:13Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615415580"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 542,
      "side": "RIGHT",
      "diff_hunk": "@@ -534,7 +534,12 @@ def get_aggregation(self, using, aggregate_exprs):\n             # Queries with distinct_fields need ordering and when a limit is\n             # applied we must take the slice from the ordered query. Otherwise\n             # no need for ordering.\n-            inner_query.clear_ordering(force=False)\n+            if (\n+                not inner_query.is_sliced\n+                and not inner_query.distinct_fields\n+                and inner_query.orderby_issubset_groupby\n+            ):\n+                inner_query.clear_ordering(force=True)",
      "comment": "I followed blindly the comments (line: 534) hoping that is true:\r\n```python\r\n# Queries with distinct_fields need ordering and when a limit is\r\n# applied we must take the slice from the ordered query. Otherwise\r\n# no need for ordering.\r\n```",
      "comment_id": 2615426796,
      "user": "michalnik",
      "created_at": "2025-12-12T20:03:27Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615426796"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 542,
      "side": "RIGHT",
      "diff_hunk": "@@ -534,7 +534,12 @@ def get_aggregation(self, using, aggregate_exprs):\n             # Queries with distinct_fields need ordering and when a limit is\n             # applied we must take the slice from the ordered query. Otherwise\n             # no need for ordering.\n-            inner_query.clear_ordering(force=False)\n+            if (\n+                not inner_query.is_sliced\n+                and not inner_query.distinct_fields\n+                and inner_query.orderby_issubset_groupby\n+            ):\n+                inner_query.clear_ordering(force=True)",
      "comment": "For sure, I just mean the `clear_ordering()` actually handles that for you and also checks `select_for_update`. See the beginning of `clear_ordering()`.\r\n\r\nJust so that we don't actually introduce any drift against that implementation, I'll roll this in for you \ud83d\udc4d ",
      "comment_id": 2615539927,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T20:47:41Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615539927"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "tests/aggregation_regress/tests.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,44 @@ def assertObjectAttrs(self, obj, **kwargs):\n         for attr, value in kwargs.items():\n             self.assertEqual(getattr(obj, attr), value)\n \n+    def test_count_preserve_group_by(self):\n+        # new release of the same book\n+        Book.objects.create(\n+            isbn=\"113235613\",\n+            name=self.b4.name,\n+            pages=self.b4.pages,\n+            rating=4.0,\n+            price=Decimal(\"39.69\"),\n+            contact=self.a5,\n+            publisher=self.p3,\n+            pubdate=datetime.date(2018, 11, 3),\n+        )\n+        qs = Book.objects.values(\"contact__name\", \"publisher__name\").annotate(\n+            publications=Count(\"id\")\n+        )\n+        self.assertEqual(qs.order_by(\"id\").count(), len(qs.order_by(\"id\")))\n+        self.assertEqual(qs.extra(order_by=[\"id\"]).count(), len(qs.order_by(\"id\")))\n+\n+    def test_aggregate_preserve_group_by(self):\n+        # new release of the same book\n+        Book.objects.create(\n+            isbn=\"113235613\",\n+            name=self.b4.name,\n+            pages=self.b4.pages,\n+            rating=4.0,\n+            price=Decimal(\"39.69\"),\n+            contact=self.a5,\n+            publisher=self.p3,\n+            pubdate=datetime.date(2018, 11, 3),\n+        )\n+        qs = Book.objects.values(\"contact__name\", \"publisher__name\").annotate(\n+            publications=Count(\"id\")\n+        )\n+        self.assertEqual(",
      "comment": "I was about to change this to assertAlmostEqual just out of paranoia about the decimal value, when I realized I think the other test is sufficient. I think Simon suggested something along those lines. I'll remove it.",
      "comment_id": 2615551547,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T20:52:17Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615551547"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2356,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2339,32 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        if self.extra_order_by:\n+            # Raw SQL from extra(order_by=...) can't be reliably compared\n+            # against resolved OrderBy/Col expressions. Treat as not a subset.\n+            return False\n+        if self.group_by in (None, True):\n+            # There is either no aggregation at all (None), or the group by\n+            # is generated automatically from model fields (True), in which\n+            # case the order by is necessarily a subset of them.\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # An empty set is always a subset of something.\n+            return True",
      "comment": "Just noticed from the coverage report that this line is not covered. When would `self.group_by` be an empty iterable?",
      "comment_id": 2615898688,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-13T00:26:12Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615898688"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2356,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2339,32 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        if self.extra_order_by:\n+            # Raw SQL from extra(order_by=...) can't be reliably compared\n+            # against resolved OrderBy/Col expressions. Treat as not a subset.\n+            return False\n+        if self.group_by in (None, True):\n+            # There is either no aggregation at all (None), or the group by\n+            # is generated automatically from model fields (True), in which\n+            # case the order by is necessarily a subset of them.\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # An empty set is always a subset of something.\n+            return True",
      "comment": "With the current call site never as we only get in this branch `if isinstance(self.group_by, tuple)` which means the queryset was previously annotated with an aggregate expression and that there was at least one value passed to `values` to specify the group by prior to that.\r\n\r\nIt might be handy if `orderby_issubset_groupby` is eventually called from other context but in with this single call site it's not.",
      "comment_id": 2615969005,
      "user": "charettes",
      "created_at": "2025-12-13T01:33:34Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2615969005"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2356,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2339,32 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        if self.extra_order_by:\n+            # Raw SQL from extra(order_by=...) can't be reliably compared\n+            # against resolved OrderBy/Col expressions. Treat as not a subset.\n+            return False\n+        if self.group_by in (None, True):\n+            # There is either no aggregation at all (None), or the group by\n+            # is generated automatically from model fields (True), in which\n+            # case the order by is necessarily a subset of them.\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # An empty set is always a subset of something.\n+            return True",
      "comment": "Shouldn't we also short-circuit if `self.order_by` is empty and `self.group_by` is non-empty?\n\nAnd if `self.order_by` is non-empty but `self.group_by` is empty, we could also short-circuit but return `False`.",
      "comment_id": 2616006109,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-13T02:42:03Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2616006109"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2356,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2339,32 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        if self.extra_order_by:\n+            # Raw SQL from extra(order_by=...) can't be reliably compared\n+            # against resolved OrderBy/Col expressions. Treat as not a subset.\n+            return False\n+        if self.group_by in (None, True):\n+            # There is either no aggregation at all (None), or the group by\n+            # is generated automatically from model fields (True), in which\n+            # case the order by is necessarily a subset of them.\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # An empty set is always a subset of something.\n+            return True",
      "comment": "> Shouldn't we also short-circuit if self.order_by is empty and self.group_by is non-empty?\r\n\r\nWe could yes to be coherent with the method name but if there is no ordering there is little value in clearing it.\r\n\r\n> And if self.order_by is non-empty but self.group_by is empty, we could also short-circuit but return False.\r\n\r\nSame story IMO, we have to choose a side.\r\n\r\nDo we want to make the function caller aware (make choices knowing it will only be called in the context of `get_aggregation`) or make it general purposed with all the optimization possible but harder to exercise through code coverage.",
      "comment_id": 2616021621,
      "user": "charettes",
      "created_at": "2025-12-13T03:10:40Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2616021621"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2356,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2339,32 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        if self.extra_order_by:\n+            # Raw SQL from extra(order_by=...) can't be reliably compared\n+            # against resolved OrderBy/Col expressions. Treat as not a subset.\n+            return False\n+        if self.group_by in (None, True):\n+            # There is either no aggregation at all (None), or the group by\n+            # is generated automatically from model fields (True), in which\n+            # case the order by is necessarily a subset of them.\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # An empty set is always a subset of something.\n+            return True",
      "comment": "Thanks, I'm just not understanding why `group_by` is in this condition; your earlier suggestion had `extra_order_by` there instead.\r\n\r\n> We could yes to be coherent with the method name but if there is no ordering there is little value in clearing it.\r\n\r\nIn that case, I think we should either change this to\r\n```py\r\nif not order_by:\r\n    # Empty sets are always subsets, but there's no point in clearing an ordering.\r\n    return False\r\n```\r\nOr just remove it altogether.\r\n\r\nIf we do that suggested tweak, then we're not doing all possible optimizations but we are doing the most likely one.",
      "comment_id": 2616350203,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-13T14:54:03Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2616350203"
    },
    {
      "repo": "django/django",
      "pr_number": 20374,
      "file_path": "django/db/models/sql/query.py",
      "line": 2356,
      "side": "RIGHT",
      "diff_hunk": "@@ -2338,6 +2339,32 @@ def add_ordering(self, *ordering):\n         else:\n             self.default_ordering = False\n \n+    @property\n+    def orderby_issubset_groupby(self):\n+        if self.extra_order_by:\n+            # Raw SQL from extra(order_by=...) can't be reliably compared\n+            # against resolved OrderBy/Col expressions. Treat as not a subset.\n+            return False\n+        if self.group_by in (None, True):\n+            # There is either no aggregation at all (None), or the group by\n+            # is generated automatically from model fields (True), in which\n+            # case the order by is necessarily a subset of them.\n+            return True\n+        if not (self.order_by or self.group_by):\n+            # An empty set is always a subset of something.\n+            return True",
      "comment": "I'm good with switching it to solely checking `not order_by` \ud83d\udc4d ",
      "comment_id": 2616364210,
      "user": "charettes",
      "created_at": "2025-12-13T15:22:56Z",
      "url": "https://github.com/django/django/pull/20374#discussion_r2616364210"
    },
    {
      "repo": "django/django",
      "pr_number": 20362,
      "file_path": "django/db/backends/base/schema.py",
      "line": 918,
      "side": "RIGHT",
      "diff_hunk": "@@ -906,6 +910,15 @@ def alter_field(self, model, old_field, new_field, strict=False):\n             else:\n                 new_field_sql = new_field.generated_sql(self.connection)\n                 modifying_generated_field = old_field_sql != new_field_sql\n+                db_features = self.connection.features\n+                # Some databases (e.g. Oracle) don't allow altering a data type\n+                # for generated columns.\n+                if (\n+                    not modifying_generated_field\n+                    and old_type != new_type",
      "comment": "I think we have to check for collation here also. Any other suffixes to check?",
      "comment_id": 2615501017,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T20:32:08Z",
      "url": "https://github.com/django/django/pull/20362#discussion_r2615501017"
    },
    {
      "repo": "django/django",
      "pr_number": 20362,
      "file_path": "django/db/backends/base/schema.py",
      "line": 918,
      "side": "RIGHT",
      "diff_hunk": "@@ -906,6 +910,15 @@ def alter_field(self, model, old_field, new_field, strict=False):\n             else:\n                 new_field_sql = new_field.generated_sql(self.connection)\n                 modifying_generated_field = old_field_sql != new_field_sql\n+                db_features = self.connection.features\n+                # Some databases (e.g. Oracle) don't allow altering a data type\n+                # for generated columns.\n+                if (\n+                    not modifying_generated_field\n+                    and old_type != new_type",
      "comment": "Actually, changing only `db_collation` works fine (I've checked on `VIRTUAL` generated field).",
      "comment_id": 2615614395,
      "user": "felixxm",
      "created_at": "2025-12-12T21:23:05Z",
      "url": "https://github.com/django/django/pull/20362#discussion_r2615614395"
    },
    {
      "repo": "django/django",
      "pr_number": 20362,
      "file_path": "django/db/backends/base/schema.py",
      "line": 918,
      "side": "RIGHT",
      "diff_hunk": "@@ -906,6 +910,15 @@ def alter_field(self, model, old_field, new_field, strict=False):\n             else:\n                 new_field_sql = new_field.generated_sql(self.connection)\n                 modifying_generated_field = old_field_sql != new_field_sql\n+                db_features = self.connection.features\n+                # Some databases (e.g. Oracle) don't allow altering a data type\n+                # for generated columns.\n+                if (\n+                    not modifying_generated_field\n+                    and old_type != new_type",
      "comment": "Oh good to know. Tried to test, but it wanted me to set `MAX_STRING_SIZE=EXTENDED` and that turned out to be impossibly complicated.",
      "comment_id": 2615770931,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-12T22:44:25Z",
      "url": "https://github.com/django/django/pull/20362#discussion_r2615770931"
    },
    {
      "repo": "django/django",
      "pr_number": 20362,
      "file_path": "django/db/backends/base/schema.py",
      "line": 918,
      "side": "RIGHT",
      "diff_hunk": "@@ -906,6 +910,15 @@ def alter_field(self, model, old_field, new_field, strict=False):\n             else:\n                 new_field_sql = new_field.generated_sql(self.connection)\n                 modifying_generated_field = old_field_sql != new_field_sql\n+                db_features = self.connection.features\n+                # Some databases (e.g. Oracle) don't allow altering a data type\n+                # for generated columns.\n+                if (\n+                    not modifying_generated_field\n+                    and old_type != new_type",
      "comment": "Yes it is complicated :disappointed: \r\n\r\nTBH, I don't see us adding more and more conditions here. I would treat this check as \"the best effort\", there are too many database-specific caveats around altering `GeneratedField`. IMO, `DatabaseError` is fine here when someone hits the edge.",
      "comment_id": 2616181976,
      "user": "felixxm",
      "created_at": "2025-12-13T08:51:26Z",
      "url": "https://github.com/django/django/pull/20362#discussion_r2616181976"
    },
    {
      "repo": "django/django",
      "pr_number": 20282,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 40,
      "side": "LEFT",
      "diff_hunk": "@@ -37,13 +37,27 @@ def as_oracle(self, compiler, connection, **extra_context):\n \n class UUID7(Func):\n     function = \"UUIDV7\"\n-    arity = 0",
      "comment": "I don't think setting this to `arity = 1` (as suggested in https://github.com/django/django/pull/20101#discussion_r2608226079) makes sense, so I've just removed it again. The problem is that setting `arity = 1` means that `shift` becomes required, rather than optional. I'm open to suggestions if there's something I've missed here.",
      "comment_id": 2608390592,
      "user": "LilyFirefly",
      "created_at": "2025-12-10T22:09:22Z",
      "url": "https://github.com/django/django/pull/20282#discussion_r2608390592"
    },
    {
      "repo": "django/django",
      "pr_number": 20282,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 40,
      "side": "LEFT",
      "diff_hunk": "@@ -37,13 +37,27 @@ def as_oracle(self, compiler, connection, **extra_context):\n \n class UUID7(Func):\n     function = \"UUIDV7\"\n-    arity = 0",
      "comment": "Makes sense, I forgot we wouldn't have access to the connection's feature flags to do the switch inside `__init__()`. EDIT: I'll propose something below.",
      "comment_id": 2612172223,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-11T21:47:12Z",
      "url": "https://github.com/django/django/pull/20282#discussion_r2612172223"
    },
    {
      "repo": "django/django",
      "pr_number": 20282,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 40,
      "side": "LEFT",
      "diff_hunk": "@@ -37,13 +37,27 @@ def as_oracle(self, compiler, connection, **extra_context):\n \n class UUID7(Func):\n     function = \"UUIDV7\"\n-    arity = 0",
      "comment": "I think we can leverage the order of operations in the `Func` constructor to avoid reimplementing args checking from scratch. This works to get us args checking:\n\n```diff\ndiff --git a/django/db/models/functions/uuid.py b/django/db/models/functions/uuid.py\nindex c41f58d11b..7059798ff3 100644\n--- a/django/db/models/functions/uuid.py\n+++ b/django/db/models/functions/uuid.py\n@@ -37,13 +37,16 @@ class UUID4(Func):\n \n class UUID7(Func):\n     function = \"UUIDV7\"\n+    arity = 1\n     output_field = UUIDField()\n \n     def __init__(self, shift=None, **extra):\n-        if shift is None:\n-            super().__init__(**extra)\n-        else:\n-            super().__init__(shift, **extra)\n+        super().__init__(shift, **extra)\n+\n+    def _parse_expressions(self, *expressions):\n+        if expressions[0] is None:\n+            expressions = expressions[1:]\n+        return super()._parse_expressions(*expressions)\n \n     def as_sql(self, compiler, connection, **extra_context):\n         if not connection.features.supports_uuid7_function:\n```",
      "comment_id": 2612209395,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-11T22:02:18Z",
      "url": "https://github.com/django/django/pull/20282#discussion_r2612209395"
    },
    {
      "repo": "django/django",
      "pr_number": 20282,
      "file_path": "tests/db_functions/models.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -59,3 +59,8 @@ class FloatModel(models.Model):\n \n class UUIDModel(models.Model):\n     uuid = models.UUIDField(null=True)\n+\n+\n+class UUIDDurationModel(models.Model):",
      "comment": "I'd probably just add `shift` to the existing model, unless you think that makes the test harder to grok?",
      "comment_id": 2612217387,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-11T22:04:12Z",
      "url": "https://github.com/django/django/pull/20282#discussion_r2612217387"
    },
    {
      "repo": "django/django",
      "pr_number": 20282,
      "file_path": "tests/db_functions/test_uuid.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,6 +32,29 @@ def test_uuid7(self):\n         self.assertEqual(m1.uuid.version, 7)\n         self.assertNotEqual(m1.uuid, m2.uuid)\n \n+    @skipUnlessDBFeature(\"supports_uuid7_function_shift\")\n+    def test_uuid7_shift(self):\n+        now = datetime.now(timezone.utc)\n+        past = datetime(2005, 11, 16, tzinfo=timezone.utc)\n+        shift = past - now\n+        m = UUIDModel.objects.create(uuid=UUID7(shift))\n+        m.refresh_from_db()\n+        self.assertIsInstance(m.uuid, uuid.UUID)\n+        self.assertEqual(m.uuid.version, 7)",
      "comment": "I'd chop, we have other save & reload tests.\n```suggestion\n```",
      "comment_id": 2612234718,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-11T22:09:06Z",
      "url": "https://github.com/django/django/pull/20282#discussion_r2612234718"
    },
    {
      "repo": "django/django",
      "pr_number": 20282,
      "file_path": "tests/db_functions/test_uuid.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,6 +32,29 @@ def test_uuid7(self):\n         self.assertEqual(m1.uuid.version, 7)\n         self.assertNotEqual(m1.uuid, m2.uuid)\n \n+    @skipUnlessDBFeature(\"supports_uuid7_function_shift\")\n+    def test_uuid7_shift(self):\n+        now = datetime.now(timezone.utc)\n+        past = datetime(2005, 11, 16, tzinfo=timezone.utc)\n+        shift = past - now\n+        m = UUIDModel.objects.create(uuid=UUID7(shift))\n+        m.refresh_from_db()\n+        self.assertIsInstance(m.uuid, uuid.UUID)\n+        self.assertEqual(m.uuid.version, 7)\n+        self.assertTrue(str(m.uuid).startswith(\"0107965e-e400\"))",
      "comment": "I wonder if this is a timezone difference making the calculation a bit off somewhere.\r\n\r\nIt would be useful to see what the uuid actually starts with - if it's only different in the last hexdigit, I think it may be just a precision/timing difference.",
      "comment_id": 2612291190,
      "user": "LilyFirefly",
      "created_at": "2025-12-11T22:36:41Z",
      "url": "https://github.com/django/django/pull/20282#discussion_r2612291190"
    },
    {
      "repo": "django/django",
      "pr_number": 20282,
      "file_path": "tests/db_functions/test_uuid.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,6 +32,29 @@ def test_uuid7(self):\n         self.assertEqual(m1.uuid.version, 7)\n         self.assertNotEqual(m1.uuid, m2.uuid)\n \n+    @skipUnlessDBFeature(\"supports_uuid7_function_shift\")\n+    def test_uuid7_shift(self):\n+        now = datetime.now(timezone.utc)\n+        past = datetime(2005, 11, 16, tzinfo=timezone.utc)\n+        shift = past - now\n+        m = UUIDModel.objects.create(uuid=UUID7(shift))\n+        m.refresh_from_db()\n+        self.assertIsInstance(m.uuid, uuid.UUID)\n+        self.assertEqual(m.uuid.version, 7)\n+        self.assertTrue(str(m.uuid).startswith(\"0107965e-e400\"))",
      "comment": "Sure thing. Maybe worth tweaking the assertion so it's always there.\r\n\r\n```py\r\nAssertionError: False is not true : 0107965e-e40a-7380-b548-5e3709b94f41\r\nAssertionError: False is not true : 0107965e-e406-72a3-9cf2-ac4f75411952\r\n```\r\n",
      "comment_id": 2612315206,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-11T22:49:43Z",
      "url": "https://github.com/django/django/pull/20282#discussion_r2612315206"
    },
    {
      "repo": "django/django",
      "pr_number": 20282,
      "file_path": "tests/db_functions/test_uuid.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,6 +32,29 @@ def test_uuid7(self):\n         self.assertEqual(m1.uuid.version, 7)\n         self.assertNotEqual(m1.uuid, m2.uuid)\n \n+    @skipUnlessDBFeature(\"supports_uuid7_function_shift\")\n+    def test_uuid7_shift(self):\n+        now = datetime.now(timezone.utc)\n+        past = datetime(2005, 11, 16, tzinfo=timezone.utc)\n+        shift = past - now\n+        m = UUIDModel.objects.create(uuid=UUID7(shift))\n+        m.refresh_from_db()\n+        self.assertIsInstance(m.uuid, uuid.UUID)\n+        self.assertEqual(m.uuid.version, 7)\n+        self.assertTrue(str(m.uuid).startswith(\"0107965e-e400\"))",
      "comment": "Yeah, looks like it's just a precision issue in the last hexdigit of the timestamp part.",
      "comment_id": 2612316993,
      "user": "LilyFirefly",
      "created_at": "2025-12-11T22:50:45Z",
      "url": "https://github.com/django/django/pull/20282#discussion_r2612316993"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "tests/db_functions/test_uuid.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+import uuid\n+\n+from django.db import NotSupportedError, connection\n+from django.db.models.functions import UUID4, UUID7\n+from django.test import TestCase\n+from django.test.testcases import skipIfDBFeature, skipUnlessDBFeature\n+\n+from .models import UUIDModel\n+\n+\n+class TestUUID(TestCase):\n+    @skipUnlessDBFeature(\"supports_uuid4_function\")\n+    def test_uuid4(self):\n+        m1 = UUIDModel.objects.create()\n+        m2 = UUIDModel.objects.create()\n+        UUIDModel.objects.update(uuid=UUID4())\n+        m1.refresh_from_db()\n+        m2.refresh_from_db()\n+        self.assertIsInstance(m1.uuid, uuid.UUID)\n+        self.assertEqual(m1.uuid.version, 4)",
      "comment": "We could do, but I don't think there's a big benefit either way.",
      "comment_id": 2542938281,
      "user": "LilyFirefly",
      "created_at": "2025-11-19T17:23:46Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2542938281"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/backends/sqlite3/_functions.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,6 +5,7 @@\n import functools\n import random\n import statistics\n+import uuid",
      "comment": "Do `from uuid import uuid4, uuid7` to avoid the attribute lookup in the functions - micro optimisation but since these functions can be called many times in a query I think it makes sense. uuid7 will need guarding with PY314.",
      "comment_id": 2543474426,
      "user": "adamchainz",
      "created_at": "2025-11-19T20:31:40Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2543474426"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,17 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+        )\n+        super().__init__(*args, **kwargs)",
      "comment": "Since `RandomUUID()` may have been used in migrations as a `db_default`, doesn't it have to remain for use in historical migrations?",
      "comment_id": 2546238662,
      "user": "cliffordgama",
      "created_at": "2025-11-20T14:17:03Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2546238662"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,17 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+        )\n+        super().__init__(*args, **kwargs)",
      "comment": "Regardless of the above, I'd also add \"RandomUUID is deprecated\" to the deprecation message, and a `skip_file_prefixes=django_file_prefixes()` to the `warn`, so a user is pointed to where they need to change.\r\n",
      "comment_id": 2546262213,
      "user": "cliffordgama",
      "created_at": "2025-11-20T14:23:50Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2546262213"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,17 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+        )\n+        super().__init__(*args, **kwargs)",
      "comment": "Yeah, I'm not entirely happy with this approach.\r\n\r\nFor `Field` subclasses, we can move the deprecation to the checks framework with `system_check_deprecated_details` (and later `system_check_removed_details`), but these aren't set up for expressions and I think it would be out of scope for this PR to add something like that.",
      "comment_id": 2547432896,
      "user": "LilyFirefly",
      "created_at": "2025-11-20T19:35:34Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2547432896"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,17 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+        )\n+        super().__init__(*args, **kwargs)",
      "comment": "If this is merged, django-upgrade can gain a fixer for `RandomUUID` -> `UUID4`, which would affect migrations too. That would help users of django-upgrade, at least.",
      "comment_id": 2554405884,
      "user": "adamchainz",
      "created_at": "2025-11-23T23:22:45Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2554405884"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,17 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+        )\n+        super().__init__(*args, **kwargs)",
      "comment": "I like the  Adam's proposal.\nWhat others think?\nHow do you think we want to solve this RandomUUID question here?",
      "comment_id": 2572907198,
      "user": "pauloxnet",
      "created_at": "2025-11-29T09:00:32Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2572907198"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 230,
      "side": "RIGHT",
      "diff_hunk": "@@ -224,3 +224,7 @@ def bare_select_suffix(self):\n     def supports_tuple_lookups(self):\n         # Support is known to be missing on 23.2 but available on 23.4.\n         return self.connection.oracle_version >= (23, 4)\n+\n+    @cached_property\n+    def supports_uuid4_function(self):\n+        return self.connection.oracle_version >= (23, 4)",
      "comment": "```suggestion\r\n        return self.connection.oracle_version >= (23, 9)\r\n```",
      "comment_id": 2573669121,
      "user": "felixxm",
      "created_at": "2025-11-30T13:52:17Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2573669121"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")",
      "comment": "```suggestion\r\n            raise NotSupportedError(\"UUID4 requires Oracle version 26ai or later.\")\r\n```",
      "comment_id": 2606165338,
      "user": "pauloxnet",
      "created_at": "2025-12-10T10:51:20Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2606165338"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")\n+        return self.as_sql(compiler, connection, function=\"UUID\", **extra_context)",
      "comment": "I know that based on the docs using `UUID` is OK, but what if we explicitly use the version number `UUID(4)`?\r\n\r\n> UUID can optionally take as input a version_specifier of NUMBER type. UUID(0) and UUID(4) are equivalent to UUID() in that in both cases a version 4 variant 1 UUID is returned.\r\n> Versions other than 4 and 0 return an error.\r\n\r\nSo, if in the future the `UUID` will change or be deprecated (like `GEN_RANDOM_UUID` in PG) we don't have to change nothing here.\r\n",
      "comment_id": 2606191096,
      "user": "pauloxnet",
      "created_at": "2025-12-10T10:58:48Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2606191096"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")",
      "comment": "26ai is not a precise error message. `UUID` was added in `23.9` so between `23ai` (`23.4`) and 26ai (`23.26`).",
      "comment_id": 2606212734,
      "user": "felixxm",
      "created_at": "2025-12-10T11:05:54Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2606212734"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")",
      "comment": "I was trying to update the error message based on this comment of yours:\r\nhttps://github.com/django/django/pull/20101#issuecomment-3592316394\r\n\r\n> It seems that UUID is not available in Oracle 23ai, maybe only in 26ai (23.9)\r\n\r\nfrom which I understand that the sentence:\r\n\r\n> \"UUID4 requires Oracle version 23ai or later.\"\r\n\r\nis not correct.\r\n\r\nI don't know exactly how the Oracle version number works, so please update it :-)",
      "comment_id": 2606226940,
      "user": "pauloxnet",
      "created_at": "2025-12-10T11:10:34Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2606226940"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")",
      "comment": "> ... `UUID` was added in `23.9` ...\r\n\r\nMaybe this error message is more precise?\r\n\r\n> \"UUID4 requires Oracle version 23.9 or later.\"",
      "comment_id": 2606236361,
      "user": "pauloxnet",
      "created_at": "2025-12-10T11:13:35Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2606236361"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")",
      "comment": "> I don't know exactly how the Oracle version number works, so please update it :-)\r\n\r\nno one knows :upside_down_face: ",
      "comment_id": 2606259798,
      "user": "felixxm",
      "created_at": "2025-12-10T11:21:27Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2606259798"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")",
      "comment": "I'd use the same wording that I proposed in #20362, so `23ai/26ai (23.9)`, e.g.\r\n\r\n_\"UUID4 requires Oracle version 23ai/26ai (23.9) or later.\"_",
      "comment_id": 2606549024,
      "user": "felixxm",
      "created_at": "2025-12-10T12:51:57Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2606549024"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "tests/postgres_tests/test_functions.py",
      "line": 32,
      "side": "LEFT",
      "diff_hunk": "@@ -29,11 +29,7 @@ def test_transaction_now(self):\n \n \n class TestRandomUUID(PostgreSQLTestCase):\n-    def test_random_uuid(self):",
      "comment": "Let's keep the new test for the deprecation warning but also keep the old test since it's still supported for now. All you should have to do is `warnings.catch_warnings(action=\"ignore\", category=...)`",
      "comment_id": 2607840889,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T18:49:52Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2607840889"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"",
      "comment": "We should take the opportunity to add `arity` on new built-in functions:\n```suggestion\n    function = \"UUIDV4\"\n    arity = 0\n```",
      "comment_id": 2607897034,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T19:09:33Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2607897034"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")\n+        return self.as_sql(compiler, connection, function=\"UUID\", **extra_context)\n+\n+\n+class UUID7(Func):\n+    function = \"UUIDV7\"\n+    output_field = UUIDField()",
      "comment": "We should take a decision about whether to add `arity = 0` here also, even though postgres has an optional `shift` argument, or leave it without. I don't think the shift is part of our cross-db abstraction here, so I'm okay with `arity = 0` and forcing people to subclass `Func` themselves if they want a shift. WDYT?",
      "comment_id": 2607897466,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T19:09:42Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2607897466"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,17 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+        )\n+        super().__init__(*args, **kwargs)",
      "comment": "We definitely need to keep the class forever. Whether to deprecate it is, I think, bound up with Lily's point about `system_check_deprecated_details` gaining support for inspecting `db_default`. If we don't want to do that in this PR, then we should remove the deprecation.",
      "comment_id": 2607952140,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T19:28:20Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2607952140"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning, django_file_prefixes\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"RandomUUID is deprecated. Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+            skip_file_prefixes=django_file_prefixes(),",
      "comment": "This will be pretty noisy for existing migrations. Did you look into whether you could `catch_warnings` anywhere inside the migration loader?",
      "comment_id": 2607960300,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T19:31:17Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2607960300"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")\n+        return self.as_sql(compiler, connection, function=\"UUID\", **extra_context)\n+\n+\n+class UUID7(Func):\n+    function = \"UUIDV7\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid7_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID7 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid7_function:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID7 requires PostgreSQL version 18 or later.\")\n+\n+    def as_sqlite(self, compiler, connection, **extra_context):",
      "comment": "This will help when grepping for `PY314` three years from now. :-)\n```suggestion\n    # PY314: When dropping support for 3.14, remove the entire method.\n    def as_sqlite(self, compiler, connection, **extra_context):\n```\n",
      "comment_id": 2608161415,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T20:47:41Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608161415"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/backends/sqlite3/_functions.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,6 +86,8 @@ def register(connection):\n     connection.create_aggregate(\"VAR_POP\", 1, VarPop)\n     connection.create_aggregate(\"VAR_SAMP\", 1, VarSamp)\n     connection.create_aggregate(\"ANY_VALUE\", 1, AnyValue)\n+    connection.create_function(\"UUIDV4\", 0, _sqlite_uuid4)\n+    connection.create_function(\"UUIDV7\", 0, _sqlite_uuid7)",
      "comment": "I think we should try to avoid adding an invalid function when Python > 3.14 is used. Maybe:\r\n```python\r\ndef _sqlite_uuid7():\r\n    if PY314:\r\n        from uuid import uuid7\r\n\r\n        return uuid7().hex\r\n    else:\r\n        return None\r\n```\r\nor raise an error in `else...`.",
      "comment_id": 2608200027,
      "user": "felixxm",
      "created_at": "2025-12-10T21:01:47Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608200027"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")\n+        return self.as_sql(compiler, connection, function=\"UUID\", **extra_context)\n+\n+\n+class UUID7(Func):\n+    function = \"UUIDV7\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid7_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID7 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid7_function:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID7 requires PostgreSQL version 18 or later.\")\n+\n+    def as_sqlite(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid7_function:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\n+            \"UUID7 on sqlite requires Python version 3.14 or later.\"",
      "comment": "```suggestion\r\n            \"UUID7 on SQLite requires Python version 3.14 or later.\"\r\n```",
      "comment_id": 2608205772,
      "user": "felixxm",
      "created_at": "2025-12-10T21:04:17Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608205772"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 5,
      "side": "LEFT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning, django_file_prefixes\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"",
      "comment": "I don't think it's worth removing these class attributes -- we're breaking backward compatibility for subclasses that might be using different `template` or `function` or `output_field`.",
      "comment_id": 2608208743,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T21:05:37Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608208743"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning, django_file_prefixes\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(",
      "comment": "Reminder for when you've finalized the deprecation strategy: Please add a `# RemovedInDjango70Warning` with instructions about how to alter the code.",
      "comment_id": 2608211211,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T21:06:44Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608211211"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/models/functions/uuid.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from django.db import NotSupportedError\n+from django.db.models.expressions import Func\n+from django.db.models.fields import UUIDField\n+\n+\n+class UUID4(Func):\n+    function = \"UUIDV4\"\n+    output_field = UUIDField()\n+\n+    def as_sql(self, compiler, connection, **extra_context):\n+        if connection.features.supports_uuid4_function:\n+            return super().as_sql(compiler, connection, **extra_context)\n+        raise NotSupportedError(\"UUID4 is not supported on this database backend.\")\n+\n+    def as_postgresql(self, compiler, connection, **extra_context):\n+        if connection.features.is_postgresql_18:\n+            return self.as_sql(compiler, connection, **extra_context)\n+        return self.as_sql(\n+            compiler, connection, function=\"GEN_RANDOM_UUID\", **extra_context\n+        )\n+\n+    def as_mysql(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            if connection.mysql_is_mariadb:\n+                raise NotSupportedError(\"UUID4 requires MariaDB version 11.7 or later.\")\n+            raise NotSupportedError(\"UUID4 is not supported on MySQL.\")\n+        return self.as_sql(compiler, connection, function=\"UUID_V4\", **extra_context)\n+\n+    def as_oracle(self, compiler, connection, **extra_context):\n+        if not connection.features.supports_uuid4_function:\n+            raise NotSupportedError(\"UUID4 requires Oracle version 23ai or later.\")\n+        return self.as_sql(compiler, connection, function=\"UUID\", **extra_context)\n+\n+\n+class UUID7(Func):\n+    function = \"UUIDV7\"\n+    output_field = UUIDField()",
      "comment": "Oh, I just saw #20282. In that case let's definitely use `arity=0` here and then in #20282 we can change to `arity=1` and then raise in `__init__` for providing `shift` on unsupported backends before delegating to the super's arity checks.",
      "comment_id": 2608226079,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T21:12:57Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608226079"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning, django_file_prefixes\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"RandomUUID is deprecated. Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+            skip_file_prefixes=django_file_prefixes(),",
      "comment": "Since we probably don't want to do that, I think I prefer either the system check or not deprecating.",
      "comment_id": 2608234157,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T21:16:04Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608234157"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning, django_file_prefixes\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"RandomUUID is deprecated. Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+            skip_file_prefixes=django_file_prefixes(),",
      "comment": "I think I'll just remove the deprecation. We could document the new alternative, but anything more than that is too much hassle without the check infrastructure, which I don't want to add. This could be revisited if someone else adds it. Should we have a ticket for that?",
      "comment_id": 2608251263,
      "user": "LilyFirefly",
      "created_at": "2025-12-10T21:22:46Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608251263"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning, django_file_prefixes\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"\n-    output_field = UUIDField()\n+\n+class RandomUUID(UUID4):\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"RandomUUID is deprecated. Use django.db.models.functions.UUID4 instead.\",\n+            RemovedInDjango70Warning,\n+            skip_file_prefixes=django_file_prefixes(),",
      "comment": "> Should we have a ticket for that?\r\n\r\nSure, but I would say a new-features issue: \"make it possible to deprecate expressions\". Let me know if you don't have a cycle for that, I could toss something quickly over the wall.",
      "comment_id": 2608288501,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-10T21:34:23Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608288501"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/db/backends/sqlite3/_functions.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,6 +86,8 @@ def register(connection):\n     connection.create_aggregate(\"VAR_POP\", 1, VarPop)\n     connection.create_aggregate(\"VAR_SAMP\", 1, VarSamp)\n     connection.create_aggregate(\"ANY_VALUE\", 1, AnyValue)\n+    connection.create_function(\"UUIDV4\", 0, _sqlite_uuid4)\n+    connection.create_function(\"UUIDV7\", 0, _sqlite_uuid7)",
      "comment": "I put an `if PY314:` guard around registering the function instead.",
      "comment_id": 2608356932,
      "user": "LilyFirefly",
      "created_at": "2025-12-10T21:57:46Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608356932"
    },
    {
      "repo": "django/django",
      "pr_number": 20101,
      "file_path": "django/contrib/postgres/functions.py",
      "line": 5,
      "side": "LEFT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n-from django.db.models import DateTimeField, Func, UUIDField\n+import warnings\n \n+from django.db.models import DateTimeField, Func\n+from django.db.models.functions import UUID4\n+from django.utils.deprecation import RemovedInDjango70Warning, django_file_prefixes\n \n-class RandomUUID(Func):\n-    template = \"GEN_RANDOM_UUID()\"",
      "comment": "This is moot since I've removed the deprecation, but otherwise a good point.",
      "comment_id": 2608364593,
      "user": "LilyFirefly",
      "created_at": "2025-12-10T21:59:59Z",
      "url": "https://github.com/django/django/pull/20101#discussion_r2608364593"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/models/fields/json.py",
      "line": 416,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,6 +373,69 @@ class JSONIContains(CaseInsensitiveMixin, lookups.IContains):\n     pass\n \n \n+class JSONIn(lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(\n+            compiler,\n+            connection,\n+            sql,\n+            param,\n+        )\n+        if (\n+            not hasattr(param, \"as_sql\")\n+            and not connection.features.has_native_json_field\n+        ):\n+            if connection.vendor == \"oracle\":\n+                value = json.loads(param)\n+                sql = \"%s(JSON_OBJECT('value' VALUE %%s FORMAT JSON), '$.value')\"\n+                if isinstance(value, (list, dict)):\n+                    sql %= \"JSON_QUERY\"\n+                else:\n+                    sql %= \"JSON_VALUE\"\n+            elif connection.vendor == \"mysql\" or (\n+                connection.vendor == \"sqlite\"\n+                and params[0] not in connection.ops.jsonfield_datatype_values\n+            ):\n+                sql = \"JSON_EXTRACT(%s, '$')\"\n+        if connection.vendor == \"mysql\" and connection.mysql_is_mariadb:\n+            sql = \"JSON_UNQUOTE(%s)\" % sql\n+        return sql, params\n+\n+    def process_lhs(self, compiler, connection):\n+        sql, params = super().process_lhs(compiler, connection)\n+        if isinstance(self.lhs, KeyTransform):\n+            return sql, params\n+        if connection.vendor in \"mysql\":\n+            sql = \"JSON_EXTRACT(%s, '$')\" % sql\n+        elif connection.vendor == \"oracle\":\n+            if connection.features.supports_primitives_in_json_field:\n+                template = (\n+                    \"COALESCE(\"\n+                    \"JSON_VALUE(%s, '$'),\"\n+                    \"JSON_QUERY(%s, '$' DISALLOW SCALARS)\"\n+                    \")\"",
      "comment": "This looks subtly different from the logic in `KeyTransform.as_oracle`. Can you share more about how you derived this code, or why we wouldn't factor out the duplication?",
      "comment_id": 2477965161,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-30T12:46:14Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2477965161"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/models/fields/json.py",
      "line": 416,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,6 +373,69 @@ class JSONIContains(CaseInsensitiveMixin, lookups.IContains):\n     pass\n \n \n+class JSONIn(lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(\n+            compiler,\n+            connection,\n+            sql,\n+            param,\n+        )\n+        if (\n+            not hasattr(param, \"as_sql\")\n+            and not connection.features.has_native_json_field\n+        ):\n+            if connection.vendor == \"oracle\":\n+                value = json.loads(param)\n+                sql = \"%s(JSON_OBJECT('value' VALUE %%s FORMAT JSON), '$.value')\"\n+                if isinstance(value, (list, dict)):\n+                    sql %= \"JSON_QUERY\"\n+                else:\n+                    sql %= \"JSON_VALUE\"\n+            elif connection.vendor == \"mysql\" or (\n+                connection.vendor == \"sqlite\"\n+                and params[0] not in connection.ops.jsonfield_datatype_values\n+            ):\n+                sql = \"JSON_EXTRACT(%s, '$')\"\n+        if connection.vendor == \"mysql\" and connection.mysql_is_mariadb:\n+            sql = \"JSON_UNQUOTE(%s)\" % sql\n+        return sql, params\n+\n+    def process_lhs(self, compiler, connection):\n+        sql, params = super().process_lhs(compiler, connection)\n+        if isinstance(self.lhs, KeyTransform):\n+            return sql, params\n+        if connection.vendor in \"mysql\":\n+            sql = \"JSON_EXTRACT(%s, '$')\" % sql\n+        elif connection.vendor == \"oracle\":\n+            if connection.features.supports_primitives_in_json_field:\n+                template = (\n+                    \"COALESCE(\"\n+                    \"JSON_VALUE(%s, '$'),\"\n+                    \"JSON_QUERY(%s, '$' DISALLOW SCALARS)\"\n+                    \")\"",
      "comment": "I factored out the duplication. LMKWYT!\r\n\r\n(The code was derived taking inspiration from `KeyTransform.as_{vendor}` methods, replacing JSON paths with the root path for JSON `Col`s.)",
      "comment_id": 2479215592,
      "user": "cliffordgama",
      "created_at": "2025-10-30T19:02:49Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2479215592"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "@jacobtylerwalls you were right about there being no way to extract a JSON scalar `null` value in Oracle. Oracle's JSON/SQL functions will convert it to SQL NULL. The way key transform exact handles this is by changing `__key__exact=JSONNull()` to \"does the JSON value have the key and is the key NULL. https://github.com/django/django/blob/main/django/db/models/fields/json.py#L594-L597\n\nPerhaps a potential hack in this case would be to rewrite the `IN` clause as an `OR` chain, for example replacing\n`IN (v1, v2, \u2026)` with\n`JSON_EQUAL(..., v1) OR JSON_EQUAL(..., v2) OR ...` although I'm not sure if it's worth it or not. \n\n",
      "comment_id": 2479337244,
      "user": "cliffordgama",
      "created_at": "2025-10-30T19:53:12Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2479337244"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "Cool. I'll sit with this, but at a glance yeah a skip looks better than a feature flag for this.\n\n> rewrite the IN clause as an OR chain\n\nThat seems akin to what we did with composite pk's but I agree would be pretty overkill for a niche use case. Happy to skip as you suggest here.",
      "comment_id": 2479579117,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-30T21:29:44Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2479579117"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/models/fields/json.py",
      "line": 382,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,16 +373,106 @@ class JSONIContains(CaseInsensitiveMixin, lookups.IContains):\n     pass\n \n \n+class ProcessJSONLHSMixin:\n+    def _get_json_path(self, connection, key_transforms):\n+        if key_transforms is None:\n+            json_path = \"$\"\n+        else:\n+            json_path = connection.ops.compile_json_path(key_transforms)\n+        return json_path",
      "comment": "```suggestion\n        if key_transforms is None:\n            return \"$\"\n        return connection.ops.compile_json_path(key_transforms)\n```",
      "comment_id": 2480388626,
      "user": "cliffordgama",
      "created_at": "2025-10-31T07:33:28Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2480388626"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1021,
      "side": "RIGHT",
      "diff_hunk": "@@ -1010,6 +1010,19 @@ def test_key_iexact(self):\n             NullableJSONModel.objects.filter(value__foo__iexact='\"BaR\"').exists(), False\n         )\n \n+    def test_in(self):\n+        tests = [\n+            ([[]], [self.objs[1]]),\n+            ([{}], [self.objs[2]]),\n+            ([{\"a\": \"b\", \"c\": 14}], [self.objs[3]]),\n+            ([[1, [2]]], [self.objs[5]]),\n+        ]\n+        for lookup_value, expected in tests:\n+            with self.subTest(value__in=lookup_value), transaction.atomic():",
      "comment": "I saw that Simon added it for `test__key__in` in 089deb82b9ac2d002af36fd36f288368cdac4b53 (seemingly intentionally? there is no comment), and I thought that maybe it is needed to isolate failures, say in the event of a database error. I'm not too sure, tho'.",
      "comment_id": 2482867388,
      "user": "cliffordgama",
      "created_at": "2025-10-31T22:56:13Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2482867388"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1021,
      "side": "RIGHT",
      "diff_hunk": "@@ -1010,6 +1010,19 @@ def test_key_iexact(self):\n             NullableJSONModel.objects.filter(value__foo__iexact='\"BaR\"').exists(), False\n         )\n \n+    def test_in(self):\n+        tests = [\n+            ([[]], [self.objs[1]]),\n+            ([{}], [self.objs[2]]),\n+            ([{\"a\": \"b\", \"c\": 14}], [self.objs[3]]),\n+            ([[1, [2]]], [self.objs[5]]),\n+        ]\n+        for lookup_value, expected in tests:\n+            with self.subTest(value__in=lookup_value), transaction.atomic():",
      "comment": "> maybe it is needed to isolate failures\r\n\r\nAh, maybe. But then this would fall more on the side of _debugging code_ then? I think we can remove it here.",
      "comment_id": 2488387985,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-04T01:53:53Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2488387985"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "I also struggled with that, and that explains why I played with `__in=[JSONNull(), None]` -- all I wanted was a second parameter, and `None` was the easiest thing to provide. (But now I see an issue with providing `None` there is that the behavior isn't the same on all backends, so let's remove it.)  I think it would be better to use `JSONObject(k=Value(\"v\")` for now. \r\n\r\nIf you think there is a separate issue here where we can improve handling of list/dict params we should probably get a new ticket triaged for it and evaluate it on each backend.\r\n\r\nI also think I'm missing a `clone = self.rhs.copy()` before mutating the source expressions.",
      "comment_id": 2494543502,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-05T13:39:15Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2494543502"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "I do see this now with `JSONObject`:\r\n\r\n> django.db.utils.DatabaseError: ORA-22848: cannot use NCLOB type as comparison key\r\nHelp: https://docs.oracle.com/error-help/db/ora-22848/\r\n\r\nDo you have an idea about this?",
      "comment_id": 2494562062,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-05T13:42:48Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2494562062"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "> Do you have an idea about this?\r\n\r\nI will look into it \ud83d\udc4d\ud83c\udffe ",
      "comment_id": 2494598393,
      "user": "cliffordgama",
      "created_at": "2025-11-05T13:50:26Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2494598393"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "Grepping for the NCLOB stuff, I see this `== \"TextField\"` that maybe should be `in [\"TextField\", \"JSONField\"]`?\r\n\r\nhttps://github.com/django/django/blob/6d4d99b3cef4a6d931de02f89a493fb345dc438e/django/db/models/functions/comparison.py#L88-L91",
      "comment_id": 2500562079,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-06T19:39:52Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2500562079"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "> Grepping for the NCLOB stuff, I see this == \"TextField\" that maybe should be in [\"TextField\", \"JSONField\"]?\r\n\r\nI'd say yes, since Django saves `JSONField` as NCLOB on Oracle, although given how strict Oracle is with LOBs we'd probably want to add a few extra tests to ensure that nothing breaks?\r\n\r\n> I do see this now with `JSONObject`:\r\n\r\nFrom a glance at the queries, I think it's because `JSONObject` is explicitly `RETURNING CLOB` and LOB cannot be used for comparison. Although I'm not sure that we want to add support for `JSONObject()` seeing as there are no tests related to `JSONField`?",
      "comment_id": 2508344373,
      "user": "cliffordgama",
      "created_at": "2025-11-09T21:47:30Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2508344373"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "Hello, @jacobtylerwalls \ud83d\udc4b\ud83c\udffe \r\n\r\nRE: your `as_oracle` to allow \"OR ... IS NULL\"\r\n\r\nI struggled to make it work in a way I was happy with. For context, the following are some specific things that I had to take into account.\r\n1. The `IS NULL` check is not the same for top-level `JSONField` and for keys, (which were overlooked). To make sure a key truly has \"null\" as a value, we need to first perform a `JSON_EXISTS` (`__haskey` lookup) on the key and then do a `JSON_VALUE(...) IS NULL` (`__isnull`). This is because `JSON_VALUE(..) IS NULL` will also be true for nonexistent keys.\r\n3. Because of the above, we also have to handle `None` values (at least when lhs is a keytransform), since they are synonymous with `JSONNull()` inside an array or json document.\r\n4. `JSON_VALUE(...)` is fine for the case when what the LHS returns is a JSON scalar value, otherwise we have to use `JSON_QUERY(...)` using `COALESCE(...)` as is done when processing other oracle lhs in these lookups.\r\n5. As you identified in the patch, we need to handle cases when `JSONNull()/None` may be the only values in the iterable rhs.\r\n\r\nGiven that this is non-trivial, can we skip the test on oracle for now and follow up with this in a separate work, if we choose to follow up? If so, I'd like to try chaining `OR` instead of doing an `IN () OR ... IS NULL` in a follow up.\r\n\r\n(RE: The extra commit:\r\n\r\nThinking of an alternative solution \ud83e\udd14. Do you have any idea why `FieldGetDbPrepValueIterableMixin` does not call any `get_db_prep_value()` despite its name seemingly promising that it will? ... I understand values are already \"prepped\" by the time they are wrapped in `ExpressionList`, but this doesn't mean much for JSONField since it doesn't override `get_prep_value()`...)",
      "comment_id": 2511974291,
      "user": "cliffordgama",
      "created_at": "2025-11-10T21:08:15Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2511974291"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "> Given that this is non-trivial, can we skip the test on oracle for now and follow up with this in a separate work, if we choose to follow up? If so, I'd like to try chaining OR instead of doing an IN () OR ... IS NULL in a follow up.\r\n\r\nFor sure. This is getting pretty baroque. Let's wait until someone needs it. Thanks for giving it a look though.",
      "comment_id": 2512145486,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-10T22:14:42Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2512145486"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/models/lookups.py",
      "line": 309,
      "side": "RIGHT",
      "diff_hunk": "@@ -304,11 +304,9 @@ def get_prep_lookup(self):\n         if contains_expr:\n             return ExpressionList(\n                 *[\n-                    # Expression defaults `str` to field references while\n-                    # lookups default them to literal values.\n                     (\n                         Value(prep_value, self.lhs.output_field)\n-                        if isinstance(prep_value, str)\n+                        if not hasattr(prep_value, \"as_sql\")",
      "comment": "Can you say more about how you worked out this should check for compilables and not resolvables? I get no failures when I change this to `\"resolve_expression\"`.",
      "comment_id": 2519512397,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-12T19:21:26Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2519512397"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "> Do you have any idea why FieldGetDbPrepValueIterableMixin does not call any get_db_prep_value() despite its name seemingly promising that it will?\r\n\r\nIt inherits from `FieldGetDbPrepValueMixin`, which does provide a `get_db_prep_lookup()` that calls `get_db_prep_value()`, looks relevant?\r\n",
      "comment_id": 2519527706,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-12T19:27:29Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2519527706"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/models/lookups.py",
      "line": 309,
      "side": "RIGHT",
      "diff_hunk": "@@ -304,11 +304,9 @@ def get_prep_lookup(self):\n         if contains_expr:\n             return ExpressionList(\n                 *[\n-                    # Expression defaults `str` to field references while\n-                    # lookups default them to literal values.\n                     (\n                         Value(prep_value, self.lhs.output_field)\n-                        if isinstance(prep_value, str)\n+                        if not hasattr(prep_value, \"as_sql\")",
      "comment": "That was a mistake, it should check for resolvables instead. Thanks.",
      "comment_id": 2526149643,
      "user": "cliffordgama",
      "created_at": "2025-11-14T07:31:07Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2526149643"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "The issue is that once an iterable RHS is wrapped in `ExpressionList`, its elements become expressions, so `get_db_prep_value()` is no longer called for literal values.\r\n\r\n>  looks relevant?\r\n\r\nI thought `get_db_prep_lookup()` might help, but it can\u2019t, because the RHS has already been turned into expressions by the time that method runs.\r\n\r\nUsing `Value(..., output_field=...)` ensures that `get_db_prep_value()` [is applied to every value](https://github.com/django/django/blob/0eec2a163a4b2ea4e82c53ae1d7b71bf43ac911d/django/db/models/expressions.py#L1171) in the RHS.",
      "comment_id": 2526227582,
      "user": "cliffordgama",
      "created_at": "2025-11-14T07:47:34Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2526227582"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/models/lookups.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -287,33 +287,26 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n     def get_prep_lookup(self):\n         if hasattr(self.rhs, \"resolve_expression\"):\n             return self.rhs\n-        contains_expr = False\n+        if any(hasattr(value, \"resolve_expression\") for value in self.rhs):\n+            return ExpressionList(",
      "comment": "We can return early since direct values will be prepped at compilation time by `Value.as_sql()`; there's no need to prep them here.",
      "comment_id": 2526242219,
      "user": "cliffordgama",
      "created_at": "2025-11-14T07:51:29Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2526242219"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,6 +127,9 @@ def django_test_skips(self):\n             \"Oracle doesn't support casting filters to NUMBER.\": {\n                 \"lookup.tests.LookupQueryingTests.test_aggregate_combined_lookup\",\n             },\n+            \"Oracle doesn't support JSON null scalar extraction for IN queries\": {\n+                \"model_fields.test_jsonfield.JSONNullTests.test_filter_in\"\n+            },",
      "comment": "> This is getting pretty baroque. Let's wait until someone needs it.\r\n\r\n@jacobtylerwalls I decided to give it another shot with fresh eyes. It seems like the logic becomes simplified if we just `exact` and chain everything instead of special-casing `JSONNull()` alone.\r\n",
      "comment_id": 2598600249,
      "user": "cliffordgama",
      "created_at": "2025-12-08T13:14:10Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2598600249"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/models/lookups.py",
      "line": 298,
      "side": "RIGHT",
      "diff_hunk": "@@ -287,33 +287,26 @@ class FieldGetDbPrepValueIterableMixin(FieldGetDbPrepValueMixin):\n     def get_prep_lookup(self):\n         if hasattr(self.rhs, \"resolve_expression\"):\n             return self.rhs\n-        contains_expr = False\n+        if any(hasattr(value, \"resolve_expression\") for value in self.rhs):\n+            return ExpressionList(\n+                *[\n+                    (\n+                        value\n+                        if hasattr(value, \"resolve_expression\")\n+                        else Value(value, self.lhs.output_field)",
      "comment": "Somewhere in this vicinity we might keep the comment \"an expression will be handled by the database...\"",
      "comment_id": 2603509196,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-09T16:57:02Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2603509196"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "django/db/models/fields/json.py",
      "line": 476,
      "side": "RIGHT",
      "diff_hunk": "@@ -375,16 +375,121 @@ class JSONIContains(CaseInsensitiveMixin, lookups.IContains):\n     pass\n \n \n+class ProcessJSONLHSMixin:\n+    def _get_json_path(self, connection, key_transforms):\n+        if key_transforms is None:\n+            return \"$\"\n+        return connection.ops.compile_json_path(key_transforms)\n+\n+    def _process_as_oracle(self, sql, params, connection, key_transforms=None):\n+        json_path = self._get_json_path(connection, key_transforms)\n+        if connection.features.supports_primitives_in_json_field:\n+            template = (\n+                \"COALESCE(\"\n+                \"JSON_VALUE(%s, q'\\uffff%s\\uffff'),\"\n+                \"JSON_QUERY(%s, q'\\uffff%s\\uffff' DISALLOW SCALARS)\"\n+                \")\"\n+            )\n+        else:\n+            template = (\n+                \"COALESCE(\"\n+                \"JSON_QUERY(%s, q'\\uffff%s\\uffff'),\"\n+                \"JSON_VALUE(%s, q'\\uffff%s\\uffff')\"\n+                \")\"\n+            )\n+        # Add paths directly into SQL because path expressions cannot be passed\n+        # as bind variables on Oracle. Use a custom delimiter to prevent the\n+        # JSON path from escaping the SQL literal. Each key in the JSON path is\n+        # passed through json.dumps() with ensure_ascii=True (the default),\n+        # which converts the delimiter into the escaped \\uffff format. This\n+        # ensures that the delimiter is not present in the JSON path.\n+        sql = template % ((sql, json_path) * 2)\n+        return sql, params * 2\n+\n+    def _process_as_sqlite(self, sql, params, connection, key_transforms=None):\n+        json_path = self._get_json_path(connection, key_transforms)\n+        datatype_values = \",\".join(\n+            [repr(value) for value in connection.ops.jsonfield_datatype_values]\n+        )\n+        return (\n+            \"(CASE WHEN JSON_TYPE(%s, %%s) IN (%s) \"\n+            \"THEN JSON_TYPE(%s, %%s) ELSE JSON_EXTRACT(%s, %%s) END)\"\n+        ) % (sql, datatype_values, sql, sql), (*params, json_path) * 3\n+\n+    def _process_as_mysql(self, sql, params, connection, key_transforms=None):\n+        json_path = self._get_json_path(connection, key_transforms)\n+        return \"JSON_EXTRACT(%s, %%s)\" % sql, (*params, json_path)\n+\n+\n+class JSONIn(ProcessJSONLHSMixin, lookups.In):\n+    def resolve_expression_parameter(self, compiler, connection, sql, param):\n+        sql, params = super().resolve_expression_parameter(\n+            compiler,\n+            connection,\n+            sql,\n+            param,\n+        )\n+        if not connection.features.has_native_json_field and (\n+            not hasattr(param, \"as_sql\") or isinstance(param, expressions.Value)\n+        ):\n+            if connection.vendor == \"oracle\":\n+                value = param.value if hasattr(param, \"value\") else json.loads(param)\n+                sql = \"%s(JSON_OBJECT('value' VALUE %%s FORMAT JSON), '$.value')\"\n+                if isinstance(value, (list, dict)):\n+                    sql %= \"JSON_QUERY\"\n+                else:\n+                    sql %= \"JSON_VALUE\"\n+            elif connection.vendor == \"mysql\" or (\n+                connection.vendor == \"sqlite\"\n+                and params[0] not in connection.ops.jsonfield_datatype_values\n+            ):\n+                sql = \"JSON_EXTRACT(%s, '$')\"\n+        if connection.vendor == \"mysql\" and connection.mysql_is_mariadb:\n+            sql = \"JSON_UNQUOTE(%s)\" % sql\n+        return sql, params\n+\n+    def process_lhs(self, compiler, connection):\n+        sql, params = super().process_lhs(compiler, connection)\n+        if isinstance(self.lhs, KeyTransform):\n+            return sql, params\n+        if connection.vendor == \"mysql\":\n+            return self._process_as_mysql(sql, params, connection)\n+        elif connection.vendor == \"oracle\":\n+            return self._process_as_oracle(sql, params, connection)\n+        elif connection.vendor == \"sqlite\":\n+            return self._process_as_sqlite(sql, params, connection)\n+        return sql, params\n+\n+    def as_oracle(self, compiler, connection):\n+        if (\n+            connection.features.supports_primitives_in_json_field\n+            and isinstance(self.rhs, expressions.ExpressionList)\n+            and JSONNull() in self.rhs.get_source_expressions()\n+        ):\n+            exact_lookup = self.lhs.get_lookup(\"exact\")\n+            sql_parts = []\n+            all_params = ()\n+            for expr in self.rhs.get_source_expressions():\n+                lookup = exact_lookup(self.lhs, expr)\n+                sql, params = lookup.as_oracle(compiler, connection)\n+                sql_parts.append(f\"({sql})\")\n+                all_params += params",
      "comment": "Let's avoid the `+` and favor `*`, given how much trouble we've had with `TypeError` for tuple + list. It *shouldn't* be an issue now, but who knows what subclasses are doing in the wild...",
      "comment_id": 2603519947,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-09T17:00:16Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2603519947"
    },
    {
      "repo": "django/django",
      "pr_number": 20009,
      "file_path": "tests/model_fields/test_jsonfield.py",
      "line": 1329,
      "side": "RIGHT",
      "diff_hunk": "@@ -1297,6 +1322,22 @@ def test_filter(self):\n             NullableJSONModel.objects.filter(value__isnull=True), [sql_null]\n         )\n \n+    def test_filter_in(self):\n+        obj = NullableJSONModel.objects.create(value=JSONNull())\n+        obj2 = NullableJSONModel.objects.create(value=[1])\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__in=[JSONNull(), [1], \"foo\"]),",
      "comment": "Playing with this test case (using `In()` rather than `__in`) revealed ticket-36787, but we don't have to block on that here.",
      "comment_id": 2604162492,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-09T20:07:43Z",
      "url": "https://github.com/django/django/pull/20009#discussion_r2604162492"
    },
    {
      "repo": "django/django",
      "pr_number": 19993,
      "file_path": "tests/gis_tests/geoapp/tests.py",
      "line": 303,
      "side": "RIGHT",
      "diff_hunk": "@@ -269,6 +272,47 @@ def test_empty_geometries(self):\n             self.assertEqual(feature.geom.srid, g.srid)\n \n \n+class SaveLoadTests(TestCase):\n+    def test_multilinestringfield(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LineString((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+\n+    def test_multilinestring_with_linearring(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LinearRing((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[0].tuple, geom[0].tuple)\n+        # LinearRings are transformed to LineString.\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[1].tuple, geom[1].tuple)\n+\n+    def test_multipointfield(self):\n+        geom = MultiPoint(Point(1, 1), Point(0, 0))\n+        obj = Points.objects.create(geom=geom)",
      "comment": "It is a bug in MariaDB, see 5a2490a19d81f6f2666dd90ce79e5724b9a20a39.",
      "comment_id": 2458949436,
      "user": "felixxm",
      "created_at": "2025-10-24T05:33:29Z",
      "url": "https://github.com/django/django/pull/19993#discussion_r2458949436"
    },
    {
      "repo": "django/django",
      "pr_number": 19993,
      "file_path": "tests/gis_tests/geoapp/tests.py",
      "line": 303,
      "side": "RIGHT",
      "diff_hunk": "@@ -269,6 +272,47 @@ def test_empty_geometries(self):\n             self.assertEqual(feature.geom.srid, g.srid)\n \n \n+class SaveLoadTests(TestCase):\n+    def test_multilinestringfield(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LineString((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+\n+    def test_multilinestring_with_linearring(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LinearRing((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[0].tuple, geom[0].tuple)\n+        # LinearRings are transformed to LineString.\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[1].tuple, geom[1].tuple)\n+\n+    def test_multipointfield(self):\n+        geom = MultiPoint(Point(1, 1), Point(0, 0))\n+        obj = Points.objects.create(geom=geom)",
      "comment": "Any pointer about Oracle failure?\r\n```\r\nTraceback (most recent call last):\r\n  File \"/tests/gis_tests/geoapp/tests.py\", line 315, in test_geometrycollectionfield\r\n    self.assertEqual(obj.geom, geom)\r\n    ~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^\r\nAssertionError: <GeometryCollection object at 0x782e1769da40> != <GeometryCollection object at 0x782e1769dea0>\r\n```",
      "comment_id": 2467450335,
      "user": "timgraham",
      "created_at": "2025-10-27T23:35:53Z",
      "url": "https://github.com/django/django/pull/19993#discussion_r2467450335"
    },
    {
      "repo": "django/django",
      "pr_number": 19993,
      "file_path": "tests/gis_tests/geoapp/tests.py",
      "line": 303,
      "side": "RIGHT",
      "diff_hunk": "@@ -269,6 +272,47 @@ def test_empty_geometries(self):\n             self.assertEqual(feature.geom.srid, g.srid)\n \n \n+class SaveLoadTests(TestCase):\n+    def test_multilinestringfield(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LineString((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+\n+    def test_multilinestring_with_linearring(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LinearRing((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[0].tuple, geom[0].tuple)\n+        # LinearRings are transformed to LineString.\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[1].tuple, geom[1].tuple)\n+\n+    def test_multipointfield(self):\n+        geom = MultiPoint(Point(1, 1), Point(0, 0))\n+        obj = Points.objects.create(geom=geom)",
      "comment": "@felixxm ^^ can you speculate on the cause offhand? Some way that Oracle normalizes geometries perhaps?",
      "comment_id": 2562380114,
      "user": "timgraham",
      "created_at": "2025-11-26T01:34:55Z",
      "url": "https://github.com/django/django/pull/19993#discussion_r2562380114"
    },
    {
      "repo": "django/django",
      "pr_number": 19993,
      "file_path": "tests/gis_tests/geoapp/tests.py",
      "line": 303,
      "side": "RIGHT",
      "diff_hunk": "@@ -269,6 +272,47 @@ def test_empty_geometries(self):\n             self.assertEqual(feature.geom.srid, g.srid)\n \n \n+class SaveLoadTests(TestCase):\n+    def test_multilinestringfield(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LineString((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+\n+    def test_multilinestring_with_linearring(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LinearRing((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[0].tuple, geom[0].tuple)\n+        # LinearRings are transformed to LineString.\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[1].tuple, geom[1].tuple)\n+\n+    def test_multipointfield(self):\n+        geom = MultiPoint(Point(1, 1), Point(0, 0))\n+        obj = Points.objects.create(geom=geom)",
      "comment": "> @felixxm ^^ can you speculate on the cause offhand? Some way that Oracle normalizes geometries perhaps?\r\n\r\nTBH, I have no idea, but I can try to investigate it.",
      "comment_id": 2565342366,
      "user": "felixxm",
      "created_at": "2025-11-26T14:59:13Z",
      "url": "https://github.com/django/django/pull/19993#discussion_r2565342366"
    },
    {
      "repo": "django/django",
      "pr_number": 19993,
      "file_path": "tests/gis_tests/geoapp/tests.py",
      "line": 303,
      "side": "RIGHT",
      "diff_hunk": "@@ -269,6 +272,47 @@ def test_empty_geometries(self):\n             self.assertEqual(feature.geom.srid, g.srid)\n \n \n+class SaveLoadTests(TestCase):\n+    def test_multilinestringfield(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LineString((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+\n+    def test_multilinestring_with_linearring(self):\n+        geom = MultiLineString(\n+            LineString((0, 0), (1, 1), (5, 5)),\n+            LinearRing((0, 0), (0, 5), (5, 5), (5, 0), (0, 0)),\n+        )\n+        obj = Lines.objects.create(geom=geom)\n+        obj.refresh_from_db()\n+        self.assertEqual(obj.geom.tuple, geom.tuple)\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[0].tuple, geom[0].tuple)\n+        # LinearRings are transformed to LineString.\n+        self.assertEqual(obj.geom[1].__class__.__name__, \"LineString\")\n+        self.assertEqual(obj.geom[1].tuple, geom[1].tuple)\n+\n+    def test_multipointfield(self):\n+        geom = MultiPoint(Point(1, 1), Point(0, 0))\n+        obj = Points.objects.create(geom=geom)",
      "comment": "It seems that the database is reversing the direction of the polygon:\r\n\r\n> (Pdb) geom.wkt\r\n'GEOMETRYCOLLECTION (POINT (2 2), LINESTRING (0 0, 2 2), POLYGON ((0 0, 0 5, 5 5, 5 0, 0 0)))'\r\n(Pdb) obj.geom.wkt\r\n'GEOMETRYCOLLECTION (POINT (2 2), LINESTRING (0 0, 2 2), POLYGON ((0 0, 5 0, 5 5, 0 5, 0 0)))'\r\n\r\nWe could change the test to:\r\n\r\n```python\r\n        self.assertIs(obj.geom.equals(geom), True)\r\n```\r\n\r\nI think this is ok as there are other tests in the file which use `.equals()` method for comparing geometries?",
      "comment_id": 2603683934,
      "user": "smithdc1",
      "created_at": "2025-12-09T17:44:58Z",
      "url": "https://github.com/django/django/pull/19993#discussion_r2603683934"
    },
    {
      "repo": "django/django",
      "pr_number": 19993,
      "file_path": "tests/gis_tests/geoapp/models.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,3 +102,15 @@ class ManyPointModel(NamedModel):\n     point1 = models.PointField()\n     point2 = models.PointField()\n     point3 = models.PointField(srid=3857)\n+\n+\n+class Points(models.Model):\n+    geom = models.MultiPointField()\n+\n+\n+class Lines(models.Model):\n+    geom = models.MultiLineStringField()\n+\n+\n+class GeometryCollections(models.Model):",
      "comment": "Should this be singular and not plural? `GeometryCollections(geom=single_collection)` doesn't seem right, although I get `Lines(geom=lines)`.",
      "comment_id": 2604431680,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-09T21:29:07Z",
      "url": "https://github.com/django/django/pull/19993#discussion_r2604431680"
    },
    {
      "repo": "django/django",
      "pr_number": 19993,
      "file_path": "tests/gis_tests/geoapp/models.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,3 +102,15 @@ class ManyPointModel(NamedModel):\n     point1 = models.PointField()\n     point2 = models.PointField()\n     point3 = models.PointField(srid=3857)\n+\n+\n+class Points(models.Model):\n+    geom = models.MultiPointField()\n+\n+\n+class Lines(models.Model):\n+    geom = models.MultiLineStringField()\n+\n+\n+class GeometryCollections(models.Model):",
      "comment": "I didn't want to collide with `geos.GeometryCollection`. Could go with `GeometryCollectionModel`.",
      "comment_id": 2604549893,
      "user": "timgraham",
      "created_at": "2025-12-09T22:15:19Z",
      "url": "https://github.com/django/django/pull/19993#discussion_r2604549893"
    },
    {
      "repo": "django/django",
      "pr_number": 20370,
      "file_path": "django/core/files/base.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,26 +78,27 @@ def __iter__(self):\n         for chunk in self.chunks():\n             for line in chunk.splitlines(True):\n                 if buffer_:\n-                    if endswith_cr(buffer_) and not equals_lf(line):\n+                    if endswith_cr(buffer_[-1]) and not equals_lf(line):\n                         # Line split after a \\r newline; yield buffer_.\n-                        yield buffer_\n-                        # Continue with line.\n+                        yield type(buffer_[0])().join(buffer_)\n+                        buffer_ = None",
      "comment": "Let's try to keep the type consistent. Will require changes above & below.\n```suggestion\n                        buffer_ = []\n```",
      "comment_id": 2590154473,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-04T18:34:19Z",
      "url": "https://github.com/django/django/pull/20370#discussion_r2590154473"
    },
    {
      "repo": "django/django",
      "pr_number": 20086,
      "file_path": "django/contrib/admin/templatetags/base.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,11 +10,20 @@ class InclusionAdminNode(InclusionNode):\n     or globally.\n     \"\"\"\n \n-    def __init__(self, parser, token, func, template_name, takes_context=True):\n+    def __init__(self, name, parser, token, func, template_name, takes_context=True):\n         self.template_name = template_name\n         params, varargs, varkw, defaults, kwonly, kwonly_defaults, _ = getfullargspec(\n             func\n         )\n+        if takes_context:",
      "comment": "Thought: This pattern is used quite a bit in this file - should it be extracted into a function?",
      "comment_id": 2526810573,
      "user": "RealOrangeOne",
      "created_at": "2025-11-14T09:56:00Z",
      "url": "https://github.com/django/django/pull/20086#discussion_r2526810573"
    },
    {
      "repo": "django/django",
      "pr_number": 20086,
      "file_path": "django/template/library.py",
      "line": 423,
      "side": "RIGHT",
      "diff_hunk": "@@ -391,22 +412,13 @@ def parse_bits(\n     defaults,\n     kwonly,\n     kwonly_defaults,\n-    takes_context,\n     name,\n ):\n     \"\"\"\n     Parse bits for template tag helpers simple_tag and inclusion_tag, in\n     particular by detecting syntax errors and by extracting positional and\n     keyword arguments.",
      "comment": "Should we clarify here that `context` should already be popped?",
      "comment_id": 2589982688,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-04T17:34:59Z",
      "url": "https://github.com/django/django/pull/20086#discussion_r2589982688"
    },
    {
      "repo": "django/django",
      "pr_number": 20074,
      "file_path": "tests/model_fields/test_integerfield.py",
      "line": 201,
      "side": "LEFT",
      "diff_hunk": "@@ -198,7 +198,7 @@ def test_invalid_value(self):\n             (TypeError, {}),\n             (TypeError, set()),\n             (TypeError, object()),\n-            (TypeError, complex()),",
      "comment": "This was raising \"The database backend does not accept 0 as a value for AutoField\" for me on MySQL. `complex() == 0` is `True`. (`IntegerFieldTests` is subclassed by auto field test cases.)",
      "comment_id": 2510541734,
      "user": "cliffordgama",
      "created_at": "2025-11-10T13:16:34Z",
      "url": "https://github.com/django/django/pull/20074#discussion_r2510541734"
    },
    {
      "repo": "django/django",
      "pr_number": 20074,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 2851,
      "side": "RIGHT",
      "diff_hunk": "@@ -2810,10 +2810,13 @@ def validate(self, value, model_instance):\n         pass\n \n     def get_db_prep_value(self, value, connection, prepared=False):\n-        if not prepared:\n-            value = self.get_prep_value(value)\n-            value = connection.ops.validate_autopk_value(value)\n-        return value\n+        return value if prepared else self.get_prep_value(value)\n+\n+    def get_db_prep_save(self, value, connection):\n+        if hasattr(value, \"as_sql\"):\n+            return value\n+        value = connection.ops.validate_autopk_value(value)",
      "comment": "This no longer feeds get_prep_value() into validate_autopk_value(). Should we instead gather the result of `get_db_prep_value` and validate _that_?",
      "comment_id": 2586658762,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-03T21:26:44Z",
      "url": "https://github.com/django/django/pull/20074#discussion_r2586658762"
    },
    {
      "repo": "django/django",
      "pr_number": 20074,
      "file_path": "tests/model_fields/test_integerfield.py",
      "line": 201,
      "side": "LEFT",
      "diff_hunk": "@@ -198,7 +198,7 @@ def test_invalid_value(self):\n             (TypeError, {}),\n             (TypeError, set()),\n             (TypeError, object()),\n-            (TypeError, complex()),",
      "comment": "The original test with `complex()` passes with my suggestion to validate the prepped value.",
      "comment_id": 2586706569,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-03T21:43:00Z",
      "url": "https://github.com/django/django/pull/20074#discussion_r2586706569"
    },
    {
      "repo": "django/django",
      "pr_number": 19688,
      "file_path": "tests/admin_changelist/test_date_hierarchy.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,3 +95,11 @@ def test_invalid_params(self):\n                 self.assertRaises(IncorrectLookupParameters),\n             ):\n                 self.assertDateParams(invalid_query, None, None)\n+\n+    @override_settings(ROOT_URLCONF=\"admin_changelist.urls\")\n+    def test_label_in_hierarchy(self):\n+        self.client.force_login(self.superuser)\n+        Event.objects.create(date=datetime(2017, 1, 1))\n+        response = self.client.get(\"/admin/admin_changelist/event/\")",
      "comment": "I see there\u2019s other date_hierarchy tests elsewhere but this seems like the right place and right test. But - shouldn\u2019t this be using `reverse` rather than hard-coded URL like other tests?\n\n",
      "comment_id": 2588936250,
      "user": "thibaudcolas",
      "created_at": "2025-12-04T12:46:06Z",
      "url": "https://github.com/django/django/pull/19688#discussion_r2588936250"
    },
    {
      "repo": "django/django",
      "pr_number": 19688,
      "file_path": "tests/admin_changelist/test_date_hierarchy.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,3 +96,11 @@ def test_invalid_params(self):\n                 self.assertRaises(IncorrectLookupParameters),\n             ):\n                 self.assertDateParams(invalid_query, None, None)\n+\n+    @override_settings(ROOT_URLCONF=\"admin_changelist.urls\")\n+    def test_label_in_hierarchy(self):\n+        self.client.force_login(self.superuser)\n+        Event.objects.create(date=datetime(2017, 1, 1))\n+        response = self.client.get(reverse(\"admin:admin_changelist_event_changelist\"))\n+        self.assertEqual(response.status_code, 200)\n+        self.assertContains(response, \"Filter by\")",
      "comment": "I think instead of testing the template we could test that the view provided the dynamic content.",
      "comment_id": 2590577711,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-04T21:06:56Z",
      "url": "https://github.com/django/django/pull/19688#discussion_r2590577711"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,8 +34,32 @@ def end_object(self, obj):\n \n     def get_dump_object(self, obj):\n         data = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = True\n+\n+        if self.use_natural_primary_keys:\n+            natural_key_func = getattr(obj, \"natural_key\", None)\n+\n+            if callable(natural_key_func):\n+                natural_key_value = None\n+                try:\n+                    natural_key_value = natural_key_func()\n+                except Exception:\n+                    pass\n+\n+                is_opt_out = (\n+                    natural_key_value is None\n+                    or not natural_key_value\n+                    or natural_key_value == (obj.pk,)\n+                    or not isinstance(natural_key_value, tuple)\n+                )",
      "comment": "This handles a lot of variance. Can we just use implicit booleanness? (`not natural_key_value`). This whole block will likely become shorter.",
      "comment_id": 2441068956,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T19:46:27Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441068956"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,8 +34,32 @@ def end_object(self, obj):\n \n     def get_dump_object(self, obj):\n         data = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = True\n+\n+        if self.use_natural_primary_keys:\n+            natural_key_func = getattr(obj, \"natural_key\", None)\n+\n+            if callable(natural_key_func):\n+                natural_key_value = None\n+                try:\n+                    natural_key_value = natural_key_func()\n+                except Exception:\n+                    pass",
      "comment": "Let's remove the except (if the callable raises, that's not our problem).",
      "comment_id": 2441069386,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T19:46:41Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441069386"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,7 +81,16 @@ def handle_fk_field(self, obj, field):\n         ):\n             related = getattr(obj, field.name)\n             if related:\n-                value = related.natural_key()\n+                natural_key_value = related.natural_key()\n+\n+                is_opt_out = (natural_key_value is None) or (\n+                    natural_key_value == (related.pk,)\n+                )",
      "comment": "This isn't identical with the other check, where non-tuples or 0-tuples are handled.",
      "comment_id": 2441072154,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T19:48:17Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441072154"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,7 +53,32 @@ def start_object(self, obj):\n \n         self.indent(1)\n         attrs = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = True\n+\n+        if self.use_natural_primary_keys:",
      "comment": "The duplication here is starting to show that we should factor out a helper as I mused on the ticket :-)",
      "comment_id": 2441073531,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T19:49:09Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441073531"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,8 +34,32 @@ def end_object(self, obj):\n \n     def get_dump_object(self, obj):\n         data = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = True\n+\n+        if self.use_natural_primary_keys:\n+            natural_key_func = getattr(obj, \"natural_key\", None)\n+\n+            if callable(natural_key_func):\n+                natural_key_value = None\n+                try:\n+                    natural_key_value = natural_key_func()\n+                except Exception:\n+                    pass\n+\n+                is_opt_out = (\n+                    natural_key_value is None\n+                    or not natural_key_value\n+                    or natural_key_value == (obj.pk,)",
      "comment": "A 1-tuple of just `\"pk\"` feels like a little bit of a hack / contradiction. If we don't add support for this, then we can just use implicit booleanness (truthiness).",
      "comment_id": 2441075243,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T19:50:06Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441075243"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 140,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,12 +138,17 @@ def handle_fk_field(self, obj, field):\n             ):\n                 related = getattr(obj, field.name)\n                 # If related object has a natural key, use it\n-                related = related.natural_key()\n-                # Iterable natural keys are rolled out as subelements\n-                for key_value in related:\n-                    self.xml.startElement(\"natural\", {})\n-                    self.xml.characters(str(key_value))\n-                    self.xml.endElement(\"natural\")\n+                natural_key_value = related.natural_key()\n+                is_pk_tuple = natural_key_value == (related.pk,)\n+\n+                if natural_key_value is None or is_pk_tuple:\n+                    self.xml.characters(str(related_att))\n+                else:\n+                    # Iterable natural keys are rolled out as subelements\n+                    for key_value in natural_key_value:\n+                        self.xml.startElement(\"natural\", {})\n+                        self.xml.characters(str(key_value))\n+                        self.xml.endElement(\"natural\")\n             else:\n                 self.xml.characters(str(related_att))",
      "comment": "There's another `hasattr(..., \"natural_key\")` to update in `build_instance` in django/core/serializers.py.",
      "comment_id": 2441078639,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T19:51:50Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441078639"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,7 +81,16 @@ def handle_fk_field(self, obj, field):\n         ):\n             related = getattr(obj, field.name)\n             if related:\n-                value = related.natural_key()\n+                natural_key_value = related.natural_key()\n+\n+                is_opt_out = (natural_key_value is None) or (\n+                    natural_key_value == (related.pk,)\n+                )\n+\n+                if is_opt_out:\n+                    value = self._value_from_field(obj, field)\n+                else:\n+                    value = natural_key_value\n             else:\n                 value = None\n         else:",
      "comment": "There's a 3rd location in this file with a similar need (`handle_m2m_field`).",
      "comment_id": 2441081478,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T19:53:15Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441081478"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "tests/serializers/models/natural.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,3 +75,43 @@ class FKAsPKNoNaturalKey(models.Model):\n \n     def natural_key(self):\n         raise NotImplementedError(\"This method was not expected to be called.\")\n+\n+\n+class PKTupleOptOutUser(AbstractBaseUser):",
      "comment": "Let's replace these models with a single one using a 0-tuple. Suggest renaming the model to mention subclass, not the tuple detail.",
      "comment_id": 2441094991,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T20:00:18Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441094991"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "tests/serializers/test_natural.py",
      "line": 266,
      "side": "RIGHT",
      "diff_hunk": "@@ -250,6 +256,78 @@ def fk_as_pk_natural_key_not_called(self, format):\n         self.assertEqual(obj.object.pk, o1.pk)\n \n \n+def natural_key_opt_out_test(self, format):\n+    # Refs #35729\n+    \"\"\"\n+    Tests natural key opt-out scenarios for models inheriting\n+    from AbstractBaseUser.\n+\n+    Verifies that when natural_key() returns None or (self.pk,):\n+    \"\"\"",
      "comment": "This is a fun one: our coding style docs advises against \"tests...\" \"verifies that...\" [preambles](https://docs.djangoproject.com/en/5.2/internals/contributing/writing-code/coding-style/#:~:text=preambles%20such%20as%20%E2%80%9CTests%20that%E2%80%9D%20or%20%E2%80%9CEnsures%20that%E2%80%9D.).",
      "comment_id": 2441098431,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T20:02:06Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441098431"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "tests/serializers/test_natural.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -250,6 +256,78 @@ def fk_as_pk_natural_key_not_called(self, format):\n         self.assertEqual(obj.object.pk, o1.pk)\n \n \n+def natural_key_opt_out_test(self, format):\n+    # Refs #35729\n+    \"\"\"\n+    Tests natural key opt-out scenarios for models inheriting\n+    from AbstractBaseUser.\n+\n+    Verifies that when natural_key() returns None or (self.pk,):\n+    \"\"\"\n+\n+    user1 = PKTupleOptOutUser.objects.create(email=\"user1@example.com\")\n+    post1 = PostToPKTupleUser.objects.create(author=user1, title=\"Post 1 (PK Opt-out)\")\n+\n+    user2 = NoneOptOutUser.objects.create(email=\"user2@example.com\")\n+    post2 = PostToNoneUser.objects.create(author=user2, title=\"Post 2 (None Opt-out)\")\n+    scenarios = [\n+        (user1, post1),\n+        (user2, post2),\n+    ]\n+\n+    is_json = format == \"json\"\n+\n+    for user, post in scenarios:\n+        user_pk = user.pk\n+\n+        user_data_str = serializers.serialize(\n+            format, [user], indent=2, use_natural_primary_keys=True\n+        )\n+\n+        if is_json:\n+            user_data = json.loads(user_data_str)\n+            serialized_user = user_data[0]\n+\n+            self.assertEqual(\n+                serialized_user.get(\"pk\"),\n+                user_pk,\n+                f\"[{user.__class__.__name__}] PK must be included \"\n+                f\"in the primary object after patch.\",\n+            )\n+\n+        post_data_str = serializers.serialize(\n+            format,\n+            [post],\n+            indent=2,\n+            use_natural_foreign_keys=True,\n+        )\n+\n+        if is_json:\n+            post_data = json.loads(post_data_str)\n+            serialized_post = post_data[0]\n+\n+            self.assertEqual(\n+                serialized_post[\"fields\"][\"author\"],\n+                user_pk,\n+                f\"[{user.__class__.__name__}] FK must be serialized as PK integer\"\n+                f\", not a natural key list.\",\n+            )\n+\n+        try:\n+            list(serializers.deserialize(format, user_data_str))\n+        except Exception as e:\n+            self.fail(\n+                f\"Deserialization of {user.__class__.__name__} failed in {format}: {e}\"\n+            )",
      "comment": "We let exceptions escape naturally instead of `self.fail`ing. If you need additional messaging, use the last argument to `self.assert...`",
      "comment_id": 2441099917,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T20:02:50Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441099917"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "tests/serializers/test_natural.py",
      "line": 313,
      "side": "RIGHT",
      "diff_hunk": "@@ -250,6 +256,78 @@ def fk_as_pk_natural_key_not_called(self, format):\n         self.assertEqual(obj.object.pk, o1.pk)\n \n \n+def natural_key_opt_out_test(self, format):\n+    # Refs #35729\n+    \"\"\"\n+    Tests natural key opt-out scenarios for models inheriting\n+    from AbstractBaseUser.\n+\n+    Verifies that when natural_key() returns None or (self.pk,):\n+    \"\"\"\n+\n+    user1 = PKTupleOptOutUser.objects.create(email=\"user1@example.com\")\n+    post1 = PostToPKTupleUser.objects.create(author=user1, title=\"Post 1 (PK Opt-out)\")\n+\n+    user2 = NoneOptOutUser.objects.create(email=\"user2@example.com\")\n+    post2 = PostToNoneUser.objects.create(author=user2, title=\"Post 2 (None Opt-out)\")\n+    scenarios = [\n+        (user1, post1),\n+        (user2, post2),\n+    ]\n+\n+    is_json = format == \"json\"\n+\n+    for user, post in scenarios:\n+        user_pk = user.pk\n+\n+        user_data_str = serializers.serialize(\n+            format, [user], indent=2, use_natural_primary_keys=True\n+        )\n+\n+        if is_json:\n+            user_data = json.loads(user_data_str)\n+            serialized_user = user_data[0]\n+\n+            self.assertEqual(\n+                serialized_user.get(\"pk\"),\n+                user_pk,\n+                f\"[{user.__class__.__name__}] PK must be included \"\n+                f\"in the primary object after patch.\",\n+            )\n+\n+        post_data_str = serializers.serialize(\n+            format,\n+            [post],\n+            indent=2,\n+            use_natural_foreign_keys=True,\n+        )\n+\n+        if is_json:\n+            post_data = json.loads(post_data_str)\n+            serialized_post = post_data[0]\n+\n+            self.assertEqual(\n+                serialized_post[\"fields\"][\"author\"],\n+                user_pk,\n+                f\"[{user.__class__.__name__}] FK must be serialized as PK integer\"\n+                f\", not a natural key list.\",",
      "comment": "Only running these tests if `is_json` kind of cuts against the design of the surrounding tests, which test export & import instead of asserting on the exact output.\n\nWhile I like the explicitness of this, I wonder if it would \"blend in\" to demonstrate a roundtrip instead. This would involve demonstrating when deserializing that objects serialized with integer pk's instead of natural keys cause pk collisions when those integer pk's already exist, but not otherwise.",
      "comment_id": 2441121730,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T20:12:13Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2441121730"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,7 +53,32 @@ def start_object(self, obj):\n \n         self.indent(1)\n         attrs = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = True\n+\n+        if self.use_natural_primary_keys:",
      "comment": "Thanks for the suggestion!\r\nSince all format serializers are likely to follow that pattern,\r\nI'm planning to factor out the helper into `django/core/serializers/base.py` as a method of the base Serializer.\r\nDoes that location sound reasonable to you?",
      "comment_id": 2459797774,
      "user": "rimi0108",
      "created_at": "2025-10-24T10:55:48Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2459797774"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,8 +34,32 @@ def end_object(self, obj):\n \n     def get_dump_object(self, obj):\n         data = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = True\n+\n+        if self.use_natural_primary_keys:\n+            natural_key_func = getattr(obj, \"natural_key\", None)\n+\n+            if callable(natural_key_func):\n+                natural_key_value = None\n+                try:\n+                    natural_key_value = natural_key_func()\n+                except Exception:\n+                    pass\n+\n+                is_opt_out = (\n+                    natural_key_value is None\n+                    or not natural_key_value\n+                    or natural_key_value == (obj.pk,)",
      "comment": "I'd like to confirm the opt-out contract.\r\n\r\n```\r\nclass PKTupleOptOutUser(AbstractBaseUser):\r\n    email = models.EmailField(unique=False, null=True, blank=True)\r\n    USERNAME_FIELD = \"email\"\r\n    REQUIRED_FIELDS = []\r\n\r\n    class Manager(models.Manager):\r\n        def get_by_natural_key(self, pk_value):\r\n            return self.get(pk=pk_value)\r\n\r\n    objects = Manager()\r\n\r\n    def natural_key(self):\r\n        return (self.pk,)\r\n```\r\n\r\nWould it be correct to treat only returning a falsy value (such as None or an empty tuple ()) as the explicit opt-out signal, and not treat cases like (self.pk,) \u2014 as in the example above \u2014 as opt-out?",
      "comment_id": 2459927371,
      "user": "rimi0108",
      "created_at": "2025-10-24T11:30:03Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2459927371"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,8 +34,32 @@ def end_object(self, obj):\n \n     def get_dump_object(self, obj):\n         data = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = True\n+\n+        if self.use_natural_primary_keys:\n+            natural_key_func = getattr(obj, \"natural_key\", None)\n+\n+            if callable(natural_key_func):\n+                natural_key_value = None\n+                try:\n+                    natural_key_value = natural_key_func()\n+                except Exception:\n+                    pass\n+\n+                is_opt_out = (\n+                    natural_key_value is None\n+                    or not natural_key_value\n+                    or natural_key_value == (obj.pk,)",
      "comment": "That's right. As we progress the review, we might even remove support for `None`, since it could cause problems with uses like `.get_by_natural_key(*obj.natural_key())`.",
      "comment_id": 2461619895,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-24T18:35:10Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2461619895"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,8 +34,32 @@ def end_object(self, obj):\n \n     def get_dump_object(self, obj):\n         data = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = True\n+\n+        if self.use_natural_primary_keys:\n+            natural_key_func = getattr(obj, \"natural_key\", None)\n+\n+            if callable(natural_key_func):\n+                natural_key_value = None\n+                try:\n+                    natural_key_value = natural_key_func()\n+                except Exception:\n+                    pass\n+\n+                is_opt_out = (\n+                    natural_key_value is None\n+                    or not natural_key_value\n+                    or natural_key_value == (obj.pk,)",
      "comment": "Got it, that makes sense.\r\nI\u2019ll keep the current None handling for this PR, and we can revisit its removal in a follow-up change if needed!",
      "comment_id": 2463322746,
      "user": "rimi0108",
      "created_at": "2025-10-26T08:30:50Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2463322746"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/base.py",
      "line": 232,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,6 +209,29 @@ def getvalue(self):\n         if callable(getattr(self.stream, \"getvalue\", None)):\n             return self.stream.getvalue()\n \n+    def _should_include_pk(self, obj):\n+        \"\"\"\n+        Determines whether the Primary Key (PK) should be included in the\n+        serialized data for the given object, especially when\n+        use_natural_primary_keys=True is set.\n+        \"\"\"\n+        pk_included = True\n+\n+        if self.use_natural_primary_keys:\n+            natural_key_func = getattr(obj, \"natural_key\", None)\n+\n+            if callable(natural_key_func):\n+                natural_key_value = natural_key_func()\n+\n+                is_opt_out = not natural_key_value or not isinstance(\n+                    natural_key_value, tuple\n+                )\n+\n+                if not is_opt_out:\n+                    pk_included = False\n+",
      "comment": "Could this logic be flipped around and cleaned up w/ Demorgan's Law?\r\n\r\n```\r\nif callable(natural_key_func):\r\n    natural_key_value = natural_key_func()\r\n    if natural_key_value and isinstance(natural_key_value, tuple):\r\n        pk_included = False\r\n```",
      "comment_id": 2479716275,
      "user": "seanhelvey",
      "created_at": "2025-10-30T22:55:33Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2479716275"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/base.py",
      "line": 375,
      "side": "RIGHT",
      "diff_hunk": "@@ -317,12 +369,13 @@ def build_instance(Model, data, db):\n         obj = Model(**data)\n         obj._state.db = db\n         natural_key = obj.natural_key()\n-        try:\n-            data[Model._meta.pk.attname] = Model._meta.pk.to_python(\n-                default_manager.db_manager(db).get_by_natural_key(*natural_key).pk\n-            )\n-        except Model.DoesNotExist:\n-            pass\n+        if natural_key is not None:\n+            try:\n+                data[Model._meta.pk.attname] = Model._meta.pk.to_python(\n+                    default_manager.db_manager(db).get_by_natural_key(*natural_key).pk",
      "comment": "Maybe less complex if the value passed into to_python is processed first and then passed in?\r\n\r\n```\r\nobj = default_manager.db_manager(db).get_by_natural_key(*natural_key)\r\ndata[Model._meta.pk.attname] = Model._meta.pk.to_python(obj.pk)\r\n```",
      "comment_id": 2525223828,
      "user": "seanhelvey",
      "created_at": "2025-11-13T23:13:10Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2525223828"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/base.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,6 +209,54 @@ def getvalue(self):\n         if callable(getattr(self.stream, \"getvalue\", None)):\n             return self.stream.getvalue()\n \n+    def _should_include_pk(self, obj):\n+        \"\"\"\n+        Determines whether the Primary Key (PK) should be included in the\n+        serialized data for the given object, especially when\n+        use_natural_primary_keys=True is set.\n+        \"\"\"\n+        if not self.use_natural_primary_keys:\n+            return True\n+\n+        return not self._resolve_natural_key(obj)\n+\n+    def _resolve_fk_natural_key(self, obj, field):\n+        \"\"\"\n+        Return the natural key for a ForeignKey's related object when valid.\n+\n+        When natural foreign keys are enabled, the helper attempts to use the\n+        related object's natural key; otherwise it falls back to the PK.\n+        \"\"\"\n+        if not self.use_natural_foreign_keys:\n+            return None\n+\n+        if not self._model_supports_natural_key(field.remote_field.model):\n+            return None\n+\n+        related = getattr(obj, field.name, None)\n+        return self._resolve_natural_key(related)\n+\n+    def _resolve_natural_key(self, obj):\n+        \"\"\"\n+        Return a natural key tuple for the given object when available.\n+        \"\"\"\n+        if not (obj and callable(getattr(obj, \"natural_key\", None))):\n+            return None\n+\n+        natural_key_value = obj.natural_key()\n+        if self._is_natural_key_opt_out(natural_key_value):\n+            return None\n+\n+        return natural_key_value\n+\n+    def _is_natural_key_opt_out(self, natural_key_value):\n+        return not natural_key_value or not isinstance(natural_key_value, tuple)",
      "comment": "```suggestion\n        return not natural_key_value\n```\n\nLists worked before via duck-typing, so let's make sure we don't remove support.\n\nGiven that, you probably don't need this helper.",
      "comment_id": 2539329637,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T18:56:29Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539329637"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/base.py",
      "line": 369,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,20 +357,23 @@ def build_instance(Model, data, db):\n     \"\"\"\n     default_manager = Model._meta.default_manager\n     pk = data.get(Model._meta.pk.attname)\n+    natural_key_method = getattr(Model, \"natural_key\", None)\n     if (\n         pk is None\n         and hasattr(default_manager, \"get_by_natural_key\")\n-        and hasattr(Model, \"natural_key\")\n+        and callable(natural_key_method)\n     ):\n         obj = Model(**data)\n         obj._state.db = db\n         natural_key = obj.natural_key()\n-        try:\n-            data[Model._meta.pk.attname] = Model._meta.pk.to_python(\n-                default_manager.db_manager(db).get_by_natural_key(*natural_key).pk\n-            )\n-        except Model.DoesNotExist:\n-            pass\n+        if natural_key:",
      "comment": "Carrying over a thread from the last review, since we're not suggesting to support `None`, we don't have to touch these lines. Let's pursue that and revert the changes to these lines.",
      "comment_id": 2539425972,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T19:30:13Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539425972"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,43 +56,42 @@ def handle_field(self, obj, field):\n         self._current[field.name] = self._value_from_field(obj, field)\n \n     def handle_fk_field(self, obj, field):\n-        if self.use_natural_foreign_keys and hasattr(\n-            field.remote_field.model, \"natural_key\"\n-        ):\n-            related = getattr(obj, field.name)\n-            if related:\n-                value = related.natural_key()\n+        if self.use_natural_foreign_keys:\n+            natural_key_value = self._resolve_fk_natural_key(obj, field)\n+            if natural_key_value is not None:\n+                value = natural_key_value\n             else:\n-                value = None\n+                value = self._value_from_field(obj, field)",
      "comment": "I think this simplifies to the following since `_resolve_fk_natural_key()` also checks `self.use_natural_foreign_keys`:\n```suggestion\n        if natural_key_value := self._resolve_fk_natural_key(obj, field):\n            value = natural_key_value\n```",
      "comment_id": 2539481919,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T19:46:29Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539481919"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 156,
      "side": "LEFT",
      "diff_hunk": "@@ -133,36 +132,39 @@ def handle_m2m_field(self, obj, field):\n         \"\"\"\n         if field.remote_field.through._meta.auto_created:\n             self._start_relational_field(field)\n-            if self.use_natural_foreign_keys and hasattr(",
      "comment": "Can you reduce this diff by keeping the original if else branches and just replacing the first if with `if use_natural`?",
      "comment_id": 2539555687,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T20:06:03Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539555687"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 68,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,43 +56,42 @@ def handle_field(self, obj, field):\n         self._current[field.name] = self._value_from_field(obj, field)\n \n     def handle_fk_field(self, obj, field):\n-        if self.use_natural_foreign_keys and hasattr(\n-            field.remote_field.model, \"natural_key\"\n-        ):\n-            related = getattr(obj, field.name)\n-            if related:\n-                value = related.natural_key()\n+        if self.use_natural_foreign_keys:\n+            natural_key_value = self._resolve_fk_natural_key(obj, field)\n+            if natural_key_value is not None:\n+                value = natural_key_value\n             else:\n-                value = None\n+                value = self._value_from_field(obj, field)\n         else:\n             value = self._value_from_field(obj, field)\n         self._current[field.name] = value\n \n     def handle_m2m_field(self, obj, field):\n         if field.remote_field.through._meta.auto_created:\n-            if self.use_natural_foreign_keys and hasattr(\n-                field.remote_field.model, \"natural_key\"\n-            ):\n+            use_natural = (",
      "comment": "Same here, it would be helpful to mix in fewer refactors here. Let's keep the if/else branches as they were and only insert the changes you need.",
      "comment_id": 2539558074,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T20:06:36Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539558074"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,7 +53,10 @@ def start_object(self, obj):\n \n         self.indent(1)\n         attrs = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = self._should_include_pk(obj)\n+\n+        if pk_included:",
      "comment": "This method name is named well enough to just avoid the assignment:\n```suggestion\n        if self._should_include_pk(obj):\n```",
      "comment_id": 2539562562,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T20:07:42Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539562562"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,8 +34,12 @@ def end_object(self, obj):\n \n     def get_dump_object(self, obj):\n         data = {\"model\": str(obj._meta)}\n-        if not self.use_natural_primary_keys or not hasattr(obj, \"natural_key\"):\n+\n+        pk_included = self._should_include_pk(obj)\n+\n+        if pk_included:\n             data[\"pk\"] = self._value_from_field(obj, obj._meta.pk)\n+",
      "comment": "```suggestion\n        if pk_included := self._should_include_pk(obj):\n            data[\"pk\"] = self._value_from_field(obj, obj._meta.pk)\n```",
      "comment_id": 2539569451,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T20:08:59Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539569451"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "tests/serializers/test_natural.py",
      "line": 263,
      "side": "RIGHT",
      "diff_hunk": "@@ -250,6 +253,51 @@ def fk_as_pk_natural_key_not_called(self, format):\n         self.assertEqual(obj.object.pk, o1.pk)\n \n \n+def natural_key_opt_out_test(self, format):\n+    \"\"\"\n+    When a subclass of AbstractBaseUser opts out of natural key serialization\n+    by returning an empty tuple, both FK and M2M relations serialize as\n+    integer PKs and can be deserialized without error.\n+    \"\"\"\n+    user1 = SubclassNaturalKeyOptOutUser.objects.create(email=\"user2@example.com\")\n+    user2 = SubclassNaturalKeyOptOutUser.objects.create(email=\"user3@example.com\")",
      "comment": "left-hand side doesn't match the numbers in the email addresses.",
      "comment_id": 2539658297,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T20:41:27Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539658297"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/base.py",
      "line": 374,
      "side": "RIGHT",
      "diff_hunk": "@@ -309,20 +357,23 @@ def build_instance(Model, data, db):\n     \"\"\"\n     default_manager = Model._meta.default_manager\n     pk = data.get(Model._meta.pk.attname)\n+    natural_key_method = getattr(Model, \"natural_key\", None)\n     if (\n         pk is None\n         and hasattr(default_manager, \"get_by_natural_key\")\n-        and hasattr(Model, \"natural_key\")\n+        and callable(natural_key_method)\n     ):\n         obj = Model(**data)\n         obj._state.db = db\n         natural_key = obj.natural_key()\n-        try:\n-            data[Model._meta.pk.attname] = Model._meta.pk.to_python(\n-                default_manager.db_manager(db).get_by_natural_key(*natural_key).pk\n-            )\n-        except Model.DoesNotExist:\n-            pass\n+        if natural_key:\n+            try:\n+                existing = default_manager.db_manager(db).get_by_natural_key(\n+                    *natural_key\n+                )\n+                data[Model._meta.pk.attname] = Model._meta.pk.to_python(existing.pk)",
      "comment": "If we're taking the opportunity to factor this line out, then let's move it out of the `try` and under an `else`.",
      "comment_id": 2539681336,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T21:03:14Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539681336"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "tests/serializers/test_natural.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -250,6 +253,51 @@ def fk_as_pk_natural_key_not_called(self, format):\n         self.assertEqual(obj.object.pk, o1.pk)\n \n \n+def natural_key_opt_out_test(self, format):\n+    \"\"\"\n+    When a subclass of AbstractBaseUser opts out of natural key serialization\n+    by returning an empty tuple, both FK and M2M relations serialize as\n+    integer PKs and can be deserialized without error.\n+    \"\"\"\n+    user1 = SubclassNaturalKeyOptOutUser.objects.create(email=\"user2@example.com\")\n+    user2 = SubclassNaturalKeyOptOutUser.objects.create(email=\"user3@example.com\")\n+\n+    post = PostToOptOutSubclassUser.objects.create(\n+        author=user1, title=\"Post 2 (Subclass Opt-out)\"\n+    )\n+    post.subscribers.add(user1, user2)\n+\n+    user_data = serializers.serialize(format, [user1], use_natural_primary_keys=True)\n+    post_data = serializers.serialize(format, [post], use_natural_foreign_keys=True)\n+\n+    list(serializers.deserialize(format, user_data))\n+    deserialized_posts = list(serializers.deserialize(format, post_data))\n+\n+    post_obj = deserialized_posts[0].object\n+    self.assertEqual(user1.email, post_obj.author.email)\n+    self.assertEqual(\n+        sorted([user1.email, user2.email]),\n+        sorted(post_obj.subscribers.values_list(\"email\", flat=True)),\n+    )\n+\n+\n+def deserialize_natural_key_then_opted_out(self, format):\n+    \"\"\"\n+    Deserialization remains backward compatible:\n+    data serialized with natural keys continues to load correctly\n+    after the model opts out by returning empty tuple from natural_key().\n+    \"\"\"\n+    user = NaturalKeyOptOut.objects.create(name=\"example\")\n+    serialized = serializers.serialize(format, [user], use_natural_primary_keys=True)\n+\n+    def optout_natural_key(self):\n+        return ()\n+\n+    NaturalKeyOptOut.natural_key = optout_natural_key",
      "comment": "This test doesn't seem very realistic -- I don't think we want to set the expectation that you can change the natural key and load data you dumped before without problems. I think we can just remove it; then we don't have to worry about polishing this test. (I was about to suggest things like making sure state was restored after the test, since we're altering the class during the test, but it will be nice not to worry about that!)\n\nIf that leaves a coverage gap somewhere, let me know, and we can develop a different test.",
      "comment_id": 2539690375,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T21:10:40Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2539690375"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/xml_serializer.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,12 +130,19 @@ def handle_m2m_field(self, obj, field):\n         \"\"\"\n         if field.remote_field.through._meta.auto_created:\n             self._start_relational_field(field)\n-            if self.use_natural_foreign_keys and hasattr(\n-                field.remote_field.model, \"natural_key\"\n-            ):\n+\n+            use_natural = (\n+                self.use_natural_foreign_keys\n+                and self._model_supports_natural_key(field.remote_field.model)\n+            )\n+\n+            if use_natural:\n                 # If the objects in the m2m have a natural key, use it\n                 def handle_m2m(value):\n-                    natural = value.natural_key()\n+                    natural = self._resolve_natural_key(value)\n+                    if not natural:",
      "comment": "If we move this boolean test into your helper, then we can avoid adding this branch and ensure we aren't missing analogous changes for the `queryset_iterator` nested function.",
      "comment_id": 2582370428,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-02T18:30:52Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2582370428"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/base.py",
      "line": 228,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,6 +209,51 @@ def getvalue(self):\n         if callable(getattr(self.stream, \"getvalue\", None)):\n             return self.stream.getvalue()\n \n+    def _should_include_pk(self, obj):\n+        \"\"\"\n+        Determines whether the Primary Key (PK) should be included in the\n+        serialized data for the given object, especially when\n+        use_natural_primary_keys=True is set.\n+        \"\"\"\n+        if not self.use_natural_primary_keys:\n+            return True\n+\n+        return not self._resolve_natural_key(obj)\n+\n+    def _resolve_fk_natural_key(self, obj, field):\n+        \"\"\"\n+        Return the natural key for a ForeignKey's related object when valid.\n+\n+        When natural foreign keys are enabled, the helper attempts to use the\n+        related object's natural key; otherwise it falls back to the PK.",
      "comment": "I'm not seeing where this fallback behavior is implemented. I'll take a quick stab at simplifying the helpers a little further.",
      "comment_id": 2582486319,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-02T19:08:45Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2582486319"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/python.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,43 +56,42 @@ def handle_field(self, obj, field):\n         self._current[field.name] = self._value_from_field(obj, field)\n \n     def handle_fk_field(self, obj, field):\n-        if self.use_natural_foreign_keys and hasattr(\n-            field.remote_field.model, \"natural_key\"\n-        ):\n-            related = getattr(obj, field.name)\n-            if related:\n-                value = related.natural_key()\n+        if self.use_natural_foreign_keys:\n+            natural_key_value = self._resolve_fk_natural_key(obj, field)\n+            if natural_key_value is not None:\n+                value = natural_key_value\n             else:\n-                value = None\n+                value = self._value_from_field(obj, field)",
      "comment": "Thanks for implementing this simplification. What I'm now realizing is that we lack test cases for when natural keys are defined and `self.use_natural_foreign_keys` is False. To avoid having to add coverage for your helper where you check that condition, I'm just going to shuffle that responsibility back out of the helper so we can leave it where it was (and not have the responsibility for testing new added lines of code). Pardon me!",
      "comment_id": 2582599958,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-02T19:54:43Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2582599958"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/base.py",
      "line": 235,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,6 +209,31 @@ def getvalue(self):\n         if callable(getattr(self.stream, \"getvalue\", None)):\n             return self.stream.getvalue()\n \n+    def _resolve_fk_natural_key(self, obj, field):\n+        \"\"\"\n+        Return the natural key for a ForeignKey's related object, or None if\n+        not supported.\n+        \"\"\"\n+        if not self._model_supports_natural_key(field.remote_field.model):\n+            return None\n+\n+        related = getattr(obj, field.name, None)\n+        try:\n+            return related.natural_key()\n+        except AttributeError:\n+            return None\n+\n+    def _instance_supports_natural_key(self, obj):\n+        \"\"\"Return True if the instance defines a non-empty natural_key().\"\"\"\n+        try:\n+            return bool(obj.natural_key())\n+        except AttributeError:\n+            return False\n+\n+    def _model_supports_natural_key(self, model):\n+        \"\"\"Return True if the model defines a non-empty natural_key().\"\"\"\n+        return self._instance_supports_natural_key(model())",
      "comment": "I went too far. I now see why you needed to call `natural_key()` on each object during the many-to-many iterator. Will restore your helper for that. \ud83d\ude05 ",
      "comment_id": 2585419830,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-03T14:48:00Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2585419830"
    },
    {
      "repo": "django/django",
      "pr_number": 19919,
      "file_path": "django/core/serializers/base.py",
      "line": 235,
      "side": "RIGHT",
      "diff_hunk": "@@ -209,6 +209,31 @@ def getvalue(self):\n         if callable(getattr(self.stream, \"getvalue\", None)):\n             return self.stream.getvalue()\n \n+    def _resolve_fk_natural_key(self, obj, field):\n+        \"\"\"\n+        Return the natural key for a ForeignKey's related object, or None if\n+        not supported.\n+        \"\"\"\n+        if not self._model_supports_natural_key(field.remote_field.model):\n+            return None\n+\n+        related = getattr(obj, field.name, None)\n+        try:\n+            return related.natural_key()\n+        except AttributeError:\n+            return None\n+\n+    def _instance_supports_natural_key(self, obj):\n+        \"\"\"Return True if the instance defines a non-empty natural_key().\"\"\"\n+        try:\n+            return bool(obj.natural_key())\n+        except AttributeError:\n+            return False\n+\n+    def _model_supports_natural_key(self, model):\n+        \"\"\"Return True if the model defines a non-empty natural_key().\"\"\"\n+        return self._instance_supports_natural_key(model())",
      "comment": "Got it \u2014 thank you for all your help and guidance throughout this PR. \ud83d\ude0a",
      "comment_id": 2592128347,
      "user": "rimi0108",
      "created_at": "2025-12-05T10:11:30Z",
      "url": "https://github.com/django/django/pull/19919#discussion_r2592128347"
    },
    {
      "repo": "django/django",
      "pr_number": 20369,
      "file_path": "django/db/backends/postgresql/compiler.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,7 +29,8 @@ class SQLCompiler(BaseSQLCompiler):\n     def quote_name_unless_alias(self, name):\n         if \"$\" in name:\n             raise ValueError(\n-                \"Dollar signs are not permitted in column aliases on PostgreSQL.\"\n+                \"Dollar signs are not permitted in column aliases on \"\n+                f\"{self.connection.display_name}.\"\n             )\n         return super().quote_name_unless_alias(name)",
      "comment": "Now that we have a flag for this, I suppose we could just move this into the top of the method in the base class in `django/db/models/sql/compiler.py`?\n\n```python\n        if \"$\" in name and self.connection.features.prohibits_dollar_signs_in_column_aliases:\n            raise ValueError(\n                \"Dollar signs are not permitted in column aliases on \"\n                f\"{self.connection.display_name}.\"\n            )",
      "comment_id": 2588577393,
      "user": "ngnpope",
      "created_at": "2025-12-04T11:02:32Z",
      "url": "https://github.com/django/django/pull/20369#discussion_r2588577393"
    },
    {
      "repo": "django/django",
      "pr_number": 20369,
      "file_path": "django/db/backends/base/features.py",
      "line": 420,
      "side": "RIGHT",
      "diff_hunk": "@@ -415,6 +415,10 @@ class BaseDatabaseFeatures:\n     # Does the Round() database function round to even?\n     rounds_to_even = False\n \n+    # Should dollar signs be prohibited in column aliases to prevent SQL\n+    # injection?\n+    prohibits_dollar_signs_in_column_aliases = False",
      "comment": "Maybe `prohibits_dollar_char_in_column_aliases` or `prohibits_dollar_in_column_aliases`?",
      "comment_id": 2588583262,
      "user": "ngnpope",
      "created_at": "2025-12-04T11:04:00Z",
      "url": "https://github.com/django/django/pull/20369#discussion_r2588583262"
    },
    {
      "repo": "django/django",
      "pr_number": 20369,
      "file_path": "django/db/backends/base/features.py",
      "line": 420,
      "side": "RIGHT",
      "diff_hunk": "@@ -415,6 +415,10 @@ class BaseDatabaseFeatures:\n     # Does the Round() database function round to even?\n     rounds_to_even = False\n \n+    # Should dollar signs be prohibited in column aliases to prevent SQL\n+    # injection?\n+    prohibits_dollar_signs_in_column_aliases = False",
      "comment": "I think it's okay. It's called a dollar sign, not a dollar character. :-D",
      "comment_id": 2589449087,
      "user": "timgraham",
      "created_at": "2025-12-04T15:06:09Z",
      "url": "https://github.com/django/django/pull/20369#discussion_r2589449087"
    },
    {
      "repo": "django/django",
      "pr_number": 20329,
      "file_path": "django/test/runner.py",
      "line": 604,
      "side": "RIGHT",
      "diff_hunk": "@@ -579,38 +586,30 @@ def run(self, result):\n                 self.debug_mode,\n                 self.used_aliases,\n             ],\n-        )\n-        args = [\n-            (self.runner_class, index, subsuite, self.failfast, self.buffer)\n-            for index, subsuite in enumerate(self.subsuites)\n-        ]\n-        # Don't buffer in the main process to avoid error propagation issues.\n-        result.buffer = False\n-\n-        test_results = pool.imap_unordered(self.run_subsuite.__func__, args)\n-\n-        while True:\n-            if result.shouldStop:\n-                pool.terminate()\n-                break\n-\n-            try:\n-                subsuite_index, events = test_results.next(timeout=0.1)\n-            except multiprocessing.TimeoutError as err:\n-                if counter.value < 0:\n-                    err.add_note(\"ERROR: _init_worker failed, see prior traceback\")\n+        ) as pool:\n+            test_results = pool.imap_unordered(self.run_subsuite.__func__, args)\n+\n+            while True:\n+                if result.shouldStop:\n+                    pool.terminate()\n+                    break\n+\n+                try:\n+                    subsuite_index, events = test_results.next(timeout=0.1)\n+                except multiprocessing.TimeoutError as err:\n+                    if counter.value < 0:\n+                        err.add_note(\"ERROR: _init_worker failed, see prior traceback\")\n+                        raise\n+                    continue\n+                except StopIteration:",
      "comment": "I think we don't need the `pool.close()` on the line below this now.",
      "comment_id": 2582973946,
      "user": "LilyFirefly",
      "created_at": "2025-12-02T22:28:57Z",
      "url": "https://github.com/django/django/pull/20329#discussion_r2582973946"
    },
    {
      "repo": "django/django",
      "pr_number": 20329,
      "file_path": "django/test/runner.py",
      "line": 604,
      "side": "RIGHT",
      "diff_hunk": "@@ -579,38 +586,30 @@ def run(self, result):\n                 self.debug_mode,\n                 self.used_aliases,\n             ],\n-        )\n-        args = [\n-            (self.runner_class, index, subsuite, self.failfast, self.buffer)\n-            for index, subsuite in enumerate(self.subsuites)\n-        ]\n-        # Don't buffer in the main process to avoid error propagation issues.\n-        result.buffer = False\n-\n-        test_results = pool.imap_unordered(self.run_subsuite.__func__, args)\n-\n-        while True:\n-            if result.shouldStop:\n-                pool.terminate()\n-                break\n-\n-            try:\n-                subsuite_index, events = test_results.next(timeout=0.1)\n-            except multiprocessing.TimeoutError as err:\n-                if counter.value < 0:\n-                    err.add_note(\"ERROR: _init_worker failed, see prior traceback\")\n+        ) as pool:\n+            test_results = pool.imap_unordered(self.run_subsuite.__func__, args)\n+\n+            while True:\n+                if result.shouldStop:\n+                    pool.terminate()\n+                    break\n+\n+                try:\n+                    subsuite_index, events = test_results.next(timeout=0.1)\n+                except multiprocessing.TimeoutError as err:\n+                    if counter.value < 0:\n+                        err.add_note(\"ERROR: _init_worker failed, see prior traceback\")\n+                        raise\n+                    continue\n+                except StopIteration:",
      "comment": "I get the following when I try that (given that we only `break` and not `raise`):\r\n\r\n```py\r\n  File \"/Users/jwalls/django/django/test/runner.py\", line 611, in run\r\n    pool.join()\r\n    ~~~~~~~~~^^\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.14/lib/python3.14/multiprocessing/pool.py\", line 662, in join\r\n    raise ValueError(\"Pool is still running\")\r\nValueError: Pool is still running\r\n```",
      "comment_id": 2583021202,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-02T22:54:42Z",
      "url": "https://github.com/django/django/pull/20329#discussion_r2583021202"
    },
    {
      "repo": "django/django",
      "pr_number": 20182,
      "file_path": "tests/auth_tests/test_validators.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -202,24 +202,26 @@ def test_validate(self):\n         self.assertEqual(cm.exception.messages, [expected_error % \"username\"])\n         self.assertEqual(cm.exception.error_list[0].code, \"password_too_similar\")\n \n-        with self.assertRaises(ValidationError) as cm:\n+        msg = expected_error % \"email address\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n             UserAttributeSimilarityValidator().validate(\"example.com\", user=user)\n-        self.assertEqual(cm.exception.messages, [expected_error % \"email address\"])\n \n-        with self.assertRaises(ValidationError) as cm:\n+        msg = expected_error % \"first name\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n             UserAttributeSimilarityValidator(\n                 user_attributes=[\"first_name\"],\n                 max_similarity=0.3,\n             ).validate(\"testclient\", user=user)\n-        self.assertEqual(cm.exception.messages, [expected_error % \"first name\"])\n+",
      "comment": "Try not to introduce new newlines; it bloats the diff.",
      "comment_id": 2582715526,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-02T20:40:21Z",
      "url": "https://github.com/django/django/pull/20182#discussion_r2582715526"
    },
    {
      "repo": "django/django",
      "pr_number": 20182,
      "file_path": "tests/auth_tests/test_validators.py",
      "line": 215,
      "side": "RIGHT",
      "diff_hunk": "@@ -202,24 +202,26 @@ def test_validate(self):\n         self.assertEqual(cm.exception.messages, [expected_error % \"username\"])\n         self.assertEqual(cm.exception.error_list[0].code, \"password_too_similar\")\n \n-        with self.assertRaises(ValidationError) as cm:\n+        msg = expected_error % \"email address\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n             UserAttributeSimilarityValidator().validate(\"example.com\", user=user)\n-        self.assertEqual(cm.exception.messages, [expected_error % \"email address\"])\n \n-        with self.assertRaises(ValidationError) as cm:\n+        msg = expected_error % \"first name\"\n+        with self.assertRaisesMessage(ValidationError, msg):\n             UserAttributeSimilarityValidator(\n                 user_attributes=[\"first_name\"],\n                 max_similarity=0.3,\n             ).validate(\"testclient\", user=user)\n-        self.assertEqual(cm.exception.messages, [expected_error % \"first name\"])\n+",
      "comment": "done , removed the newline and also added a fullstop",
      "comment_id": 2584662143,
      "user": "Skyiesac",
      "created_at": "2025-12-03T11:03:05Z",
      "url": "https://github.com/django/django/pull/20182#discussion_r2584662143"
    },
    {
      "repo": "django/django",
      "pr_number": 19277,
      "file_path": "tests/bulk_create/models.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,3 +148,10 @@ class RelatedModel(models.Model):\n class DbDefaultModel(models.Model):\n     name = models.CharField(max_length=10)\n     created_at = models.DateTimeField(db_default=Now())\n+\n+\n+class DbDefaultPrimaryKey(models.Model):\n+    id = models.UUIDField(primary_key=True, db_default=Func(function=\"gen_random_uuid\"))\n+\n+    class Meta:\n+        required_db_vendor = \"postgresql\"",
      "comment": "The problem is not Postgres specific; use the following model instead\r\n\r\n```suggestion\r\nclass DbDefaultPrimaryKeyModel(models.Model):\r\n    id = models.DateTimeField(primary_key=True, db_default=Now())\r\n```",
      "comment_id": 1997775535,
      "user": "charettes",
      "created_at": "2025-03-16T23:53:32Z",
      "url": "https://github.com/django/django/pull/19277#discussion_r1997775535"
    },
    {
      "repo": "django/django",
      "pr_number": 19277,
      "file_path": "tests/bulk_create/tests.py",
      "line": 880,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,3 +869,12 @@ def test_db_default_field_excluded(self):\n             ctx[0][\"sql\"].count(created_at_quoted_name),\n             2 if connection.features.can_return_rows_from_bulk_insert else 1,\n         )\n+\n+    @unittest.skipUnless(connection.vendor == \"postgresql\", \"PostgreSQL specific SQL\")\n+    def test_db_default_primary_key(self):\n+        obj1, obj2 = DbDefaultPrimaryKey.objects.bulk_create(\n+            [DbDefaultPrimaryKey(), DbDefaultPrimaryKey()]\n+        )\n+        self.assertIsInstance(obj1.id, UUID)\n+        self.assertIsInstance(obj2.id, UUID)\n+        self.assertNotEqual(obj1.id, obj2.id)",
      "comment": "```suggestion\r\n    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\r\n    def test_db_default_primary_key(self):\r\n        (obj,) = DbDefaultPrimaryKeyModel.objects.bulk_create(\r\n            [DbDefaultPrimaryKeyModel()]\r\n        )\r\n        self.assertIsInstance(obj.id, datetime)\r\n```",
      "comment_id": 1997780377,
      "user": "charettes",
      "created_at": "2025-03-17T00:08:11Z",
      "url": "https://github.com/django/django/pull/19277#discussion_r1997780377"
    },
    {
      "repo": "django/django",
      "pr_number": 19277,
      "file_path": "django/db/models/base.py",
      "line": 688,
      "side": "RIGHT",
      "diff_hunk": "@@ -685,6 +685,7 @@ def _is_pk_set(self, meta=None):\n         pk_val = self._get_pk_val(meta)\n         return not (\n             pk_val is None\n+            or isinstance(pk_val, DatabaseDefault)",
      "comment": "I think we should avoid adding more to this function particularly in the context of ticket-36259.\r\n\r\nI'd suggest altering the `bulk_create` usage instead\r\n\r\n```diff\r\ndiff --git a/django/db/models/query.py b/django/db/models/query.py\r\nindex 175073b961..9f2332a60e 100644\r\n--- a/django/db/models/query.py\r\n+++ b/django/db/models/query.py\r\n@@ -23,7 +23,7 @@\r\n from django.db.models import AutoField, DateField, DateTimeField, Field, sql\r\n from django.db.models.constants import LOOKUP_SEP, OnConflict\r\n from django.db.models.deletion import Collector\r\n-from django.db.models.expressions import Case, F, Value, When\r\n+from django.db.models.expressions import Case, DatabaseDefault, F, Value, When\r\n from django.db.models.functions import Cast, Trunc\r\n from django.db.models.query_utils import FilteredRelation, Q\r\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE, ROW_COUNT\r\n@@ -789,7 +789,10 @@ def bulk_create(\r\n         objs = list(objs)\r\n         self._prepare_for_bulk_create(objs)\r\n         with transaction.atomic(using=self.db, savepoint=False):\r\n-            objs_without_pk, objs_with_pk = partition(lambda o: o._is_pk_set(), objs)\r\n+            objs_without_pk, objs_with_pk = partition(\r\n+                lambda o: o._is_pk_set() and not isinstance(o.pk, DatabaseDefault),\r\n+                objs,\r\n+            )\r\n             if objs_with_pk:\r\n                 returned_columns = self._batched_insert(\r\n                     objs_with_pk,\r\n```",
      "comment_id": 1997781682,
      "user": "charettes",
      "created_at": "2025-03-17T00:12:27Z",
      "url": "https://github.com/django/django/pull/19277#discussion_r1997781682"
    },
    {
      "repo": "django/django",
      "pr_number": 19277,
      "file_path": "django/db/models/query.py",
      "line": 795,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,7 +789,10 @@ def bulk_create(\n         objs = list(objs)\n         self._prepare_for_bulk_create(objs)\n         with transaction.atomic(using=self.db, savepoint=False):\n-            objs_without_pk, objs_with_pk = partition(lambda o: o._is_pk_set(), objs)\n+            objs_without_pk, objs_with_pk = partition(\n+                lambda o: o._is_pk_set() and not isinstance(o.pk, DatabaseDefault),\n+                objs,\n+            )",
      "comment": "Yes, this change makes sense to avoid looping twice. Should I push it to my branch?",
      "comment_id": 1998859153,
      "user": "mitya57",
      "created_at": "2025-03-17T14:25:52Z",
      "url": "https://github.com/django/django/pull/19277#discussion_r1998859153"
    },
    {
      "repo": "django/django",
      "pr_number": 19277,
      "file_path": "django/db/models/query.py",
      "line": 795,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,7 +789,10 @@ def bulk_create(\n         objs = list(objs)\n         self._prepare_for_bulk_create(objs)\n         with transaction.atomic(using=self.db, savepoint=False):\n-            objs_without_pk, objs_with_pk = partition(lambda o: o._is_pk_set(), objs)\n+            objs_without_pk, objs_with_pk = partition(\n+                lambda o: o._is_pk_set() and not isinstance(o.pk, DatabaseDefault),\n+                objs,\n+            )",
      "comment": "I think you could yes, worst case it gets removed at merge time. Push it as a separate commit starting with `Refs #36260 -- <past tense message>` \ud83d\ude47 ",
      "comment_id": 1998864090,
      "user": "charettes",
      "created_at": "2025-03-17T14:28:06Z",
      "url": "https://github.com/django/django/pull/19277#discussion_r1998864090"
    },
    {
      "repo": "django/django",
      "pr_number": 19277,
      "file_path": "django/db/models/query.py",
      "line": 684,
      "side": "RIGHT",
      "diff_hunk": "@@ -670,11 +670,20 @@ async def acreate(self, **kwargs):\n     acreate.alters_data = True\n \n     def _prepare_for_bulk_create(self, objs):\n+        objs_with_pk, objs_without_pk = [], []\n         for obj in objs:\n-            if not obj._is_pk_set():\n-                # Populate new PK values.\n+            if isinstance(obj.pk, DatabaseDefault):\n+                objs_without_pk.append(obj)\n+            elif obj._is_pk_set():\n+                objs_with_pk.append(obj)\n+            else:\n                 obj.pk = obj._meta.pk.get_pk_value_on_save(obj)\n+                if obj._is_pk_set():\n+                    objs_with_pk.append(obj)\n+                else:\n+                    objs_without_pk.append(obj)",
      "comment": "```suggestion\r\n                objs_without_pk.append(obj)\r\n```\r\nI'm not sure if I've missed something but I can change to the following without any bulk_create test failures. Are we missing a test for this or can it be simplified?",
      "comment_id": 2011588141,
      "user": "sarahboyce",
      "created_at": "2025-03-25T08:40:53Z",
      "url": "https://github.com/django/django/pull/19277#discussion_r2011588141"
    },
    {
      "repo": "django/django",
      "pr_number": 19277,
      "file_path": "django/db/models/query.py",
      "line": 684,
      "side": "RIGHT",
      "diff_hunk": "@@ -670,11 +670,20 @@ async def acreate(self, **kwargs):\n     acreate.alters_data = True\n \n     def _prepare_for_bulk_create(self, objs):\n+        objs_with_pk, objs_without_pk = [], []\n         for obj in objs:\n-            if not obj._is_pk_set():\n-                # Populate new PK values.\n+            if isinstance(obj.pk, DatabaseDefault):\n+                objs_without_pk.append(obj)\n+            elif obj._is_pk_set():\n+                objs_with_pk.append(obj)\n+            else:\n                 obj.pk = obj._meta.pk.get_pk_value_on_save(obj)\n+                if obj._is_pk_set():\n+                    objs_with_pk.append(obj)\n+                else:\n+                    objs_without_pk.append(obj)",
      "comment": "@sarahboyce through a bit of git-blame if found the test that would fail.\r\n\r\n`get_pk_value_on_save` was introduced in 8adc59038cdc6ce4f9170e4de2d716d940e136b3 to [expose a hook for these reasons](https://code.djangoproject.com/ticket/23617#comment:11).\r\n\r\nWhether or not this hook is still relevant today now that we support `db_default` is up for discussion but if you run the `model_fields.test_uuid` suite you'll notice that this code is exercised and thus likely used in the wild.",
      "comment_id": 2012212921,
      "user": "charettes",
      "created_at": "2025-03-25T14:17:48Z",
      "url": "https://github.com/django/django/pull/19277#discussion_r2012212921"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "tests/aggregation_regress/tests.py",
      "line": 196,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,56 @@ def assertObjectAttrs(self, obj, **kwargs):\n         for attr, value in kwargs.items():\n             self.assertEqual(getattr(obj, attr), value)\n \n+    def test_count_preserve_group_by(self):\n+        # new release of the same book\n+        Book.objects.create(\n+            isbn=\"113235613\",\n+            name=self.b4.name,\n+            pages=self.b4.pages,\n+            rating=4.0,\n+            price=Decimal(\"39.69\"),\n+            contact=self.a5,\n+            publisher=self.p3,\n+            pubdate=datetime.date(2018, 11, 3),\n+        )\n+        qs = Book.objects.values(\"contact__name\", \"publisher__name\").annotate(\n+            publications=Count(\"id\")\n+        )\n+        self.assertEqual(qs.count(), 6)\n+        self.assertEqual(qs.count(), len(qs))\n+        # before ticket 26434 had been solved .count() was returning also 6\n+        self.assertEqual(qs.order_by(\"id\").count(), 7)\n+        # before ticket 26434 had been solved .count() was not equal to len(qs)\n+        self.assertEqual(qs.order_by(\"id\").count(), len(qs.order_by(\"id\")))\n+\n+    def test_aggregate_preserve_group_by(self):",
      "comment": "Counts are aggregates, and this patch doesn't introduce specialization for `Count`, so I think just having the prior test with count is sufficient.",
      "comment_id": 2440361876,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T15:18:06Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2440361876"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "tests/aggregation_regress/tests.py",
      "line": 194,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,56 @@ def assertObjectAttrs(self, obj, **kwargs):\n         for attr, value in kwargs.items():\n             self.assertEqual(getattr(obj, attr), value)\n \n+    def test_count_preserve_group_by(self):\n+        # new release of the same book\n+        Book.objects.create(\n+            isbn=\"113235613\",\n+            name=self.b4.name,\n+            pages=self.b4.pages,\n+            rating=4.0,\n+            price=Decimal(\"39.69\"),\n+            contact=self.a5,\n+            publisher=self.p3,\n+            pubdate=datetime.date(2018, 11, 3),\n+        )\n+        qs = Book.objects.values(\"contact__name\", \"publisher__name\").annotate(\n+            publications=Count(\"id\")\n+        )\n+        self.assertEqual(qs.count(), 6)\n+        self.assertEqual(qs.count(), len(qs))\n+        # before ticket 26434 had been solved .count() was returning also 6\n+        self.assertEqual(qs.order_by(\"id\").count(), 7)\n+        # before ticket 26434 had been solved .count() was not equal to len(qs)\n+        self.assertEqual(qs.order_by(\"id\").count(), len(qs.order_by(\"id\")))",
      "comment": "```suggestion\n        self.assertEqual(qs.count(), Book.objects.count() - 1)\n        self.assertEqual(qs.order_by(\"id\").count(), Book.objects.count())\n```",
      "comment_id": 2440384837,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T15:26:13Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2440384837"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "django/db/models/sql/query.py",
      "line": 2319,
      "side": "RIGHT",
      "diff_hunk": "@@ -2311,7 +2311,13 @@ def clear_ordering(self, force=False, clear_default=True):\n         query (not even the model's default).\n         \"\"\"\n         if not force and (\n-            self.is_sliced or self.distinct_fields or self.select_for_update\n+            self.is_sliced\n+            or self.distinct_fields\n+            or self.select_for_update\n+            or (\n+                isinstance(self.group_by, tuple)\n+                and not set(self.order_by + self.extra_order_by).issubset(self.group_by)",
      "comment": "No test fails when I remove the `self.extra_order_by`, so let's add coverage.",
      "comment_id": 2440386611,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T15:26:53Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2440386611"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "django/db/models/sql/query.py",
      "line": 2319,
      "side": "RIGHT",
      "diff_hunk": "@@ -2311,7 +2311,13 @@ def clear_ordering(self, force=False, clear_default=True):\n         query (not even the model's default).\n         \"\"\"\n         if not force and (\n-            self.is_sliced or self.distinct_fields or self.select_for_update\n+            self.is_sliced\n+            or self.distinct_fields\n+            or self.select_for_update\n+            or (\n+                isinstance(self.group_by, tuple)\n+                and not set(self.order_by + self.extra_order_by).issubset(self.group_by)",
      "comment": "Just to confirm regarding the missing coverage for self.extra_order_by: \r\n\r\nDo you have a specific scenario in mind that I should turn into a test? \r\nI assume you mean a case where extra_order_by affects the count/aggregation differently than order_by alone - I can add a dedicated test for that if that\u2019s what you meant.",
      "comment_id": 2440622157,
      "user": "michalnik",
      "created_at": "2025-10-17T17:00:38Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2440622157"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "tests/aggregation_regress/tests.py",
      "line": 194,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +171,56 @@ def assertObjectAttrs(self, obj, **kwargs):\n         for attr, value in kwargs.items():\n             self.assertEqual(getattr(obj, attr), value)\n \n+    def test_count_preserve_group_by(self):\n+        # new release of the same book\n+        Book.objects.create(\n+            isbn=\"113235613\",\n+            name=self.b4.name,\n+            pages=self.b4.pages,\n+            rating=4.0,\n+            price=Decimal(\"39.69\"),\n+            contact=self.a5,\n+            publisher=self.p3,\n+            pubdate=datetime.date(2018, 11, 3),\n+        )\n+        qs = Book.objects.values(\"contact__name\", \"publisher__name\").annotate(\n+            publications=Count(\"id\")\n+        )\n+        self.assertEqual(qs.count(), 6)\n+        self.assertEqual(qs.count(), len(qs))\n+        # before ticket 26434 had been solved .count() was returning also 6\n+        self.assertEqual(qs.order_by(\"id\").count(), 7)\n+        # before ticket 26434 had been solved .count() was not equal to len(qs)\n+        self.assertEqual(qs.order_by(\"id\").count(), len(qs.order_by(\"id\")))",
      "comment": "I don\u2019t have time to adjust the test right now, but I\u2019ll make sure to address it in the next update.",
      "comment_id": 2440652178,
      "user": "michalnik",
      "created_at": "2025-10-17T17:15:20Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2440652178"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "django/db/models/sql/query.py",
      "line": 2319,
      "side": "RIGHT",
      "diff_hunk": "@@ -2311,7 +2311,13 @@ def clear_ordering(self, force=False, clear_default=True):\n         query (not even the model's default).\n         \"\"\"\n         if not force and (\n-            self.is_sliced or self.distinct_fields or self.select_for_update\n+            self.is_sliced\n+            or self.distinct_fields\n+            or self.select_for_update\n+            or (\n+                isinstance(self.group_by, tuple)\n+                and not set(self.order_by + self.extra_order_by).issubset(self.group_by)",
      "comment": "Right, just having a test that varies only in that instead of calling `.order_by()` it calls `.extra(order_by=...`.",
      "comment_id": 2440684480,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T17:30:26Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2440684480"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "django/db/models/sql/query.py",
      "line": 2354,
      "side": "RIGHT",
      "diff_hunk": "@@ -2346,7 +2346,15 @@ def clear_ordering(self, force=False, clear_default=True):\n         query (not even the model's default).\n         \"\"\"\n         if not force and (\n-            self.is_sliced or self.distinct_fields or self.select_for_update\n+            self.is_sliced\n+            or self.distinct_fields\n+            or self.select_for_update\n+            or (\n+                isinstance(self.group_by, tuple)\n+                and not set(*self.order_by, *self.extra_order_by).issubset(",
      "comment": "Isn't this missing a `[...]` wrapping?\n\n\n```suggestion\n                and not set([*self.order_by, *self.extra_order_by]).issubset(\n```\n\n```\n\u279c  Workspace python --version\nPython 3.13.5\n\u279c  Workspace python\nPython 3.13.5 (main, Jun 14 2025, 15:09:19) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> set(*[1,2,3], *[4,5,6])\nTraceback (most recent call last):\n  File \"<python-input-0>\", line 1, in <module>\n    set(*[1,2,3], *[4,5,6])\n    ~~~^^^^^^^^^^^^^^^^^^^^\nTypeError: set expected at most 1 argument, got 6\n```",
      "comment_id": 2466412464,
      "user": "charettes",
      "created_at": "2025-10-27T16:57:50Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2466412464"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "django/db/models/sql/query.py",
      "line": 2354,
      "side": "RIGHT",
      "diff_hunk": "@@ -2346,7 +2346,15 @@ def clear_ordering(self, force=False, clear_default=True):\n         query (not even the model's default).\n         \"\"\"\n         if not force and (\n-            self.is_sliced or self.distinct_fields or self.select_for_update\n+            self.is_sliced\n+            or self.distinct_fields\n+            or self.select_for_update\n+            or (\n+                isinstance(self.group_by, tuple)\n+                and not set(*self.order_by, *self.extra_order_by).issubset(",
      "comment": "Or maybe use a set literal directly?\n\n\n```suggestion\n                and not {*self.order_by, *self.extra_order_by}.issubset(\n```",
      "comment_id": 2466417097,
      "user": "charettes",
      "created_at": "2025-10-27T16:59:25Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2466417097"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "django/db/models/sql/query.py",
      "line": 2354,
      "side": "RIGHT",
      "diff_hunk": "@@ -2346,7 +2346,15 @@ def clear_ordering(self, force=False, clear_default=True):\n         query (not even the model's default).\n         \"\"\"\n         if not force and (\n-            self.is_sliced or self.distinct_fields or self.select_for_update\n+            self.is_sliced\n+            or self.distinct_fields\n+            or self.select_for_update\n+            or (\n+                isinstance(self.group_by, tuple)\n+                and not set(*self.order_by, *self.extra_order_by).issubset(",
      "comment": "(I naively assumed that if tests passed when removing the `tuple` I would be okay.)",
      "comment_id": 2466435673,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-27T17:06:35Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2466435673"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "django/db/models/sql/query.py",
      "line": 2354,
      "side": "RIGHT",
      "diff_hunk": "@@ -2346,7 +2346,15 @@ def clear_ordering(self, force=False, clear_default=True):\n         query (not even the model's default).\n         \"\"\"\n         if not force and (\n-            self.is_sliced or self.distinct_fields or self.select_for_update\n+            self.is_sliced\n+            or self.distinct_fields\n+            or self.select_for_update\n+            or (\n+                isinstance(self.group_by, tuple)\n+                and not set(*self.order_by, *self.extra_order_by).issubset(",
      "comment": "I suspect it does because there's only one member of `order_by` present which turned into single argument being provided?",
      "comment_id": 2466439300,
      "user": "charettes",
      "created_at": "2025-10-27T17:07:55Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2466439300"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "django/db/models/sql/query.py",
      "line": 2355,
      "side": "RIGHT",
      "diff_hunk": "@@ -2346,7 +2346,13 @@ def clear_ordering(self, force=False, clear_default=True):\n         query (not even the model's default).\n         \"\"\"\n         if not force and (\n-            self.is_sliced or self.distinct_fields or self.select_for_update\n+            self.is_sliced\n+            or self.distinct_fields\n+            or self.select_for_update\n+            or (\n+                isinstance(self.group_by, tuple)\n+                and not {*self.order_by, *self.extra_order_by}.issubset(self.group_by)\n+            )",
      "comment": "This caused a [regression](https://djangoci.com/job/django-oracle/database=oracle19,label=oracle,python=python3.14/lastCompletedBuild/testReport/) on Oracle but not only. `group_by` is a tuple of `Col` expressions, `order_by` is a list of strings, so `{*self.order_by, *self.extra_order_by}` will never be a subset of `group_by`.\r\n\r\nPreviously:\r\n\r\n```sql\r\nSELECT\r\n   ...\r\nFROM \"AGGREGATION_REGRESS_BOOK\"\r\nWHERE \"AGGREGATION_REGRESS_BOOK\".\"ID\" IN (\r\n    SELECT MAX(U0.\"ID\") AS \"ID__MAX\"\r\n   FROM \"AGGREGATION_REGRESS_BOOK\" U0\r\n   GROUP BY U0.\"CONTACT_ID\"\r\n)\r\nORDER BY \"AGGREGATION_REGRESS_BOOK\".\"ID\" ASC\r\n```\r\nwith this patch\r\n```sql\r\nSELECT\r\n   ...\r\nFROM \"AGGREGATION_REGRESS_BOOK\"\r\nWHERE \"AGGREGATION_REGRESS_BOOK\".\"ID\" IN (\r\n    SELECT MAX(U0.\"ID\") AS \"ID__MAX\"\r\n   FROM \"AGGREGATION_REGRESS_BOOK\" U0\r\n   GROUP BY U0.\"CONTACT_ID\"\r\n   ORDER BY U0.\"CONTACT_ID\" ASC\r\n)\r\nORDER BY \"AGGREGATION_REGRESS_BOOK\".\"ID\" ASC\r\n```",
      "comment_id": 2468153859,
      "user": "felixxm",
      "created_at": "2025-10-28T07:08:56Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2468153859"
    },
    {
      "repo": "django/django",
      "pr_number": 19519,
      "file_path": "django/db/models/sql/query.py",
      "line": 2355,
      "side": "RIGHT",
      "diff_hunk": "@@ -2346,7 +2346,13 @@ def clear_ordering(self, force=False, clear_default=True):\n         query (not even the model's default).\n         \"\"\"\n         if not force and (\n-            self.is_sliced or self.distinct_fields or self.select_for_update\n+            self.is_sliced\n+            or self.distinct_fields\n+            or self.select_for_update\n+            or (\n+                isinstance(self.group_by, tuple)\n+                and not {*self.order_by, *self.extra_order_by}.issubset(self.group_by)\n+            )",
      "comment": "As far as I'm aware, we would need to translate string aliases (`order_by` and `extra_order_by`) to `Col` expressions but this may be expensive here (or at least non-trivial).",
      "comment_id": 2468339798,
      "user": "felixxm",
      "created_at": "2025-10-28T08:06:05Z",
      "url": "https://github.com/django/django/pull/19519#discussion_r2468339798"
    },
    {
      "repo": "django/django",
      "pr_number": 20340,
      "file_path": "django/utils/inspect.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,3 +107,27 @@ def is_module_level_function(func):\n         return False\n \n     return True\n+\n+\n+@contextmanager\n+def leave_deferred_annotations_unevaluated():\n+    \"\"\"\n+    inspect.getfullargspec eagerly evaluates type annotations. To add\n+    compatibility with Python 3.14+ deferred evaluation, patch the module-level\n+    helper to provide the annotation_format that we are using elsewhere.\n+\n+    This private helper could be removed when there is an upstream solution for\n+    https://github.com/python/cpython/issues/141560.\n+    \"\"\"\n+    with lock:",
      "comment": "Nit: For non-3.14 versions, this adds a lock around evaluting arguments. It's probably not huge, but in especially hot contexts it adds unnecessary extra work and could impact throughput. Perhaps worth a short-circuit for non-3.14 to avoid the lock?\n\n```python\nif not PY314:\n    yield\nelse:\n    with lock:\n        ...\n```",
      "comment_id": 2576958451,
      "user": "RealOrangeOne",
      "created_at": "2025-12-01T12:51:35Z",
      "url": "https://github.com/django/django/pull/20340#discussion_r2576958451"
    },
    {
      "repo": "django/django",
      "pr_number": 20340,
      "file_path": "django/utils/inspect.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,11 +1,20 @@\n import functools\n import inspect\n+import threading\n+from contextlib import contextmanager\n \n from django.utils.version import PY314\n \n if PY314:\n     import annotationlib\n \n+    safe_signature_from_callable = functools.partial(\n+        inspect._signature_from_callable,\n+        annotation_format=annotationlib.Format.FORWARDREF,\n+    )\n+\n+lock = threading.Lock()",
      "comment": "Should this `lock` also be inside the `if PY314:` guard?",
      "comment_id": 2578207946,
      "user": "nessita",
      "created_at": "2025-12-01T18:34:27Z",
      "url": "https://github.com/django/django/pull/20340#discussion_r2578207946"
    },
    {
      "repo": "django/django",
      "pr_number": 20340,
      "file_path": "django/utils/inspect.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,3 +107,29 @@ def is_module_level_function(func):\n         return False\n \n     return True\n+\n+\n+@contextmanager\n+def leave_deferred_annotations_unevaluated():\n+    \"\"\"\n+    inspect.getfullargspec eagerly evaluates type annotations. To add\n+    compatibility with Python 3.14+ deferred evaluation, patch the module-level\n+    helper to provide the annotation_format that we are using elsewhere.\n+\n+    This private helper could be removed when there is an upstream solution for\n+    https://github.com/python/cpython/issues/141560.\n+    \"\"\"\n+    if not PY314:\n+        yield\n+        return\n+    with lock:\n+        helper_was_already_replaced = False",
      "comment": "I would suggest using the slightly shorter:\n\n```suggestion\n        helper_was_replaced = False\n```",
      "comment_id": 2578372192,
      "user": "nessita",
      "created_at": "2025-12-01T19:39:25Z",
      "url": "https://github.com/django/django/pull/20340#discussion_r2578372192"
    },
    {
      "repo": "django/django",
      "pr_number": 20340,
      "file_path": "django/utils/inspect.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,3 +107,29 @@ def is_module_level_function(func):\n         return False\n \n     return True\n+\n+\n+@contextmanager\n+def leave_deferred_annotations_unevaluated():",
      "comment": "How about:\n\n```suggestion\ndef lazy_deferred_annotations():\n```\n",
      "comment_id": 2578376018,
      "user": "nessita",
      "created_at": "2025-12-01T19:40:59Z",
      "url": "https://github.com/django/django/pull/20340#discussion_r2578376018"
    },
    {
      "repo": "django/django",
      "pr_number": 20340,
      "file_path": "django/utils/inspect.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,3 +107,29 @@ def is_module_level_function(func):\n         return False\n \n     return True\n+\n+\n+@contextmanager\n+def leave_deferred_annotations_unevaluated():\n+    \"\"\"\n+    inspect.getfullargspec eagerly evaluates type annotations. To add\n+    compatibility with Python 3.14+ deferred evaluation, patch the module-level\n+    helper to provide the annotation_format that we are using elsewhere.\n+\n+    This private helper could be removed when there is an upstream solution for\n+    https://github.com/python/cpython/issues/141560.\n+    \"\"\"\n+    if not PY314:\n+        yield\n+        return\n+    with lock:\n+        helper_was_already_replaced = False",
      "comment": "Good call -- I had it like this, then changed it, because from the perspective of the finally block, it could be unclear what \"replaced\" means: replaced before the context was entered, or during the `try`? \r\n\r\nBut this isn't necessarily helping, so I'll revert.",
      "comment_id": 2579083832,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-01T23:35:09Z",
      "url": "https://github.com/django/django/pull/20340#discussion_r2579083832"
    },
    {
      "repo": "django/django",
      "pr_number": 20340,
      "file_path": "django/utils/inspect.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,11 +1,19 @@\n import functools\n import inspect\n+import threading\n+from contextlib import contextmanager\n \n from django.utils.version import PY314\n \n if PY314:\n     import annotationlib\n \n+    lock = threading.Lock()\n+    safe_signature_from_callable = functools.partial(\n+        inspect._signature_from_callable,",
      "comment": "No reason to have to `getattr` for this below, since we're relying on it here. This helper hasn't changed in python for a long time, it's likely pretty stable.",
      "comment_id": 2579133267,
      "user": "jacobtylerwalls",
      "created_at": "2025-12-02T00:08:30Z",
      "url": "https://github.com/django/django/pull/20340#discussion_r2579133267"
    },
    {
      "repo": "django/django",
      "pr_number": 20350,
      "file_path": "django/core/exceptions.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,7 +58,7 @@ class DisallowedHost(SuspiciousOperation):\n \n \n class DisallowedRedirect(SuspiciousOperation):\n-    \"\"\"Redirect to scheme not in allowed list\"\"\"\n+    \"\"\"Redirect too long or scheme not in allowed list\"\"\"",
      "comment": "Since we are changing this line, could you please add the missing ending dot? Thanks!",
      "comment_id": 2577192175,
      "user": "nessita",
      "created_at": "2025-12-01T13:56:38Z",
      "url": "https://github.com/django/django/pull/20350#discussion_r2577192175"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,108 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+\n+        db = schema_editor.connection.alias\n+\n+        if not router.allow_migrate_model(db, Permission):\n+            return\n+\n+        try:\n+            ctypes = ContentType.objects.filter(\n+                app_label=self.app_label, model__icontains=self.old_model\n+            )\n+\n+            permissions = Permission.objects.filter(content_type__in=ctypes)\n+\n+        except Permission.DoesNotExist:\n+            pass\n+        else:\n+            for permission in permissions:\n+                permission.codename = (\n+                    permission.codename.split(\"_\")[0] + \"_\" + self.new_model\n+                )\n+\n+                new_str = permission.name.split()[:-1]\n+\n+                permission.name = \" \".join(new_str) + \" \" + self.new_model\n+                try:\n+                    with transaction.atomic(using=db):\n+                        permission.save(update_fields={\"name\", \"codename\"})\n+                except IntegrityError:\n+                    # Gracefully fallback if a stale content type causes a\n+                    # conflict as update_contenttypes will take care of asking the\n+                    # user what should be done next.\n+                    permission.model = old_model\n+            else:\n+                # Clear the cache as the `get_by_natual_key()` call will cache\n+                # the renamed ContentType instance by its old model name.\n+                # Permission.objects.clear_cache()\n+                pass\n+\n+    def rename_forward(self, apps, schema_editor):\n+        self._rename(apps, schema_editor, self.old_model, self.new_model)\n+\n+    def rename_backward(self, apps, schema_editor):\n+        self._rename(apps, schema_editor, self.new_model, self.old_model)",
      "comment": "Can update this to \"pass\" without any failures, so this is missing a test",
      "comment_id": 2089084240,
      "user": "sarahboyce",
      "created_at": "2025-05-14T14:25:31Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2089084240"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,108 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+\n+        db = schema_editor.connection.alias\n+\n+        if not router.allow_migrate_model(db, Permission):\n+            return\n+\n+        try:\n+            ctypes = ContentType.objects.filter(\n+                app_label=self.app_label, model__icontains=self.old_model\n+            )\n+\n+            permissions = Permission.objects.filter(content_type__in=ctypes)\n+\n+        except Permission.DoesNotExist:\n+            pass\n+        else:\n+            for permission in permissions:\n+                permission.codename = (\n+                    permission.codename.split(\"_\")[0] + \"_\" + self.new_model\n+                )\n+\n+                new_str = permission.name.split()[:-1]\n+\n+                permission.name = \" \".join(new_str) + \" \" + self.new_model\n+                try:\n+                    with transaction.atomic(using=db):\n+                        permission.save(update_fields={\"name\", \"codename\"})\n+                except IntegrityError:\n+                    # Gracefully fallback if a stale content type causes a\n+                    # conflict as update_contenttypes will take care of asking the\n+                    # user what should be done next.\n+                    permission.model = old_model\n+            else:\n+                # Clear the cache as the `get_by_natual_key()` call will cache\n+                # the renamed ContentType instance by its old model name.\n+                # Permission.objects.clear_cache()\n+                pass\n+\n+    def rename_forward(self, apps, schema_editor):\n+        self._rename(apps, schema_editor, self.old_model, self.new_model)\n+\n+    def rename_backward(self, apps, schema_editor):\n+        self._rename(apps, schema_editor, self.new_model, self.old_model)\n+\n+\n+def update_permissions(\n+    plan,\n+    verbosity=2,\n+    interactive=True,\n+    using=DEFAULT_DB_ALIAS,\n+    apps=global_apps,\n+    **kwargs,\n+):\n+    \"\"\"\n+    Insert a `RenameContentType` operation after every planned `RenameModel`\n+    operation.\n+    \"\"\"\n+    if plan is None:\n+        return\n+\n+    # Determine whether or not the ContentType model is available.\n+    try:\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        available = False\n+    else:\n+        if not router.allow_migrate_model(using, ContentType):\n+            return\n+        available = True\n+\n+    if not available:\n+        return",
      "comment": "without this the tests (the global ones) do fail, since at some point the function called while permission model is not defined.\r\nI added tests that you asked for and pushed them, if I did something wrong or misunderstood you let me know",
      "comment_id": 2122358303,
      "user": "artirix1927",
      "created_at": "2025-06-03T00:02:16Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2122358303"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1549,
      "side": "RIGHT",
      "diff_hunk": "@@ -1522,6 +1531,186 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+class RenamePermissionTests(TestCase):\n+\n+    def setUp(self):\n+        ct, _ = ContentType.objects.get_or_create(\n+            app_label=\"auth_tests\", model=\"OldModel\"\n+        )\n+\n+        Permission.objects.get_or_create(\n+            codename=\"change_oldmodel\", name=\"Can change oldmodel\", content_type=ct\n+        )\n+        pre_migrate.connect(update_permissions)\n+\n+    def tearDown(self):\n+        pre_migrate.disconnect(update_permissions)\n+\n+    def test_fake_migration_plan(self):",
      "comment": "Thank you for the updates!\r\n\r\nI just realized we might want the testing to be closer to what was done in f179113e6cbc8ba0a8d4e87e1d4410fb61d63e75 where we call migrate and migrate back to zero to check everything was undone. I think this is cleaner than having some of the \"setup\" and \"clean state\" that exists in some of the tests. Would you mind taking a look?",
      "comment_id": 2145084652,
      "user": "sarahboyce",
      "created_at": "2025-06-13T13:21:51Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2145084652"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,90 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        from django.contrib.auth.models import Permission  # real live model import",
      "comment": "Can you explain why this shouldn't be `Permission = apps.get_model(\"auth\", \"Permission\")`?\r\nI see there are some test failures but the direct import feels wrong",
      "comment_id": 2215677607,
      "user": "sarahboyce",
      "created_at": "2025-07-18T10:19:15Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2215677607"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1753,
      "side": "RIGHT",
      "diff_hunk": "@@ -1522,6 +1528,208 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+@override_settings(\n+    MIGRATION_MODULES=dict(\n+        settings.MIGRATION_MODULES,\n+        auth_tests=\"auth_tests.operations_migrations\",\n+    ),\n+)\n+class PermissionRenameOperationsTests(TransactionTestCase):\n+    available_apps = [\n+        \"django.contrib.contenttypes\",\n+        \"django.contrib.auth\",\n+        \"auth_tests\",\n+    ]\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+    def tearDown(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.disconnect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.RenameModel):\n+                    next_operation = next(operations)\n+                    self.assertTrue(\n+                        any(isinstance(op, RenamePermission) for op in operations),\n+                        \"RenamePermission not found in injected operations\",\n+                    )\n+                    self.assertEqual(next_operation.app_label, migration.app_label)\n+                    self.assertEqual(next_operation.old_model, operation.old_name_lower)\n+                    self.assertEqual(next_operation.new_model, operation.new_name_lower)\n+\n+    def test_permission_rename(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change oldmodel\",\n+            content_type=ct,\n+        )\n+\n+        self.assertTrue(Permission.objects.filter(name=\"Can change oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(name=\"Can change newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(Permission.objects.filter(name=\"Can change oldmodel\").exists())\n+        self.assertTrue(Permission.objects.filter(name=\"Can change newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(Permission.objects.filter(name=\"Can change oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(name=\"Can change newmodel\").exists())\n+\n+    def test_rename_skipped_if_router_disallows(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change oldmodel\",\n+            content_type=ct,\n+        )\n+\n+        with mock.patch(\"django.db.router.allow_migrate_model\", return_value=False):\n+            call_command(\n+                \"migrate\",\n+                \"auth_tests\",\n+                database=\"default\",\n+                interactive=False,\n+                verbosity=0,\n+            )\n+\n+        self.assertTrue(Permission.objects.filter(codename=\"change_oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+    def test_rename_backward_does_nothing_if_no_permissions(self):\n+        Permission.objects.filter(content_type__app_label=\"auth_tests\").delete()\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        self.assertFalse(\n+            Permission.objects.filter(\n+                codename__in=[\"change_oldmodel\", \"change_newmodel\"]\n+            ).exists()\n+        )\n+\n+    def test_rename_permission_integrity_error(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_newmodel\",\n+            name=\"Can change newmodel\",\n+            content_type=ct,\n+        )\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change oldmodel\",\n+            content_type=ct,\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        self.assertTrue(\n+            Permission.objects.filter(\n+                codename=\"change_oldmodel\",\n+                name=\"Can change oldmodel\",\n+            ).exists()\n+        )\n+        self.assertEqual(\n+            Permission.objects.filter(\n+                codename=\"change_newmodel\",\n+                name=\"Can change newmodel\",\n+            ).count(),\n+            1,\n+        )\n+\n+    def test_multiple_permission_types(self):\n+        \"\"\"Tests that all permission types (add/change/delete/view) are renamed\"\"\"\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        for action in [\"add\", \"change\", \"delete\", \"view\"]:\n+            Permission.objects.create(\n+                codename=f\"{action}_oldmodel\",\n+                name=f\"Can {action} oldmodel\",\n+                content_type=ct,\n+            )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+\n+        for action in [\"add\", \"change\", \"delete\", \"view\"]:\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        for action in [\"add\", \"change\", \"delete\", \"view\"]:\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+    def test_case_sensitivity(self):\n+        \"\"\"Tests that renaming works with mixed-case model names\"\"\"\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"OldModel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change OldModel\",\n+            content_type=ct,\n+        )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+        self.assertTrue(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+",
      "comment": "```suggestion\r\n        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\r\n\r\n```\r\nWhen I add the following assertion to check this has reversed, this fails. Can you look into this?",
      "comment_id": 2215681390,
      "user": "sarahboyce",
      "created_at": "2025-07-18T10:20:32Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2215681390"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,90 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        from django.contrib.auth.models import Permission  # real live model import",
      "comment": "Okay, so as I understand, the tests don't pass because the apps.get_model() function returns frozen (`__fake__`) model. Which does not have foreign key relationships yet and does not have content_type field at all. I tried to fix this by avoiding the foreign keys and content types to find the needed permissions, but the permission class has its own ordering that involves contenttypes so this does not work too. I can call .order_by() inside the operation, which will clear the ordering and wont raise errors and will allow me to query for permissions by codename strings and etc, while  avoiding contettypes. Other than that, the he only way I could do this is by using raw sql inside the migration operation which seems even worse than using live model.",
      "comment_id": 2217998863,
      "user": "artirix1927",
      "created_at": "2025-07-20T23:23:05Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2217998863"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1753,
      "side": "RIGHT",
      "diff_hunk": "@@ -1522,6 +1528,208 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+@override_settings(\n+    MIGRATION_MODULES=dict(\n+        settings.MIGRATION_MODULES,\n+        auth_tests=\"auth_tests.operations_migrations\",\n+    ),\n+)\n+class PermissionRenameOperationsTests(TransactionTestCase):\n+    available_apps = [\n+        \"django.contrib.contenttypes\",\n+        \"django.contrib.auth\",\n+        \"auth_tests\",\n+    ]\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+    def tearDown(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.disconnect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.RenameModel):\n+                    next_operation = next(operations)\n+                    self.assertTrue(\n+                        any(isinstance(op, RenamePermission) for op in operations),\n+                        \"RenamePermission not found in injected operations\",\n+                    )\n+                    self.assertEqual(next_operation.app_label, migration.app_label)\n+                    self.assertEqual(next_operation.old_model, operation.old_name_lower)\n+                    self.assertEqual(next_operation.new_model, operation.new_name_lower)\n+\n+    def test_permission_rename(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change oldmodel\",\n+            content_type=ct,\n+        )\n+\n+        self.assertTrue(Permission.objects.filter(name=\"Can change oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(name=\"Can change newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(Permission.objects.filter(name=\"Can change oldmodel\").exists())\n+        self.assertTrue(Permission.objects.filter(name=\"Can change newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(Permission.objects.filter(name=\"Can change oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(name=\"Can change newmodel\").exists())\n+\n+    def test_rename_skipped_if_router_disallows(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change oldmodel\",\n+            content_type=ct,\n+        )\n+\n+        with mock.patch(\"django.db.router.allow_migrate_model\", return_value=False):\n+            call_command(\n+                \"migrate\",\n+                \"auth_tests\",\n+                database=\"default\",\n+                interactive=False,\n+                verbosity=0,\n+            )\n+\n+        self.assertTrue(Permission.objects.filter(codename=\"change_oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+    def test_rename_backward_does_nothing_if_no_permissions(self):\n+        Permission.objects.filter(content_type__app_label=\"auth_tests\").delete()\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        self.assertFalse(\n+            Permission.objects.filter(\n+                codename__in=[\"change_oldmodel\", \"change_newmodel\"]\n+            ).exists()\n+        )\n+\n+    def test_rename_permission_integrity_error(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_newmodel\",\n+            name=\"Can change newmodel\",\n+            content_type=ct,\n+        )\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change oldmodel\",\n+            content_type=ct,\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        self.assertTrue(\n+            Permission.objects.filter(\n+                codename=\"change_oldmodel\",\n+                name=\"Can change oldmodel\",\n+            ).exists()\n+        )\n+        self.assertEqual(\n+            Permission.objects.filter(\n+                codename=\"change_newmodel\",\n+                name=\"Can change newmodel\",\n+            ).count(),\n+            1,\n+        )\n+\n+    def test_multiple_permission_types(self):\n+        \"\"\"Tests that all permission types (add/change/delete/view) are renamed\"\"\"\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        for action in [\"add\", \"change\", \"delete\", \"view\"]:\n+            Permission.objects.create(\n+                codename=f\"{action}_oldmodel\",\n+                name=f\"Can {action} oldmodel\",\n+                content_type=ct,\n+            )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+\n+        for action in [\"add\", \"change\", \"delete\", \"view\"]:\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        for action in [\"add\", \"change\", \"delete\", \"view\"]:\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+    def test_case_sensitivity(self):\n+        \"\"\"Tests that renaming works with mixed-case model names\"\"\"\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"OldModel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change OldModel\",\n+            content_type=ct,\n+        )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+        self.assertTrue(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+",
      "comment": "I looked into this and to be honest that test is not needed and it didnt pass the test because when creating a contenttype for this test I put the \"model=\" with camel case which wont ever happen in real app since django manages the names by itself and lowers all the names of the models to lower case automatically.",
      "comment_id": 2218015036,
      "user": "artirix1927",
      "created_at": "2025-07-21T00:16:10Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2218015036"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,90 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        from django.contrib.auth.models import Permission  # real live model import\n+\n+        db = schema_editor.connection.alias\n+        if not router.allow_migrate_model(db, Permission):\n+            return\n+\n+        ctypes = ContentType.objects.filter(\n+            app_label=self.app_label, model__icontains=old_model\n+        )\n+        permissions = Permission.objects.filter(\n+            content_type_id__in=[ct.id for ct in ctypes]\n+        )\n+        for permission in permissions:\n+            prefix = permission.codename.split(\"_\")[0]\n+            new_codename = f\"{prefix}_{new_model}\"\n+            new_name = f\"Can {prefix} {new_model}\"",
      "comment": "```suggestion\r\n            default_verbose_name = camel_case_to_spaces(new_model)\r\n            new_name = f\"Can {prefix} {default_verbose_name}\"\r\n```\r\nI think the Permission name uses the model verbose_name which I'm not sure we can access but we can probably do a better job of building. This will need some test updates :+1: ",
      "comment_id": 2218547038,
      "user": "sarahboyce",
      "created_at": "2025-07-21T08:45:53Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2218547038"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,90 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        from django.contrib.auth.models import Permission  # real live model import\n+\n+        db = schema_editor.connection.alias\n+        if not router.allow_migrate_model(db, Permission):\n+            return\n+\n+        ctypes = ContentType.objects.filter(\n+            app_label=self.app_label, model__icontains=old_model\n+        )\n+        permissions = Permission.objects.filter(\n+            content_type_id__in=[ct.id for ct in ctypes]\n+        )\n+        for permission in permissions:\n+            prefix = permission.codename.split(\"_\")[0]\n+            new_codename = f\"{prefix}_{new_model}\"\n+            new_name = f\"Can {prefix} {new_model}\"\n+            if permission.codename != new_codename or permission.name != new_name:\n+                permission.codename = new_codename\n+                permission.name = new_name\n+                try:\n+                    with transaction.atomic(using=db):\n+                        permission.save(update_fields={\"name\", \"codename\"})\n+                except IntegrityError:\n+                    # Skip conflicting permissions.\n+                    pass\n+\n+    def rename_forward(self, apps, schema_editor):\n+        self._rename(apps, schema_editor, self.old_model, self.new_model)\n+\n+    def rename_backward(self, apps, schema_editor):\n+        self._rename(apps, schema_editor, self.new_model, self.old_model)\n+\n+\n+def inject_permission_rename_operations(",
      "comment": "Why not to keep the same naming pattern? `inject_*_operations` sounds unnecessary\r\n```suggestion\r\ndef rename_permissions(\r\n```",
      "comment_id": 2218592266,
      "user": "felixxm",
      "created_at": "2025-07-21T09:07:17Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2218592266"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,90 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        from django.contrib.auth.models import Permission  # real live model import\n+\n+        db = schema_editor.connection.alias\n+        if not router.allow_migrate_model(db, Permission):\n+            return\n+\n+        ctypes = ContentType.objects.filter(\n+            app_label=self.app_label, model__icontains=old_model\n+        )\n+        permissions = Permission.objects.filter(\n+            content_type_id__in=[ct.id for ct in ctypes]\n+        )\n+        for permission in permissions:\n+            prefix = permission.codename.split(\"_\")[0]\n+            new_codename = f\"{prefix}_{new_model}\"\n+            new_name = f\"Can {prefix} {new_model}\"\n+            if permission.codename != new_codename or permission.name != new_name:\n+                permission.codename = new_codename\n+                permission.name = new_name\n+                try:\n+                    with transaction.atomic(using=db):\n+                        permission.save(update_fields={\"name\", \"codename\"})\n+                except IntegrityError:\n+                    # Skip conflicting permissions.\n+                    pass\n+\n+    def rename_forward(self, apps, schema_editor):\n+        self._rename(apps, schema_editor, self.old_model, self.new_model)\n+\n+    def rename_backward(self, apps, schema_editor):\n+        self._rename(apps, schema_editor, self.new_model, self.old_model)\n+\n+\n+def inject_permission_rename_operations(\n+    plan,\n+    verbosity=2,\n+    interactive=True,\n+    using=DEFAULT_DB_ALIAS,\n+    apps=global_apps,\n+    **kwargs,\n+):\n+    \"\"\"\n+    Insert a `RenamePermissionType` operation after every planned `RenameModel`\n+    operation.\n+    \"\"\"\n+    try:\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+    except LookupError:\n+        available = False\n+    else:\n+        if not router.allow_migrate_model(using, Permission):\n+            return\n+        available = True\n+\n+    if not available:\n+        return",
      "comment": "Do we need the `available` temporary variable?\r\n```suggestion\r\n    try:\r\n        Permission = apps.get_model(\"auth\", \"Permission\")\r\n    except LookupError:\r\n        return\r\n    else:\r\n        if not router.allow_migrate_model(using, Permission):\r\n            return\r\n\r\n```",
      "comment_id": 2218595401,
      "user": "felixxm",
      "created_at": "2025-07-21T09:08:53Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2218595401"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,108 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+\n+        db = schema_editor.connection.alias\n+\n+        if not router.allow_migrate_model(db, Permission):\n+            return",
      "comment": "Just to clarify \u2014 for the missing test, do you mean I should assert that the RenamePermission operation is not in the migration plan when the router disallows it? I want to make sure I understand what you expecting from the test. Sorry for being a little bit slow",
      "comment_id": 2253337693,
      "user": "artirix1927",
      "created_at": "2025-08-05T06:57:22Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2253337693"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,108 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+\n+        db = schema_editor.connection.alias\n+\n+        if not router.allow_migrate_model(db, Permission):\n+            return",
      "comment": "I think in this case, the `RenamePermission` is in the plan but `router.allow_migrate_model(db, Permission)` returns `False` and so no permission renames, or queries, should take place",
      "comment_id": 2253388157,
      "user": "sarahboyce",
      "created_at": "2025-08-05T07:21:11Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2253388157"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,108 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+\n+        db = schema_editor.connection.alias\n+\n+        if not router.allow_migrate_model(db, Permission):\n+            return",
      "comment": "Do you think it would be appropriate to call the RenamePermission manually in this specific case? Because I cant find a way to write the test so the router allows migration at the stage of building the migration plan (so it can actually insert the rename operation) but disallows it in the runtime (when the actual rename happens).\r\n\r\n\r\n```python\r\n       op = RenamePermission(\r\n            app_label=\"auth_tests\",\r\n            old_model=\"OldModel\",\r\n            new_model=\"NewModel\",\r\n        )\r\n\r\n        with connection.schema_editor() as schema_editor:\r\n            op.rename_forward(apps, schema_editor)\r\n ",
      "comment_id": 2259205764,
      "user": "artirix1927",
      "created_at": "2025-08-07T06:20:45Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2259205764"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +109,108 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        Permission = apps.get_model(\"auth\", \"Permission\")\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+\n+        db = schema_editor.connection.alias\n+\n+        if not router.allow_migrate_model(db, Permission):\n+            return",
      "comment": "Perhaps we just remove it :thinking: \r\nWe have copied this because it exists in `django.contrib.contenttypes.management.RenameContentType._rename` but this is also not covered by tests and may not be needed :thinking: ",
      "comment_id": 2259672062,
      "user": "sarahboyce",
      "created_at": "2025-08-07T09:18:48Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2259672062"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "django/contrib/auth/management/__init__.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +110,84 @@ def create_permissions(\n             print(\"Adding permission '%s'\" % perm)\n \n \n+class RenamePermission(migrations.RunPython):\n+    def __init__(self, app_label, old_model, new_model):\n+        self.app_label = app_label\n+        self.old_model = old_model\n+        self.new_model = new_model\n+        super(RenamePermission, self).__init__(\n+            self.rename_forward, self.rename_backward\n+        )\n+\n+    def _rename(self, apps, schema_editor, old_model, new_model):\n+        ContentType = apps.get_model(\"contenttypes\", \"ContentType\")\n+        # Use the live Permission model instead of the frozen one, since frozen\n+        # models do not retain foreign key constraints.\n+        from django.contrib.auth.models import Permission\n+\n+        db = schema_editor.connection.alias\n+        ctypes = ContentType.objects.filter(\n+            app_label=self.app_label, model__icontains=old_model.lower()\n+        )\n+        for permission in Permission.objects.filter(\n+            content_type_id__in=ctypes.values(\"id\")\n+        ):\n+            prefix = permission.codename.split(\"_\")[0]\n+            default_verbose_name = camel_case_to_spaces(new_model)\n+\n+            new_codename = f\"{prefix}_{new_model.lower()}\"\n+            new_name = f\"Can {prefix} {default_verbose_name}\"\n+\n+            if permission.codename != new_codename or permission.name != new_name:\n+                permission.codename = new_codename\n+                permission.name = new_name\n+                try:\n+                    with transaction.atomic(using=db):\n+                        permission.save(update_fields={\"name\", \"codename\"})\n+                except IntegrityError:",
      "comment": "This could use a comment explaining under what circumstances `IntegrityError` happens.",
      "comment_id": 2566920018,
      "user": "timgraham",
      "created_at": "2025-11-27T01:35:20Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2566920018"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1693,
      "side": "RIGHT",
      "diff_hunk": "@@ -1528,6 +1534,174 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+@override_settings(\n+    MIGRATION_MODULES=dict(\n+        settings.MIGRATION_MODULES,\n+        auth_tests=\"auth_tests.operations_migrations\",\n+    ),\n+)\n+class PermissionRenameOperationsTests(TransactionTestCase):\n+    available_apps = [\n+        \"django.contrib.contenttypes\",\n+        \"django.contrib.auth\",\n+        \"auth_tests\",\n+    ]\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+        self.addCleanup(\n+            models.signals.post_migrate.disconnect,\n+            self.assertOperationsInjected,\n+            sender=app_config,\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.RenameModel):\n+                    next_operation = next(operations)\n+                    self.assertIsInstance(next_operation, RenamePermission)\n+                    self.assertEqual(next_operation.app_label, migration.app_label)\n+                    self.assertEqual(next_operation.old_model, operation.old_name)\n+                    self.assertEqual(next_operation.new_model, operation.new_name)\n+\n+    def test_permission_rename(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        actions = [\"add\", \"change\", \"delete\", \"view\"]\n+        for action in actions:\n+            Permission.objects.create(\n+                codename=f\"{action}_oldmodel\",\n+                name=f\"Can {action} old model\",\n+                content_type=ct,\n+            )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+        for action in actions:\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        for action in actions:\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+    @mock.patch(\n+        \"django.db.router.allow_migrate_model\",\n+        return_value=False,\n+    )\n+    def test_rename_skipped_if_router_disallows(self, _):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+        # The rename operation should not be there when disallowed by router.\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.disconnect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(Permission.objects.filter(codename=\"change_oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+    def test_rename_backward_does_nothing_if_no_permissions(self):\n+        Permission.objects.filter(content_type__app_label=\"auth_tests\").delete()\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(\n+            Permission.objects.filter(\n+                codename__in=[\"change_oldmodel\", \"change_newmodel\"]\n+            ).exists()\n+        )\n+\n+    def test_rename_permission_conflict(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_newmodel\",\n+            name=\"Can change new model\",\n+            content_type=ct,\n+        )\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(\n+            Permission.objects.filter(\n+                codename=\"change_oldmodel\",\n+                name=\"Can change old model\",\n+            ).exists()\n+        )\n+        self.assertEqual(\n+            Permission.objects.filter(\n+                codename=\"change_newmodel\",\n+                name=\"Can change new model\",\n+            ).count(),\n+            1,\n+        )",
      "comment": "This test could use an explanatory docstring and/or inline comments. It fails on Snowflake (because Snowflake doesn't support unique constraints, I think) and it's not obvious to me exactly what scenario the test is simulating. I'm guessing \"change_oldmodel\" can't be renamed to \"change_newmodel\" because it already exists, but there is no explanation of why the permission would already exist (related to my other comment).\r\n\r\nOn Snowflake, I've seen the test fail like this:\r\n```\r\n======================================================================\r\nFAIL: test_rename_permission_conflict (auth_tests.test_management.PermissionRenameOperationsTests.test_rename_permission_conflict)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"/home/tim/code/django/tests/auth_tests/test_management.py\", line 1702, in test_rename_permission_conflict\r\n    self.assertTrue(\r\nAssertionError: False is not true\r\n```\r\nAnd then like this subsequently (I use `--keepdb`) so probably the test isn't isolated in this case.\r\n```\r\n======================================================================\r\nFAIL: test_rename_permission_conflict (auth_tests.test_management.PermissionRenameOperationsTests.test_rename_permission_conflict)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"/home/tim/code/django/tests/auth_tests/test_management.py\", line 1708, in test_rename_permission_conflict\r\n    self.assertEqual(\r\nAssertionError: 2 != 1\r\n```",
      "comment_id": 2566927400,
      "user": "timgraham",
      "created_at": "2025-11-27T01:42:23Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2566927400"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1693,
      "side": "RIGHT",
      "diff_hunk": "@@ -1528,6 +1534,174 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+@override_settings(\n+    MIGRATION_MODULES=dict(\n+        settings.MIGRATION_MODULES,\n+        auth_tests=\"auth_tests.operations_migrations\",\n+    ),\n+)\n+class PermissionRenameOperationsTests(TransactionTestCase):\n+    available_apps = [\n+        \"django.contrib.contenttypes\",\n+        \"django.contrib.auth\",\n+        \"auth_tests\",\n+    ]\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+        self.addCleanup(\n+            models.signals.post_migrate.disconnect,\n+            self.assertOperationsInjected,\n+            sender=app_config,\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.RenameModel):\n+                    next_operation = next(operations)\n+                    self.assertIsInstance(next_operation, RenamePermission)\n+                    self.assertEqual(next_operation.app_label, migration.app_label)\n+                    self.assertEqual(next_operation.old_model, operation.old_name)\n+                    self.assertEqual(next_operation.new_model, operation.new_name)\n+\n+    def test_permission_rename(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        actions = [\"add\", \"change\", \"delete\", \"view\"]\n+        for action in actions:\n+            Permission.objects.create(\n+                codename=f\"{action}_oldmodel\",\n+                name=f\"Can {action} old model\",\n+                content_type=ct,\n+            )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+        for action in actions:\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        for action in actions:\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+    @mock.patch(\n+        \"django.db.router.allow_migrate_model\",\n+        return_value=False,\n+    )\n+    def test_rename_skipped_if_router_disallows(self, _):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+        # The rename operation should not be there when disallowed by router.\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.disconnect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(Permission.objects.filter(codename=\"change_oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+    def test_rename_backward_does_nothing_if_no_permissions(self):\n+        Permission.objects.filter(content_type__app_label=\"auth_tests\").delete()\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(\n+            Permission.objects.filter(\n+                codename__in=[\"change_oldmodel\", \"change_newmodel\"]\n+            ).exists()\n+        )\n+\n+    def test_rename_permission_conflict(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_newmodel\",\n+            name=\"Can change new model\",\n+            content_type=ct,\n+        )\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(\n+            Permission.objects.filter(\n+                codename=\"change_oldmodel\",\n+                name=\"Can change old model\",\n+            ).exists()\n+        )\n+        self.assertEqual(\n+            Permission.objects.filter(\n+                codename=\"change_newmodel\",\n+                name=\"Can change new model\",\n+            ).count(),\n+            1,\n+        )",
      "comment": "We need this test because previously the migration would create new permissions instead of renaming existing ones. This could leave unused permissions in the database, which might trigger integrity errors if duplicates exist.",
      "comment_id": 2567306885,
      "user": "artirix1927",
      "created_at": "2025-11-27T06:22:34Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2567306885"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1693,
      "side": "RIGHT",
      "diff_hunk": "@@ -1528,6 +1534,174 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+@override_settings(\n+    MIGRATION_MODULES=dict(\n+        settings.MIGRATION_MODULES,\n+        auth_tests=\"auth_tests.operations_migrations\",\n+    ),\n+)\n+class PermissionRenameOperationsTests(TransactionTestCase):\n+    available_apps = [\n+        \"django.contrib.contenttypes\",\n+        \"django.contrib.auth\",\n+        \"auth_tests\",\n+    ]\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+        self.addCleanup(\n+            models.signals.post_migrate.disconnect,\n+            self.assertOperationsInjected,\n+            sender=app_config,\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.RenameModel):\n+                    next_operation = next(operations)\n+                    self.assertIsInstance(next_operation, RenamePermission)\n+                    self.assertEqual(next_operation.app_label, migration.app_label)\n+                    self.assertEqual(next_operation.old_model, operation.old_name)\n+                    self.assertEqual(next_operation.new_model, operation.new_name)\n+\n+    def test_permission_rename(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        actions = [\"add\", \"change\", \"delete\", \"view\"]\n+        for action in actions:\n+            Permission.objects.create(\n+                codename=f\"{action}_oldmodel\",\n+                name=f\"Can {action} old model\",\n+                content_type=ct,\n+            )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+        for action in actions:\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        for action in actions:\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+    @mock.patch(\n+        \"django.db.router.allow_migrate_model\",\n+        return_value=False,\n+    )\n+    def test_rename_skipped_if_router_disallows(self, _):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+        # The rename operation should not be there when disallowed by router.\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.disconnect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(Permission.objects.filter(codename=\"change_oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+    def test_rename_backward_does_nothing_if_no_permissions(self):\n+        Permission.objects.filter(content_type__app_label=\"auth_tests\").delete()\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(\n+            Permission.objects.filter(\n+                codename__in=[\"change_oldmodel\", \"change_newmodel\"]\n+            ).exists()\n+        )\n+\n+    def test_rename_permission_conflict(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_newmodel\",\n+            name=\"Can change new model\",\n+            content_type=ct,\n+        )\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(\n+            Permission.objects.filter(\n+                codename=\"change_oldmodel\",\n+                name=\"Can change old model\",\n+            ).exists()\n+        )\n+        self.assertEqual(\n+            Permission.objects.filter(\n+                codename=\"change_newmodel\",\n+                name=\"Can change new model\",\n+            ).count(),\n+            1,\n+        )",
      "comment": "```======================================================================\r\nFAIL: test_rename_permission_conflict (auth_tests.test_management.PermissionRenameOperationsTests.test_rename_permission_conflict)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"/home/tim/code/django/tests/auth_tests/test_management.py\", line 1708, in test_rename_permission_conflict\r\n    self.assertEqual(\r\nAssertionError: 2 != 1\r\n```\r\n\r\n\r\nYou get this only on the second run only?",
      "comment_id": 2567344147,
      "user": "artirix1927",
      "created_at": "2025-11-27T06:43:32Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2567344147"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1693,
      "side": "RIGHT",
      "diff_hunk": "@@ -1528,6 +1534,174 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+@override_settings(\n+    MIGRATION_MODULES=dict(\n+        settings.MIGRATION_MODULES,\n+        auth_tests=\"auth_tests.operations_migrations\",\n+    ),\n+)\n+class PermissionRenameOperationsTests(TransactionTestCase):\n+    available_apps = [\n+        \"django.contrib.contenttypes\",\n+        \"django.contrib.auth\",\n+        \"auth_tests\",\n+    ]\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+        self.addCleanup(\n+            models.signals.post_migrate.disconnect,\n+            self.assertOperationsInjected,\n+            sender=app_config,\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.RenameModel):\n+                    next_operation = next(operations)\n+                    self.assertIsInstance(next_operation, RenamePermission)\n+                    self.assertEqual(next_operation.app_label, migration.app_label)\n+                    self.assertEqual(next_operation.old_model, operation.old_name)\n+                    self.assertEqual(next_operation.new_model, operation.new_name)\n+\n+    def test_permission_rename(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        actions = [\"add\", \"change\", \"delete\", \"view\"]\n+        for action in actions:\n+            Permission.objects.create(\n+                codename=f\"{action}_oldmodel\",\n+                name=f\"Can {action} old model\",\n+                content_type=ct,\n+            )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+        for action in actions:\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        for action in actions:\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+    @mock.patch(\n+        \"django.db.router.allow_migrate_model\",\n+        return_value=False,\n+    )\n+    def test_rename_skipped_if_router_disallows(self, _):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+        # The rename operation should not be there when disallowed by router.\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.disconnect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(Permission.objects.filter(codename=\"change_oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+    def test_rename_backward_does_nothing_if_no_permissions(self):\n+        Permission.objects.filter(content_type__app_label=\"auth_tests\").delete()\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(\n+            Permission.objects.filter(\n+                codename__in=[\"change_oldmodel\", \"change_newmodel\"]\n+            ).exists()\n+        )\n+\n+    def test_rename_permission_conflict(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_newmodel\",\n+            name=\"Can change new model\",\n+            content_type=ct,\n+        )\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(\n+            Permission.objects.filter(\n+                codename=\"change_oldmodel\",\n+                name=\"Can change old model\",\n+            ).exists()\n+        )\n+        self.assertEqual(\n+            Permission.objects.filter(\n+                codename=\"change_newmodel\",\n+                name=\"Can change new model\",\n+            ).count(),\n+            1,\n+        )",
      "comment": "If I understand correctly, the test simulates a pre-Django 6.0 database where duplicate permissions exist after \"oldmodel\" was renamed to \"newmodel\". The ignoring of IntegrityError handles the case where \"newmodel\" is renamed back to \"oldmodel\". In this case, is there anything to update user-permission relations to point to the \"oldmodel\" permission? If not, it might be better not to let this issue pass silently.",
      "comment_id": 2572257963,
      "user": "timgraham",
      "created_at": "2025-11-28T18:07:12Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2572257963"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1659,
      "side": "RIGHT",
      "diff_hunk": "@@ -1528,6 +1534,174 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+@override_settings(\n+    MIGRATION_MODULES=dict(\n+        settings.MIGRATION_MODULES,\n+        auth_tests=\"auth_tests.operations_migrations\",\n+    ),\n+)\n+class PermissionRenameOperationsTests(TransactionTestCase):\n+    available_apps = [\n+        \"django.contrib.contenttypes\",\n+        \"django.contrib.auth\",\n+        \"auth_tests\",\n+    ]\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+        self.addCleanup(\n+            models.signals.post_migrate.disconnect,\n+            self.assertOperationsInjected,\n+            sender=app_config,\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.RenameModel):\n+                    next_operation = next(operations)\n+                    self.assertIsInstance(next_operation, RenamePermission)\n+                    self.assertEqual(next_operation.app_label, migration.app_label)\n+                    self.assertEqual(next_operation.old_model, operation.old_name)\n+                    self.assertEqual(next_operation.new_model, operation.new_name)\n+\n+    def test_permission_rename(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        actions = [\"add\", \"change\", \"delete\", \"view\"]\n+        for action in actions:\n+            Permission.objects.create(\n+                codename=f\"{action}_oldmodel\",\n+                name=f\"Can {action} old model\",\n+                content_type=ct,\n+            )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+        for action in actions:\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        for action in actions:\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+    @mock.patch(\n+        \"django.db.router.allow_migrate_model\",\n+        return_value=False,\n+    )\n+    def test_rename_skipped_if_router_disallows(self, _):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+        # The rename operation should not be there when disallowed by router.\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.disconnect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(Permission.objects.filter(codename=\"change_oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+    def test_rename_backward_does_nothing_if_no_permissions(self):\n+        Permission.objects.filter(content_type__app_label=\"auth_tests\").delete()\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(\n+            Permission.objects.filter(\n+                codename__in=[\"change_oldmodel\", \"change_newmodel\"]\n+            ).exists()\n+        )",
      "comment": "I think this test isn't written properly because migrating to zero with no migrations applied doesn't do anything and so no `RenamePermission` operations are injected.",
      "comment_id": 2572260857,
      "user": "timgraham",
      "created_at": "2025-11-28T18:09:25Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2572260857"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1659,
      "side": "RIGHT",
      "diff_hunk": "@@ -1528,6 +1534,174 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+@override_settings(\n+    MIGRATION_MODULES=dict(\n+        settings.MIGRATION_MODULES,\n+        auth_tests=\"auth_tests.operations_migrations\",\n+    ),\n+)\n+class PermissionRenameOperationsTests(TransactionTestCase):\n+    available_apps = [\n+        \"django.contrib.contenttypes\",\n+        \"django.contrib.auth\",\n+        \"auth_tests\",\n+    ]\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+        self.addCleanup(\n+            models.signals.post_migrate.disconnect,\n+            self.assertOperationsInjected,\n+            sender=app_config,\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.RenameModel):\n+                    next_operation = next(operations)\n+                    self.assertIsInstance(next_operation, RenamePermission)\n+                    self.assertEqual(next_operation.app_label, migration.app_label)\n+                    self.assertEqual(next_operation.old_model, operation.old_name)\n+                    self.assertEqual(next_operation.new_model, operation.new_name)\n+\n+    def test_permission_rename(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        actions = [\"add\", \"change\", \"delete\", \"view\"]\n+        for action in actions:\n+            Permission.objects.create(\n+                codename=f\"{action}_oldmodel\",\n+                name=f\"Can {action} old model\",\n+                content_type=ct,\n+            )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+        for action in actions:\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        for action in actions:\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+    @mock.patch(\n+        \"django.db.router.allow_migrate_model\",\n+        return_value=False,\n+    )\n+    def test_rename_skipped_if_router_disallows(self, _):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+        # The rename operation should not be there when disallowed by router.\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.disconnect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(Permission.objects.filter(codename=\"change_oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+    def test_rename_backward_does_nothing_if_no_permissions(self):\n+        Permission.objects.filter(content_type__app_label=\"auth_tests\").delete()\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(\n+            Permission.objects.filter(\n+                codename__in=[\"change_oldmodel\", \"change_newmodel\"]\n+            ).exists()\n+        )",
      "comment": "You were right \u2014 I\u2019ve updated the test and modified the migration so that when an IntegrityError occurs, duplicate user/group assignments are correctly transferred to the new permission and delete the old one. What\u2019s the best way to open a PR with these fixes? Should I still reference ticket #27489, or can I just submit the fixes directly?",
      "comment_id": 2572706254,
      "user": "artirix1927",
      "created_at": "2025-11-29T01:22:26Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2572706254"
    },
    {
      "repo": "django/django",
      "pr_number": 19405,
      "file_path": "tests/auth_tests/test_management.py",
      "line": 1659,
      "side": "RIGHT",
      "diff_hunk": "@@ -1528,6 +1534,174 @@ def test_permission_with_proxy_content_type_created(self):\n         )\n \n \n+@override_settings(\n+    MIGRATION_MODULES=dict(\n+        settings.MIGRATION_MODULES,\n+        auth_tests=\"auth_tests.operations_migrations\",\n+    ),\n+)\n+class PermissionRenameOperationsTests(TransactionTestCase):\n+    available_apps = [\n+        \"django.contrib.contenttypes\",\n+        \"django.contrib.auth\",\n+        \"auth_tests\",\n+    ]\n+\n+    def setUp(self):\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.connect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+        self.addCleanup(\n+            models.signals.post_migrate.disconnect,\n+            self.assertOperationsInjected,\n+            sender=app_config,\n+        )\n+\n+    def assertOperationsInjected(self, plan, **kwargs):\n+        for migration, _backward in plan:\n+            operations = iter(migration.operations)\n+            for operation in operations:\n+                if isinstance(operation, migrations.RenameModel):\n+                    next_operation = next(operations)\n+                    self.assertIsInstance(next_operation, RenamePermission)\n+                    self.assertEqual(next_operation.app_label, migration.app_label)\n+                    self.assertEqual(next_operation.old_model, operation.old_name)\n+                    self.assertEqual(next_operation.new_model, operation.new_name)\n+\n+    def test_permission_rename(self):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        actions = [\"add\", \"change\", \"delete\", \"view\"]\n+        for action in actions:\n+            Permission.objects.create(\n+                codename=f\"{action}_oldmodel\",\n+                name=f\"Can {action} old model\",\n+                content_type=ct,\n+            )\n+\n+        call_command(\"migrate\", \"auth_tests\", verbosity=0)\n+        for action in actions:\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+        for action in actions:\n+            self.assertTrue(\n+                Permission.objects.filter(codename=f\"{action}_oldmodel\").exists()\n+            )\n+            self.assertFalse(\n+                Permission.objects.filter(codename=f\"{action}_newmodel\").exists()\n+            )\n+\n+    @mock.patch(\n+        \"django.db.router.allow_migrate_model\",\n+        return_value=False,\n+    )\n+    def test_rename_skipped_if_router_disallows(self, _):\n+        ct = ContentType.objects.create(app_label=\"auth_tests\", model=\"oldmodel\")\n+        Permission.objects.create(\n+            codename=\"change_oldmodel\",\n+            name=\"Can change old model\",\n+            content_type=ct,\n+        )\n+        # The rename operation should not be there when disallowed by router.\n+        app_config = apps.get_app_config(\"auth_tests\")\n+        models.signals.post_migrate.disconnect(\n+            self.assertOperationsInjected, sender=app_config\n+        )\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertTrue(Permission.objects.filter(codename=\"change_oldmodel\").exists())\n+        self.assertFalse(Permission.objects.filter(codename=\"change_newmodel\").exists())\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+\n+    def test_rename_backward_does_nothing_if_no_permissions(self):\n+        Permission.objects.filter(content_type__app_label=\"auth_tests\").delete()\n+\n+        call_command(\n+            \"migrate\",\n+            \"auth_tests\",\n+            \"zero\",\n+            database=\"default\",\n+            interactive=False,\n+            verbosity=0,\n+        )\n+        self.assertFalse(\n+            Permission.objects.filter(\n+                codename__in=[\"change_oldmodel\", \"change_newmodel\"]\n+            ).exists()\n+        )",
      "comment": "You can use \"Refs #27489 -- ...\" since the fix hasn't made it to a stable release yet, otherwise, we would use a new ticket.",
      "comment_id": 2572766716,
      "user": "timgraham",
      "created_at": "2025-11-29T03:01:04Z",
      "url": "https://github.com/django/django/pull/19405#discussion_r2572766716"
    },
    {
      "repo": "django/django",
      "pr_number": 19947,
      "file_path": "tests/expressions/tests.py",
      "line": 2915,
      "side": "RIGHT",
      "diff_hunk": "@@ -2911,6 +2912,47 @@ def test_non_empty_group_by(self):\n         self.assertEqual(group_by_cols[0].output_field, expr.output_field)\n \n \n+class DateFieldTimedeltaTests(TestCase):",
      "comment": "I think this can just be a documentation PR. The tests are date field specific, but this file tests the general behavior of expressions.",
      "comment_id": 2432822889,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-15T14:35:51Z",
      "url": "https://github.com/django/django/pull/19947#discussion_r2432822889"
    },
    {
      "repo": "django/django",
      "pr_number": 19947,
      "file_path": "tests/expressions/tests.py",
      "line": 2941,
      "side": "RIGHT",
      "diff_hunk": "@@ -2911,6 +2912,47 @@ def test_non_empty_group_by(self):\n         self.assertEqual(group_by_cols[0].output_field, expr.output_field)\n \n \n+class DateFieldTimedeltaTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.test_date = datetime.date(2025, 10, 11)\n+        cls.experiment = Experiment.objects.create(\n+            name=\"DateField Test\",\n+            assigned=cls.test_date,\n+            start=datetime.datetime(2025, 10, 11, 18, 0, 0),\n+            end=datetime.datetime(2025, 10, 13, 18, 0, 0),\n+            completed=datetime.date(2025, 10, 13),\n+            estimated_time=datetime.timedelta(days=2),\n+        )\n+\n+    def test_datefield_timedelta_with_cast(self):\n+        \"\"\"Cast ensures date type when subtracting timedelta from DateField.\"\"\"\n+        qs = Experiment.objects.annotate(\n+            next_day=Cast(\n+                F(\"assigned\") + datetime.timedelta(days=1),\n+                output_field=DateField(),\n+            )\n+        )\n+        result = qs.first().next_day\n+        self.assertIsInstance(result, datetime.date)\n+        self.assertNotIsInstance(result, datetime.datetime)\n+        self.assertEqual(result, datetime.date(2025, 10, 12))\n+\n+    @unittest.skipUnless(connection.vendor == \"postgresql\", \"PostgreSQL only\")",
      "comment": "In general we don't add tests that memorialize database quirks. (If we did, we'd want to include mysql also.)",
      "comment_id": 2432824716,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-15T14:36:17Z",
      "url": "https://github.com/django/django/pull/19947#discussion_r2432824716"
    },
    {
      "repo": "django/django",
      "pr_number": 18637,
      "file_path": "tests/gis_tests/geoapp/models.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,6 +28,13 @@ class Meta:\n         app_label = \"geoapp\"\n \n \n+class City3d(NamedModel):\n+    point = models.PointField(dim=3)\n+\n+    class Meta:\n+        app_label = \"geoapp\"\n+\n+",
      "comment": "Do you really need to create a new model? Isn't `ThreeDimensionalFeature` usable for the tests?",
      "comment_id": 1780482246,
      "user": "claudep",
      "created_at": "2024-09-30T06:05:15Z",
      "url": "https://github.com/django/django/pull/18637#discussion_r1780482246"
    },
    {
      "repo": "django/django",
      "pr_number": 20286,
      "file_path": "django/db/models/fields/related.py",
      "line": 1079,
      "side": "RIGHT",
      "diff_hunk": "@@ -1056,9 +1057,43 @@ def check(self, **kwargs):\n             *self._check_unique(),\n         ]\n \n+    def _check_on_delete_db_support(self, on_delete, feature_flag, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, self.model):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                feature_flag in self.model._meta.required_db_features\n+                or getattr(connection.features, feature_flag)\n+            ):\n+                no_db_option_name = on_delete.__name__.removeprefix(\"DB_\")\n+                errors.append(\n+                    checks.Error(\n+                        f\"{connection.display_name} does not support a \"\n+                        f\"{on_delete.__name__}.\",\n+                        hint=f\"Change the on_delete rule to {no_db_option_name}.\",\n+                        obj=self,\n+                        id=\"fields.E324\",\n+                    ),\n+                )",
      "comment": "```suggestion\r\n            if (\r\n                feature_flag in self.model._meta.required_db_features\r\n                or getattr(connection.features, feature_flag)\r\n            ):\r\n                continue\r\n            no_db_option_name = on_delete.__name__.removeprefix(\"DB_\")\r\n            errors.append(\r\n                checks.Error(\r\n                    f\"{connection.display_name} does not support a \"\r\n                    f\"{on_delete.__name__}.\",\r\n                    hint=f\"Change the on_delete rule to {no_db_option_name}.\",\r\n                    obj=self,\r\n                    id=\"fields.E324\",\r\n                ),\r\n            )\r\n```",
      "comment_id": 2553904847,
      "user": "LilyFirefly",
      "created_at": "2025-11-23T09:20:24Z",
      "url": "https://github.com/django/django/pull/20286#discussion_r2553904847"
    },
    {
      "repo": "django/django",
      "pr_number": 20286,
      "file_path": "django/db/models/fields/related.py",
      "line": 1079,
      "side": "RIGHT",
      "diff_hunk": "@@ -1056,9 +1057,43 @@ def check(self, **kwargs):\n             *self._check_unique(),\n         ]\n \n+    def _check_on_delete_db_support(self, on_delete, feature_flag, databases):\n+        errors = []\n+        for db in databases:\n+            if not router.allow_migrate_model(db, self.model):\n+                continue\n+            connection = connections[db]\n+            if not (\n+                feature_flag in self.model._meta.required_db_features\n+                or getattr(connection.features, feature_flag)\n+            ):\n+                no_db_option_name = on_delete.__name__.removeprefix(\"DB_\")\n+                errors.append(\n+                    checks.Error(\n+                        f\"{connection.display_name} does not support a \"\n+                        f\"{on_delete.__name__}.\",\n+                        hint=f\"Change the on_delete rule to {no_db_option_name}.\",\n+                        obj=self,\n+                        id=\"fields.E324\",\n+                    ),\n+                )",
      "comment": "We could also make this helper method a generator and `yield` the `Error`s.",
      "comment_id": 2553909821,
      "user": "LilyFirefly",
      "created_at": "2025-11-23T09:22:25Z",
      "url": "https://github.com/django/django/pull/20286#discussion_r2553909821"
    },
    {
      "repo": "django/django",
      "pr_number": 20303,
      "file_path": "tests/expressions/tests.py",
      "line": 1575,
      "side": "RIGHT",
      "diff_hunk": "@@ -1571,6 +1571,24 @@ def test_get_expression_for_validation_only_one_source_expression(self):\n         with self.assertRaisesMessage(ValueError, msg):\n             expression.get_expression_for_validation()\n \n+    def test_replace_expressions_falsey(self):\n+        class AssignableExpression(Expression):",
      "comment": "I wanted to use `Expression` directly but it doesn't allow assignment of `source_expressions`\r\n\r\nhttps://github.com/django/django/blob/ec60df6d1ea8939a316d9b180faa0b4ef2e83606/django/db/models/expressions.py#L212-L213",
      "comment_id": 2554485923,
      "user": "charettes",
      "created_at": "2025-11-24T01:44:23Z",
      "url": "https://github.com/django/django/pull/20303#discussion_r2554485923"
    },
    {
      "repo": "django/django",
      "pr_number": 20303,
      "file_path": "tests/expressions/tests.py",
      "line": 1587,
      "side": "RIGHT",
      "diff_hunk": "@@ -1571,6 +1571,24 @@ def test_get_expression_for_validation_only_one_source_expression(self):\n         with self.assertRaisesMessage(ValueError, msg):\n             expression.get_expression_for_validation()\n \n+    def test_replace_expressions_falsey(self):\n+        class AssignableExpression(Expression):\n+            def __init__(self, *source_expressions):\n+                super().__init__()\n+                self.set_source_expressions(list(source_expressions))\n+\n+            def get_source_expressions(self):\n+                return self.source_expressions\n+\n+            def set_source_expressions(self, exprs):\n+                self.source_expressions = exprs\n+\n+        expression = AssignableExpression()\n+        falsey = Q()",
      "comment": "We could use any object with a `__bool__() -> False` but I figured it was simpler to use `Q` directly since it's the case that triggered the reported problem.",
      "comment_id": 2554486756,
      "user": "charettes",
      "created_at": "2025-11-24T01:45:50Z",
      "url": "https://github.com/django/django/pull/20303#discussion_r2554486756"
    },
    {
      "repo": "django/django",
      "pr_number": 20303,
      "file_path": "django/db/models/expressions.py",
      "line": 429,
      "side": "RIGHT",
      "diff_hunk": "@@ -426,7 +426,7 @@ def replace_expressions(self, replacements):\n         clone = self.copy()\n         clone.set_source_expressions(\n             [\n-                expr.replace_expressions(replacements) if expr else None\n+                None if expr is None else expr.replace_expressions(replacements)",
      "comment": "As mentionned in the commit message this would have caused objects such as `QuerySet` to be evaluated as replacement as well (since `QuerySet.__bool__` executes the query).",
      "comment_id": 2554487267,
      "user": "charettes",
      "created_at": "2025-11-24T01:46:42Z",
      "url": "https://github.com/django/django/pull/20303#discussion_r2554487267"
    },
    {
      "repo": "django/django",
      "pr_number": 20290,
      "file_path": "tests/template_tests/filter_tests/test_urlize.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,6 +218,13 @@ def test_parenthesis(self):\n             'rel=\"nofollow\">https://en.wikipedia.org/wiki/Django_(web_framework)</a>)',\n         )\n \n+    def test_parenthesis_and_bracket(self):\n+        self.assertEqual(\n+            urlize(\"[(https://en.wikipedia.org/)]\"),\n+            '[(<a href=\"https://en.wikipedia.org/\" '\n+            'rel=\"nofollow\">https://en.wikipedia.org/</a>)]',",
      "comment": "Before, this final bracket at the end of the string was missing.",
      "comment_id": 2550143280,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-21T15:30:58Z",
      "url": "https://github.com/django/django/pull/20290#discussion_r2550143280"
    },
    {
      "repo": "django/django",
      "pr_number": 20045,
      "file_path": "django/utils/http.py",
      "line": 176,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,11 +169,11 @@ def int_to_base36(i):\n         raise ValueError(\"Negative base36 conversion input.\")\n     if i < 36:\n         return char_set[i]\n-    b36 = \"\"\n+    b36 = []\n     while i != 0:\n         i, n = divmod(i, 36)\n-        b36 = char_set[n] + b36\n-    return b36\n+        b36.append(char_set[n])\n+    return \"\".join(reversed(b36))",
      "comment": "I get appending and finally reversing to avoid `insert()`, but in that case I think we need to update the `b36` variable name.",
      "comment_id": 2499937378,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-06T17:04:33Z",
      "url": "https://github.com/django/django/pull/20045#discussion_r2499937378"
    },
    {
      "repo": "django/django",
      "pr_number": 20045,
      "file_path": "django/utils/html.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -442,7 +443,7 @@ def trim_punctuation(self, word):\n                     rstripped = middle.rstrip(closing)\n                     if rstripped != middle:\n                         strip = counts[closing] - counts[opening]\n-                        trail = middle[-strip:]\n+                        trail.appendleft(middle[-strip:])",
      "comment": "This seems like a wrong transformation - we don't want to append, but fully replace\u2026? So more like:\n\n```python\ntrail.clear()\ntrail.append(middle[-strip:])\n```",
      "comment_id": 2544009071,
      "user": "adamchainz",
      "created_at": "2025-11-20T01:07:42Z",
      "url": "https://github.com/django/django/pull/20045#discussion_r2544009071"
    },
    {
      "repo": "django/django",
      "pr_number": 20045,
      "file_path": "django/utils/html.py",
      "line": 446,
      "side": "RIGHT",
      "diff_hunk": "@@ -442,7 +443,7 @@ def trim_punctuation(self, word):\n                     rstripped = middle.rstrip(closing)\n                     if rstripped != middle:\n                         strip = counts[closing] - counts[opening]\n-                        trail = middle[-strip:]\n+                        trail.appendleft(middle[-strip:])",
      "comment": "Thanks @adamchainz, good eye.\n\nAlthough this is a logic change, I'm wondering if it fixed a bug.\n\nBefore (i.e. with #20045):\n```py\n>>> Urlizer()(\"([https://djangoproject.com])\")\n'([<a href=\"https://djangoproject.com\">https://djangoproject.com</a>])'\n```\n\n\nWith adding `trail.clear()` to \"fix\" the accidental change, wrong result, missing final \")\":\n```py\n>>> Urlizer()(\"([https://djangoproject.com])\")\n'([<a href=\"https://djangoproject.com\">https://djangoproject.com</a>]'\n```\n\nThe missing trailing character is also missing on stable/6.0.x\n\nDo you agree we should add a test case to capture?",
      "comment_id": 2547729992,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-20T21:31:55Z",
      "url": "https://github.com/django/django/pull/20045#discussion_r2547729992"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/backends/base/schema.py",
      "line": 1638,
      "side": "RIGHT",
      "diff_hunk": "@@ -1628,6 +1630,13 @@ def _rename_index_sql(self, model, old_name, new_name):\n             new_name=self.quote_name(new_name),\n         )\n \n+    def _create_on_delete_sql(self, model, field):\n+        if (on_delete_db := getattr(field.remote_field, \"on_delete\", None)) and hasattr(\n+            on_delete_db, \"on_delete_sql\"\n+        ):\n+            return on_delete_db.on_delete_sql(self)\n+        return \"\"",
      "comment": "I find this a bit easier to read:\r\n\r\n```suggestion\r\n        remote_field = field.remote_field\r\n        try:\r\n            on_delete_sql = remote_field.on_delete.on_delete_sql\r\n        except AttributeError:\r\n            return \"\"\r\n        return on_delete_sql(self)\r\n```",
      "comment_id": 2413496071,
      "user": "LilyFirefly",
      "created_at": "2025-10-08T11:09:24Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2413496071"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/models/deletion.py",
      "line": 349,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,8 +347,13 @@ def collect(\n                 continue\n             field = related.field\n             on_delete = field.remote_field.on_delete\n-            if on_delete == DO_NOTHING:\n-                continue\n+            if on_delete in SKIP_COLLECTION:\n+                if self.force_collection and (\n+                    forced_on_delete := getattr(on_delete, \"forced_collector\", None)\n+                ):\n+                    on_delete = forced_on_delete",
      "comment": "```suggestion\r\n                if self.force_collection:\r\n                    on_delete = getattr(on_delete, \"forced_collector\", on_delete)\r\n```",
      "comment_id": 2413500954,
      "user": "LilyFirefly",
      "created_at": "2025-10-08T11:11:35Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2413500954"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/contrib/contenttypes/fields.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -138,6 +139,19 @@ def _check_content_type_field(self):\n                         id=\"contenttypes.E004\",\n                     )\n                 ]\n+            elif isinstance(field.remote_field.on_delete, DatabaseOnDelete):\n+                return [\n+                    checks.Error(\n+                        f\"'{self.model._meta.object_name}.{self.ct_field}' cannot use \"\n+                        \"the database-level on_delete variant.\",\n+                        hint=\"Change the on_delete rule to non-database variant.\",\n+                        obj=self,\n+                        id=\"contenttypes.E006\",\n+                    )\n+                ]\n+                raise ValueError(\n+                    \"The GenericForeignKey  cannot use database-level on_delete option.\"",
      "comment": "```suggestion\n                    \"GenericForeignKey can't use database-level `on_delete` options.\"\n```",
      "comment_id": 2422052384,
      "user": "charettes",
      "created_at": "2025-10-10T20:45:28Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2422052384"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/invalid_models_tests/test_relative_fields.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,7 +3,8 @@\n from django.core.checks import Error\n from django.core.checks import Warning as DjangoWarning\n from django.db import connection, models\n-from django.test.testcases import SimpleTestCase\n+from django.test import skipUnlessDBFeature",
      "comment": "Not related to your changes but this module should be named `test_related_fields`, there's no such thing as a relative field \ud83d\ude05 ",
      "comment_id": 2422056473,
      "user": "charettes",
      "created_at": "2025-10-10T20:48:19Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2422056473"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/contrib/contenttypes/fields.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -138,6 +139,19 @@ def _check_content_type_field(self):\n                         id=\"contenttypes.E004\",\n                     )\n                 ]\n+            elif isinstance(field.remote_field.on_delete, DatabaseOnDelete):\n+                return [\n+                    checks.Error(\n+                        f\"'{self.model._meta.object_name}.{self.ct_field}' cannot use \"\n+                        \"the database-level on_delete variant.\",\n+                        hint=\"Change the on_delete rule to non-database variant.\",\n+                        obj=self,\n+                        id=\"contenttypes.E006\",\n+                    )\n+                ]\n+                raise ValueError(\n+                    \"The GenericForeignKey  cannot use database-level on_delete option.\"",
      "comment": "Sorry, raising `ValueError` was the first idea :facepalm: Removed.",
      "comment_id": 2422100652,
      "user": "felixxm",
      "created_at": "2025-10-10T21:14:12Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2422100652"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/invalid_models_tests/test_relative_fields.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,7 +3,8 @@\n from django.core.checks import Error\n from django.core.checks import Warning as DjangoWarning\n from django.db import connection, models\n-from django.test.testcases import SimpleTestCase\n+from django.test import skipUnlessDBFeature",
      "comment": "Good catch :dart: Let's rename it when this is merged.",
      "comment_id": 2422101773,
      "user": "felixxm",
      "created_at": "2025-10-10T21:14:50Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2422101773"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/contrib/admin/utils.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -185,6 +185,7 @@ def format_callback(obj):\n \n class NestedObjects(Collector):\n     def __init__(self, *args, **kwargs):\n+        kwargs.setdefault(\"force_collection\", True)\n         super().__init__(*args, **kwargs)",
      "comment": "Why not put this in the signature?\n```suggestion\n    def __init__(self, *args, force_collection=True, **kwargs):\n        super().__init__(*args, force_collection=force_collection, **kwargs)\n```",
      "comment_id": 2423173154,
      "user": "adamchainz",
      "created_at": "2025-10-11T22:20:35Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2423173154"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/models/base.py",
      "line": 2441,
      "side": "RIGHT",
      "diff_hunk": "@@ -2421,6 +2422,29 @@ def _check_long_column_names(cls, databases):\n \n         return errors\n \n+    @classmethod\n+    def _check_related_fields(cls):\n+        has_db_variant = False\n+        has_python_variant = False\n+        for rel in cls._meta.get_fields():\n+            if rel.related_model and not rel.auto_created:\n+                if not (on_delete := getattr(rel.remote_field, \"on_delete\", None)):\n+                    continue\n+                if isinstance(on_delete, DatabaseOnDelete):\n+                    has_db_variant = True\n+                else:\n+                    has_python_variant = True\n+                if has_db_variant and has_python_variant:\n+                    return [\n+                        checks.Error(\n+                            \"The model cannot have both related fields with \"\n+                            \"database-level and python-level on_delete variants.\",",
      "comment": "Grammar fix:\n\n```suggestion\n                            \"The model cannot have related fields with both \"\n                            \"database-level and python-level on_delete variants.\",\n```",
      "comment_id": 2423173800,
      "user": "adamchainz",
      "created_at": "2025-10-11T22:22:38Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2423173800"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/contrib/admin/utils.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -185,6 +185,7 @@ def format_callback(obj):\n \n class NestedObjects(Collector):\n     def __init__(self, *args, **kwargs):\n+        kwargs.setdefault(\"force_collection\", True)\n         super().__init__(*args, **kwargs)",
      "comment": "No other reason than this originated from a local iteration session, we should change.",
      "comment_id": 2423740737,
      "user": "charettes",
      "created_at": "2025-10-12T11:56:05Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2423740737"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/delete/tests.py",
      "line": 355,
      "side": "RIGHT",
      "diff_hunk": "@@ -304,6 +342,32 @@ def test_restrict_gfk_no_fast_delete(self):\n         self.assertFalse(GenericB2.objects.exists())\n         self.assertFalse(GenericDeleteBottom.objects.exists())\n \n+    @skipUnlessDBFeature(\"supports_on_delete_db_restrict\")\n+    def test_db_restrict(self):\n+        r = RelatedDbOptionParent.objects.create()\n+        restrict_db_obj = RestrictDbModel.objects.create(\n+            db_restrict=r, name=\"db_restrict\"\n+        )\n+        with self.assertRaises(IntegrityError), transaction.atomic():\n+            restrict_db_obj.db_restrict.delete()\n+\n+    @skipUnlessDBFeature(\"supports_on_delete_db_restrict\")\n+    def test_db_restrict_path_db_cascade_direct(self):",
      "comment": "I wouldn't be surprised if this failed on MySQL because it [has poor foreign key constraint deferral support](https://docs.djangoproject.com/en/5.2/topics/db/fixtures/#:~:text=constraints%20will%20be%20checked%20at%20the%20end%20of%20the%20transaction.%20Any%20relationships).\n\nhttps://github.com/django/django/blob/315dbe675df338ae66c8fa43274a76ecbed7ef67/django/db/backends/base/features.py#L122-L124\n\nI think we'll want to also include `can_defer_constraint_checks`?\n\n\n```suggestion\n    @skipUnlessDBFeatures(\"supports_on_delete_db_restrict\", \"can_defer_constraint_checks\")\n    def test_db_restrict_path_db_cascade_direct(self):\n```",
      "comment_id": 2423757673,
      "user": "charettes",
      "created_at": "2025-10-12T12:01:40Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2423757673"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/delete/tests.py",
      "line": 355,
      "side": "RIGHT",
      "diff_hunk": "@@ -304,6 +342,32 @@ def test_restrict_gfk_no_fast_delete(self):\n         self.assertFalse(GenericB2.objects.exists())\n         self.assertFalse(GenericDeleteBottom.objects.exists())\n \n+    @skipUnlessDBFeature(\"supports_on_delete_db_restrict\")\n+    def test_db_restrict(self):\n+        r = RelatedDbOptionParent.objects.create()\n+        restrict_db_obj = RestrictDbModel.objects.create(\n+            db_restrict=r, name=\"db_restrict\"\n+        )\n+        with self.assertRaises(IntegrityError), transaction.atomic():\n+            restrict_db_obj.db_restrict.delete()\n+\n+    @skipUnlessDBFeature(\"supports_on_delete_db_restrict\")\n+    def test_db_restrict_path_db_cascade_direct(self):",
      "comment": "In other words, since MySQL doesn't support foreign key constraints check deferral its version of `DB_RESTRICT` is kind of an equivalent to our `PROTECTED`.",
      "comment_id": 2423767238,
      "user": "charettes",
      "created_at": "2025-10-12T12:05:00Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2423767238"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/delete/tests.py",
      "line": 355,
      "side": "RIGHT",
      "diff_hunk": "@@ -304,6 +342,32 @@ def test_restrict_gfk_no_fast_delete(self):\n         self.assertFalse(GenericB2.objects.exists())\n         self.assertFalse(GenericDeleteBottom.objects.exists())\n \n+    @skipUnlessDBFeature(\"supports_on_delete_db_restrict\")\n+    def test_db_restrict(self):\n+        r = RelatedDbOptionParent.objects.create()\n+        restrict_db_obj = RestrictDbModel.objects.create(\n+            db_restrict=r, name=\"db_restrict\"\n+        )\n+        with self.assertRaises(IntegrityError), transaction.atomic():\n+            restrict_db_obj.db_restrict.delete()\n+\n+    @skipUnlessDBFeature(\"supports_on_delete_db_restrict\")\n+    def test_db_restrict_path_db_cascade_direct(self):",
      "comment": "More than happy to add this, I've scratched my head why it started to fail :sweat_smile: ",
      "comment_id": 2423771253,
      "user": "felixxm",
      "created_at": "2025-10-12T12:06:21Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2423771253"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/backends/base/operations.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -254,6 +254,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\", \"SET DEFAULT\"]:",
      "comment": "```suggestion\r\n        if operation in {\"CASCADE\", \"RESTRICT\", \"SET DEFAULT\", \"SET NULL\"}:\r\n```\r\nIt's a micro optimization to have a faster check and ordered values to help to read the code.",
      "comment_id": 2425728916,
      "user": "pauloxnet",
      "created_at": "2025-10-13T09:41:49Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2425728916"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/backends/base/schema.py",
      "line": 1636,
      "side": "RIGHT",
      "diff_hunk": "@@ -1628,6 +1630,13 @@ def _rename_index_sql(self, model, old_name, new_name):\n             new_name=self.quote_name(new_name),\n         )\n \n+    def _create_on_delete_sql(self, model, field):\n+        remote_field = field.remote_field\n+        try:\n+            return remote_field.on_delete.on_delete_sql(self)",
      "comment": "```suggestion\r\n        try:\r\n            return field.remote_field.on_delete.on_delete_sql(self)\r\n```\r\nAnother micro optimization, removing a variable used only once.",
      "comment_id": 2425733340,
      "user": "pauloxnet",
      "created_at": "2025-10-13T09:43:45Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2425733340"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/backends/base/operations.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -254,6 +254,17 @@ def limit_offset_sql(self, low_mark, high_mark):\n             if sql\n         )\n \n+    def fk_on_delete_sql(self, operation):\n+        \"\"\"\n+        Return the SQL to make an ON DELETE statement during a CREATE TABLE\n+        statement.\n+        \"\"\"\n+        if operation in [\"CASCADE\", \"SET NULL\", \"RESTRICT\", \"SET DEFAULT\"]:",
      "comment": "Is this actually faster for four elements? It could be that the cost of hashing outweighs the big O behaviour.",
      "comment_id": 2426014824,
      "user": "LilyFirefly",
      "created_at": "2025-10-13T11:19:03Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2426014824"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/backends/base/schema.py",
      "line": 1636,
      "side": "RIGHT",
      "diff_hunk": "@@ -1628,6 +1630,13 @@ def _rename_index_sql(self, model, old_name, new_name):\n             new_name=self.quote_name(new_name),\n         )\n \n+    def _create_on_delete_sql(self, model, field):\n+        remote_field = field.remote_field\n+        try:\n+            return remote_field.on_delete.on_delete_sql(self)",
      "comment": "If `field` doesn't have a `remote_field` attribute, the behaviour will change here.",
      "comment_id": 2426018577,
      "user": "LilyFirefly",
      "created_at": "2025-10-13T11:19:57Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2426018577"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/backends/base/schema.py",
      "line": 1636,
      "side": "RIGHT",
      "diff_hunk": "@@ -1628,6 +1630,13 @@ def _rename_index_sql(self, model, old_name, new_name):\n             new_name=self.quote_name(new_name),\n         )\n \n+    def _create_on_delete_sql(self, model, field):\n+        remote_field = field.remote_field\n+        try:\n+            return remote_field.on_delete.on_delete_sql(self)",
      "comment": "Yes, I wanted to limit catching the `AttributeError` to `on_delete`, that's why `.remote_field` is outside of `try... except`.",
      "comment_id": 2426042214,
      "user": "felixxm",
      "created_at": "2025-10-13T11:24:36Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2426042214"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/contrib/contenttypes/fields.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -138,6 +139,16 @@ def _check_content_type_field(self):\n                         id=\"contenttypes.E004\",\n                     )\n                 ]\n+            elif isinstance(field.remote_field.on_delete, DatabaseOnDelete):\n+                return [\n+                    checks.Error(\n+                        f\"'{self.model._meta.object_name}.{self.ct_field}' cannot use \"\n+                        \"the database-level on_delete variant.\",\n+                        hint=\"Change the on_delete rule to non-database variant.\",",
      "comment": "To match the error\n```suggestion\n                        hint=\"Change the on_delete rule to the non-database variant.\",\n```",
      "comment_id": 2432993897,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-15T15:19:36Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2432993897"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/models/fields/related.py",
      "line": 1156,
      "side": "RIGHT",
      "diff_hunk": "@@ -1041,37 +1049,119 @@ def __class_getitem__(cls, *args, **kwargs):\n         return cls\n \n     def check(self, **kwargs):\n+        databases = kwargs.get(\"databases\") or []\n         return [\n             *super().check(**kwargs),\n-            *self._check_on_delete(),\n+            *self._check_on_delete(databases),\n             *self._check_unique(),\n         ]\n \n-    def _check_on_delete(self):\n+    def _check_on_delete(self, databases):\n         on_delete = getattr(self.remote_field, \"on_delete\", None)\n-        if on_delete == SET_NULL and not self.null:\n-            return [\n+        errors = []\n+        if on_delete in [DB_SET_NULL, SET_NULL] and not self.null:\n+            errors.append(\n                 checks.Error(\n-                    \"Field specifies on_delete=SET_NULL, but cannot be null.\",\n+                    f\"Field specifies on_delete={on_delete.__name__}, but cannot be \"\n+                    \"null.\",\n                     hint=(\n                         \"Set null=True argument on the field, or change the on_delete \"\n                         \"rule.\"\n                     ),\n                     obj=self,\n                     id=\"fields.E320\",\n                 )\n-            ]\n+            )\n         elif on_delete == SET_DEFAULT and not self.has_default():\n-            return [\n+            errors.append(\n                 checks.Error(\n                     \"Field specifies on_delete=SET_DEFAULT, but has no default value.\",\n                     hint=\"Set a default value, or change the on_delete rule.\",\n                     obj=self,\n                     id=\"fields.E321\",\n                 )\n-            ]\n-        else:\n-            return []\n+            )\n+        elif on_delete == DB_SET_DEFAULT:\n+            if self.db_default is NOT_PROVIDED:\n+                errors.append(\n+                    checks.Error(\n+                        \"Field specifies on_delete=DB_SET_DEFAULT, but has \"\n+                        \"no db_default value.\",\n+                        hint=\"Set a db_default value, or change the on_delete rule.\",\n+                        obj=self,\n+                        id=\"fields.E322\",\n+                    )\n+                )\n+            for db in databases:\n+                if not router.allow_migrate_model(db, self.model):\n+                    continue\n+                connection = connections[db]\n+                if not (\n+                    \"supports_on_delete_db_default\"\n+                    in self.model._meta.required_db_features\n+                    or connection.features.supports_on_delete_db_default\n+                ):\n+                    errors.append(\n+                        checks.Error(\n+                            f\"{connection.display_name} does not support a \"\n+                            \"DB_SET_DEFAULT.\",\n+                            hint=\"Change the on_delete rule to SET_DEFAULT.\",\n+                            obj=self,\n+                            id=\"fields.E324\",\n+                        ),\n+                    )\n+        elif on_delete == DB_RESTRICT:\n+            for db in databases:\n+                if not router.allow_migrate_model(db, self.model):\n+                    continue\n+                connection = connections[db]\n+                if not (\n+                    \"supports_on_delete_db_restrict\"\n+                    in self.model._meta.required_db_features\n+                    or connection.features.supports_on_delete_db_restrict\n+                ):\n+                    errors.append(\n+                        checks.Error(\n+                            f\"{connection.display_name} does not support a \"\n+                            \"DB_RESTRICT.\",\n+                            hint=\"Change the on_delete rule to RESTRICT.\",\n+                            obj=self,\n+                            id=\"fields.E324\",\n+                        ),\n+                    )\n+        elif not isinstance(self.remote_field.model, str):\n+            # Database and Python variants cannot be mixed in a chain of\n+            # model references.\n+            is_db_on_delete = isinstance(on_delete, DatabaseOnDelete)\n+            ref_model_related_fields = (\n+                ref_model_field.remote_field\n+                for ref_model_field in self.remote_field.model._meta.get_fields()\n+                if ref_model_field.related_model and not ref_model_field.auto_created\n+            )\n+\n+            for ref_remote_field in ref_model_related_fields:\n+                if (\n+                    ref_remote_field.on_delete is not None\n+                    and isinstance(ref_remote_field.on_delete, DatabaseOnDelete)\n+                    is not is_db_on_delete\n+                ):\n+                    on_delete_type = \"database\" if is_db_on_delete else \"python\"\n+                    ref_on_delete_type = \"python\" if is_db_on_delete else \"database\"\n+                    errors.append(\n+                        checks.Error(\n+                            f\"Field specifies {on_delete_type}-level on_delete \"\n+                            \"variant, but referenced model uses \"\n+                            f\"{ref_on_delete_type}-level variant.\",\n+                            hint=(\n+                                \"Use constantly database or python on_delete variants \"",
      "comment": "```suggestion\n                                \"Use either database or python on_delete variants uniformly\"\n```",
      "comment_id": 2433533607,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-15T18:14:35Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2433533607"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/models/fields/related.py",
      "line": 1134,
      "side": "RIGHT",
      "diff_hunk": "@@ -1041,37 +1049,119 @@ def __class_getitem__(cls, *args, **kwargs):\n         return cls\n \n     def check(self, **kwargs):\n+        databases = kwargs.get(\"databases\") or []\n         return [\n             *super().check(**kwargs),\n-            *self._check_on_delete(),\n+            *self._check_on_delete(databases),\n             *self._check_unique(),\n         ]\n \n-    def _check_on_delete(self):\n+    def _check_on_delete(self, databases):\n         on_delete = getattr(self.remote_field, \"on_delete\", None)\n-        if on_delete == SET_NULL and not self.null:\n-            return [\n+        errors = []\n+        if on_delete in [DB_SET_NULL, SET_NULL] and not self.null:\n+            errors.append(\n                 checks.Error(\n-                    \"Field specifies on_delete=SET_NULL, but cannot be null.\",\n+                    f\"Field specifies on_delete={on_delete.__name__}, but cannot be \"\n+                    \"null.\",\n                     hint=(\n                         \"Set null=True argument on the field, or change the on_delete \"\n                         \"rule.\"\n                     ),\n                     obj=self,\n                     id=\"fields.E320\",\n                 )\n-            ]\n+            )\n         elif on_delete == SET_DEFAULT and not self.has_default():\n-            return [\n+            errors.append(\n                 checks.Error(\n                     \"Field specifies on_delete=SET_DEFAULT, but has no default value.\",\n                     hint=\"Set a default value, or change the on_delete rule.\",\n                     obj=self,\n                     id=\"fields.E321\",\n                 )\n-            ]\n-        else:\n-            return []\n+            )\n+        elif on_delete == DB_SET_DEFAULT:\n+            if self.db_default is NOT_PROVIDED:\n+                errors.append(\n+                    checks.Error(\n+                        \"Field specifies on_delete=DB_SET_DEFAULT, but has \"\n+                        \"no db_default value.\",\n+                        hint=\"Set a db_default value, or change the on_delete rule.\",\n+                        obj=self,\n+                        id=\"fields.E322\",\n+                    )\n+                )\n+            for db in databases:\n+                if not router.allow_migrate_model(db, self.model):\n+                    continue\n+                connection = connections[db]\n+                if not (\n+                    \"supports_on_delete_db_default\"\n+                    in self.model._meta.required_db_features\n+                    or connection.features.supports_on_delete_db_default\n+                ):\n+                    errors.append(\n+                        checks.Error(\n+                            f\"{connection.display_name} does not support a \"\n+                            \"DB_SET_DEFAULT.\",\n+                            hint=\"Change the on_delete rule to SET_DEFAULT.\",\n+                            obj=self,\n+                            id=\"fields.E324\",\n+                        ),\n+                    )\n+        elif on_delete == DB_RESTRICT:\n+            for db in databases:\n+                if not router.allow_migrate_model(db, self.model):\n+                    continue\n+                connection = connections[db]\n+                if not (\n+                    \"supports_on_delete_db_restrict\"\n+                    in self.model._meta.required_db_features\n+                    or connection.features.supports_on_delete_db_restrict\n+                ):\n+                    errors.append(\n+                        checks.Error(\n+                            f\"{connection.display_name} does not support a \"\n+                            \"DB_RESTRICT.\",\n+                            hint=\"Change the on_delete rule to RESTRICT.\",\n+                            obj=self,\n+                            id=\"fields.E324\",\n+                        ),\n+                    )\n+        elif not isinstance(self.remote_field.model, str):\n+            # Database and Python variants cannot be mixed in a chain of\n+            # model references.\n+            is_db_on_delete = isinstance(on_delete, DatabaseOnDelete)\n+            ref_model_related_fields = (\n+                ref_model_field.remote_field\n+                for ref_model_field in self.remote_field.model._meta.get_fields()\n+                if ref_model_field.related_model and not ref_model_field.auto_created\n+            )\n+\n+            for ref_remote_field in ref_model_related_fields:\n+                if (\n+                    ref_remote_field.on_delete is not None\n+                    and isinstance(ref_remote_field.on_delete, DatabaseOnDelete)\n+                    is not is_db_on_delete\n+                ):\n+                    on_delete_type = \"database\" if is_db_on_delete else \"python\"\n+                    ref_on_delete_type = \"python\" if is_db_on_delete else \"database\"\n+                    errors.append(\n+                        checks.Error(",
      "comment": "Is there any harm in letting DO_NOTHING pass here when there are DB_* variants? (Since we're unlikely to create a DB_DO_NOTHING variant?) It might help folks migrate to DB_* when they have some models with `PROTECT`, i.e. they can migrate to `DO_NOTHING` and let the db integrity error bubble up.\r\n\r\nEDIT: shouldn't imply that PROTECT is equivalent to DO_NOTHING, as PROTECT is a little stricter.",
      "comment_id": 2433675875,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-15T19:13:14Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2433675875"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/models/fields/related.py",
      "line": 1134,
      "side": "RIGHT",
      "diff_hunk": "@@ -1041,37 +1049,119 @@ def __class_getitem__(cls, *args, **kwargs):\n         return cls\n \n     def check(self, **kwargs):\n+        databases = kwargs.get(\"databases\") or []\n         return [\n             *super().check(**kwargs),\n-            *self._check_on_delete(),\n+            *self._check_on_delete(databases),\n             *self._check_unique(),\n         ]\n \n-    def _check_on_delete(self):\n+    def _check_on_delete(self, databases):\n         on_delete = getattr(self.remote_field, \"on_delete\", None)\n-        if on_delete == SET_NULL and not self.null:\n-            return [\n+        errors = []\n+        if on_delete in [DB_SET_NULL, SET_NULL] and not self.null:\n+            errors.append(\n                 checks.Error(\n-                    \"Field specifies on_delete=SET_NULL, but cannot be null.\",\n+                    f\"Field specifies on_delete={on_delete.__name__}, but cannot be \"\n+                    \"null.\",\n                     hint=(\n                         \"Set null=True argument on the field, or change the on_delete \"\n                         \"rule.\"\n                     ),\n                     obj=self,\n                     id=\"fields.E320\",\n                 )\n-            ]\n+            )\n         elif on_delete == SET_DEFAULT and not self.has_default():\n-            return [\n+            errors.append(\n                 checks.Error(\n                     \"Field specifies on_delete=SET_DEFAULT, but has no default value.\",\n                     hint=\"Set a default value, or change the on_delete rule.\",\n                     obj=self,\n                     id=\"fields.E321\",\n                 )\n-            ]\n-        else:\n-            return []\n+            )\n+        elif on_delete == DB_SET_DEFAULT:\n+            if self.db_default is NOT_PROVIDED:\n+                errors.append(\n+                    checks.Error(\n+                        \"Field specifies on_delete=DB_SET_DEFAULT, but has \"\n+                        \"no db_default value.\",\n+                        hint=\"Set a db_default value, or change the on_delete rule.\",\n+                        obj=self,\n+                        id=\"fields.E322\",\n+                    )\n+                )\n+            for db in databases:\n+                if not router.allow_migrate_model(db, self.model):\n+                    continue\n+                connection = connections[db]\n+                if not (\n+                    \"supports_on_delete_db_default\"\n+                    in self.model._meta.required_db_features\n+                    or connection.features.supports_on_delete_db_default\n+                ):\n+                    errors.append(\n+                        checks.Error(\n+                            f\"{connection.display_name} does not support a \"\n+                            \"DB_SET_DEFAULT.\",\n+                            hint=\"Change the on_delete rule to SET_DEFAULT.\",\n+                            obj=self,\n+                            id=\"fields.E324\",\n+                        ),\n+                    )\n+        elif on_delete == DB_RESTRICT:\n+            for db in databases:\n+                if not router.allow_migrate_model(db, self.model):\n+                    continue\n+                connection = connections[db]\n+                if not (\n+                    \"supports_on_delete_db_restrict\"\n+                    in self.model._meta.required_db_features\n+                    or connection.features.supports_on_delete_db_restrict\n+                ):\n+                    errors.append(\n+                        checks.Error(\n+                            f\"{connection.display_name} does not support a \"\n+                            \"DB_RESTRICT.\",\n+                            hint=\"Change the on_delete rule to RESTRICT.\",\n+                            obj=self,\n+                            id=\"fields.E324\",\n+                        ),\n+                    )\n+        elif not isinstance(self.remote_field.model, str):\n+            # Database and Python variants cannot be mixed in a chain of\n+            # model references.\n+            is_db_on_delete = isinstance(on_delete, DatabaseOnDelete)\n+            ref_model_related_fields = (\n+                ref_model_field.remote_field\n+                for ref_model_field in self.remote_field.model._meta.get_fields()\n+                if ref_model_field.related_model and not ref_model_field.auto_created\n+            )\n+\n+            for ref_remote_field in ref_model_related_fields:\n+                if (\n+                    ref_remote_field.on_delete is not None\n+                    and isinstance(ref_remote_field.on_delete, DatabaseOnDelete)\n+                    is not is_db_on_delete\n+                ):\n+                    on_delete_type = \"database\" if is_db_on_delete else \"python\"\n+                    ref_on_delete_type = \"python\" if is_db_on_delete else \"database\"\n+                    errors.append(\n+                        checks.Error(",
      "comment": "I think we should also check for auto-created OneToOneField parent links via MTI:\n```py\nclass A(models.Model):\n    ...\n\nclass B(A):\n    ...\n\nclass C(models.Model):\n    b = models.ForeignKey(B, on_delete=models.DB_CASCADE)\n```\n```py\nIn [1]: a = A.objects.create()\n\nIn [2]: b = B.objects.create(a_ptr=a)\n\nIn [3]: c = C.objects.create(b=b)\n\nIn [4]: a.delete()\nOut[4]: (2, {'models.B': 1, 'models.A': 1})\n\nIn [5]: c.refresh_from_db()\n---------------------------------------------------------------------------\nDoesNotExist                              Traceback (most recent call last)\nCell In[5], line 1\n----> 1 c.refresh_from_db()\n\nFile ~/django/django/db/models/base.py:758, in Model.refresh_from_db(self, using, fields, from_queryset)\n    749 elif deferred_fields:\n    750     db_instance_qs = db_instance_qs.only(\n    751         *{\n    752             f.attname\n   (...)    755         }\n    756     )\n--> 758 db_instance = db_instance_qs.get()\n    759 non_loaded_fields = db_instance.get_deferred_fields()\n    760 for field in self._meta.fields:\n\nFile ~/django/django/db/models/query.py:637, in QuerySet.get(self, *args, **kwargs)\n    635     return clone._result_cache[0]\n    636 if not num:\n--> 637     raise self.model.DoesNotExist(\n    638         \"%s matching query does not exist.\" % self.model._meta.object_name\n    639     )\n    640 raise self.model.MultipleObjectsReturned(\n    641     \"get() returned more than one %s -- it returned %s!\"\n    642     % (\n   (...)    645     )\n    646 )\n\nDoesNotExist: C matching query does not exist.\n```",
      "comment_id": 2433808248,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-15T20:12:05Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2433808248"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/schema/tests.py",
      "line": 447,
      "side": "RIGHT",
      "diff_hunk": "@@ -410,6 +412,41 @@ def test_inline_fk(self):\n             ]\n         )\n \n+    @skipUnlessDBFeature(\"can_create_inline_fk\")\n+    def test_inline_fk_db_on_delete(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            editor.create_model(Book)\n+            editor.create_model(Note)\n+        self.assertForeignKeyNotExists(Note, \"book_id\", \"schema_book\")\n+        # Add a foreign key from model to the other.\n+        with (\n+            CaptureQueriesContext(connection) as ctx,\n+            connection.schema_editor() as editor,\n+        ):\n+            new_field = ForeignKey(Book, DB_CASCADE)\n+            new_field.set_attributes_from_name(\"book\")\n+            editor.add_field(Note, new_field)\n+        self.assertForeignKeyExists(Note, \"book_id\", \"schema_book\")\n+        # Creating a FK field with a constraint uses a single statement without\n+        # a deferred ALTER TABLE.\n+        self.assertFalse(\n+            [\n+                sql\n+                for sql in (str(statement) for statement in editor.deferred_sql)\n+                if sql.startswith(\"ALTER TABLE\") and \"ADD CONSTRAINT\" in sql\n+            ]\n+        )\n+        # ON DELETE clause is used.\n+        self.assertTrue(\n+            [\n+                True\n+                for capture_query in ctx.captured_queries\n+                if capture_query[\"sql\"].startswith(\"ALTER TABLE\")\n+                and \"ON DELETE\" in capture_query[\"sql\"]\n+            ]",
      "comment": "At your option, I find this a little more straightforward.\n```suggestion\n            any(\n                capture_query[\"sql\"].startswith(\"ALTER TABLE\")\n                and \"ON DELETE\" in capture_query[\"sql\"]\n                for capture_query in ctx.captured_queries\n            )\n```",
      "comment_id": 2433854740,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-15T20:28:42Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2433854740"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/delete/tests.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,18 +82,50 @@ def test_setnull(self):\n         a = A.objects.get(pk=a.pk)\n         self.assertIsNone(a.setnull)\n \n+    def test_db_setnull(self):\n+        a = create_related_db_option(\"db_setnull\")\n+        a.db_setnull.delete()\n+        a = RelatedDbOption.objects.get(pk=a.pk)\n+        self.assertIsNone(a.db_setnull)\n+\n     def test_setdefault(self):\n         a = create_a(\"setdefault\")\n         a.setdefault.delete()\n         a = A.objects.get(pk=a.pk)\n         self.assertEqual(self.DEFAULT, a.setdefault.pk)\n \n+    @skipUnlessDBFeature(\"supports_on_delete_db_default\")\n+    def test_db_setdefault(self):\n+        # Object cannot be created on the module initialization, use hardcoded\n+        # PKs instead.\n+        RelatedDbOptionParent.objects.all().delete()",
      "comment": "Good catch :dart: It's leftover from using the same model for both database and python `on_delete` variants.",
      "comment_id": 2433930628,
      "user": "felixxm",
      "created_at": "2025-10-15T20:59:56Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2433930628"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +78,8 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     supports_json_field_contains = False\n     supports_json_negative_indexing = False\n     supports_collation_on_textfield = False\n+    supports_on_delete_db_default = False\n+    supports_on_delete_db_restrict = False",
      "comment": "> ... since they claim that their default behavior is roughly equivalent to restrict ...\r\n\r\nCan you share any links to Oracle docs?",
      "comment_id": 2433952996,
      "user": "felixxm",
      "created_at": "2025-10-15T21:09:39Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2433952996"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/backends/oracle/features.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +78,8 @@ class DatabaseFeatures(BaseDatabaseFeatures):\n     supports_json_field_contains = False\n     supports_json_negative_indexing = False\n     supports_collation_on_textfield = False\n+    supports_on_delete_db_default = False\n+    supports_on_delete_db_restrict = False",
      "comment": "I was looking at [this](https://docs.oracle.com/cd/B28359_01/server.111/b28318/data_int.htm#CNCPT1629), which I now realize is an old version:\r\n\r\n> No action: Disallows the update or deletion of referenced data. This differs from RESTRICT in that it is checked at the end of the statement, or at the end of the transaction if the constraint is deferred. (Oracle Database uses No Action as its default action.)\r\n\r\n... but that small difference is represented by our `PROTECT` and `DO NOTHING`, which Simon's reply below clarified for me. Nothing to add here, I think.",
      "comment_id": 2434077955,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-15T21:55:20Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2434077955"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/invalid_models_tests/test_relative_fields.py",
      "line": 2441,
      "side": "RIGHT",
      "diff_hunk": "@@ -2259,3 +2283,162 @@ class FooBar(models.Model):\n                 ),\n             ],\n         )\n+\n+\n+@isolate_apps(\"invalid_models_tests\")\n+class DatabaseLevelOnDeleteTests(TestCase):\n+\n+    def test_db_set_default_support(self):\n+        class Parent(models.Model):\n+            pass\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(\n+                Parent, models.DB_SET_DEFAULT, db_default=models.Value(1)\n+            )\n+\n+        field = Child._meta.get_field(\"parent\")\n+        expected = (\n+            []\n+            if connection.features.supports_on_delete_db_default\n+            else [\n+                Error(\n+                    f\"{connection.display_name} does not support a DB_SET_DEFAULT.\",\n+                    hint=\"Change the on_delete rule to SET_DEFAULT.\",\n+                    obj=field,\n+                    id=\"fields.E324\",\n+                )\n+            ]\n+        )\n+        self.assertEqual(field.check(databases=self.databases), expected)\n+\n+    def test_db_set_default_required_db_features(self):\n+        class Parent(models.Model):\n+            pass\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(\n+                Parent, models.DB_SET_DEFAULT, db_default=models.Value(1)\n+            )\n+\n+            class Meta:\n+                required_db_features = {\"supports_on_delete_db_default\"}\n+\n+        field = Child._meta.get_field(\"parent\")\n+        self.assertEqual(field.check(databases=self.databases), [])\n+\n+    @skipUnlessDBFeature(\"supports_on_delete_db_default\")\n+    def test_db_set_default_no_db_default(self):\n+        class Parent(models.Model):\n+            pass\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, models.DB_SET_DEFAULT)\n+\n+        field = Child._meta.get_field(\"parent\")\n+        self.assertEqual(\n+            field.check(databases=self.databases),\n+            [\n+                Error(\n+                    \"Field specifies on_delete=DB_SET_DEFAULT, but has no db_default \"\n+                    \"value.\",\n+                    hint=\"Set a db_default value, or change the on_delete rule.\",\n+                    obj=field,\n+                    id=\"fields.E322\",\n+                )\n+            ],\n+        )\n+\n+    def test_python_db_chain(self):\n+        class GrandParent(models.Model):\n+            pass\n+\n+        class Parent(models.Model):\n+            grand_parent = models.ForeignKey(GrandParent, models.DB_CASCADE)\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, models.RESTRICT)\n+\n+        field = Child._meta.get_field(\"parent\")\n+        self.assertEqual(\n+            field.check(databases=self.databases),\n+            [\n+                Error(\n+                    \"Field specifies python-level on_delete variant, but referenced \"\n+                    \"model uses database-level variant.\",\n+                    hint=(\n+                        \"Use either database or python on_delete variants uniformly in \"\n+                        \"the references chain.\"\n+                    ),\n+                    obj=field,\n+                    id=\"fields.E323\",\n+                )\n+            ],\n+        )\n+\n+    def test_db_python_chain(self):\n+        class GrandParent(models.Model):\n+            pass\n+\n+        class Parent(models.Model):\n+            grand_parent = models.ForeignKey(GrandParent, models.CASCADE)\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, models.DB_SET_NULL, null=True)\n+\n+        field = Child._meta.get_field(\"parent\")\n+        self.assertEqual(\n+            field.check(databases=self.databases),\n+            [\n+                Error(\n+                    \"Field specifies database-level on_delete variant, but referenced \"\n+                    \"model uses python-level variant.\",\n+                    hint=(\n+                        \"Use either database or python on_delete variants uniformly in \"\n+                        \"the references chain.\"\n+                    ),\n+                    obj=field,\n+                    id=\"fields.E323\",\n+                )\n+            ],\n+        )\n+\n+    def test_db_python_chain_auto_created(self):\n+        class GrandParent(models.Model):\n+            pass\n+\n+        class Parent(GrandParent):\n+            pass\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.DB_CASCADE)\n+\n+        field = Child._meta.get_field(\"parent\")\n+        self.assertEqual(\n+            field.check(databases=self.databases),\n+            [\n+                Error(\n+                    \"Field specifies database-level on_delete variant, but referenced \"\n+                    \"model uses python-level variant.\",\n+                    hint=(\n+                        \"Use either database or python on_delete variants uniformly in \"\n+                        \"the references chain.\"\n+                    ),\n+                    obj=field,\n+                    id=\"fields.E323\",\n+                )\n+            ],\n+        )\n+\n+    def test_db_do_nothing_chain(self):\n+        class GrandParent(models.Model):\n+            pass\n+\n+        class Parent(models.Model):\n+            grand_parent = models.ForeignKey(GrandParent, models.DO_NOTHING)\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, models.DB_SET_NULL, null=True)",
      "comment": "Reversing these gives a failure:\n```diff\ndiff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex b86235c964..06c42c77b6 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -2435,10 +2435,10 @@ class DatabaseLevelOnDeleteTests(TestCase):\n             pass\n \n         class Parent(models.Model):\n-            grand_parent = models.ForeignKey(GrandParent, models.DO_NOTHING)\n+            grand_parent = models.ForeignKey(GrandParent, models.DB_SET_NULL, null=True)\n \n         class Child(models.Model):\n-            parent = models.ForeignKey(Parent, models.DB_SET_NULL, null=True)\n+            parent = models.ForeignKey(Parent, models.DO_NOTHING)\n \n         field = Child._meta.get_field(\"parent\")\n         self.assertEqual(field.check(databases=self.databases), [])\n```\n```\nAssertionError: Lists differ: [<Error: level=40, msg='Field specifies py[245 chars]23'>] != []\n\nFirst list contains 1 additional elements.\nFirst extra element 0:\n<Error: level=40, msg='Field specifies python-level on_delete variant, but referenced model uses database-level variant.', hint='Use either database or python on_delete variants uniformly in the references chain.', obj=<django.db.models.fields.related.ForeignKey: parent>, id='fields.E323'>\n```",
      "comment_id": 2437223646,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-16T19:26:46Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2437223646"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/models/base.py",
      "line": 2469,
      "side": "RIGHT",
      "diff_hunk": "@@ -2455,6 +2456,29 @@ def _check_long_column_names(cls, databases):\n \n         return errors\n \n+    @classmethod\n+    def _check_related_fields(cls):\n+        has_db_variant = False\n+        has_python_variant = False\n+        for rel in cls._meta.get_fields():\n+            if rel.related_model and not rel.auto_created:\n+                if not (on_delete := getattr(rel.remote_field, \"on_delete\", None)):\n+                    continue\n+                if isinstance(on_delete, DatabaseOnDelete):\n+                    has_db_variant = True\n+                else:",
      "comment": "Same problem here, suspect we want something like:\n```suggestion\n                elif on_delete != DO_NOTHING:\n```",
      "comment_id": 2437441499,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-16T20:52:55Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2437441499"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "django/db/models/base.py",
      "line": 2469,
      "side": "RIGHT",
      "diff_hunk": "@@ -2455,6 +2456,29 @@ def _check_long_column_names(cls, databases):\n \n         return errors\n \n+    @classmethod\n+    def _check_related_fields(cls):\n+        has_db_variant = False\n+        has_python_variant = False\n+        for rel in cls._meta.get_fields():\n+            if rel.related_model and not rel.auto_created:\n+                if not (on_delete := getattr(rel.remote_field, \"on_delete\", None)):\n+                    continue\n+                if isinstance(on_delete, DatabaseOnDelete):\n+                    has_db_variant = True\n+                else:",
      "comment": "Fixed, I also fixed this system check for auto-created `OneToOneField`s.",
      "comment_id": 2438601824,
      "user": "felixxm",
      "created_at": "2025-10-17T06:59:43Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2438601824"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/delete/tests.py",
      "line": 411,
      "side": "RIGHT",
      "diff_hunk": "@@ -359,6 +394,22 @@ def test_bulk(self):\n         self.assertNumQueries(5, s.delete)\n         self.assertFalse(S.objects.exists())\n \n+    def test_db_cascade(self):\n+        related_db_op = RelatedDbOptionParent.objects.create(\n+            p=RelatedDbOptionGrandParent.objects.create()\n+        )\n+        RelatedDbOption.objects.bulk_create(\n+            [\n+                RelatedDbOption(db_cascade=related_db_op)\n+                for _ in range(2 * GET_ITERATOR_CHUNK_SIZE)\n+            ]\n+        )\n+        with self.assertNumQueries(1):\n+            results = related_db_op.delete()\n+            self.assertEqual(results, (1, {\"delete.RelatedDbOptionParent\": 1}))\n+        self.assertFalse(RelatedDbOption.objects.exists())\n+        self.assertFalse(RelatedDbOptionParent.objects.exists())",
      "comment": "> Are some `@skipUnlessDBFeature(\"supports_on_delete_db_default\")` missing? I have these failures on MongoDB:\r\n\r\n`supports_on_delete_db_default` is only for `SET DEFAULT` support. We can add `supports_on_delete_db_null` and `supports_on_delete_db_cascade` feature flags if none of the remaining options are supported on some databases :thinking: ",
      "comment_id": 2545344719,
      "user": "felixxm",
      "created_at": "2025-11-20T10:29:01Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2545344719"
    },
    {
      "repo": "django/django",
      "pr_number": 19925,
      "file_path": "tests/delete/tests.py",
      "line": 411,
      "side": "RIGHT",
      "diff_hunk": "@@ -359,6 +394,22 @@ def test_bulk(self):\n         self.assertNumQueries(5, s.delete)\n         self.assertFalse(S.objects.exists())\n \n+    def test_db_cascade(self):\n+        related_db_op = RelatedDbOptionParent.objects.create(\n+            p=RelatedDbOptionGrandParent.objects.create()\n+        )\n+        RelatedDbOption.objects.bulk_create(\n+            [\n+                RelatedDbOption(db_cascade=related_db_op)\n+                for _ in range(2 * GET_ITERATOR_CHUNK_SIZE)\n+            ]\n+        )\n+        with self.assertNumQueries(1):\n+            results = related_db_op.delete()\n+            self.assertEqual(results, (1, {\"delete.RelatedDbOptionParent\": 1}))\n+        self.assertFalse(RelatedDbOption.objects.exists())\n+        self.assertFalse(RelatedDbOptionParent.objects.exists())",
      "comment": "Thanks for explaining. Here you are: https://github.com/django/django/pull/20286",
      "comment_id": 2548340448,
      "user": "timgraham",
      "created_at": "2025-11-21T02:34:26Z",
      "url": "https://github.com/django/django/pull/19925#discussion_r2548340448"
    },
    {
      "repo": "django/django",
      "pr_number": 20183,
      "file_path": "django/utils/html.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,8 +76,9 @@ def escape(text):\n     ord(\"\\u2029\"): \"\\\\u2029\",\n }\n \n-# Escape every ASCII character with a value less than 32.\n+# Escape every ASCII character with a value less than 32 (C0) && 127-159(C1).",
      "comment": "Nit: Suggest keeping the comment as prose\n```suggestion\n# Escape every ASCII character with a value less than 32 (C0) and 127-159(C1).\n```",
      "comment_id": 2537169158,
      "user": "RealOrangeOne",
      "created_at": "2025-11-18T09:44:23Z",
      "url": "https://github.com/django/django/pull/20183#discussion_r2537169158"
    },
    {
      "repo": "django/django",
      "pr_number": 20183,
      "file_path": "tests/utils_tests/test_html.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,6 +244,9 @@ def test_escapejs(self):\n                 \"paragraph separator:\\\\u2029and line separator:\\\\u2028\",\n             ),\n             (\"`\", \"\\\\u0060\"),\n+            (\"\\u007F\", \"\\u007F\"),       \n+            (\"\\u0080\", \"\\u0080\"),\n+            (\"\\u009F\",\"\\u009F\"),",
      "comment": "```suggestion\r\n            (\"\\u009F\", \"\\u009F\"),\r\n```",
      "comment_id": 2537179876,
      "user": "pauloxnet",
      "created_at": "2025-11-18T09:46:22Z",
      "url": "https://github.com/django/django/pull/20183#discussion_r2537179876"
    },
    {
      "repo": "django/django",
      "pr_number": 20183,
      "file_path": "tests/utils_tests/test_html.py",
      "line": 247,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,6 +244,9 @@ def test_escapejs(self):\n                 \"paragraph separator:\\\\u2029and line separator:\\\\u2028\",\n             ),\n             (\"`\", \"\\\\u0060\"),\n+            (\"\\u007F\", \"\\u007F\"),       ",
      "comment": "```suggestion\r\n            (\"\\u007F\", \"\\u007F\"),\r\n```",
      "comment_id": 2537180633,
      "user": "pauloxnet",
      "created_at": "2025-11-18T09:46:29Z",
      "url": "https://github.com/django/django/pull/20183#discussion_r2537180633"
    },
    {
      "repo": "django/django",
      "pr_number": 20183,
      "file_path": "tests/utils_tests/test_html.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,6 +244,9 @@ def test_escapejs(self):\n                 \"paragraph separator:\\\\u2029and line separator:\\\\u2028\",\n             ),\n             (\"`\", \"\\\\u0060\"),\n+            (\"\\u007f\", \"\\u007f\"),\n+            (\"\\u0080\", \"\\u0080\"),\n+            (\"\\u009f\", \"\\u009f\"),",
      "comment": "These should all be escaped\n```suggestion\n            (\"\\u007f\", \"\\\\u007F\"),\n            (\"\\u0080\", \"\\\\u0080\"),\n            (\"\\u009f\", \"\\\\u009F\"),\n```",
      "comment_id": 2539170208,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-18T17:55:21Z",
      "url": "https://github.com/django/django/pull/20183#discussion_r2539170208"
    },
    {
      "repo": "django/django",
      "pr_number": 20183,
      "file_path": "tests/utils_tests/test_html.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,6 +244,9 @@ def test_escapejs(self):\n                 \"paragraph separator:\\\\u2029and line separator:\\\\u2028\",\n             ),\n             (\"`\", \"\\\\u0060\"),\n+            (\"\\u007f\", \"\\u007f\"),\n+            (\"\\u0080\", \"\\u0080\"),\n+            (\"\\u009f\", \"\\u009f\"),",
      "comment": "Major doubt I have checked my code works but during the implementation of test cases throws an ` Asserstion error` that similar test executed separately runs perfectly \r\nI have been stuck with this for a while",
      "comment_id": 2540597502,
      "user": "farthestmage",
      "created_at": "2025-11-19T05:30:23Z",
      "url": "https://github.com/django/django/pull/20183#discussion_r2540597502"
    },
    {
      "repo": "django/django",
      "pr_number": 20183,
      "file_path": "tests/utils_tests/test_html.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,6 +244,9 @@ def test_escapejs(self):\n                 \"paragraph separator:\\\\u2029and line separator:\\\\u2028\",\n             ),\n             (\"`\", \"\\\\u0060\"),\n+            (\"\\u007f\", \"\\u007f\"),\n+            (\"\\u0080\", \"\\u0080\"),\n+            (\"\\u009f\", \"\\u009f\"),",
      "comment": "The test passes for me when I correct the expected results.",
      "comment_id": 2542253819,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-19T14:28:39Z",
      "url": "https://github.com/django/django/pull/20183#discussion_r2542253819"
    },
    {
      "repo": "django/django",
      "pr_number": 20183,
      "file_path": "django/utils/html.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,8 +76,9 @@ def escape(text):\n     ord(\"\\u2029\"): \"\\\\u2029\",\n }\n \n-# Escape every ASCII character with a value less than 32.\n+# Escape every ASCII character with a value less than 32 (C0) and 127-159(C1).\n _js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(32))\n+_js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(0x7F, 0xA0))",
      "comment": "You can just do this once if you `from itertools import chain`. Also please don't include 127 with the C1 range, it's C0.\n```suggestion\n# Escape every ASCII character with a value less than 32 (C0), 127 (C0),\n# or 128-159(C1).\n_js_escapes.update(\n    (ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in chain(range(32), range(0x7F, 0xA0))\n)\n```",
      "comment_id": 2542489782,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-19T15:21:21Z",
      "url": "https://github.com/django/django/pull/20183#discussion_r2542489782"
    },
    {
      "repo": "django/django",
      "pr_number": 20183,
      "file_path": "django/utils/html.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,8 +77,11 @@ def escape(text):\n     ord(\"\\u2029\"): \"\\\\u2029\",\n }\n \n-# Escape every ASCII character with a value less than 32.\n-_js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(32))\n+# Escape every ASCII character with a value less than 32 (C0) ,127(C0)",
      "comment": "```suggestion\n# Escape every ASCII character with a value less than 32 (C0), 127(C0)\n```",
      "comment_id": 2543233340,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-19T19:08:22Z",
      "url": "https://github.com/django/django/pull/20183#discussion_r2543233340"
    },
    {
      "repo": "django/django",
      "pr_number": 20183,
      "file_path": "django/utils/html.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,8 +77,11 @@ def escape(text):\n     ord(\"\\u2029\"): \"\\\\u2029\",\n }\n \n-# Escape every ASCII character with a value less than 32.\n-_js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(32))\n+# Escape every ASCII character with a value less than 32 (C0), 127(C0)\n+#  or 128-159(C1).",
      "comment": "```suggestion\n# Escape every ASCII character with a value less than 32 (C0), 127(C0),\n# or 128-159(C1).\n```",
      "comment_id": 2543235742,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-19T19:09:17Z",
      "url": "https://github.com/django/django/pull/20183#discussion_r2543235742"
    },
    {
      "repo": "django/django",
      "pr_number": 20043,
      "file_path": "django/db/migrations/loader.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -109,11 +109,11 @@ def load_disk(self):\n                 if was_loaded:\n                     reload(module)\n             self.migrated_apps.add(app_config.label)\n-            migration_names = {\n+            migration_names = [",
      "comment": "I considered making this `sorted()`, but I wanted to take the lightest possible touch for now, and not risk making a Django 6.1 upgrade any more difficult for anyone.",
      "comment_id": 2487263895,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-03T17:15:27Z",
      "url": "https://github.com/django/django/pull/20043#discussion_r2487263895"
    },
    {
      "repo": "django/django",
      "pr_number": 20043,
      "file_path": "tests/migrations/test_loader.py",
      "line": 687,
      "side": "RIGHT",
      "diff_hunk": "@@ -649,6 +654,70 @@ def test_loading_package_without__file__(self):\n             test_module.__spec__.origin = module_origin\n             test_module.__spec__.has_location = module_has_location\n \n+    def test_loading_order_does_not_create_circular_dependency(self):\n+        \"\"\"\n+        Before, for these migrations:\n+        app1\n+        [ ] 0001_squashed_initial <- replaces app1.0001\n+        [ ] 0002_squashed_initial <- replaces app1.0001\n+            depends on app1.0001_squashed_initial & app2.0001_squashed_initial\n+        app2\n+        [ ] 0001_squashed_initial <- replaces app2.0001\n+\n+        When loading app1's migrations, if 0002_squashed_initial was first:\n+        {'0002_squashed_initial', '0001_initial', '0001_squashed_initial'}\n+        Then CircularDependencyError was raised, but it's resolvable as:\n+        {'0001_initial', '0001_squashed_initial', '0002_squashed_initial'}\n+        \"\"\"\n+        # Create a test settings file to provide to the subprocess.\n+        MIGRATION_MODULES = {\n+            \"app1\": \"migrations.test_migrations_squashed_replaced_order.app1\",\n+            \"app2\": \"migrations.test_migrations_squashed_replaced_order.app2\",\n+        }\n+        INSTALLED_APPS = [\n+            \"migrations.test_migrations_squashed_replaced_order.app1\",\n+            \"migrations.test_migrations_squashed_replaced_order.app2\",\n+        ]\n+        tests_dir = Path(__file__).parent.parent\n+        with tempfile.NamedTemporaryFile(\n+            mode=\"w\", encoding=\"utf-8\", suffix=\".py\", dir=tests_dir, delete=False\n+        ) as test_settings:\n+            for attr, value in settings._wrapped.__dict__.items():\n+                if attr.isupper():\n+                    test_settings.write(f\"{attr} = {value!r}\\n\")",
      "comment": "This is a bit brittle. I don't know that it's worth accounting for, but for MongoDB we have this patch:\r\n```diff\r\ndiff --git a/tests/runtests.py b/tests/runtests.py\r\nindex 500908978a..b72b9b7de1 100755\r\n--- a/tests/runtests.py\r\n+++ b/tests/runtests.py\r\n@@ -14,6 +14,7 @@ import warnings\r\n from pathlib import Path\r\n \r\n import django_mongodb_backend\r\n+from bson import ObjectId\r\n \r\n try:\r\n     import django\r\n@@ -247,7 +248,7 @@ def setup_collect_tests(start_at, start_after, test_labels=None):\r\n         }\r\n     ]\r\n     settings.LANGUAGE_CODE = \"en\"\r\n-    settings.SITE_ID = 1\r\n+    settings.SITE_ID = ObjectId(\"000000000000000000000001\")\r\n     settings.MIDDLEWARE = ALWAYS_MIDDLEWARE\r\n     settings.MIGRATION_MODULES = {\r\n         # This lets us skip creating migrations for the test models as many of\r\n```\r\nThe written migration file doesn't have the necessary import:\r\n```\r\n  File \"/home/tim/code/django/tests/tmpf6bu1e4h.py\", line 151, in <module>\r\n    SITE_ID = ObjectId('000000000000000000000001')\r\n              ^^^^^^^^\r\nNameError: name 'ObjectId' is not defined. Did you mean: 'object'?\r\n```",
      "comment_id": 2544080477,
      "user": "timgraham",
      "created_at": "2025-11-20T01:49:58Z",
      "url": "https://github.com/django/django/pull/20043#discussion_r2544080477"
    },
    {
      "repo": "django/django",
      "pr_number": 20043,
      "file_path": "tests/migrations/test_loader.py",
      "line": 687,
      "side": "RIGHT",
      "diff_hunk": "@@ -649,6 +654,70 @@ def test_loading_package_without__file__(self):\n             test_module.__spec__.origin = module_origin\n             test_module.__spec__.has_location = module_has_location\n \n+    def test_loading_order_does_not_create_circular_dependency(self):\n+        \"\"\"\n+        Before, for these migrations:\n+        app1\n+        [ ] 0001_squashed_initial <- replaces app1.0001\n+        [ ] 0002_squashed_initial <- replaces app1.0001\n+            depends on app1.0001_squashed_initial & app2.0001_squashed_initial\n+        app2\n+        [ ] 0001_squashed_initial <- replaces app2.0001\n+\n+        When loading app1's migrations, if 0002_squashed_initial was first:\n+        {'0002_squashed_initial', '0001_initial', '0001_squashed_initial'}\n+        Then CircularDependencyError was raised, but it's resolvable as:\n+        {'0001_initial', '0001_squashed_initial', '0002_squashed_initial'}\n+        \"\"\"\n+        # Create a test settings file to provide to the subprocess.\n+        MIGRATION_MODULES = {\n+            \"app1\": \"migrations.test_migrations_squashed_replaced_order.app1\",\n+            \"app2\": \"migrations.test_migrations_squashed_replaced_order.app2\",\n+        }\n+        INSTALLED_APPS = [\n+            \"migrations.test_migrations_squashed_replaced_order.app1\",\n+            \"migrations.test_migrations_squashed_replaced_order.app2\",\n+        ]\n+        tests_dir = Path(__file__).parent.parent\n+        with tempfile.NamedTemporaryFile(\n+            mode=\"w\", encoding=\"utf-8\", suffix=\".py\", dir=tests_dir, delete=False\n+        ) as test_settings:\n+            for attr, value in settings._wrapped.__dict__.items():\n+                if attr.isupper():\n+                    test_settings.write(f\"{attr} = {value!r}\\n\")",
      "comment": "Ah. A prior iteration tried to only write the few settings that appeared relevant for the test, until the geodjango tests revealed that the geo settings needed to be present in order connect to the db. I'll give it some thought. Maybe we can only write out settings values consisting of literals and end up with something slightly less brittle.",
      "comment_id": 2544230217,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-20T03:41:30Z",
      "url": "https://github.com/django/django/pull/20043#discussion_r2544230217"
    },
    {
      "repo": "django/django",
      "pr_number": 20267,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 320,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,11 +316,13 @@ def _check_choices(self):\n         if not self.choices:\n             return []\n \n-        if not isinstance(self.choices, Iterable) or isinstance(self.choices, str):\n+        if not isinstance(self.choices, Iterable) or isinstance(\n+            self.choices, (str, set, frozenset)",
      "comment": "Ahh I always assumed `frozenset` was subclass of `set` but it makes sense that it isn't (e.g. it doesn't have an `add` method).",
      "comment_id": 2539076876,
      "user": "charettes",
      "created_at": "2025-11-18T17:23:32Z",
      "url": "https://github.com/django/django/pull/20267#discussion_r2539076876"
    },
    {
      "repo": "django/django",
      "pr_number": 20267,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 320,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,11 +316,13 @@ def _check_choices(self):\n         if not self.choices:\n             return []\n \n-        if not isinstance(self.choices, Iterable) or isinstance(self.choices, str):\n+        if not isinstance(self.choices, Iterable) or isinstance(\n+            self.choices, (str, set, frozenset)",
      "comment": "> Ahh I always assumed `frozenset` was subclass of `set` ....\r\n\r\n![giphy](https://github.com/user-attachments/assets/f0d9f81c-df72-45f9-bbb7-422b18a4f081)\r\n\r\n:sweat_smile: ",
      "comment_id": 2539091817,
      "user": "felixxm",
      "created_at": "2025-11-18T17:28:32Z",
      "url": "https://github.com/django/django/pull/20267#discussion_r2539091817"
    },
    {
      "repo": "django/django",
      "pr_number": 20267,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 320,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,11 +316,13 @@ def _check_choices(self):\n         if not self.choices:\n             return []\n \n-        if not isinstance(self.choices, Iterable) or isinstance(self.choices, str):\n+        if not isinstance(self.choices, Iterable) or isinstance(\n+            self.choices, (str, set, frozenset)",
      "comment": "But they are both subclasses of [`collections.abc.Set`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Set).",
      "comment_id": 2542498015,
      "user": "ngnpope",
      "created_at": "2025-11-19T15:23:35Z",
      "url": "https://github.com/django/django/pull/20267#discussion_r2542498015"
    },
    {
      "repo": "django/django",
      "pr_number": 20098,
      "file_path": "django/utils/feedgenerator.py",
      "line": 108,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,11 +96,15 @@ def mimetype(self):\n         return self._mimetype\n \n     def __str__(self):\n-        data = [f'href=\"{self.url}\"']\n-        if self.mimetype is not None:\n-            data.append(f'type=\"{self.mimetype}\"')\n-        if self.media is not None:\n-            data.append(f'media=\"{self.media}\"')\n+        url = escape(iri_to_uri(self._url))\n+        mimetype = escape(self.mimetype) if self.mimetype is not None else None\n+        media = escape(self.media) if self.media is not None else None\n+\n+        data = [f'href=\"{url}\"']\n+        if mimetype is not None:\n+            data.append(f'type=\"{mimetype}\"')\n+        if media is not None:\n+            data.append(f'media=\"{media}\"')\n         return \" \".join(data)",
      "comment": "Suggestion: It might be nice to use `django.forms.utils.flatatt` here, since it handles both joining the values together and escaping them",
      "comment_id": 2534936310,
      "user": "RealOrangeOne",
      "created_at": "2025-11-17T17:24:03Z",
      "url": "https://github.com/django/django/pull/20098#discussion_r2534936310"
    },
    {
      "repo": "django/django",
      "pr_number": 20098,
      "file_path": "tests/utils_tests/test_feedgenerator.py",
      "line": 166,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,3 +159,20 @@ def test_stylesheet_keeps_lazy_urls(self):\n             str(stylesheet), 'href=\"test.css\" type=\"text/css\" media=\"screen\"'\n         )\n         m.assert_called_once()\n+\n+    def test_stylesheet_attribute_escaping(self):\n+        \"\"\"\n+        Stylesheet.__str__() should escape attribute values.\n+        \"\"\"",
      "comment": "You can chop this docstring; we favor descriptive method names instead (which you have done).",
      "comment_id": 2535288327,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-17T19:31:59Z",
      "url": "https://github.com/django/django/pull/20098#discussion_r2535288327"
    },
    {
      "repo": "django/django",
      "pr_number": 20098,
      "file_path": "django/utils/feedgenerator.py",
      "line": 108,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,11 +96,15 @@ def mimetype(self):\n         return self._mimetype\n \n     def __str__(self):\n-        data = [f'href=\"{self.url}\"']\n-        if self.mimetype is not None:\n-            data.append(f'type=\"{self.mimetype}\"')\n-        if self.media is not None:\n-            data.append(f'media=\"{self.media}\"')\n+        url = escape(iri_to_uri(self._url))\n+        mimetype = escape(self.mimetype) if self.mimetype is not None else None\n+        media = escape(self.media) if self.media is not None else None\n+\n+        data = [f'href=\"{url}\"']\n+        if mimetype is not None:\n+            data.append(f'type=\"{mimetype}\"')\n+        if media is not None:\n+            data.append(f'media=\"{media}\"')\n         return \" \".join(data)",
      "comment": "It is unfortunate to have to update the tests, but I agree with @RealOrangeOne that delegating to `flatatt` is nicer.\n\n@varunkasyap are you up for updating the tests? What hurts is that we don't have an `assertInXML` helper like we do for `assertInHTML`.",
      "comment_id": 2535368961,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-17T20:05:30Z",
      "url": "https://github.com/django/django/pull/20098#discussion_r2535368961"
    },
    {
      "repo": "django/django",
      "pr_number": 20098,
      "file_path": "django/utils/feedgenerator.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,12 +96,13 @@ def mimetype(self):\n         return self._mimetype\n \n     def __str__(self):\n-        data = [f'href=\"{self.url}\"']\n-        if self.mimetype is not None:\n-            data.append(f'type=\"{self.mimetype}\"')\n-        if self.media is not None:\n-            data.append(f'media=\"{self.media}\"')\n-        return \" \".join(data)\n+        attrs = {\n+            \"href\": iri_to_uri(self._url),\n+            \"type\": self.mimetype,\n+            \"media\": self.media,\n+        }\n+        final_attrs = {k: v for k, v in attrs.items() if v is not None}",
      "comment": "Nit: Looks like `flatatt` excludes `None` already: \n\nhttps://github.com/django/django/blob/3c005b5f79bf6d71f3f4c3692ed670e1722b0fb6/django/forms/utils.py#L37",
      "comment_id": 2537299479,
      "user": "RealOrangeOne",
      "created_at": "2025-11-18T10:12:17Z",
      "url": "https://github.com/django/django/pull/20098#discussion_r2537299479"
    },
    {
      "repo": "django/django",
      "pr_number": 20094,
      "file_path": "django/db/migrations/loader.py",
      "line": 374,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +369,20 @@ def check_consistent_history(self, connection):\n                         )\n                     )\n \n+    def all_replaced_applied(self, migration_key, applied):\n+        \"\"\"\n+        Checks (recursively) whether all replaced migrations are applied.",
      "comment": "Just noting for others: the checking for cycles is done earlier, in `replace_migration()`. I can't find a way to cause recursion errors that wouldn't be caught there.",
      "comment_id": 2528961826,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-14T21:18:56Z",
      "url": "https://github.com/django/django/pull/20094#discussion_r2528961826"
    },
    {
      "repo": "django/django",
      "pr_number": 19370,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,6 +21,29 @@ def _make_id(target):\n # A marker for caching\n NO_RECEIVERS = object()\n \n+async def _gather(*coros):\n+    if len(coros) == 0:\n+        return []\n+\n+    if len(coros) == 1:\n+        return [await coros[0], ]",
      "comment": "```suggestion\r\n        return [await coros[0]]\r\n```",
      "comment_id": 2036839318,
      "user": "graingert",
      "created_at": "2025-04-10T08:44:35Z",
      "url": "https://github.com/django/django/pull/19370#discussion_r2036839318"
    },
    {
      "repo": "django/django",
      "pr_number": 19370,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,28 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n+async def _gather(*coros):\n+    if len(coros) == 0:\n+        return []\n+\n+    if len(coros) == 1:\n+        return [await coros[0]]\n+\n+    async def run(i, coro):\n+        results[i] = await coro\n+\n+    try:\n+        async with asyncio.TaskGroup() as tg:\n+            results = [None] * len(coros)\n+            for i, coro in enumerate(coros):\n+                tg.create_task(run(i, coro))\n+        return results\n+    except BaseExceptionGroup as exception_group:\n+        if len(exception_group.exceptions) == 1:\n+            raise exception_group.exceptions[0]\n+        raise",
      "comment": "Can this be simplified to:\r\n\r\n```suggestion\r\nasync def gather_tasks(*coros):\r\n    async with asyncio.TaskGroup() as tg:\r\n        tasks = [tg.create_task(coro) for coro in coros]\r\n    return [task.result() for task in tasks]\r\n```\r\n\r\nunless there's reason for the error handling? (BaseExceptionGroup).\r\n\r\nAlso, it might be worth moving the function to a `utils.py` file, so that it can easily be reused by other places.",
      "comment_id": 2061248814,
      "user": "g-nie",
      "created_at": "2025-04-26T09:58:37Z",
      "url": "https://github.com/django/django/pull/19370#discussion_r2061248814"
    },
    {
      "repo": "django/django",
      "pr_number": 19370,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,28 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n+async def _gather(*coros):\n+    if len(coros) == 0:\n+        return []\n+\n+    if len(coros) == 1:\n+        return [await coros[0]]\n+\n+    async def run(i, coro):\n+        results[i] = await coro\n+\n+    try:\n+        async with asyncio.TaskGroup() as tg:\n+            results = [None] * len(coros)\n+            for i, coro in enumerate(coros):\n+                tg.create_task(run(i, coro))\n+        return results\n+    except BaseExceptionGroup as exception_group:\n+        if len(exception_group.exceptions) == 1:\n+            raise exception_group.exceptions[0]\n+        raise",
      "comment": "Yes the error handling is important to maintain backwards compatibility with the old use of gather",
      "comment_id": 2061250947,
      "user": "graingert",
      "created_at": "2025-04-26T10:13:18Z",
      "url": "https://github.com/django/django/pull/19370#discussion_r2061250947"
    },
    {
      "repo": "django/django",
      "pr_number": 19370,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,28 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n+async def _gather(*coros):\n+    if len(coros) == 0:\n+        return []\n+\n+    if len(coros) == 1:\n+        return [await coros[0]]\n+\n+    async def run(i, coro):\n+        results[i] = await coro\n+\n+    try:\n+        async with asyncio.TaskGroup() as tg:\n+            results = [None] * len(coros)\n+            for i, coro in enumerate(coros):\n+                tg.create_task(run(i, coro))\n+        return results\n+    except BaseExceptionGroup as exception_group:\n+        if len(exception_group.exceptions) == 1:\n+            raise exception_group.exceptions[0]\n+        raise",
      "comment": "Keeping an extra reference to tasks here will result in reference cycles in the traceback of any errors that will delay garbage collection if there's any errors in signals",
      "comment_id": 2061251178,
      "user": "graingert",
      "created_at": "2025-04-26T10:15:01Z",
      "url": "https://github.com/django/django/pull/19370#discussion_r2061251178"
    },
    {
      "repo": "django/django",
      "pr_number": 19370,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,28 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n+async def _gather(*coros):\n+    if len(coros) == 0:\n+        return []\n+\n+    if len(coros) == 1:\n+        return [await coros[0]]\n+\n+    async def run(i, coro):\n+        results[i] = await coro\n+\n+    try:\n+        async with asyncio.TaskGroup() as tg:\n+            results = [None] * len(coros)\n+            for i, coro in enumerate(coros):\n+                tg.create_task(run(i, coro))\n+        return results\n+    except BaseExceptionGroup as exception_group:\n+        if len(exception_group.exceptions) == 1:\n+            raise exception_group.exceptions[0]\n+        raise",
      "comment": "To maintain backward compatibility, shouldn't the first exception be raised even when the exception group contains multiple exceptions?",
      "comment_id": 2089978989,
      "user": "hartungstenio",
      "created_at": "2025-05-15T01:02:35Z",
      "url": "https://github.com/django/django/pull/19370#discussion_r2089978989"
    },
    {
      "repo": "django/django",
      "pr_number": 19370,
      "file_path": "django/dispatch/dispatcher.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,28 @@ def _make_id(target):\n NO_RECEIVERS = object()\n \n \n+async def _gather(*coros):\n+    if len(coros) == 0:\n+        return []\n+\n+    if len(coros) == 1:\n+        return [await coros[0]]\n+\n+    async def run(i, coro):\n+        results[i] = await coro\n+\n+    try:\n+        async with asyncio.TaskGroup() as tg:\n+            results = [None] * len(coros)\n+            for i, coro in enumerate(coros):\n+                tg.create_task(run(i, coro))\n+        return results\n+    except BaseExceptionGroup as exception_group:\n+        if len(exception_group.exceptions) == 1:\n+            raise exception_group.exceptions[0]\n+        raise",
      "comment": "I'm half-inclined to think we could evolve this fallback away over the medium term...   but if I'm not expecting the exception group would be a weird one. \r\n\r\n> To maintain backward compatibility, shouldn't the first exception be raised even when the exception group contains multiple exceptions?\r\n\r\nFirst exception will cancel the other tasks, so I'm not sure how this comes up in real life. \ud83e\udd14 (I think the _unexpected_ raising of the group is better in this _unexpected_ case.)",
      "comment_id": 2502545819,
      "user": "carltongibson",
      "created_at": "2025-11-07T10:08:43Z",
      "url": "https://github.com/django/django/pull/19370#discussion_r2502545819"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/lazy.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from contextlib import contextmanager\n+\n+from asgiref.local import Local\n+\n+\n+def FETCH_ONE(instance, field, fetch_for_instances, **kwargs):\n+    fetch_for_instances((instance,))\n+\n+\n+def FETCH_PEERS(instance, field, fetch_for_instances, **kwargs):\n+    instances = [\n+        peer\n+        for weakref_peer in instance._state.peers\n+        if (peer := weakref_peer()) is not None\n+    ]\n+    if not instances:\n+        # Peers aren\u2019t tracked for QuerySets returning a single instance\n+        instances = (instance,)\n+\n+    fetch_for_instances(instances)\n+\n+\n+class LazyFieldAccess(Exception):\n+    \"\"\"Blocked lazy access of a model field.\"\"\"\n+\n+    pass\n+\n+\n+def RAISE(instance, field, fetch_for_instances, **kwargs):",
      "comment": "Any thoughts about including a `WARN` as well? It seems like the only remaining feature that doesn't make `django-seal` obsolete.",
      "comment_id": 1555162327,
      "user": "charettes",
      "created_at": "2024-04-08T02:31:54Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1555162327"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/related_descriptors.py",
      "line": 532,
      "side": "RIGHT",
      "diff_hunk": "@@ -509,16 +517,34 @@ def __get__(self, instance, cls=None):\n             if related_pk is None:\n                 rel_obj = None\n             else:\n-                filter_args = self.related.field.get_forward_related_filter(instance)\n-                try:\n-                    rel_obj = self.get_queryset(instance=instance).get(**filter_args)\n-                except self.related.related_model.DoesNotExist:\n-                    rel_obj = None\n+                peers = [\n+                    peer\n+                    for weakref_peer in instance._state.peers\n+                    if (peer := weakref_peer()) is not None and not self.is_cached(peer)\n+                ]\n+                if len(peers) > 1:\n+                    # If the instance was fetched with other instances then\n+                    # prefetch the field for all of them\n+                    qs = self.get_queryset()\n+                    prefetch_related_objects(\n+                        peers, Prefetch(self.related.get_accessor_name(), queryset=qs)\n+                    )\n+                    rel_obj = self.related.get_cached_value(instance)",
      "comment": "That seems wrong. Is this meant to go through the currently defined lazy mode as well?",
      "comment_id": 1555163802,
      "user": "charettes",
      "created_at": "2024-04-08T02:35:43Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1555163802"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 222,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,7 +204,22 @@ def __get__(self, instance, cls=None):\n                     raise AttributeError(\n                         \"Cannot read a generated field from an unsaved model.\"\n                     )\n-                instance.refresh_from_db(fields=[field_name])\n+\n+                def fetch_for_instances(instances):\n+                    if len(instances) == 1:\n+                        instances[0].refresh_from_db(fields=[field_name])\n+                    else:\n+                        attname = self.field.attname\n+                        value_by_pk = {\n+                            pk: value\n+                            for pk, value in self.field.model._base_manager.db_manager()\n+                            .filter(pk__in={i.pk for i in instances})\n+                            .values_list(\"pk\", attname)\n+                        }\n+                        for instance in instances:\n+                            setattr(instance, attname, value_by_pk[instance.pk])\n+\n+                get_lazy_mode()(instance, self.field, fetch_for_instances)",
      "comment": "I wonder if a better interface for lazy modes would be to simply accept `(fetcher: Fetcher, instance: Model)` where `Fetcher` would have two methods `fetch_one(instance: Model)` and `fetch_many(Iterable[Model])`.\r\n\r\nThat would avoid creating unnecessary closures on every attribute access and make lazy modes focused on retrieving peers and delegating to the object manipulating the instance.\r\n\r\nIn the case of `DeferredAttribute` that would mean adding these two methods\r\n\r\n```python\r\ndef fetch_one(self, instance):\r\n    instance.refresh_from_db(fields=[self.field.attname])\r\n\r\ndef fetch_many(self, instances):\r\n    attname = self.field.attname\r\n    value_by_pk = {\r\n        pk: value\r\n        for pk, value in self.field.model._base_manager.db_manager()\r\n        .filter(pk__in={i.pk for i in instances})\r\n        .values_list(\"pk\", attname)\r\n     }\r\n    for instance in instances:\r\n        setattr(instance, attname, value_by_pk[instance.pk])\r\n```\r\n\r\nAnd changing this call to `get_lazy_mode()(self, instance)`",
      "comment_id": 1555170810,
      "user": "charettes",
      "created_at": "2024-04-08T02:53:23Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1555170810"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/lazy.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from contextlib import contextmanager",
      "comment": "Any thoughts about naming this module  `fetching` instead? It feels like _fetching_ ties it to `prefetch_related` and is not an already overloaded term within the code base compared the _lazy_.",
      "comment_id": 1555171742,
      "user": "charettes",
      "created_at": "2024-04-08T02:55:48Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1555171742"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/related_descriptors.py",
      "line": 266,
      "side": "RIGHT",
      "diff_hunk": "@@ -251,13 +252,20 @@ def __get__(self, instance, cls=None):\n             else:\n                 rel_obj = None\n             if rel_obj is None and has_value:\n-                rel_obj = self.get_object(instance)\n-                remote_field = self.field.remote_field\n-                # If this is a one-to-one relation, set the reverse accessor\n-                # cache on the related object to the current instance to avoid\n-                # an extra SQL query if it's accessed later on.\n-                if not remote_field.multiple:\n-                    remote_field.set_cached_value(rel_obj, instance)\n+\n+                def fetch_for_instances(instances):\n+                    if len(instances) == 1:\n+                        instance = instances[0]\n+                        setattr(instance, self.field.name, self.get_object(instance))\n+                    else:\n+                        prefetch_related_objects(\n+                            instances,\n+                            Prefetch(self.field.name, queryset=self.get_queryset()),\n+                        )\n+\n+                get_lazy_mode()(instance, self.field, fetch_for_instances)",
      "comment": "Ditto about the unnecessary closure creation and the `Fetcher` protocol idea discussed below.",
      "comment_id": 1555173108,
      "user": "charettes",
      "created_at": "2024-04-08T02:59:01Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1555173108"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/related_descriptors.py",
      "line": 532,
      "side": "RIGHT",
      "diff_hunk": "@@ -509,16 +517,34 @@ def __get__(self, instance, cls=None):\n             if related_pk is None:\n                 rel_obj = None\n             else:\n-                filter_args = self.related.field.get_forward_related_filter(instance)\n-                try:\n-                    rel_obj = self.get_queryset(instance=instance).get(**filter_args)\n-                except self.related.related_model.DoesNotExist:\n-                    rel_obj = None\n+                peers = [\n+                    peer\n+                    for weakref_peer in instance._state.peers\n+                    if (peer := weakref_peer()) is not None and not self.is_cached(peer)\n+                ]\n+                if len(peers) > 1:\n+                    # If the instance was fetched with other instances then\n+                    # prefetch the field for all of them\n+                    qs = self.get_queryset()\n+                    prefetch_related_objects(\n+                        peers, Prefetch(self.related.get_accessor_name(), queryset=qs)\n+                    )\n+                    rel_obj = self.related.get_cached_value(instance)",
      "comment": "Yes, I just didn\u2019t update this yet from Andreas\u2019 original PR copying from django-auto-prefetch, yet.",
      "comment_id": 1575930309,
      "user": "adamchainz",
      "created_at": "2024-04-23T09:17:49Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1575930309"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/lazy.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from contextlib import contextmanager",
      "comment": "I tried describing the feature name a few different ways before settling on \u201clazy-loading modes\u201d as in the release notes. But \u201clazy-fetching modes\u201d could also be a candidate.\r\n\r\nHappy to rename the module, but I\u2019d prefer to keep it aligned with the name of the feature.\r\n\r\nI agree that \u201clazy\u201d is used in many ways - translations, \u201clazy relationships\u201d for passing a string to Foreign Keys, `SimpleLazyObject`... But it does also accurately describes how the data is lazily fetched by a field on access. Naming things is hard.",
      "comment_id": 1575936312,
      "user": "adamchainz",
      "created_at": "2024-04-23T09:22:04Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1575936312"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/lazy.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from contextlib import contextmanager\n+\n+from asgiref.local import Local\n+\n+\n+def FETCH_ONE(instance, field, fetch_for_instances, **kwargs):\n+    fetch_for_instances((instance,))\n+\n+\n+def FETCH_PEERS(instance, field, fetch_for_instances, **kwargs):\n+    instances = [\n+        peer\n+        for weakref_peer in instance._state.peers\n+        if (peer := weakref_peer()) is not None\n+    ]\n+    if not instances:\n+        # Peers aren\u2019t tracked for QuerySets returning a single instance\n+        instances = (instance,)\n+\n+    fetch_for_instances(instances)\n+\n+\n+class LazyFieldAccess(Exception):\n+    \"\"\"Blocked lazy access of a model field.\"\"\"\n+\n+    pass\n+\n+\n+def RAISE(instance, field, fetch_for_instances, **kwargs):",
      "comment": "I was thinking of that, but then maybe users would want \u201cfetch peers\u201d + warnings, or log messages directly rather than warnings. Maybe something we can instead document the pattern for? Like:\r\n\r\n```python\r\ndef warn_then_fetch_peers(...):\r\n    logger.warning(\"fetching peers!\")\r\n    return FETCH_PEERS(...)\r\n\r\nset_default_lazy_mode(warn_then_fetch_peers)\r\n```",
      "comment_id": 1575939529,
      "user": "adamchainz",
      "created_at": "2024-04-23T09:24:29Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1575939529"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 222,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,7 +204,22 @@ def __get__(self, instance, cls=None):\n                     raise AttributeError(\n                         \"Cannot read a generated field from an unsaved model.\"\n                     )\n-                instance.refresh_from_db(fields=[field_name])\n+\n+                def fetch_for_instances(instances):\n+                    if len(instances) == 1:\n+                        instances[0].refresh_from_db(fields=[field_name])\n+                    else:\n+                        attname = self.field.attname\n+                        value_by_pk = {\n+                            pk: value\n+                            for pk, value in self.field.model._base_manager.db_manager()\n+                            .filter(pk__in={i.pk for i in instances})\n+                            .values_list(\"pk\", attname)\n+                        }\n+                        for instance in instances:\n+                            setattr(instance, attname, value_by_pk[instance.pk])\n+\n+                get_lazy_mode()(instance, self.field, fetch_for_instances)",
      "comment": "Yeah, that would be good. I originally tried an interface but it was hard for some reason. At least, it was confusing whether methods should live on the descriptors or fields. I will give it another try, making the descriptors the \u201cfetchers\u201d.\r\n\r\nFetch one and many have separate implementations here only for backwards compatibility. Since its introduction, `refresh_from_db()` [has been documented](https://docs.djangoproject.com/en/5.0/ref/models/instances/#django.db.models.Model.refresh_from_db) as the backing method for deferred attributes:\r\n\r\n> Note that when deferred fields are accessed, the loading of the deferred field\u2019s value happens through this method.\r\n\r\nThere are more backwards compatibility concerns for related descriptors, but there won\u2019t be for `GenericForeignKey` (TODO), so maybe we should only have one method.",
      "comment_id": 1575951348,
      "user": "adamchainz",
      "created_at": "2024-04-23T09:33:07Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1575951348"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 222,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,7 +204,22 @@ def __get__(self, instance, cls=None):\n                     raise AttributeError(\n                         \"Cannot read a generated field from an unsaved model.\"\n                     )\n-                instance.refresh_from_db(fields=[field_name])\n+\n+                def fetch_for_instances(instances):\n+                    if len(instances) == 1:\n+                        instances[0].refresh_from_db(fields=[field_name])\n+                    else:\n+                        attname = self.field.attname\n+                        value_by_pk = {\n+                            pk: value\n+                            for pk, value in self.field.model._base_manager.db_manager()\n+                            .filter(pk__in={i.pk for i in instances})\n+                            .values_list(\"pk\", attname)\n+                        }\n+                        for instance in instances:\n+                            setattr(instance, attname, value_by_pk[instance.pk])\n+\n+                get_lazy_mode()(instance, self.field, fetch_for_instances)",
      "comment": "I\u2019ve just updated to a new mode with a `Fetcher` protocol using only a single `fetch()` method. The protocol also comes with the requirement `.field` resolves to the target field, for the `RAISE` lazy mode, but that is already the case for `DeferredAttribute`, `ReverseOneToOneDescriptor`, and `ForwardManyToOneDescriptor`. We can add `field` to `GenericForeignKey`, although it will be a little weird since the field is its own descriptor.",
      "comment_id": 1579632361,
      "user": "adamchainz",
      "created_at": "2024-04-25T14:54:13Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1579632361"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/lazy.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from contextlib import contextmanager",
      "comment": "What do you think about putting this module in `db.models.fields` ? The fetching code here is all called from, and calls back to, fields. It seems logical to me...",
      "comment_id": 1579648680,
      "user": "adamchainz",
      "created_at": "2024-04-25T15:00:27Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1579648680"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/lazy.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from contextlib import contextmanager",
      "comment": "I\u2019ve tried that for now, and updated the release notes to avoid the word lazy. I went for \u201con-demand fetching\u201d, which makes sense to me. WDYT?",
      "comment_id": 1579823787,
      "user": "adamchainz",
      "created_at": "2024-04-25T16:47:19Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1579823787"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/lazy.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from contextlib import contextmanager\n+\n+from asgiref.local import Local\n+\n+\n+def FETCH_ONE(instance, field, fetch_for_instances, **kwargs):\n+    fetch_for_instances((instance,))\n+\n+\n+def FETCH_PEERS(instance, field, fetch_for_instances, **kwargs):\n+    instances = [\n+        peer\n+        for weakref_peer in instance._state.peers\n+        if (peer := weakref_peer()) is not None\n+    ]\n+    if not instances:\n+        # Peers aren\u2019t tracked for QuerySets returning a single instance\n+        instances = (instance,)\n+\n+    fetch_for_instances(instances)\n+\n+\n+class LazyFieldAccess(Exception):\n+    \"\"\"Blocked lazy access of a model field.\"\"\"\n+\n+    pass\n+\n+\n+def RAISE(instance, field, fetch_for_instances, **kwargs):",
      "comment": "I see, that makes sense to separate non-terminal _surfacing_ of _leaks_ from the actual fetching implementation. I wonder if there is anything that we could provide to avoid such boiler plate though.",
      "comment_id": 1590395782,
      "user": "charettes",
      "created_at": "2024-05-05T19:34:29Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1590395782"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 222,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,7 +204,22 @@ def __get__(self, instance, cls=None):\n                     raise AttributeError(\n                         \"Cannot read a generated field from an unsaved model.\"\n                     )\n-                instance.refresh_from_db(fields=[field_name])\n+\n+                def fetch_for_instances(instances):\n+                    if len(instances) == 1:\n+                        instances[0].refresh_from_db(fields=[field_name])\n+                    else:\n+                        attname = self.field.attname\n+                        value_by_pk = {\n+                            pk: value\n+                            for pk, value in self.field.model._base_manager.db_manager()\n+                            .filter(pk__in={i.pk for i in instances})\n+                            .values_list(\"pk\", attname)\n+                        }\n+                        for instance in instances:\n+                            setattr(instance, attname, value_by_pk[instance.pk])\n+\n+                get_lazy_mode()(instance, self.field, fetch_for_instances)",
      "comment": "That looks great! Any reason for going with a single `fetch` method over two distinct `fetch_(one|many)`?\r\n\r\nI don't see it as a hard blocker but the fact that all `fetch` implementations have an `if` branch that is unnecessary from the caller's perspective (the mode handler knows which method it should call) seemed odd to me.",
      "comment_id": 1590396387,
      "user": "charettes",
      "created_at": "2024-05-05T19:38:03Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1590396387"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/lazy.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from contextlib import contextmanager",
      "comment": "I think your proposed structure and wording under `fields.fetching` makes a lot of sense. Thank you for doing that!",
      "comment_id": 1590396565,
      "user": "charettes",
      "created_at": "2024-05-05T19:39:08Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1590396565"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/fetching.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+from contextlib import contextmanager\n+\n+from asgiref.local import Local\n+\n+\n+def FETCH_ONE(fetcher, instance, **kwargs):\n+    fetcher.fetch((instance,))\n+\n+\n+def FETCH_PEERS(fetcher, instance, **kwargs):\n+    if instance._state.peers:\n+        instances = [\n+            peer\n+            for weakref_peer in instance._state.peers\n+            if (peer := weakref_peer()) is not None\n+        ]\n+    else:\n+        # Peers aren\u2019t tracked for QuerySets returning a single instance\n+        instances = (instance,)\n+\n+    fetcher.fetch(instances)\n+\n+\n+class LazyFieldAccess(Exception):\n+    \"\"\"Blocked lazy access of a model field.\"\"\"\n+\n+    pass\n+\n+\n+def RAISE(fetcher, instance, **kwargs):",
      "comment": "Should we get rid of the `**kwargs`? Were they meant to be used for something?",
      "comment_id": 1590501433,
      "user": "charettes",
      "created_at": "2024-05-06T03:25:11Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1590501433"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/fetching.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+from contextlib import contextmanager\n+\n+from asgiref.local import Local\n+\n+\n+def FETCH_ONE(fetcher, instance, **kwargs):\n+    fetcher.fetch((instance,))\n+\n+\n+def FETCH_PEERS(fetcher, instance, **kwargs):\n+    if instance._state.peers:\n+        instances = [\n+            peer\n+            for weakref_peer in instance._state.peers\n+            if (peer := weakref_peer()) is not None\n+        ]\n+    else:\n+        # Peers aren\u2019t tracked for QuerySets returning a single instance\n+        instances = (instance,)\n+\n+    fetcher.fetch(instances)\n+\n+\n+class LazyFieldAccess(Exception):\n+    \"\"\"Blocked lazy access of a model field.\"\"\"\n+\n+    pass\n+\n+\n+def RAISE(fetcher, instance, **kwargs):",
      "comment": "I left them to leave space for future extensions, if users wrap the calls. But I guess we don\u2019t have that for the callables in `django.db.models.deletion`, so we can drop them.",
      "comment_id": 1592071411,
      "user": "adamchainz",
      "created_at": "2024-05-07T08:56:51Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1592071411"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/fetching.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+from contextlib import contextmanager\n+\n+from asgiref.local import Local\n+\n+\n+def FETCH_ONE(fetcher, instance, **kwargs):\n+    fetcher.fetch((instance,))\n+\n+\n+def FETCH_PEERS(fetcher, instance, **kwargs):\n+    if instance._state.peers:\n+        instances = [\n+            peer\n+            for weakref_peer in instance._state.peers\n+            if (peer := weakref_peer()) is not None\n+        ]\n+    else:\n+        # Peers aren\u2019t tracked for QuerySets returning a single instance\n+        instances = (instance,)\n+\n+    fetcher.fetch(instances)\n+\n+\n+class LazyFieldAccess(Exception):\n+    \"\"\"Blocked lazy access of a model field.\"\"\"\n+\n+    pass\n+\n+\n+def RAISE(fetcher, instance, **kwargs):",
      "comment": "I'm not that familiar with the back compat policy but the kwargs feels unnecessary\r\nif I had a custom fetch mode I would understand if a feature release broke it due to signature change and it would break loud and fast\r\n",
      "comment_id": 1626056734,
      "user": "tolomea",
      "created_at": "2024-06-04T13:50:33Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1626056734"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/fetching.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+from contextlib import contextmanager\n+\n+from asgiref.local import Local\n+\n+\n+def FETCH_ONE(fetcher, instance, **kwargs):\n+    fetcher.fetch((instance,))\n+\n+\n+def FETCH_PEERS(fetcher, instance, **kwargs):\n+    if instance._state.peers:\n+        instances = [\n+            peer\n+            for weakref_peer in instance._state.peers\n+            if (peer := weakref_peer()) is not None\n+        ]\n+    else:\n+        # Peers aren\u2019t tracked for QuerySets returning a single instance\n+        instances = (instance,)\n+\n+    fetcher.fetch(instances)\n+\n+\n+class LazyFieldAccess(Exception):\n+    \"\"\"Blocked lazy access of a model field.\"\"\"\n+\n+    pass\n+\n+\n+def RAISE(fetcher, instance, **kwargs):\n+    klass = instance.__class__.__qualname__\n+    field_name = fetcher.field.name\n+    raise LazyFieldAccess(f\"Lazy loading of {klass}.{field_name} blocked.\")\n+\n+\n+_default = FETCH_ONE\n+_local = Local()\n+\n+\n+def set_default_fetching_mode(mode):\n+    global _default\n+    if not callable(mode):  # TODO: verify signature\n+        raise TypeError(\"mode must be callable.\")\n+    _default = mode\n+\n+\n+@contextmanager\n+def lazy_mode(mode):",
      "comment": "Yes, but I went with `fetch_mode` to keep it shorter.",
      "comment_id": 1965336672,
      "user": "adamchainz",
      "created_at": "2025-02-21T11:36:54Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1965336672"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 222,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,7 +204,22 @@ def __get__(self, instance, cls=None):\n                     raise AttributeError(\n                         \"Cannot read a generated field from an unsaved model.\"\n                     )\n-                instance.refresh_from_db(fields=[field_name])\n+\n+                def fetch_for_instances(instances):\n+                    if len(instances) == 1:\n+                        instances[0].refresh_from_db(fields=[field_name])\n+                    else:\n+                        attname = self.field.attname\n+                        value_by_pk = {\n+                            pk: value\n+                            for pk, value in self.field.model._base_manager.db_manager()\n+                            .filter(pk__in={i.pk for i in instances})\n+                            .values_list(\"pk\", attname)\n+                        }\n+                        for instance in instances:\n+                            setattr(instance, attname, value_by_pk[instance.pk])\n+\n+                get_lazy_mode()(instance, self.field, fetch_for_instances)",
      "comment": "Now using `fetch_one` and `fetch_many`! No need for a branch.",
      "comment_id": 1965362281,
      "user": "adamchainz",
      "created_at": "2025-02-21T11:57:09Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1965362281"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/fetching.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+from contextlib import contextmanager\n+\n+from asgiref.local import Local\n+\n+\n+def FETCH_ONE(fetcher, instance, **kwargs):\n+    fetcher.fetch((instance,))\n+\n+\n+def FETCH_PEERS(fetcher, instance, **kwargs):\n+    if instance._state.peers:\n+        instances = [\n+            peer\n+            for weakref_peer in instance._state.peers\n+            if (peer := weakref_peer()) is not None\n+        ]\n+    else:\n+        # Peers aren\u2019t tracked for QuerySets returning a single instance\n+        instances = (instance,)\n+\n+    fetcher.fetch(instances)\n+\n+\n+class LazyFieldAccess(Exception):\n+    \"\"\"Blocked lazy access of a model field.\"\"\"\n+\n+    pass\n+\n+\n+def RAISE(fetcher, instance, **kwargs):",
      "comment": "I got rid of `**kwargs`. If we document \u201cmake your own mode\u201d, we can encourage using them there.",
      "comment_id": 1965363855,
      "user": "adamchainz",
      "created_at": "2025-02-21T11:58:08Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1965363855"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "tests/model_fields/test_fetch_mode.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,59 @@\n+from django.db.models import (\n+    FETCH_ONE,\n+    FETCH_PEERS,\n+    RAISE,\n+    fetch_mode,\n+    set_default_fetch_mode,\n+)\n+from django.db.models.fields.fetch_modes import get_fetch_mode\n+from django.test import SimpleTestCase\n+\n+\n+class FetchModeTests(SimpleTestCase):\n+    def test_set_default_fetch_mode(self):\n+        try:\n+            set_default_fetch_mode(RAISE)\n+            self.assertIs(get_fetch_mode(), RAISE)\n+        finally:\n+            set_default_fetch_mode(FETCH_ONE)\n+\n+    def test_set_default_non_callable(self):\n+        msg = \"'RAISE' is not a callable object\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            set_default_fetch_mode(\"RAISE\")\n+\n+    def test_set_default_incorrect_signature(self):\n+        msg = \"mode must have signature (fetcher, instance).\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            set_default_fetch_mode(lambda x: x)\n+\n+    def test_fetch_mode_context_manager(self):\n+        self.assertIs(get_fetch_mode(), FETCH_ONE)\n+\n+        with fetch_mode(RAISE):\n+            self.assertIs(get_fetch_mode(), RAISE)\n+\n+        self.assertIs(get_fetch_mode(), FETCH_ONE)\n+\n+    def test_fetch_mode_nested(self):\n+        with fetch_mode(RAISE):\n+            self.assertIs(get_fetch_mode(), RAISE)\n+            with fetch_mode(FETCH_PEERS):\n+                self.assertIs(get_fetch_mode(), FETCH_PEERS)\n+            self.assertIs(get_fetch_mode(), RAISE)\n+\n+    @fetch_mode(RAISE)\n+    def test_fetch_mode_decorator(self):\n+        self.assertIs(get_fetch_mode(), RAISE)\n+\n+    def test_fetch_mode_non_callable(self):\n+        msg = \"'RAISE' is not a callable object\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            with fetch_mode(\"RAISE\"):\n+                pass\n+\n+    def test_bad_argument(self):\n+        msg = \"mode must have signature (fetcher, instance).\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            with fetch_mode(lambda x: x):\n+                pass",
      "comment": "(this is not the correct file/line for this comment)\r\n\r\ndoes fetch modes work with manytomany fields? if so, are there any tests?  if not, I think we should document that as a limitation of fetch modes. ignore this comment if this is already covered somewhere that I missed.",
      "comment_id": 1983136003,
      "user": "pelme",
      "created_at": "2025-03-06T10:51:59Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1983136003"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 959,
      "side": "RIGHT",
      "diff_hunk": "@@ -954,7 +954,9 @@ def contribute_to_class(self, cls, name, private_only=False):\n         self.model = cls\n         cls._meta.add_field(self, private=private_only)\n         if self.column:\n-            setattr(cls, self.attname, self.descriptor_class(self))\n+            descriptor = self.descriptor_class(self)\n+            setattr(cls, self.attname, descriptor)\n+            descriptor.__set_name__(cls, self.name)",
      "comment": "Could we potentially avoid calling these magic methods directly? Why can't descriptors rely on `self.field.name` instead if they require it?",
      "comment_id": 1983704129,
      "user": "charettes",
      "created_at": "2025-03-06T16:38:10Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1983704129"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,6 +145,16 @@ def __iter__(self):\n                 else:\n                     setattr(obj, field.name, rel_obj)\n \n+            # Create peers, but only for >1 result, to save memory.\n+            if first_obj is None:\n+                first_obj = obj\n+            else:",
      "comment": "Could we also avoid storing peers entirely when this feature is not enabled? If memory is a concern for `>1` I assume it might also be the case for the existing Django projects where this feature is not necessary?",
      "comment_id": 1983718536,
      "user": "charettes",
      "created_at": "2025-03-06T16:47:20Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1983718536"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/fetch_modes.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+from contextlib import contextmanager\n+\n+from asgiref.local import Local\n+\n+from django.core.exceptions import FieldFetchBlocked\n+from django.utils.inspect import get_func_args\n+\n+\n+def FETCH_ONE(fetcher, instance):\n+    fetcher.fetch_one(instance)\n+\n+\n+def FETCH_PEERS(fetcher, instance):\n+    if instance._state.peers:\n+        instances = [\n+            peer\n+            for weakref_peer in instance._state.peers\n+            if (peer := weakref_peer()) is not None\n+        ]\n+        fetcher.fetch_many(instances)\n+    else:\n+        # Peers aren\u2019t tracked for QuerySets returning a single instance\n+        fetcher.fetch_one(instance)\n+\n+\n+def RAISE(fetcher, instance):\n+    klass = instance.__class__.__qualname__\n+    field_name = fetcher.name\n+    raise FieldFetchBlocked(f\"Fetching of {klass}.{field_name} blocked.\")\n+\n+\n+_default = FETCH_ONE\n+_local = Local()\n+\n+\n+def validate_mode(mode):\n+    if get_func_args(mode) != [\"fetcher\", \"instance\"]:\n+        raise TypeError(\"mode must have signature (fetcher, instance).\")\n+\n+\n+def set_default_fetch_mode(mode):\n+    global _default\n+    validate_mode(mode)\n+    _default = mode\n+\n+\n+@contextmanager\n+def fetch_mode(mode):\n+    validate_mode(mode)\n+\n+    orig = getattr(_local, \"mode\", None)\n+    _local.mode = mode\n+    try:\n+        yield\n+    finally:\n+        if orig is None:\n+            del _local.mode\n+        else:\n+            _local.mode = orig",
      "comment": "I've brought it before but the fact the fetch mode is a global variable as opposed to attributed to `QuerySet` instances is likely going to make ergonomics quite weird when wanting to mix modes for distinct querysets or enable it only in some cases.\r\n\r\nI believe the way database routing is implemented for example where both `QuerySet.using` and routers can be used to determine what database should be used is battle proven approach. If you then want to rely on global state decorators to advise your router decision you can but Django has lived quite well without having core support for that in database routers.\r\n\r\nThe lack of queryset method / hook prevents usage of this feature in declarative scenarios such as admins, CBV, or anything that takes a `QuerySet` as a parameter (form, serializer).\r\n\r\ne.g.\r\n\r\n```python\r\nclass BookView(ListView):\r\n   queryset = Book.objects.fetch_mode(FETCH_PEERS)\r\n\r\n\r\nclass AuthorManager(Manager):\r\n   def get_queryset(self):\r\n       return super().get_queryset().fetch_mode(RAISE)\r\n\r\nclass Author(Model):\r\n    objects = AuthorManager()\r\n```",
      "comment_id": 1983745446,
      "user": "charettes",
      "created_at": "2025-03-06T17:05:03Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1983745446"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,6 +145,16 @@ def __iter__(self):\n                 else:\n                     setattr(obj, field.name, rel_obj)\n \n+            # Create peers, but only for >1 result, to save memory.\n+            if first_obj is None:\n+                first_obj = obj\n+            else:",
      "comment": "If the fetching mode was bound to the current queryset instance this whole logic could be delegated to the fetcher itself. That would allow the `FetchPeer` logic to handle the `list[weakref]` creation only when needed while avoiding its creation when dealing with other fetching modes.",
      "comment_id": 1983758471,
      "user": "charettes",
      "created_at": "2025-03-06T17:14:00Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r1983758471"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,6 +145,16 @@ def __iter__(self):\n                 else:\n                     setattr(obj, field.name, rel_obj)\n \n+            # Create peers, but only for >1 result, to save memory.\n+            if first_obj is None:\n+                first_obj = obj\n+            else:",
      "comment": "This is done.\r\n\r\nI also added peers during `RawModelIterable`, making fetch modes work for instances retrieved through raw queries.",
      "comment_id": 2021099404,
      "user": "adamchainz",
      "created_at": "2025-03-31T13:57:09Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2021099404"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "tests/model_fields/test_fetch_mode.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,59 @@\n+from django.db.models import (\n+    FETCH_ONE,\n+    FETCH_PEERS,\n+    RAISE,\n+    fetch_mode,\n+    set_default_fetch_mode,\n+)\n+from django.db.models.fields.fetch_modes import get_fetch_mode\n+from django.test import SimpleTestCase\n+\n+\n+class FetchModeTests(SimpleTestCase):\n+    def test_set_default_fetch_mode(self):\n+        try:\n+            set_default_fetch_mode(RAISE)\n+            self.assertIs(get_fetch_mode(), RAISE)\n+        finally:\n+            set_default_fetch_mode(FETCH_ONE)\n+\n+    def test_set_default_non_callable(self):\n+        msg = \"'RAISE' is not a callable object\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            set_default_fetch_mode(\"RAISE\")\n+\n+    def test_set_default_incorrect_signature(self):\n+        msg = \"mode must have signature (fetcher, instance).\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            set_default_fetch_mode(lambda x: x)\n+\n+    def test_fetch_mode_context_manager(self):\n+        self.assertIs(get_fetch_mode(), FETCH_ONE)\n+\n+        with fetch_mode(RAISE):\n+            self.assertIs(get_fetch_mode(), RAISE)\n+\n+        self.assertIs(get_fetch_mode(), FETCH_ONE)\n+\n+    def test_fetch_mode_nested(self):\n+        with fetch_mode(RAISE):\n+            self.assertIs(get_fetch_mode(), RAISE)\n+            with fetch_mode(FETCH_PEERS):\n+                self.assertIs(get_fetch_mode(), FETCH_PEERS)\n+            self.assertIs(get_fetch_mode(), RAISE)\n+\n+    @fetch_mode(RAISE)\n+    def test_fetch_mode_decorator(self):\n+        self.assertIs(get_fetch_mode(), RAISE)\n+\n+    def test_fetch_mode_non_callable(self):\n+        msg = \"'RAISE' is not a callable object\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            with fetch_mode(\"RAISE\"):\n+                pass\n+\n+    def test_bad_argument(self):\n+        msg = \"mode must have signature (fetcher, instance).\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            with fetch_mode(lambda x: x):\n+                pass",
      "comment": "They don't work with related managers from `ManyToManyField` or the reverse side of a `ForeignKey`. Some support could potentially be added later, at least for `.all()`, analogously with how `prefetch_related` can prefetch such querysets. The related manager classes would need to become \"fetcher\" classes and call the fetch mode like fields do, saving results back in the instances\u2019 `_prefetched_objects_cache` attrs.\r\n\r\nI think it's clear enough now that in the new fetch mode docs that we list what *is* supported, no need to explicitly call out related managers as unsupported.",
      "comment_id": 2021114339,
      "user": "adamchainz",
      "created_at": "2025-03-31T14:04:01Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2021114339"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 959,
      "side": "RIGHT",
      "diff_hunk": "@@ -954,7 +954,9 @@ def contribute_to_class(self, cls, name, private_only=False):\n         self.model = cls\n         cls._meta.add_field(self, private=private_only)\n         if self.column:\n-            setattr(cls, self.attname, self.descriptor_class(self))\n+            descriptor = self.descriptor_class(self)\n+            setattr(cls, self.attname, descriptor)\n+            descriptor.__set_name__(cls, self.name)",
      "comment": "The aim here was to have the \"fetcher protocol\" include a consistent way to see the related field's name available, so the `RAISE` mode can rely on it.\r\n\r\nDescriptors did not consistently point at fields. At least `GenericForeignKey` is, oddly, its own descriptor. Adding a recursive `field` attribute there felt wrong, but it seemed to make sense to call [`__set_name__`](https://docs.python.org/3/reference/datamodel.html#object.__set_name__) here because it's the same point that Python would do so if the descriptor were placed in the class definition.\r\n\r\nIn retrospect, it's probably less invasive and more sensible to make `field` consistently available, and fix GFK to have a separate descriptor class. I'll give that a try now.",
      "comment_id": 2042249701,
      "user": "adamchainz",
      "created_at": "2025-04-14T14:23:12Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2042249701"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/related_descriptors.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,6 +134,9 @@ class Child(Model):\n     def __init__(self, field_with_rel):\n         self.field = field_with_rel\n \n+    def __set_name__(self, owner, name):\n+        self.name = name\n+",
      "comment": "Per above - trying with field.\r\n\r\nhttps://github.com/django/django/pull/17554#discussion_r2042249701",
      "comment_id": 2042251992,
      "user": "adamchainz",
      "created_at": "2025-04-14T14:24:22Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2042251992"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/__init__.py",
      "line": 959,
      "side": "RIGHT",
      "diff_hunk": "@@ -954,7 +954,9 @@ def contribute_to_class(self, cls, name, private_only=False):\n         self.model = cls\n         cls._meta.add_field(self, private=private_only)\n         if self.column:\n-            setattr(cls, self.attname, self.descriptor_class(self))\n+            descriptor = self.descriptor_class(self)\n+            setattr(cls, self.attname, descriptor)\n+            descriptor.__set_name__(cls, self.name)",
      "comment": "Okay, I just pushed a fix. It required a new commit that splits a descriptor class from `GenericForeignKey`, which I also put into a new PR at #19381. Another minor hack it required is a new property in `ReverseOneToOneDescriptor` for `field`, with a docstring explaining the ducktyping.",
      "comment_id": 2042353629,
      "user": "adamchainz",
      "created_at": "2025-04-14T15:08:02Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2042353629"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,6 +242,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "I wonder if the set comprehension here could have some performance impact for a large number of `instances`. I'm not sure what else could be done instead though.",
      "comment_id": 2062580287,
      "user": "g-nie",
      "created_at": "2025-04-27T09:53:06Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2062580287"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,6 +242,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "It shouldn't take a meaningful amount of time. Yes, it's for N instances, but gathering their in-memory PKs will be way faster than the actual query.",
      "comment_id": 2067519711,
      "user": "adamchainz",
      "created_at": "2025-04-29T22:36:44Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2067519711"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/contrib/contenttypes/fields.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,11 +156,19 @@ def get_content_type(self, obj=None, id=None, using=None, model=None):\n             # This should never happen. I love comments like this, don't you?\n             raise Exception(\"Impossible arguments to GFK.get_content_type!\")\n \n+\n+class GenericForeignKeyDescriptor:",
      "comment": "Just to make sure I understand the rationale behind this change.\r\n\r\nThe same thing could be achieved by adding a `field` property on `GenericForeignKey` that returns `self` but a distinct class is deemed preferable as it makes `GenericForeignKey` follow the pattern used by other related fields.\r\n\r\nIt might be worth _explaining_ the rationale behind these changes in the commit message and the benefits it provides for the followed commits in the patch set for future reference.",
      "comment_id": 2191302268,
      "user": "charettes",
      "created_at": "2025-07-08T01:37:18Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2191302268"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/contrib/contenttypes/fields.py",
      "line": 281,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,7 +267,10 @@ def __get__(self, instance, cls=None):\n             except ObjectDoesNotExist:\n                 pass\n         self.field.set_cached_value(instance, rel_obj)\n-        return rel_obj\n+\n+    def fetch_many(self, instances):\n+        missing_instances = [i for i in instances if not self.field.is_cached(i)]",
      "comment": "Minor but it might be worth using a local reference for `self.field.is_cached` to avoid two attribute lookups per instance in a potentially large loop\r\n\r\n```python\r\nis_cached = self.field.is_cache\r\nmissing_instances = [i for i in instances if not is_cached(i)]\r\n```",
      "comment_id": 2191308766,
      "user": "charettes",
      "created_at": "2025-07-08T01:44:59Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2191308766"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/base.py",
      "line": 494,
      "side": "RIGHT",
      "diff_hunk": "@@ -473,6 +482,14 @@ class ModelState:\n     # on the actual save.\n     adding = True\n     fields_cache = ModelStateFieldsCacheDescriptor()\n+    fetch_mode = ModelStateFetchModeDescriptor()\n+    peers = ()\n+\n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        state.pop(\"fetch_mode\", None)\n+        state.pop(\"peers\", None)",
      "comment": "Just to make sure I understand, does this mean that a pickled model instances, and by definition a queryset of such objects, looses its fetch mode affinity? For example would that mean that caching a queryset though pickling and then unpickling it would not preserve the specified mode (e.g. raising errors on attributes that would require fetching).\r\n\r\nMaybe that's by design but the lack of comments makes me wonder the purpose behind it.",
      "comment_id": 2191313616,
      "user": "charettes",
      "created_at": "2025-07-08T01:48:55Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2191313616"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,52 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:\n+    __slots__ = ()\n+\n+    track_peers = False\n+\n+    def fetch(self, fetcher, instance):\n+        raise NotImplementedError(\"Subclasses must implement this method.\")\n+\n+\n+class FetchOne(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        fetcher.fetch_one(instance)\n+\n+\n+FETCH_ONE = FetchOne()\n+\n+\n+class FetchPeers(FetchMode):\n+    __slots__ = ()\n+\n+    track_peers = True\n+\n+    def fetch(self, fetcher, instance):\n+        instances = [\n+            peer\n+            for peer_weakref in instance._state.peers\n+            if (peer := peer_weakref()) is not None\n+        ]\n+        if len(instances) > 1:\n+            fetcher.fetch_many(instances)\n+        else:\n+            fetcher.fetch_one(instance)\n+\n+\n+FETCH_PEERS = FetchPeers()\n+\n+\n+class Raise(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        klass = instance.__class__.__qualname__\n+        field_name = fetcher.field.name\n+        raise FieldFetchBlocked(f\"Fetching of {klass}.{field_name} blocked.\")\n+\n+\n+RAISE = Raise()",
      "comment": "Really like how this turned out, thanks for the tweaks!",
      "comment_id": 2191315057,
      "user": "charettes",
      "created_at": "2025-07-08T01:50:46Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2191315057"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/related_descriptors.py",
      "line": 465,
      "side": "RIGHT",
      "diff_hunk": "@@ -441,16 +447,20 @@ def RelatedObjectDoesNotExist(self):\n     def is_cached(self, instance):\n         return self.related.is_cached(instance)\n \n-    def get_queryset(self, **hints):\n-        return self.related.related_model._base_manager.db_manager(hints=hints).all()\n+    def get_queryset(self, *, instance):\n+        return self.related.related_model._base_manager.db_manager(\n+            hints={\"instance\": instance}",
      "comment": "I appreciate that a clearer signature is used but it should be done in a distinct commit as it might be used under other circumstances in the wild.",
      "comment_id": 2191322664,
      "user": "charettes",
      "created_at": "2025-07-08T01:59:07Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2191322664"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/related_descriptors.py",
      "line": 479,
      "side": "RIGHT",
      "diff_hunk": "@@ -441,16 +447,20 @@ def RelatedObjectDoesNotExist(self):\n     def is_cached(self, instance):\n         return self.related.is_cached(instance)\n \n-    def get_queryset(self, **hints):\n-        return self.related.related_model._base_manager.db_manager(hints=hints).all()\n+    def get_queryset(self, *, instance):\n+        return self.related.related_model._base_manager.db_manager(\n+            hints={\"instance\": instance}\n+        ).fetch_mode(instance._state.fetch_mode)\n \n     def get_prefetch_querysets(self, instances, querysets=None):\n         if querysets and len(querysets) != 1:\n             raise ValueError(\n                 \"querysets argument of get_prefetch_querysets() should have a length \"\n                 \"of 1.\"\n             )\n-        queryset = querysets[0] if querysets else self.get_queryset()\n+        queryset = (\n+            querysets[0] if querysets else self.get_queryset(instance=instances[0])\n+        )\n         queryset._add_hints(instance=instances[0])",
      "comment": "Aren't these two `instance` hint passing redundant?",
      "comment_id": 2191323414,
      "user": "charettes",
      "created_at": "2025-07-08T02:00:07Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2191323414"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,52 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:\n+    __slots__ = ()\n+\n+    track_peers = False\n+\n+    def fetch(self, fetcher, instance):\n+        raise NotImplementedError(\"Subclasses must implement this method.\")\n+\n+\n+class FetchOne(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        fetcher.fetch_one(instance)\n+\n+\n+FETCH_ONE = FetchOne()\n+\n+\n+class FetchPeers(FetchMode):\n+    __slots__ = ()\n+\n+    track_peers = True\n+\n+    def fetch(self, fetcher, instance):\n+        instances = [\n+            peer\n+            for peer_weakref in instance._state.peers\n+            if (peer := peer_weakref()) is not None\n+        ]\n+        if len(instances) > 1:\n+            fetcher.fetch_many(instances)\n+        else:\n+            fetcher.fetch_one(instance)\n+\n+\n+FETCH_PEERS = FetchPeers()\n+\n+\n+class Raise(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        klass = instance.__class__.__qualname__\n+        field_name = fetcher.field.name\n+        raise FieldFetchBlocked(f\"Fetching of {klass}.{field_name} blocked.\")",
      "comment": "Thanks for this tool, currently using it to debug a project. I noticed that with `RAISE`, the exception raised here will include context like:\r\n\r\n```py\r\nTraceback (most recent call last):\r\n  File \"/Users/jwalls/django/django/db/models/fields/related_descriptors.py\", line 231, in __get__\r\n    rel_obj = self.field.get_cached_value(instance)\r\n  File \"/Users/jwalls/django/django/db/models/fields/mixins.py\", line 21, in get_cached_value\r\n    return instance._state.fields_cache[self.cache_name]\r\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^\r\nKeyError: 'nodegroup'\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n```\r\n\r\nWhat do you think about raising this error `from None` to suppress that irrelevant context?",
      "comment_id": 2261482253,
      "user": "jacobtylerwalls",
      "created_at": "2025-08-07T21:44:57Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2261482253"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query.py",
      "line": 313,
      "side": "RIGHT",
      "diff_hunk": "@@ -291,6 +308,7 @@ def __init__(self, model=None, query=None, using=None, hints=None):\n         self._prefetch_done = False\n         self._known_related_objects = {}  # {rel_field: {pk: rel_obj}}\n         self._iterable_class = ModelIterable\n+        self._fetch_mode = FETCH_ONE",
      "comment": "When debugging a project earlier this summer, it was enormously helpful to be able to just monkey-patch this to `RAISE` and comb through failures.\r\n\r\nOne _interesting_ failure I wasn't able to solve looked like:\r\n\r\n```py\r\nrequest.user.userprofile\r\n```\r\n```py\r\ndjango.core.exceptions.FieldFetchBlocked: Fetching of User.userprofile blocked.\r\n```\r\n\r\nTo fix that, I'd need:\r\n- a custom user model\r\n- a custom model manager for that custom model that overrides `get_queryset()` to chain `.fetch_mode(models.FETCH_PEERS)`\r\n\r\nMy questions are:\r\n- that's the easiest way, right?\r\n- Is there a future where `django.contrib.auth` would ever use `.fetch_mode(models.FETCH_PEERS)` in `get_user()`? Since it's a contrib app? Or would that violate the mental model of \"django defaults to FETCH_ONE\"?\r\n\r\nOne query for a `.userprofile` per request isn't so bad, but the fact that I can't \"globally\" turn on RAISE mode without my tests immediately failing on this is actually what impacts me more.",
      "comment_id": 2311291480,
      "user": "jacobtylerwalls",
      "created_at": "2025-08-29T21:11:02Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2311291480"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query.py",
      "line": 1938,
      "side": "RIGHT",
      "diff_hunk": "@@ -1835,6 +1854,12 @@ def using(self, alias):\n         clone._db = alias\n         return clone\n \n+    def fetch_mode(self, fetch_mode):\n+        \"\"\"Set the fetch mode for the QuerySet.\"\"\"\n+        clone = self._chain()",
      "comment": "`.fetch_mode(None)` fails pretty far from the source of the problem, after the qs is evaluated:\r\n```py\r\n--> 134     if fetch_mode.track_peers:\r\n    135         peers.append(weak_ref(obj))\r\n    136         obj._state.peers = peers\r\n\r\nAttributeError: 'NoneType' object has no attribute 'track_peers'\r\n```\r\n\r\nCould we fail immediately inside this method, similar to how `.order_by(None)` immediately fails (rather than during query execution)?",
      "comment_id": 2319130510,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-03T14:15:47Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2319130510"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "Somebody in the wild might have non-hashable primary keys, which as far as I know work just fine (outside of `in_bulk()` for obvious reasons).\r\n\r\nThe test model for custom pks even lacked a `__hash__` method until 8fd21b0da35697591e86f4eab0035c4360a45144.\r\n\r\nShould we use different data structures here to account for this?",
      "comment_id": 2319162023,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-03T14:26:09Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2319162023"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/base.py",
      "line": 615,
      "side": "RIGHT",
      "diff_hunk": "@@ -595,7 +612,7 @@ def __init__(self, *args, **kwargs):\n         post_init.send(sender=cls, instance=self)\n \n     @classmethod\n-    def from_db(cls, db, field_names, values):\n+    def from_db(cls, db, field_names, values, *, fetch_mode=None):",
      "comment": "Should we document the ability to set `._state.fetch_mode` directly? I found this useful when I was downstream of a `RAISE`, but I needed to loosen the mode back to `FETCH_PEERS`, because there was no way to \"fix\" the underlying N+1 problem if the object I was dealing with came from `create()` (since there is no one-shot `create()` + `select_related()`).",
      "comment_id": 2319233714,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-03T14:48:49Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2319233714"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/contrib/contenttypes/fields.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,11 +156,19 @@ def get_content_type(self, obj=None, id=None, using=None, model=None):\n             # This should never happen. I love comments like this, don't you?\n             raise Exception(\"Impossible arguments to GFK.get_content_type!\")\n \n+\n+class GenericForeignKeyDescriptor:",
      "comment": "Yes, precisely. I added this explanation over in the separate PR (#19381):\r\n\r\n> This makes GenericForeignKey more similar to other fields which act as\r\ndescriptors, preparing it to add \u201cfetcher protocol\u201d support in a clear and\r\nconsistent way.\r\n\r\nI hope that is sufficient.",
      "comment_id": 2321568442,
      "user": "adamchainz",
      "created_at": "2025-09-04T10:30:01Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2321568442"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/contrib/contenttypes/fields.py",
      "line": 281,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,7 +267,10 @@ def __get__(self, instance, cls=None):\n             except ObjectDoesNotExist:\n                 pass\n         self.field.set_cached_value(instance, rel_obj)\n-        return rel_obj\n+\n+    def fetch_many(self, instances):\n+        missing_instances = [i for i in instances if not self.field.is_cached(i)]",
      "comment": "Done, and similarly in `ForwardManyToOneDescriptor` and `ReverseOneToOneDescriptor` as well.",
      "comment_id": 2322151599,
      "user": "adamchainz",
      "created_at": "2025-09-04T13:25:30Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2322151599"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,52 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:\n+    __slots__ = ()\n+\n+    track_peers = False\n+\n+    def fetch(self, fetcher, instance):\n+        raise NotImplementedError(\"Subclasses must implement this method.\")\n+\n+\n+class FetchOne(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        fetcher.fetch_one(instance)\n+\n+\n+FETCH_ONE = FetchOne()\n+\n+\n+class FetchPeers(FetchMode):\n+    __slots__ = ()\n+\n+    track_peers = True\n+\n+    def fetch(self, fetcher, instance):\n+        instances = [\n+            peer\n+            for peer_weakref in instance._state.peers\n+            if (peer := peer_weakref()) is not None\n+        ]\n+        if len(instances) > 1:\n+            fetcher.fetch_many(instances)\n+        else:\n+            fetcher.fetch_one(instance)\n+\n+\n+FETCH_PEERS = FetchPeers()\n+\n+\n+class Raise(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        klass = instance.__class__.__qualname__\n+        field_name = fetcher.field.name\n+        raise FieldFetchBlocked(f\"Fetching of {klass}.{field_name} blocked.\")",
      "comment": "Done, and expanded the tests to check for this with extra assertions like:\r\n\r\n```python\r\nwith self.assertRaisesMessage(FieldFetchBlocked, msg) as cm:\r\n    ...\r\nself.assertIsNone(cm.exception.__cause__)\r\nself.assertTrue(cm.exception.__suppress_context__)\r\n```",
      "comment_id": 2322200121,
      "user": "adamchainz",
      "created_at": "2025-09-04T13:37:27Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2322200121"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fields/related_descriptors.py",
      "line": 465,
      "side": "RIGHT",
      "diff_hunk": "@@ -441,16 +447,20 @@ def RelatedObjectDoesNotExist(self):\n     def is_cached(self, instance):\n         return self.related.is_cached(instance)\n \n-    def get_queryset(self, **hints):\n-        return self.related.related_model._base_manager.db_manager(hints=hints).all()\n+    def get_queryset(self, *, instance):\n+        return self.related.related_model._base_manager.db_manager(\n+            hints={\"instance\": instance}",
      "comment": "Good point, I have split the signature change into a new commit.",
      "comment_id": 2322874407,
      "user": "adamchainz",
      "created_at": "2025-09-04T17:16:38Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2322874407"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/base.py",
      "line": 615,
      "side": "RIGHT",
      "diff_hunk": "@@ -595,7 +612,7 @@ def __init__(self, *args, **kwargs):\n         post_init.send(sender=cls, instance=self)\n \n     @classmethod\n-    def from_db(cls, db, field_names, values):\n+    def from_db(cls, db, field_names, values, *, fetch_mode=None):",
      "comment": "I think we should leave it as a private API for now. Let's allow the tinkerers who read the source to play with it for the first release.\r\n\r\nBut at least we've documented two attributes of `Model._state` ([link](https://docs.djangoproject.com/en/5.2/ref/models/instances/#django.db.models.Model._state)) so there's precedent to document it more.",
      "comment_id": 2322888562,
      "user": "adamchainz",
      "created_at": "2025-09-04T17:21:04Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2322888562"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query.py",
      "line": 1938,
      "side": "RIGHT",
      "diff_hunk": "@@ -1835,6 +1854,12 @@ def using(self, alias):\n         clone._db = alias\n         return clone\n \n+    def fetch_mode(self, fetch_mode):\n+        \"\"\"Set the fetch mode for the QuerySet.\"\"\"\n+        clone = self._chain()",
      "comment": "I'm not sure if it's worth special-casing `None` here, given it's not documented\u2026 can we push this to a follow-up enhancement?",
      "comment_id": 2323492036,
      "user": "adamchainz",
      "created_at": "2025-09-04T20:35:06Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2323492036"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "After a quick search, I think Django already doesn't support unhashable primary keys. The deletion collector performs a similar set comprehension:\r\n\r\nhttps://github.com/django/django/blob/2722cb61ccae84f593e6d2c28814e3c628743994/django/db/models/deletion.py#L490\r\n\r\nSimilarly, model forms rely on hashing PKs:\r\n\r\nhttps://github.com/django/django/blob/2722cb61ccae84f593e6d2c28814e3c628743994/django/forms/models.py#L720\r\n\r\nAlso, because values must be unique in the database, that implies a hash function can be written.\r\n\r\nSo, I think this isn't a use case we need to worry about.\r\n\r\n",
      "comment_id": 2323509075,
      "user": "adamchainz",
      "created_at": "2025-09-04T20:43:00Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2323509075"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query.py",
      "line": 313,
      "side": "RIGHT",
      "diff_hunk": "@@ -291,6 +308,7 @@ def __init__(self, model=None, query=None, using=None, hints=None):\n         self._prefetch_done = False\n         self._known_related_objects = {}  # {rel_field: {pk: rel_obj}}\n         self._iterable_class = ModelIterable\n+        self._fetch_mode = FETCH_ONE",
      "comment": "> that's the easiest way, right?\r\n\r\nI think it would be slightly easier to subclass `ModelBackend` and replace `get_user` with a version that adds the `.fetch_mode()` call.\r\n\r\n> Is there a future where `django.contrib.auth` would ever use `.fetch_mode(models.FETCH_PEERS)` in `get_user()`? Since it's a contrib app? Or would that violate the mental model of \"django defaults to FETCH_ONE\"?\r\n\r\nI think there could be such a future. I'd hope we could also change the admin to use `models.FETCH_PEERS` by default.\r\n\r\n> One query for a `.userprofile` per request isn't so bad, but the fact that I can't \"globally\" turn on RAISE mode without my tests immediately failing on this is actually what impacts me more.\r\n\r\nYeah, I found a similar issue in a project I tried the same trick on. That one failed during migrations, because a data migration in a third-party app was relying on the default `FETCH_ONE` behaviour.\r\n\r\nI don't think there's a good API we can provide to allow enabling `RAISE` globally without breaking lots of hard-to-fix stuff. That's why I've come around to Simon's suggestion of going with the `QuerySet`-based API. We can always address adding a supported global switch later, but for now having the targeted API seems best.",
      "comment_id": 2323521780,
      "user": "adamchainz",
      "created_at": "2025-09-04T20:50:16Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2323521780"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,52 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:\n+    __slots__ = ()\n+\n+    track_peers = False\n+\n+    def fetch(self, fetcher, instance):\n+        raise NotImplementedError(\"Subclasses must implement this method.\")\n+\n+\n+class FetchOne(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        fetcher.fetch_one(instance)\n+\n+\n+FETCH_ONE = FetchOne()",
      "comment": "Last Q: did you consider making this an enum? (can totally punt...)",
      "comment_id": 2323557124,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-04T21:11:08Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2323557124"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,52 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:\n+    __slots__ = ()\n+\n+    track_peers = False\n+\n+    def fetch(self, fetcher, instance):\n+        raise NotImplementedError(\"Subclasses must implement this method.\")\n+\n+\n+class FetchOne(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        fetcher.fetch_one(instance)\n+\n+\n+FETCH_ONE = FetchOne()",
      "comment": "I think initial designs used an enum or constants, but @charettes suggested to use callables, copying the `on_delete` modes like `CASCADE`. Not only is this more consistent, it opens the door for adding custom logic, like including logging or conditionally blocking fetches.",
      "comment_id": 2323750492,
      "user": "adamchainz",
      "created_at": "2025-09-04T23:35:54Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2323750492"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/base.py",
      "line": 494,
      "side": "RIGHT",
      "diff_hunk": "@@ -473,6 +482,14 @@ class ModelState:\n     # on the actual save.\n     adding = True\n     fields_cache = ModelStateFieldsCacheDescriptor()\n+    fetch_mode = ModelStateFetchModeDescriptor()\n+    peers = ()\n+\n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        state.pop(\"fetch_mode\", None)\n+        state.pop(\"peers\", None)",
      "comment": "Yes, these state removals do mean that pickled instances lose their fetch modes.\r\n\r\nI added these lines because weakrefs aren't pickleable, copying from:\r\n\r\nhttps://github.com/adamchainz/django-auto-prefetch/blob/7f3b7aed5b1b029b7ddeb4d5fa9c0d76281b4fe4/src/auto_prefetch/__init__.py#L118-L126\r\n\r\nHowever, it's a good point that unpickled instances shouldn't lose their fetch modes. I guess the best we can do is drop peers only, so `FETCH_PEERS` won't work for unpickled instances. However, it will be propagated, so at least there's that.\r\n\r\nI'll change this and add a test for an unpickled instnace.",
      "comment_id": 2323760732,
      "user": "adamchainz",
      "created_at": "2025-09-04T23:47:16Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2323760732"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/base.py",
      "line": 494,
      "side": "RIGHT",
      "diff_hunk": "@@ -473,6 +482,14 @@ class ModelState:\n     # on the actual save.\n     adding = True\n     fields_cache = ModelStateFieldsCacheDescriptor()\n+    fetch_mode = ModelStateFetchModeDescriptor()\n+    peers = ()\n+\n+    def __getstate__(self):\n+        state = self.__dict__.copy()\n+        state.pop(\"fetch_mode\", None)\n+        state.pop(\"peers\", None)",
      "comment": "I ended up adding `__reduce__` methods to fetch modes to make them pickle more efficiently, in a new commit 30c72657ff9d3747eb5d4b59aacce9bac0acdbad.",
      "comment_id": 2324686265,
      "user": "adamchainz",
      "created_at": "2025-09-05T10:15:52Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2324686265"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,52 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:\n+    __slots__ = ()\n+\n+    track_peers = False\n+\n+    def fetch(self, fetcher, instance):\n+        raise NotImplementedError(\"Subclasses must implement this method.\")\n+\n+\n+class FetchOne(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        fetcher.fetch_one(instance)\n+\n+\n+FETCH_ONE = FetchOne()",
      "comment": "I'm down with the callables, but I just meant wrapping them in an enum like this, mostly just for discoverability:\r\n```py\r\nclass FetchModes(enum.Enum):\r\n    FETCH_ONE = FETCH_ONE\r\n    FETCH_PEERS = FETCH_PEERS\r\n    RAISE = RAISE\r\n```",
      "comment_id": 2324891799,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-05T11:52:48Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2324891799"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,52 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:\n+    __slots__ = ()\n+\n+    track_peers = False\n+\n+    def fetch(self, fetcher, instance):\n+        raise NotImplementedError(\"Subclasses must implement this method.\")\n+\n+\n+class FetchOne(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        fetcher.fetch_one(instance)\n+\n+\n+FETCH_ONE = FetchOne()",
      "comment": "Oh, right\u2026 I'm not super convinced, but maybe others would be.\r\n\r\nCan we defer this one, too? I think we'd want the same pattern for the deletion modes as well, so it could be done as a cleanup affecting both.",
      "comment_id": 2324953376,
      "user": "adamchainz",
      "created_at": "2025-09-05T12:23:50Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2324953376"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "Any interest in observing database parameter limits, similar to how `in_bulk()` [does it](https://github.com/django/django/blob/0ddbe12ea99a2dc1b757dc2015ba8bb6bfd9d653/django/db/models/query.py#L1195), or factoring out some reusable private helper?",
      "comment_id": 2325273743,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-05T14:34:00Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2325273743"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "Kind of a shame that `in_bulk` doesn't support `values` / `values_list` in the first place as that could have been\r\n\r\n```python\r\nvalue_by_pk = (\r\n    self.field.model._base_manager\r\n    .values_list(attname, flat=True).in_bulk({i.pk for i in instances})\r\n)\r\n```\r\n\r\nin all cases it seems that the `db_manager()` call is unnecessary?",
      "comment_id": 2325313394,
      "user": "charettes",
      "created_at": "2025-09-05T14:49:19Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2325313394"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "> Kind of a shame that in_bulk doesn't support values / values_list\r\n\r\nI'll open a new features ticket and link to the [sketched](https://github.com/django/django/pull/18497) implementation, given that we have this additional use in Django itself now.",
      "comment_id": 2325335804,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-05T14:58:40Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2325335804"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "Also, not sure if the dict literal is faster but the `dict` function can be used as well\r\n\r\n```python\r\n        value_by_pk = dict(\r\n            self.field.model._base_manager\r\n            .filter(pk__in={i.pk for i in instances})\r\n            .values_list(\"pk\", attname)\r\n        )",
      "comment_id": 2325429976,
      "user": "charettes",
      "created_at": "2025-09-05T15:38:59Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2325429976"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "> Any interest in observing database parameter limits, similar to how `in_bulk()` [does it](https://github.com/django/django/blob/0ddbe12ea99a2dc1b757dc2015ba8bb6bfd9d653/django/db/models/query.py#L1195), or factoring out some reusable private helper?\r\n\r\nWell, yes, that seems great. I will take a look at how easy it would be to revive that old PR.\r\n\r\nParameter limit support is necessary, right? Otherwise, this will crash when there are enough instances to fetch, yes?\r\n\r\n> in all cases it seems that the `db_manager()` call is unnecessary?\r\n\r\nYup, good shout, updating.\r\n\r\n> Also, not sure if the dict literal is faster but the `dict` function can be used as well\r\n\r\n`dict()` is indeed faster:\r\n\r\n```\r\n$ uvx -p 3.14 ipython\r\n...\r\nPython 3.14.0rc1 (main, Aug  8 2025, 16:52:21) [Clang 20.1.4 ]\r\n...\r\n\r\nIn [1]: items = [(i, str(i)) for i in range(1000)]\r\n\r\nIn [2]: %timeit {k: v for k, v in items}\r\n22.1 \u03bcs \u00b1 208 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\r\n\r\nIn [3]: %timeit dict(items)\r\n15.7 \u03bcs \u00b1 52.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\r\n```\r\n\r\nI'll update.\r\n",
      "comment_id": 2339752180,
      "user": "adamchainz",
      "created_at": "2025-09-11T09:31:05Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2339752180"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,61 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:",
      "comment": "I really love this pattern because it allows users to subclass and define their own fetch mode really easily. There are many variations that users will inevitably want:\r\n - fetch-many and then log\r\n - fetch-one but log if there are peers to fetch\r\n - add sentry event (ot whatever observability platform you're using) and do each of the above.\r\n - etc.\r\n\r\nAnd this pattern allows for all of the above without an ever-growing list of fetch-modes. Is it worth documenting this? We could add a simple how-to with an example.",
      "comment_id": 2344830617,
      "user": "tim-mccurrach",
      "created_at": "2025-09-12T16:30:47Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2344830617"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,61 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:\n+    __slots__ = ()\n+\n+    track_peers = False\n+\n+    def fetch(self, fetcher, instance):\n+        raise NotImplementedError(\"Subclasses must implement this method.\")\n+\n+\n+class FetchOne(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        fetcher.fetch_one(instance)\n+\n+    def __reduce__(self):\n+        return \"FETCH_ONE\"\n+\n+\n+FETCH_ONE = FetchOne()\n+\n+\n+class FetchPeers(FetchMode):\n+    __slots__ = ()\n+\n+    track_peers = True\n+\n+    def fetch(self, fetcher, instance):\n+        instances = [\n+            peer\n+            for peer_weakref in instance._state.peers\n+            if (peer := peer_weakref()) is not None\n+        ]",
      "comment": "In light of the comment above, I think the logic within`FetchPeers` will be useful for custom fetch-modes. I can imagine users only wanting to log/do-something in the case when `len(instances) > 1`. \n\nIt would be great to make `FetchPeers` more subclass-able without users needing to copy code. Two ideas that occur are:\n - Maybe give the `fetch` method a return value of `len(instances)`, so that you can call `super().fetch(...)` and vary the behaviour accordingly.\n - Alternatively, move lines 32-36 to a separate method, `get_peers`. This would make overwriting the `fetch` method easier. (This method could even go in the base `FetchMode` class). \n",
      "comment_id": 2344857151,
      "user": "tim-mccurrach",
      "created_at": "2025-09-12T16:35:36Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2344857151"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -122,10 +125,17 @@ def __iter__(self):\n             )\n             for field, related_objs in queryset._known_related_objects.items()\n         ]\n+        peers = []\n         for row in compiler.results_iter(results):\n             obj = model_cls.from_db(\n-                db, init_list, row[model_fields_start:model_fields_end]\n+                db,\n+                init_list,\n+                row[model_fields_start:model_fields_end],\n+                fetch_mode=fetch_mode,\n             )\n+            if fetch_mode.track_peers:\n+                peers.append(weak_ref(obj))\n+                obj._state.peers = peers",
      "comment": "This is really pernickety (sorry), but `peers` starts off life as a tuple and then changes to a list here. This makes it more difficult to use, since there are fewer assumptions you can make at the point of using it. Having said this, I appreciate that this is not part of the public API, so maybe that need not be a concern.",
      "comment_id": 2344869077,
      "user": "tim-mccurrach",
      "created_at": "2025-09-12T16:41:07Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2344869077"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,61 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:",
      "comment": "Yes, I'd like to document the pattern. I was thinking of leaving it out of the initial PR, but perhaps that's not worth it at this point!",
      "comment_id": 2345545473,
      "user": "adamchainz",
      "created_at": "2025-09-12T22:38:41Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2345545473"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -122,10 +125,17 @@ def __iter__(self):\n             )\n             for field, related_objs in queryset._known_related_objects.items()\n         ]\n+        peers = []\n         for row in compiler.results_iter(results):\n             obj = model_cls.from_db(\n-                db, init_list, row[model_fields_start:model_fields_end]\n+                db,\n+                init_list,\n+                row[model_fields_start:model_fields_end],\n+                fetch_mode=fetch_mode,\n             )\n+            if fetch_mode.track_peers:\n+                peers.append(weak_ref(obj))\n+                obj._state.peers = peers",
      "comment": "There are good reasons for this discrepancy\u2026\r\n\r\n1. We keep `peers` as a class-level variable in `ModelState` to avoid creating any values for new instances that don't need.\r\n2. For class-level variables, we want them to be immutable, hence a tuple.\r\n3. When peers are collected, though, they must be a list, so we can grow it as we instantiate the model instances here.\r\n\r\nIf we were using type hints, we would define `peers: Sequence[weak_ref[T]]`, so we'd know that code relied only on the common methods of a sequence, not any of the specifics of tuple or list.",
      "comment_id": 2345566633,
      "user": "adamchainz",
      "created_at": "2025-09-12T22:54:47Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2345566633"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,61 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:",
      "comment": "I think I will leave this as a follow-up, I haven't found the time to really hash out the details, and the 6.0 merge deadline is here\u2026 Also, it's probably best to leave it for tinkerers to explore for one version before we commit to a certain pattern.\r\n\r\nI'd also like to make another follow-up, to use `FETCH_PEERS` by default in the admin.",
      "comment_id": 2354993737,
      "user": "adamchainz",
      "created_at": "2025-09-17T10:06:06Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2354993737"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/fetch_modes.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,61 @@\n+from django.core.exceptions import FieldFetchBlocked\n+\n+\n+class FetchMode:\n+    __slots__ = ()\n+\n+    track_peers = False\n+\n+    def fetch(self, fetcher, instance):\n+        raise NotImplementedError(\"Subclasses must implement this method.\")\n+\n+\n+class FetchOne(FetchMode):\n+    __slots__ = ()\n+\n+    def fetch(self, fetcher, instance):\n+        fetcher.fetch_one(instance)\n+\n+    def __reduce__(self):\n+        return \"FETCH_ONE\"\n+\n+\n+FETCH_ONE = FetchOne()\n+\n+\n+class FetchPeers(FetchMode):\n+    __slots__ = ()\n+\n+    track_peers = True\n+\n+    def fetch(self, fetcher, instance):\n+        instances = [\n+            peer\n+            for peer_weakref in instance._state.peers\n+            if (peer := peer_weakref()) is not None\n+        ]",
      "comment": "I think best to leave this for a follow-up where we document how to make a custom fetch mode.",
      "comment_id": 2354996204,
      "user": "adamchainz",
      "created_at": "2025-09-17T10:07:07Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2354996204"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "I've just rebased and made this bit use `in_bulk()` now that support was added in 1820d35b17f0a95f4ce888971b9ca0c7a3697c83.",
      "comment_id": 2387381954,
      "user": "adamchainz",
      "created_at": "2025-09-29T10:01:04Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2387381954"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "Nice. Just checking: did you plan to use `dict()` here after all?",
      "comment_id": 2387808331,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-29T12:44:07Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2387808331"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,20 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = {\n+            pk: value\n+            for pk, value in self.field.model._base_manager.db_manager()\n+            .filter(pk__in={i.pk for i in instances})",
      "comment": "Whoops, that's irrelevant now that we got `in_bulk` working :-), resolving",
      "comment_id": 2429953607,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-14T17:32:40Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2429953607"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,17 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = self.field.model._base_manager.values_list(attname).in_bulk(\n+            {i.pk for i in instances}\n+        )",
      "comment": "Earlier you removed a no-argument call to `db_manager()`, but now I wonder if we need to provide a db alias here.\r\n\r\nWith only an `\"other\"` connection, I see this works: the deferred field is fetched from `\"other\"`:\r\n```py\r\nIn [18]: qs = ResourceInstance.objects.defer('principaluser').using('other')\r\n\r\nIn [19]: for el in qs:\r\n    ...:     print(el.principaluser)\r\n    ...: \r\nadmin\r\n```\r\nversus this failure showing we tried to go to the default alias:\r\n```py\r\nIn [20]: qs = ResourceInstance.objects.defer('principaluser').using('other').fetch_mode(models.FETCH_PEERS)\r\n\r\nIn [21]: for el in qs:\r\n    ...:     print(el.principaluser)\r\n\r\nFile ~/django/django/db/models/query_utils.py:290, in DeferredAttribute.fetch_many(self, instances)\r\n    288 def fetch_many(self, instances):\r\n    289     attname = self.field.attname\r\n--> 290     value_by_pk = self.field.model._base_manager.values_list(attname).in_bulk(\r\n    291         {i.pk for i in instances}\r\n    292     )\r\n    293     for instance in instances:\r\n    294         setattr(instance, attname, value_by_pk[instance.pk])\r\n...\r\nFile ~/django/django/db/backends/dummy/base.py:21, in complain(*args, **kwargs)\r\n     20 def complain(*args, **kwargs):\r\n---> 21     raise ImproperlyConfigured(\r\n     22         \"settings.DATABASES is improperly configured. \"\r\n     23         \"Please supply the ENGINE value. Check \"\r\n     24         \"settings documentation for more details.\"\r\n     25     )\r\n\r\nImproperlyConfigured: settings.DATABASES is improperly configured. Please supply the ENGINE value. Check settings documentation for more details.\r\n```\r\n\r\nHow would the user provide an alias here?",
      "comment_id": 2430149841,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-14T19:01:12Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2430149841"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,17 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = self.field.model._base_manager.values_list(attname).in_bulk(\n+            {i.pk for i in instances}\n+        )",
      "comment": "@jacobtylerwalls we can safely assume that all instances are originating from the same database (otherwise they wouldn't be queryset peers) so doing\r\n\r\n```python\r\ndb = instances[0]._state.db\r\nvalue_by_pk = self.field.model._base_manager.using(db).values_list(attname).in_bulk(\r\n    {i.pk for i in instances}\r\n)\r\n```\r\n\r\nshould do here",
      "comment_id": 2430326751,
      "user": "charettes",
      "created_at": "2025-10-14T20:12:53Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2430326751"
    },
    {
      "repo": "django/django",
      "pr_number": 17554,
      "file_path": "django/db/models/query_utils.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,6 +282,17 @@ def _check_parent_chain(self, instance):\n             return getattr(instance, link_field.attname)\n         return None\n \n+    def fetch_one(self, instance):\n+        instance.refresh_from_db(fields=[self.field.attname])\n+\n+    def fetch_many(self, instances):\n+        attname = self.field.attname\n+        value_by_pk = self.field.model._base_manager.values_list(attname).in_bulk(\n+            {i.pk for i in instances}\n+        )",
      "comment": "Yeah, that looks good. @jacobtylerwalls since you set \"ready to merge\", will you take care of this edit?",
      "comment_id": 2430476759,
      "user": "adamchainz",
      "created_at": "2025-10-14T21:12:10Z",
      "url": "https://github.com/django/django/pull/17554#discussion_r2430476759"
    },
    {
      "repo": "django/django",
      "pr_number": 19943,
      "file_path": "django/utils/text.py",
      "line": 406,
      "side": "RIGHT",
      "diff_hunk": "@@ -393,6 +393,22 @@ def compress_sequence(sequence, *, max_random_bytes=None):\n     yield buf.read()\n \n \n+async def acompress_sequence(sequence, *, max_random_bytes=None):\n+    buf = StreamingBuffer()\n+    filename = _get_random_filename(max_random_bytes) if max_random_bytes else None\n+    with GzipFile(\n+        filename=filename, mode=\"wb\", compresslevel=6, fileobj=buf, mtime=0\n+    ) as zfile:\n+        # Output headers...\n+        yield buf.read()\n+        async for item in sequence:\n+            zfile.write(item)\n+            data = buf.read()",
      "comment": "Is this blocked on ticket-36293? Without flushing here, your sample app from the ticket blocks. Or does this have independent value?",
      "comment_id": 2440793566,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-17T18:12:50Z",
      "url": "https://github.com/django/django/pull/19943#discussion_r2440793566"
    },
    {
      "repo": "django/django",
      "pr_number": 19943,
      "file_path": "django/utils/text.py",
      "line": 406,
      "side": "RIGHT",
      "diff_hunk": "@@ -393,6 +393,22 @@ def compress_sequence(sequence, *, max_random_bytes=None):\n     yield buf.read()\n \n \n+async def acompress_sequence(sequence, *, max_random_bytes=None):\n+    buf = StreamingBuffer()\n+    filename = _get_random_filename(max_random_bytes) if max_random_bytes else None\n+    with GzipFile(\n+        filename=filename, mode=\"wb\", compresslevel=6, fileobj=buf, mtime=0\n+    ) as zfile:\n+        # Output headers...\n+        yield buf.read()\n+        async for item in sequence:\n+            zfile.write(item)\n+            data = buf.read()",
      "comment": "This change has independent value because it fixes response correctness, even if they are buffered.",
      "comment_id": 2442432141,
      "user": "adamchainz",
      "created_at": "2025-10-18T13:52:05Z",
      "url": "https://github.com/django/django/pull/19943#discussion_r2442432141"
    },
    {
      "repo": "django/django",
      "pr_number": 20087,
      "file_path": "django/db/models/constraints.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,9 +51,9 @@ def remove_sql(self, model, schema_editor):\n     def _expression_refs_exclude(cls, model, expression, exclude):\n         get_field = model._meta.get_field\n         for field_name, *__ in model._get_expr_references(expression):\n-            if field_name in exclude:\n-                return True\n             field = get_field(field_name)\n+            if field.name in exclude:\n+                return True",
      "comment": "We need to handle `pk` separately (ticket-27944):\r\n```python\r\nif field_name == \"pk\":\r\n    field = model._meta.pk\r\nelse:\r\n    field = get_field(field_name)\r\nif field.name in exclude:\r\n    return True\r\n```",
      "comment_id": 2519928779,
      "user": "felixxm",
      "created_at": "2025-11-12T21:52:37Z",
      "url": "https://github.com/django/django/pull/20087#discussion_r2519928779"
    },
    {
      "repo": "django/django",
      "pr_number": 20087,
      "file_path": "tests/model_forms/models.py",
      "line": 557,
      "side": "RIGHT",
      "diff_hunk": "@@ -543,3 +543,22 @@ class Meta:\n                 violation_error_message=\"Price must be greater than zero.\",\n             ),\n         ]\n+\n+\n+class AttnameConstraintsModel(models.Model):\n+    left = models.ForeignKey(\n+        \"self\", related_name=\"+\", null=True, on_delete=models.SET_NULL\n+    )\n+    right = models.ForeignKey(\n+        \"self\", related_name=\"+\", null=True, on_delete=models.SET_NULL\n+    )\n+\n+    class Meta:\n+        required_db_features = {\"supports_table_check_constraints\"}",
      "comment": "EDIT ~The same flag should be checked in `test_check_constraint_refs_excluded_field_attname`.~ Nvd",
      "comment_id": 2522180621,
      "user": "felixxm",
      "created_at": "2025-11-13T08:08:19Z",
      "url": "https://github.com/django/django/pull/20087#discussion_r2522180621"
    },
    {
      "repo": "django/django",
      "pr_number": 19912,
      "file_path": "django/contrib/postgres/fields/array.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,7 +67,7 @@ def check(self, **kwargs):\n                 )\n             )\n         else:\n-            base_checks = self.base_field.check()\n+            base_checks = self.base_field.check(**kwargs)",
      "comment": "This is not strictly necessary here but it ensures `databases` is respected when specified.",
      "comment_id": 2389370509,
      "user": "charettes",
      "created_at": "2025-09-29T22:03:32Z",
      "url": "https://github.com/django/django/pull/19912#discussion_r2389370509"
    },
    {
      "repo": "django/django",
      "pr_number": 20059,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 179,
      "side": "RIGHT",
      "diff_hunk": "@@ -192,11 +167,18 @@ def run_manage(\n         with open(test_manage_py, \"w\") as fp:\n             fp.write(manage_py_contents)\n \n-        return self.run_test(\n-            [\"./manage.py\", *args],\n-            settings_file,\n-            discover_formatters=discover_formatters,\n-        )\n+        return self.run_test([\"./manage.py\", *args], settings_file)\n+\n+    def assertInAfterFormatting(self, member, container, msg=None):\n+        if HAS_BLACK:\n+            import black\n+\n+            # Black does not have a stable API, but this is still less\n+            # fragile than attempting to filter out containing paths.\n+            member = black.format_str(member, mode=black.FileMode())\n+            container = black.format_str(container, mode=black.FileMode())",
      "comment": "Yep, missed a handful here. Most of the assertIn's are actually asserting against streams, not templated files, so black isn't relevant there.\n\nRe:\n> Moreover, I would rename this helper to assertInOutput \n\nI hear that, but the tricky part is we have an `assertOutput` already for streams. How's `assertInTemplatedFile`?",
      "comment_id": 2492115136,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-04T21:37:42Z",
      "url": "https://github.com/django/django/pull/20059#discussion_r2492115136"
    },
    {
      "repo": "django/django",
      "pr_number": 20059,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 179,
      "side": "RIGHT",
      "diff_hunk": "@@ -192,11 +167,18 @@ def run_manage(\n         with open(test_manage_py, \"w\") as fp:\n             fp.write(manage_py_contents)\n \n-        return self.run_test(\n-            [\"./manage.py\", *args],\n-            settings_file,\n-            discover_formatters=discover_formatters,\n-        )\n+        return self.run_test([\"./manage.py\", *args], settings_file)\n+\n+    def assertInAfterFormatting(self, member, container, msg=None):\n+        if HAS_BLACK:\n+            import black\n+\n+            # Black does not have a stable API, but this is still less\n+            # fragile than attempting to filter out containing paths.\n+            member = black.format_str(member, mode=black.FileMode())\n+            container = black.format_str(container, mode=black.FileMode())",
      "comment": "We can't use it blindly, since the blind approach gives on an input of `<&>`:\n```py\nblack.parsing.InvalidInput: Cannot parse: 1:0: <&>\n```",
      "comment_id": 2492116915,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-04T21:38:31Z",
      "url": "https://github.com/django/django/pull/20059#discussion_r2492116915"
    },
    {
      "repo": "django/django",
      "pr_number": 20059,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 179,
      "side": "RIGHT",
      "diff_hunk": "@@ -192,11 +167,18 @@ def run_manage(\n         with open(test_manage_py, \"w\") as fp:\n             fp.write(manage_py_contents)\n \n-        return self.run_test(\n-            [\"./manage.py\", *args],\n-            settings_file,\n-            discover_formatters=discover_formatters,\n-        )\n+        return self.run_test([\"./manage.py\", *args], settings_file)\n+\n+    def assertInAfterFormatting(self, member, container, msg=None):\n+        if HAS_BLACK:\n+            import black\n+\n+            # Black does not have a stable API, but this is still less\n+            # fragile than attempting to filter out containing paths.\n+            member = black.format_str(member, mode=black.FileMode())\n+            container = black.format_str(container, mode=black.FileMode())",
      "comment": "Given that, I kind of like `assertInAfterFormatting` or similar after all so that you don't end up with:\n```py\n            self.assertIn(\"class NewAppConfig(AppConfig)\", content)\n            self.assertInTemplatedFile(\"name = 'new_app'\", content)\n```",
      "comment_id": 2492128225,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-04T21:44:05Z",
      "url": "https://github.com/django/django/pull/20059#discussion_r2492128225"
    },
    {
      "repo": "django/django",
      "pr_number": 20059,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,6 +47,8 @@\n \n SYSTEM_CHECK_MSG = \"System check identified no issues\"\n \n+HAS_BLACK = shutil.which(\"black\")",
      "comment": "[Black is in the requirements.txt](https://github.com/django/django/blob/74564946c3b42a2ef7d087047e49873847a7e1d9/tests/requirements/py3.txt#L5) that the test instructions and CI jobs install. Unless you're explicitly wanting to support running tests in other contexts, I think the tests could assume black is installed and perhaps explicitly test the case where it doesn't by mocking `find_formatters()` to return `None`?\r\n\r\n(Just passing by after you mentioned this in my MR \u2014 I think your approach here to avoid changing the PATH is sensible!)",
      "comment_id": 2493634457,
      "user": "h4l",
      "created_at": "2025-11-05T09:18:58Z",
      "url": "https://github.com/django/django/pull/20059#discussion_r2493634457"
    },
    {
      "repo": "django/django",
      "pr_number": 20059,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,6 +47,8 @@\n \n SYSTEM_CHECK_MSG = \"System check identified no issues\"\n \n+HAS_BLACK = shutil.which(\"black\")",
      "comment": "Thank you @h4l for taking another look. Django explicitly support development environments (and Django general usage) without having `black` available, so we can't just assume `black` is installed.\n\nFor example, in our Jenkins CI we define one job that runs the tests without any external dependency (https://djangoci.com/job/main-no-requirements/).",
      "comment_id": 2510985184,
      "user": "nessita",
      "created_at": "2025-11-10T15:21:21Z",
      "url": "https://github.com/django/django/pull/20059#discussion_r2510985184"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,65 +170,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):\n                     pass",
      "comment": "Wouldn't simply cancelling the background task achieve the same result, without triggering the exception handling mechanism. It would also make this code more readable, since it seems like the exception is being raised only to cancel the task.\r\n\r\n```python\r\n                    async with asyncio.TaskGroup() as tg:\r\n                        disconnect_task = tg.create_task(self.listen_for_disconnect(receive))\r\n                        response = await self.run_get_response(request)\r\n                        await self.send_response(response, send)\r\n                        disconnect_task.cancel()\r\n                except* RequestAborted:\r\n                    pass\r\n```",
      "comment_id": 2089932163,
      "user": "hartungstenio",
      "created_at": "2025-05-15T00:14:28Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2089932163"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,65 +170,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):\n                     pass",
      "comment": "This is the recommended way to terminate a TaskGroup https://docs.python.org/3/library/asyncio-task.html#terminating-a-task-group",
      "comment_id": 2090087654,
      "user": "graingert",
      "created_at": "2025-05-15T02:30:44Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2090087654"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,65 +170,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):\n                     pass",
      "comment": "The recommendation is to create an \"exception-raising task\".\r\n\r\nBut in this case, semantically, we don't want to end the TaskGroup (like, there are many tasks running, and want to finish them all), we want to stop listening for disconnections (which happens to be the only running task).",
      "comment_id": 2091086606,
      "user": "hartungstenio",
      "created_at": "2025-05-15T12:43:02Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2091086606"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()",
      "comment": "I want the body to close before waiting for send_response in this case ",
      "comment_id": 2504649015,
      "user": "graingert",
      "created_at": "2025-11-07T17:11:48Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2504649015"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "This CancelledError should be propagated because it comes from a manual cancel call unrelated to the TaskGroup. Generally you should not catch CancelledError and replace it unless you caused the cancellation ",
      "comment_id": 2505398546,
      "user": "graingert",
      "created_at": "2025-11-07T20:34:56Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2505398546"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "First of all, thank you for your MR. It will definitely help me in the future \ud83d\ude0c\r\n\r\nYou\u2019re right about the propagation. So, the better approach is probably to wrap everything in a `try/finally` block:\r\n\r\n```python \r\ntry:\r\n    ...\r\nfinally:\r\n    if response is None:\r\n        await signals.request_finished.asend(sender=self.__class__)\r\n    else:\r\n        await sync_to_async(response.close)()\r\n```\r\n\r\nThe `request_finished` signal is used for connection cleanup, and if I don\u2019t release the connection back to the pool, it could cause issues later.\r\n\r\nwhat do u think?",
      "comment_id": 2505601632,
      "user": "Arfey",
      "created_at": "2025-11-07T21:27:02Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2505601632"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "Oh I see yes this PR needs reverting and this try/finally applying",
      "comment_id": 2506875448,
      "user": "graingert",
      "created_at": "2025-11-08T12:00:36Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2506875448"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "Hmmm maybe not, I don't think external cancellation should fire the request_finished hook, @carltongibson thoughts?",
      "comment_id": 2506882555,
      "user": "graingert",
      "created_at": "2025-11-08T12:19:48Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2506882555"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "Yes, so we do want to fire request finished here. The client disconnected rather than completing the request, but we still need to clean up. \n\nI need to look at the tests here. The request finished signal not firing should trigger a failure. \ud83e\udd14 ",
      "comment_id": 2506906529,
      "user": "carltongibson",
      "created_at": "2025-11-08T13:00:19Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2506906529"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "I don't think we should revert the current MR (it doesn't break the existing codebase), but we need to find a proper approach for handling the cleanup. We can move this discussion elsewhere.",
      "comment_id": 2506952926,
      "user": "Arfey",
      "created_at": "2025-11-08T14:25:45Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2506952926"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "OK, so the signals.request_finished.asend is **still hit** on the tests checking cancellation. \r\n\r\ne.g. see `asgi.tests.ASGITest.test_asyncio_cancel_error`.\r\n\r\n@Arfey If you could add a test case demonstrating a change in behaviour then we can certainly tweak. ",
      "comment_id": 2506966218,
      "user": "carltongibson",
      "created_at": "2025-11-08T14:58:47Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2506966218"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "Thanks.\r\n\r\nThe `asgi.tests.ASGITest.test_asyncio_cancel_error` covers two cases:\r\n- The request cycle completes normally when no disconnect is sent.\r\n- The request cycle is interrupted when a disconnect occurs before the view responds.\r\n\r\nSo, it tests cancellation caused by a disconnection event. However, we discovered a potential cleanup issue if something higher up cancels `handle_request`.\r\n\r\n>  demonstrating a change in behaviour then we can certainly tweak.\r\n\r\nThe behaviour remains the same. We already had the same potential issue in the previous version of the code.\r\n\r\n> If you could add a test case\r\n\r\nSure",
      "comment_id": 2507328215,
      "user": "Arfey",
      "created_at": "2025-11-08T22:32:50Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2507328215"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "https://github.com/Arfey/django/pull/2/files\r\n\r\nIt's not a problem for now, since we don't use async database connections. The threaded version doesn't have this issue, as it handles connection closing both before and after each request. But for pure async connections, it could become an issue.",
      "comment_id": 2507350483,
      "user": "Arfey",
      "created_at": "2025-11-08T23:12:18Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2507350483"
    },
    {
      "repo": "django/django",
      "pr_number": 19366,
      "file_path": "django/core/handlers/asgi.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,65 +174,41 @@ async def handle(self, scope, receive, send):\n             body_file = await self.read_body(receive)\n         except RequestAborted:\n             return\n-        # Request is complete and can be served.\n-        set_script_prefix(get_script_prefix(scope))\n-        await signals.request_started.asend(sender=self.__class__, scope=scope)\n-        # Get the request and check for basic issues.\n-        request, error_response = self.create_request(scope, body_file)\n-        if request is None:\n-            body_file.close()\n-            await self.send_response(error_response, send)\n-            await sync_to_async(error_response.close)()\n-            return\n \n-        async def process_request(request, send):\n-            response = await self.run_get_response(request)\n-            try:\n-                await self.send_response(response, send)\n-            except asyncio.CancelledError:\n-                # Client disconnected during send_response (ignore exception).\n+        with closing(body_file):\n+            # Request is complete and can be served.\n+            set_script_prefix(get_script_prefix(scope))\n+            await signals.request_started.asend(sender=self.__class__, scope=scope)\n+            # Get the request and check for basic issues.\n+            request, error_response = self.create_request(scope, body_file)\n+            if request is None:\n+                body_file.close()\n+                await self.send_response(error_response, send)\n+                await sync_to_async(error_response.close)()\n+                return\n+\n+            class RequestProcessed(Exception):\n                 pass\n \n-            return response\n-\n-        # Try to catch a disconnect while getting response.\n-        tasks = [\n-            # Check the status of these tasks and (optionally) terminate them\n-            # in this order. The listen_for_disconnect() task goes first\n-            # because it should not raise unexpected errors that would prevent\n-            # us from cancelling process_request().\n-            asyncio.create_task(self.listen_for_disconnect(receive)),\n-            asyncio.create_task(process_request(request, send)),\n-        ]\n-        await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n-        # Now wait on both tasks (they may have both finished by now).\n-        for task in tasks:\n-            if task.done():\n-                try:\n-                    task.result()\n-                except RequestAborted:\n-                    # Ignore client disconnects.\n-                    pass\n-                except AssertionError:\n-                    body_file.close()\n-                    raise\n-            else:\n-                # Allow views to handle cancellation.\n-                task.cancel()\n+            response = None\n+            try:\n                 try:\n-                    await task\n-                except asyncio.CancelledError:\n-                    # Task re-raised the CancelledError as expected.\n+                    async with asyncio.TaskGroup() as tg:\n+                        tg.create_task(self.listen_for_disconnect(receive))\n+                        response = await self.run_get_response(request)\n+                        await self.send_response(response, send)\n+                        raise RequestProcessed\n+                except* (RequestProcessed, RequestAborted):",
      "comment": "Great. I'll look at that. Thanks. \n\nNot sure how such a case would come up currently. We can likely discuss elsewhere as you say. ",
      "comment_id": 2507617647,
      "user": "carltongibson",
      "created_at": "2025-11-09T05:41:05Z",
      "url": "https://github.com/django/django/pull/19366#discussion_r2507617647"
    },
    {
      "repo": "django/django",
      "pr_number": 19517,
      "file_path": "django/db/backends/sqlite3/operations.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,16 +156,15 @@ def _quote_params_for_last_executed_query(self, params):\n         \"\"\"\n         Only for last_executed_query! Don't use this to execute SQL queries!\n         \"\"\"\n-        # This function is limited both by SQLITE_LIMIT_VARIABLE_NUMBER (the\n-        # number of parameters, default = 999) and SQLITE_MAX_COLUMN (the\n-        # number of return values, default = 2000). Since Python's sqlite3\n-        # module doesn't expose the get_limit() C API, assume the default\n-        # limits are in effect and split the work in batches if needed.\n-        BATCH_SIZE = 999\n-        if len(params) > BATCH_SIZE:\n+        connection = self.connection.connection\n+        variable_limit = connection.getlimit(sqlite3.SQLITE_LIMIT_VARIABLE_NUMBER)",
      "comment": "This is now available as `self.connection.features.max_query_params` as of #19427.\r\n\r\nhttps://github.com/django/django/blob/26313bc21932d0d3af278ab387549d63b1f64575/django/db/backends/sqlite3/features.py#L144-L152\r\n\r\n```suggestion\r\n        variable_limit = self.connection.features.max_query_params\r\n```",
      "comment_id": 2124371771,
      "user": "laymonage",
      "created_at": "2025-06-03T16:24:54Z",
      "url": "https://github.com/django/django/pull/19517#discussion_r2124371771"
    },
    {
      "repo": "django/django",
      "pr_number": 19517,
      "file_path": "django/db/backends/sqlite3/operations.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,16 +156,15 @@ def _quote_params_for_last_executed_query(self, params):\n         \"\"\"\n         Only for last_executed_query! Don't use this to execute SQL queries!\n         \"\"\"\n-        # This function is limited both by SQLITE_LIMIT_VARIABLE_NUMBER (the\n-        # number of parameters, default = 999) and SQLITE_MAX_COLUMN (the\n-        # number of return values, default = 2000). Since Python's sqlite3\n-        # module doesn't expose the get_limit() C API, assume the default\n-        # limits are in effect and split the work in batches if needed.\n-        BATCH_SIZE = 999\n-        if len(params) > BATCH_SIZE:\n+        connection = self.connection.connection\n+        variable_limit = connection.getlimit(sqlite3.SQLITE_LIMIT_VARIABLE_NUMBER)",
      "comment": "Thanks for pointing this out! I considered updating column_limit to use the same pattern (self.connection.features.max_columns), but decided to keep this PR focused on the immediate fix. ",
      "comment_id": 2128935590,
      "user": "myoungjinGo-BE",
      "created_at": "2025-06-05T14:00:41Z",
      "url": "https://github.com/django/django/pull/19517#discussion_r2128935590"
    },
    {
      "repo": "django/django",
      "pr_number": 20041,
      "file_path": "tests/bulk_create/tests.py",
      "line": 894,
      "side": "RIGHT",
      "diff_hunk": "@@ -884,6 +884,13 @@ def test_db_default_primary_key(self):\n         (obj,) = DbDefaultPrimaryKey.objects.bulk_create([DbDefaultPrimaryKey()])\n         self.assertIsInstance(obj.id, datetime)\n \n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_db_expression_primary_key(self):\n+        (obj,) = DbDefaultPrimaryKey.objects.bulk_create(\n+            [DbDefaultPrimaryKey(id=Now())]\n+        )\n+        self.assertIsInstance(obj.id, datetime)",
      "comment": "Use `State` instead as the `DbDefaultPrimaryKey` model will only be created on backends that `supports_expression_defaults`.\r\n\r\n```suggestion\r\n    def test_db_expression_primary_key(self):\r\n        (obj,) = State.objects.bulk_create(\r\n            [State(two_letter_code=Value(\"CA\"))]\r\n        )\r\n        self.assertIsInstance(obj.two_letter_code, str)\r\n```",
      "comment_id": 2486575052,
      "user": "charettes",
      "created_at": "2025-11-03T13:55:46Z",
      "url": "https://github.com/django/django/pull/20041#discussion_r2486575052"
    },
    {
      "repo": "django/django",
      "pr_number": 20041,
      "file_path": "tests/bulk_create/tests.py",
      "line": 894,
      "side": "RIGHT",
      "diff_hunk": "@@ -884,6 +884,13 @@ def test_db_default_primary_key(self):\n         (obj,) = DbDefaultPrimaryKey.objects.bulk_create([DbDefaultPrimaryKey()])\n         self.assertIsInstance(obj.id, datetime)\n \n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_db_expression_primary_key(self):\n+        (obj,) = DbDefaultPrimaryKey.objects.bulk_create(\n+            [DbDefaultPrimaryKey(id=Now())]\n+        )\n+        self.assertIsInstance(obj.id, datetime)",
      "comment": "With your suggested test my fix doesn't work, because `two_letter_code` is not in `State._meta.db_returning_fields` because it doesn't have a `db_default`.",
      "comment_id": 2486612576,
      "user": "us77ipis",
      "created_at": "2025-11-03T14:08:08Z",
      "url": "https://github.com/django/django/pull/20041#discussion_r2486612576"
    },
    {
      "repo": "django/django",
      "pr_number": 20041,
      "file_path": "tests/bulk_create/tests.py",
      "line": 894,
      "side": "RIGHT",
      "diff_hunk": "@@ -884,6 +884,13 @@ def test_db_default_primary_key(self):\n         (obj,) = DbDefaultPrimaryKey.objects.bulk_create([DbDefaultPrimaryKey()])\n         self.assertIsInstance(obj.id, datetime)\n \n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_db_expression_primary_key(self):\n+        (obj,) = DbDefaultPrimaryKey.objects.bulk_create(\n+            [DbDefaultPrimaryKey(id=Now())]\n+        )\n+        self.assertIsInstance(obj.id, datetime)",
      "comment": "I see, so the follow up will address this case as well.\r\n\r\nMake sure to include `\"supports_expression_defaults\"` in the `skipUnlessDBFeature` instead then.",
      "comment_id": 2486620653,
      "user": "charettes",
      "created_at": "2025-11-03T14:10:48Z",
      "url": "https://github.com/django/django/pull/20041#discussion_r2486620653"
    },
    {
      "repo": "django/django",
      "pr_number": 20041,
      "file_path": "tests/bulk_create/tests.py",
      "line": 894,
      "side": "RIGHT",
      "diff_hunk": "@@ -884,6 +884,13 @@ def test_db_default_primary_key(self):\n         (obj,) = DbDefaultPrimaryKey.objects.bulk_create([DbDefaultPrimaryKey()])\n         self.assertIsInstance(obj.id, datetime)\n \n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_db_expression_primary_key(self):\n+        (obj,) = DbDefaultPrimaryKey.objects.bulk_create(\n+            [DbDefaultPrimaryKey(id=Now())]\n+        )\n+        self.assertIsInstance(obj.id, datetime)",
      "comment": "Fixing the issue for the more general case would require to allow entirely overriding or at least specifying additional returning fields through an additional parameter of `bulk_create`. This way also expressions specified for other non-primary key fields could easily be returned.",
      "comment_id": 2486684981,
      "user": "us77ipis",
      "created_at": "2025-11-03T14:29:56Z",
      "url": "https://github.com/django/django/pull/20041#discussion_r2486684981"
    },
    {
      "repo": "django/django",
      "pr_number": 20041,
      "file_path": "tests/bulk_create/tests.py",
      "line": 894,
      "side": "RIGHT",
      "diff_hunk": "@@ -884,6 +884,13 @@ def test_db_default_primary_key(self):\n         (obj,) = DbDefaultPrimaryKey.objects.bulk_create([DbDefaultPrimaryKey()])\n         self.assertIsInstance(obj.id, datetime)\n \n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_db_expression_primary_key(self):\n+        (obj,) = DbDefaultPrimaryKey.objects.bulk_create(\n+            [DbDefaultPrimaryKey(id=Now())]\n+        )\n+        self.assertIsInstance(obj.id, datetime)",
      "comment": "> This way also expressions specified for other non-primary key fields could easily be returned.\r\n\r\nI think there might be a way to efficiently flag all fields that have resolvable/compilable values assigned to them and automatically augment `returning_fields` with them so it can be done implicitly.\r\n\r\nThat's [the approach we've recently taken with `Model.save` for example](https://github.com/django/django/commit/94680437a45a71c70ca8bd2e68b72aa1e2eff337#diff-1c8b882c73bfda668d5451d4578c97191b0ebc0f088d0c0ba2296ab89b428c44R1105-R1158).",
      "comment_id": 2486867339,
      "user": "charettes",
      "created_at": "2025-11-03T15:23:17Z",
      "url": "https://github.com/django/django/pull/20041#discussion_r2486867339"
    },
    {
      "repo": "django/django",
      "pr_number": 20041,
      "file_path": "tests/bulk_create/tests.py",
      "line": 894,
      "side": "RIGHT",
      "diff_hunk": "@@ -884,6 +884,13 @@ def test_db_default_primary_key(self):\n         (obj,) = DbDefaultPrimaryKey.objects.bulk_create([DbDefaultPrimaryKey()])\n         self.assertIsInstance(obj.id, datetime)\n \n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_db_expression_primary_key(self):\n+        (obj,) = DbDefaultPrimaryKey.objects.bulk_create(\n+            [DbDefaultPrimaryKey(id=Now())]\n+        )\n+        self.assertIsInstance(obj.id, datetime)",
      "comment": "That would be smart. Still a worst case scenario could be a `bulk_create` call with many objects on a model that has many fields, most of them specified as expressions, none of which are actually needed afterwards. It would be both unnecessary to look at all field values for all objects to check if they are expressions, and also to fetch all values again from the db. For such a case it would still be nice to override the returning fields manually to regain the little extra performance.",
      "comment_id": 2487007143,
      "user": "us77ipis",
      "created_at": "2025-11-03T16:00:23Z",
      "url": "https://github.com/django/django/pull/20041#discussion_r2487007143"
    },
    {
      "repo": "django/django",
      "pr_number": 20041,
      "file_path": "tests/bulk_create/tests.py",
      "line": 894,
      "side": "RIGHT",
      "diff_hunk": "@@ -884,6 +884,13 @@ def test_db_default_primary_key(self):\n         (obj,) = DbDefaultPrimaryKey.objects.bulk_create([DbDefaultPrimaryKey()])\n         self.assertIsInstance(obj.id, datetime)\n \n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_db_expression_primary_key(self):\n+        (obj,) = DbDefaultPrimaryKey.objects.bulk_create(\n+            [DbDefaultPrimaryKey(id=Now())]\n+        )\n+        self.assertIsInstance(obj.id, datetime)",
      "comment": "> It would be both unnecessary to look at all field values for all objects to check if they are expressions\r\n\r\nThe thing is we already have to do that in order to call `resolve_expression` and `as_sql` on them and generate the proper SQL. See how `SQLInsertCompiler` does it.\r\n\r\n> also to fetch all values again from the db. For such a case it would still be nice to override the returning fields manually to regain the little extra performance.\r\n\r\nI do agree that granular control over `returning_fields` is desirable as even without implicitly `RETURNING` any field that makes use of expressions, as suggested above, the overfetching problem is already present for `db_returning` fields such as the ones that define `db_default` or are `GeneratedField`. You might not necessarily want fetch back db generated value on each `bulk_create` and in some cases the `pk` might not even be of interest.\r\n\r\nI think we agree that in an ideal state `returning_fields` could be overridable and it would default to `db_returning` fields + fields that had at least one instance with a provided expression.",
      "comment_id": 2487379150,
      "user": "charettes",
      "created_at": "2025-11-03T17:53:52Z",
      "url": "https://github.com/django/django/pull/20041#discussion_r2487379150"
    },
    {
      "repo": "django/django",
      "pr_number": 20060,
      "file_path": "tests/utils_tests/test_html.py",
      "line": 469,
      "side": "RIGHT",
      "diff_hunk": "@@ -455,6 +455,18 @@ def test_urlize(self):\n                 '<a href=\"mailto:idna-2008@%DE%89%DE%A8%DE%80%DE%A7%DE%83%DE%AA.ex'\n                 'ample.mv\">idna-2008@\u0789\u07a8\u0780\u07a7\u0783\u07aa.example.mv</a>',\n             ),\n+            (\n+                \"as.d8f.ghj8.gov\",\n+                '<a href=\"https://as.d8f.ghj8.gov\">as.d8f.ghj8.gov</a>',\n+            ),\n+            (\n+                \"a.b2c.com\",\n+                '<a href=\"https://a.b2c.com\">a.b2c.com</a>',\n+            ),\n+            (\n+                \"www.sub1.d2f.gov\",\n+                '<a href=\"https://www.sub1.d2f.gov\">www.sub1.d2f.gov</a>',\n+            ),",
      "comment": "I think we can just use one test here. Something like `host.djangoproject.com`.",
      "comment_id": 2495851342,
      "user": "jacobtylerwalls",
      "created_at": "2025-11-05T19:30:46Z",
      "url": "https://github.com/django/django/pull/20060#discussion_r2495851342"
    },
    {
      "repo": "django/django",
      "pr_number": 19614,
      "file_path": "django/db/models/query.py",
      "line": 803,
      "side": "RIGHT",
      "diff_hunk": "@@ -800,7 +801,11 @@ def bulk_create(\n         fields = [f for f in opts.concrete_fields if not f.generated]\n         objs = list(objs)\n         objs_with_pk, objs_without_pk = self._prepare_for_bulk_create(objs)",
      "comment": "It appears that this whole primary key assignment partition logic can also be elided if [we'd like to go further](https://github.com/django/django/compare/main...charettes:django:ticket-36490-simplify-bulk_create#diff-d58ef61559dc7af5fdf7b56fee13571a4d2948e784cd608f6afeacf3ac2fb195R793-R808)",
      "comment_id": 2180637311,
      "user": "charettes",
      "created_at": "2025-07-02T17:45:13Z",
      "url": "https://github.com/django/django/pull/19614#discussion_r2180637311"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/mysql/introspection.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +54,14 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         FIELD_TYPE.VAR_STRING: \"CharField\",\n     }\n \n+    @cached_property\n+    def on_delete_types(self):\n+        on_delete_types = super().on_delete_types\n+        if self.connection.mysql_is_mariadb:\n+            # On MariaDB \"NO ACTION\" and \"RESTRICT\" are synonyms.\n+            on_delete_types[\"RESTRICT\"] = DO_NOTHING",
      "comment": "https://mariadb.com/docs/server/ha-and-performance/optimization-and-tuning/optimization-and-indexes/foreign-keys#constraints",
      "comment_id": 2452129490,
      "user": "felixxm",
      "created_at": "2025-10-22T13:35:35Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2452129490"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/mysql/introspection.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +54,14 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         FIELD_TYPE.VAR_STRING: \"CharField\",\n     }\n \n+    @cached_property\n+    def on_delete_types(self):\n+        on_delete_types = super().on_delete_types\n+        if self.connection.mysql_is_mariadb:\n+            # On MariaDB \"NO ACTION\" and \"RESTRICT\" are synonyms.\n+            on_delete_types[\"RESTRICT\"] = DO_NOTHING",
      "comment": "I suspect it's the same on MySQL as neither support deferrable foreign key constraints which means that both `RETRICT` and `DO_NOTHING` are equivalent.\r\n\r\nNot sure we should translate it to `DO_NOTHING` though as when we do add support do `DB_RESTRICT` the value will be swapped back to `DO_NOTHING` on introspection.\r\n\r\nMaybe this is something we can revisit when we do add support for `DB_RESTRICT`.",
      "comment_id": 2452151882,
      "user": "charettes",
      "created_at": "2025-10-22T13:42:34Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2452151882"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/mysql/introspection.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +54,14 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         FIELD_TYPE.VAR_STRING: \"CharField\",\n     }\n \n+    @cached_property\n+    def on_delete_types(self):\n+        on_delete_types = super().on_delete_types\n+        if self.connection.mysql_is_mariadb:\n+            # On MariaDB \"NO ACTION\" and \"RESTRICT\" are synonyms.\n+            on_delete_types[\"RESTRICT\"] = DO_NOTHING",
      "comment": "> I suspect it's the same on MySQL as neither support deferrable foreign key constraints which means that both `RETRICT` and `DO_NOTHING` are equivalent.\r\n\r\nAt least on MySQL, `delete_rule` returns `NO ACTION` by default :)",
      "comment_id": 2452227636,
      "user": "felixxm",
      "created_at": "2025-10-22T14:05:56Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2452227636"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/mysql/introspection.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +54,14 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         FIELD_TYPE.VAR_STRING: \"CharField\",\n     }\n \n+    @cached_property\n+    def on_delete_types(self):\n+        on_delete_types = super().on_delete_types\n+        if self.connection.mysql_is_mariadb:\n+            # On MariaDB \"NO ACTION\" and \"RESTRICT\" are synonyms.\n+            on_delete_types[\"RESTRICT\"] = DO_NOTHING",
      "comment": "> Not sure we should translate it to `DO_NOTHING` though as when we do add support do `DB_RESTRICT` the value will be swapped back to `DO_NOTHING` on introspection.\r\n\r\nPreviously we translated all options to `DO_NOTHING`.",
      "comment_id": 2452234598,
      "user": "felixxm",
      "created_at": "2025-10-22T14:08:15Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2452234598"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/core/management/commands/inspectdb.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,6 +194,13 @@ def handle_inspection(self, options):\n                                 model_name.lower(),\n                                 att_name,\n                             )\n+                        if db_on_delete:\n+                            if isinstance(db_on_delete, DatabaseOnDelete):\n+                                extra_params[\"on_delete\"] = f\"models.{db_on_delete}\"\n+                            else:\n+                                extra_params[\"on_delete\"] = (\n+                                    f\"models.{db_on_delete.__qualname__}\"\n+                                )",
      "comment": "No tests fail when I alter this to assign an empty tuple, but maybe that's fine.",
      "comment_id": 2478017710,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-30T13:03:30Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2478017710"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/core/management/commands/inspectdb.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -227,8 +237,12 @@ def handle_inspection(self, options):\n                         \"\" if \".\" in field_type else \"models.\",\n                         field_type,\n                     )\n+                    on_delete_repr = extra_params.pop(\"on_delete\", None)",
      "comment": "```suggestion\n                    on_delete_qualname = extra_params.pop(\"on_delete\", None)\n```",
      "comment_id": 2478025450,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-30T13:05:47Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2478025450"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/mysql/introspection.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +54,14 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         FIELD_TYPE.VAR_STRING: \"CharField\",\n     }\n \n+    @cached_property\n+    def on_delete_types(self):\n+        on_delete_types = super().on_delete_types\n+        if self.connection.mysql_is_mariadb:\n+            # On MariaDB \"NO ACTION\" and \"RESTRICT\" are synonyms.\n+            on_delete_types[\"RESTRICT\"] = DO_NOTHING",
      "comment": "True, but if we have a choice between synonyms, why wouldn't we leave it as is and avoid swapping it out for `DO_NOTHING`? Maybe a project starts by introspecting a mariadb and plans to migrate to postgres later.\n\nIf we did that, couldn't we remove the property and just make this a class constant?",
      "comment_id": 2478099528,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-30T13:25:34Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2478099528"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/mysql/introspection.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +54,14 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         FIELD_TYPE.VAR_STRING: \"CharField\",\n     }\n \n+    @cached_property\n+    def on_delete_types(self):\n+        on_delete_types = super().on_delete_types\n+        if self.connection.mysql_is_mariadb:\n+            # On MariaDB \"NO ACTION\" and \"RESTRICT\" are synonyms.\n+            on_delete_types[\"RESTRICT\"] = DO_NOTHING",
      "comment": "> I suspect it's the same on MySQL as neither support deferrable foreign key constraints which means that both RETRICT and DO_NOTHING are equivalent.\r\n\r\nA subtle difference is [mentioned](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html#foreign-key-referential-actions) between InnoDB and NDB:\r\n\r\n> [NDB](https://dev.mysql.com/doc/refman/8.0/en/mysql-cluster.html) supports deferred checks, and NO ACTION specifies a deferred check;",
      "comment_id": 2478113664,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-30T13:29:44Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2478113664"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/base/introspection.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,8 +183,11 @@ def get_sequences(self, cursor, table_name, table_fields=()):\n \n     def get_relations(self, cursor, table_name):\n         \"\"\"\n-        Return a dictionary of {field_name: (field_name_other_table,\n-        other_table)} representing all foreign keys in the given table.\n+        Return a dictionary of\n+            {\n+                field_name: (field_name_other_table, other_table, db_on_delete)\n+            }\n+        representing all foreign keys in the given table.",
      "comment": "Do we need to mention this in the \"changes that may be needed in third-party database\nbackends\"?",
      "comment_id": 2478125018,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-30T13:33:10Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2478125018"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/mysql/introspection.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +54,14 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         FIELD_TYPE.VAR_STRING: \"CharField\",\n     }\n \n+    @cached_property\n+    def on_delete_types(self):\n+        on_delete_types = super().on_delete_types\n+        if self.connection.mysql_is_mariadb:\n+            # On MariaDB \"NO ACTION\" and \"RESTRICT\" are synonyms.\n+            on_delete_types[\"RESTRICT\"] = DO_NOTHING",
      "comment": "Thanks for that, TIL about NDB.\n\nI don't think we support the NDB storage engine though, at least we don't test against it and [we explicitly mark the MySQL backend as not supporting deferred constraint checks](https://github.com/search?q=repo%3Adjango%2Fdjango%20can_defer_constraint_checks&type=code).",
      "comment_id": 2478337721,
      "user": "charettes",
      "created_at": "2025-10-30T14:29:46Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2478337721"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/core/management/commands/inspectdb.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,6 +194,13 @@ def handle_inspection(self, options):\n                                 model_name.lower(),\n                                 att_name,\n                             )\n+                        if db_on_delete:\n+                            if isinstance(db_on_delete, DatabaseOnDelete):\n+                                extra_params[\"on_delete\"] = f\"models.{db_on_delete}\"\n+                            else:\n+                                extra_params[\"on_delete\"] = (\n+                                    f\"models.{db_on_delete.__qualname__}\"\n+                                )",
      "comment": "Right, currently it's unnecessary because the only `db_on_delete` that is not `DatabaseOnDelete` is actually `DO_NOTHING`.",
      "comment_id": 2480307147,
      "user": "felixxm",
      "created_at": "2025-10-31T06:43:55Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2480307147"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/base/introspection.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +24,18 @@ def __init__(self, connection):\n     def __del__(self):\n         del self.connection\n \n+    @cached_property\n+    def on_delete_types(self):\n+        from django.db.models import DB_CASCADE, DB_SET_DEFAULT, DB_SET_NULL, DO_NOTHING",
      "comment": "Nope, `django.db` could be an issue but `django.db.models` is fine.",
      "comment_id": 2480318514,
      "user": "felixxm",
      "created_at": "2025-10-31T06:51:08Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2480318514"
    },
    {
      "repo": "django/django",
      "pr_number": 19989,
      "file_path": "django/db/backends/mysql/introspection.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +54,14 @@ class DatabaseIntrospection(BaseDatabaseIntrospection):\n         FIELD_TYPE.VAR_STRING: \"CharField\",\n     }\n \n+    @cached_property\n+    def on_delete_types(self):\n+        on_delete_types = super().on_delete_types\n+        if self.connection.mysql_is_mariadb:\n+            # On MariaDB \"NO ACTION\" and \"RESTRICT\" are synonyms.\n+            on_delete_types[\"RESTRICT\"] = DO_NOTHING",
      "comment": "We can remove `on_delete_types` in MySQL backend, but this requires minor adjustments in introspection tests.\r\n\r\nUpdated.",
      "comment_id": 2480368385,
      "user": "felixxm",
      "created_at": "2025-10-31T07:21:23Z",
      "url": "https://github.com/django/django/pull/19989#discussion_r2480368385"
    },
    {
      "repo": "django/django",
      "pr_number": 20024,
      "file_path": "tests/utils_tests/test_inspect.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,6 +114,17 @@ def test_func_accepts_kwargs(self):\n         self.assertIs(inspect.func_accepts_kwargs(Person.all_kinds), True)\n         self.assertIs(inspect.func_accepts_kwargs(Person().just_args), False)\n \n+    def test_regression_36696(self):",
      "comment": "Use descriptive name instead of the ticket number, e.g.\r\n```suggestion\r\n    def test_func_accepts_kwargs_deferred_annotations(self):\r\n```",
      "comment_id": 2477618244,
      "user": "felixxm",
      "created_at": "2025-10-30T11:14:56Z",
      "url": "https://github.com/django/django/pull/20024#discussion_r2477618244"
    },
    {
      "repo": "django/django",
      "pr_number": 20024,
      "file_path": "tests/utils_tests/test_inspect.py",
      "line": 122,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,6 +114,17 @@ def test_func_accepts_kwargs(self):\n         self.assertIs(inspect.func_accepts_kwargs(Person.all_kinds), True)\n         self.assertIs(inspect.func_accepts_kwargs(Person().just_args), False)\n \n+    def test_regression_36696(self):\n+        # See https://code.djangoproject.com/ticket/36696\n+        # inspection failed with deferred annotations starting with python 3.14\n+        # however, we can only render this bug with Python 3.14, as earlier\n+        # versions would trigger the NameError on initialization of this\n+        # module.",
      "comment": "We normally don't include links to tickets in test comments, and avoid using `we` and similar. Maybe:\r\n```\r\n        # Inspection fails with deferred annotations with python 3.14+. Earlier\r\n        # Python versions trigger the NameError on module initialization.\r\n```",
      "comment_id": 2477633315,
      "user": "felixxm",
      "created_at": "2025-10-30T11:17:55Z",
      "url": "https://github.com/django/django/pull/20024#discussion_r2477633315"
    },
    {
      "repo": "django/django",
      "pr_number": 20024,
      "file_path": "tests/utils_tests/test_inspect.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,6 +114,17 @@ def test_func_accepts_kwargs(self):\n         self.assertIs(inspect.func_accepts_kwargs(Person.all_kinds), True)\n         self.assertIs(inspect.func_accepts_kwargs(Person().just_args), False)\n \n+    def test_regression_36696(self):\n+        # See https://code.djangoproject.com/ticket/36696\n+        # inspection failed with deferred annotations starting with python 3.14\n+        # however, we can only render this bug with Python 3.14, as earlier\n+        # versions would trigger the NameError on initialization of this\n+        # module.\n+        if not PY314:\n+            return",
      "comment": "Uhh, I did not know about this feature before, nice to know :)",
      "comment_id": 2477699445,
      "user": "prauscher",
      "created_at": "2025-10-30T11:29:47Z",
      "url": "https://github.com/django/django/pull/20024#discussion_r2477699445"
    },
    {
      "repo": "django/django",
      "pr_number": 20024,
      "file_path": "tests/utils_tests/test_inspect.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,6 +108,16 @@ def test_func_accepts_kwargs(self):\n         self.assertIs(inspect.func_accepts_kwargs(Person.all_kinds), True)\n         self.assertIs(inspect.func_accepts_kwargs(Person().just_args), False)\n \n+    @unittest.skipUnless(PY314, \"deferred annotations are python 3.14+ only\")",
      "comment": "```suggestion\r\n    @unittest.skipUnless(PY314, \"Deferred annotations are Python 3.14+ only\")\r\n```",
      "comment_id": 2480185369,
      "user": "felixxm",
      "created_at": "2025-10-31T05:14:14Z",
      "url": "https://github.com/django/django/pull/20024#discussion_r2480185369"
    },
    {
      "repo": "django/django",
      "pr_number": 19983,
      "file_path": "django/test/runner.py",
      "line": 574,
      "side": "RIGHT",
      "diff_hunk": "@@ -571,18 +571,25 @@ def run(self, result):\n \n         test_results = pool.imap_unordered(self.run_subsuite.__func__, args)\n \n+        timeout = 64  # ms",
      "comment": "I experiemented with another approach where I wrapped the body of `_init_worker` in a `try/except`, and set a flag (`init_failed`) in the except, and accessed it in the workers via a lock (shared state), but the bloating of the diff told me I was going in the wrong direction (?)",
      "comment_id": 2449843526,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-21T22:16:43Z",
      "url": "https://github.com/django/django/pull/19983#discussion_r2449843526"
    },
    {
      "repo": "django/django",
      "pr_number": 19983,
      "file_path": "django/test/runner.py",
      "line": 574,
      "side": "RIGHT",
      "diff_hunk": "@@ -571,18 +571,25 @@ def run(self, result):\n \n         test_results = pool.imap_unordered(self.run_subsuite.__func__, args)\n \n+        timeout = 64  # ms",
      "comment": "Actually, scratch that, I'll have to go back in that direction, in case user tests exceed this time limit. Bah. (EDIT: done \u2714\ufe0f )",
      "comment_id": 2449858046,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-21T22:21:23Z",
      "url": "https://github.com/django/django/pull/19983#discussion_r2449858046"
    },
    {
      "repo": "django/django",
      "pr_number": 19983,
      "file_path": "django/test/runner.py",
      "line": 598,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,9 +590,12 @@ def run(self, result):\n \n             try:\n                 subsuite_index, events = test_results.next(timeout=0.1)\n-            except multiprocessing.TimeoutError:\n+            except multiprocessing.TimeoutError as err:\n+                if counter.value == -1:\n+                    err.add_note(\"_init_worker failed\")\n+                    raise\n                 continue\n-            except StopIteration:\n+            except (StopIteration, multiprocessing.TimeoutError):",
      "comment": "I assumed this was added to avoid this error, but I'm still getting it if I force an error inside `init_worker`:\n```\nResourceWarning: unclosed running multiprocessing pool <multiprocessing.pool.Pool state=RUN pool_size=16>\n```",
      "comment_id": 2467145848,
      "user": "nessita",
      "created_at": "2025-10-27T21:36:22Z",
      "url": "https://github.com/django/django/pull/19983#discussion_r2467145848"
    },
    {
      "repo": "django/django",
      "pr_number": 19983,
      "file_path": "django/test/runner.py",
      "line": 595,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,9 +590,12 @@ def run(self, result):\n \n             try:\n                 subsuite_index, events = test_results.next(timeout=0.1)\n-            except multiprocessing.TimeoutError:\n+            except multiprocessing.TimeoutError as err:\n+                if counter.value == -1:\n+                    err.add_note(\"_init_worker failed\")",
      "comment": "Could we add a more prominent and explanatory note here?",
      "comment_id": 2467146325,
      "user": "nessita",
      "created_at": "2025-10-27T21:36:40Z",
      "url": "https://github.com/django/django/pull/19983#discussion_r2467146325"
    },
    {
      "repo": "django/django",
      "pr_number": 19983,
      "file_path": "django/test/runner.py",
      "line": 491,
      "side": "RIGHT",
      "diff_hunk": "@@ -480,6 +481,15 @@ def _init_worker(\n         )\n \n \n+def _safe_init_worker(init_worker, counter, *args, **kwargs):\n+    try:\n+        init_worker(counter, *args, **kwargs)\n+    except Exception:\n+        with counter.get_lock():\n+            counter.value = -1\n+        raise",
      "comment": "Is the goal of this new method to avoid indenting the original `_init_worker` one level in to add the try-except there?\n\nAlso, question: what happens if we create a `multiprocessing.Pool` of `N` threads: `t1`, `t2`, ..., `tN`, and (for example) `t2` executes super fast and crashes inside `_init_worker` before `t3` even starts initializing?\n\nSince `_safe_init_worker` sets `counter.value = -1` on failure, any thread still initializing could then read that shared value and end up with `_worker_id = 0`. That seems unintended and could lead to duplicate or invalid worker IDs. Furthermore, it could still raise but the code handling the exception does not see the counter in `-1`.",
      "comment_id": 2467358337,
      "user": "nessita",
      "created_at": "2025-10-27T23:01:40Z",
      "url": "https://github.com/django/django/pull/19983#discussion_r2467358337"
    },
    {
      "repo": "django/django",
      "pr_number": 19983,
      "file_path": "django/test/runner.py",
      "line": 595,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,9 +590,12 @@ def run(self, result):\n \n             try:\n                 subsuite_index, events = test_results.next(timeout=0.1)\n-            except multiprocessing.TimeoutError:\n+            except multiprocessing.TimeoutError as err:\n+                if counter.value == -1:\n+                    err.add_note(\"_init_worker failed\")",
      "comment": "Natalia suggested something like \"see traceback above\"",
      "comment_id": 2469498583,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-28T13:02:56Z",
      "url": "https://github.com/django/django/pull/19983#discussion_r2469498583"
    },
    {
      "repo": "django/django",
      "pr_number": 19983,
      "file_path": "django/test/runner.py",
      "line": 491,
      "side": "RIGHT",
      "diff_hunk": "@@ -480,6 +481,15 @@ def _init_worker(\n         )\n \n \n+def _safe_init_worker(init_worker, counter, *args, **kwargs):\n+    try:\n+        init_worker(counter, *args, **kwargs)\n+    except Exception:\n+        with counter.get_lock():\n+            counter.value = -1\n+        raise",
      "comment": "> Is the goal of this new method to avoid indenting the original _init_worker one level in to add the try-except there?\r\n\r\nExactly, keep the diff smaller and (more importantly) reduce the number of statements under a try.\r\n\r\n> That seems unintended and could lead to duplicate or invalid worker IDs.\r\n\r\nThanks \ud83c\udfaf ",
      "comment_id": 2470762225,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-28T19:14:11Z",
      "url": "https://github.com/django/django/pull/19983#discussion_r2470762225"
    },
    {
      "repo": "django/django",
      "pr_number": 19991,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,7 +112,20 @@ def _ext_backend_paths(self):\n                 paths.append(os.path.dirname(backend_dir))\n         return paths\n \n-    def run_test(self, args, settings_file=None, apps=None, umask=-1):\n+    @cached_property\n+    def path_without_formatters(self):\n+        black_path = find_formatters()[\"black_path\"]",
      "comment": "If black exists in multiple places on the path, we'd have to iterate this algorithm to keep patching it out. Not sure it's worth it.",
      "comment_id": 2452927439,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-22T18:08:47Z",
      "url": "https://github.com/django/django/pull/19991#discussion_r2452927439"
    },
    {
      "repo": "django/django",
      "pr_number": 19991,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,7 +112,20 @@ def _ext_backend_paths(self):\n                 paths.append(os.path.dirname(backend_dir))\n         return paths\n \n-    def run_test(self, args, settings_file=None, apps=None, umask=-1):\n+    @cached_property\n+    def path_without_formatters(self):\n+        black_path = find_formatters()[\"black_path\"]",
      "comment": "I agree it's not worth it. But perhaps we could/should remove from the `PATH` every formatter returned from `find_formatters` to be truth to the param name?\nSuggestion below.\n",
      "comment_id": 2465783866,
      "user": "nessita",
      "created_at": "2025-10-27T13:57:27Z",
      "url": "https://github.com/django/django/pull/19991#discussion_r2465783866"
    },
    {
      "repo": "django/django",
      "pr_number": 19991,
      "file_path": "tests/admin_scripts/tests.py",
      "line": 122,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,7 +112,20 @@ def _ext_backend_paths(self):\n                 paths.append(os.path.dirname(backend_dir))\n         return paths\n \n-    def run_test(self, args, settings_file=None, apps=None, umask=-1):\n+    @cached_property\n+    def path_without_formatters(self):\n+        black_path = find_formatters()[\"black_path\"]\n+        return os.pathsep.join(\n+            [\n+                path_component\n+                for path_component in os.environ.get(\"PATH\", \"\").split(os.pathsep)\n+                if os.path.commonpath([path_component, black_path]) == os.sep",
      "comment": "```suggestion\n                path_component\n                for path_component in os.environ.get(\"PATH\", \"\").split(os.pathsep)\n                for formmater_path in find_formatters().values()\n                if os.path.commonpath([path_component, formatter_path]) == os.sep\n```",
      "comment_id": 2465792187,
      "user": "nessita",
      "created_at": "2025-10-27T13:59:30Z",
      "url": "https://github.com/django/django/pull/19991#discussion_r2465792187"
    },
    {
      "repo": "django/django",
      "pr_number": 20003,
      "file_path": "tests/queries/test_explain.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,9 +159,7 @@ def test_mysql_text_to_traditional(self):\n         self.assertEqual(len(captured_queries), 1)\n         self.assertIn(\"FORMAT=TRADITIONAL\", captured_queries[0][\"sql\"])\n \n-    @unittest.skipUnless(\n-        connection.vendor == \"mysql\", \"MariaDB and MySQL >= 8.0.18 specific.\"\n-    )\n+    @unittest.skipUnless(connection.vendor == \"mysql\", \"MySQL specific\")",
      "comment": "This test passes on mariadb, so I think we can remove the skip. Debatable whether we should fix in this PR, but we are removing the dynamic skip for this test elsewhere in the PR.",
      "comment_id": 2465570550,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-27T12:58:37Z",
      "url": "https://github.com/django/django/pull/20003#discussion_r2465570550"
    },
    {
      "repo": "django/django",
      "pr_number": 20003,
      "file_path": "tests/queries/test_explain.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,9 +159,7 @@ def test_mysql_text_to_traditional(self):\n         self.assertEqual(len(captured_queries), 1)\n         self.assertIn(\"FORMAT=TRADITIONAL\", captured_queries[0][\"sql\"])\n \n-    @unittest.skipUnless(\n-        connection.vendor == \"mysql\", \"MariaDB and MySQL >= 8.0.18 specific.\"\n-    )\n+    @unittest.skipUnless(connection.vendor == \"mysql\", \"MySQL specific\")",
      "comment": "MySQL and MariaDB share the same vendor name `mysql`, this test is skipped on other vendors, not on MySQL or MariaDB.",
      "comment_id": 2465673708,
      "user": "felixxm",
      "created_at": "2025-10-27T13:27:51Z",
      "url": "https://github.com/django/django/pull/20003#discussion_r2465673708"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 320,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,27 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return \"a\" * secrets.randbelow(max_random_bytes)",
      "comment": "```suggestion\r\n    return b\"a\" * secrets.randbelow(max_random_bytes)\r\n```",
      "comment_id": 1027364608,
      "user": "ngnpope",
      "created_at": "2022-11-20T22:29:52Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1027364608"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 335,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,27 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return \"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, max_random_bytes=0):\n+    compressed_data = gzip_compress(s, compresslevel=6, mtime=0)\n+\n+    if max_random_bytes == 0:\n+        return compressed_data\n+\n+    header = bytearray(compressed_data[:10])\n+    header[3] = gzip.FNAME\n+\n+    return b\"\".join(\n+        [\n+            header,\n+            _get_random_fname(max_random_bytes).encode(\"ascii\"),",
      "comment": "```suggestion\r\n            _get_random_fname(max_random_bytes),\r\n```",
      "comment_id": 1027364663,
      "user": "ngnpope",
      "created_at": "2022-11-20T22:30:15Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1027364663"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,27 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return \"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, max_random_bytes=0):",
      "comment": "Make this new argument keyword-only?\r\n```suggestion\r\ndef compress_string(s, *,  max_random_bytes=0):\r\n```",
      "comment_id": 1027364796,
      "user": "ngnpope",
      "created_at": "2022-11-20T22:31:19Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1027364796"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 356,
      "side": "RIGHT",
      "diff_hunk": "@@ -327,9 +348,15 @@ def read(self):\n \n \n # Like compress_string, but for iterators of strings.\n-def compress_sequence(sequence):\n+def compress_sequence(sequence, max_random_bytes=0):\n     buf = StreamingBuffer()\n-    with GzipFile(mode=\"wb\", compresslevel=6, fileobj=buf, mtime=0) as zfile:\n+    with GzipFile(\n+        mode=\"wb\",\n+        filename=_get_random_fname(max_random_bytes) if max_random_bytes else None,",
      "comment": "_This should be fine if provided with a `bytes` filename... At least if `typeshed` is correct..._",
      "comment_id": 1027365391,
      "user": "ngnpope",
      "created_at": "2022-11-20T22:34:43Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1027365391"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 335,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,27 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return \"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, max_random_bytes=0):\n+    compressed_data = gzip_compress(s, compresslevel=6, mtime=0)\n+\n+    if max_random_bytes == 0:\n+        return compressed_data\n+\n+    header = bytearray(compressed_data[:10])\n+    header[3] = gzip.FNAME\n+\n+    return b\"\".join(\n+        [\n+            header,\n+            _get_random_fname(max_random_bytes).encode(\"ascii\"),",
      "comment": "This would also be less clunky styled as:\r\n```python\r\n    fname = _get_random_fname(max_random_bytes) + b\"\\x00\"\r\n    return b\"\".join([header, fname, compressed_data[10:]])\r\n```",
      "comment_id": 1027366036,
      "user": "ngnpope",
      "created_at": "2022-11-20T22:39:12Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1027366036"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,27 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return \"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, max_random_bytes=0):\n+    compressed_data = gzip_compress(s, compresslevel=6, mtime=0)\n+\n+    if max_random_bytes == 0:\n+        return compressed_data\n+\n+    header = bytearray(compressed_data[:10])\n+    header[3] = gzip.FNAME\n+\n+    return b\"\".join(\n+        [\n+            header,\n+            _get_random_fname(max_random_bytes).encode(\"ascii\"),\n+            b\"\\x00\",\n+            compressed_data[10:],",
      "comment": "```suggestion\r\n            memoryview(compressed_data)[10:],\r\n```\r\n\r\nUsing `memoryview` seems to prevent creating a copy of bytes for the slice. At least in the test that I used:\r\n```sh\r\n$ /usr/bin/time -f \"%M\" python -c 'b = b\"0\" * 10**6; b\"\".join([b\"123\", b[10:]])'            \r\n11880\r\n$ /usr/bin/time -f \"%M\" python -c 'b = b\"0\" * 10**6; b\"\".join([b\"123\", memoryview(b)[10:]])'\r\n10820\r\n```",
      "comment_id": 1028463589,
      "user": "illia-v",
      "created_at": "2022-11-21T19:56:17Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1028463589"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,27 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return \"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, max_random_bytes=0):\n+    compressed_data = gzip_compress(s, compresslevel=6, mtime=0)\n+\n+    if max_random_bytes == 0:\n+        return compressed_data\n+\n+    header = bytearray(compressed_data[:10])\n+    header[3] = gzip.FNAME\n+\n+    return b\"\".join(\n+        [\n+            header,\n+            _get_random_fname(max_random_bytes).encode(\"ascii\"),\n+            b\"\\x00\",\n+            compressed_data[10:],",
      "comment": "very nice! I thought about how to avoid potential copies but did not figure this out!",
      "comment_id": 1028528403,
      "user": "pelme",
      "created_at": "2022-11-21T21:25:06Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1028528403"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/conf/global_settings.py",
      "line": 673,
      "side": "RIGHT",
      "diff_hunk": "@@ -666,3 +666,8 @@ def gettext_noop(s):\n SECURE_REFERRER_POLICY = \"same-origin\"\n SECURE_SSL_HOST = None\n SECURE_SSL_REDIRECT = False\n+\n+###################\n+# GZIP MIDDLEWARE #\n+###################\n+GZIP_MIDDLEWARE_RANDOM_BYTES = 100",
      "comment": "Playing devil's advocate for a moment here, and to ensure the discussion is had, do we really _need_ a new setting here? \r\nAssuming `100` is enough in the general case[^1] and is a _good_ default, we could also possibly consider having it be directly on the `GZipMiddleware` class and letting downstream users subclass that if they wish to change the value[^2]. Though there might be considerations around other related concepts, like using it via `decorator_from_middleware` which I've not given a second thought to...\r\n\r\n[^1]: I've skimmed the paper to understand where that value came from, but I'm not exactly used to reading papers, so there may be nuance that I've missed.\r\n[^2]: I wonder, under what scenarios one might wish to change it? Any ideas?",
      "comment_id": 1030207386,
      "user": "kezabelle",
      "created_at": "2022-11-23T09:31:13Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1030207386"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/conf/global_settings.py",
      "line": 673,
      "side": "RIGHT",
      "diff_hunk": "@@ -666,3 +666,8 @@ def gettext_noop(s):\n SECURE_REFERRER_POLICY = \"same-origin\"\n SECURE_SSL_HOST = None\n SECURE_SSL_REDIRECT = False\n+\n+###################\n+# GZIP MIDDLEWARE #\n+###################\n+GZIP_MIDDLEWARE_RANDOM_BYTES = 100",
      "comment": "Totally agree, the number of random bytes should be a `GZipMiddleware` attribute.",
      "comment_id": 1030213682,
      "user": "felixxm",
      "created_at": "2022-11-23T09:37:26Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1030213682"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/conf/global_settings.py",
      "line": 673,
      "side": "RIGHT",
      "diff_hunk": "@@ -666,3 +666,8 @@ def gettext_noop(s):\n SECURE_REFERRER_POLICY = \"same-origin\"\n SECURE_SSL_HOST = None\n SECURE_SSL_REDIRECT = False\n+\n+###################\n+# GZIP MIDDLEWARE #\n+###################\n+GZIP_MIDDLEWARE_RANDOM_BYTES = 100",
      "comment": "Good idea, I agree, using an attribute is much better!\r\n\r\nRegarding picking the number, I picked 100 because it was the highest (safest) number discussed the paper. I have reached out to the paper authors to get their opinion on a good number being default in Django but has not gotten any feedback from them (yet).",
      "comment_id": 1031794016,
      "user": "pelme",
      "created_at": "2022-11-24T19:46:11Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1031794016"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/conf/global_settings.py",
      "line": 673,
      "side": "RIGHT",
      "diff_hunk": "@@ -666,3 +666,8 @@ def gettext_noop(s):\n SECURE_REFERRER_POLICY = \"same-origin\"\n SECURE_SSL_HOST = None\n SECURE_SSL_REDIRECT = False\n+\n+###################\n+# GZIP MIDDLEWARE #\n+###################\n+GZIP_MIDDLEWARE_RANDOM_BYTES = 100",
      "comment": "I think the only downside of using the highest number is the overhead of sending more bytes. However, the extra 50 bytes (average) does not feel that excessive to me. Especially since the other option may in many cases be to disable gzip altogether. ",
      "comment_id": 1031806426,
      "user": "pelme",
      "created_at": "2022-11-24T20:23:39Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1031806426"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,29 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return b\"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, *, max_random_bytes=0):\n+    compressed_data = gzip_compress(s, compresslevel=6, mtime=0)\n+\n+    if max_random_bytes == 0:\n+        return compressed_data\n+\n+    header = bytearray(compressed_data[:10])\n+    header[3] = gzip.FNAME\n+\n+    fname = _get_random_fname(max_random_bytes)\n+\n+    return b\"\".join(\n+        [\n+            header,\n+            fname,\n+            b\"\\x00\",\n+            memoryview(compressed_data)[10:],\n+        ]\n+    )",
      "comment": "I guess you could create the `memoryview` earlier?\r\n\r\nAlso, `header[3]` contains flags, so we should, strictly speaking, use `header[3] |= gzip.FNAME`.\r\n\r\n```suggestion\r\n    compressed_view = memory_view(compressed_data)\r\n    header = bytearray(compressed_view[:10])\r\n    header[3] |= gzip.FNAME\r\n    fname = _get_random_fname(max_random_bytes)\r\n    return b\"\".join([header, fname, b\"\\x00\", compressed_view[10:]])\r\n```",
      "comment_id": 1032368266,
      "user": "ngnpope",
      "created_at": "2022-11-25T11:36:03Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1032368266"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,29 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return b\"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, *, max_random_bytes=0):\n+    compressed_data = gzip_compress(s, compresslevel=6, mtime=0)\n+\n+    if max_random_bytes == 0:\n+        return compressed_data\n+\n+    header = bytearray(compressed_data[:10])\n+    header[3] = gzip.FNAME\n+\n+    fname = _get_random_fname(max_random_bytes)\n+\n+    return b\"\".join(\n+        [\n+            header,\n+            fname,\n+            b\"\\x00\",\n+            memoryview(compressed_data)[10:],\n+        ]\n+    )",
      "comment": "Also, not sure if it's cheaper, but we could do:\r\n```python\r\n    return header + fname + b\"\\x00\" + compressed_view[10:]\r\n```",
      "comment_id": 1032370390,
      "user": "ngnpope",
      "created_at": "2022-11-25T11:39:01Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1032370390"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,29 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return b\"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, *, max_random_bytes=0):\n+    compressed_data = gzip_compress(s, compresslevel=6, mtime=0)\n+\n+    if max_random_bytes == 0:\n+        return compressed_data\n+\n+    header = bytearray(compressed_data[:10])\n+    header[3] = gzip.FNAME\n+\n+    fname = _get_random_fname(max_random_bytes)\n+\n+    return b\"\".join(\n+        [\n+            header,\n+            fname,\n+            b\"\\x00\",\n+            memoryview(compressed_data)[10:],\n+        ]\n+    )",
      "comment": "In my original code, I made put in `assert header[3] == 0` before setting the flag. I am not sure if other flags can potentially mess up the byte order of the filename or cause other problems. We do control the call to `gzip.compress` so there should never be anything else than 0 for the flags anyways. Do you have any input on that?\r\n\r\nI originally used + instead of \"\".join(...) but thought that maybe join would lead to fewer allocations since python can just the build the result directly instead of doing 3 concatenations. Have not measured it and have no idea if it is better or worse. The header, fname and null termination is tiny data and the memoryview avoids copies anyways (IIUC) so I'll change to +, it is cleaner!.",
      "comment_id": 1032581307,
      "user": "pelme",
      "created_at": "2022-11-25T16:13:29Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1032581307"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,29 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_fname(max_random_bytes):\n+    return b\"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, *, max_random_bytes=0):\n+    compressed_data = gzip_compress(s, compresslevel=6, mtime=0)\n+\n+    if max_random_bytes == 0:\n+        return compressed_data\n+\n+    header = bytearray(compressed_data[:10])\n+    header[3] = gzip.FNAME\n+\n+    fname = _get_random_fname(max_random_bytes)\n+\n+    return b\"\".join(\n+        [\n+            header,\n+            fname,\n+            b\"\\x00\",\n+            memoryview(compressed_data)[10:],\n+        ]\n+    )",
      "comment": "Makes sense regarding the flags, thanks for the reasoning. Also, for the join or concat, whatever is faster \ud83d\ude42",
      "comment_id": 1032756943,
      "user": "ngnpope",
      "created_at": "2022-11-26T08:21:45Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1032756943"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "tests/middleware/tests.py",
      "line": 995,
      "side": "RIGHT",
      "diff_hunk": "@@ -978,12 +979,57 @@ def test_compress_deterministic(self):\n         ConditionalGetMiddleware from recognizing conditional matches\n         on gzipped content).\n         \"\"\"\n-        r1 = GZipMiddleware(self.get_response)(self.req)\n-        r2 = GZipMiddleware(self.get_response)(self.req)\n+\n+        class DeterministicGZipMiddleware(GZipMiddleware):\n+            max_random_bytes = 0\n+\n+        r1 = DeterministicGZipMiddleware(self.get_response)(self.req)\n+        r2 = DeterministicGZipMiddleware(self.get_response)(self.req)\n         self.assertEqual(r1.content, r2.content)\n         self.assertEqual(self.get_mtime(r1.content), 0)\n         self.assertEqual(self.get_mtime(r2.content), 0)\n \n+    def test_random_bytes(self):\n+        \"\"\"\n+        A random number of bytes is added to mitigate the BREACH attack:\n+        https://breachattack.com/",
      "comment": "on a second thought, I cant really think of a better wording, leaving it as-is",
      "comment_id": 1032811344,
      "user": "pelme",
      "created_at": "2022-11-26T17:05:48Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1032811344"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/middleware/gzip.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,6 +13,8 @@ class GZipMiddleware(MiddlewareMixin):\n     on the Accept-Encoding header.\n     \"\"\"\n \n+    max_random_bytes = 100",
      "comment": "We should document `max_random_bytes` in the `GZipMiddleware` docs.",
      "comment_id": 1049292009,
      "user": "felixxm",
      "created_at": "2022-12-15T07:21:29Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1049292009"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/utils/text.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -314,8 +316,23 @@ def phone2numeric(phone):\n     return \"\".join(char2number.get(c, c) for c in phone.lower())\n \n \n-def compress_string(s):\n-    return gzip_compress(s, compresslevel=6, mtime=0)\n+def _get_random_filename(max_random_bytes):\n+    return b\"a\" * secrets.randbelow(max_random_bytes)\n+\n+\n+def compress_string(s, *, max_random_bytes=0):",
      "comment": "I would change the default to `None` (in both functions):\r\n```suggestion\r\ndef compress_string(s, *, max_random_bytes=None):\r\n```",
      "comment_id": 1049292752,
      "user": "felixxm",
      "created_at": "2022-12-15T07:22:39Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1049292752"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "tests/middleware/tests.py",
      "line": 1004,
      "side": "RIGHT",
      "diff_hunk": "@@ -978,12 +979,57 @@ def test_compress_deterministic(self):\n         ConditionalGetMiddleware from recognizing conditional matches\n         on gzipped content).\n         \"\"\"\n-        r1 = GZipMiddleware(self.get_response)(self.req)\n-        r2 = GZipMiddleware(self.get_response)(self.req)\n+\n+        class DeterministicGZipMiddleware(GZipMiddleware):\n+            max_random_bytes = 0\n+\n+        r1 = DeterministicGZipMiddleware(self.get_response)(self.req)\n+        r2 = DeterministicGZipMiddleware(self.get_response)(self.req)\n         self.assertEqual(r1.content, r2.content)\n         self.assertEqual(self.get_mtime(r1.content), 0)\n         self.assertEqual(self.get_mtime(r2.content), 0)\n \n+    def test_random_bytes(self):\n+        \"\"\"\n+        A random number of bytes is added to mitigate the BREACH attack:\n+        https://breachattack.com/\n+        \"\"\"\n+        with mock.patch(\n+            \"django.utils.text.secrets.randbelow\", autospec=True, return_value=3\n+        ):\n+            r = GZipMiddleware(self.get_response)(self.req)\n+\n+        # The fourth byte of a gzip stream contains flags.\n+        self.assertEqual(r.content[3], gzip.FNAME)\n+        # Ensure we got a 3 byte filename \"aaa\" and a null byte",
      "comment": "To add more explanation, comments should state the expected behavior and omit prefixes like \"Ensure\" since all assertions ensure things. This guideline is from [Python coding style](https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#python-style).\r\n",
      "comment_id": 1049294516,
      "user": "felixxm",
      "created_at": "2022-12-15T07:25:20Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r1049294516"
    },
    {
      "repo": "django/django",
      "pr_number": 16311,
      "file_path": "django/conf/global_settings.py",
      "line": 673,
      "side": "RIGHT",
      "diff_hunk": "@@ -666,3 +666,8 @@ def gettext_noop(s):\n SECURE_REFERRER_POLICY = \"same-origin\"\n SECURE_SSL_HOST = None\n SECURE_SSL_REDIRECT = False\n+\n+###################\n+# GZIP MIDDLEWARE #\n+###################\n+GZIP_MIDDLEWARE_RANDOM_BYTES = 100",
      "comment": "For the record, after this PR was merged, I received this reply from Rafael Palacios, the author of the HTB paper:\r\n\r\n> We made our test using n=10 and n=100. Complexity for n=100 is huge, probably enough to use n=10 if there is an intrusion detection system, but safer in any scenario for n=100.",
      "comment_id": 2463728229,
      "user": "pelme",
      "created_at": "2025-10-26T10:49:24Z",
      "url": "https://github.com/django/django/pull/16311#discussion_r2463728229"
    },
    {
      "repo": "django/django",
      "pr_number": 19997,
      "file_path": "tests/update/tests.py",
      "line": 317,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,6 +311,11 @@ def test_updating_non_conditional_field(self):\n         with self.assertRaisesMessage(TypeError, msg):\n             DataPoint.objects.update(is_active=~F(\"name\"))\n \n+    def test_disallowed_update_distinct_on(self):\n+        msg = \"Cannot call update() after .distinct(*fields).\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            DataPoint.objects.distinct(\"id\").update(is_active=False)",
      "comment": "A thought: how about a field other than the primary key? That would model more realistic usage.\n\nThen, for the same reason, since this this syntax is only available on Postgres, I think we should move this test to the `DistinctOnTests` (even though this error still rises even when attempted on other dbs).",
      "comment_id": 2462046066,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-24T21:35:18Z",
      "url": "https://github.com/django/django/pull/19997#discussion_r2462046066"
    },
    {
      "repo": "django/django",
      "pr_number": 19997,
      "file_path": "tests/update/tests.py",
      "line": 317,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,6 +311,11 @@ def test_updating_non_conditional_field(self):\n         with self.assertRaisesMessage(TypeError, msg):\n             DataPoint.objects.update(is_active=~F(\"name\"))\n \n+    def test_disallowed_update_distinct_on(self):\n+        msg = \"Cannot call update() after .distinct(*fields).\"\n+        with self.assertRaisesMessage(TypeError, msg):\n+            DataPoint.objects.distinct(\"id\").update(is_active=False)",
      "comment": "Thanks for the feedback! \r\n\r\nTest was moved to `DistinctOnTests` and now performs a `distinct` on the `organization` field instead of `id` field. Please let me know if you spot any additional changes.",
      "comment_id": 2462113507,
      "user": "matthewshirley",
      "created_at": "2025-10-24T22:01:45Z",
      "url": "https://github.com/django/django/pull/19997#discussion_r2462113507"
    },
    {
      "repo": "django/django",
      "pr_number": 19986,
      "file_path": "tests/utils_tests/utils.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,3 +14,25 @@ def on_macos_with_hfs():\n         parsed_macos_version = tuple(int(x) for x in macos_version.split(\".\"))\n         return parsed_macos_version < (10, 14)\n     return False\n+\n+\n+@contextmanager\n+def gc_debug_context():",
      "comment": "A context manager is the right approach, but I was expecting to factor out the guts of `test_release_memory_without_garbage_collection` and use it both here and there.",
      "comment_id": 2452975018,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-22T18:23:22Z",
      "url": "https://github.com/django/django/pull/19986#discussion_r2452975018"
    },
    {
      "repo": "django/django",
      "pr_number": 19998,
      "file_path": "tests/bulk_create/tests.py",
      "line": 893,
      "side": "RIGHT",
      "diff_hunk": "@@ -890,18 +890,20 @@ class BulkCreateTransactionTests(TransactionTestCase):\n     available_apps = [\"bulk_create\"]\n \n     def test_no_unnecessary_transaction(self):\n+        unused_id = getattr(Country.objects.last(), \"id\", 10) + 100",
      "comment": "Maybe\n\n\n```suggestion\n        # Find a serial ID that hasn't been used already and has enough of a buffer for the\n        # following `bulk_create` call without an explicit pk not to conflict.\n        unused_id = getattr(Country.objects.last(), \"id\", 10) + 100\n```",
      "comment_id": 2460487611,
      "user": "charettes",
      "created_at": "2025-10-24T13:31:20Z",
      "url": "https://github.com/django/django/pull/19998#discussion_r2460487611"
    },
    {
      "repo": "django/django",
      "pr_number": 19933,
      "file_path": "django/conf/locale/de_CH/formats.py",
      "line": 32,
      "side": "LEFT",
      "diff_hunk": "@@ -25,11 +25,9 @@\n     \"%d.%m.%Y %H:%M\",  # '25.10.2006 14:30'\n ]\n \n-# these are the separators for non-monetary numbers. For monetary numbers,\n-# the DECIMAL_SEPARATOR is a . (decimal point) and the THOUSAND_SEPARATOR is a\n-# ' (single quote).\n-# For details, please refer to the documentation and the following link:\n-# https://www.bk.admin.ch/bk/de/home/dokumentation/sprachen/hilfsmittel-textredaktion/schreibweisungen.html",
      "comment": "Did you come to a conclusion about the usefulness of that link?",
      "comment_id": 2453292979,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-22T20:35:57Z",
      "url": "https://github.com/django/django/pull/19933#discussion_r2453292979"
    },
    {
      "repo": "django/django",
      "pr_number": 19933,
      "file_path": "django/conf/locale/de_CH/formats.py",
      "line": 32,
      "side": "LEFT",
      "diff_hunk": "@@ -25,11 +25,9 @@\n     \"%d.%m.%Y %H:%M\",  # '25.10.2006 14:30'\n ]\n \n-# these are the separators for non-monetary numbers. For monetary numbers,\n-# the DECIMAL_SEPARATOR is a . (decimal point) and the THOUSAND_SEPARATOR is a\n-# ' (single quote).\n-# For details, please refer to the documentation and the following link:\n-# https://www.bk.admin.ch/bk/de/home/dokumentation/sprachen/hilfsmittel-textredaktion/schreibweisungen.html",
      "comment": "I removed the link because of your [comment:29](https://code.djangoproject.com/ticket/35095#comment:29) suggesting it, which convinced me. Also, the document is in German. In English, a [styleguide for English-language translators](https://www.bk.admin.ch/bk/en/home/dokumentation/languages/hilfsmittel-textredaktion.html) is the only similar document available.",
      "comment_id": 2454855104,
      "user": "annalauraw",
      "created_at": "2025-10-23T11:48:09Z",
      "url": "https://github.com/django/django/pull/19933#discussion_r2454855104"
    },
    {
      "repo": "django/django",
      "pr_number": 19982,
      "file_path": "tests/test_runner/test_parallel.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -163,6 +166,13 @@ def test_picklable(self):\n         loaded_result = pickle.loads(pickle.dumps(result))\n         self.assertEqual(result.events, loaded_result.events)\n \n+    @unittest.skipIf(\n+        tblib and tblib_version >= (3, 2),\n+        \"tblib 3.2.0+ makes exception subclasses with __init__() and the \"\n+        \"default ___reduce__() picklable. Therefore, \"",
      "comment": "```suggestion\n        \"default __reduce__() picklable. Therefore, \"\n```",
      "comment_id": 2449470656,
      "user": "cliffordgama",
      "created_at": "2025-10-21T19:24:02Z",
      "url": "https://github.com/django/django/pull/19982#discussion_r2449470656"
    },
    {
      "repo": "django/django",
      "pr_number": 19593,
      "file_path": "django/core/servers/basehttp.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -182,35 +183,27 @@ def address_string(self):\n         return self.client_address[0]\n \n     def log_message(self, format, *args):\n-        extra = {\n-            \"request\": self.request,\n-            \"server_time\": self.log_date_time_string(),\n-        }\n-        if args[1][0] == \"4\":\n+        if args[1][0] == \"4\" and args[0].startswith(\"\\x16\\x03\"):\n             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n-            if args[0].startswith(\"\\x16\\x03\"):\n-                extra[\"status_code\"] = 500\n-                logger.error(\n-                    \"You're accessing the development server over HTTPS, but \"\n-                    \"it only supports HTTP.\",\n-                    extra=extra,\n-                )\n-                return\n-\n-        if args[1].isdigit() and len(args[1]) == 3:\n+            format = (\n+                \"You're accessing the development server over HTTPS, but it only \"\n+                \"supports HTTP.\"\n+            )\n+            status_code = 500\n+            args = ()",
      "comment": "Issue: This concerns me slightly, as it overrides the `*args*` passed in to the function. I suspect duplicating the `log_message` call here again is fine.",
      "comment_id": 2416037696,
      "user": "RealOrangeOne",
      "created_at": "2025-10-09T08:50:47Z",
      "url": "https://github.com/django/django/pull/19593#discussion_r2416037696"
    },
    {
      "repo": "django/django",
      "pr_number": 19593,
      "file_path": "django/core/servers/basehttp.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -182,35 +183,27 @@ def address_string(self):\n         return self.client_address[0]\n \n     def log_message(self, format, *args):\n-        extra = {\n-            \"request\": self.request,\n-            \"server_time\": self.log_date_time_string(),\n-        }\n-        if args[1][0] == \"4\":\n+        if args[1][0] == \"4\" and args[0].startswith(\"\\x16\\x03\"):\n             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n-            if args[0].startswith(\"\\x16\\x03\"):\n-                extra[\"status_code\"] = 500\n-                logger.error(\n-                    \"You're accessing the development server over HTTPS, but \"\n-                    \"it only supports HTTP.\",\n-                    extra=extra,\n-                )\n-                return\n-\n-        if args[1].isdigit() and len(args[1]) == 3:\n+            format = (\n+                \"You're accessing the development server over HTTPS, but it only \"\n+                \"supports HTTP.\"\n+            )\n+            status_code = 500\n+            args = ()",
      "comment": "But this was the case before, right? for this logging, the message and the args were completely ignored/dropped.",
      "comment_id": 2416527928,
      "user": "nessita",
      "created_at": "2025-10-09T11:51:18Z",
      "url": "https://github.com/django/django/pull/19593#discussion_r2416527928"
    },
    {
      "repo": "django/django",
      "pr_number": 19593,
      "file_path": "django/core/servers/basehttp.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -182,35 +183,27 @@ def address_string(self):\n         return self.client_address[0]\n \n     def log_message(self, format, *args):\n-        extra = {\n-            \"request\": self.request,\n-            \"server_time\": self.log_date_time_string(),\n-        }\n-        if args[1][0] == \"4\":\n+        if args[1][0] == \"4\" and args[0].startswith(\"\\x16\\x03\"):\n             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n-            if args[0].startswith(\"\\x16\\x03\"):\n-                extra[\"status_code\"] = 500\n-                logger.error(\n-                    \"You're accessing the development server over HTTPS, but \"\n-                    \"it only supports HTTP.\",\n-                    extra=extra,\n-                )\n-                return\n-\n-        if args[1].isdigit() and len(args[1]) == 3:\n+            format = (\n+                \"You're accessing the development server over HTTPS, but it only \"\n+                \"supports HTTP.\"\n+            )\n+            status_code = 500\n+            args = ()",
      "comment": "I agree that we were ignoring the args earlier, but i think duplicating the **log_message** makes the code much cleaner. So here i agree with @RealOrangeOne approach here. \r\n\r\nApart from this, i think everything else is fine.",
      "comment_id": 2417485541,
      "user": "YashRaj1506",
      "created_at": "2025-10-09T17:37:10Z",
      "url": "https://github.com/django/django/pull/19593#discussion_r2417485541"
    },
    {
      "repo": "django/django",
      "pr_number": 19593,
      "file_path": "django/core/servers/basehttp.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -182,35 +183,27 @@ def address_string(self):\n         return self.client_address[0]\n \n     def log_message(self, format, *args):\n-        extra = {\n-            \"request\": self.request,\n-            \"server_time\": self.log_date_time_string(),\n-        }\n-        if args[1][0] == \"4\":\n+        if args[1][0] == \"4\" and args[0].startswith(\"\\x16\\x03\"):\n             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n-            if args[0].startswith(\"\\x16\\x03\"):\n-                extra[\"status_code\"] = 500\n-                logger.error(\n-                    \"You're accessing the development server over HTTPS, but \"\n-                    \"it only supports HTTP.\",\n-                    extra=extra,\n-                )\n-                return\n-\n-        if args[1].isdigit() and len(args[1]) == 3:\n+            format = (\n+                \"You're accessing the development server over HTTPS, but it only \"\n+                \"supports HTTP.\"\n+            )\n+            status_code = 500\n+            args = ()",
      "comment": "Adding something like this makes sense:\r\n\r\n```\r\nif args[1][0] == \"4\" and args[0].startswith(\"\\x16\\x03\"):\r\n    log_message(\r\n        logger,\r\n        \"You're accessing the development server over HTTPS, but it only supports HTTP.\",\r\n        request=self.request,\r\n        status_code=500,\r\n        server_time=self.log_date_time_string(),\r\n    )\r\n    return\r\n```",
      "comment_id": 2417492514,
      "user": "YashRaj1506",
      "created_at": "2025-10-09T17:40:35Z",
      "url": "https://github.com/django/django/pull/19593#discussion_r2417492514"
    },
    {
      "repo": "django/django",
      "pr_number": 19593,
      "file_path": "django/core/servers/basehttp.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -182,35 +183,27 @@ def address_string(self):\n         return self.client_address[0]\n \n     def log_message(self, format, *args):\n-        extra = {\n-            \"request\": self.request,\n-            \"server_time\": self.log_date_time_string(),\n-        }\n-        if args[1][0] == \"4\":\n+        if args[1][0] == \"4\" and args[0].startswith(\"\\x16\\x03\"):\n             # 0x16 = Handshake, 0x03 = SSL 3.0 or TLS 1.x\n-            if args[0].startswith(\"\\x16\\x03\"):\n-                extra[\"status_code\"] = 500\n-                logger.error(\n-                    \"You're accessing the development server over HTTPS, but \"\n-                    \"it only supports HTTP.\",\n-                    extra=extra,\n-                )\n-                return\n-\n-        if args[1].isdigit() and len(args[1]) == 3:\n+            format = (\n+                \"You're accessing the development server over HTTPS, but it only \"\n+                \"supports HTTP.\"\n+            )\n+            status_code = 500\n+            args = ()",
      "comment": "Thank you both for your comments, but after some further consideration I'll leave the single call to the helper as proposed.\r\n\r\nThe rationale is that, in the HTTPS case, we already override the log message, so overriding `args` feels not only correct but necessary, since the message does not interpolate them. Keeping the current structure to reuse the helper for consistency and clarity.",
      "comment_id": 2445782052,
      "user": "nessita",
      "created_at": "2025-10-20T18:25:39Z",
      "url": "https://github.com/django/django/pull/19593#discussion_r2445782052"
    },
    {
      "repo": "django/django",
      "pr_number": 19968,
      "file_path": "django/db/backends/postgresql/compiler.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,10 +1,10 @@\n-from django.db.models.sql.compiler import (\n+from django.db.models.sql.compiler import (  # isort:skip\n     SQLAggregateCompiler,\n     SQLCompiler,\n     SQLDeleteCompiler,\n+    SQLUpdateCompiler,",
      "comment": "(I imagine this is where this import first was before isort tried to alphabetize it.)",
      "comment_id": 2436261665,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-16T14:38:46Z",
      "url": "https://github.com/django/django/pull/19968#discussion_r2436261665"
    },
    {
      "repo": "django/django",
      "pr_number": 19968,
      "file_path": "django/db/backends/postgresql/compiler.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,10 +1,10 @@\n-from django.db.models.sql.compiler import (\n+from django.db.models.sql.compiler import (  # isort:skip\n     SQLAggregateCompiler,\n     SQLCompiler,\n     SQLDeleteCompiler,\n+    SQLUpdateCompiler,",
      "comment": "If we are going down this path (isort skip), I would rather we do:\n\n```python\nfrom django.db.models.sql.compiler import (\n    SQLAggregateCompiler,\n    SQLCompiler,\n    SQLDeleteCompiler,\n    SQLInsertCompiler as BaseSQLInsertCompiler,\n    SQLUpdateCompiler,\n)\n```",
      "comment_id": 2436470108,
      "user": "nessita",
      "created_at": "2025-10-16T15:27:23Z",
      "url": "https://github.com/django/django/pull/19968#discussion_r2436470108"
    },
    {
      "repo": "django/django",
      "pr_number": 19968,
      "file_path": "tests/contenttypes_tests/test_views.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,9 +19,8 @@\n     ModelWithM2MToSite,\n     ModelWithNullFKToSite,\n     SchemeIncludedURL,\n+    UUIDModel,",
      "comment": "As before, if we are skipping, I would rather:\n```python\nfrom .models import (\n    Article,\n    Author,\n    FooWithBrokenAbsoluteUrl,\n    FooWithoutUrl,\n    FooWithUrl,\n    ModelWithM2MToSite,\n    ModelWithNullFKToSite,\n    SchemeIncludedURL,\n    Site as MockSite,\n    UUIDModel,\n)\n```",
      "comment_id": 2436476032,
      "user": "nessita",
      "created_at": "2025-10-16T15:28:49Z",
      "url": "https://github.com/django/django/pull/19968#discussion_r2436476032"
    },
    {
      "repo": "django/django",
      "pr_number": 19957,
      "file_path": "tests/gis_tests/geoapp/test_functions.py",
      "line": 950,
      "side": "RIGHT",
      "diff_hunk": "@@ -939,10 +939,19 @@ def test_geometry_type(self):\n             (\"POINT\", Point),\n             (\"LINESTRING\", LineString),\n             (\"POLYGON\", Polygon),\n-            (\"MULTIPOINT\", MultiPoint),\n             (\"MULTILINESTRING\", MultiLineString),\n             (\"MULTIPOLYGON\", MultiPolygon),\n         ]\n+        # GEOSWKTWriter_write() behavior was changed in GEOS 3.12+ to include\n+        # parentheses for sub-members. MariaDB doesn't accept WKT\n+        # representations with additional parentheses for MultiPoint. This is\n+        # an accepted bug (MDEV-36166) in MariaDB that should be fixed in the\n+        # future.\n+        if not connection.ops.mariadb or geos_version_tuple() < (3, 12):",
      "comment": "TIL that we set vendor name as booleans on `BaseSpatialOperations` instead of using features per-backend instead (I was expecting this to raise `AttributeError` or non-MySQL based backends).",
      "comment_id": 2432338490,
      "user": "charettes",
      "created_at": "2025-10-15T12:17:25Z",
      "url": "https://github.com/django/django/pull/19957#discussion_r2432338490"
    },
    {
      "repo": "django/django",
      "pr_number": 19955,
      "file_path": "django/db/models/query.py",
      "line": 2154,
      "side": "RIGHT",
      "diff_hunk": "@@ -2141,13 +2141,17 @@ def _check_operator_queryset(self, other, operator_):\n             raise TypeError(f\"Cannot use {operator_} operator with combined queryset.\")\n \n     def _check_ordering_first_last_queryset_aggregation(self, method):\n-        if isinstance(self.query.group_by, tuple) and not any(\n-            col.output_field is self.model._meta.pk for col in self.query.group_by\n-        ):\n-            raise TypeError(\n-                f\"Cannot use QuerySet.{method}() on an unordered queryset performing \"\n-                f\"aggregation. Add an ordering with order_by().\"\n-            )\n+        if isinstance(self.query.group_by, tuple):\n+            # Raise if the pk fields are not already in the group_by.\n+            if self.model._meta.pk not in {\n+                col.output_field for col in self.query.group_by\n+            } and set(self.model._meta.pk_fields).difference(\n+                {col.target for col in self.query.group_by}\n+            ):\n+                raise TypeError(\n+                    f\"Cannot use QuerySet.{method}() on an unordered queryset \"\n+                    \"performing aggregation. Add an ordering with order_by().\"\n+                )",
      "comment": "Could we avoid the extra indentation level and nested `if`, since all the checks need to hold as an `and`?\n\n```suggestion\n        if (\n            isinstance(self.query.group_by, tuple)\n            # Raise if the pk fields are not in the group_by.\n            and self.model._meta.pk\n            not in {col.output_field for col in self.query.group_by}\n            and set(self.model._meta.pk_fields).difference(\n                {col.target for col in self.query.group_by}\n            )\n        ):\n            raise TypeError(\n                f\"Cannot use QuerySet.{method}() on an unordered queryset performing \"\n                \"aggregation. Add an ordering with order_by().\"\n            )\n```",
      "comment_id": 2429980006,
      "user": "nessita",
      "created_at": "2025-10-14T17:44:16Z",
      "url": "https://github.com/django/django/pull/19955#discussion_r2429980006"
    },
    {
      "repo": "django/django",
      "pr_number": 19492,
      "file_path": "tests/admin_views/test_nav_sidebar.py",
      "line": 94,
      "side": "LEFT",
      "diff_hunk": "@@ -91,9 +91,7 @@ def test_sidebar_aria_current_page_missing_without_request_context_processor(sel\n         self.assertContains(\n             response, '<nav class=\"sticky\" id=\"nav-sidebar\" aria-label=\"Sidebar\">'\n         )\n-        # Does not include aria-current attribute.",
      "comment": "I would keep this comment\r\nThe test above has\r\n```\r\n      self.assertContains(\r\n            response, '<a href=\"%s\" aria-current=\"page\">Users</a>' % url\r\n        )\r\n```\r\nSo it's testing this Users link doesn't have aria-current=\"page\"",
      "comment_id": 2163215331,
      "user": "sarahboyce",
      "created_at": "2025-06-24T07:51:53Z",
      "url": "https://github.com/django/django/pull/19492#discussion_r2163215331"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "django/db/models/base.py",
      "line": 2223,
      "side": "RIGHT",
      "diff_hunk": "@@ -2220,6 +2220,15 @@ def _check_local_fields(cls, fields, option):\n                             id=\"models.E048\",\n                         )\n                     )\n+                elif type(field) is models.ForeignObject:",
      "comment": "If we want to make this more resilient against subclassing, we could borrow the logic here:\r\n\r\nhttps://github.com/django/django/blob/7528979153355faa49c3e49ba3ea233f998a7583/django/db/models/base.py#L1379-L1382",
      "comment_id": 2363158285,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-19T14:47:19Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2363158285"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "django/db/models/base.py",
      "line": 2227,
      "side": "RIGHT",
      "diff_hunk": "@@ -2220,6 +2220,15 @@ def _check_local_fields(cls, fields, option):\n                             id=\"models.E048\",\n                         )\n                     )\n+                elif type(field) is models.ForeignObject:\n+                    errors.append(\n+                        checks.Error(\n+                            f\"{option!r} refers to a ForeignObject {field_name!r},\"\n+                            f\"but ForeignObject are not permitted in {option!r}.\",",
      "comment": "```suggestion\r\n                            f\"but ForeignObjects are not permitted in {option!r}.\",\r\n```",
      "comment_id": 2363159095,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-19T14:47:31Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2363159095"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "tests/foreign_object/tests.py",
      "line": 776,
      "side": "RIGHT",
      "diff_hunk": "@@ -771,6 +773,14 @@ def test_pickling_foreignobject(self):\n \n \n class ForeignObjectModelValidationTests(TestCase):\n+    def setUp(self):\n+        CustomerTab._meta.constraints = [",
      "comment": "I bet we could move these to `invalid_models_tests.test_models.ConstraintsTests` to avoid the hack, but I didn't look too closely.",
      "comment_id": 2363189936,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-19T14:54:08Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2363189936"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "tests/foreign_object/tests.py",
      "line": 776,
      "side": "RIGHT",
      "diff_hunk": "@@ -771,6 +773,14 @@ def test_pickling_foreignobject(self):\n \n \n class ForeignObjectModelValidationTests(TestCase):\n+    def setUp(self):\n+        CustomerTab._meta.constraints = [",
      "comment": "Looking again, that doesn't look very promising :-)",
      "comment_id": 2380036104,
      "user": "jacobtylerwalls",
      "created_at": "2025-09-25T18:48:04Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2380036104"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "tests/foreign_object/tests.py",
      "line": 776,
      "side": "RIGHT",
      "diff_hunk": "@@ -771,6 +773,14 @@ def test_pickling_foreignobject(self):\n \n \n class ForeignObjectModelValidationTests(TestCase):\n+    def setUp(self):\n+        CustomerTab._meta.constraints = [",
      "comment": "yeah you want to avoid altering model definition at run time like this it's doomed to cause a ton of problems.",
      "comment_id": 2380040497,
      "user": "charettes",
      "created_at": "2025-09-25T18:49:42Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2380040497"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "django/db/models/base.py",
      "line": 2227,
      "side": "RIGHT",
      "diff_hunk": "@@ -2220,6 +2220,18 @@ def _check_local_fields(cls, fields, option):\n                             id=\"models.E048\",\n                         )\n                     )\n+                elif (\n+                    isinstance(field.remote_field, ForeignObjectRel)\n+                    and field not in cls._meta.local_concrete_fields\n+                ):",
      "comment": "How about we narrow this down to:\r\n```suggestion\r\n                    and len(getattr(field, \"from_fields\", [])) > 1\r\n                ):\r\n```",
      "comment_id": 2388713164,
      "user": "nessita",
      "created_at": "2025-09-29T17:31:47Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2388713164"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "django/db/models/base.py",
      "line": 2230,
      "side": "RIGHT",
      "diff_hunk": "@@ -2220,6 +2220,18 @@ def _check_local_fields(cls, fields, option):\n                             id=\"models.E048\",\n                         )\n                     )\n+                elif (\n+                    isinstance(field.remote_field, ForeignObjectRel)\n+                    and field not in cls._meta.local_concrete_fields\n+                ):\n+                    errors.append(\n+                        checks.Error(\n+                            f\"{option!r} refers to a ForeignObject {field_name!r}, \"\n+                            f\"but ForeignObjects are not permitted in {option!r}.\",",
      "comment": "With message:\r\n```suggestion\r\n                            f\"{option!r} refers to a ForeignObject {field_name!r} \"\r\n                            f\"with multiple target fields, which is not supported.\",\r\n```",
      "comment_id": 2388714563,
      "user": "nessita",
      "created_at": "2025-09-29T17:32:26Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2388714563"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "tests/invalid_models_tests/test_models.py",
      "line": 216,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,6 +166,34 @@ class Meta:\n             ],\n         )\n \n+    def test_pointing_to_foreign_object(self):\n+        class Reference(models.Model):\n+            reference_id = models.IntegerField(unique=True)\n+\n+        class ReferenceTab(models.Model):\n+            reference_id = models.IntegerField()\n+            reference = models.ForeignObject(\n+                Reference,\n+                from_fields=[\"reference_id\"],\n+                to_fields=[\"reference_id\"],\n+                on_delete=models.CASCADE,\n+            )\n+\n+            class Meta:\n+                unique_together = [[\"reference\"]]\n+\n+        self.assertEqual(\n+            ReferenceTab.check(),\n+            [\n+                Error(\n+                    \"'unique_together' refers to a ForeignObject 'reference', but \"\n+                    \"ForeignObjects are not permitted in 'unique_together'.\",\n+                    obj=ReferenceTab,\n+                    id=\"models.E049\",\n+                ),\n+            ],\n+        )\n+",
      "comment": "```suggestion\r\n        self.assertEqual(ReferenceTab.check(), [])\r\n\r\n    def test_pointing_to_foreign_object_multi_column(self):\r\n        class Reference(models.Model):\r\n            reference_id = models.IntegerField(unique=True)\r\n            code = models.CharField(max_length=1)\r\n\r\n        class ReferenceTabMultiple(models.Model):\r\n            reference_id = models.IntegerField()\r\n            code = models.CharField(max_length=1)\r\n            reference = models.ForeignObject(\r\n                Reference,\r\n                from_fields=[\"reference_id\", \"code\"],\r\n                to_fields=[\"reference_id\", \"code\"],\r\n                on_delete=models.CASCADE,\r\n            )\r\n\r\n            class Meta:\r\n                unique_together = [[\"reference\"]]\r\n\r\n        self.assertEqual(\r\n            ReferenceTabMultiple.check(),\r\n            [\r\n                Error(\r\n                    \"'unique_together' refers to a ForeignObject 'reference' \"\r\n                    \"with multiple target fields, which is not supported.\",\r\n                    obj=ReferenceTabMultiple,\r\n                    id=\"models.E049\",\r\n                ),\r\n            ],\r\n        )\r\n\r\n```",
      "comment_id": 2388798523,
      "user": "nessita",
      "created_at": "2025-09-29T18:03:52Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2388798523"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "tests/foreign_object/tests.py",
      "line": 795,
      "side": "RIGHT",
      "diff_hunk": "@@ -770,16 +770,39 @@ def test_pickling_foreignobject(self):\n         self.assertIn(\"reverse_path_infos\", foreign_object_restored.__dict__)\n \n \n-class ForeignObjectModelValidationTests(TestCase):\n-    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n+@isolate_apps(\"foreign_object\")\n+@skipUnlessDBFeature(\"supports_table_check_constraints\")\n+class ForeignObjectConstraintTests(TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+\n+        class CustomerTab(models.Model):\n+            customer_id = models.IntegerField()\n+            customer = models.ForeignObject(\n+                \"Customer\",\n+                from_fields=[\"customer_id\"],\n+                to_fields=[\"id\"],\n+                on_delete=models.CASCADE,\n+            )\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(\n+                        condition=Q(customer__lt=1000),\n+                        name=\"customer_id_limit\",\n+                    ),\n+                ]",
      "comment": "I haven't fully understood why we need to move this class to inside the `setUpClass`  forcing us to do `self.CustomerTab` in the tests. Could you help me understand please?",
      "comment_id": 2403635600,
      "user": "nessita",
      "created_at": "2025-10-04T01:06:06Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2403635600"
    },
    {
      "repo": "django/django",
      "pr_number": 19884,
      "file_path": "tests/foreign_object/tests.py",
      "line": 795,
      "side": "RIGHT",
      "diff_hunk": "@@ -770,16 +770,39 @@ def test_pickling_foreignobject(self):\n         self.assertIn(\"reverse_path_infos\", foreign_object_restored.__dict__)\n \n \n-class ForeignObjectModelValidationTests(TestCase):\n-    @skipUnlessDBFeature(\"supports_table_check_constraints\")\n+@isolate_apps(\"foreign_object\")\n+@skipUnlessDBFeature(\"supports_table_check_constraints\")\n+class ForeignObjectConstraintTests(TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+\n+        class CustomerTab(models.Model):\n+            customer_id = models.IntegerField()\n+            customer = models.ForeignObject(\n+                \"Customer\",\n+                from_fields=[\"customer_id\"],\n+                to_fields=[\"id\"],\n+                on_delete=models.CASCADE,\n+            )\n+\n+            class Meta:\n+                constraints = [\n+                    models.CheckConstraint(\n+                        condition=Q(customer__lt=1000),\n+                        name=\"customer_id_limit\",\n+                    ),\n+                ]",
      "comment": "Oh! Now that we've adjusted the system check to affect only multicolumns, we could probably revert this change.\r\n\r\n(It was only moved up here to evade the system check, so we could still check the underlying code supporting n = 1 columns.)",
      "comment_id": 2403639667,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-04T01:13:05Z",
      "url": "https://github.com/django/django/pull/19884#discussion_r2403639667"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/custom_lookups/tests.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,28 @@ def test_custom_name_lookup(self):\n             self.assertSequenceEqual(qs1, [a1])\n             self.assertSequenceEqual(qs2, [a1])\n \n+    def test_custom_lookup_with_subquery(self):",
      "comment": "I like that `NotEqual` is now in our test suite, I checked the documented custom `AbsoluteValueLessThan` lookup that's in the docs and this also appears to be working :+1: ",
      "comment_id": 1946760102,
      "user": "sarahboyce",
      "created_at": "2025-02-07T15:55:44Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r1946760102"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/lookup/tests.py",
      "line": 1067,
      "side": "RIGHT",
      "diff_hunk": "@@ -1064,6 +1064,16 @@ def test_regex_null(self):\n         Season.objects.create(year=2012, gt=None)\n         self.assertQuerySetEqual(Season.objects.filter(gt__regex=r\"^$\"), [])\n \n+    def test_regex_lookup_with_subquery(self):",
      "comment": "How do you feel about having a test which covers pretty much all registered lookups with a subquery (in a loop with `self.subTest`)?\r\nThere's a couple of line changes which we haven't strictly covered with a test and I wonder if having something like this might \"catch\" this issue in future lookups :thinking: \r\n",
      "comment_id": 1946777004,
      "user": "sarahboyce",
      "created_at": "2025-02-07T16:07:08Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r1946777004"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/lookup/tests.py",
      "line": 1067,
      "side": "RIGHT",
      "diff_hunk": "@@ -1064,6 +1064,16 @@ def test_regex_null(self):\n         Season.objects.create(year=2012, gt=None)\n         self.assertQuerySetEqual(Season.objects.filter(gt__regex=r\"^$\"), [])\n \n+    def test_regex_lookup_with_subquery(self):",
      "comment": "Good idea. (Note to self: probably move this test to BasicExpressionsTests circa `test_in_subquery()`?)\r\n\r\nCould you let me know which line changes you don't see covered? I tried reverting each one individually (while leaving the rest of the PR) and at least one test failed for each, but I might be missing your meaning:\r\n\r\n| change | test |\r\n| ------------- | ------------- |\r\n| Col.as_sql | test_custom_implementation_year_exact |\r\n| HasKeyLookup.as_sql | queries.test_bulk_update.BulkUpdateTests.test_json_field |\r\n| Lookup.get_db_prep_lookup | custom_lookups.tests.LookupTests.test_custom_lookup_with_subquery |\r\n| IExact.process_rhs | admin_utils.test_logentry.LogEntryTests.test_logentry_change_message |\r\n| PatternLookup.process_rhs | model_forms.test_modelchoicefield.ModelChoiceFieldTests.test_queryset_none |\r\n| Regex.get_db_prep_lookup | (on mariadb:) lookups.tests.LookupTests.test_regex_lookup_with_subquery |\r\n| SearchVector.as_sql | (on postgres) postgres_tests.test_search.MultipleFieldsTest |\r\n| SearchVectorExact.as_sql |  (on postgres) postgres_tests.test_search.TestCombinations |\r\n| DistanceLookupFromFunction.as_sql | gis_tests.distapp.tests.DistanceTest |\r\n| DWithinLookup.process_rhs | gis_tests.distapp.tests.DistanceTest |\r\n| RelateLookup.process_rhs |  gis_tests.distapp.tests.DistanceTest |\r\n",
      "comment_id": 1947983073,
      "user": "jacobtylerwalls",
      "created_at": "2025-02-09T01:00:25Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r1947983073"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/expressions/tests.py",
      "line": 752,
      "side": "RIGHT",
      "diff_hunk": "@@ -729,6 +729,24 @@ def test_in_subquery(self):\n         )\n         self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n \n+    def test_lookups_subquery(self):",
      "comment": "I looked into doing something similar for JSONField, but it fails pretty badly, so this might be a follow-up ticket:\r\n\r\nRough test:\r\n```diff\r\ndiff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\r\nindex 5a9cf9ad7a..32471d910e 100644\r\n--- a/tests/model_fields/test_jsonfield.py\r\n+++ b/tests/model_fields/test_jsonfield.py\r\n@@ -925,6 +925,20 @@ class TestQuerying(TestCase):\r\n             self.objs[3:5],\r\n         )\r\n \r\n+    @skipUnlessDBFeature(\"supports_json_field_contains\")\r\n+    def test_lookups_subquery(self):\r\n+        qs = NullableJSONModel.objects.values(\"value__foo\")[:1]\r\n+        for lookup in JSONField.get_lookups():\r\n+            with self.subTest(lookup=lookup):\r\n+                if lookup == \"isnull\":\r\n+                    continue  # not allowed, rhs must be a literal boolean.\r\n+                if lookup in {\"has_keys\", \"has_any_keys\"}:\r\n+                    rhs = [Subquery(qs)]\r\n+                else:\r\n+                    rhs = Subquery(qs)\r\n+                qs = NullableJSONModel.objects.filter(**{f\"value__foo__{lookup}\": rhs})\r\n+                self.assertGreaterEqual(len(qs), 0)\r\n+\r\n     @skipUnlessDBFeature(\"supports_json_field_contains\")\r\n     def test_array_key_contains(self):\r\n         tests = [\r\n```\r\n***\r\n```\r\n  File \"/usr/local/lib/python3.12/site-packages/psycopg/cursor.py\", line 97, in execute\r\n    raise ex.with_traceback(None)\r\ndjango.db.utils.ProgrammingError: the query has 5 placeholders but 19 parameters were passed\r\n```\r\n",
      "comment_id": 1948274147,
      "user": "jacobtylerwalls",
      "created_at": "2025-02-09T23:59:00Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r1948274147"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/custom_lookups/tests.py",
      "line": 262,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,28 @@ def test_custom_name_lookup(self):\n             self.assertSequenceEqual(qs1, [a1])\n             self.assertSequenceEqual(qs2, [a1])\n \n+    def test_custom_lookup_with_subquery(self):\n+        class NotEqual(models.Lookup):\n+            lookup_name = \"ne\"\n+\n+            def as_sql(self, compiler, connection):\n+                lhs, lhs_params = self.process_lhs(compiler, connection)\n+                rhs, rhs_params = self.process_rhs(compiler, connection)\n+                params = lhs_params + rhs_params",
      "comment": "Did you use the `a + b` style over the `(*a, *b)` intentionally here? Seems inconsistent with the other tests and the docs...",
      "comment_id": 2061414027,
      "user": "browniebroke",
      "created_at": "2025-04-26T15:56:14Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r2061414027"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/custom_lookups/tests.py",
      "line": 262,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,28 @@ def test_custom_name_lookup(self):\n             self.assertSequenceEqual(qs1, [a1])\n             self.assertSequenceEqual(qs2, [a1])\n \n+    def test_custom_lookup_with_subquery(self):\n+        class NotEqual(models.Lookup):\n+            lookup_name = \"ne\"\n+\n+            def as_sql(self, compiler, connection):\n+                lhs, lhs_params = self.process_lhs(compiler, connection)\n+                rhs, rhs_params = self.process_rhs(compiler, connection)\n+                params = lhs_params + rhs_params",
      "comment": "Great question. Yes, I did this intentionally to capture the scenario that failed with `TypeError`. If I adjust this test to the more resilient pattern with unpacking, I won't capture the issue.\r\n\r\nDo you think adding a comment would help clarify?\r\n\r\n> Seems inconsistent with the other tests and the docs...\r\n\r\nRe the docs, I've only documented the unpacking syntax in the release note (addressed to users supporting multiple versions of Django) since part of the point of this change is that the prior documented behavior (which was working in most cases) now works in the edge case with `Subquery`. So I wouldn't call it inconsistent with the docs.",
      "comment_id": 2061418361,
      "user": "jacobtylerwalls",
      "created_at": "2025-04-26T16:06:53Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r2061418361"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/custom_lookups/tests.py",
      "line": 262,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,28 @@ def test_custom_name_lookup(self):\n             self.assertSequenceEqual(qs1, [a1])\n             self.assertSequenceEqual(qs2, [a1])\n \n+    def test_custom_lookup_with_subquery(self):\n+        class NotEqual(models.Lookup):\n+            lookup_name = \"ne\"\n+\n+            def as_sql(self, compiler, connection):\n+                lhs, lhs_params = self.process_lhs(compiler, connection)\n+                rhs, rhs_params = self.process_rhs(compiler, connection)\n+                params = lhs_params + rhs_params",
      "comment": "Ah got you. Thanks for the explanation. \r\n\r\n> Do you think adding a comment would help clarify?\r\n\r\nPerhaps... I stumbled on this issue in the review queue and had some basic context, so I can imagine someone else looking at the test in the future might think the same as I did? I might have been biased by the surrounding changes in the diff.",
      "comment_id": 2061434915,
      "user": "browniebroke",
      "created_at": "2025-04-26T16:14:21Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r2061434915"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/custom_lookups/tests.py",
      "line": 262,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,28 @@ def test_custom_name_lookup(self):\n             self.assertSequenceEqual(qs1, [a1])\n             self.assertSequenceEqual(qs2, [a1])\n \n+    def test_custom_lookup_with_subquery(self):\n+        class NotEqual(models.Lookup):\n+            lookup_name = \"ne\"\n+\n+            def as_sql(self, compiler, connection):\n+                lhs, lhs_params = self.process_lhs(compiler, connection)\n+                rhs, rhs_params = self.process_rhs(compiler, connection)\n+                params = lhs_params + rhs_params",
      "comment": "Pushed a little comment in 6f1ada81c34df69290d80fa739c5956a04573bb3. Noticed there are merge conflicts, so I'll rebase in a sec.",
      "comment_id": 2061484297,
      "user": "jacobtylerwalls",
      "created_at": "2025-04-26T16:39:50Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r2061484297"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/custom_lookups/tests.py",
      "line": 262,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,28 @@ def test_custom_name_lookup(self):\n             self.assertSequenceEqual(qs1, [a1])\n             self.assertSequenceEqual(qs2, [a1])\n \n+    def test_custom_lookup_with_subquery(self):\n+        class NotEqual(models.Lookup):\n+            lookup_name = \"ne\"\n+\n+            def as_sql(self, compiler, connection):\n+                lhs, lhs_params = self.process_lhs(compiler, connection)\n+                rhs, rhs_params = self.process_rhs(compiler, connection)\n+                params = lhs_params + rhs_params",
      "comment": "And if you're still at the sprints, raise your hand or come say hello!",
      "comment_id": 2061484552,
      "user": "jacobtylerwalls",
      "created_at": "2025-04-26T16:40:37Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r2061484552"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/lookup/tests.py",
      "line": 1067,
      "side": "RIGHT",
      "diff_hunk": "@@ -1064,6 +1064,16 @@ def test_regex_null(self):\n         Season.objects.create(year=2012, gt=None)\n         self.assertQuerySetEqual(Season.objects.filter(gt__regex=r\"^$\"), [])\n \n+    def test_regex_lookup_with_subquery(self):",
      "comment": "The ones I don't get test failures for are:\r\n- `RelateLookup.process_rhs` (the `gis_tests.distapp.tests.DistanceTest` tests passed for me)\r\n- `Func.as_sql`\r\n\r\nAll other line changes I do get test failures when reverting",
      "comment_id": 2139974337,
      "user": "sarahboyce",
      "created_at": "2025-06-11T12:12:07Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r2139974337"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/lookup/tests.py",
      "line": 1067,
      "side": "RIGHT",
      "diff_hunk": "@@ -1064,6 +1064,16 @@ def test_regex_null(self):\n         Season.objects.create(year=2012, gt=None)\n         self.assertQuerySetEqual(Season.objects.filter(gt__regex=r\"^$\"), [])\n \n+    def test_regex_lookup_with_subquery(self):",
      "comment": "Thanks, my results agree with yours now. I'll have a look at adding some coverage in the next few days \ud83d\udc4d ",
      "comment_id": 2142839900,
      "user": "jacobtylerwalls",
      "created_at": "2025-06-12T13:59:09Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r2142839900"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/lookup/tests.py",
      "line": 1067,
      "side": "RIGHT",
      "diff_hunk": "@@ -1064,6 +1064,16 @@ def test_regex_null(self):\n         Season.objects.create(year=2012, gt=None)\n         self.assertQuerySetEqual(Season.objects.filter(gt__regex=r\"^$\"), [])\n \n+    def test_regex_lookup_with_subquery(self):",
      "comment": "I think the GIS changes are difficult to cover because the underlying lookups are already so resilient against either lists or tuples since ticket-31002. I think we can just treat these changes as code style cleanups. I did miss one for consistency: `GISLookup.get_db_prep_lookup`, just added.\r\n\r\nI added a case for `Func` (via `Lower`).",
      "comment_id": 2147399658,
      "user": "jacobtylerwalls",
      "created_at": "2025-06-15T01:56:14Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r2147399658"
    },
    {
      "repo": "django/django",
      "pr_number": 19057,
      "file_path": "tests/expressions/tests.py",
      "line": 752,
      "side": "RIGHT",
      "diff_hunk": "@@ -729,6 +729,24 @@ def test_in_subquery(self):\n         )\n         self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n \n+    def test_lookups_subquery(self):",
      "comment": "~This test found something to fix now, so I'll spruce it up and include it.~ Never mind, I had #19459 checked out, disregard. I'll just submit this test on Trac and get an opinion about the `# expected failures`.",
      "comment_id": 2178782419,
      "user": "jacobtylerwalls",
      "created_at": "2025-07-02T00:57:02Z",
      "url": "https://github.com/django/django/pull/19057#discussion_r2178782419"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +113,22 @@ def check(self, **kwargs):\n                 )\n         return errors\n \n-    def find(self, path, all=False):\n+    def find(self, path, fetch_all=False, **kwargs):",
      "comment": "I'm not familiarized in how deprecations are handled in python/django, but I think that adding `**kwargs` is overkill. Maybe add something like:\r\n\r\n```python\r\n    def find(self, path, fetch_all=False, all=None):\r\n        if all is not None:\r\n            # TODO: Add a warning or something\r\n            fetch_all = all\r\n```\r\n\r\nThis sadly doesn't fix shadowing `all`, but by adding a deprecation warning it will allow us to remove it in future versions.\r\n\r\nMaybe someone can give us some advice on how to handle this?",
      "comment_id": 1636888794,
      "user": "EnriqueSoria",
      "created_at": "2024-06-12T18:02:06Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1636888794"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +113,22 @@ def check(self, **kwargs):\n                 )\n         return errors\n \n-    def find(self, path, all=False):\n+    def find(self, path, fetch_all=False, **kwargs):",
      "comment": "Thanks for the feedback @EnriqueSoria. As per your suggestion I've added the deprecations warnings for the use of the `all` param in 03b3b1faabd1970ad846f1266ffb320b1ce0508b . On the other hand, I don't see why the use of `**kwargs` is an overkill in this case. I think it fits the case, removing the shadowing of the builtin `all` function and at the same time avoiding the errors for third party packages that may use or extend the existing finders API. I think  using `**kwargs` provide us the flexibility we need to keep the backwards compatibility. ",
      "comment_id": 1636958625,
      "user": "avallbona",
      "created_at": "2024-06-12T19:09:38Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1636958625"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +113,22 @@ def check(self, **kwargs):\n                 )\n         return errors\n \n-    def find(self, path, all=False):\n+    def find(self, path, fetch_all=False, **kwargs):",
      "comment": "When using a function that has `**kwargs` you don't know which parameters it does accept. That's why I dislike using it. \r\n\r\nBut I guess in this case is worth.",
      "comment_id": 1638038486,
      "user": "EnriqueSoria",
      "created_at": "2024-06-13T11:19:07Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1638038486"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +113,22 @@ def check(self, **kwargs):\n                 )\n         return errors\n \n-    def find(self, path, all=False):\n+    def find(self, path, fetch_all=False, **kwargs):",
      "comment": "Using `**kwargs` has the undesired side effect of allowing for arbitrary named arguments and the silently ignoring them. This is something that we should avoid so I see two options:\r\n1. Continue using `all` for the deprecation period, is not that terrible since we have already done so for the last 10+ years. \r\n2. Change to use `**kwargs` but then we should check that no other named param was given and raise the corresponding `TypeError`.\r\n\r\nI think 1 is the best option, so I would suggest to go down that path.",
      "comment_id": 1647853993,
      "user": "nessita",
      "created_at": "2024-06-20T16:36:57Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1647853993"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,11 +32,11 @@ def check(self, **kwargs):\n             \"configured correctly.\"\n         )\n \n-    def find(self, path, all=False):\n+    def find(self, path, fetch_all=False, **kwargs):",
      "comment": "I'm not sold on the new proposed name, I think a more accurate option would be `match_all` or `find_all`. To me, fetch implies that something will be \"brought\" from there to here (ie like data retrieval or similar), which is not really the case.\r\nWhat do you think?",
      "comment_id": 1647858614,
      "user": "nessita",
      "created_at": "2024-06-20T16:41:06Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1647858614"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,11 +32,11 @@ def check(self, **kwargs):\n             \"configured correctly.\"\n         )\n \n-    def find(self, path, all=False):\n+    def find(self, path, fetch_all=False, **kwargs):",
      "comment": "I agree, I think `find_all` it's a better fit for this param name. Handled in 704fdb92b513ee0d6218068990bd70afa90dfdfd",
      "comment_id": 1648173947,
      "user": "avallbona",
      "created_at": "2024-06-20T21:43:39Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1648173947"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +113,22 @@ def check(self, **kwargs):\n                 )\n         return errors\n \n-    def find(self, path, all=False):\n+    def find(self, path, fetch_all=False, **kwargs):",
      "comment": "@avallbona The comment above is what I was referring in the global comment.",
      "comment_id": 1649388083,
      "user": "nessita",
      "created_at": "2024-06-21T20:11:32Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1649388083"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +113,22 @@ def check(self, **kwargs):\n                 )\n         return errors\n \n-    def find(self, path, all=False):\n+    def find(self, path, fetch_all=False, **kwargs):",
      "comment": "Sorry I missed this comment \ud83d\ude2c . I'm not sure I like the option 1, we don't solve the problem right away and we pospone the solution to a future version, but I think it's clearer on what params the method accepts.\r\n\r\nI'll fix it.\r\n",
      "comment_id": 1649451616,
      "user": "avallbona",
      "created_at": "2024-06-21T21:40:33Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1649451616"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +113,22 @@ def check(self, **kwargs):\n                 )\n         return errors\n \n-    def find(self, path, all=False):\n+    def find(self, path, fetch_all=False, **kwargs):",
      "comment": "@nessita Addressed the issue in eacad9336b5225b6bd47894cd1d7d5db33367a47",
      "comment_id": 1649464846,
      "user": "avallbona",
      "created_at": "2024-06-21T22:06:00Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1649464846"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 136,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +119,25 @@ def check(self, **kwargs):\n                 )\n         return errors\n \n-    def find(self, path, all=False):\n+    def find(self, path, find_all=False, all=None):\n         \"\"\"\n         Look for files in the extra locations as defined in STATICFILES_DIRS.\n         \"\"\"\n+\n+        # we cover the case the method get called with the legacy param \"all\"\n+        if all is not None:\n+            warnings.warn(\n+                DEPRECATION_WARNING_MSG, RemovedInDjango60Warning, stacklevel=2\n+            )\n+            find_all = all",
      "comment": "What about deleting `all` symbol? That way we don't have it shadowed anymore\r\n\r\n```suggestion\r\n            find_all = all\r\n            del all\r\n```\r\n\r\nMaybe it's a bit tricky, but it does the job:\r\n\r\n```pycon\r\n>>> all = 3\r\n>>> find_all = 3\r\n>>> all([1,0,1])\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: 'int' object is not callable\r\n>>> del all\r\n>>> all([1,0,1])\r\nFalse\r\n>>> find_all\r\n3\r\n```",
      "comment_id": 1649693190,
      "user": "EnriqueSoria",
      "created_at": "2024-06-22T12:43:10Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1649693190"
    },
    {
      "repo": "django/django",
      "pr_number": 18259,
      "file_path": "django/contrib/staticfiles/finders.py",
      "line": 136,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,17 +119,25 @@ def check(self, **kwargs):\n                 )\n         return errors\n \n-    def find(self, path, all=False):\n+    def find(self, path, find_all=False, all=None):\n         \"\"\"\n         Look for files in the extra locations as defined in STATICFILES_DIRS.\n         \"\"\"\n+\n+        # we cover the case the method get called with the legacy param \"all\"\n+        if all is not None:\n+            warnings.warn(\n+                DEPRECATION_WARNING_MSG, RemovedInDjango60Warning, stacklevel=2\n+            )\n+            find_all = all",
      "comment": "@EnriqueSoria, It may be a personal preference but, I don't like this approach. It feels a bit hacky. I would rather way for the next version, to completely remove the `all` param from the method signature. ",
      "comment_id": 1654466057,
      "user": "avallbona",
      "created_at": "2024-06-26T09:32:24Z",
      "url": "https://github.com/django/django/pull/18259#discussion_r1654466057"
    },
    {
      "repo": "django/django",
      "pr_number": 19917,
      "file_path": "django/views/i18n.py",
      "line": 32,
      "side": "LEFT",
      "diff_hunk": "@@ -29,8 +29,9 @@ def builtin_template_path(name):\n \n def set_language(request):\n     \"\"\"\n-    Redirect to a given URL while setting the chosen language in the session",
      "comment": "Elsewhere (other than the other place in this PR), this is just \"the language cookie\", so I think this is sufficient here:\n```suggestion\n    Redirect to a given URL while setting the chosen language in the language cookie.\n```",
      "comment_id": 2402243330,
      "user": "jacobtylerwalls",
      "created_at": "2025-10-03T14:50:01Z",
      "url": "https://github.com/django/django/pull/19917#discussion_r2402243330"
    }
  ]
}