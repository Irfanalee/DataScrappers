{
  "repo": "psf/requests",
  "scraped_at": "2026-02-03T12:22:58.803383",
  "stats": {
    "total_comments": 450,
    "filtered": {
      "not_python": 81,
      "too_short": 117,
      "no_diff_hunk": 1,
      "too_long": 1,
      "skip_pattern:thank you": 1,
      "skip_pattern:nit:": 1
    },
    "kept": 248
  },
  "examples": [
    {
      "repo": "psf/requests",
      "pr_number": 6724,
      "file_path": "src/requests/adapters.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,13 +98,19 @@ def _urllib3_request_context(\n     parsed_request_url = urlparse(request.url)\n     scheme = parsed_request_url.scheme.lower()\n     port = parsed_request_url.port\n+\n+    # Determine if we have and should use our default SSLContext\n+    # to optimize performance on standard requests.\n     poolmanager_kwargs = getattr(poolmanager, \"connection_pool_kw\", {})\n     has_poolmanager_ssl_context = poolmanager_kwargs.get(\"ssl_context\")\n+    should_use_default_ssl_context = (\n+        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context\n+    )\n \n     cert_reqs = \"CERT_REQUIRED\"\n     if verify is False:\n         cert_reqs = \"CERT_NONE\"\n-    elif verify is True and not has_poolmanager_ssl_context:\n+    elif verify is True and should_use_default_ssl_context:",
      "comment": "Missed this earlier but do we need any logic for verify=True without a condition here? ",
      "comment_id": 1617854876,
      "user": "sigmavirus24",
      "created_at": "2024-05-28T20:27:08Z",
      "url": "https://github.com/psf/requests/pull/6724#discussion_r1617854876"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6724,
      "file_path": "src/requests/adapters.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,13 +98,19 @@ def _urllib3_request_context(\n     parsed_request_url = urlparse(request.url)\n     scheme = parsed_request_url.scheme.lower()\n     port = parsed_request_url.port\n+\n+    # Determine if we have and should use our default SSLContext\n+    # to optimize performance on standard requests.\n     poolmanager_kwargs = getattr(poolmanager, \"connection_pool_kw\", {})\n     has_poolmanager_ssl_context = poolmanager_kwargs.get(\"ssl_context\")\n+    should_use_default_ssl_context = (\n+        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context\n+    )\n \n     cert_reqs = \"CERT_REQUIRED\"\n     if verify is False:\n         cert_reqs = \"CERT_NONE\"\n-    elif verify is True and not has_poolmanager_ssl_context:\n+    elif verify is True and should_use_default_ssl_context:",
      "comment": "Are you asking about the behavior if `verify is True` but `should_use_default_ssl_context` is False? This was a no-op prior to #6655 which fellback to letting the SSLContext be created when fetching the connection from the pool. [`_ssl_wrap_socket_and_match_hostname`](https://github.com/urllib3/urllib3/blob/b07a669bd970d69847801148286b726f0570b625/src/urllib3/connection.py#L755-L765) handles this for us, so I don't know if there's any additional concern from our previous behavior unless I'm missing part of the question.",
      "comment_id": 1617955993,
      "user": "nateprewitt",
      "created_at": "2024-05-28T22:28:51Z",
      "url": "https://github.com/psf/requests/pull/6724#discussion_r1617955993"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6724,
      "file_path": "src/requests/adapters.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,13 +98,19 @@ def _urllib3_request_context(\n     parsed_request_url = urlparse(request.url)\n     scheme = parsed_request_url.scheme.lower()\n     port = parsed_request_url.port\n+\n+    # Determine if we have and should use our default SSLContext\n+    # to optimize performance on standard requests.\n     poolmanager_kwargs = getattr(poolmanager, \"connection_pool_kw\", {})\n     has_poolmanager_ssl_context = poolmanager_kwargs.get(\"ssl_context\")\n+    should_use_default_ssl_context = (\n+        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context\n+    )\n \n     cert_reqs = \"CERT_REQUIRED\"\n     if verify is False:\n         cert_reqs = \"CERT_NONE\"\n-    elif verify is True and not has_poolmanager_ssl_context:\n+    elif verify is True and should_use_default_ssl_context:",
      "comment": "Makes sense. I've a terrible headache so just looking at the branches and concerned about missing something is all. ",
      "comment_id": 1618008653,
      "user": "sigmavirus24",
      "created_at": "2024-05-28T23:58:29Z",
      "url": "https://github.com/psf/requests/pull/6724#discussion_r1618008653"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6724,
      "file_path": "src/requests/adapters.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,13 +98,19 @@ def _urllib3_request_context(\n     parsed_request_url = urlparse(request.url)\n     scheme = parsed_request_url.scheme.lower()\n     port = parsed_request_url.port\n+\n+    # Determine if we have and should use our default SSLContext\n+    # to optimize performance on standard requests.\n     poolmanager_kwargs = getattr(poolmanager, \"connection_pool_kw\", {})\n     has_poolmanager_ssl_context = poolmanager_kwargs.get(\"ssl_context\")\n+    should_use_default_ssl_context = (\n+        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context\n+    )\n \n     cert_reqs = \"CERT_REQUIRED\"\n     if verify is False:\n         cert_reqs = \"CERT_NONE\"\n-    elif verify is True and not has_poolmanager_ssl_context:\n+    elif verify is True and should_use_default_ssl_context:",
      "comment": "Nope, that's a good call out. I'll give it one more look before merging but I think we're ok for that case.",
      "comment_id": 1618009506,
      "user": "nateprewitt",
      "created_at": "2024-05-29T00:00:07Z",
      "url": "https://github.com/psf/requests/pull/6724#discussion_r1618009506"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6724,
      "file_path": "src/requests/adapters.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,13 +98,19 @@ def _urllib3_request_context(\n     parsed_request_url = urlparse(request.url)\n     scheme = parsed_request_url.scheme.lower()\n     port = parsed_request_url.port\n+\n+    # Determine if we have and should use our default SSLContext\n+    # to optimize performance on standard requests.\n     poolmanager_kwargs = getattr(poolmanager, \"connection_pool_kw\", {})\n     has_poolmanager_ssl_context = poolmanager_kwargs.get(\"ssl_context\")\n+    should_use_default_ssl_context = (\n+        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context\n+    )\n \n     cert_reqs = \"CERT_REQUIRED\"\n     if verify is False:\n         cert_reqs = \"CERT_NONE\"\n-    elif verify is True and not has_poolmanager_ssl_context:\n+    elif verify is True and should_use_default_ssl_context:",
      "comment": "Oh, looking again, not on a phone, and without a migraine, I see the `cert_reqs = \"CERT_REQUIRED\"` line on L110 that I clearly wrote, and which is what I was thinking we may want to be concerned about. So, I'm not nearly as worried.",
      "comment_id": 1619000165,
      "user": "sigmavirus24",
      "created_at": "2024-05-29T14:31:10Z",
      "url": "https://github.com/psf/requests/pull/6724#discussion_r1619000165"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6724,
      "file_path": "src/requests/adapters.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,13 +98,19 @@ def _urllib3_request_context(\n     parsed_request_url = urlparse(request.url)\n     scheme = parsed_request_url.scheme.lower()\n     port = parsed_request_url.port\n+\n+    # Determine if we have and should use our default SSLContext\n+    # to optimize performance on standard requests.\n     poolmanager_kwargs = getattr(poolmanager, \"connection_pool_kw\", {})\n     has_poolmanager_ssl_context = poolmanager_kwargs.get(\"ssl_context\")\n+    should_use_default_ssl_context = (\n+        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context\n+    )\n \n     cert_reqs = \"CERT_REQUIRED\"\n     if verify is False:\n         cert_reqs = \"CERT_NONE\"\n-    elif verify is True and not has_poolmanager_ssl_context:\n+    elif verify is True and should_use_default_ssl_context:\n         pool_kwargs[\"ssl_context\"] = _preloaded_ssl_context\n     elif isinstance(verify, str):\n         if not os.path.isdir(verify):",
      "comment": "Looking at this again with something of a performance mindset, do we want to cache somehow lookups to `isdir`? I'm not sure this hurts us at all, but just thinking about things that could slow us down in certain cases now. (Not for this pull request, just putting it out there)",
      "comment_id": 1619003075,
      "user": "sigmavirus24",
      "created_at": "2024-05-29T14:32:37Z",
      "url": "https://github.com/psf/requests/pull/6724#discussion_r1619003075"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6724,
      "file_path": "src/requests/adapters.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,13 +98,19 @@ def _urllib3_request_context(\n     parsed_request_url = urlparse(request.url)\n     scheme = parsed_request_url.scheme.lower()\n     port = parsed_request_url.port\n+\n+    # Determine if we have and should use our default SSLContext\n+    # to optimize performance on standard requests.\n     poolmanager_kwargs = getattr(poolmanager, \"connection_pool_kw\", {})\n     has_poolmanager_ssl_context = poolmanager_kwargs.get(\"ssl_context\")\n+    should_use_default_ssl_context = (\n+        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context\n+    )\n \n     cert_reqs = \"CERT_REQUIRED\"\n     if verify is False:\n         cert_reqs = \"CERT_NONE\"\n-    elif verify is True and not has_poolmanager_ssl_context:\n+    elif verify is True and should_use_default_ssl_context:\n         pool_kwargs[\"ssl_context\"] = _preloaded_ssl_context\n     elif isinstance(verify, str):\n         if not os.path.isdir(verify):",
      "comment": "That seems like a reasonable optimization, I guess we'd need to check how much time we're actually spending on the dir check. I assume we'll get feedback if we have cases where this is a bottleneck.",
      "comment_id": 1619084935,
      "user": "nateprewitt",
      "created_at": "2024-05-29T15:23:20Z",
      "url": "https://github.com/psf/requests/pull/6724#discussion_r1619084935"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6667,
      "file_path": "src/requests/adapters.py",
      "line": 294,
      "side": "LEFT",
      "diff_hunk": "@@ -284,27 +284,26 @@ def cert_verify(self, conn, url, verify, cert):\n         :param cert: The SSL certificate to verify.\n         \"\"\"\n         if url.lower().startswith(\"https\") and verify:\n-            cert_loc = None\n+            conn.cert_reqs = \"CERT_REQUIRED\"\n \n-            # Allow self-specified cert location.\n+            # Only load the CA certificates if 'verify' is a string indicating the CA bundle to use.\n+            # Otherwise, if verify is a boolean, we don't load anything since\n+            # the connection will be using a context with the default certificates already loaded,\n+            # and this avoids a call to the slow load_verify_locations()\n             if verify is not True:\n+                # `verify` must be a str with a path then\n                 cert_loc = verify\n \n-            if not cert_loc:\n-                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)",
      "comment": "This is actually critical behavior you're removing ",
      "comment_id": 1533138744,
      "user": "sigmavirus24",
      "created_at": "2024-03-21T01:45:42Z",
      "url": "https://github.com/psf/requests/pull/6667#discussion_r1533138744"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6667,
      "file_path": "src/requests/adapters.py",
      "line": 294,
      "side": "LEFT",
      "diff_hunk": "@@ -284,27 +284,26 @@ def cert_verify(self, conn, url, verify, cert):\n         :param cert: The SSL certificate to verify.\n         \"\"\"\n         if url.lower().startswith(\"https\") and verify:\n-            cert_loc = None\n+            conn.cert_reqs = \"CERT_REQUIRED\"\n \n-            # Allow self-specified cert location.\n+            # Only load the CA certificates if 'verify' is a string indicating the CA bundle to use.\n+            # Otherwise, if verify is a boolean, we don't load anything since\n+            # the connection will be using a context with the default certificates already loaded,\n+            # and this avoids a call to the slow load_verify_locations()\n             if verify is not True:\n+                # `verify` must be a str with a path then\n                 cert_loc = verify\n \n-            if not cert_loc:\n-                cert_loc = extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)",
      "comment": "Thanks for the catch, I had to adapt the patch quite a bit from what we're using right now and that inconsistency slipped by.\r\n\r\nI pushed a change to explicitly use `DEFAULT_CA_BUNDLE_PATH` when `verify=True`. This is done by creating a module-level `SSLContext` with that bundle already loaded, and instructing the connection pool to use that context when no custom bundle is specified. Since the server's cert is verified using the CA certificates loaded in the `SSLContext` used in the request, this should work.\r\n\r\nAgain, the goal is to avoid setting `ca_certs` or `ca_cert_dir` in the most common use case as it triggers another (in this case redundant) call to `load_verify_locations()` by urllib3:\r\n\r\n```py\r\nif ca_certs or ca_cert_dir or ca_cert_data:\r\n        try:\r\n            context.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)\r\n```\r\n\r\nSince `DEFAULT_CA_BUNDLE_PATH` is sugar for `certifi.where()`, which in turn always returns the path to a single bundle file, I decided to skip checking for `os.path.isdir()` because it should always be False. If you're not comfortable with this please let me know and I'll change it.\r\n\r\nI also changed `_urllib3_request_context()` slightly to handle the case where `verify` is a path to a dir instead to a single file, as we should set `ca_cert_dir` instead of `ca_certs` in that case. I believe this is now fully redundant with the corresponding logic in `cert_verify()`.\r\n\r\nI tried to write corresponding tests to verify that the `SSLContext`s used in different scenarios have the correct certificates loaded, but I couldn't find a way to access such low-level information about a request in the exposed classes. If it's possible, please give me a few pointers and I'll be glad to expand the test suite.",
      "comment_id": 1533587993,
      "user": "agubelu",
      "created_at": "2024-03-21T10:14:37Z",
      "url": "https://github.com/psf/requests/pull/6667#discussion_r1533587993"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6655,
      "file_path": "src/requests/adapters.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,12 +62,38 @@ def SOCKSProxyManager(*args, **kwargs):\n         raise InvalidSchema(\"Missing dependencies for SOCKS support.\")\n \n \n+if typing.TYPE_CHECKING:\n+    from .models import PreparedRequest",
      "comment": "Not against this, but I think this is the first time we're introducing typing into Requests. I'm curious if we want to start that or push it into typeshed since this will be precedent for future inline typing?",
      "comment_id": 1515206804,
      "user": "nateprewitt",
      "created_at": "2024-03-06T21:56:23Z",
      "url": "https://github.com/psf/requests/pull/6655#discussion_r1515206804"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6655,
      "file_path": "tests/test_requests.py",
      "line": 2836,
      "side": "RIGHT",
      "diff_hunk": "@@ -2828,6 +2828,13 @@ def test_status_code_425(self):\n         assert r5 == 425\n         assert r6 == 425\n \n+    def test_different_connection_pool_for_tls_settings(self):\n+        s = requests.Session()\n+        r1 = s.get(\"https://invalid.badssl.com\", verify=False)\n+        assert r1.status_code == 421\n+        with pytest.raises(requests.exceptions.SSLError):\n+            s.get(\"https://invalid.badssl.com\")",
      "comment": "There may not be a better way to test this but I don't know if we have other tests that require contacting a live site with TLS disabled. That may have some durability issues and means we're going to take the first response we get back. Probably minor, but figured I'd call it out.",
      "comment_id": 1518892861,
      "user": "nateprewitt",
      "created_at": "2024-03-10T16:33:36Z",
      "url": "https://github.com/psf/requests/pull/6655#discussion_r1518892861"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6655,
      "file_path": "src/requests/adapters.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,12 +62,38 @@ def SOCKSProxyManager(*args, **kwargs):\n         raise InvalidSchema(\"Missing dependencies for SOCKS support.\")\n \n \n+if typing.TYPE_CHECKING:\n+    from .models import PreparedRequest",
      "comment": "This is for a private method (that I fully anticipate people abusing) but we're not advertising things are typed and so it's not something I'm concerned with. ",
      "comment_id": 1518900181,
      "user": "sigmavirus24",
      "created_at": "2024-03-10T17:11:39Z",
      "url": "https://github.com/psf/requests/pull/6655#discussion_r1518900181"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6655,
      "file_path": "tests/test_requests.py",
      "line": 2836,
      "side": "RIGHT",
      "diff_hunk": "@@ -2828,6 +2828,13 @@ def test_status_code_425(self):\n         assert r5 == 425\n         assert r6 == 425\n \n+    def test_different_connection_pool_for_tls_settings(self):\n+        s = requests.Session()\n+        r1 = s.get(\"https://invalid.badssl.com\", verify=False)\n+        assert r1.status_code == 421\n+        with pytest.raises(requests.exceptions.SSLError):\n+            s.get(\"https://invalid.badssl.com\")",
      "comment": "There are many alternatives here, but those are all significantly more effort and this shows the behaviour is fixed before and after handily. I'm sure Linux folks will get pissed but I'm not as bothered about finding time later to do this a different way after we have fixed this",
      "comment_id": 1518900465,
      "user": "sigmavirus24",
      "created_at": "2024-03-10T17:12:49Z",
      "url": "https://github.com/psf/requests/pull/6655#discussion_r1518900465"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6655,
      "file_path": "tests/test_requests.py",
      "line": 2836,
      "side": "RIGHT",
      "diff_hunk": "@@ -2828,6 +2828,13 @@ def test_status_code_425(self):\n         assert r5 == 425\n         assert r6 == 425\n \n+    def test_different_connection_pool_for_tls_settings(self):\n+        s = requests.Session()\n+        r1 = s.get(\"https://invalid.badssl.com\", verify=False)\n+        assert r1.status_code == 421\n+        with pytest.raises(requests.exceptions.SSLError):\n+            s.get(\"https://invalid.badssl.com\")",
      "comment": "I'll try to prioritize better (offline) tests soon",
      "comment_id": 1519559679,
      "user": "sigmavirus24",
      "created_at": "2024-03-11T11:21:54Z",
      "url": "https://github.com/psf/requests/pull/6655#discussion_r1519559679"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6767,
      "file_path": "src/requests/adapters.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,19 +85,9 @@ def _urllib3_request_context(\n     scheme = parsed_request_url.scheme.lower()\n     port = parsed_request_url.port\n \n-    # Determine if we have and should use our default SSLContext\n-    # to optimize performance on standard requests.\n-    poolmanager_kwargs = getattr(poolmanager, \"connection_pool_kw\", {})\n-    has_poolmanager_ssl_context = poolmanager_kwargs.get(\"ssl_context\")\n-    should_use_default_ssl_context = (\n-        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context\n-    )\n-\n     cert_reqs = \"CERT_REQUIRED\"\n     if verify is False:\n         cert_reqs = \"CERT_NONE\"\n-    elif verify is True and should_use_default_ssl_context:\n-        pool_kwargs[\"ssl_context\"] = _preloaded_ssl_context\n     elif isinstance(verify, str):\n         if not os.path.isdir(verify):",
      "comment": "This is one piece I left in place from #6667. We were unilaterally considering any `verify` string to be `ca_certs` instead of detecting if it was a directory. That seems like a miss from #6655 unless I'm missing something?",
      "comment_id": 1683276287,
      "user": "nateprewitt",
      "created_at": "2024-07-18T18:02:54Z",
      "url": "https://github.com/psf/requests/pull/6767#discussion_r1683276287"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6757,
      "file_path": "src/requests/compat.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +10,14 @@\n import importlib\n import sys\n \n+# -------\n+# urllib3\n+# -------\n+from urllib3 import __version__ as urllib3_version\n+\n+# Detect which major version of urllib3 is being used.\n+is_urllib3_2 = urllib3_version.split('.')[0] == 2",
      "comment": "I believe this is a string, not an integer. Also, should do a >= check instead of equals.",
      "comment_id": 1683193453,
      "user": "sethmlarson",
      "created_at": "2024-07-18T16:49:44Z",
      "url": "https://github.com/psf/requests/pull/6757#discussion_r1683193453"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6757,
      "file_path": "src/requests/compat.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +10,14 @@\n import importlib\n import sys\n \n+# -------\n+# urllib3\n+# -------\n+from urllib3 import __version__ as urllib3_version\n+\n+# Detect which major version of urllib3 is being used.\n+is_urllib3_2 = urllib3_version.split('.')[0] == 2",
      "comment": "Good catch on the `int`. For the equivalence, I don't know if `>=` is what we want if this is specifically scoping the 2.x major version. In the same way I wouldn't want an `is_py3` to include Python 4.x. We could do something like `is_gt_urllib3_1` but that seems like it may be premature forwards-compatibility?\r\n\r\nRight now our dependencies are scoped at `urllib3<3` and if we add this check to any other behaviors, I'd rather they stay scoped to the major version. That will let tests fail if we major version again and we can make an informed decision at that point when adding support. Otherwise, we may unintentionally carry forward behaviors that are subtly wrong.\r\n\r\nI can see similar risks with both sides, so not a hill I'm going to die on, but that was my initial thought process.",
      "comment_id": 1683204168,
      "user": "nateprewitt",
      "created_at": "2024-07-18T16:58:58Z",
      "url": "https://github.com/psf/requests/pull/6757#discussion_r1683204168"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6757,
      "file_path": "src/requests/compat.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +10,14 @@\n import importlib\n import sys\n \n+# -------\n+# urllib3\n+# -------\n+from urllib3 import __version__ as urllib3_version\n+\n+# Detect which major version of urllib3 is being used.\n+is_urllib3_2 = urllib3_version.split('.')[0] == 2",
      "comment": "I've changed the check from checking for urllib3 2.x to check for 1.x. That leaves us open to forward compatibility without the confusing behavior with `is_urllib3_2` including newer major versions.",
      "comment_id": 1695374605,
      "user": "nateprewitt",
      "created_at": "2024-07-29T14:49:41Z",
      "url": "https://github.com/psf/requests/pull/6757#discussion_r1695374605"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6963,
      "file_path": "src/requests/utils.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -236,16 +236,8 @@ def get_netrc_auth(url, raise_errors=False):\n             return\n \n         ri = urlparse(url)\n-\n-        # Strip port numbers from netloc. This weird `if...encode`` dance is\n-        # used for Python 3.2, which doesn't support unicode literals.\n-        splitstr = b\":\"\n-        if isinstance(url, str):\n-            splitstr = splitstr.decode(\"ascii\")\n-        host = ri.netloc.split(splitstr)[0]\n-\n         try:\n-            _netrc = netrc(netrc_path).authenticators(host)\n+            _netrc = netrc(netrc_path).authenticators(ri.hostname)",
      "comment": "This is fixed now in main: https://github.com/psf/requests/commit/96ba401c1296ab1dda74a2365ef36d88f7d144ef",
      "comment_id": 2128118428,
      "user": "danigm",
      "created_at": "2025-06-05T07:12:17Z",
      "url": "https://github.com/psf/requests/pull/6963#discussion_r2128118428"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6951,
      "file_path": "docs/conf.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,7 +58,7 @@\n \n # General information about the project.\n project = u\"Requests\"\n-copyright = u'MMXVIX. A <a href=\"https://kenreitz.org/projects\">Kenneth Reitz</a> Project'\n+copyright = u'MMXVIX. A <a href=\"https://kennethreitz.org/software/\">Kenneth Reitz</a> Project'",
      "comment": "```suggestion\r\ncopyright = u'MMXVIX. A Kenneth Reitz Project'\r\n```",
      "comment_id": 2101041830,
      "user": "nateprewitt",
      "created_at": "2025-05-21T19:45:04Z",
      "url": "https://github.com/psf/requests/pull/6951#discussion_r2101041830"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6710,
      "file_path": "src/requests/adapters.py",
      "line": 417,
      "side": "RIGHT",
      "diff_hunk": "@@ -404,7 +414,10 @@ def _get_connection(self, request, verify, proxies=None, cert=None):\n         return conn\n \n     def get_connection(self, url, proxies=None):\n-        \"\"\"Returns a urllib3 connection for the given URL. This should not be\n+        \"\"\"DEPRECATED: Users should move to `get_connection_with_tls_context`",
      "comment": "If this method is deprecated shall we start emitting `DeprecationWarning`?",
      "comment_id": 1608603801,
      "user": "sethmlarson",
      "created_at": "2024-05-21T16:12:52Z",
      "url": "https://github.com/psf/requests/pull/6710#discussion_r1608603801"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6710,
      "file_path": "src/requests/adapters.py",
      "line": 417,
      "side": "RIGHT",
      "diff_hunk": "@@ -404,7 +414,10 @@ def _get_connection(self, request, verify, proxies=None, cert=None):\n         return conn\n \n     def get_connection(self, url, proxies=None):\n-        \"\"\"Returns a urllib3 connection for the given URL. This should not be\n+        \"\"\"DEPRECATED: Users should move to `get_connection_with_tls_context`",
      "comment": "I thought about that but it's not reachable in any of our code anymore and if someone is using a custom implementation it won't have the warning.\n\nHappy to be wrong if I'm missing something but it seems like it will just be dead code on arrival.",
      "comment_id": 1608609666,
      "user": "nateprewitt",
      "created_at": "2024-05-21T16:17:36Z",
      "url": "https://github.com/psf/requests/pull/6710#discussion_r1608609666"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6710,
      "file_path": "src/requests/adapters.py",
      "line": 417,
      "side": "RIGHT",
      "diff_hunk": "@@ -404,7 +414,10 @@ def _get_connection(self, request, verify, proxies=None, cert=None):\n         return conn\n \n     def get_connection(self, url, proxies=None):\n-        \"\"\"Returns a urllib3 connection for the given URL. This should not be\n+        \"\"\"DEPRECATED: Users should move to `get_connection_with_tls_context`",
      "comment": "I guess it's better to be safe, this should be addressed in 92075b330a30b9883f466a43d3f7566ab849f91b.",
      "comment_id": 1608624860,
      "user": "nateprewitt",
      "created_at": "2024-05-21T16:29:48Z",
      "url": "https://github.com/psf/requests/pull/6710#discussion_r1608624860"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6702,
      "file_path": "src/requests/compat.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,13 +7,28 @@\n compatibility until the next major version.\n \"\"\"\n \n-try:\n-    import chardet\n-except ImportError:\n-    import charset_normalizer as chardet\n-\n+import importlib\n import sys\n \n+# -------------------\n+# Character Detection\n+# -------------------\n+\n+\n+def _resolve_char_detection():\n+    \"\"\"Find supported character detection libraries.\"\"\"\n+    chardet = None\n+    for lib in (\"chardet\", \"charset_normalizer\"):",
      "comment": "While this keeps the logic of the earlier code, I think that the library which is required on should be tried first. https://github.com/psf/requests/pull/6714 addresses this.",
      "comment_id": 1609492798,
      "user": "nijel",
      "created_at": "2024-05-22T08:08:55Z",
      "url": "https://github.com/psf/requests/pull/6702#discussion_r1609492798"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6644,
      "file_path": "tests/test_adapters.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,7 @@\n+import requests.adapters\n+\n+\n+def test_request_url_trims_leading_path_separators():\n+    \"\"\"See also https://github.com/psf/requests/issues/6643.\"\"\"\n+    a = request.adapters.HTTPAdapter()",
      "comment": "```suggestion\n    a = requests.adapters.HTTPAdapter()\n```",
      "comment_id": 1498532708,
      "user": "sigmavirus24",
      "created_at": "2024-02-22T02:17:57Z",
      "url": "https://github.com/psf/requests/pull/6644#discussion_r1498532708"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6644,
      "file_path": "tests/test_adapters.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,7 @@\n+import requests.adapters\n+\n+\n+def test_request_url_trims_leading_path_separators():\n+    \"\"\"See also https://github.com/psf/requests/issues/6643.\"\"\"\n+    a = requests.adapters.HTTPAdapter()\n+    assert \"/v:h\" == a.request_url(\"http://127.0.0.1:10000//v:h\")",
      "comment": "```suggestion\n    assert \"/v:h\" == a.request_url(\"http://127.0.0.1:10000//v:h\", {})\n```",
      "comment_id": 1498534695,
      "user": "sigmavirus24",
      "created_at": "2024-02-22T02:21:39Z",
      "url": "https://github.com/psf/requests/pull/6644#discussion_r1498534695"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6644,
      "file_path": "tests/test_adapters.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,7 @@\n+import requests.adapters\n+\n+\n+def test_request_url_trims_leading_path_separators():\n+    \"\"\"See also https://github.com/psf/requests/issues/6643.\"\"\"\n+    a = requests.adapters.HTTPAdapter()\n+    assert \"/v:h\" == a.request_url(\"http://127.0.0.1:10000//v:h\", {})",
      "comment": "```suggestion\n    p = requests.Request(method=\"GET\", url=\"http://127.0.0.1:10000//v:h\").prepare()\n    assert \"/v:h\" == a.request_url(p, {})\n```",
      "comment_id": 1498539954,
      "user": "sigmavirus24",
      "created_at": "2024-02-22T02:31:51Z",
      "url": "https://github.com/psf/requests/pull/6644#discussion_r1498539954"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6644,
      "file_path": "src/requests/adapters.py",
      "line": 393,
      "side": "RIGHT",
      "diff_hunk": "@@ -389,7 +390,7 @@ def request_url(self, request, proxies):\n             proxy_scheme = urlparse(proxy).scheme.lower()\n             using_socks_proxy = proxy_scheme.startswith(\"socks\")\n \n-        url = request.path_url\n+        url = re.sub(\"^/+\", \"/\", request.path_url)",
      "comment": "As mentioned on https://github.com/urllib3/urllib3/issues/3352 this could also be\r\n\r\n```python\r\nurl = f\"/{request.path_url.lstrip('/')}\"\r\n```\r\n\r\nI could benchmark these but I don't particularly care what the implementation is. I just threw this together to show that it can be fixed",
      "comment_id": 1499181040,
      "user": "sigmavirus24",
      "created_at": "2024-02-22T12:39:14Z",
      "url": "https://github.com/psf/requests/pull/6644#discussion_r1499181040"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6644,
      "file_path": "src/requests/adapters.py",
      "line": 393,
      "side": "RIGHT",
      "diff_hunk": "@@ -389,7 +390,7 @@ def request_url(self, request, proxies):\n             proxy_scheme = urlparse(proxy).scheme.lower()\n             using_socks_proxy = proxy_scheme.startswith(\"socks\")\n \n-        url = request.path_url\n+        url = re.sub(\"^/+\", \"/\", request.path_url)",
      "comment": "It looks like the f-string (Python 3.9-3.12 tested) is ~4x faster but we're talking on the scale of nanoseconds so it's basically moot. I'd vote the f-string for readability, but don't have a strong opinion.",
      "comment_id": 1499501563,
      "user": "nateprewitt",
      "created_at": "2024-02-22T16:10:48Z",
      "url": "https://github.com/psf/requests/pull/6644#discussion_r1499501563"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6644,
      "file_path": "src/requests/adapters.py",
      "line": 393,
      "side": "RIGHT",
      "diff_hunk": "@@ -389,7 +390,7 @@ def request_url(self, request, proxies):\n             proxy_scheme = urlparse(proxy).scheme.lower()\n             using_socks_proxy = proxy_scheme.startswith(\"socks\")\n \n-        url = request.path_url\n+        url = re.sub(\"^/+\", \"/\", request.path_url)",
      "comment": "Yeah, I'm also happy to shove this into a branch too like \n\n```python\nif path.startswith('//'):\n```\n\nTo make it clearer that we only care about the separator being repeated. What I want is clarity in the reader as to why we're doing this. My old school brain things the regexp is clearer and the f-string looks sus but  that's just my opinion and I'm not holding it closely ",
      "comment_id": 1499711431,
      "user": "sigmavirus24",
      "created_at": "2024-02-22T18:22:38Z",
      "url": "https://github.com/psf/requests/pull/6644#discussion_r1499711431"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6589,
      "file_path": "src/requests/utils.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -134,7 +134,10 @@ def super_len(o):\n     total_length = None\n     current_position = 0\n \n-    if hasattr(o, \"__len__\"):\n+    if isinstance(o, str):",
      "comment": "More simply this can be an if without changing the following conditions and just set `o = o.encode(...)` in the block then let the rest of the logic work. As it will hit another condition which will get it's length",
      "comment_id": 1409296382,
      "user": "sigmavirus24",
      "created_at": "2023-11-29T13:38:39Z",
      "url": "https://github.com/psf/requests/pull/6589#discussion_r1409296382"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6589,
      "file_path": "src/requests/utils.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -134,7 +134,10 @@ def super_len(o):\n     total_length = None\n     current_position = 0\n \n-    if hasattr(o, \"__len__\"):\n+    if isinstance(o, str):",
      "comment": "Sounds fine to me. My usual workflow would be to rewrite my commit and do a force push to my branch (in my fork). Is this ok or would you prefer a separate commit for the change?",
      "comment_id": 1409321632,
      "user": "bruceadams",
      "created_at": "2023-11-29T13:57:59Z",
      "url": "https://github.com/psf/requests/pull/6589#discussion_r1409321632"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6562,
      "file_path": "src/requests/packages.py",
      "line": 26,
      "side": "LEFT",
      "diff_hunk": "@@ -23,6 +23,5 @@\n target = chardet.__name__\n for mod in list(sys.modules):\n     if mod == target or mod.startswith(f\"{target}.\"):\n-        target = target.replace(target, \"chardet\")",
      "comment": "This is unfortunately necessary. This is necessary to support charset-normalizer. The idea here is to import charset if it's installed instead of chardet from this location for users.\r\n\r\nThis is why we look at `chardet.__name__` (to determine which is most important: https://github.com/psf/requests/blob/839a8edec37c81a18ac8332cfbd44f44e1ae6206/src/requests/packages.py#L8 )\r\n\r\nSo what we need to do is determine how we want to handle this appropriately.\r\n\r\nThe idea is that we have two values:\r\n\r\n```py\r\ntarget = \"chardet\"\r\ntarget = \"charset_normalizer\"\r\n```\r\n\r\nIn the former case if `mod.startswith(\"chardet.\")` then we will be replacing `chardet` with `chardet`. In the latter case, we'd want to replace `charset_normalizer` with `chardet`.",
      "comment_id": 1377461842,
      "user": "sigmavirus24",
      "created_at": "2023-10-31T11:48:59Z",
      "url": "https://github.com/psf/requests/pull/6562#discussion_r1377461842"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6562,
      "file_path": "src/requests/packages.py",
      "line": 26,
      "side": "LEFT",
      "diff_hunk": "@@ -23,6 +23,5 @@\n target = chardet.__name__\n for mod in list(sys.modules):\n     if mod == target or mod.startswith(f\"{target}.\"):\n-        target = target.replace(target, \"chardet\")",
      "comment": "Got it, but still the for loop seems necessary. It'll just be mapping the last package of chardet modules to chardet package of requests. \r\n\r\nIf that is the expected behaviour then we can just assign the last package without running the for loop. ",
      "comment_id": 1377593896,
      "user": "amkarn258",
      "created_at": "2023-10-31T13:33:00Z",
      "url": "https://github.com/psf/requests/pull/6562#discussion_r1377593896"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6562,
      "file_path": "src/requests/packages.py",
      "line": 26,
      "side": "LEFT",
      "diff_hunk": "@@ -23,6 +23,5 @@\n target = chardet.__name__\n for mod in list(sys.modules):\n     if mod == target or mod.startswith(f\"{target}.\"):\n-        target = target.replace(target, \"chardet\")",
      "comment": "So I'm talking about the intent behind the line, there's obviously a bug in it. And I was trying to leave that as something for you to see for yourself.\n\nThe reality is that what we want is \n\n```py\nsys.modules[f\"requests.packages.{mod}\"] = sys.modules[mod]\nmod = mod.replace(target, \"chardet\")\nsys.modules[f\"requests.packages.{mod}\"] = sys.modules[mod]\n```\n\nBecause we may as well add charset normalizer in there but also, we want backwards compatibility with chardet\n\nSo it's a tiny bit obvious bug and we'd like the intended behavior fixed",
      "comment_id": 1377658476,
      "user": "sigmavirus24",
      "created_at": "2023-10-31T14:13:28Z",
      "url": "https://github.com/psf/requests/pull/6562#discussion_r1377658476"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6562,
      "file_path": "src/requests/packages.py",
      "line": 26,
      "side": "LEFT",
      "diff_hunk": "@@ -23,6 +23,5 @@\n target = chardet.__name__\n for mod in list(sys.modules):\n     if mod == target or mod.startswith(f\"{target}.\"):\n-        target = target.replace(target, \"chardet\")",
      "comment": "```\r\nsys.modules[f\"requests.packages.{mod}\"]` = sys.modules[mod]\r\nmod = mod.replace(target, \"chardet\")\r\nsys.modules[f\"requests.packages.{mod}\"] = sys.modules[mod]\r\n```\r\n\r\nDoesn't make sense, since then the mod will itself change to chardet and will throw a keyerror. \r\n\r\nHave added the support for both chardet and charset_normalizer in the latest commit, with this change - \r\n\r\n```\r\nsys.modules[f\"requests.packages.{mod}\"] = sys.modules[mod]\r\ntarget = target.replace(target, \"chardet\")\r\nsys.modules[f\"requests.packages.{target}\"] = sys.modules[mod]\r\n```\r\n",
      "comment_id": 1377751368,
      "user": "amkarn258",
      "created_at": "2023-10-31T15:10:40Z",
      "url": "https://github.com/psf/requests/pull/6562#discussion_r1377751368"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6562,
      "file_path": "src/requests/packages.py",
      "line": 26,
      "side": "LEFT",
      "diff_hunk": "@@ -23,6 +23,5 @@\n target = chardet.__name__\n for mod in list(sys.modules):\n     if mod == target or mod.startswith(f\"{target}.\"):\n-        target = target.replace(target, \"chardet\")",
      "comment": "Correct, it won't find the module, but it's still very wrong to do `target.replace(target, \"chardet\")`",
      "comment_id": 1377897436,
      "user": "sigmavirus24",
      "created_at": "2023-10-31T16:51:45Z",
      "url": "https://github.com/psf/requests/pull/6562#discussion_r1377897436"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6562,
      "file_path": "src/requests/packages.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,6 +23,7 @@\n target = chardet.__name__\n for mod in list(sys.modules):\n     if mod == target or mod.startswith(f\"{target}.\"):\n+        sys.modules[f\"requests.packages.{mod}\"] = sys.modules[mod]\n         target = target.replace(target, \"chardet\")\n         sys.modules[f\"requests.packages.{target}\"] = sys.modules[mod]",
      "comment": "```suggestion\r\n        imported_mod = sys.modules[mod]\r\n        sys.modules[f\"requests.packages.{mod}\"] = imported_mod\r\n        mod = mod.replace(target, \"chardet\")\r\n        sys.modules[f\"requests.packages.{mod}\"] = imported_mod\r\n```\r\n",
      "comment_id": 1377900725,
      "user": "sigmavirus24",
      "created_at": "2023-10-31T16:54:08Z",
      "url": "https://github.com/psf/requests/pull/6562#discussion_r1377900725"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6529,
      "file_path": "src/requests/models.py",
      "line": 948,
      "side": "RIGHT",
      "diff_hunk": "@@ -945,7 +945,7 @@ def text(self):\n         return content\n \n     def json(self, **kwargs):\n-        r\"\"\"Returns the json-encoded content of a response, if any.\n+        r\"\"\"Returns the json-decoded dict of a response, if any.",
      "comment": "```suggestion\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n\n           This may return a dictionary, list, etc. depending on what is in the response.\n```\n",
      "comment_id": 1950711358,
      "user": "sigmavirus24",
      "created_at": "2025-02-11T11:55:52Z",
      "url": "https://github.com/psf/requests/pull/6529#discussion_r1950711358"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6529,
      "file_path": "src/requests/models.py",
      "line": 948,
      "side": "RIGHT",
      "diff_hunk": "@@ -945,7 +945,8 @@ def text(self):\n         return content\n \n     def json(self, **kwargs):\n-        r\"\"\"Returns the json-encoded content of a response, if any.\n+        r\"\"\"Decodes the JSON response body (if any) as a Python object.",
      "comment": "```suggestion\n        r\"\"\"Decodes the JSON response body (if any) as a Python object.\n\n```\n",
      "comment_id": 1952510987,
      "user": "sigmavirus24",
      "created_at": "2025-02-12T11:57:20Z",
      "url": "https://github.com/psf/requests/pull/6529#discussion_r1952510987"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6448,
      "file_path": "setup.py",
      "line": 68,
      "side": "RIGHT",
      "diff_hunk": "@@ -65,7 +65,7 @@ def run_tests(self):\n     \"certifi>=2017.4.17\",\n ]\n test_requirements = [\n-    \"pytest-httpbin==0.0.7\",\n+    \"pytest-httpbin==2.0.0rc1\",",
      "comment": "```suggestion\r\n    \"pytest-httpbin==2.0.0rc2\",\r\n```",
      "comment_id": 1187828270,
      "user": "graingert",
      "created_at": "2023-05-08T19:47:43Z",
      "url": "https://github.com/psf/requests/pull/6448#discussion_r1187828270"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "requests/exceptions.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,6 +33,9 @@ class InvalidJSONError(RequestException):\n \n class JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n     \"\"\"Couldn't decode the text into json\"\"\"\n+    def __init__(self, *args, **kwargs):\n+        CompatJSONDecodeError.__init__(self, *args)\n+        InvalidJSONError.__init__(self, *self.args, **kwargs)",
      "comment": "Can we add comments here explaining why:\r\n\r\n1. We're using super old Python 2.5 methods of calling parent `__init__` methods\r\n2. We're calling the `__init__`s in this particular order - presuming the order matters\r\n3. This fixes the issue of `.doc` ending up in the message/default `__repr__`",
      "comment_id": 780674790,
      "user": "sigmavirus24",
      "created_at": "2022-01-08T14:42:14Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r780674790"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "requests/exceptions.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,6 +33,9 @@ class InvalidJSONError(RequestException):\n \n class JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n     \"\"\"Couldn't decode the text into json\"\"\"\n+    def __init__(self, *args, **kwargs):",
      "comment": "Can we add an empty line prior to the `__init__` here? That's already the style of this sub-module if not the entirety of `requests`",
      "comment_id": 780674982,
      "user": "sigmavirus24",
      "created_at": "2022-01-08T14:44:32Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r780674982"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "requests/exceptions.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,6 +34,16 @@ class InvalidJSONError(RequestException):\n class JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n     \"\"\"Couldn't decode the text into json\"\"\"\n \n+    def __init__(self, *args, **kwargs):\n+        \"\"\"\n+        Construct the JSONDecodeError instance first with all\n+        args. Then use it's args to construct the IOError so that\n+        the json specific args aren't used as IOError specific args\n+        and the error message that JSONDecodeError builds is preserved",
      "comment": "nit; This might be phrased \"[...] the error message from JSONDecodeError is preserved.\"\r\n\r\nAlso note the missing period in the current sentence.",
      "comment_id": 781581198,
      "user": "nateprewitt",
      "created_at": "2022-01-10T21:47:23Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r781581198"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "tests/test_requests.py",
      "line": 2590,
      "side": "RIGHT",
      "diff_hunk": "@@ -2585,5 +2585,11 @@ def test_post_json_nan(self, httpbin):\n \n     def test_json_decode_compatibility(self, httpbin):\n         r = requests.get(httpbin('bytes/20'))\n-        with pytest.raises(requests.exceptions.JSONDecodeError):\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n             r.json()\n+        assert isinstance(excinfo.value, RequestException)",
      "comment": "Do we need to use `.value` in these assertions? Just `excinfo` should be sufficient and that's how the typical user will probably interact with them.",
      "comment_id": 781592203,
      "user": "nateprewitt",
      "created_at": "2022-01-10T21:57:30Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r781592203"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "tests/test_requests.py",
      "line": 2594,
      "side": "RIGHT",
      "diff_hunk": "@@ -2585,5 +2585,11 @@ def test_post_json_nan(self, httpbin):\n \n     def test_json_decode_compatibility(self, httpbin):\n         r = requests.get(httpbin('bytes/20'))\n-        with pytest.raises(requests.exceptions.JSONDecodeError):\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n             r.json()\n+        assert isinstance(excinfo.value, RequestException)\n+        assert isinstance(excinfo.value, JSONDecodeError)\n+        assert data not in str(excinfo.value)\n+        if is_py3:",
      "comment": "Also somewhat of a nit. It may be better to just make this its own test with a `@unittest.skipIf(not is_py3)` at the top.\r\n\r\ne.g.\r\n\r\n```python\r\n@unittest.skipIf(not is_py3)\r\ndef test_json_decode_persists_doc_attr(self, httpbin):\r\n    r = requests.get(httpbin('bytes/20'))\r\n    with pytest.raises(requests.exceptions.JSONDecodeError) as e:\r\n        r.json()\r\n    assert e.doc == r.text\r\n```\r\n        \r\n",
      "comment_id": 781595242,
      "user": "nateprewitt",
      "created_at": "2022-01-10T22:00:15Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r781595242"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "tests/test_requests.py",
      "line": 2594,
      "side": "RIGHT",
      "diff_hunk": "@@ -2585,5 +2585,11 @@ def test_post_json_nan(self, httpbin):\n \n     def test_json_decode_compatibility(self, httpbin):\n         r = requests.get(httpbin('bytes/20'))\n-        with pytest.raises(requests.exceptions.JSONDecodeError):\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n             r.json()\n+        assert isinstance(excinfo.value, RequestException)\n+        assert isinstance(excinfo.value, JSONDecodeError)\n+        assert data not in str(excinfo.value)\n+        if is_py3:",
      "comment": "don't we want to test that the py2 object is also what we expect? Or if we don't can i can make it py3 only?",
      "comment_id": 781656546,
      "user": "chyzzqo2",
      "created_at": "2022-01-10T23:41:24Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r781656546"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "tests/test_requests.py",
      "line": 2590,
      "side": "RIGHT",
      "diff_hunk": "@@ -2585,5 +2585,11 @@ def test_post_json_nan(self, httpbin):\n \n     def test_json_decode_compatibility(self, httpbin):\n         r = requests.get(httpbin('bytes/20'))\n-        with pytest.raises(requests.exceptions.JSONDecodeError):\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n             r.json()\n+        assert isinstance(excinfo.value, RequestException)",
      "comment": "excinfo is a pytest thing that wraps the actual exception, i think we have to look at value to get the original object",
      "comment_id": 781658238,
      "user": "chyzzqo2",
      "created_at": "2022-01-10T23:45:42Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r781658238"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "tests/test_requests.py",
      "line": 2594,
      "side": "RIGHT",
      "diff_hunk": "@@ -2585,5 +2585,11 @@ def test_post_json_nan(self, httpbin):\n \n     def test_json_decode_compatibility(self, httpbin):\n         r = requests.get(httpbin('bytes/20'))\n-        with pytest.raises(requests.exceptions.JSONDecodeError):\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n             r.json()\n+        assert isinstance(excinfo.value, RequestException)\n+        assert isinstance(excinfo.value, JSONDecodeError)\n+        assert data not in str(excinfo.value)\n+        if is_py3:",
      "comment": "The original test doesn't assert anything about Python 2 either. So we don't lose anything with this change. I suppose we could assert doc _isn't_ on the Python 2 exception but I'm not sure how meaningful that is.\n\nEdit: to be clear I'm proposing two tests. The one you have and moving the Python 3 specifics to its own test.",
      "comment_id": 781659079,
      "user": "nateprewitt",
      "created_at": "2022-01-10T23:48:06Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r781659079"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "tests/test_requests.py",
      "line": 2594,
      "side": "RIGHT",
      "diff_hunk": "@@ -2585,5 +2585,11 @@ def test_post_json_nan(self, httpbin):\n \n     def test_json_decode_compatibility(self, httpbin):\n         r = requests.get(httpbin('bytes/20'))\n-        with pytest.raises(requests.exceptions.JSONDecodeError):\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n             r.json()\n+        assert isinstance(excinfo.value, RequestException)\n+        assert isinstance(excinfo.value, JSONDecodeError)\n+        assert data not in str(excinfo.value)\n+        if is_py3:",
      "comment": "ok, i think i updated it with what you had in mind.",
      "comment_id": 781684776,
      "user": "chyzzqo2",
      "created_at": "2022-01-11T00:58:10Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r781684776"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "requests/exceptions.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,6 +34,16 @@ class InvalidJSONError(RequestException):\n class JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\n     \"\"\"Couldn't decode the text into json\"\"\"\n \n+    def __init__(self, *args, **kwargs):\n+        \"\"\"\n+        Construct the JSONDecodeError instance first with all\n+        args. Then use it's args to construct the IOError so that\n+        the json specific args aren't used as IOError specific args\n+        and the error message from JSONDecodeError is preserved",
      "comment": "I think the last sentence still needs a period at the end.",
      "comment_id": 782303428,
      "user": "nateprewitt",
      "created_at": "2022-01-11T16:11:57Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r782303428"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "tests/test_requests.py",
      "line": 2601,
      "side": "RIGHT",
      "diff_hunk": "@@ -2585,5 +2585,18 @@ def test_post_json_nan(self, httpbin):\n \n     def test_json_decode_compatibility(self, httpbin):\n         r = requests.get(httpbin('bytes/20'))\n-        with pytest.raises(requests.exceptions.JSONDecodeError):\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n             r.json()\n+        assert isinstance(excinfo.value, RequestException)\n+        assert isinstance(excinfo.value, JSONDecodeError)\n+        assert data not in str(excinfo.value)\n+\n+    @pytest.mark.skipif(not is_py3, reason=\"doc attribute is only present on py3\")\n+    def test_json_decode_persists_doc_attr(self, httpbin):\n+        r = requests.get(httpbin('bytes/20'))\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n+            r.json()\n+        assert data not in str(excinfo.value)",
      "comment": "We probably don't need to reassert this since it's already handled in the test above.",
      "comment_id": 782304038,
      "user": "nateprewitt",
      "created_at": "2022-01-11T16:12:37Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r782304038"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "tests/test_requests.py",
      "line": 2598,
      "side": "RIGHT",
      "diff_hunk": "@@ -2585,5 +2585,18 @@ def test_post_json_nan(self, httpbin):\n \n     def test_json_decode_compatibility(self, httpbin):\n         r = requests.get(httpbin('bytes/20'))\n-        with pytest.raises(requests.exceptions.JSONDecodeError):\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n             r.json()\n+        assert isinstance(excinfo.value, RequestException)\n+        assert isinstance(excinfo.value, JSONDecodeError)\n+        assert data not in str(excinfo.value)\n+\n+    @pytest.mark.skipif(not is_py3, reason=\"doc attribute is only present on py3\")\n+    def test_json_decode_persists_doc_attr(self, httpbin):\n+        r = requests.get(httpbin('bytes/20'))\n+        data = r.text",
      "comment": "nit; since we're only using this once we can probably just use r.text in the final assertion as shown in the original proposal.",
      "comment_id": 782312495,
      "user": "nateprewitt",
      "created_at": "2022-01-11T16:21:42Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r782312495"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6036,
      "file_path": "tests/test_requests.py",
      "line": 2601,
      "side": "RIGHT",
      "diff_hunk": "@@ -2585,5 +2585,18 @@ def test_post_json_nan(self, httpbin):\n \n     def test_json_decode_compatibility(self, httpbin):\n         r = requests.get(httpbin('bytes/20'))\n-        with pytest.raises(requests.exceptions.JSONDecodeError):\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n             r.json()\n+        assert isinstance(excinfo.value, RequestException)\n+        assert isinstance(excinfo.value, JSONDecodeError)\n+        assert data not in str(excinfo.value)\n+\n+    @pytest.mark.skipif(not is_py3, reason=\"doc attribute is only present on py3\")\n+    def test_json_decode_persists_doc_attr(self, httpbin):\n+        r = requests.get(httpbin('bytes/20'))\n+        data = r.text\n+        with pytest.raises(requests.exceptions.JSONDecodeError) as excinfo:\n+            r.json()\n+        assert data not in str(excinfo.value)",
      "comment": "I liked having both in the same test, assures us that we are testing with the right string. but i'll take it out.",
      "comment_id": 782337397,
      "user": "chyzzqo2",
      "created_at": "2022-01-11T16:43:54Z",
      "url": "https://github.com/psf/requests/pull/6036#discussion_r782337397"
    },
    {
      "repo": "psf/requests",
      "pr_number": 4766,
      "file_path": "tests/test_requests.py",
      "line": 883,
      "side": "RIGHT",
      "diff_hunk": "@@ -875,11 +875,12 @@ def test_form_encoded_post_query_multivalued_element(self, httpbin):\n         assert prep.body == 'test=foo&test=baz'\n \n     def test_different_encodings_dont_break_post(self, httpbin):\n-        r = requests.post(httpbin('post'),\n-            data={'stuff': json.dumps({'a': 123})},\n-            params={'blah': 'asdf1234'},\n-            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n-        assert r.status_code == 200\n+        with open(__file__, 'rb') as f:\n+            r = requests.post(httpbin('post'),\n+                data={'stuff': json.dumps({'a': 123})},\n+                params={'blah': 'asdf1234'},\n+                files={'file': ('test_requests.py', f)})\n+            assert r.status_code == 200",
      "comment": "Let\u2019s pull the `assert` out to the same indentation level as `with`.",
      "comment_id": 209787773,
      "user": "nateprewitt",
      "created_at": "2018-08-13T23:14:55Z",
      "url": "https://github.com/psf/requests/pull/4766#discussion_r209787773"
    },
    {
      "repo": "psf/requests",
      "pr_number": 4766,
      "file_path": "tests/test_requests.py",
      "line": 912,
      "side": "RIGHT",
      "diff_hunk": "@@ -889,37 +890,41 @@ def test_different_encodings_dont_break_post(self, httpbin):\n             {'stuff': 'elixr'.encode('utf-8')},\n         ))\n     def test_unicode_multipart_post(self, httpbin, data):\n-        r = requests.post(httpbin('post'),\n-            data=data,\n-            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n-        assert r.status_code == 200\n+        with open(__file__, 'rb') as f:\n+            r = requests.post(httpbin('post'),\n+                data=data,\n+                files={'file': ('test_requests.py', f)})\n+            assert r.status_code == 200\n \n     def test_unicode_multipart_post_fieldnames(self, httpbin):\n         filename = os.path.splitext(__file__)[0] + '.py'\n-        r = requests.Request(\n-            method='POST', url=httpbin('post'),\n-            data={'stuff'.encode('utf-8'): 'elixr'},\n-            files={'file': ('test_requests.py', open(filename, 'rb'))})\n-        prep = r.prepare()\n-        assert b'name=\"stuff\"' in prep.body\n-        assert b'name=\"b\\'stuff\\'\"' not in prep.body\n+        with open(filename, 'rb') as f:\n+            r = requests.Request(\n+                method='POST', url=httpbin('post'),\n+                data={'stuff'.encode('utf-8'): 'elixr'},\n+                files={'file': ('test_requests.py', f)})\n+            prep = r.prepare()\n+            assert b'name=\"stuff\"' in prep.body\n+            assert b'name=\"b\\'stuff\\'\"' not in prep.body\n \n     def test_unicode_method_name(self, httpbin):\n-        files = {'file': open(__file__, 'rb')}\n-        r = requests.request(\n-            method=u('POST'), url=httpbin('post'), files=files)\n-        assert r.status_code == 200\n+        with open(__file__, 'rb') as f:\n+            files = {'file': f}",
      "comment": "Let's just pass this directly to the `files` parameter.",
      "comment_id": 221472175,
      "user": "nateprewitt",
      "created_at": "2018-09-30T20:23:42Z",
      "url": "https://github.com/psf/requests/pull/4766#discussion_r221472175"
    },
    {
      "repo": "psf/requests",
      "pr_number": 4766,
      "file_path": "tests/test_requests.py",
      "line": 907,
      "side": "RIGHT",
      "diff_hunk": "@@ -889,37 +890,41 @@ def test_different_encodings_dont_break_post(self, httpbin):\n             {'stuff': 'elixr'.encode('utf-8')},\n         ))\n     def test_unicode_multipart_post(self, httpbin, data):\n-        r = requests.post(httpbin('post'),\n-            data=data,\n-            files={'file': ('test_requests.py', open(__file__, 'rb'))})\n-        assert r.status_code == 200\n+        with open(__file__, 'rb') as f:\n+            r = requests.post(httpbin('post'),\n+                data=data,\n+                files={'file': ('test_requests.py', f)})\n+            assert r.status_code == 200\n \n     def test_unicode_multipart_post_fieldnames(self, httpbin):\n         filename = os.path.splitext(__file__)[0] + '.py'\n-        r = requests.Request(\n-            method='POST', url=httpbin('post'),\n-            data={'stuff'.encode('utf-8'): 'elixr'},\n-            files={'file': ('test_requests.py', open(filename, 'rb'))})\n-        prep = r.prepare()\n-        assert b'name=\"stuff\"' in prep.body\n-        assert b'name=\"b\\'stuff\\'\"' not in prep.body\n+        with open(filename, 'rb') as f:\n+            r = requests.Request(\n+                method='POST', url=httpbin('post'),\n+                data={'stuff'.encode('utf-8'): 'elixr'},\n+                files={'file': ('test_requests.py', f)})\n+            prep = r.prepare()\n+            assert b'name=\"stuff\"' in prep.body",
      "comment": "These asserts can be done at the same indentation as the `with` block.",
      "comment_id": 221472224,
      "user": "nateprewitt",
      "created_at": "2018-09-30T20:25:23Z",
      "url": "https://github.com/psf/requests/pull/4766#discussion_r221472224"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "requests/sessions.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,10 +39,7 @@\n \n # Preferred clock, based on which one is more accurate on a given system.\n if sys.platform == 'win32':",
      "comment": "Since we're now Python 3.7+ I wonder if we can start using `time.perf_counter` everywhere? Might need to do more research into why Windows was given only perf_counter/clock instead of `time.time()`",
      "comment_id": 833410951,
      "user": "sethmlarson",
      "created_at": "2022-03-23T15:32:31Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r833410951"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "setup.py",
      "line": 111,
      "side": "LEFT",
      "diff_hunk": "@@ -108,7 +102,6 @@ def run_tests(self):\n     extras_require={\n         'security': [],\n         'socks': ['PySocks>=1.5.6, !=1.5.7'],\n-        'socks:sys_platform == \"win32\" and python_version == \"2.7\"': ['win_inet_pton'],",
      "comment": "[Finally free...](https://pypi.org/project/win-inet-pton) :smiling_face_with_tear:",
      "comment_id": 833413598,
      "user": "sethmlarson",
      "created_at": "2022-03-23T15:34:32Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r833413598"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "tests/compat.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,9 +10,5 @@\n except ImportError:\n     cStringIO = None\n \n-if is_py3:\n-    def u(s):\n-        return s\n-else:\n-    def u(s):\n-        return s.decode('unicode-escape')\n+def u(s):",
      "comment": "Should we go through and remove all uses of `u(...)` in the tests to simplify them?",
      "comment_id": 833414757,
      "user": "sethmlarson",
      "created_at": "2022-03-23T15:35:27Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r833414757"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "tests/test_requests.py",
      "line": 846,
      "side": "RIGHT",
      "diff_hunk": "@@ -844,7 +843,7 @@ def test_conflicting_post_params(self, httpbin):\n             with pytest.raises(ValueError):\n                 requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n             with pytest.raises(ValueError):\n-                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n+                requests.post(url, data=u'[{\"some\": \"data\"}]', files={'some': f})",
      "comment": "No we don't, I have a separate linting PR that removes these lines entirely since they're redundant. I can move that into this one.",
      "comment_id": 833421896,
      "user": "nateprewitt",
      "created_at": "2022-03-23T15:41:49Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r833421896"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "tests/compat.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,9 +10,5 @@\n except ImportError:\n     cStringIO = None\n \n-if is_py3:\n-    def u(s):\n-        return s\n-else:\n-    def u(s):\n-        return s.decode('unicode-escape')\n+def u(s):",
      "comment": "I left the definition in case it's in use externally, but yes, it should be removed from all of our tests. I'll do a second pass if I missed some.",
      "comment_id": 833422816,
      "user": "nateprewitt",
      "created_at": "2022-03-23T15:42:39Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r833422816"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "requests/sessions.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,10 +39,7 @@\n \n # Preferred clock, based on which one is more accurate on a given system.\n if sys.platform == 'win32':",
      "comment": "It was a performance issue for Windows where the clock wasn't granular enough for CI to pass on Appveyor (#3988). I can take a look at standardizing everything onto perf_counter but that's probably a separate deep dive.",
      "comment_id": 833422938,
      "user": "nateprewitt",
      "created_at": "2022-03-23T15:42:44Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r833422938"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "tests/test_requests.py",
      "line": 846,
      "side": "RIGHT",
      "diff_hunk": "@@ -844,7 +843,7 @@ def test_conflicting_post_params(self, httpbin):\n             with pytest.raises(ValueError):\n                 requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n             with pytest.raises(ValueError):\n-                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n+                requests.post(url, data=u'[{\"some\": \"data\"}]', files={'some': f})",
      "comment": "`pyupgrade **/*.py --py37-plus` will deal with a bunch of `u''`s and other stuff.",
      "comment_id": 833439166,
      "user": "hugovk",
      "created_at": "2022-03-23T15:56:05Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r833439166"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "tests/test_requests.py",
      "line": 846,
      "side": "RIGHT",
      "diff_hunk": "@@ -844,7 +843,7 @@ def test_conflicting_post_params(self, httpbin):\n             with pytest.raises(ValueError):\n                 requests.post(url, data='[{\"some\": \"data\"}]', files={'some': f})\n             with pytest.raises(ValueError):\n-                requests.post(url, data=u('[{\"some\": \"data\"}]'), files={'some': f})\n+                requests.post(url, data=u'[{\"some\": \"data\"}]', files={'some': f})",
      "comment": "Yep, that's what's in the linting commit currently. Unfortunately, it just makes the two declarations identical so it will still require manual removal in one of the PRs.",
      "comment_id": 833449625,
      "user": "nateprewitt",
      "created_at": "2022-03-23T16:04:19Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r833449625"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "tests/compat.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,9 +10,5 @@\n except ImportError:\n     cStringIO = None\n \n-if is_py3:\n-    def u(s):\n-        return s\n-else:\n-    def u(s):\n-        return s.decode('unicode-escape')\n+def u(s):",
      "comment": "Perhaps add a deprecation warning for any external use?",
      "comment_id": 833454405,
      "user": "hugovk",
      "created_at": "2022-03-23T16:08:55Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r833454405"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "setup.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,7 +7,32 @@\n from setuptools import setup\n from setuptools.command.test import test as TestCommand\n \n-here = os.path.abspath(os.path.dirname(__file__))\n+\n+CURRENT_PYTHON = sys.version_info[:2]\n+REQUIRED_PYTHON = (3, 7)\n+\n+if CURRENT_PYTHON < REQUIRED_PYTHON:\n+    sys.stderr.write(\n+        \"\"\"\n+==========================\n+Unsupported Python version\n+==========================\n+This version of Requests requires Python {}.{}, but you're trying to\n+install it on Python {}.{}.\n+This may be because you are using a version of pip that doesn't\n+understand the python_requires classifier. Make sure you",
      "comment": "We discussed this in the urllib3 Discord with @nateprewitt and @graingert and figured out that this series of steps isn't always going to solve the problem because pip *also* dropped Python versions over time.\r\n\r\nThere were a few solutions proposed:\r\n- Keep the current message\r\n- Always recommend installing pip<21 (last version that supported Python 2 and 3.5)\r\n- Recommend installing [pip-with-requires-python](https://pypi.org/project/pip-with-requires-python)\r\n- Not give a recommendation on *how* to upgrade pip and setuptools?\r\n\r\nI also raised the point of recommending users upgrade pip/setuptools would likely break OS installations.",
      "comment_id": 834551612,
      "user": "sethmlarson",
      "created_at": "2022-03-24T17:20:47Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r834551612"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "setup.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,7 +7,32 @@\n from setuptools import setup\n from setuptools.command.test import test as TestCommand\n \n-here = os.path.abspath(os.path.dirname(__file__))\n+\n+CURRENT_PYTHON = sys.version_info[:2]\n+REQUIRED_PYTHON = (3, 7)\n+\n+if CURRENT_PYTHON < REQUIRED_PYTHON:\n+    sys.stderr.write(\n+        \"\"\"\n+==========================\n+Unsupported Python version\n+==========================\n+This version of Requests requires Python {}.{}, but you're trying to\n+install it on Python {}.{}.\n+This may be because you are using a version of pip that doesn't\n+understand the python_requires classifier. Make sure you",
      "comment": "I think `pip-with-requires-python` is likely the safest option. Alternatively, we'd vend the requires values from the package in our setup.py and compose the install message from those values as @graingert suggested. That avoids any risk for Python 3.4 users who still comprise a significant number of downloads.",
      "comment_id": 834561046,
      "user": "nateprewitt",
      "created_at": "2022-03-24T17:31:20Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r834561046"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "setup.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,7 +7,32 @@\n from setuptools import setup\n from setuptools.command.test import test as TestCommand\n \n-here = os.path.abspath(os.path.dirname(__file__))\n+\n+CURRENT_PYTHON = sys.version_info[:2]\n+REQUIRED_PYTHON = (3, 7)\n+\n+if CURRENT_PYTHON < REQUIRED_PYTHON:\n+    sys.stderr.write(\n+        \"\"\"\n+==========================\n+Unsupported Python version\n+==========================\n+This version of Requests requires Python {}.{}, but you're trying to\n+install it on Python {}.{}.\n+This may be because you are using a version of pip that doesn't\n+understand the python_requires classifier. Make sure you",
      "comment": "@pradyunsg Noted that new Python versions come with a \"good\" pip version out of the box. Maybe our strategy should be to instruct the user to either pin to <2.28 or upgrade to at least Python 3.7 (since they'll need that version to install Requests anyways) and then we don't need to mention pip/setuptools at all.",
      "comment_id": 834612265,
      "user": "sethmlarson",
      "created_at": "2022-03-24T18:32:48Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r834612265"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "setup.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,7 +7,32 @@\n from setuptools import setup\n from setuptools.command.test import test as TestCommand\n \n-here = os.path.abspath(os.path.dirname(__file__))\n+\n+CURRENT_PYTHON = sys.version_info[:2]\n+REQUIRED_PYTHON = (3, 7)\n+\n+if CURRENT_PYTHON < REQUIRED_PYTHON:\n+    sys.stderr.write(\n+        \"\"\"\n+==========================\n+Unsupported Python version\n+==========================\n+This version of Requests requires Python {}.{}, but you're trying to\n+install it on Python {}.{}.\n+This may be because you are using a version of pip that doesn't\n+understand the python_requires classifier. Make sure you",
      "comment": "I went ahead and [ripped out the whole of touching pip versions](https://github.com/psf/requests/pull/6091/commits/febcd5199c278d99232124e22b3ab2d912b7cc16) after further discussion. If users want to upgrade their pip, that's something they can manage, otherwise the simplest option is to upgrade their Python version which will provide this automatically.\r\n\r\nOther users are free to pin to older supported versions as discussed in the original deprecation announcement.",
      "comment_id": 834679845,
      "user": "nateprewitt",
      "created_at": "2022-03-24T20:03:49Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r834679845"
    },
    {
      "repo": "psf/requests",
      "pr_number": 6091,
      "file_path": "setup.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,17 +17,13 @@\n ==========================\n Unsupported Python version\n ==========================\n-This version of Requests requires Python {}.{}, but you're trying to\n-install it on Python {}.{}.\n-This may be because you are using a version of pip that doesn't\n-understand the python_requires classifier. Make sure you\n-have pip >= 9.0 and setuptools >= 24.2, then try again:\n-    $ python -m pip install --upgrade pip setuptools\n-    $ python -m pip install requests\n-This will install the latest version of Requests which works on your\n-version of Python. If you can't upgrade your pip (or Python), request\n-an older version of Requests:\n-    $ python -m pip install \"requests<2.28\"\n+This version of Requests requires at least Python {}.{}, but\n+you're trying to install it on Python {}.{}. To resolve this,\n+consider upgrading to a supported Python version.\n+\n+If you can't upgrade your Python version, you'll need to\n+pin to an older version of Requests:\n+    python -m pip install \"requests<2.28\"",
      "comment": "```suggestion\r\npin to an older version of Requests (<2.28).\r\n```\r\n\r\nLet's just go all the way here. :P",
      "comment_id": 834692016,
      "user": "pradyunsg",
      "created_at": "2022-03-24T20:18:55Z",
      "url": "https://github.com/psf/requests/pull/6091#discussion_r834692016"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5917,
      "file_path": "requests/utils.py",
      "line": 974,
      "side": "RIGHT",
      "diff_hunk": "@@ -932,15 +933,22 @@ def prepend_scheme_if_needed(url, new_scheme):\n \n     :rtype: str\n     \"\"\"\n-    scheme, netloc, path, params, query, fragment = urlparse(url, new_scheme)\n+    parsed = parse_url(url)\n+    scheme, auth, host, port, path, query, fragment = parsed\n \n-    # urlparse is a finicky beast, and sometimes decides that there isn't a\n-    # netloc present. Assume that it's being over-cautious, and switch netloc\n-    # and path if urlparse decided there was no netloc.\n+    # urlparse and parse_url determine that there isn't a netloc present in some\n+    # urls. We've chosen to assume parsing is being over-cautious, and switch\n+    # the netloc and path. This is maintained for backwards compatibility.\n+    netloc = parsed.netloc",
      "comment": "Uhhh, what? This doesn't make any sense to me, is this something that's only needed for `urlparse`?",
      "comment_id": 761620552,
      "user": "sethmlarson",
      "created_at": "2021-12-03T03:18:15Z",
      "url": "https://github.com/psf/requests/pull/5917#discussion_r761620552"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5917,
      "file_path": "requests/utils.py",
      "line": 974,
      "side": "RIGHT",
      "diff_hunk": "@@ -932,15 +933,22 @@ def prepend_scheme_if_needed(url, new_scheme):\n \n     :rtype: str\n     \"\"\"\n-    scheme, netloc, path, params, query, fragment = urlparse(url, new_scheme)\n+    parsed = parse_url(url)\n+    scheme, auth, host, port, path, query, fragment = parsed\n \n-    # urlparse is a finicky beast, and sometimes decides that there isn't a\n-    # netloc present. Assume that it's being over-cautious, and switch netloc\n-    # and path if urlparse decided there was no netloc.\n+    # urlparse and parse_url determine that there isn't a netloc present in some\n+    # urls. We've chosen to assume parsing is being over-cautious, and switch\n+    # the netloc and path. This is maintained for backwards compatibility.\n+    netloc = parsed.netloc",
      "comment": "Yeah, this is only a quirk for `urlparse`. I'd thought I repro'd with `parse_url` initially, but I'm unable to now.\r\n\r\nI'll reword the whole comment for clarity. I'm not confident the test suite covers all of the initial issue though. I think I'm still in favor of leaving the swap in place as a fallback for anything we're missing.",
      "comment_id": 763565145,
      "user": "nateprewitt",
      "created_at": "2021-12-07T01:46:39Z",
      "url": "https://github.com/psf/requests/pull/5917#discussion_r763565145"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5917,
      "file_path": "requests/utils.py",
      "line": 974,
      "side": "RIGHT",
      "diff_hunk": "@@ -932,15 +933,22 @@ def prepend_scheme_if_needed(url, new_scheme):\n \n     :rtype: str\n     \"\"\"\n-    scheme, netloc, path, params, query, fragment = urlparse(url, new_scheme)\n+    parsed = parse_url(url)\n+    scheme, auth, host, port, path, query, fragment = parsed\n \n-    # urlparse is a finicky beast, and sometimes decides that there isn't a\n-    # netloc present. Assume that it's being over-cautious, and switch netloc\n-    # and path if urlparse decided there was no netloc.\n+    # urlparse and parse_url determine that there isn't a netloc present in some\n+    # urls. We've chosen to assume parsing is being over-cautious, and switch\n+    # the netloc and path. This is maintained for backwards compatibility.\n+    netloc = parsed.netloc",
      "comment": "@sethmlarson I've reworded things to be a bit clearer.",
      "comment_id": 776146587,
      "user": "nateprewitt",
      "created_at": "2021-12-29T04:13:20Z",
      "url": "https://github.com/psf/requests/pull/5917#discussion_r776146587"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5894,
      "file_path": "requests/sessions.py",
      "line": 636,
      "side": "LEFT",
      "diff_hunk": "@@ -633,7 +633,8 @@ def send(self, request, **kwargs):\n         kwargs.setdefault('stream', self.stream)\n         kwargs.setdefault('verify', self.verify)\n         kwargs.setdefault('cert', self.cert)\n-        kwargs.setdefault('proxies', self.rebuild_proxies(request, self.proxies))",
      "comment": "@sigmavirus24 this change is needed because without it we are calling to re-build proxies from the environment even when proxies have been set/provided. \r\n\r\nIn one use test case I have setup - the time to \"retrieve\" a cached connection (using the cache control adapter) 10,000 times goes from 9.741 seconds and 25212240 function calls to 9902240 function calls & 6.169 seconds after applying this change. ",
      "comment_id": 678786441,
      "user": "dbaxa",
      "created_at": "2021-07-29T02:59:31Z",
      "url": "https://github.com/psf/requests/pull/5894#discussion_r678786441"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5894,
      "file_path": "requests/sessions.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -289,7 +289,9 @@ def rebuild_proxies(self, prepared_request, proxies):\n         new_proxies = proxies.copy()\n         no_proxy = proxies.get('no_proxy')\n \n-        bypass_proxy = should_bypass_proxies(url, no_proxy=no_proxy)\n+        bypass_proxy = False\n+        if self.trust_env:",
      "comment": "@omermizr  / @sigmavirus24 / @nateprewitt   - this change fixes the performance regression of #5891 but does not fix #5888. IMHO fixing #5888 is something that you might do by checking if a proxy has been selected as if one has not been selected you likely would not want to leak proxy credentials. Of course it might be easier to suggest that we do not explicitly support setting `Proxy-Authorization` as a header and that users must specify proxy credentials in the proxy url.",
      "comment_id": 679537744,
      "user": "dbaxa",
      "created_at": "2021-07-29T22:59:55Z",
      "url": "https://github.com/psf/requests/pull/5894#discussion_r679537744"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5894,
      "file_path": "requests/sessions.py",
      "line": 295,
      "side": "RIGHT",
      "diff_hunk": "@@ -289,7 +289,9 @@ def rebuild_proxies(self, prepared_request, proxies):\n         new_proxies = proxies.copy()\n         no_proxy = proxies.get('no_proxy')\n \n-        bypass_proxy = should_bypass_proxies(url, no_proxy=no_proxy)\n+        bypass_proxy = False\n+        if self.trust_env:\n+            bypass_proxy = should_bypass_proxies(url, no_proxy=no_proxy)\n         if self.trust_env and not bypass_proxy:",
      "comment": "Looking at the new change, I don't have an issue with the general idea. This seems like a performance improvement for rebuild_proxies, regardless of the outcome for #5888. Stylistically, I'd like to simplify the logic here a bit more though. Something along the lines of this would be preferred:\r\n\r\n```suggestion\r\n        if self.trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):\r\n```\r\n\r\n@omermizr I don't want to volunteer you but if you have a moment, would you mind confirming this PR resolves your issue in #5891?",
      "comment_id": 687377459,
      "user": "nateprewitt",
      "created_at": "2021-08-12T04:24:39Z",
      "url": "https://github.com/psf/requests/pull/5894#discussion_r687377459"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5894,
      "file_path": "requests/sessions.py",
      "line": 295,
      "side": "RIGHT",
      "diff_hunk": "@@ -289,7 +289,9 @@ def rebuild_proxies(self, prepared_request, proxies):\n         new_proxies = proxies.copy()\n         no_proxy = proxies.get('no_proxy')\n \n-        bypass_proxy = should_bypass_proxies(url, no_proxy=no_proxy)\n+        bypass_proxy = False\n+        if self.trust_env:\n+            bypass_proxy = should_bypass_proxies(url, no_proxy=no_proxy)\n         if self.trust_env and not bypass_proxy:",
      "comment": "@nateprewitt While this is probably a good change, unless I'm missing something it doesn't resolve the issue - when 'trust_env' is set to True (which is the default), this changes nothing. \nMore specifically to my use case - I have no control over how the third party package I'm using creates the session, and it uses the default value for 'trust_env' (like most usages). ",
      "comment_id": 689175728,
      "user": "omermizr",
      "created_at": "2021-08-16T01:02:39Z",
      "url": "https://github.com/psf/requests/pull/5894#discussion_r689175728"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5391,
      "file_path": "requests/adapters.py",
      "line": 463,
      "side": "RIGHT",
      "diff_hunk": "@@ -459,7 +459,8 @@ def send(self, request, stream=False, timeout=None, verify=True, cert=None, prox\n                 try:\n                     low_conn.putrequest(request.method,\n                                         url,\n-                                        skip_accept_encoding=True)\n+                                        skip_accept_encoding=True,\n+                                        skip_host='Host' in request.headers)",
      "comment": "That's good, this appears to be the same way that the same situation is handled in the urllib3 code itself: https://github.com/urllib3/urllib3/blob/74d6be1ab66cef44c0f479c24b0fc1756a8fe4e9/src/urllib3/connection.py#L243-L246",
      "comment_id": 523465475,
      "user": "AaronRobson",
      "created_at": "2020-11-14T21:30:07Z",
      "url": "https://github.com/psf/requests/pull/5391#discussion_r523465475"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5924,
      "file_path": "requests/sessions.py",
      "line": 623,
      "side": "RIGHT",
      "diff_hunk": "@@ -633,7 +620,10 @@ def send(self, request, **kwargs):\n         kwargs.setdefault('stream', self.stream)\n         kwargs.setdefault('verify', self.verify)\n         kwargs.setdefault('cert', self.cert)\n-        kwargs.setdefault('proxies', self.rebuild_proxies(request, self.proxies))\n+        if 'proxies' not in kwargs:",
      "comment": "This change should actually fix the performance regression in most cases (`Session.request` - which I assume is the most common flow - always sets `proxies` on `kwargs`).",
      "comment_id": 701262009,
      "user": "omermizr",
      "created_at": "2021-09-02T16:52:25Z",
      "url": "https://github.com/psf/requests/pull/5924#discussion_r701262009"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5924,
      "file_path": "requests/sessions.py",
      "line": 624,
      "side": "RIGHT",
      "diff_hunk": "@@ -633,7 +620,10 @@ def send(self, request, **kwargs):\n         kwargs.setdefault('stream', self.stream)\n         kwargs.setdefault('verify', self.verify)\n         kwargs.setdefault('cert', self.cert)\n-        kwargs.setdefault('proxies', self.rebuild_proxies(request, self.proxies))\n+        if 'proxies' not in kwargs:\n+            kwargs['proxies'] = resolve_proxies(",
      "comment": "So now we're:\r\n1. No longer stripping the proxy-auth header. Sounds right to me.\r\n2. No longer setting the proxy-auth header at all. Is this the desired behavior? What if someone uses a proxy and passes the username + password in the url? (though I'm not sure if that flow is supported or not)",
      "comment_id": 701265200,
      "user": "omermizr",
      "created_at": "2021-09-02T16:56:54Z",
      "url": "https://github.com/psf/requests/pull/5924#discussion_r701265200"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5924,
      "file_path": "requests/utils.py",
      "line": 850,
      "side": "RIGHT",
      "diff_hunk": "@@ -830,6 +830,34 @@ def select_proxy(url, proxies):\n     return proxy\n \n \n+def resolve_proxies(request, proxies, trust_env=True):\n+    \"\"\"This method takes proxy information from a request and configuration\n+    input to resolve a mapping of target proxies. This will consider settings\n+    such a NO_PROXY to strip proxy configurations.\n+\n+    :param request: Request or PreparedRequest\n+    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n+    :param trust_env: Boolean declaring whether to trust environment configs\n+\n+    :rtype: dict\n+    \"\"\"\n+    proxies = proxies if proxies is not None else {}\n+    url = request.url\n+    scheme = urlparse(url).scheme\n+    no_proxy = proxies.get('no_proxy')\n+    new_proxies = proxies.copy()\n+\n+    bypass_proxy = should_bypass_proxies(url, no_proxy=no_proxy)",
      "comment": "Didn't we want to unify 850 and 851 so we don't call `should_bypass_proxies` if `trust_env` is `False`?",
      "comment_id": 701266063,
      "user": "omermizr",
      "created_at": "2021-09-02T16:58:04Z",
      "url": "https://github.com/psf/requests/pull/5924#discussion_r701266063"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5924,
      "file_path": "requests/sessions.py",
      "line": 624,
      "side": "RIGHT",
      "diff_hunk": "@@ -633,7 +620,10 @@ def send(self, request, **kwargs):\n         kwargs.setdefault('stream', self.stream)\n         kwargs.setdefault('verify', self.verify)\n         kwargs.setdefault('cert', self.cert)\n-        kwargs.setdefault('proxies', self.rebuild_proxies(request, self.proxies))\n+        if 'proxies' not in kwargs:\n+            kwargs['proxies'] = resolve_proxies(",
      "comment": "For 2.) we were never doing that before this change and I don't think that was an intended byproduct. We should still support our normal proxy auth flows that were available prior to #5681.",
      "comment_id": 701276964,
      "user": "nateprewitt",
      "created_at": "2021-09-02T17:13:41Z",
      "url": "https://github.com/psf/requests/pull/5924#discussion_r701276964"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5924,
      "file_path": "requests/utils.py",
      "line": 850,
      "side": "RIGHT",
      "diff_hunk": "@@ -830,6 +830,34 @@ def select_proxy(url, proxies):\n     return proxy\n \n \n+def resolve_proxies(request, proxies, trust_env=True):\n+    \"\"\"This method takes proxy information from a request and configuration\n+    input to resolve a mapping of target proxies. This will consider settings\n+    such a NO_PROXY to strip proxy configurations.\n+\n+    :param request: Request or PreparedRequest\n+    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs\n+    :param trust_env: Boolean declaring whether to trust environment configs\n+\n+    :rtype: dict\n+    \"\"\"\n+    proxies = proxies if proxies is not None else {}\n+    url = request.url\n+    scheme = urlparse(url).scheme\n+    no_proxy = proxies.get('no_proxy')\n+    new_proxies = proxies.copy()\n+\n+    bypass_proxy = should_bypass_proxies(url, no_proxy=no_proxy)",
      "comment": "We do, I was going to have @dbaxa rebase their change onto whatever we merge so they can still have a commit in the repo.",
      "comment_id": 701277868,
      "user": "nateprewitt",
      "created_at": "2021-09-02T17:14:52Z",
      "url": "https://github.com/psf/requests/pull/5924#discussion_r701277868"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5924,
      "file_path": "requests/sessions.py",
      "line": 623,
      "side": "RIGHT",
      "diff_hunk": "@@ -633,7 +620,10 @@ def send(self, request, **kwargs):\n         kwargs.setdefault('stream', self.stream)\n         kwargs.setdefault('verify', self.verify)\n         kwargs.setdefault('cert', self.cert)\n-        kwargs.setdefault('proxies', self.rebuild_proxies(request, self.proxies))\n+        if 'proxies' not in kwargs:",
      "comment": "Yep, I think `proxies` will be the escape hatch when performance is a concern here :)",
      "comment_id": 701278739,
      "user": "nateprewitt",
      "created_at": "2021-09-02T17:16:02Z",
      "url": "https://github.com/psf/requests/pull/5924#discussion_r701278739"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5707,
      "file_path": "requests/utils.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -256,13 +256,28 @@ def extract_zipped_paths(path):\n \n     # we have a valid zip archive and a valid member of that archive\n     tmp = tempfile.gettempdir()\n-    extracted_path = os.path.join(tmp, *member.split('/'))\n+    extracted_path = os.path.join(tmp, member.split('/')[-1])\n     if not os.path.exists(extracted_path):\n-        extracted_path = zip_file.extract(member, path=tmp)\n-\n+        # use read + write to avoid the creating nested folders, we only want the file, avoids mkdir racing condition\n+        with atomic_open(extracted_path) as file_handler:\n+            file_handler.write(zip_file.read(member))\n     return extracted_path\n \n \n+@contextlib.contextmanager\n+def atomic_open(filename):",
      "comment": "Just to handle a further race condition that can happen between opening and writing the file.",
      "comment_id": 548761782,
      "user": "gaborbernat",
      "created_at": "2020-12-24T23:18:20Z",
      "url": "https://github.com/psf/requests/pull/5707#discussion_r548761782"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/compat.py",
      "line": 34,
      "side": "LEFT",
      "diff_hunk": "@@ -25,10 +26,6 @@\n #: Python 3.x?\n is_py3 = (_ver[0] == 3)\n \n-try:\n-    import simplejson as json\n-except ImportError:\n-    import json",
      "comment": "This is backwards incompatible and needs to be reverted",
      "comment_id": 664037480,
      "user": "sigmavirus24",
      "created_at": "2021-07-05T16:19:59Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r664037480"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +35,10 @@ def __init__(self, *args, **kwargs):\n         super(RequestException, self).__init__(*args, **kwargs)\n \n \n+class JSONDecodeError(StandardJSONDecodeError, SimpleJSONDecodeError):\n+    \"\"\"Couldn't decode the text into json\"\"\"\n+\n+\n class InvalidJSONError(RequestException):",
      "comment": "I forgot we had this exception, where do we use it? Should we sub-class this in `JSONDecodeError` as well?",
      "comment_id": 664037858,
      "user": "sigmavirus24",
      "created_at": "2021-07-05T16:20:44Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r664037858"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/models.py",
      "line": 893,
      "side": "RIGHT",
      "diff_hunk": "@@ -882,12 +890,8 @@ def json(self, **kwargs):\n         r\"\"\"Returns the json-encoded content of a response, if any.\n \n         :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.\n-        :raises simplejson.JSONDecodeError: If the response body does not\n-            contain valid json and simplejson is installed.\n-        :raises json.JSONDecodeError: If the response body does not contain\n-            valid json and simplejson is not installed on Python 3.\n-        :raises ValueError: If the response body does not contain valid\n-            json and simplejson is not installed on Python 2.        \n+        :raises requests.JSONDecodeError: If the response body does not",
      "comment": "Please document this as `requests.exceptions.JSONDecodeError`. Eventually I desperately want to stop importing every exception class into `requests/__init__.py`",
      "comment_id": 664039064,
      "user": "sigmavirus24",
      "created_at": "2021-07-05T16:23:21Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r664039064"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/models.py",
      "line": 920,
      "side": "RIGHT",
      "diff_hunk": "@@ -907,7 +911,13 @@ def json(self, **kwargs):\n                     # and the server didn't bother to tell us what codec *was*\n                     # used.\n                     pass\n-        return complexjson.loads(self.text, **kwargs)\n+\n+        try:\n+            return json.loads(self.text, **kwargs)\n+        except json.JSONDecodeError as e:\n+            # Catch JSON-related errors and raise as requests.JSONDecodeError\n+            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n+            raise JSONDecodeError(e.msg, e.doc, e.pos)",
      "comment": "We should probably preserve the original exception instance in this as well and proxy attributes down to it. That way folks can find the original exception. I'm not certain `simplejson` and `json` have the same exception attributes with the same meaning",
      "comment_id": 664039537,
      "user": "sigmavirus24",
      "created_at": "2021-07-05T16:24:32Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r664039537"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +35,10 @@ def __init__(self, *args, **kwargs):\n         super(RequestException, self).__init__(*args, **kwargs)\n \n \n+class JSONDecodeError(StandardJSONDecodeError, SimpleJSONDecodeError):\n+    \"\"\"Couldn't decode the text into json\"\"\"\n+\n+\n class InvalidJSONError(RequestException):",
      "comment": "I added this exception to sub-class both `JSONDecodeError`s",
      "comment_id": 664043187,
      "user": "steveberdy",
      "created_at": "2021-07-05T16:32:45Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r664043187"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +35,10 @@ def __init__(self, *args, **kwargs):\n         super(RequestException, self).__init__(*args, **kwargs)\n \n \n+class JSONDecodeError(StandardJSONDecodeError, SimpleJSONDecodeError):\n+    \"\"\"Couldn't decode the text into json\"\"\"\n+\n+\n class InvalidJSONError(RequestException):",
      "comment": "I'm talking about the `InvalidJSONError` exception here (the line I commented on)",
      "comment_id": 664949709,
      "user": "sigmavirus24",
      "created_at": "2021-07-07T00:02:39Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r664949709"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/compat.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,6 +33,7 @@\n except ImportError:\n     import json\n \n+",
      "comment": "These spacing changes aren't really related to the current PR, can we remove them.",
      "comment_id": 667094313,
      "user": "nateprewitt",
      "created_at": "2021-07-09T17:05:30Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r667094313"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +35,10 @@ def __init__(self, *args, **kwargs):\n         super(RequestException, self).__init__(*args, **kwargs)\n \n \n+class JSONDecodeError(StandardJSONDecodeError, SimpleJSONDecodeError):",
      "comment": "Our custom exceptions in Requests should ideally fall under a catch-all parent exception, `RequestException`. That allows users to catch everything thrown by Requests.",
      "comment_id": 667095839,
      "user": "nateprewitt",
      "created_at": "2021-07-09T17:08:32Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r667095839"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +35,10 @@ def __init__(self, *args, **kwargs):\n         super(RequestException, self).__init__(*args, **kwargs)\n \n \n+class JSONDecodeError(StandardJSONDecodeError, SimpleJSONDecodeError):\n+    \"\"\"Couldn't decode the text into json\"\"\"\n+\n+\n class InvalidJSONError(RequestException):",
      "comment": "I think we're still waiting on a response here, @steveberdy.",
      "comment_id": 667096117,
      "user": "nateprewitt",
      "created_at": "2021-07-09T17:09:04Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r667096117"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/models.py",
      "line": 920,
      "side": "RIGHT",
      "diff_hunk": "@@ -907,7 +911,13 @@ def json(self, **kwargs):\n                     # and the server didn't bother to tell us what codec *was*\n                     # used.\n                     pass\n-        return complexjson.loads(self.text, **kwargs)\n+\n+        try:\n+            return json.loads(self.text, **kwargs)\n+        except json.JSONDecodeError as e:\n+            # Catch JSON-related errors and raise as requests.JSONDecodeError\n+            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n+            raise JSONDecodeError(e.msg, e.doc, e.pos)",
      "comment": "I'm not sure I'm following how this will work in the Python 2 `json` case. Where is `ValueError` being handled?",
      "comment_id": 667104578,
      "user": "nateprewitt",
      "created_at": "2021-07-09T17:24:48Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r667104578"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/models.py",
      "line": 920,
      "side": "RIGHT",
      "diff_hunk": "@@ -907,7 +911,13 @@ def json(self, **kwargs):\n                     # and the server didn't bother to tell us what codec *was*\n                     # used.\n                     pass\n-        return complexjson.loads(self.text, **kwargs)\n+\n+        try:\n+            return json.loads(self.text, **kwargs)\n+        except json.JSONDecodeError as e:\n+            # Catch JSON-related errors and raise as requests.JSONDecodeError\n+            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n+            raise JSONDecodeError(e.msg, e.doc, e.pos)",
      "comment": "https://github.com/psf/requests/pull/5856/checks?check_run_id=3031103164 Yeah, this is broken. We need to be able to handle this a different way.",
      "comment_id": 667105634,
      "user": "nateprewitt",
      "created_at": "2021-07-09T17:26:43Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r667105634"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/models.py",
      "line": 920,
      "side": "RIGHT",
      "diff_hunk": "@@ -907,7 +911,13 @@ def json(self, **kwargs):\n                     # and the server didn't bother to tell us what codec *was*\n                     # used.\n                     pass\n-        return complexjson.loads(self.text, **kwargs)\n+\n+        try:\n+            return json.loads(self.text, **kwargs)\n+        except json.JSONDecodeError as e:\n+            # Catch JSON-related errors and raise as requests.JSONDecodeError\n+            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n+            raise JSONDecodeError(e.msg, e.doc, e.pos)",
      "comment": "I see your last comment was made outside of this thread, @steveberdy. To clarify, while `json.JSONDecodeError` does inherit from `ValueError`, it's not going to work in this case. The exception doesn't exist in Python 2, so we fall over with an attribute error when handling the exception. You'll need to take another approach to handle this.",
      "comment_id": 667121799,
      "user": "nateprewitt",
      "created_at": "2021-07-09T17:56:48Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r667121799"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +35,10 @@ def __init__(self, *args, **kwargs):\n         super(RequestException, self).__init__(*args, **kwargs)\n \n \n+class JSONDecodeError(StandardJSONDecodeError, SimpleJSONDecodeError):\n+    \"\"\"Couldn't decode the text into json\"\"\"\n+\n+\n class InvalidJSONError(RequestException):",
      "comment": "Yes, I can subclass that in `JSONDecodeError` as well.",
      "comment_id": 668015646,
      "user": "steveberdy",
      "created_at": "2021-07-12T15:07:16Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r668015646"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/models.py",
      "line": 918,
      "side": "RIGHT",
      "diff_hunk": "@@ -907,7 +905,16 @@ def json(self, **kwargs):\n                     # and the server didn't bother to tell us what codec *was*\n                     # used.\n                     pass\n-        return complexjson.loads(self.text, **kwargs)\n+\n+        try:\n+            return complexjson.loads(self.text, **kwargs)\n+        except JSONDecodeError as e:\n+            # Catch JSON-related errors and raise as requests.JSONDecodeError\n+            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError\n+            if is_py2: # e is a ValueError\n+                raise RequestsJSONDecodeError()\n+            else:\n+                raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)\n ",
      "comment": "Giving the user 0 useful information is unacceptable. Why can't we use `e.message` there?\r\n\r\n```py\r\nPython 2.7.18 (default, May 19 2021, 00:00:00)\r\n[GCC 11.1.1 20210428 (Red Hat 11.1.1-1)] on linux2\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import json\r\n>>> try:\r\n...   json.loads(\"foo\")\r\n... except ValueError as ve:\r\n...   pass\r\n...\r\n>>> dir(ve)\r\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__getitem__', '__getslice__', '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__unicode__', 'args', 'message']\r\n>>> ve.message\r\n'No JSON object could be decoded'\r\n>>> ve.args\r\n('No JSON object could be decoded',)\r\n>>>\r\n```",
      "comment_id": 669195075,
      "user": "sigmavirus24",
      "created_at": "2021-07-14T00:25:15Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r669195075"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/compat.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,8 +28,10 @@\n #: Python 3.x?\n is_py3 = (_ver[0] == 3)\n \n+has_simplejson = False",
      "comment": "It doesn't look like we use this anywhere except to declare the exceptions. We're already setting either dependency to be imported under the `json` namespace. Can we not just do `from json import JSONDecodeError` under the py3 section and have it automatically resolve? Perhaps adding a short comment above the import saying it's using simplejson or json depending on what was resolved?",
      "comment_id": 669741494,
      "user": "nateprewitt",
      "created_at": "2021-07-14T15:49:47Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r669741494"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,6 +8,16 @@\n \"\"\"\n from urllib3.exceptions import HTTPError as BaseHTTPError\n \n+try:",
      "comment": "We have logic for which simplejson/json exceptions we're using spread across a few places now. Is there a compelling reason not to simply import JSONDecodeError from compat since it's already been resolved and supplying it as a single parent class?",
      "comment_id": 671444604,
      "user": "nateprewitt",
      "created_at": "2021-07-16T18:18:17Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r671444604"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,6 +8,16 @@\n \"\"\"\n from urllib3.exceptions import HTTPError as BaseHTTPError\n \n+try:",
      "comment": "@nateprewitt We want to know which properties the `JSONDecodeError` has, since it may have different properties depending on compatibility. That requires an extra check on import.",
      "comment_id": 673240914,
      "user": "steveberdy",
      "created_at": "2021-07-20T15:40:55Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r673240914"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,6 +8,16 @@\n \"\"\"\n from urllib3.exceptions import HTTPError as BaseHTTPError\n \n+try:",
      "comment": "@steveberdy I'm not sure I'm following, could you clarify which properties you're referring to? We have 3 parent classes that we'd ever use in our environment, `json.JSONDecodeError`, `simplejson.JSONDecodeError`, and `ValueError`. Only one of those can be relevant in a given execution of Requests.\r\n\r\nWhat I was asking about was if we did:\r\n\r\n```python\r\nfrom .compat import JSONDecodeError as CompatJSONDecodeError\r\n\r\n[...]\r\n\r\nclass JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):\r\n```\r\n\r\nWe've already resolved these values once in compat, so I wanted to know why we're doing it again here.",
      "comment_id": 673356731,
      "user": "nateprewitt",
      "created_at": "2021-07-20T17:53:17Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r673356731"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,6 +8,16 @@\n \"\"\"\n from urllib3.exceptions import HTTPError as BaseHTTPError\n \n+try:",
      "comment": "@nateprewitt For Python 3, in the `compat.py` file itself, reference to the `json` package directly, whether aliased as `json` or actually the `json` package itself, would always look for the `json` package rather than whatever was aliased as it. So, just in the `compat.py` file itself, I used the check. From all other scripts that have `from .compat import json`, however, it works as expected.",
      "comment_id": 673381345,
      "user": "steveberdy",
      "created_at": "2021-07-20T18:30:36Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r673381345"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5856,
      "file_path": "requests/exceptions.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,6 +8,16 @@\n \"\"\"\n from urllib3.exceptions import HTTPError as BaseHTTPError\n \n+try:",
      "comment": "Hey @steveberdy, I think there may still be some confusion. If you open the _Files changed_ tab, you should be able to see the full context of this thread. I've written out the [full diff](https://github.com/nateprewitt/requests/commit/665cf30861fb356d84103808e240d6940e8ff3d6) from the suggestion above to minimize ambiguity. You should find this passes the test suite without issue, so please let me know if there were other concerns you had.\r\n\r\nWhile we're here it would also be good to add a test exercising this change. Something to the effect of the example below should be sufficient:\r\n\r\n```\r\ndef test_json_decode_compatibility(self, httpbin):\r\n    r = requests.get(httpbin('bytes/20'))\r\n    with pytest.raises(requests.exceptions.JSONDecodeError):\r\n        r.json()\r\n```\r\n\r\nThis won't cover simplejson in our general test suite, but I've done a one off run to ensure that's working.",
      "comment_id": 675272659,
      "user": "nateprewitt",
      "created_at": "2021-07-23T02:30:46Z",
      "url": "https://github.com/psf/requests/pull/5856#discussion_r675272659"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5851,
      "file_path": "requests/utils.py",
      "line": 248,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,6 +245,9 @@ def extract_zipped_paths(path):\n     archive, member = os.path.split(path)\n     while archive and not os.path.exists(archive):\n         archive, prefix = os.path.split(archive)\n+        if not prefix:",
      "comment": "This explains why, but the code isn't clear as to what's happening or why this fixes the infinite loop. For example, a far superior comment might be:\r\n\r\n```\r\n# If we don't check for an empty prefix after the split (in other words, archive = / before and after the split), we _can_ end up in an infinite loop on a rare corner case affecting a small number of users\r\n```\r\n\r\nThis comment explains the conditions, why we care (it affects users), and the risk to making a change (if we break this again, we may not find out about it quickly)",
      "comment_id": 664947915,
      "user": "sigmavirus24",
      "created_at": "2021-07-06T23:56:55Z",
      "url": "https://github.com/psf/requests/pull/5851#discussion_r664947915"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5851,
      "file_path": "requests/utils.py",
      "line": 248,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,6 +245,9 @@ def extract_zipped_paths(path):\n     archive, member = os.path.split(path)\n     while archive and not os.path.exists(archive):\n         archive, prefix = os.path.split(archive)\n+        if not prefix:",
      "comment": "Thanks for the feedback, I've updated the comment. ",
      "comment_id": 681158168,
      "user": "tl-hbk",
      "created_at": "2021-08-02T17:45:39Z",
      "url": "https://github.com/psf/requests/pull/5851#discussion_r681158168"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5797,
      "file_path": "setup.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,7 +41,8 @@ def run_tests(self):\n packages = ['requests']\n \n requires = [\n-    'chardet>=3.0.2,<5',\n+    'charset_normalizer>=1.3.9,<2; python_version >= \"3\"',",
      "comment": "```suggestion\r\n    'charset_normalizer~=1.4.0,<2; python_version >= \"3\"',\r\n```",
      "comment_id": 637236978,
      "user": "potiuk",
      "created_at": "2021-05-21T21:16:35Z",
      "url": "https://github.com/psf/requests/pull/5797#discussion_r637236978"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5797,
      "file_path": "setup.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,7 +41,8 @@ def run_tests(self):\n packages = ['requests']\n \n requires = [\n-    'chardet>=3.0.2,<5',\n+    'charset_normalizer~=1.4.0,<2; python_version >= \"3\"',",
      "comment": "```suggestion\r\n    'charset_normalizer~=1.4.0; python_version >= \"3\"',\r\n```",
      "comment_id": 637237986,
      "user": "potiuk",
      "created_at": "2021-05-21T21:17:59Z",
      "url": "https://github.com/psf/requests/pull/5797#discussion_r637237986"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5797,
      "file_path": "setup.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,6 +104,7 @@ def run_tests(self):\n         'security': ['pyOpenSSL >= 0.14', 'cryptography>=1.3.4'],\n         'socks': ['PySocks>=1.5.6, !=1.5.7'],\n         'socks:sys_platform == \"win32\" and python_version == \"2.7\"': ['win_inet_pton'],\n+        'lgpl': ['chardet>=3.0.2,<5']",
      "comment": "This seems somewhat disingenuous. For one thing, it's not the _only_ way to get `lgpl` dependencies. For another, it really exists to just force `chardet` to be installed on py3 so should be named something more like `use_chardet_on_py3`",
      "comment_id": 641068555,
      "user": "sigmavirus24",
      "created_at": "2021-05-28T00:15:43Z",
      "url": "https://github.com/psf/requests/pull/5797#discussion_r641068555"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5797,
      "file_path": "requests/__init__.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,12 +70,19 @@ def check_compatibility(urllib3_version, chardet_version):\n     assert minor >= 21\n     assert minor <= 26\n \n-    # Check chardet for compatibility.\n-    major, minor, patch = chardet_version.split('.')[:3]\n-    major, minor, patch = int(major), int(minor), int(patch)\n-    # chardet >= 3.0.2, < 5.0.0\n-    assert (3, 0, 2) <= (major, minor, patch) < (5, 0, 0)\n-\n+    # Check charset_normalizer for compatibility.\n+    if chardet_version:\n+        major, minor, patch = chardet_version.split('.')[:3]\n+        major, minor, patch = int(major), int(minor), int(patch)\n+        # chardet_version >= 3.0.2, < 5.0.0\n+        assert (3, 0, 2) <= (major, minor, patch) < (5, 0, 0)\n+    elif charset_normalizer_version:\n+        major, minor, patch = charset_normalizer_version.split('.')[:3]\n+        major, minor, patch = int(major), int(minor), int(patch)\n+        # charset_normalizer >= 1.3.9, < 2.0.0\n+        assert (1, 3, 9) <= (major, minor, patch) < (2, 0, 0)",
      "comment": "Changed to 1.4.1 to account for logging fix just added by @ousret ",
      "comment_id": 641297465,
      "user": "potiuk",
      "created_at": "2021-05-28T06:22:26Z",
      "url": "https://github.com/psf/requests/pull/5797#discussion_r641297465"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5797,
      "file_path": "requests/__init__.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,12 +70,19 @@ def check_compatibility(urllib3_version, chardet_version):\n     assert minor >= 21\n     assert minor <= 26\n \n-    # Check chardet for compatibility.\n-    major, minor, patch = chardet_version.split('.')[:3]\n-    major, minor, patch = int(major), int(minor), int(patch)\n-    # chardet >= 3.0.2, < 5.0.0\n-    assert (3, 0, 2) <= (major, minor, patch) < (5, 0, 0)\n-\n+    # Check charset_normalizer for compatibility.\n+    if chardet_version:\n+        major, minor, patch = chardet_version.split('.')[:3]\n+        major, minor, patch = int(major), int(minor), int(patch)\n+        # chardet_version >= 3.0.2, < 5.0.0\n+        assert (3, 0, 2) <= (major, minor, patch) < (5, 0, 0)\n+    elif charset_normalizer_version:\n+        major, minor, patch = charset_normalizer_version.split('.')[:3]\n+        major, minor, patch = int(major), int(minor), int(patch)\n+        # charset_normalizer >= 1.3.9, < 2.0.0",
      "comment": "```suggestion\r\n        # charset_normalizer >= 1.4.1, < 2.0.0\r\n```",
      "comment_id": 641438297,
      "user": "mik-laj",
      "created_at": "2021-05-28T10:16:17Z",
      "url": "https://github.com/psf/requests/pull/5797#discussion_r641438297"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5797,
      "file_path": "requests/__init__.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,12 +70,19 @@ def check_compatibility(urllib3_version, chardet_version):\n     assert minor >= 21\n     assert minor <= 26\n \n-    # Check chardet for compatibility.\n-    major, minor, patch = chardet_version.split('.')[:3]\n-    major, minor, patch = int(major), int(minor), int(patch)\n-    # chardet >= 3.0.2, < 5.0.0\n-    assert (3, 0, 2) <= (major, minor, patch) < (5, 0, 0)\n-\n+    # Check charset_normalizer for compatibility.\n+    if chardet_version:\n+        major, minor, patch = chardet_version.split('.')[:3]\n+        major, minor, patch = int(major), int(minor), int(patch)\n+        # chardet_version >= 3.0.2, < 5.0.0\n+        assert (3, 0, 2) <= (major, minor, patch) < (5, 0, 0)\n+    elif charset_normalizer_version:\n+        major, minor, patch = charset_normalizer_version.split('.')[:3]\n+        major, minor, patch = int(major), int(minor), int(patch)\n+        # charset_normalizer >= 1.4.1, < 2.0.0\n+        assert (1, 4, 1) <= (major, minor, patch) < (2, 0, 0)",
      "comment": "If charset_normalizer v2.0.0 is out do we need to update this to be >2?",
      "comment_id": 664014262,
      "user": "sethmlarson",
      "created_at": "2021-07-05T15:34:07Z",
      "url": "https://github.com/psf/requests/pull/5797#discussion_r664014262"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5797,
      "file_path": "setup.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,7 +41,8 @@ def run_tests(self):\n packages = ['requests']\n \n requires = [\n-    'chardet>=3.0.2,<5',\n+    'charset_normalizer~=1.4.1; python_version >= \"3\"',",
      "comment": "We haven't tested v2. I'd rather get something imperfect out than something perfect. Today's literally the only time I've had to review anything",
      "comment_id": 664015764,
      "user": "sigmavirus24",
      "created_at": "2021-07-05T15:36:53Z",
      "url": "https://github.com/psf/requests/pull/5797#discussion_r664015764"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5797,
      "file_path": "setup.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,7 +41,8 @@ def run_tests(self):\n packages = ['requests']\n \n requires = [\n-    'chardet>=3.0.2,<5',\n+    'charset_normalizer~=1.4.1; python_version >= \"3\"',",
      "comment": "Makes sense, I/we can handle the upgrade in a follow-up PR.",
      "comment_id": 664016609,
      "user": "sethmlarson",
      "created_at": "2021-07-05T15:38:30Z",
      "url": "https://github.com/psf/requests/pull/5797#discussion_r664016609"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5783,
      "file_path": "requests/utils.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -820,7 +821,7 @@ def default_headers():\n     \"\"\"\n     return CaseInsensitiveDict({\n         'User-Agent': default_user_agent(),\n-        'Accept-Encoding': ', '.join(('gzip', 'deflate')),\n+        'Accept-Encoding': make_headers(accept_encoding=True)[\"accept-encoding\"],",
      "comment": "Should we generate this header once and store the result so it doesn't need to be called every time? The value is determined by imports so shouldn't be changing often.",
      "comment_id": 636462152,
      "user": "sethmlarson",
      "created_at": "2021-05-20T20:52:06Z",
      "url": "https://github.com/psf/requests/pull/5783#discussion_r636462152"
    },
    {
      "repo": "psf/requests",
      "pr_number": 5783,
      "file_path": "requests/utils.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -820,7 +821,7 @@ def default_headers():\n     \"\"\"\n     return CaseInsensitiveDict({\n         'User-Agent': default_user_agent(),\n-        'Accept-Encoding': ', '.join(('gzip', 'deflate')),\n+        'Accept-Encoding': make_headers(accept_encoding=True)[\"accept-encoding\"],",
      "comment": "This optimization makes sense.  I kindly ask you to implement it in the way, you think fits best.",
      "comment_id": 636746931,
      "user": "dilyanpalauzov",
      "created_at": "2021-05-21T08:45:36Z",
      "url": "https://github.com/psf/requests/pull/5783#discussion_r636746931"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1660,
      "file_path": "requests/cookies.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,7 +45,14 @@ def get_origin_req_host(self):\n         return self.get_host()\n \n     def get_full_url(self):\n-        return self._r.url\n+        if not self._r.headers.get('Host'):\n+            return self._r.url\n+        host = self._r.headers['Host']\n+        parsed = urlparse(self._r.url)\n+        return urlunparse([\n+            parsed.scheme, host, parsed.path, parsed.params, parsed.query,\n+            parsed.fragment\n+        ])",
      "comment": "Might be a good idea to comment this so we can remember why we did this weird thing. =)\n",
      "comment_id": 6863250,
      "user": "Lukasa",
      "created_at": "2013-10-09T17:34:25Z",
      "url": "https://github.com/psf/requests/pull/1660#discussion_r6863250"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1660,
      "file_path": "requests/cookies.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,7 +45,14 @@ def get_origin_req_host(self):\n         return self.get_host()\n \n     def get_full_url(self):\n-        return self._r.url\n+        if not self._r.headers.get('Host'):\n+            return self._r.url\n+        host = self._r.headers['Host']\n+        parsed = urlparse(self._r.url)\n+        return urlunparse([\n+            parsed.scheme, host, parsed.path, parsed.params, parsed.query,\n+            parsed.fragment\n+        ])",
      "comment": "LOL If you don't write Ruby and your code isn't self-documenting. ;)\n",
      "comment_id": 6865822,
      "user": "sigmavirus24",
      "created_at": "2013-10-09T18:44:50Z",
      "url": "https://github.com/psf/requests/pull/1660#discussion_r6865822"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1660,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,7 +45,18 @@ def get_origin_req_host(self):\n         return self.get_host()\n \n     def get_full_url(self):\n-        return self._r.url\n+        # Only return the response's URL if the user hadn't set the Host\n+        # header\n+        if not self._r.headers.get('Host'):\n+            return self._r.url\n+        # If they did set it, retrieve it and reconstruct the expected doain",
      "comment": "Psh. Who cares about proper spelling? :wink: \n\nSeriously though, thanks! :cake:\n",
      "comment_id": 6930211,
      "user": "sigmavirus24",
      "created_at": "2013-10-12T01:41:34Z",
      "url": "https://github.com/psf/requests/pull/1660#discussion_r6930211"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "We need the set the Proxy-Authorization header regardless of HTTP or HTTPS. Is there a reason urllib3 can't do it? Because if there is, we'll need to fix it up in Requests.\n",
      "comment_id": 5728742,
      "user": "Lukasa",
      "created_at": "2013-08-13T05:52:06Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5728742"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "Appropriate `Proxy-Authorization` header could be set in `proxy_headers` keyword argument for `proxy_from_url()`. I don't really think that proxy authentication belongs to urllib3, so I suggest to wrap `proxy_from_url` in requests with something like:\n\n``` python\nfrom urlparse import urlparse\nimport base64\nfrom .packages.urllib3.poolmanager import  proxy_from_url\n\ndef authenticated_proxy_from_url(url, **kw):\n    parsed_url = urlparse(url)\n    if '@' in parsed_url.netloc:\n        credentials = parsed_url.netloc.split('@')[0]\n        base64string = base64.encodestring(credentials)[:-1]\n        if 'proxy_headers' not in kw:\n            kw['proxy_headers'] = {}\n        kw['proxy_headers']['Proxy-Authorization'] = 'Basic %s' % base64string\n    return proxy_from_url(url, **kw)\n```\n\nOf course it's the most crude example, there's room for further sophistication, such as authentication methods other than Basic.\n",
      "comment_id": 5757098,
      "user": "stanvit",
      "created_at": "2013-08-14T07:39:43Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5757098"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "Alright, I think we should add this header as part of this PR. We have a `get_auth_from_url` function in `utils.py` which should be used for this. @schlamar you can do this yourself, or if you prefer I can raise a PR against your branch that includes the change.\n",
      "comment_id": 5757723,
      "user": "Lukasa",
      "created_at": "2013-08-14T08:26:22Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5757723"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "To my utter disgust, GitHub seems unwilling to let me open a PR against your fork, @schlamar. Are you happy to accept an emailed patch? =D\n",
      "comment_id": 5758219,
      "user": "Lukasa",
      "created_at": "2013-08-14T08:59:24Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5758219"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "> To my utter disgust, GitHub seems unwilling to let me open a PR against your fork,\n\nAny error message or why doesn't that work?\n\n> Are you happy to accept an emailed patch? =D\n\nI can just pull from your branch :) I guess https://github.com/Lukasa/requests/commits/https-proxy-2.0, right?\n",
      "comment_id": 5760175,
      "user": "schlamar",
      "created_at": "2013-08-14T10:49:16Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5760175"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "> To my utter disgust, GitHub seems unwilling to let me open a PR against your fork\n\nMhh, I see the issue. Our branches our not comparable for whatever reason... I send an issue report to GitHub.\n",
      "comment_id": 5760232,
      "user": "schlamar",
      "created_at": "2013-08-14T10:52:40Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5760232"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "Yeah, I don't really know how GitHub decides that. There are loads of forks I _can_ open PRs against, just not yours. Very strange. Anyway, I can just email the patch if it's faster.\n",
      "comment_id": 5760248,
      "user": "Lukasa",
      "created_at": "2013-08-14T10:53:27Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5760248"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "I guess \n\n```\n$ git remote add lukasa https://github.com/Lukasa/requests.git\n$ git fetch lukasa\n$ git merge lukasa/https-proxy-2.0\n```\n\nis faster than processing a patch per mail :)\n",
      "comment_id": 5760951,
      "user": "schlamar",
      "created_at": "2013-08-14T11:36:56Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5760951"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "Almost certainly true. I blame GitHub for our pain today. =D\n",
      "comment_id": 5760971,
      "user": "Lukasa",
      "created_at": "2013-08-14T11:37:55Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5760971"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "> That network has a very large number of forks. For performance reasons, we don't show all of the available forked repositories in the Compare drop-down. We're looking into ways of improving this, but in the meantime you can generate a comparison by manually entering the URL. Try this one, for example:\n> \n> https://github.com/Lukasa/requests/compare/schlamar:master...master\n",
      "comment_id": 5772110,
      "user": "schlamar",
      "created_at": "2013-08-14T18:43:14Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5772110"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1515,
      "file_path": "requests/packages/urllib3/poolmanager.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,16 +238,22 @@ def _set_proxy_headers(self, url, headers=None):\n \n         if headers:\n             headers_.update(headers)\n-\n         return headers_\n \n-    def urlopen(self, method, url, **kw):\n+    def urlopen(self, method, url, redirect=True, **kw):\n         \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n-        kw['assert_same_host'] = False\n-        kw['headers'] = self._set_proxy_headers(url, headers=kw.get('headers'))\n-        return self.proxy_pool.urlopen(method, url, **kw)\n+        u = parse_url(url)\n+\n+        if u.scheme == \"http\":\n+            # It's too late to set proxy headers on per-request basis for\n+            # tunnelled HTTPS connections, should use\n+            # constructor's proxy_headers instead.\n+            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',\n+                                                                self.headers))\n+            kw['headers'].update(self.proxy_headers)",
      "comment": "Ah, that makes perfect sense. I could have sworn I tried that, but clearly I didn't. Awesome!\n",
      "comment_id": 5772318,
      "user": "Lukasa",
      "created_at": "2013-08-14T18:49:55Z",
      "url": "https://github.com/psf/requests/pull/1515#discussion_r5772318"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1972,
      "file_path": "requests/structures.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,6 +108,9 @@ def copy(self):\n     def __repr__(self):\n         return '%s(%r)' % (self.__class__.__name__, dict(self.items()))\n \n+    def __str__(self):\n+        return '%s' % (dict(self.items()))",
      "comment": "This could be more simply:\n\n``` python\ndef __str__(self):\n    return str(dict(self.items()))\n```\n\nThis isn't a merge blocker though.\n",
      "comment_id": 10865063,
      "user": "sigmavirus24",
      "created_at": "2014-03-23T00:49:11Z",
      "url": "https://github.com/psf/requests/pull/1972#discussion_r10865063"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1507,
      "file_path": "requests/sessions.py",
      "line": 445,
      "side": "RIGHT",
      "diff_hunk": "@@ -422,7 +441,7 @@ def send(self, request, **kwargs):\n \n         # It's possible that users might accidentally send a Request object.\n         # Guard against that specific failure case.\n-        if getattr(request, 'prepare', None):\n+        if not isinstance(request, PreparedRequest):\n             raise ValueError('You can only send PreparedRequests.')",
      "comment": "Out of curiousity, why doesn't this just call `request.prepare()` (or `self.prepare_request(request)`) instead of failing?\n",
      "comment_id": 5517892,
      "user": "rwe",
      "created_at": "2013-07-31T22:28:45Z",
      "url": "https://github.com/psf/requests/pull/1507#discussion_r5517892"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1507,
      "file_path": "requests/sessions.py",
      "line": 445,
      "side": "RIGHT",
      "diff_hunk": "@@ -422,7 +441,7 @@ def send(self, request, **kwargs):\n \n         # It's possible that users might accidentally send a Request object.\n         # Guard against that specific failure case.\n-        if getattr(request, 'prepare', None):\n+        if not isinstance(request, PreparedRequest):\n             raise ValueError('You can only send PreparedRequests.')",
      "comment": "Why would we raise such a horrible stacktrace when we can raise a much cleaner one and provide the user with an exact message as to why their request cannot be sent?\n",
      "comment_id": 5520356,
      "user": "sigmavirus24",
      "created_at": "2013-08-01T01:06:07Z",
      "url": "https://github.com/psf/requests/pull/1507#discussion_r5520356"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1507,
      "file_path": "requests/sessions.py",
      "line": 445,
      "side": "RIGHT",
      "diff_hunk": "@@ -422,7 +441,7 @@ def send(self, request, **kwargs):\n \n         # It's possible that users might accidentally send a Request object.\n         # Guard against that specific failure case.\n-        if getattr(request, 'prepare', None):\n+        if not isinstance(request, PreparedRequest):\n             raise ValueError('You can only send PreparedRequests.')",
      "comment": "I meant this:\n\n``` python\nif isinstance(request, Request):\n    request = request.prepare()\nelif not isinstance(request, PreparedRequest):\n    raise ValueError('You can only send Requests or PreparedRequests')\n```\n\nThis is outside this PR though; not important.\n",
      "comment_id": 5520474,
      "user": "rwe",
      "created_at": "2013-08-01T01:16:20Z",
      "url": "https://github.com/psf/requests/pull/1507#discussion_r5520474"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1507,
      "file_path": "requests/sessions.py",
      "line": 445,
      "side": "RIGHT",
      "diff_hunk": "@@ -422,7 +441,7 @@ def send(self, request, **kwargs):\n \n         # It's possible that users might accidentally send a Request object.\n         # Guard against that specific failure case.\n-        if getattr(request, 'prepare', None):\n+        if not isinstance(request, PreparedRequest):\n             raise ValueError('You can only send PreparedRequests.')",
      "comment": "Why would we contradict ourselves in the documentation then? We documented the API before we made this change. This was to ensure the API (and its documentation) was correct.\n",
      "comment_id": 5520681,
      "user": "sigmavirus24",
      "created_at": "2013-08-01T01:32:24Z",
      "url": "https://github.com/psf/requests/pull/1507#discussion_r5520681"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1507,
      "file_path": "requests/sessions.py",
      "line": 445,
      "side": "RIGHT",
      "diff_hunk": "@@ -422,7 +441,7 @@ def send(self, request, **kwargs):\n \n         # It's possible that users might accidentally send a Request object.\n         # Guard against that specific failure case.\n-        if getattr(request, 'prepare', None):\n+        if not isinstance(request, PreparedRequest):\n             raise ValueError('You can only send PreparedRequests.')",
      "comment": "I can't seem to find where that restriction is documented. That said, my question was more along the lines of why that restriction was designed in without supporting `Request` objects in the first place. I suspect that most users using `Request` objects only create `PreparedRequest` with directly before calling `Session.send()`, without modifying it, and so that extra hoop just gets in the way of the common case. It seemed like an artificial obstacle.\n\nAvoiding the burden lf supporting multiple argument types was the kind of rationale I expected; because it was documented before it was designed isn't.\n\nHowever: this doesn't affect my use case and I was just trying to understand the design decision better. Thanks for your answer.\n",
      "comment_id": 5520977,
      "user": "rwe",
      "created_at": "2013-08-01T02:01:16Z",
      "url": "https://github.com/psf/requests/pull/1507#discussion_r5520977"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1507,
      "file_path": "requests/sessions.py",
      "line": 445,
      "side": "RIGHT",
      "diff_hunk": "@@ -422,7 +441,7 @@ def send(self, request, **kwargs):\n \n         # It's possible that users might accidentally send a Request object.\n         # Guard against that specific failure case.\n-        if getattr(request, 'prepare', None):\n+        if not isinstance(request, PreparedRequest):\n             raise ValueError('You can only send PreparedRequests.')",
      "comment": "The reasoning, essentially, is that Requests assumes that if you're building `Request` and `PreparedRequest` objects yourself, you are doing _everything_ about preparing them yourself. The `Request` -> `PreparedRequest` flow is basically an advanced use case, when you need to work around or change something Requests does internally.\n\nWhen considered in that light, passing a `Request` to `Session.send()` is likely to be a _mistake_: you have a flow through your code where the `Request` doesn't get prepared prior to sending. That was the purpose of this exception: rather than quietly succeed but potentially do something wrong, we assume that advanced users will just fix the exception.\n",
      "comment_id": 5522899,
      "user": "Lukasa",
      "created_at": "2013-08-01T05:58:43Z",
      "url": "https://github.com/psf/requests/pull/1507#discussion_r5522899"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2088,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -456,31 +460,36 @@ def test_urlencoded_get_query_multivalued_param(self):\n         assert r.url == httpbin('get?test=foo&test=baz')\n \n     def test_different_encodings_dont_break_post(self):\n-        r = requests.post(httpbin('post'),\n-                          data={'stuff': json.dumps({'a': 123})},\n-                          params={'blah': 'asdf1234'},\n-                          files={'file': ('test_requests.py', open(__file__, 'rb'))})\n+        r = requests.post(\n+            httpbin('post'),",
      "comment": "I'd consider these if the first parameter was included on the first line. \n",
      "comment_id": 13596504,
      "user": "kennethreitz",
      "created_at": "2014-06-10T14:32:31Z",
      "url": "https://github.com/psf/requests/pull/2088#discussion_r13596504"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1959,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -410,6 +410,7 @@ def prepare_body(self, data, files):\n             hasattr(data, '__iter__'),\n             not isinstance(data, basestring),\n             not isinstance(data, list),\n+            not isinstance(data, tuple),",
      "comment": "I don't pretend to know who wrote this originally, but all of these should be shortened to:\n\n``` python\nnot isinstance(data, (basestring, list, tuple, dict))\n```\n\n`isinstance` will take a tuple for the second argument and make sure that the class is not one of the classes inside the tuple of classes. Do you mind fixing this up for us @Feng23 ?\n",
      "comment_id": 10606203,
      "user": "sigmavirus24",
      "created_at": "2014-03-14T13:09:05Z",
      "url": "https://github.com/psf/requests/pull/1959#discussion_r10606203"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1959,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -1187,5 +1189,28 @@ def test_stream_timeout(self):\n             assert 'Read timed out' in e.args[0].args[0]\n \n \n+class TestModels:",
      "comment": "This can be rewritten like so:\n\n``` python\n@pytest.fixture\ndef list_of_tuples():\n    return [\n        (('a', 'b'), ('c', 'd')),\n        (('c', 'd'), ('e', 'f')),\n        (('a', 'b'), ('c', 'd'), ('e', 'f')),\n    ]\n\ndef test_data_argument_accepts_tuples(list_of_tuples):\n    \"\"\"\n    Ensure that the data argument will accept tuples of strings\n    and properly encode them.\n    \"\"\"\n    for data_tuple in list_of_tuples:\n        p = PreparedRequest()\n        p.prepare(\n            method='GET',\n            url='http://example.com',\n            data=tuple_data,\n            hooks=default_hooks()\n        )\n        assert p.body == urlencode(tuple_data)\n```\n\nIt doesn't need to be in its own class and you're not really generating random data.\n",
      "comment_id": 10606404,
      "user": "sigmavirus24",
      "created_at": "2014-03-14T13:15:04Z",
      "url": "https://github.com/psf/requests/pull/1959#discussion_r10606404"
    },
    {
      "repo": "psf/requests",
      "pr_number": 729,
      "file_path": "requests/models.py",
      "line": 362,
      "side": "RIGHT",
      "diff_hunk": "@@ -355,6 +355,13 @@ def _encode_files(self, files):\n                 fp = StringIO(fp)\n             fields.update({k: (fn, fp.read())})\n \n+        for field in fields:\n+            if isinstance(fields[field], float):\n+                fields[field] = str(fields[field])\n+            if isinstance(fields[field], list):\n+                newvalue = ', '.join(fields[field])",
      "comment": "This makes serialisation of lists is inconsistent between `application/x-www-form-urlencoded` and `multipart/form-data` requests. \n\nSee https://github.com/kennethreitz/requests/issues/737#issuecomment-7305046 for more details.\n",
      "comment_id": 1252408,
      "user": "jkbrzt",
      "created_at": "2012-07-27T13:25:33Z",
      "url": "https://github.com/psf/requests/pull/729#discussion_r1252408"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1892,
      "file_path": "requests/sessions.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,6 +158,23 @@ def resolve_redirects(self, resp, req, stream=False, timeout=None,\n             prepared_request._cookies.update(self.cookies)\n             prepared_request.prepare_cookies(prepared_request._cookies)\n \n+            # If we get redirected to a new host, we should strip out any\n+            #\u00a0authentication headers.\n+            original_parsed = urlparse(resp.request.url)\n+            redirect_parsed = urlparse(url)\n+\n+            if original_parsed.hostname != redirect_parsed.hostname:",
      "comment": "What about:\n\n``` python\nif (original_parsed.hostname != redirect_parsed.hostname and \n        'Authorization' in headers):\n    del headers['Authorization']\n```\n",
      "comment_id": 9303571,
      "user": "sigmavirus24",
      "created_at": "2014-01-30T12:32:26Z",
      "url": "https://github.com/psf/requests/pull/1892#discussion_r9303571"
    },
    {
      "repo": "psf/requests",
      "pr_number": 819,
      "file_path": "requests/auth.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,34 +75,34 @@ def __call__(self, r):\n         Parameters may be included from the body if the content-type is\n         urlencoded, if no content type is set an educated guess is made.\n         \"\"\"\n-        contenttype = r.headers.get('Content-Type', None)\n+        # split(\";\") because Content-Type may be \"multipart/form-data; boundary=xxxxx\"\n+        contenttype = r.headers.get('Content-Type', '').split(\";\")[0].lower()\n         # extract_params will not give params unless the body is a properly\n         # formatted string, a dictionary or a list of 2-tuples.\n         decoded_body = extract_params(r.data)\n \n-        _ct = (contenttype is None)\n-        _ct = _ct or contenttype.lower() == CONTENT_TYPE_FORM_URLENCODED\n-\n-        if _ct and decoded_body != None:\n-            # extract_params can only check the present r.data and does not know\n-            # of r.files, thus an extra check is performed. We know that\n-            # if files are present the request will not have\n-            # Content-type: x-www-form-urlencoded. We guess it will have\n-            # a mimetype of multipart/form-encoded and if this is not the case\n-            # we assume the correct header will be set later.\n-            if r.files:\n-                # Omit body data in the signing and since it will always\n-                # be empty (cant add paras to body if multipart) and we wish\n-                # to preserve body.\n-                r.headers['Content-Type'] = 'multipart/form-encoded'\n-                r.url, r.headers, _ = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), None, r.headers)\n-            else:\n-                # Normal signing\n-                r.headers['Content-Type'] = 'application/x-www-form-urlencoded'\n-                r.url, r.headers, r.data = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), r.data, r.headers)\n-\n+        # extract_params can only check the present r.data and does not know\n+        # of r.files, thus an extra check is performed. We know that\n+        # if files are present the request will not have\n+        # Content-type: x-www-form-urlencoded. We guess it will have\n+        # a mimetype of multipart/form-encoded and if this is not the case",
      "comment": "\"multipart/form-encoded\" -> \"multipart/form-data\"\n",
      "comment_id": 1472088,
      "user": "idan",
      "created_at": "2012-08-28T07:14:04Z",
      "url": "https://github.com/psf/requests/pull/819#discussion_r1472088"
    },
    {
      "repo": "psf/requests",
      "pr_number": 819,
      "file_path": "requests/auth.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,34 +75,34 @@ def __call__(self, r):\n         Parameters may be included from the body if the content-type is\n         urlencoded, if no content type is set an educated guess is made.\n         \"\"\"\n-        contenttype = r.headers.get('Content-Type', None)\n+        # split(\";\") because Content-Type may be \"multipart/form-data; boundary=xxxxx\"\n+        contenttype = r.headers.get('Content-Type', '').split(\";\")[0].lower()\n         # extract_params will not give params unless the body is a properly\n         # formatted string, a dictionary or a list of 2-tuples.\n         decoded_body = extract_params(r.data)\n \n-        _ct = (contenttype is None)\n-        _ct = _ct or contenttype.lower() == CONTENT_TYPE_FORM_URLENCODED\n-\n-        if _ct and decoded_body != None:\n-            # extract_params can only check the present r.data and does not know\n-            # of r.files, thus an extra check is performed. We know that\n-            # if files are present the request will not have\n-            # Content-type: x-www-form-urlencoded. We guess it will have\n-            # a mimetype of multipart/form-encoded and if this is not the case\n-            # we assume the correct header will be set later.\n-            if r.files:\n-                # Omit body data in the signing and since it will always\n-                # be empty (cant add paras to body if multipart) and we wish\n-                # to preserve body.\n-                r.headers['Content-Type'] = 'multipart/form-encoded'\n-                r.url, r.headers, _ = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), None, r.headers)\n-            else:\n-                # Normal signing\n-                r.headers['Content-Type'] = 'application/x-www-form-urlencoded'\n-                r.url, r.headers, r.data = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), r.data, r.headers)\n-\n+        # extract_params can only check the present r.data and does not know\n+        # of r.files, thus an extra check is performed. We know that\n+        # if files are present the request will not have\n+        # Content-type: x-www-form-urlencoded. We guess it will have\n+        # a mimetype of multipart/form-encoded and if this is not the case\n+        # we assume the correct header will be set later.\n+        _cond = True\n+        if r.files and contenttype == CONTENT_TYPE_MULTI_PART:\n+            # Omit body data in the signing and since it will always\n+            # be empty (cant add paras to body if multipart) and we wish\n+            # to preserve body.\n+            r.headers['Content-Type'] = CONTENT_TYPE_MULTI_PART",
      "comment": "Why are we replacing the content-type header here? Seems like we're just erasing the boundary data.\n",
      "comment_id": 1472093,
      "user": "idan",
      "created_at": "2012-08-28T07:15:19Z",
      "url": "https://github.com/psf/requests/pull/819#discussion_r1472093"
    },
    {
      "repo": "psf/requests",
      "pr_number": 819,
      "file_path": "requests/auth.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,34 +75,34 @@ def __call__(self, r):\n         Parameters may be included from the body if the content-type is\n         urlencoded, if no content type is set an educated guess is made.\n         \"\"\"\n-        contenttype = r.headers.get('Content-Type', None)\n+        # split(\";\") because Content-Type may be \"multipart/form-data; boundary=xxxxx\"\n+        contenttype = r.headers.get('Content-Type', '').split(\";\")[0].lower()\n         # extract_params will not give params unless the body is a properly\n         # formatted string, a dictionary or a list of 2-tuples.\n         decoded_body = extract_params(r.data)\n \n-        _ct = (contenttype is None)\n-        _ct = _ct or contenttype.lower() == CONTENT_TYPE_FORM_URLENCODED\n-\n-        if _ct and decoded_body != None:\n-            # extract_params can only check the present r.data and does not know\n-            # of r.files, thus an extra check is performed. We know that\n-            # if files are present the request will not have\n-            # Content-type: x-www-form-urlencoded. We guess it will have\n-            # a mimetype of multipart/form-encoded and if this is not the case\n-            # we assume the correct header will be set later.\n-            if r.files:\n-                # Omit body data in the signing and since it will always\n-                # be empty (cant add paras to body if multipart) and we wish\n-                # to preserve body.\n-                r.headers['Content-Type'] = 'multipart/form-encoded'\n-                r.url, r.headers, _ = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), None, r.headers)\n-            else:\n-                # Normal signing\n-                r.headers['Content-Type'] = 'application/x-www-form-urlencoded'\n-                r.url, r.headers, r.data = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), r.data, r.headers)\n-\n+        # extract_params can only check the present r.data and does not know\n+        # of r.files, thus an extra check is performed. We know that\n+        # if files are present the request will not have\n+        # Content-type: x-www-form-urlencoded. We guess it will have\n+        # a mimetype of multipart/form-encoded and if this is not the case",
      "comment": "@idan In fact there does not exist \"multipart/form-encoded\", but only \"multipart/form-data\".\n",
      "comment_id": 1472095,
      "user": "ayanamist",
      "created_at": "2012-08-28T07:16:00Z",
      "url": "https://github.com/psf/requests/pull/819#discussion_r1472095"
    },
    {
      "repo": "psf/requests",
      "pr_number": 819,
      "file_path": "requests/auth.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,34 +75,34 @@ def __call__(self, r):\n         Parameters may be included from the body if the content-type is\n         urlencoded, if no content type is set an educated guess is made.\n         \"\"\"\n-        contenttype = r.headers.get('Content-Type', None)\n+        # split(\";\") because Content-Type may be \"multipart/form-data; boundary=xxxxx\"\n+        contenttype = r.headers.get('Content-Type', '').split(\";\")[0].lower()\n         # extract_params will not give params unless the body is a properly\n         # formatted string, a dictionary or a list of 2-tuples.\n         decoded_body = extract_params(r.data)\n \n-        _ct = (contenttype is None)\n-        _ct = _ct or contenttype.lower() == CONTENT_TYPE_FORM_URLENCODED\n-\n-        if _ct and decoded_body != None:\n-            # extract_params can only check the present r.data and does not know\n-            # of r.files, thus an extra check is performed. We know that\n-            # if files are present the request will not have\n-            # Content-type: x-www-form-urlencoded. We guess it will have\n-            # a mimetype of multipart/form-encoded and if this is not the case\n-            # we assume the correct header will be set later.\n-            if r.files:\n-                # Omit body data in the signing and since it will always\n-                # be empty (cant add paras to body if multipart) and we wish\n-                # to preserve body.\n-                r.headers['Content-Type'] = 'multipart/form-encoded'\n-                r.url, r.headers, _ = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), None, r.headers)\n-            else:\n-                # Normal signing\n-                r.headers['Content-Type'] = 'application/x-www-form-urlencoded'\n-                r.url, r.headers, r.data = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), r.data, r.headers)\n-\n+        # extract_params can only check the present r.data and does not know\n+        # of r.files, thus an extra check is performed. We know that\n+        # if files are present the request will not have\n+        # Content-type: x-www-form-urlencoded. We guess it will have\n+        # a mimetype of multipart/form-encoded and if this is not the case",
      "comment": "Yes, I'm agreeing! I'm asking you to update the pull to also change the comment to the correct mimetype :)\n",
      "comment_id": 1472096,
      "user": "idan",
      "created_at": "2012-08-28T07:17:05Z",
      "url": "https://github.com/psf/requests/pull/819#discussion_r1472096"
    },
    {
      "repo": "psf/requests",
      "pr_number": 819,
      "file_path": "requests/auth.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,34 +75,34 @@ def __call__(self, r):\n         Parameters may be included from the body if the content-type is\n         urlencoded, if no content type is set an educated guess is made.\n         \"\"\"\n-        contenttype = r.headers.get('Content-Type', None)\n+        # split(\";\") because Content-Type may be \"multipart/form-data; boundary=xxxxx\"\n+        contenttype = r.headers.get('Content-Type', '').split(\";\")[0].lower()\n         # extract_params will not give params unless the body is a properly\n         # formatted string, a dictionary or a list of 2-tuples.\n         decoded_body = extract_params(r.data)\n \n-        _ct = (contenttype is None)\n-        _ct = _ct or contenttype.lower() == CONTENT_TYPE_FORM_URLENCODED\n-\n-        if _ct and decoded_body != None:\n-            # extract_params can only check the present r.data and does not know\n-            # of r.files, thus an extra check is performed. We know that\n-            # if files are present the request will not have\n-            # Content-type: x-www-form-urlencoded. We guess it will have\n-            # a mimetype of multipart/form-encoded and if this is not the case\n-            # we assume the correct header will be set later.\n-            if r.files:\n-                # Omit body data in the signing and since it will always\n-                # be empty (cant add paras to body if multipart) and we wish\n-                # to preserve body.\n-                r.headers['Content-Type'] = 'multipart/form-encoded'\n-                r.url, r.headers, _ = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), None, r.headers)\n-            else:\n-                # Normal signing\n-                r.headers['Content-Type'] = 'application/x-www-form-urlencoded'\n-                r.url, r.headers, r.data = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), r.data, r.headers)\n-\n+        # extract_params can only check the present r.data and does not know\n+        # of r.files, thus an extra check is performed. We know that\n+        # if files are present the request will not have\n+        # Content-type: x-www-form-urlencoded. We guess it will have\n+        # a mimetype of multipart/form-encoded and if this is not the case\n+        # we assume the correct header will be set later.\n+        _cond = True\n+        if r.files and contenttype == CONTENT_TYPE_MULTI_PART:\n+            # Omit body data in the signing and since it will always\n+            # be empty (cant add paras to body if multipart) and we wish\n+            # to preserve body.\n+            r.headers['Content-Type'] = CONTENT_TYPE_MULTI_PART",
      "comment": "@idan Sorry, it's my fault, because sometimes the header does not exist, so i just simply set the header again. I will add another commit soon.\n",
      "comment_id": 1472100,
      "user": "ayanamist",
      "created_at": "2012-08-28T07:17:42Z",
      "url": "https://github.com/psf/requests/pull/819#discussion_r1472100"
    },
    {
      "repo": "psf/requests",
      "pr_number": 819,
      "file_path": "requests/auth.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,34 +75,34 @@ def __call__(self, r):\n         Parameters may be included from the body if the content-type is\n         urlencoded, if no content type is set an educated guess is made.\n         \"\"\"\n-        contenttype = r.headers.get('Content-Type', None)\n+        # split(\";\") because Content-Type may be \"multipart/form-data; boundary=xxxxx\"\n+        contenttype = r.headers.get('Content-Type', '').split(\";\")[0].lower()\n         # extract_params will not give params unless the body is a properly\n         # formatted string, a dictionary or a list of 2-tuples.\n         decoded_body = extract_params(r.data)\n \n-        _ct = (contenttype is None)\n-        _ct = _ct or contenttype.lower() == CONTENT_TYPE_FORM_URLENCODED\n-\n-        if _ct and decoded_body != None:\n-            # extract_params can only check the present r.data and does not know\n-            # of r.files, thus an extra check is performed. We know that\n-            # if files are present the request will not have\n-            # Content-type: x-www-form-urlencoded. We guess it will have\n-            # a mimetype of multipart/form-encoded and if this is not the case\n-            # we assume the correct header will be set later.\n-            if r.files:\n-                # Omit body data in the signing and since it will always\n-                # be empty (cant add paras to body if multipart) and we wish\n-                # to preserve body.\n-                r.headers['Content-Type'] = 'multipart/form-encoded'\n-                r.url, r.headers, _ = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), None, r.headers)\n-            else:\n-                # Normal signing\n-                r.headers['Content-Type'] = 'application/x-www-form-urlencoded'\n-                r.url, r.headers, r.data = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), r.data, r.headers)\n-\n+        # extract_params can only check the present r.data and does not know\n+        # of r.files, thus an extra check is performed. We know that\n+        # if files are present the request will not have\n+        # Content-type: x-www-form-urlencoded. We guess it will have\n+        # a mimetype of multipart/form-data and if this is not the case\n+        # we assume the correct header will be set later.\n+        _cond = True",
      "comment": "let's give `_cond` a descriptive name like `was_oauth_signed` \u2014 would make the logic here a lot clearer.\n",
      "comment_id": 1472177,
      "user": "idan",
      "created_at": "2012-08-28T07:35:18Z",
      "url": "https://github.com/psf/requests/pull/819#discussion_r1472177"
    },
    {
      "repo": "psf/requests",
      "pr_number": 819,
      "file_path": "requests/auth.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,34 +75,34 @@ def __call__(self, r):\n         Parameters may be included from the body if the content-type is\n         urlencoded, if no content type is set an educated guess is made.\n         \"\"\"\n-        contenttype = r.headers.get('Content-Type', None)\n+        # split(\";\") because Content-Type may be \"multipart/form-data; boundary=xxxxx\"\n+        contenttype = r.headers.get('Content-Type', '').split(\";\")[0].lower()\n         # extract_params will not give params unless the body is a properly\n         # formatted string, a dictionary or a list of 2-tuples.\n         decoded_body = extract_params(r.data)\n \n-        _ct = (contenttype is None)\n-        _ct = _ct or contenttype.lower() == CONTENT_TYPE_FORM_URLENCODED\n-\n-        if _ct and decoded_body != None:\n-            # extract_params can only check the present r.data and does not know\n-            # of r.files, thus an extra check is performed. We know that\n-            # if files are present the request will not have\n-            # Content-type: x-www-form-urlencoded. We guess it will have\n-            # a mimetype of multipart/form-encoded and if this is not the case\n-            # we assume the correct header will be set later.\n-            if r.files:\n-                # Omit body data in the signing and since it will always\n-                # be empty (cant add paras to body if multipart) and we wish\n-                # to preserve body.\n-                r.headers['Content-Type'] = 'multipart/form-encoded'\n-                r.url, r.headers, _ = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), None, r.headers)\n-            else:\n-                # Normal signing\n-                r.headers['Content-Type'] = 'application/x-www-form-urlencoded'\n-                r.url, r.headers, r.data = self.client.sign(\n-                    unicode(r.full_url), unicode(r.method), r.data, r.headers)\n-\n+        # extract_params can only check the present r.data and does not know\n+        # of r.files, thus an extra check is performed. We know that\n+        # if files are present the request will not have\n+        # Content-type: x-www-form-urlencoded. We guess it will have\n+        # a mimetype of multipart/form-data and if this is not the case\n+        # we assume the correct header will be set later.\n+        _cond = True",
      "comment": "Another option is to break out the conditional logic into a separate method, like sanitize_signed(), and call it from both branches of the if/elif below.\n",
      "comment_id": 1472194,
      "user": "idan",
      "created_at": "2012-08-28T07:40:32Z",
      "url": "https://github.com/psf/requests/pull/819#discussion_r1472194"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1635,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -404,3 +404,19 @@ def cookiejar_from_dict(cookie_dict, cookiejar=None):\n         for name in cookie_dict:\n             cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))\n     return cookiejar\n+\n+\n+def merge_session_cookies(cookiejar, cookie_dict):\n+    \"\"\"Merges cookie_dict with session CookieJar.\n+\n+    :param cookiejar: Should be session cookie.\n+    :param cookie_dict: Dict of key/values to be merged.\n+    \"\"\"\n+    if cookiejar is None:\n+        cookiejar = RequestsCookieJar()\n+\n+    if cookie_dict is not None:\n+        for k in cookie_dict:\n+            # Session should not be modified by request cookie.\n+            if k not in [cookie.name for cookie in cookiejar]:\n+                cookiejar.set_cookie(create_cookie(k, cookie_dict[k]))",
      "comment": "I think it might be better to add an optional argument to `cookiejar_from_dict` rather than have a new function that duplicates almost all the logic. Something like:\n\n``` python\ndef cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):\n    \"\"\"Returns a CookieJar from a key/value dictionary.\n\n    :param cookie_dict: Dict of key/values to insert into CookieJar.\n    :param cookiejar: (optional) A cookiejar to add the cookies to.\n    :param overwrite: (optional) If False, will not replace cookies already\n                                 in the jar with new ones.\n    \"\"\"\n    if cookiejar is None:\n        cookiejar = RequestsCookieJar()\n\n    if cookie_dict is not None:\n        names = [cookie.name for cookie in cookiejar]\n\n        for name in cookie_dict:\n            if overwrite or (name not in names):\n                cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))\n\n    return cookiejar\n```\n",
      "comment_id": 6644392,
      "user": "Lukasa",
      "created_at": "2013-09-28T15:35:19Z",
      "url": "https://github.com/psf/requests/pull/1635#discussion_r6644392"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1951,
      "file_path": "requests/sessions.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,6 +177,75 @@ def resolve_redirects(self, resp, req, stream=False, timeout=None,\n             i += 1\n             yield resp\n \n+    def rebuild_auth(self, prepared_request, response):\n+        \"\"\"\n+        When being redirected we may want to strip authentication from the\n+        request to avoid leaking credentials. This method intelligently removes\n+        and reapplies authentication where possible to avoid credential loss.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+\n+        if 'Authorization' in headers:\n+            # If we get redirected to a new host, we should strip out any\n+            #\u00a0authentication headers.\n+            original_parsed = urlparse(response.request.url)\n+            redirect_parsed = urlparse(url)\n+\n+            if (original_parsed.hostname != redirect_parsed.hostname):\n+                del headers['Authorization']\n+\n+        # .netrc might have more auth for us on our new host.\n+        new_auth = get_netrc_auth(url) if self.trust_env else None\n+        if new_auth is not None:\n+            prepared_request.prepare_auth(new_auth)\n+\n+        return\n+\n+    def rebuild_proxies(self, prepared_request, proxies):\n+        \"\"\"\n+        This method re-evaluates the proxy configuration by considering the\n+        environment variables. If we are redirected to a URL covered by\n+        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing\n+        proxy keys for this URL (in case they were stripped by a previous\n+        redirect).\n+\n+        This method also replaces the Proxy-Authorization header where\n+        necessary.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+        new_proxies = {}\n+\n+        # Consider proxies. First evaluate the new proxy config. If we are\n+        # being redirected to a host on the NO_PROXY list then we want to\n+        # remove the proxy dictionary entirely. Otherwise, if there's a relevant\n+        # environment proxy, set it if we don't already have a proxy to go to.\n+        if not should_bypass_proxies(url):\n+            environ_proxies = get_environ_proxies(url)\n+            scheme = urlparse(url).scheme\n+\n+            try:\n+                new_proxies.setdefault(scheme, environ_proxies[scheme])\n+            except KeyError:\n+                pass\n+\n+        # If there's a proxy-authorization header present, remove it, then add",
      "comment": "This comment is pretty unnecessary :) (the less code the better!)\n\n(not sure if you're looking for feedback on that stuff or not) :P\n",
      "comment_id": 10538705,
      "user": "kennethreitz",
      "created_at": "2014-03-12T20:25:59Z",
      "url": "https://github.com/psf/requests/pull/1951#discussion_r10538705"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1951,
      "file_path": "requests/sessions.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,6 +177,69 @@ def resolve_redirects(self, resp, req, stream=False, timeout=None,\n             i += 1\n             yield resp\n \n+    def rebuild_auth(self, prepared_request, response):\n+        \"\"\"\n+        When being redirected we may want to strip authentication from the\n+        request to avoid leaking credentials. This method intelligently removes\n+        and reapplies authentication where possible to avoid credential loss.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+\n+        if 'Authorization' in headers:\n+            # If we get redirected to a new host, we should strip out any\n+            #\u00a0authentication headers.\n+            original_parsed = urlparse(response.request.url)\n+            redirect_parsed = urlparse(url)\n+\n+            if (original_parsed.hostname != redirect_parsed.hostname):\n+                del headers['Authorization']\n+\n+        # .netrc might have more auth for us on our new host.\n+        new_auth = get_netrc_auth(url) if self.trust_env else None\n+        if new_auth is not None:\n+            prepared_request.prepare_auth(new_auth)\n+\n+        return\n+\n+    def rebuild_proxies(self, prepared_request, proxies):\n+        \"\"\"\n+        This method re-evaluates the proxy configuration by considering the\n+        environment variables. If we are redirected to a URL covered by\n+        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing\n+        proxy keys for this URL (in case they were stripped by a previous\n+        redirect).\n+\n+        This method also replaces the Proxy-Authorization header where\n+        necessary.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+        new_proxies = {}\n+\n+        if not should_bypass_proxies(url):\n+            environ_proxies = get_environ_proxies(url)\n+            scheme = urlparse(url).scheme\n+\n+            try:\n+                new_proxies.setdefault(scheme, environ_proxies[scheme])",
      "comment": "The `KeyError` is for `environ_proxies` right? Meaning we only want to set the default for `scheme` if `environ_proxies[scheme]` exists, right? Would something along these lines be amenable?\n\n``` python\nenviron_proxies = get_environ_proxies(url)\nscheme = urlparse(url).scheme\n\nproxy = environ_proxies.get(scheme)\nif proxy:\n   new_proxies.setdefault(scheme, proxy)\n```\n",
      "comment_id": 10550290,
      "user": "sigmavirus24",
      "created_at": "2014-03-13T01:51:26Z",
      "url": "https://github.com/psf/requests/pull/1951#discussion_r10550290"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1951,
      "file_path": "requests/sessions.py",
      "line": 232,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,6 +177,69 @@ def resolve_redirects(self, resp, req, stream=False, timeout=None,\n             i += 1\n             yield resp\n \n+    def rebuild_auth(self, prepared_request, response):\n+        \"\"\"\n+        When being redirected we may want to strip authentication from the\n+        request to avoid leaking credentials. This method intelligently removes\n+        and reapplies authentication where possible to avoid credential loss.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+\n+        if 'Authorization' in headers:\n+            # If we get redirected to a new host, we should strip out any\n+            #\u00a0authentication headers.\n+            original_parsed = urlparse(response.request.url)\n+            redirect_parsed = urlparse(url)\n+\n+            if (original_parsed.hostname != redirect_parsed.hostname):\n+                del headers['Authorization']\n+\n+        # .netrc might have more auth for us on our new host.\n+        new_auth = get_netrc_auth(url) if self.trust_env else None\n+        if new_auth is not None:\n+            prepared_request.prepare_auth(new_auth)\n+\n+        return\n+\n+    def rebuild_proxies(self, prepared_request, proxies):\n+        \"\"\"\n+        This method re-evaluates the proxy configuration by considering the\n+        environment variables. If we are redirected to a URL covered by\n+        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing\n+        proxy keys for this URL (in case they were stripped by a previous\n+        redirect).\n+\n+        This method also replaces the Proxy-Authorization header where\n+        necessary.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+        new_proxies = {}\n+\n+        if not should_bypass_proxies(url):\n+            environ_proxies = get_environ_proxies(url)\n+            scheme = urlparse(url).scheme\n+\n+            try:\n+                new_proxies.setdefault(scheme, environ_proxies[scheme])\n+            except KeyError:\n+                pass\n+\n+        if 'Proxy-Authorization' in headers:\n+            del headers['Proxy-Authorization']\n+\n+        try:",
      "comment": "Similar deal here?\n\n``` python\nusername, password = (None, None)\nproxy = new_proxies.get(scheme)\n\nif proxy:\n    username, password = get_auth_from_url(proxy)\n\nif username and password:\n    headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n\nreturn new_proxies\n```\n",
      "comment_id": 10550367,
      "user": "sigmavirus24",
      "created_at": "2014-03-13T01:55:44Z",
      "url": "https://github.com/psf/requests/pull/1951#discussion_r10550367"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1951,
      "file_path": "requests/sessions.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,6 +177,69 @@ def resolve_redirects(self, resp, req, stream=False, timeout=None,\n             i += 1\n             yield resp\n \n+    def rebuild_auth(self, prepared_request, response):\n+        \"\"\"\n+        When being redirected we may want to strip authentication from the\n+        request to avoid leaking credentials. This method intelligently removes\n+        and reapplies authentication where possible to avoid credential loss.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+\n+        if 'Authorization' in headers:\n+            # If we get redirected to a new host, we should strip out any\n+            #\u00a0authentication headers.\n+            original_parsed = urlparse(response.request.url)\n+            redirect_parsed = urlparse(url)\n+\n+            if (original_parsed.hostname != redirect_parsed.hostname):\n+                del headers['Authorization']\n+\n+        # .netrc might have more auth for us on our new host.\n+        new_auth = get_netrc_auth(url) if self.trust_env else None\n+        if new_auth is not None:\n+            prepared_request.prepare_auth(new_auth)\n+\n+        return\n+\n+    def rebuild_proxies(self, prepared_request, proxies):\n+        \"\"\"\n+        This method re-evaluates the proxy configuration by considering the\n+        environment variables. If we are redirected to a URL covered by\n+        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing\n+        proxy keys for this URL (in case they were stripped by a previous\n+        redirect).\n+\n+        This method also replaces the Proxy-Authorization header where\n+        necessary.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+        new_proxies = {}\n+\n+        if not should_bypass_proxies(url):\n+            environ_proxies = get_environ_proxies(url)\n+            scheme = urlparse(url).scheme\n+\n+            try:\n+                new_proxies.setdefault(scheme, environ_proxies[scheme])",
      "comment": "In general, I just hate empty except blocks. I don't necessarily prefer it to `KeyError`. :)\n",
      "comment_id": 10607448,
      "user": "sigmavirus24",
      "created_at": "2014-03-14T13:46:14Z",
      "url": "https://github.com/psf/requests/pull/1951#discussion_r10607448"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1951,
      "file_path": "requests/sessions.py",
      "line": 232,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,6 +177,69 @@ def resolve_redirects(self, resp, req, stream=False, timeout=None,\n             i += 1\n             yield resp\n \n+    def rebuild_auth(self, prepared_request, response):\n+        \"\"\"\n+        When being redirected we may want to strip authentication from the\n+        request to avoid leaking credentials. This method intelligently removes\n+        and reapplies authentication where possible to avoid credential loss.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+\n+        if 'Authorization' in headers:\n+            # If we get redirected to a new host, we should strip out any\n+            #\u00a0authentication headers.\n+            original_parsed = urlparse(response.request.url)\n+            redirect_parsed = urlparse(url)\n+\n+            if (original_parsed.hostname != redirect_parsed.hostname):\n+                del headers['Authorization']\n+\n+        # .netrc might have more auth for us on our new host.\n+        new_auth = get_netrc_auth(url) if self.trust_env else None\n+        if new_auth is not None:\n+            prepared_request.prepare_auth(new_auth)\n+\n+        return\n+\n+    def rebuild_proxies(self, prepared_request, proxies):\n+        \"\"\"\n+        This method re-evaluates the proxy configuration by considering the\n+        environment variables. If we are redirected to a URL covered by\n+        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing\n+        proxy keys for this URL (in case they were stripped by a previous\n+        redirect).\n+\n+        This method also replaces the Proxy-Authorization header where\n+        necessary.\n+        \"\"\"\n+        headers = prepared_request.headers\n+        url = prepared_request.url\n+        new_proxies = {}\n+\n+        if not should_bypass_proxies(url):\n+            environ_proxies = get_environ_proxies(url)\n+            scheme = urlparse(url).scheme\n+\n+            try:\n+                new_proxies.setdefault(scheme, environ_proxies[scheme])\n+            except KeyError:\n+                pass\n+\n+        if 'Proxy-Authorization' in headers:\n+            del headers['Proxy-Authorization']\n+\n+        try:",
      "comment": "How about this:\n\n```\ntry:\n    username, password = get_auth_from_url(new_proxies[scheme])\nexcept KeyError:\n    username = password = None\n\nif username and password:\n    headers['Proxy-Authorization'] = _basic_auth_str(username, password)\n```\n\nIn general, I cringe when I see code inside the `try` block that will not raise the exception being caught. Further this will allow you to keep your `KeyError` (=P) and use the except block in a meaningful way. It also is a bit nicer than the original suggestion I had.\n",
      "comment_id": 10607515,
      "user": "sigmavirus24",
      "created_at": "2014-03-14T13:48:25Z",
      "url": "https://github.com/psf/requests/pull/1951#discussion_r10607515"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1770,
      "file_path": "requests/utils.py",
      "line": 428,
      "side": "RIGHT",
      "diff_hunk": "@@ -405,6 +407,48 @@ def requote_uri(uri):\n     return quote(unquote_unreserved(uri), safe=\"!#$%&'()*+,/:;=?@[]~\")\n \n \n+def address_in_network(ip, net):\n+    \"\"\"\n+    This function allows you to check if on IP belongs to a Network subnet\n+    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n+             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n+    \"\"\"\n+    ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]\n+    netaddr, bits = net.split('/')\n+    netmask = struct.unpack('=L', socket.inet_aton(dotted_netmask(int(bits))))[0]\n+    network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask\n+    return (ipaddr & netmask) == (network & netmask)\n+\n+\n+def dotted_netmask(mask):\n+    \"\"\"\n+    Converts mask from /xx format to xxx.xxx.xxx.xxx\n+    Example: if mask is 24 function returns 255.255.255.0\n+    \"\"\"\n+    bits = 0xffffffff ^ (1 << 32 - mask) - 1",
      "comment": "I know I've written too much C, because I saw this line and started freaking out about undefined behaviour until I remembered what language this is. =D\n",
      "comment_id": 8104723,
      "user": "Lukasa",
      "created_at": "2013-12-04T18:33:52Z",
      "url": "https://github.com/psf/requests/pull/1770#discussion_r8104723"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1770,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -405,6 +407,48 @@ def requote_uri(uri):\n     return quote(unquote_unreserved(uri), safe=\"!#$%&'()*+,/:;=?@[]~\")\n \n \n+def address_in_network(ip, net):\n+    \"\"\"\n+    This function allows you to check if on IP belongs to a Network subnet\n+    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n+             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n+    \"\"\"\n+    ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]\n+    netaddr, bits = net.split('/')\n+    netmask = struct.unpack('=L', socket.inet_aton(dotted_netmask(int(bits))))[0]\n+    network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask\n+    return (ipaddr & netmask) == (network & netmask)\n+\n+\n+def dotted_netmask(mask):\n+    \"\"\"\n+    Converts mask from /xx format to xxx.xxx.xxx.xxx\n+    Example: if mask is 24 function returns 255.255.255.0\n+    \"\"\"\n+    bits = 0xffffffff ^ (1 << 32 - mask) - 1\n+    return socket.inet_ntoa(struct.pack('>I', bits))\n+\n+\n+def is_ipv4_address(string_ip):\n+    try:\n+        socket.inet_aton(string_ip)\n+    except BaseException:",
      "comment": "Do we need to catch `BaseException` here? Why not just `Exception`?\n\nActually, sorry I didn't catch this the first time around, but we should be really specific about the exceptions we catch here. From a quick check, an invalid IP address returns a `socket.error`, and an invalid object returns `TypeError`. I feel like we should only catch `socket.error`, and let a `TypeError` bubble up (as it suggests someone's doing something stupid).\n",
      "comment_id": 8104751,
      "user": "Lukasa",
      "created_at": "2013-12-04T18:34:38Z",
      "url": "https://github.com/psf/requests/pull/1770#discussion_r8104751"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1770,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -405,6 +407,48 @@ def requote_uri(uri):\n     return quote(unquote_unreserved(uri), safe=\"!#$%&'()*+,/:;=?@[]~\")\n \n \n+def address_in_network(ip, net):\n+    \"\"\"\n+    This function allows you to check if on IP belongs to a Network subnet\n+    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n+             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n+    \"\"\"\n+    ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]\n+    netaddr, bits = net.split('/')\n+    netmask = struct.unpack('=L', socket.inet_aton(dotted_netmask(int(bits))))[0]\n+    network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask\n+    return (ipaddr & netmask) == (network & netmask)\n+\n+\n+def dotted_netmask(mask):\n+    \"\"\"\n+    Converts mask from /xx format to xxx.xxx.xxx.xxx\n+    Example: if mask is 24 function returns 255.255.255.0\n+    \"\"\"\n+    bits = 0xffffffff ^ (1 << 32 - mask) - 1\n+    return socket.inet_ntoa(struct.pack('>I', bits))\n+\n+\n+def is_ipv4_address(string_ip):\n+    try:\n+        socket.inet_aton(string_ip)\n+    except BaseException:\n+        return False\n+    return True\n+\n+\n+def is_ipv4_network(string_network):",
      "comment": "I don't think this function is properly named. This doesn't in any sense test whether this is an IPv4 network, just whether it's a network in CIDR notation or not.\n",
      "comment_id": 8105107,
      "user": "Lukasa",
      "created_at": "2013-12-04T18:42:49Z",
      "url": "https://github.com/psf/requests/pull/1770#discussion_r8105107"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1770,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -405,6 +407,48 @@ def requote_uri(uri):\n     return quote(unquote_unreserved(uri), safe=\"!#$%&'()*+,/:;=?@[]~\")\n \n \n+def address_in_network(ip, net):\n+    \"\"\"\n+    This function allows you to check if on IP belongs to a Network subnet",
      "comment": "Typo. Should be `This function allows you to check if an IP address belongs to a network subnet` or similar.\n",
      "comment_id": 8118872,
      "user": "Anorov",
      "created_at": "2013-12-05T02:14:16Z",
      "url": "https://github.com/psf/requests/pull/1770#discussion_r8118872"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1770,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -405,6 +407,48 @@ def requote_uri(uri):\n     return quote(unquote_unreserved(uri), safe=\"!#$%&'()*+,/:;=?@[]~\")\n \n \n+def address_in_network(ip, net):\n+    \"\"\"\n+    This function allows you to check if on IP belongs to a Network subnet\n+    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n+             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n+    \"\"\"\n+    ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]\n+    netaddr, bits = net.split('/')\n+    netmask = struct.unpack('=L', socket.inet_aton(dotted_netmask(int(bits))))[0]\n+    network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask\n+    return (ipaddr & netmask) == (network & netmask)\n+\n+\n+def dotted_netmask(mask):\n+    \"\"\"\n+    Converts mask from /xx format to xxx.xxx.xxx.xxx\n+    Example: if mask is 24 function returns 255.255.255.0\n+    \"\"\"\n+    bits = 0xffffffff ^ (1 << 32 - mask) - 1\n+    return socket.inet_ntoa(struct.pack('>I', bits))\n+\n+\n+def is_ipv4_address(string_ip):\n+    try:\n+        socket.inet_aton(string_ip)\n+    except BaseException:\n+        return False\n+    return True\n+\n+\n+def is_ipv4_network(string_network):",
      "comment": "Fair warning: really splitting hairs here...\n\nI agree that the naming could be better. Maybe `is_valid_cidr` might be a better name? In that case, you might want to validate that there's only one '/' in `string_network`, that `string_network.split('/')[1]` is an integer between 0 and 32, and keep the implicit check that `socket.inet_aton(string_network.split('/')[0])` raises when it's not a valid IPv4 address. Although, I do think that `inet_aton` takes valid input that wouldn't make for a valid CIDR. For example, I think it'll return a valid value for the input `\"127\"`.\n",
      "comment_id": 8119384,
      "user": "hoov",
      "created_at": "2013-12-05T02:54:54Z",
      "url": "https://github.com/psf/requests/pull/1770#discussion_r8119384"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1770,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -405,6 +407,48 @@ def requote_uri(uri):\n     return quote(unquote_unreserved(uri), safe=\"!#$%&'()*+,/:;=?@[]~\")\n \n \n+def address_in_network(ip, net):\n+    \"\"\"\n+    This function allows you to check if on IP belongs to a Network subnet\n+    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24\n+             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24\n+    \"\"\"\n+    ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]\n+    netaddr, bits = net.split('/')\n+    netmask = struct.unpack('=L', socket.inet_aton(dotted_netmask(int(bits))))[0]\n+    network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask\n+    return (ipaddr & netmask) == (network & netmask)\n+\n+\n+def dotted_netmask(mask):\n+    \"\"\"\n+    Converts mask from /xx format to xxx.xxx.xxx.xxx\n+    Example: if mask is 24 function returns 255.255.255.0\n+    \"\"\"\n+    bits = 0xffffffff ^ (1 << 32 - mask) - 1\n+    return socket.inet_ntoa(struct.pack('>I', bits))\n+\n+\n+def is_ipv4_address(string_ip):\n+    try:\n+        socket.inet_aton(string_ip)\n+    except BaseException:",
      "comment": "You are absolutely right. BaseException is too broad. I'm going to change it to socket.error.\n",
      "comment_id": 8123640,
      "user": "kmadac",
      "created_at": "2013-12-05T09:14:23Z",
      "url": "https://github.com/psf/requests/pull/1770#discussion_r8123640"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1772,
      "file_path": "requests/cookies.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -383,9 +383,11 @@ def morsel_to_cookie(morsel):\n         expires = time.time() + morsel[\"max-age\"]\n     elif morsel['expires']:\n         expires = morsel['expires']\n-        if type(expires) == type(\"\"):",
      "comment": "If we absolutely need to check that the type is a string, the preferred method (per [pep8](http://www.python.org/dev/peps/pep-0008/)) is to use `isinstance` instead of type. However, `try`/`except` is [always preferred](docs.python.org/2/glossary.html#term-duck-typing) over `type` or `isinstance`. The more pythonic way is to [ask for forgiveness](http://docs.python.org/2/glossary.html#term-eafp) not permission.\n\nAnother thing to keep in mind is that maybe expires is a `unicode` or a `byte` object and the current check won't properly account for this.\n",
      "comment_id": 8049604,
      "user": "mdbecker",
      "created_at": "2013-12-03T03:27:46Z",
      "url": "https://github.com/psf/requests/pull/1772#discussion_r8049604"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1772,
      "file_path": "requests/cookies.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -383,9 +383,11 @@ def morsel_to_cookie(morsel):\n         expires = time.time() + morsel[\"max-age\"]\n     elif morsel['expires']:\n         expires = morsel['expires']\n-        if type(expires) == type(\"\"):",
      "comment": "I agree this smells, I have no argument with that, I just hate try/except blocks. They're cowardly. What I mean is: morsel comes from a header so it's always going to be a native strings (str/bytes on python 2, str on python 3) so these should always be parseable. The bigger question is what could cause that parsing to raise an exception? None? If it's a None value we need a simple check: `if expires:` That's far more readable and avoids an antipattern of not doing something in an except block which is a pattern that should be avoided more than anything. \n\nTesting this out in the console implies that a malformed string could cause a `ValueError` and that `TypeError`. That said, this can already raise an uncaught ValueError which is fine. If the server is misbehaving we should make the user aware.\n\nFor what it's worth, the RFC defines the Expires header as a string with the format  we're assigning to `time_template` so checking if it is a string is unnecessary.\n",
      "comment_id": 8049767,
      "user": "sigmavirus24",
      "created_at": "2013-12-03T03:40:32Z",
      "url": "https://github.com/psf/requests/pull/1772#discussion_r8049767"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1772,
      "file_path": "requests/cookies.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -383,9 +383,11 @@ def morsel_to_cookie(morsel):\n         expires = time.time() + morsel[\"max-age\"]\n     elif morsel['expires']:\n         expires = morsel['expires']\n-        if type(expires) == type(\"\"):",
      "comment": "Yeah, sorry I just didn't want to cause any side-effects so I was trying to be cautious. Based on your comment, it sounds like maybe the preferred fix would be something like this?\n\n``` python\n    elif morsel['expires']:\n        expires = morsel['expires']\n        if expires:\n            time_template = \"%a, %d-%b-%Y %H:%M:%S GMT\"\n            expires = time.mktime(time.strptime(expires, time_template))\n```\n\nIf that's the case, I'll resubmit my pull request with this solution instead?\n\nAny recommendations on a better way of testing this without manually creating the `Morsel` object like I am now?\n",
      "comment_id": 8049890,
      "user": "mdbecker",
      "created_at": "2013-12-03T03:52:05Z",
      "url": "https://github.com/psf/requests/pull/1772#discussion_r8049890"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1772,
      "file_path": "requests/cookies.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -383,9 +383,11 @@ def morsel_to_cookie(morsel):\n         expires = time.time() + morsel[\"max-age\"]\n     elif morsel['expires']:\n         expires = morsel['expires']\n-        if type(expires) == type(\"\"):",
      "comment": "That would be what I would prefer. **But** don't submit a new PR. Simply tack extra commits onto this branch to fix that.\n\nFor testing, we could use mock here but the library doesn't already use it and while we're not as concerned about testing dependencies, it is fine to create the Morsel. It communicates the intent of the function. I would just ask that you break that one test up into 3. You already have the body of that function broken into three paragraphs, they're three different logical tests and should be isolated in three different functions to represent that.\n",
      "comment_id": 8050016,
      "user": "sigmavirus24",
      "created_at": "2013-12-03T04:01:31Z",
      "url": "https://github.com/psf/requests/pull/1772#discussion_r8050016"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1772,
      "file_path": "requests/cookies.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -383,9 +383,11 @@ def morsel_to_cookie(morsel):\n         expires = time.time() + morsel[\"max-age\"]\n     elif morsel['expires']:\n         expires = morsel['expires']\n-        if type(expires) == type(\"\"):",
      "comment": "Will do, I'll update tomorrow. Just to clarify do you prefer squashing commits or new commits?\n",
      "comment_id": 8050123,
      "user": "mdbecker",
      "created_at": "2013-12-03T04:10:54Z",
      "url": "https://github.com/psf/requests/pull/1772#discussion_r8050123"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1772,
      "file_path": "requests/cookies.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -383,9 +383,11 @@ def morsel_to_cookie(morsel):\n         expires = time.time() + morsel[\"max-age\"]\n     elif morsel['expires']:\n         expires = morsel['expires']\n-        if type(expires) == type(\"\"):",
      "comment": "If you want to rebase those out you can, but you can also not worry about that all. Just add a new commit or two onto this branch and you'll be fine.\n",
      "comment_id": 8050218,
      "user": "sigmavirus24",
      "created_at": "2013-12-03T04:18:34Z",
      "url": "https://github.com/psf/requests/pull/1772#discussion_r8050218"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2049,
      "file_path": "requests/adapters.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -116,7 +119,30 @@ def init_poolmanager(self, connections, maxsize, block=DEFAULT_POOLBLOCK):\n         self._pool_block = block\n \n         self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize,\n-                                       block=block)\n+                                       block=block, **pool_kwargs)\n+\n+    def proxy_manager_for(self, proxy, **proxy_kwargs):\n+        \"\"\"Return urllib3 ProxyManager for the given proxy.\n+\n+        This method should not be called from user code, and is only\n+        exposed for use when subclassing the\n+        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.\n+\n+        :param proxy: The proxy to return a urllib3 ProxyManager for.\n+        :param proxy_kwargs: Extra keyword arguments used to configure the Proxy Manager.\n+        :returns: ProxyManager\n+        \"\"\"\n+        if not proxy in self.proxy_manager:\n+            proxy_headers = self.proxy_headers(proxy)\n+            self.proxy_manager[proxy] = proxy_from_url(\n+                                            proxy,\n+                                            proxy_headers=proxy_headers,\n+                                            num_pools=self._pool_connections,\n+                                            maxsize=self._pool_maxsize,\n+                                            block=self._pool_block,\n+                                            **proxy_kwargs)",
      "comment": "Kenneth is going to hate this indentation, can we fix it up? Should look like this:\n\n``` python\nself.proxy_manager[proxy] = proxy_from_url(\n    proxy,\n    proxy_headers=proxy_headers,\n    num_pools=self._pool_connections,\n    maxsize=self._pool_maxsize,\n    block=self._pool_block,\n    **proxy_kwargs\n)\n```\n",
      "comment_id": 13523524,
      "user": "Lukasa",
      "created_at": "2014-06-08T09:55:54Z",
      "url": "https://github.com/psf/requests/pull/2049#discussion_r13523524"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1937,
      "file_path": "requests/models.py",
      "line": 645,
      "side": "RIGHT",
      "diff_hunk": "@@ -642,12 +641,17 @@ def generate():\n \n             self._content_consumed = True\n \n-        gen = generate()\n+        # simulate reading small chunks of the content\n+        reused_chunks = iter_slices(self._content, chunk_size)",
      "comment": "Call me crazy but this would look better if it were simply:\n\n``` python\nif self._content_consumed:\n    chunks = iter_slices(self._content, chunk_size)\nelse:\n    chunks = generate()\n```\n\nTernaries are not used in the requests code base and are generally advised against by PEP8 (one of the few places requests' style and PEP8 happen to coincide). You're also unconditionally creating two iterators which incurs the cost of creation and garbage collection (which has two parts: decrementing the ref count and collecting the object on the next sweep of the garbage collector) as opposed to creating one iterator (and binding) and returning it.\n",
      "comment_id": 10284711,
      "user": "sigmavirus24",
      "created_at": "2014-03-05T01:40:59Z",
      "url": "https://github.com/psf/requests/pull/1937#discussion_r10284711"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1937,
      "file_path": "requests/models.py",
      "line": 645,
      "side": "RIGHT",
      "diff_hunk": "@@ -642,12 +641,17 @@ def generate():\n \n             self._content_consumed = True\n \n-        gen = generate()\n+        # simulate reading small chunks of the content\n+        reused_chunks = iter_slices(self._content, chunk_size)",
      "comment": "You're welcome to adjust the style to suit the projects' preferences. I prefer ternary statements for assignment because it communicates better:\n- the left hand argument is referenced exactly once.\n- the assignment is obvious (there's no code path that could avoid assignment).\n- the branch is obvious (one or the other).\n- there's no temptation to inject additional behavior as there might be with a code block.\n\nI did recognize the unconditional construction of the two iterators, but I considered the costs to be negligible. In general, I would only consider costs of function calls and object construction/destruction in highly sensitive tight loops. Perhaps this method falls into that category for some applications, but I suspect not as it's likely to be I/O bound instead. That said, if you wanted to keep the ternary operator but not have the unconditional construction, you could easily:\n\n```\nchunks = iter_slices(self._content, chunk_size) if self._content_consumed else generate()\n```\n\nI chose to create variables in an attempt to create more self-documenting code. Giving names to reused_chunks and stream_chunks adds clarity to the behavior. I believe the clarity of purpose outweighs the performance costs of unconditional construction.\n\nBut again, please feel free to accept my contribution as is and then tweak it to suit your preferences.\n",
      "comment_id": 10302494,
      "user": "jaraco",
      "created_at": "2014-03-05T15:10:19Z",
      "url": "https://github.com/psf/requests/pull/1937#discussion_r10302494"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1122,
      "file_path": "requests/models.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -121,7 +121,7 @@ def _encode_files(files, data):\n                 fp = StringIO(fp)\n             if isinstance(fp, bytes):\n                 fp = BytesIO(fp)\n-            \n+",
      "comment": "Sublime Text 2 keeps removing spaces or something, so this keeps ending up in my diffs. Might start just checking in hunks.\n",
      "comment_id": 2718245,
      "user": "Lukasa",
      "created_at": "2013-01-21T21:17:49Z",
      "url": "https://github.com/psf/requests/pull/1122#discussion_r2718245"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1122,
      "file_path": "requests/models.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -121,7 +121,7 @@ def _encode_files(files, data):\n                 fp = StringIO(fp)\n             if isinstance(fp, bytes):\n                 fp = BytesIO(fp)\n-            \n+",
      "comment": "This is good though. I've been thinking of running flake8 against this repo and making a bunch of similar changes. It drives me crazy when flake8 tells me how much is wrong with this repo. :P\n",
      "comment_id": 2720202,
      "user": "sigmavirus24",
      "created_at": "2013-01-22T00:28:05Z",
      "url": "https://github.com/psf/requests/pull/1122#discussion_r2720202"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1807,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -198,30 +198,48 @@ def set(self, name, value, **kwargs):\n         self.set_cookie(c)\n         return c\n \n+    def iterkeys(self):\n+        \"\"\"Dict-like iterkeys() that returns an iterator of names of cookies from the jar.\n+        See itervalues() and iteritems().\"\"\"\n+        for cookie in iter(self):\n+            yield cookie.name\n+\n     def keys(self):\n         \"\"\"Dict-like keys() that returns a list of names of cookies from the jar.\n         See values() and items().\"\"\"\n-        keys = []\n+        if is_py3:\n+            return self.iterkeys()",
      "comment": "On python3, what's returned is not an iterator but a \"View\", specifically a `KeysView`.\n",
      "comment_id": 8426441,
      "user": "sigmavirus24",
      "created_at": "2013-12-18T04:42:30Z",
      "url": "https://github.com/psf/requests/pull/1807#discussion_r8426441"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1807,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -198,30 +198,48 @@ def set(self, name, value, **kwargs):\n         self.set_cookie(c)\n         return c\n \n+    def iterkeys(self):\n+        \"\"\"Dict-like iterkeys() that returns an iterator of names of cookies from the jar.\n+        See itervalues() and iteritems().\"\"\"\n+        for cookie in iter(self):\n+            yield cookie.name\n+\n     def keys(self):\n         \"\"\"Dict-like keys() that returns a list of names of cookies from the jar.\n         See values() and items().\"\"\"\n-        keys = []\n+        if is_py3:\n+            return self.iterkeys()\n+        else:\n+            return list(self.iterkeys())\n+\n+    def itervalues(self):\n+        \"\"\"Dict-like itervalues() that returns an iterator of values of cookies from the jar.\n+        See iterkeys() and iteritems().\"\"\"\n         for cookie in iter(self):\n-            keys.append(cookie.name)\n-        return keys\n+            yield cookie.value\n \n     def values(self):\n         \"\"\"Dict-like values() that returns a list of values of cookies from the jar.\n         See keys() and items().\"\"\"\n-        values = []\n+        if is_py3:\n+            return self.itervalues()",
      "comment": "Same comment as above except that this actually returns a `ValuesView`. An iterator here is the _wrong_ thing to return.\n",
      "comment_id": 8426450,
      "user": "sigmavirus24",
      "created_at": "2013-12-18T04:43:11Z",
      "url": "https://github.com/psf/requests/pull/1807#discussion_r8426450"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1713,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -410,3 +411,28 @@ def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):\n                 cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))\n \n     return cookiejar\n+\n+\n+def merge_cookies(cookiejar, cookies):\n+    \"\"\"Add cookies to cookiejar and returns a merged CookieJar.\n+\n+    :param cookiejar: CookieJar object to add the cookies to.\n+    :param cookies: Dictionary or CookieJar object to be added.\n+    \"\"\"\n+    if not isinstance(cookiejar, cookielib.CookieJar):\n+        raise ValueError('You can only merge into CookieJar')\n+    \n+    if isinstance(cookies, dict):\n+        cookiejar = cookiejar_from_dict(\n+            cookies, cookiejar=cookiejar, overwrite=False)\n+    elif isinstance(cookies, cookielib.CookieJar):\n+        try:\n+            if hasattr(cookiejar, 'update'):\n+                cookiejar.update(cookies)\n+            else:\n+                raise CookieJarError",
      "comment": "From a purely stylistic perspective I'd rather this be\n\n``` python\ntry:\n    cookiejar.update(cookies)\nexcept AttributeError:\n    raise CookieJarError\n```\n",
      "comment_id": 7434681,
      "user": "Lukasa",
      "created_at": "2013-11-05T16:01:56Z",
      "url": "https://github.com/psf/requests/pull/1713#discussion_r7434681"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1713,
      "file_path": "requests/cookies.py",
      "line": 443,
      "side": "RIGHT",
      "diff_hunk": "@@ -410,3 +411,28 @@ def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):\n                 cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))\n \n     return cookiejar\n+\n+\n+def merge_cookies(cookiejar, cookies):\n+    \"\"\"Add cookies to cookiejar and returns a merged CookieJar.\n+\n+    :param cookiejar: CookieJar object to add the cookies to.\n+    :param cookies: Dictionary or CookieJar object to be added.\n+    \"\"\"\n+    if not isinstance(cookiejar, cookielib.CookieJar):\n+        raise ValueError('You can only merge into CookieJar')\n+    \n+    if isinstance(cookies, dict):\n+        cookiejar = cookiejar_from_dict(\n+            cookies, cookiejar=cookiejar, overwrite=False)\n+    elif isinstance(cookies, cookielib.CookieJar):\n+        try:\n+            try:\n+                cookiejar.update(cookies)\n+            except AttributeError:\n+                raise CookieJarError\n+        except CookieJarError:\n+            for cookie_in_jar in cookies:\n+                cookiejar.set_cookie(cookie_in_jar)",
      "comment": "Ah, sorry, I think we got our wires crossed here. There's no point throwing this exception if we're just going to catch it straight away. The right code here would be:\n\n``` python\ntry:\n    cookiejar.update(cookies)\nexcept AttributeError:\n    for cookie_in_jar in cookies:\n        cookierjar.set_cookie(cookie_in_jar)\n```\n",
      "comment_id": 7458284,
      "user": "Lukasa",
      "created_at": "2013-11-06T09:25:33Z",
      "url": "https://github.com/psf/requests/pull/1713#discussion_r7458284"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1836,
      "file_path": "docs/conf.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -43,7 +43,7 @@\n \n # General information about the project.\n project = u'Requests'\n-copyright = u'2013. A <a href=\"http://kennethreitz.com/pages/open-projects.html\">Kenneth Reitz</a> Project'\n+copyright = u'2014. A <a href=\"http://kennethreitz.com/pages/open-projects.html\">Kenneth Reitz</a> Project'",
      "comment": "maybe future-proof this? something like..\n\n```\nfrom datetime import date\n\ncopyright = str(date.today().year) + ' A <a href=\"...\"'\n```\n",
      "comment_id": 8676624,
      "user": "kevinburke",
      "created_at": "2014-01-06T20:39:01Z",
      "url": "https://github.com/psf/requests/pull/1836#discussion_r8676624"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1836,
      "file_path": "requests/__init__.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,7 +36,7 @@\n The other HTTP methods are supported - see `requests.api`. Full documentation\n is at <http://python-requests.org>.\n \n-:copyright: (c) 2013 by Kenneth Reitz.\n+:copyright: (c) 2014 by Kenneth Reitz.",
      "comment": "Regardless of how clever that might actually be, I'm worried it wouldn't be legally valid.\n",
      "comment_id": 8680909,
      "user": "sigmavirus24",
      "created_at": "2014-01-06T23:02:53Z",
      "url": "https://github.com/psf/requests/pull/1836#discussion_r8680909"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1836,
      "file_path": "requests/__init__.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,7 +36,7 @@\n The other HTTP methods are supported - see `requests.api`. Full documentation\n is at <http://python-requests.org>.\n \n-:copyright: (c) 2013 by Kenneth Reitz.\n+:copyright: (c) 2014 by Kenneth Reitz.",
      "comment": "Whoops... thought this was part of a Python string, never mind.\n",
      "comment_id": 8681064,
      "user": "kevinburke",
      "created_at": "2014-01-06T23:08:47Z",
      "url": "https://github.com/psf/requests/pull/1836#discussion_r8681064"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2115,
      "file_path": "requests/sessions.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -436,11 +436,11 @@ def request(self, method, url,\n                 proxies.setdefault(k, v)\n \n             # Look for configuration.\n-            if not verify and verify is not False:\n+            if verify is True or (verify is None and verify is not False):",
      "comment": "If `verify` _is_ `None`, could it possibly also be `False`?\n",
      "comment_id": 14464250,
      "user": "Lukasa",
      "created_at": "2014-07-02T15:39:48Z",
      "url": "https://github.com/psf/requests/pull/2115#discussion_r14464250"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,11 @@ def __delitem__(self, name):\n         \"\"\"Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name().\"\"\"\n         remove_cookie_by_name(self, name)\n \n+    def set_cookie(self, cookie, *args, **kwargs):\n+        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+            cookie.value = cookie.value.strip('\\\\\"')",
      "comment": "alternatively, use `cookie.value = cookie.value.replace('\\\\\"', '')` if we want to keep the double quotes, removing the `/`'s\n",
      "comment_id": 4969856,
      "user": "fcurella",
      "created_at": "2013-07-01T19:27:16Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r4969856"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,6 +170,11 @@ def test_cookie_removed_on_expire(self):\n         )\n         assert 'foo' not in s.cookies\n \n+    def test_cookie_quote_wrapped(self):\n+        s = requests.session()\n+        s.get(httpbin('cookies/set?foo=\"bar:baz\"'))\n+        self.assertTrue(s.cookies['foo'] == 'bar:baz')",
      "comment": "or `self.assertTrue(s.cookies['foo'] == '\"bar:baz\"')`?\n",
      "comment_id": 4969880,
      "user": "fcurella",
      "created_at": "2013-07-01T19:27:58Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r4969880"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "requests/cookies.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,11 @@ def __delitem__(self, name):\n         \"\"\"Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name().\"\"\"\n         remove_cookie_by_name(self, name)\n \n+    def set_cookie(self, cookie, *args, **kwargs):\n+        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+            cookie.value = cookie.value.replace('\\\\\"', '')\n+        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)",
      "comment": "What's this code doing now? It looks like you're going through cookies and removing all instances of `\\\"`...is that the right behaviour?\n",
      "comment_id": 5027439,
      "user": "Lukasa",
      "created_at": "2013-07-04T08:48:09Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r5027439"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "requests/cookies.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,11 @@ def __delitem__(self, name):\n         \"\"\"Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name().\"\"\"\n         remove_cookie_by_name(self, name)\n \n+    def set_cookie(self, cookie, *args, **kwargs):\n+        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+            cookie.value = cookie.value.replace('\\\\\"', '')\n+        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)",
      "comment": "@Lukasa going by what you quoted, I suspect not. Going one step further, the `*cookie-octent` you mention looks to be a URL-encoded string that doesn't allow `\"`, controls, whitespace, `,`, `;`, and `\\`.  The real problem then becomes, how do we add back the `\"`s (when necessary)?\n\nAlso @fcurella do you have an example of where the current implementation breaks (or rather a server breaks due to it)?\n",
      "comment_id": 5031863,
      "user": "sigmavirus24",
      "created_at": "2013-07-04T14:22:53Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r5031863"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "requests/cookies.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,11 @@ def __delitem__(self, name):\n         \"\"\"Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name().\"\"\"\n         remove_cookie_by_name(self, name)\n \n+    def set_cookie(self, cookie, *args, **kwargs):\n+        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+            cookie.value = cookie.value.replace('\\\\\"', '')\n+        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)",
      "comment": "@Lukasa currently, the `cookie.value` will be `'\"\\\\\"bar:baz\\\\\"\"'` (to clarify: double-quote, slash, double-quote, cookie_value, slash, double-quote, double-quote).\n\nIf we want to keep the quotes, we can't use `.strip()`. Maybe we can use a regex like `re.sub(r'\"\\\\\"(.*)\\\\\"\"', '\"$1\"', cookie.value)`, to make sure we remove only the two `\\\"` at the ends of the string.\n\n@sigmavirus24 the problem came up on a django project i'm working on, where one service would use `request.set_cookie(key, \"param1:param2\")`, and we're using requests on a different service and we need to forward the cookie to the browser.\n\nI've already verified that keeping the quotes (but not _escaping_ them) produces the correct cookie.\n\nMoreover,  when removing the quotes altogether (my previous solution), django will recognize the `:` and will add the quotes back again. I've done a quick test with Flask, and in this last scenario (unquoted cookie containing `:`) it doesn't quote the cookie value automatically.\n",
      "comment_id": 5034005,
      "user": "fcurella",
      "created_at": "2013-07-04T16:40:22Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r5034005"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "requests/cookies.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,11 @@ def __delitem__(self, name):\n         \"\"\"Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name().\"\"\"\n         remove_cookie_by_name(self, name)\n \n+    def set_cookie(self, cookie, *args, **kwargs):\n+        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+            cookie.value = cookie.value.replace('\\\\\"', '')\n+        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)",
      "comment": "Aha, that makes sense to me. It would be awesome if you could add a test just to verify that this is actuall what happens.\n",
      "comment_id": 5034783,
      "user": "Lukasa",
      "created_at": "2013-07-04T18:10:32Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r5034783"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "requests/cookies.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,11 @@ def __delitem__(self, name):\n         \"\"\"Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name().\"\"\"\n         remove_cookie_by_name(self, name)\n \n+    def set_cookie(self, cookie, *args, **kwargs):\n+        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+            cookie.value = cookie.value.replace('\\\\\"', '')\n+        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)",
      "comment": "@fcurella you mean `request.set_cookie(key, '\"param1:param2\"')` right? If so that makes sense. But yes, adding a test and ensuring this doesn't break anything else would be awesome.\n",
      "comment_id": 5034834,
      "user": "sigmavirus24",
      "created_at": "2013-07-04T18:16:23Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r5034834"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "requests/cookies.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,11 @@ def __delitem__(self, name):\n         \"\"\"Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name().\"\"\"\n         remove_cookie_by_name(self, name)\n \n+    def set_cookie(self, cookie, *args, **kwargs):\n+        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+            cookie.value = cookie.value.replace('\\\\\"', '')\n+        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)",
      "comment": "@sigmavirus24 no. if you call `response.set_cookie(key, 'param1:param2')` django will add the double-quotes implicitly because of the `:` (and other special characters, see https://github.com/django/django/blob/master/django/http/cookie.py#L23)\n\nLooking at the django code and its comments, this seems to be the desired behaviour and not due to a bug in django.\n\nRe tests: I'm already adding a new test for the parsing. Do you want me to include additional weirder cookie values?\n\nI'd also like your and @Lukasa's opinion on `.replace()` vs `re.sub()`. \n",
      "comment_id": 5035689,
      "user": "fcurella",
      "created_at": "2013-07-04T20:49:26Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r5035689"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "requests/cookies.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,11 @@ def __delitem__(self, name):\n         \"\"\"Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name().\"\"\"\n         remove_cookie_by_name(self, name)\n \n+    def set_cookie(self, cookie, *args, **kwargs):\n+        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+            cookie.value = cookie.value.replace('\\\\\"', '')\n+        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)",
      "comment": "> I'd also like your and @Lukasa's opinion on replace vs regex. \n\nMine has always been straight-forward, never use regex. Replace works well and \nit it is all we need currently. `re` is not the best implementation of regular \nexpressions in python and the others are not in the standard library. Beyond \nthat, string methods are fast.\n",
      "comment_id": 5035863,
      "user": "sigmavirus24",
      "created_at": "2013-07-04T21:18:30Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r5035863"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1440,
      "file_path": "requests/cookies.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,11 @@ def __delitem__(self, name):\n         \"\"\"Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name().\"\"\"\n         remove_cookie_by_name(self, name)\n \n+    def set_cookie(self, cookie, *args, **kwargs):\n+        if cookie.value.startswith('\"') and cookie.value.endswith('\"'):\n+            cookie.value = cookie.value.replace('\\\\\"', '')\n+        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)",
      "comment": "@sigmavirus24 +1. Regexes are only worth using if you're actually defining a complicated grammar. If you don't use a single regex special character, you didn't need a regex. =)\n",
      "comment_id": 5038877,
      "user": "Lukasa",
      "created_at": "2013-07-05T07:52:19Z",
      "url": "https://github.com/psf/requests/pull/1440#discussion_r5038877"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1900,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -725,11 +725,20 @@ def json(self, **kwargs):\n         if not self.encoding and len(self.content) > 3:\n             # No encoding set. JSON RFC 4627 section 3 states we should expect\n             # UTF-8, -16 or -32. Detect which one to use; If the detection or\n-            # decoding fails, fall back to `self.text` (using chardet to make\n+            # decoding fails, fall back to `self.text` (using charade to make",
      "comment": "We're actually using chardet again since that project has come back to life over at https://github.com/chardet/chardet.\n",
      "comment_id": 9380974,
      "user": "sigmavirus24",
      "created_at": "2014-02-03T12:27:35Z",
      "url": "https://github.com/psf/requests/pull/1900#discussion_r9380974"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1900,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -725,11 +725,20 @@ def json(self, **kwargs):\n         if not self.encoding and len(self.content) > 3:\n             # No encoding set. JSON RFC 4627 section 3 states we should expect\n             # UTF-8, -16 or -32. Detect which one to use; If the detection or\n-            # decoding fails, fall back to `self.text` (using chardet to make\n+            # decoding fails, fall back to `self.text` (using charade to make\n             # a best guess).\n             encoding = guess_json_utf(self.content)\n             if encoding is not None:\n-                return json.loads(self.content.decode(encoding), **kwargs)\n+                try:\n+                    return json.loads(self.content.decode(encoding), **kwargs)\n+                except UnicodeDecodeError:\n+                    # Wrong UTF codec detected; usually because it's not UTF-8\n+                    # but some other 8-bit codec.  This is an RFC violation,\n+                    # and the server didn't bother to tell us what codec *was*\n+                    # used.\n+                    pass\n+            log.warn('No encoding specified for JSON response, and no '",
      "comment": "Nowhere else in the file is logging used. Can you remove this line and the import at the top of the file please?\n",
      "comment_id": 9380998,
      "user": "sigmavirus24",
      "created_at": "2014-02-03T12:28:22Z",
      "url": "https://github.com/psf/requests/pull/1900#discussion_r9380998"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1900,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -725,11 +725,20 @@ def json(self, **kwargs):\n         if not self.encoding and len(self.content) > 3:\n             # No encoding set. JSON RFC 4627 section 3 states we should expect\n             # UTF-8, -16 or -32. Detect which one to use; If the detection or\n-            # decoding fails, fall back to `self.text` (using chardet to make\n+            # decoding fails, fall back to `self.text` (using charade to make\n             # a best guess).\n             encoding = guess_json_utf(self.content)\n             if encoding is not None:\n-                return json.loads(self.content.decode(encoding), **kwargs)\n+                try:\n+                    return json.loads(self.content.decode(encoding), **kwargs)\n+                except UnicodeDecodeError:\n+                    # Wrong UTF codec detected; usually because it's not UTF-8\n+                    # but some other 8-bit codec.  This is an RFC violation,\n+                    # and the server didn't bother to tell us what codec *was*\n+                    # used.\n+                    pass\n+            log.warn('No encoding specified for JSON response, and no '",
      "comment": "Why is that an argument to not start using it? I'll happily remove the `log.warn()` and remove the line at the top in a separate pull request (keeping lines of development separate), but I don't understand why we cannot start using logging for these kinds of problems now. :-)\n",
      "comment_id": 9381382,
      "user": "mjpieters",
      "created_at": "2014-02-03T12:47:54Z",
      "url": "https://github.com/psf/requests/pull/1900#discussion_r9381382"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1900,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -725,11 +725,20 @@ def json(self, **kwargs):\n         if not self.encoding and len(self.content) > 3:\n             # No encoding set. JSON RFC 4627 section 3 states we should expect\n             # UTF-8, -16 or -32. Detect which one to use; If the detection or\n-            # decoding fails, fall back to `self.text` (using chardet to make\n+            # decoding fails, fall back to `self.text` (using charade to make",
      "comment": "Ah, then you may want to update the comment on `def text(self)` as well.\n",
      "comment_id": 9381415,
      "user": "mjpieters",
      "created_at": "2014-02-03T12:49:19Z",
      "url": "https://github.com/psf/requests/pull/1900#discussion_r9381415"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1900,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -725,11 +725,20 @@ def json(self, **kwargs):\n         if not self.encoding and len(self.content) > 3:\n             # No encoding set. JSON RFC 4627 section 3 states we should expect\n             # UTF-8, -16 or -32. Detect which one to use; If the detection or\n-            # decoding fails, fall back to `self.text` (using chardet to make\n+            # decoding fails, fall back to `self.text` (using charade to make\n             # a best guess).\n             encoding = guess_json_utf(self.content)\n             if encoding is not None:\n-                return json.loads(self.content.decode(encoding), **kwargs)\n+                try:\n+                    return json.loads(self.content.decode(encoding), **kwargs)\n+                except UnicodeDecodeError:\n+                    # Wrong UTF codec detected; usually because it's not UTF-8\n+                    # but some other 8-bit codec.  This is an RFC violation,\n+                    # and the server didn't bother to tell us what codec *was*\n+                    # used.\n+                    pass\n+            log.warn('No encoding specified for JSON response, and no '",
      "comment": "Because @kennethreitz tore out logging in 1.0 with malice. The fact that the logger object and import stuck around does not change that.\n",
      "comment_id": 9381438,
      "user": "sigmavirus24",
      "created_at": "2014-02-03T12:50:32Z",
      "url": "https://github.com/psf/requests/pull/1900#discussion_r9381438"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1900,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -725,11 +725,20 @@ def json(self, **kwargs):\n         if not self.encoding and len(self.content) > 3:\n             # No encoding set. JSON RFC 4627 section 3 states we should expect\n             # UTF-8, -16 or -32. Detect which one to use; If the detection or\n-            # decoding fails, fall back to `self.text` (using chardet to make\n+            # decoding fails, fall back to `self.text` (using charade to make",
      "comment": "I was looking at an outdated master branch, there was only one reference left; see #1901 for a pull removing that one reference.\n",
      "comment_id": 9382598,
      "user": "mjpieters",
      "created_at": "2014-02-03T13:42:38Z",
      "url": "https://github.com/psf/requests/pull/1900#discussion_r9382598"
    },
    {
      "repo": "psf/requests",
      "pr_number": 316,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -597,7 +599,7 @@ def iter_lines(self, newlines=None, decode_unicode=None):\n         def generate():\n             chunk = []\n \n-            while 1:\n+            while True:",
      "comment": "Gah. I'm an idiot. I undid this particular change in subsequent commits. In case it's not painfully obvious, I'm still figuring out git.\n",
      "comment_id": 312604,
      "user": "atdt",
      "created_at": "2011-12-22T23:02:27Z",
      "url": "https://github.com/psf/requests/pull/316#discussion_r312604"
    },
    {
      "repo": "psf/requests",
      "pr_number": 313,
      "file_path": "requests/models.py",
      "line": 600,
      "side": "RIGHT",
      "diff_hunk": "@@ -597,7 +597,7 @@ def iter_lines(self, newlines=None, decode_unicode=None):\n         def generate():\n             chunk = []\n \n-            while 1:\n+            while True:",
      "comment": "Oops, sorry. This snuck into my commit unintentionally. It's not related to the iter_lines bug at all. My understanding is that '`while 1:`' is slightly more performant, while '`while True:`' is a bit clearer. Whether or not the optimization is warranted in this case is above my league.\n",
      "comment_id": 304833,
      "user": "atdt",
      "created_at": "2011-12-20T07:17:33Z",
      "url": "https://github.com/psf/requests/pull/313#discussion_r304833"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2148,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -720,6 +720,18 @@ def read_mock(amt, decode_content=None):\n         assert next(iter(r))\n         io.close()\n \n+    def test_iter_content_handles_socket_error(self):\n+        r = requests.Response()\n+        import socket\n+\n+        class RawMock(object):\n+            def stream(self, chunk_size, decode_content=None):\n+                raise socket.error()\n+\n+        setattr(r, 'raw', RawMock())",
      "comment": "I missed the `setattr` call. I second this. Could you just change this quickly @romanlevin?\n",
      "comment_id": 15373551,
      "user": "sigmavirus24",
      "created_at": "2014-07-24T21:18:11Z",
      "url": "https://github.com/psf/requests/pull/2148#discussion_r15373551"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2168,
      "file_path": "requests/sessions.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,10 +91,17 @@ def resolve_redirects(self, resp, req, stream=False, timeout=None,\n         \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n \n         i = 0\n+        hist = [] #keep track of history\n \n         while resp.is_redirect:\n             prepared_request = req.copy()\n \n+            if i > 0:\n+                #create deep copy of the history and keep track of redirects",
      "comment": "This comment is a bit misleading: you're _not_ taking a deep copy here, which is a good thing.\n",
      "comment_id": 16338153,
      "user": "Lukasa",
      "created_at": "2014-08-18T05:56:21Z",
      "url": "https://github.com/psf/requests/pull/2168#discussion_r16338153"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2168,
      "file_path": "test_requests.py",
      "line": 984,
      "side": "RIGHT",
      "diff_hunk": "@@ -974,6 +974,13 @@ def test_basic_auth_str_is_always_native(self):\n         assert isinstance(s, builtin_str)\n         assert s == \"Basic dGVzdDp0ZXN0\"\n \n+    def test_requests_history_is_saved(self):\n+        r = requests.get('https://httpbin.org/redirect/5')\n+        count = 0\n+        for item in r.history:\n+            assert len(item.history) == count\n+            count = count + 1\n+",
      "comment": "Can we make this test a bit more rigorous? We should be able to assert that each item has the correct slice of the history as well.\n",
      "comment_id": 16338170,
      "user": "Lukasa",
      "created_at": "2014-08-18T05:57:00Z",
      "url": "https://github.com/psf/requests/pull/2168#discussion_r16338170"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1832,
      "file_path": "requests/adapters.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,14 +55,16 @@ class HTTPAdapter(BaseAdapter):\n \n     :param pool_connections: The number of urllib3 connection pools to cache.\n     :param pool_maxsize: The maximum number of connections to save in the pool.\n-    :param max_retries: The maximum number of retries each connection should attempt.\n+    :param int max_retries: The maximum number of retries each connection\n+        should attempt. Note, this applies only to failed connections and\n+        timeouts, never to requests where the server returns a response.\n     :param pool_block: Whether the connection pool should block for connections.\n \n     Usage::\n \n       >>> import requests\n       >>> s = requests.Session()\n-      >>> a = requests.adapters.HTTPAdapter()\n+      >>> a = requests.adapters.HTTPAdapter(max_retries=3)",
      "comment": "The idea is to show the reader (one reason) why they'd want to use an Adapter, as the given example doesn't change the functionality of the code at all.\n",
      "comment_id": 8576728,
      "user": "kevinburke",
      "created_at": "2013-12-28T17:01:47Z",
      "url": "https://github.com/psf/requests/pull/1832#discussion_r8576728"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2178,
      "file_path": "requests/sessions.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -612,6 +592,32 @@ def send(self, request, **kwargs):\n \n         return r\n \n+    def merge_environment_settings(self, url, proxies, stream, verify, cert):\n+        \"\"\"Checks the environment and merges it with some settings.\"\"\"\n+        # Gather clues from the surrounding environment.\n+        if self.trust_env:\n+            # Set environment's proxies.\n+            env_proxies = get_environ_proxies(url) or {}\n+            for (k, v) in env_proxies.items():\n+                proxies.setdefault(k, v)\n+\n+            # Look for configuration.\n+            if verify is True or verify is None:\n+                verify = os.environ.get('REQUESTS_CA_BUNDLE')\n+\n+            # Curl compatibility.\n+            if verify is True or verify is None:\n+                verify = os.environ.get('CURL_CA_BUNDLE')",
      "comment": "While we're here, these two conditional blocks make me feel a bit uncomfortable. Maybe combine the two? Something like:\n\n``` python\nif verify is True or verify is None:\n    verify = os.environ.get('REQUESTS_CA_BUNDLE') or os.environ.get('CURL_CA_BUNDLE')\n```\n\nObviously there's a line length issue here, but I feel like it's a little cleaner. We'd need to update the commenting too.\n\nI'm not hugely attached to it, what do you think?\n",
      "comment_id": 16632859,
      "user": "Lukasa",
      "created_at": "2014-08-23T21:39:33Z",
      "url": "https://github.com/psf/requests/pull/2178#discussion_r16632859"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2178,
      "file_path": "requests/sessions.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -612,6 +592,32 @@ def send(self, request, **kwargs):\n \n         return r\n \n+    def merge_environment_settings(self, url, proxies, stream, verify, cert):\n+        \"\"\"Checks the environment and merges it with some settings.\"\"\"\n+        # Gather clues from the surrounding environment.\n+        if self.trust_env:\n+            # Set environment's proxies.\n+            env_proxies = get_environ_proxies(url) or {}\n+            for (k, v) in env_proxies.items():\n+                proxies.setdefault(k, v)\n+\n+            # Look for configuration.\n+            if verify is True or verify is None:\n+                verify = os.environ.get('REQUESTS_CA_BUNDLE')\n+\n+            # Curl compatibility.\n+            if verify is True or verify is None:\n+                verify = os.environ.get('CURL_CA_BUNDLE')",
      "comment": "I agree. I never liked the duplicated check, but didn't want to add noise to the PR =P\n",
      "comment_id": 16636190,
      "user": "sigmavirus24",
      "created_at": "2014-08-24T14:52:59Z",
      "url": "https://github.com/psf/requests/pull/2178#discussion_r16636190"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2176,
      "file_path": "requests/adapters.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,7 +331,21 @@ def send(self, request, stream=False, timeout=None, verify=True, cert=None, prox\n \n         chunked = not (request.body is None or 'Content-Length' in request.headers)\n \n-        timeout = TimeoutSauce(connect=timeout, read=timeout)\n+        if isinstance(timeout, tuple):\n+            try:\n+                connect, read = timeout\n+                timeout = TimeoutSauce(connect=connect, read=read)\n+            except ValueError as e:\n+                try:\n+                    err = (\"Invalid timeout {0}. Pass a (connect, read) \"\n+                           \"timeout tuple, or a single float to set \"\n+                           \"both timeouts to the same value\".format(timeout))\n+                except Exception:\n+                    # string formatting failed.\n+                    raise ValueError(e)",
      "comment": "Ah, who cares, if the user passed us something so insane that we can't format the string then let's just throw that exception.\n",
      "comment_id": 16632478,
      "user": "Lukasa",
      "created_at": "2014-08-23T19:59:25Z",
      "url": "https://github.com/psf/requests/pull/2176#discussion_r16632478"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2176,
      "file_path": "requests/exceptions.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +44,22 @@ class SSLError(ConnectionError):\n \n \n class Timeout(RequestException):\n-    \"\"\"The request timed out.\"\"\"\n+    \"\"\"The request timed out.\n+\n+    Catching this error will catch both :exc:`ConnectTimeout` and\n+    :exc:`ReadTimeout` errors.\n+    \"\"\"\n+\n+\n+class ConnectTimeout(Timeout):\n+    \"\"\" The request timed out while trying to connect to the server.\n+\n+    Requests that produce this error are safe to retry\n+    \"\"\"\n+\n+\n+class ReadTimeout(Timeout):\n+    \"\"\"The server did not send any data in the allotted amount of time.\"\"\"",
      "comment": "Let's stop and think about our exception heirarchy.\n\nCurrently this is a breaking change, because in situations where we previously would have thrown a `ConnectionError` we'll now throw a `ConnectTimeout`, which will not get caught. Should we be making the `Timeout` exception a subclass of `ConnectionError`? @sigmavirus24 \n",
      "comment_id": 16634483,
      "user": "Lukasa",
      "created_at": "2014-08-24T06:09:55Z",
      "url": "https://github.com/psf/requests/pull/2176#discussion_r16634483"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2176,
      "file_path": "requests/structures.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,7 +35,7 @@ class CaseInsensitiveDict(collections.MutableMapping):\n     of how the header name was originally stored.\n \n     If the constructor, ``.update``, or equality comparison\n-    operations are given keys that have equal ``.lower()``s, the\n+    operations are given keys that have equal ``.lower()`` s, the",
      "comment": "reStructuredText doesn't like having the `s` right against plain-text block. To achieve what I think you want, you need \n\n``` rst\n``.lower()``\\ s\n```\n",
      "comment_id": 16636208,
      "user": "sigmavirus24",
      "created_at": "2014-08-24T14:56:16Z",
      "url": "https://github.com/psf/requests/pull/2176#discussion_r16636208"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2176,
      "file_path": "requests/exceptions.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +44,22 @@ class SSLError(ConnectionError):\n \n \n class Timeout(RequestException):\n-    \"\"\"The request timed out.\"\"\"\n+    \"\"\"The request timed out.\n+\n+    Catching this error will catch both :exc:`ConnectTimeout` and\n+    :exc:`ReadTimeout` errors.\n+    \"\"\"\n+\n+\n+class ConnectTimeout(Timeout):\n+    \"\"\" The request timed out while trying to connect to the server.",
      "comment": "No leading space between triple-quotes and first letter of the docstring.\n",
      "comment_id": 16636225,
      "user": "sigmavirus24",
      "created_at": "2014-08-24T14:57:47Z",
      "url": "https://github.com/psf/requests/pull/2176#discussion_r16636225"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2176,
      "file_path": "requests/structures.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,7 +35,7 @@ class CaseInsensitiveDict(collections.MutableMapping):\n     of how the header name was originally stored.\n \n     If the constructor, ``.update``, or equality comparison\n-    operations are given keys that have equal ``.lower()``s, the\n+    operations are given keys that have equal ``.lower()`` s, the",
      "comment": "Really? I don't think I've ever seen a problem, but maybe I've only ever done it with Markdown.\n",
      "comment_id": 16636237,
      "user": "Lukasa",
      "created_at": "2014-08-24T15:01:12Z",
      "url": "https://github.com/psf/requests/pull/2176#discussion_r16636237"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2176,
      "file_path": "requests/exceptions.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +44,22 @@ class SSLError(ConnectionError):\n \n \n class Timeout(RequestException):\n-    \"\"\"The request timed out.\"\"\"\n+    \"\"\"The request timed out.\n+\n+    Catching this error will catch both :exc:`ConnectTimeout` and\n+    :exc:`ReadTimeout` errors.\n+    \"\"\"\n+\n+\n+class ConnectTimeout(Timeout):\n+    \"\"\" The request timed out while trying to connect to the server.\n+\n+    Requests that produce this error are safe to retry\n+    \"\"\"\n+\n+\n+class ReadTimeout(Timeout):\n+    \"\"\"The server did not send any data in the allotted amount of time.\"\"\"",
      "comment": "So I agree 100% that the fact this is a breaking change is important. Sub-classing `ConnectionError` is definitely the way to have backwards compatibility, but I'm not confident that all `Timeout` errors should inherit from it. `ConnectTimeout` makes perfect sense. A read timeout is different to me. There's no error in the connection itself. We were able to create it and maintain it. We are the ones terminating it arbitrarily because the user asked us to. There's no \"error\" there. Does that make sense? It's purely semantics, and I'm not entirely against having `Timeout` inherit from `ConnectionError`, I just don't know if it's the most correct way to do it.\n",
      "comment_id": 16636255,
      "user": "sigmavirus24",
      "created_at": "2014-08-24T15:03:33Z",
      "url": "https://github.com/psf/requests/pull/2176#discussion_r16636255"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2176,
      "file_path": "requests/exceptions.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +44,22 @@ class SSLError(ConnectionError):\n \n \n class Timeout(RequestException):\n-    \"\"\"The request timed out.\"\"\"\n+    \"\"\"The request timed out.\n+\n+    Catching this error will catch both :exc:`ConnectTimeout` and\n+    :exc:`ReadTimeout` errors.\n+    \"\"\"\n+\n+\n+class ConnectTimeout(Timeout):\n+    \"\"\" The request timed out while trying to connect to the server.\n+\n+    Requests that produce this error are safe to retry\n+    \"\"\"\n+\n+\n+class ReadTimeout(Timeout):\n+    \"\"\"The server did not send any data in the allotted amount of time.\"\"\"",
      "comment": "I think having `ConnectTimeout` multiply-inherit from `ConnectionError` and `Timeout` will assuage my fears, and resolve the breaking change. I agree that it feels more conceptually appropriate.\n",
      "comment_id": 16636277,
      "user": "Lukasa",
      "created_at": "2014-08-24T15:08:09Z",
      "url": "https://github.com/psf/requests/pull/2176#discussion_r16636277"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2176,
      "file_path": "requests/structures.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,7 +35,7 @@ class CaseInsensitiveDict(collections.MutableMapping):\n     of how the header name was originally stored.\n \n     If the constructor, ``.update``, or equality comparison\n-    operations are given keys that have equal ``.lower()``s, the\n+    operations are given keys that have equal ``.lower()`` s, the",
      "comment": "github3.py does it in the docstrings often. This also applies to internal references, e.g.,\n\n``` rst\n:class:`User <github3.users.User>`\\ s\n```\n",
      "comment_id": 16636326,
      "user": "sigmavirus24",
      "created_at": "2014-08-24T15:17:37Z",
      "url": "https://github.com/psf/requests/pull/2176#discussion_r16636326"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2176,
      "file_path": "requests/structures.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,7 +35,7 @@ class CaseInsensitiveDict(collections.MutableMapping):\n     of how the header name was originally stored.\n \n     If the constructor, ``.update``, or equality comparison\n-    operations are given keys that have equal ``.lower()``s, the\n+    operations are given keys that have equal ``.lower()`` s, the",
      "comment": "So, this is sort of silly. My initial idea was to add the Timeout class from urllib3 to the docs and add an \"internals\" docs page. Since we're not using that interface I decided not to do it, ended up just reverting this change.\n",
      "comment_id": 16640746,
      "user": "kevinburke",
      "created_at": "2014-08-25T02:48:49Z",
      "url": "https://github.com/psf/requests/pull/2176#discussion_r16640746"
    },
    {
      "repo": "psf/requests",
      "pr_number": 1935,
      "file_path": "test_requests.py",
      "line": 1172,
      "side": "RIGHT",
      "diff_hunk": "@@ -1170,6 +1170,15 @@ def test_max_age_invalid_str(self):\n         with pytest.raises(TypeError):\n             morsel_to_cookie(morsel)\n ",
      "comment": "We should probably PEP8 this: can we get an extra blank line here?\n",
      "comment_id": 10180894,
      "user": "Lukasa",
      "created_at": "2014-02-28T20:53:14Z",
      "url": "https://github.com/psf/requests/pull/1935#discussion_r10180894"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2223,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -334,7 +334,9 @@ def prepare_url(self, url, params):\n         except UnicodeDecodeError:\n             pass\n \n-        # Don't do any URL preparation for oddball schemes\n+        # Don't do any URL preparation for oddball schemes like `mailto`,",
      "comment": "While you're here, let's remove the usage of `oddball` it's offensive. We should say `non-HTTP`\n",
      "comment_id": 17486844,
      "user": "sigmavirus24",
      "created_at": "2014-09-12T16:03:11Z",
      "url": "https://github.com/psf/requests/pull/2223#discussion_r17486844"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2222,
      "file_path": "test_requests.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,12 @@ def test_entry_points(self):\n     def test_invalid_url(self):\n         with pytest.raises(MissingSchema):\n             requests.get('hiwpefhipowhefopw')\n+        with pytest.raises(InvalidSchema):\n+            requests.get('localhost:3128')\n+        with pytest.raises(InvalidSchema):",
      "comment": "This test and the test below are exactly the same test case since `urlparse` parses them in the exact same way:\n\n``` pycon\n>>> urlparse.urlparse('localhost.localdomain:3128/')\nParseResult(scheme='localhost.localdomain', netloc='', path='3128/', params='', query='', fragment='')\n>>> urlparse.urlparse('10.122.1.1:3128/')\nParseResult(scheme='10.122.1.1', netloc='', path='3128/', params='', query='', fragment='')\n```\n\nThey should be consolidated.\n",
      "comment_id": 17480767,
      "user": "sigmavirus24",
      "created_at": "2014-09-12T14:18:23Z",
      "url": "https://github.com/psf/requests/pull/2222#discussion_r17480767"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2222,
      "file_path": "test_requests.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,12 @@ def test_entry_points(self):\n     def test_invalid_url(self):\n         with pytest.raises(MissingSchema):\n             requests.get('hiwpefhipowhefopw')\n+        with pytest.raises(InvalidSchema):\n+            requests.get('localhost:3128')\n+        with pytest.raises(InvalidSchema):",
      "comment": "@sigmavirus24 \nI would argue that this is an implementation detail, and the test should be independent of this, and it's better to have more tests than less.\nIt might happen that the test for skipping wouldn't catch IP addresses, but only domains.\n\nFor example, given an IP address and/or the dots in the \"scheme\", it would be possible to not use this as a scheme. These tests are meant to keep this behavior.\n",
      "comment_id": 17483864,
      "user": "blueyed",
      "created_at": "2014-09-12T15:11:05Z",
      "url": "https://github.com/psf/requests/pull/2222#discussion_r17483864"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2222,
      "file_path": "test_requests.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,12 @@ def test_entry_points(self):\n     def test_invalid_url(self):\n         with pytest.raises(MissingSchema):\n             requests.get('hiwpefhipowhefopw')\n+        with pytest.raises(InvalidSchema):\n+            requests.get('localhost:3128')\n+        with pytest.raises(InvalidSchema):",
      "comment": "They are still functionally equivalent. They're not an implementation detail because as I mentioned, RFC 3986 has no way of identifying that the part before the `:` here is not a scheme. So any specification compliant implementation will do this, ergo it's a specification detail that makes these tests functionally equivalent.\n",
      "comment_id": 17485897,
      "user": "sigmavirus24",
      "created_at": "2014-09-12T15:45:15Z",
      "url": "https://github.com/psf/requests/pull/2222#discussion_r17485897"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2222,
      "file_path": "test_requests.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,12 @@ def test_entry_points(self):\n     def test_invalid_url(self):\n         with pytest.raises(MissingSchema):\n             requests.get('hiwpefhipowhefopw')\n+        with pytest.raises(InvalidSchema):\n+            requests.get('localhost:3128')\n+        with pytest.raises(InvalidSchema):",
      "comment": "What I've meant is that this tests the skipping code: if this was changed, e.g. by using a more sophisticated regex, the behavior might change and this additional test might catch it.\n",
      "comment_id": 17487277,
      "user": "blueyed",
      "created_at": "2014-09-12T16:11:13Z",
      "url": "https://github.com/psf/requests/pull/2222#discussion_r17487277"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2222,
      "file_path": "test_requests.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,12 @@ def test_entry_points(self):\n     def test_invalid_url(self):\n         with pytest.raises(MissingSchema):\n             requests.get('hiwpefhipowhefopw')\n+        with pytest.raises(InvalidSchema):\n+            requests.get('localhost:3128')\n+        with pytest.raises(InvalidSchema):",
      "comment": "We don't currently have a regular expression that does this. We have 3 options as I see them:\n1. continue to rely on `urlparse` from the standard library\n2. use `urllib3`'s URL parser\n3. use `rfc3986`'s URI parser\n\nThey all, to varying degrees, follow the specification and will have very similar, if not exactly the same behaviour. We are far more likely to rely on third party libraries that do things efficiently to regular expressions that we put together ourselves.\n",
      "comment_id": 17489132,
      "user": "sigmavirus24",
      "created_at": "2014-09-12T16:47:52Z",
      "url": "https://github.com/psf/requests/pull/2222#discussion_r17489132"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2222,
      "file_path": "test_requests.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,12 @@ def test_entry_points(self):\n     def test_invalid_url(self):\n         with pytest.raises(MissingSchema):\n             requests.get('hiwpefhipowhefopw')\n+        with pytest.raises(InvalidSchema):\n+            requests.get('localhost:3128')\n+        with pytest.raises(InvalidSchema):",
      "comment": "I am referring to this code (https://github.com/kennethreitz/requests/blob/master/requests/models.py#L337-L342):\n\n```\n    if ':' in url and not url.lower().startswith('http'):\n        self.url = url\n        return\n```\n\nIf this would get changed, an IP address might get handled different from a hostname.\n\nHere btw `urllib3`s URL parser is being used further down.\n",
      "comment_id": 17490866,
      "user": "blueyed",
      "created_at": "2014-09-12T17:22:09Z",
      "url": "https://github.com/psf/requests/pull/2222#discussion_r17490866"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2222,
      "file_path": "test_requests.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,12 @@ def test_entry_points(self):\n     def test_invalid_url(self):\n         with pytest.raises(MissingSchema):\n             requests.get('hiwpefhipowhefopw')\n+        with pytest.raises(InvalidSchema):\n+            requests.get('localhost:3128')\n+        with pytest.raises(InvalidSchema):",
      "comment": "Ah, forgive me @blueyed. I was mistaking the discussion here for one of the other issues you've filed recently. \n",
      "comment_id": 17497144,
      "user": "sigmavirus24",
      "created_at": "2014-09-12T19:10:14Z",
      "url": "https://github.com/psf/requests/pull/2222#discussion_r17497144"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2238,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -326,13 +326,20 @@ def prepare_method(self, method):\n     def prepare_url(self, url, params):\n         \"\"\"Prepares the given HTTP URL.\"\"\"\n         #: Accept objects that have string representations.\n-        try:\n-            url = unicode(url)\n-        except NameError:\n-            # We're on Python 3.\n-            url = str(url)\n-        except UnicodeDecodeError:\n-            pass\n+        #: We're unable to blindy call unicode/str functions\n+        #: as this will include the bytestring indicator (b'')\n+        #: on python 3.x.\n+        #: https://github.com/kennethreitz/requests/pull/2238\n+        if not is_py2:",
      "comment": "Would this be acceptable:\n\n``` python\ntry:\n    url = url.decode('utf8')\nexcept AttributeError:\n    url = unicode(url) if not is_py2 else str(url)\n```\n",
      "comment_id": 18229317,
      "user": "sigmavirus24",
      "created_at": "2014-09-30T16:35:04Z",
      "url": "https://github.com/psf/requests/pull/2238#discussion_r18229317"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2238,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -326,13 +326,20 @@ def prepare_method(self, method):\n     def prepare_url(self, url, params):\n         \"\"\"Prepares the given HTTP URL.\"\"\"\n         #: Accept objects that have string representations.\n-        try:\n-            url = unicode(url)\n-        except NameError:\n-            # We're on Python 3.\n-            url = str(url)\n-        except UnicodeDecodeError:\n-            pass\n+        #: We're unable to blindy call unicode/str functions\n+        #: as this will include the bytestring indicator (b'')\n+        #: on python 3.x.\n+        #: https://github.com/kennethreitz/requests/pull/2238\n+        if not is_py2:",
      "comment": "That's nice and succinct, have ammended and pushed\n",
      "comment_id": 18237157,
      "user": "joealcorn",
      "created_at": "2014-09-30T18:29:40Z",
      "url": "https://github.com/psf/requests/pull/2238#discussion_r18237157"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2241,
      "file_path": "requests/models.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -655,8 +655,12 @@ def generate():\n \n             self._content_consumed = True\n \n-        # simulate reading small chunks of the content\n-        reused_chunks = iter_slices(self._content, chunk_size)\n+        if self._content_consumed and isinstance(self._content, bool):\n+            raise RuntimeError(\n+                        'The content for this response was already consumed')\n+        else:",
      "comment": "No need for the `else` or the subsequent indentation, we won't get this far if we raise anyway.\n",
      "comment_id": 17860683,
      "user": "Lukasa",
      "created_at": "2014-09-22T16:39:59Z",
      "url": "https://github.com/psf/requests/pull/2241#discussion_r17860683"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2241,
      "file_path": "requests/exceptions.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,3 +89,6 @@ class ChunkedEncodingError(RequestException):\n \n class ContentDecodingError(RequestException, BaseHTTPError):\n     \"\"\"Failed to decode response content\"\"\"\n+\n+class StreamConsumedError(RequestException):",
      "comment": "This needs to doubly inherit, like so:\n\n``` python\nclass StreamConsumedError(RequestException, TypeError):\n```\n",
      "comment_id": 17873814,
      "user": "sigmavirus24",
      "created_at": "2014-09-22T19:55:51Z",
      "url": "https://github.com/psf/requests/pull/2241#discussion_r17873814"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2271,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -567,7 +567,7 @@ def parse_header_links(value):\n \n     replace_chars = \" '\\\"\"\n \n-    for val in value.split(\",\"):\n+    for val in re.split(\",\\ *<\",value):",
      "comment": "Also, please put a ` `after the comma, e.g.,`split(\",\\ *<\", value)`.\n",
      "comment_id": 18650977,
      "user": "sigmavirus24",
      "created_at": "2014-10-09T15:07:40Z",
      "url": "https://github.com/psf/requests/pull/2271#discussion_r18650977"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2271,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -567,7 +567,7 @@ def parse_header_links(value):\n \n     replace_chars = \" '\\\"\"\n \n-    for val in value.split(\",\"):\n+    for val in re.split(\",\\ *<\",value):",
      "comment": "Done\n\nOn Thu, Oct 9, 2014 at 8:07 AM, Ian Cordasco notifications@github.com\nwrote:\n\n> In requests/utils.py:\n> \n> > @@ -567,7 +567,7 @@ def parse_header_links(value):\n> > \n> > ```\n> >  replace_chars = \" '\\\"\"\n> > ```\n> > -    for val in value.split(\",\"):\n> > -    for val in re.split(\",\\ *<\",value):\n> \n> Also, please put a after the comma, e.g., split(\",\\ *<\", value).\n> \n> \u2014\n> Reply to this email directly or view it on GitHub\n> https://github.com/kennethreitz/requests/pull/2271/files#r18650977.\n",
      "comment_id": 18673012,
      "user": "mikecool1000",
      "created_at": "2014-10-09T20:46:41Z",
      "url": "https://github.com/psf/requests/pull/2271#discussion_r18673012"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2271,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -567,7 +567,7 @@ def parse_header_links(value):\n \n     replace_chars = \" '\\\"\"\n \n-    for val in value.split(\",\"):\n+    for val in re.split(\",\\ *<\", value):",
      "comment": "Why do you have a `\\` in the expression? I'm very certain that's unnecessary if you're trying to say \"zero or more ` `s\".\n",
      "comment_id": 18708681,
      "user": "sigmavirus24",
      "created_at": "2014-10-10T14:25:26Z",
      "url": "https://github.com/psf/requests/pull/2271#discussion_r18708681"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2271,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -567,7 +567,7 @@ def parse_header_links(value):\n \n     replace_chars = \" '\\\"\"\n \n-    for val in value.split(\",\"):\n+    for val in re.split(\",\\ *<\", value):",
      "comment": "You're completely right, sorry I do most of my regex in js, where it would be necessary sometimes\n",
      "comment_id": 18716851,
      "user": "mikecool1000",
      "created_at": "2014-10-10T16:52:51Z",
      "url": "https://github.com/psf/requests/pull/2271#discussion_r18716851"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2349,
      "file_path": "requests/sessions.py",
      "line": 276,
      "side": "RIGHT",
      "diff_hunk": "@@ -274,7 +276,7 @@ class Session(SessionRedirectMixin):\n     __attrs__ = [",
      "comment": "does this at all affect the publicly exportable interface for the class?\n",
      "comment_id": 20485209,
      "user": "kevinburke",
      "created_at": "2014-11-18T04:29:00Z",
      "url": "https://github.com/psf/requests/pull/2349#discussion_r20485209"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2363,
      "file_path": "test_requests.py",
      "line": 1012,
      "side": "RIGHT",
      "diff_hunk": "@@ -1008,12 +1008,12 @@ def test_basic_auth_str_is_always_native(self):\n         assert s == \"Basic dGVzdDp0ZXN0\"\n \n     def test_requests_history_is_saved(self):\n-        r = requests.get('https://httpbin.org/redirect/5')\n+        r = requests.get(httpbin('redirect/5'))\n         total = r.history[-1].history",
      "comment": "Feedback from IRC (@alex in particular): just use enumerate for this loop to eliminate the need to use `i` as a counter\n",
      "comment_id": 21125376,
      "user": "sigmavirus24",
      "created_at": "2014-12-01T22:30:50Z",
      "url": "https://github.com/psf/requests/pull/2363#discussion_r21125376"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2390,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,26 +157,28 @@ class CookieConflictError(RuntimeError):\n \n \n class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n-    \"\"\"Compatibility class; is a cookielib.CookieJar, but exposes a dict interface.\n+    \"\"\"Compatibility class; is a cookielib.CookieJar, but exposes a dict\n+    interface.\n \n     This is the CookieJar we create by default for requests and sessions that\n     don't specify one, since some clients may expect response.cookies and\n     session.cookies to support dict operations.\n \n-    Don't use the dict interface internally; it's just for compatibility with\n-    with external client code. All `requests` code should work out of the box\n-    with externally provided instances of CookieJar, e.g., LWPCookieJar and\n-    FileCookieJar.\n-\n-    Caution: dictionary operations that are normally O(1) may be O(n).\n+    Requests does not use the dict interface internally; it's just for\n+    compatibility with external client code. All `requests` code should work",
      "comment": "Not your fault, but this should be double backticks around requests.\n",
      "comment_id": 22257300,
      "user": "sigmavirus24",
      "created_at": "2014-12-24T14:46:39Z",
      "url": "https://github.com/psf/requests/pull/2390#discussion_r22257300"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2390,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,26 +157,28 @@ class CookieConflictError(RuntimeError):\n \n \n class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):\n-    \"\"\"Compatibility class; is a cookielib.CookieJar, but exposes a dict interface.\n+    \"\"\"Compatibility class; is a cookielib.CookieJar, but exposes a dict\n+    interface.\n \n     This is the CookieJar we create by default for requests and sessions that\n     don't specify one, since some clients may expect response.cookies and\n     session.cookies to support dict operations.\n \n-    Don't use the dict interface internally; it's just for compatibility with\n-    with external client code. All `requests` code should work out of the box\n-    with externally provided instances of CookieJar, e.g., LWPCookieJar and\n-    FileCookieJar.\n-\n-    Caution: dictionary operations that are normally O(1) may be O(n).\n+    Requests does not use the dict interface internally; it's just for\n+    compatibility with external client code. All `requests` code should work",
      "comment": "Resolved in 101425ebfc747d4c0173fc42e64654c6bcb45fe1.\n",
      "comment_id": 22257484,
      "user": "Lukasa",
      "created_at": "2014-12-24T14:55:22Z",
      "url": "https://github.com/psf/requests/pull/2390#discussion_r22257484"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2390,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -269,21 +273,23 @@ def get_dict(self, domain=None, path=None):\n         return dictionary\n \n     def __getitem__(self, name):\n-        \"\"\"Dict-like __getitem__() for compatibility with client code. Throws exception\n-        if there are more than one cookie with name. In that case, use the more\n-        explicit get() method instead. Caution: operation is O(n), not O(1).\"\"\"\n+        \"\"\"Dict-like __getitem__() for compatibility with client code. Throws\n+        exception if there are more than one cookie with name. In that case,\n+        use the more explicit get() method instead. Caution: operation is O(n),",
      "comment": "Resolved in 101425ebfc747d4c0173fc42e64654c6bcb45fe1.\n",
      "comment_id": 22257486,
      "user": "Lukasa",
      "created_at": "2014-12-24T14:55:27Z",
      "url": "https://github.com/psf/requests/pull/2390#discussion_r22257486"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2390,
      "file_path": "requests/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -313,10 +320,11 @@ def _find(self, name, domain=None, path=None):\n         raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))\n \n     def _find_no_duplicates(self, name, domain=None, path=None):\n-        \"\"\"__get_item__ and get call _find_no_duplicates -- never used in Requests internally.\n-        Takes as args name and optional domain and path. Returns a cookie.value.\n-        Throws KeyError if cookie is not found and CookieConflictError if there are\n-        multiple cookies that match name and optionally domain and path.\"\"\"\n+        \"\"\"__get_item__ and get call _find_no_duplicates -- never used in",
      "comment": "Resolved in 101425ebfc747d4c0173fc42e64654c6bcb45fe1.\n",
      "comment_id": 22257497,
      "user": "Lukasa",
      "created_at": "2014-12-24T14:56:06Z",
      "url": "https://github.com/psf/requests/pull/2390#discussion_r22257497"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2379,
      "file_path": "requests/utils.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,7 +115,7 @@ def get_netrc_auth(url):\n def guess_filename(obj):\n     \"\"\"Tries to guess the filename of the given object.\"\"\"\n     name = getattr(obj, 'name', None)\n-    if name and name[0] != '<' and name[-1] != '>':\n+    if isinstance(name, type('')) and name[0] != '<' and name[-1] != '>':",
      "comment": "We have a name for this either in this module or in `requests/compat.py` called `builtin_str`. Please use that instead.\n",
      "comment_id": 21753687,
      "user": "sigmavirus24",
      "created_at": "2014-12-12T16:10:50Z",
      "url": "https://github.com/psf/requests/pull/2379#discussion_r21753687"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2375,
      "file_path": "requests/packages/__init__.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,3 +1,80 @@\n+\"\"\"\n+pip._vendor is for vendoring dependencies of pip to prevent needing pip to\n+depend on something external.\n+\n+Files inside of pip._vendor should be considered immutable and should only be\n+updated to versions from upstream.\n+\"\"\"\n from __future__ import absolute_import\n \n-from . import urllib3\n+import sys\n+\n+\n+class VendorAlias(object):\n+\n+    def __init__(self):\n+        self._vendor_name = __name__\n+        self._vendor_pkg = self._vendor_name + \".\"\n+\n+    def find_module(self, fullname, path=None):\n+        if fullname.startswith(self._vendor_pkg):\n+            return self\n+\n+    def load_module(self, name):\n+        # Ensure that this only works for the vendored name\n+        if not name.startswith(self._vendor_pkg):\n+            raise ImportError(\n+                \"Cannot import %s, must be a subpackage of '%s'.\" % (\n+                    name, self._vendor_name,\n+                )\n+            )\n+\n+        # Check to see if we already have this item in sys.modules, if we do\n+        # then simply return that.\n+        if name in sys.modules:\n+            return sys.modules[name]\n+\n+        # Check to see if we can import the vendor name\n+        try:\n+            # We do this dance here because we want to try and import this\n+            # module without hitting a recursion error because of a bunch of\n+            # VendorAlias instances on sys.meta_path\n+            real_meta_path = sys.meta_path[:]\n+            try:\n+                sys.meta_path = [\n+                    m for m in sys.meta_path\n+                    if not isinstance(m, VendorAlias)\n+                ]\n+                __import__(name)\n+                module = sys.modules[name]\n+            finally:\n+                # Re-add any additions to sys.meta_path that were made while\n+                # during the import we just did, otherwise things like\n+                # pip._vendor.six.moves will fail.",
      "comment": "This comment, too, references pip.  It could be updated to refer to requests instead?\n",
      "comment_id": 21609422,
      "user": "ralphbean",
      "created_at": "2014-12-10T15:22:38Z",
      "url": "https://github.com/psf/requests/pull/2375#discussion_r21609422"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2393,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -1301,6 +1301,28 @@ def test_get_auth_from_url(self):\n         assert username == percent_encoding_test_chars\n         assert password == percent_encoding_test_chars\n \n+    def test_requote_uri_with_unquoted_percents(self):\n+        \"\"\"Ensure we handle unquoted percent signs in redirects.\n+\n+        See: https://github.com/kennethreitz/requests/issues/2356\n+        \"\"\"\n+        from requests.utils import requote_uri\n+        bad_uri = ('http://style.shoedazzle.com/dmg/3AE3B8?dzcode=FBT'\n+                   '&dzcontent=FBT_SDZ_CPM_Q414&pid=112768085&aid=285880402'\n+                   '&cid=0&publisher=%ppublisher=!;&placement=%pplacement=!;')\n+        quoted = ('http://style.shoedazzle.com/dmg/3AE3B8?dzcode=FBT'\n+                  '&dzcontent=FBT_SDZ_CPM_Q414&pid=112768085&aid=285880402&cid'\n+                  '=0&publisher=%25ppublisher=!;&placement=%25pplacement=!;')",
      "comment": "These URIs are massive so it makes it easy to miss what you're actually doing. Can we shorten them to a smaller case?\n",
      "comment_id": 23136046,
      "user": "Lukasa",
      "created_at": "2015-01-18T19:20:40Z",
      "url": "https://github.com/psf/requests/pull/2393#discussion_r23136046"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2413,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -1265,6 +1265,25 @@ def test_get_environ_proxies(self):\n             'http://localhost.localdomain:5000/v1.0/') == {}\n         assert get_environ_proxies('http://www.requests.com/') != {}\n \n+    def test_guess_filename_when_int(self):\n+        from requests.utils import guess_filename\n+        assert None is guess_filename(1)\n+\n+    def test_guess_filename_when_filename_is_an_int(self):\n+        from requests.utils import guess_filename\n+        fake = type('Fake', (object,), {'name': 1})()\n+        assert None is guess_filename(fake)\n+\n+    def test_guess_filename_with_file_like_obj(self):\n+        from requests.utils import guess_filename\n+        fake = type('Fake', (object,), {'name': 'value'})()\n+        assert 'value' == guess_filename(fake)\n+\n+    def test_guess_filename_with_unicode_name(self):\n+        from requests.utils import guess_filename\n+        fake = type('Fake', (object,), {'name': b'value'.decode('utf-8')})()\n+        assert 'value' == guess_filename(fake)",
      "comment": "This should assert type not value, otherwise the test is brittle on Py2.\n",
      "comment_id": 23164665,
      "user": "Lukasa",
      "created_at": "2015-01-19T15:09:28Z",
      "url": "https://github.com/psf/requests/pull/2413#discussion_r23164665"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2413,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -1265,6 +1265,25 @@ def test_get_environ_proxies(self):\n             'http://localhost.localdomain:5000/v1.0/') == {}\n         assert get_environ_proxies('http://www.requests.com/') != {}\n \n+    def test_guess_filename_when_int(self):\n+        from requests.utils import guess_filename\n+        assert None is guess_filename(1)\n+\n+    def test_guess_filename_when_filename_is_an_int(self):\n+        from requests.utils import guess_filename\n+        fake = type('Fake', (object,), {'name': 1})()\n+        assert None is guess_filename(fake)\n+\n+    def test_guess_filename_with_file_like_obj(self):\n+        from requests.utils import guess_filename\n+        fake = type('Fake', (object,), {'name': 'value'})()\n+        assert 'value' == guess_filename(fake)\n+\n+    def test_guess_filename_with_unicode_name(self):\n+        from requests.utils import guess_filename\n+        fake = type('Fake', (object,), {'name': b'value'.decode('utf-8')})()\n+        assert 'value' == guess_filename(fake)",
      "comment": "I disagree. The test will work just fine on Py2. And we do want to check the value since we want to make sure the name is returned. At the very least we want to make sure it isn't `None`.\n",
      "comment_id": 23165490,
      "user": "sigmavirus24",
      "created_at": "2015-01-19T15:22:10Z",
      "url": "https://github.com/psf/requests/pull/2413#discussion_r23165490"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2413,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -1265,6 +1265,25 @@ def test_get_environ_proxies(self):\n             'http://localhost.localdomain:5000/v1.0/') == {}\n         assert get_environ_proxies('http://www.requests.com/') != {}\n \n+    def test_guess_filename_when_int(self):\n+        from requests.utils import guess_filename\n+        assert None is guess_filename(1)\n+\n+    def test_guess_filename_when_filename_is_an_int(self):\n+        from requests.utils import guess_filename\n+        fake = type('Fake', (object,), {'name': 1})()\n+        assert None is guess_filename(fake)\n+\n+    def test_guess_filename_with_file_like_obj(self):\n+        from requests.utils import guess_filename\n+        fake = type('Fake', (object,), {'name': 'value'})()\n+        assert 'value' == guess_filename(fake)\n+\n+    def test_guess_filename_with_unicode_name(self):\n+        from requests.utils import guess_filename\n+        fake = type('Fake', (object,), {'name': b'value'.decode('utf-8')})()\n+        assert 'value' == guess_filename(fake)",
      "comment": "The test will work fine on Py2, it just won't prove anything because of the implicit string type conversion. The test fundamentally asks a different question on each platform. On Python 3, it will say \"does guess_filename return a unicode string with the value 'value'\", whereas on Python 2 it will say \"does guess_filename return any string that can be coerced to 'value'\".\n\nObserve that if this was the function of `guess_filename` it would work fine on Py 2 and fail on Py 3:\n\n``` python\ndef guess_filename(obj):\n    return b'value'\n```\n\nNote that the check against `None` is included in a type check. I'm happy to check the value _as well_, but we need to write a test that Python 2's implicit string conversion doesn't defeat.\n",
      "comment_id": 23167513,
      "user": "Lukasa",
      "created_at": "2015-01-19T15:51:35Z",
      "url": "https://github.com/psf/requests/pull/2413#discussion_r23167513"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2436,
      "file_path": "test_requests.py",
      "line": 312,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,11 +301,13 @@ def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self):\n         r = s.get(url)\n         assert r.status_code == 200\n \n-    def test_connection_error(self):\n+    def test_connection_error_invalid_domain(self):\n         \"\"\"Connecting to an unknown domain should raise a ConnectionError\"\"\"\n         with pytest.raises(ConnectionError):\n-            requests.get(\"http://fooobarbangbazbing.httpbin.org\")\n+            requests.get(\"http://doesnotexist.google.com\")\n \n+    def test_connection_error_invalid_port(self):\n+        \"\"\"Connecting to an invalid port should raise a ConnectionError\"\"\"\n         with pytest.raises(ConnectionError):\n             requests.get(\"http://httpbin.org:1\")",
      "comment": "Huh. This line hangs on my machine and I'm pretty sure I wrote this test. Maybe your local machine is sending back a TCP RST, mine isn't\n",
      "comment_id": 23981147,
      "user": "kevinburke",
      "created_at": "2015-02-03T03:51:55Z",
      "url": "https://github.com/psf/requests/pull/2436#discussion_r23981147"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2436,
      "file_path": "test_requests.py",
      "line": 312,
      "side": "RIGHT",
      "diff_hunk": "@@ -301,11 +301,13 @@ def test_BASICAUTH_TUPLE_HTTP_200_OK_GET(self):\n         r = s.get(url)\n         assert r.status_code == 200\n \n-    def test_connection_error(self):\n+    def test_connection_error_invalid_domain(self):\n         \"\"\"Connecting to an unknown domain should raise a ConnectionError\"\"\"\n         with pytest.raises(ConnectionError):\n-            requests.get(\"http://fooobarbangbazbing.httpbin.org\")\n+            requests.get(\"http://doesnotexist.google.com\")\n \n+    def test_connection_error_invalid_port(self):\n+        \"\"\"Connecting to an invalid port should raise a ConnectionError\"\"\"\n         with pytest.raises(ConnectionError):\n             requests.get(\"http://httpbin.org:1\")",
      "comment": "@kevinburke i will make another PR today which will fix the hang.   (i didn't notice the hang last night on my windows machine, but i do have it on my ubuntu machine.)   cheers.\n",
      "comment_id": 24001271,
      "user": "colindickson",
      "created_at": "2015-02-03T12:55:16Z",
      "url": "https://github.com/psf/requests/pull/2436#discussion_r24001271"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2468,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -935,6 +935,19 @@ def test_can_send_nonstring_objects_with_files(self):\n \n         assert 'multipart/form-data' in p.headers['Content-Type']\n \n+    def test_can_send_bytes_bytearray_objects_with_files(self):\n+        # Test bytes:\n+        data = {'a': 0.0}",
      "comment": "@Lukasa I thought we expected all data to be bytes/string and were generally against coercing int, float, etc.?\n",
      "comment_id": 25694128,
      "user": "sigmavirus24",
      "created_at": "2015-03-03T15:10:27Z",
      "url": "https://github.com/psf/requests/pull/2468#discussion_r25694128"
    },
    {
      "repo": "psf/requests",
      "pr_number": 2468,
      "file_path": "test_requests.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -935,6 +935,19 @@ def test_can_send_nonstring_objects_with_files(self):\n \n         assert 'multipart/form-data' in p.headers['Content-Type']\n \n+    def test_can_send_bytes_bytearray_objects_with_files(self):\n+        # Test bytes:\n+        data = {'a': 0.0}",
      "comment": "Good point, can you change this to not be a float @scholer?\n",
      "comment_id": 25705344,
      "user": "Lukasa",
      "created_at": "2015-03-03T17:08:47Z",
      "url": "https://github.com/psf/requests/pull/2468#discussion_r25705344"
    }
  ]
}