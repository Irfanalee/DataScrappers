{
  "repo": "tiangolo/sqlmodel",
  "scraped_at": "2026-02-03T10:52:17.032090",
  "stats": {
    "total_comments": 57,
    "filtered": {
      "no_diff_hunk": 1,
      "too_long": 1,
      "too_short": 16,
      "not_python": 8
    },
    "kept": 31
  },
  "examples": [
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "sqlmodel/_compat.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -221,7 +221,13 @@ def get_field_metadata(field: Any) -> Any:\n         return FakeMetadata()\n \n     def post_init_field_info(field_info: FieldInfo) -> None:\n-        return None\n+        if IS_PYDANTIC_V2:",
      "comment": "This function is declared inside the `if IS_PYDANTIC_V2:` block. So, this condition looks not necessary here.\r\nAm I missing something?",
      "comment_id": 2392413881,
      "user": "YuriiMotov",
      "created_at": "2025-09-30T17:59:10Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2392413881"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "sqlmodel/main.py",
      "line": 445,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,43 +395,65 @@ def Field(\n     schema_extra: Optional[Dict[str, Any]] = None,\n ) -> Any:\n     current_schema_extra = schema_extra or {}\n-    field_info = FieldInfo(\n-        default,\n-        default_factory=default_factory,\n-        alias=alias,\n-        title=title,\n-        description=description,\n-        exclude=exclude,\n-        include=include,\n-        const=const,\n-        gt=gt,\n-        ge=ge,\n-        lt=lt,\n-        le=le,\n-        multiple_of=multiple_of,\n-        max_digits=max_digits,\n-        decimal_places=decimal_places,\n-        min_items=min_items,\n-        max_items=max_items,\n-        unique_items=unique_items,\n-        min_length=min_length,\n-        max_length=max_length,\n-        allow_mutation=allow_mutation,\n-        regex=regex,\n-        discriminator=discriminator,\n-        repr=repr,\n-        primary_key=primary_key,\n-        foreign_key=foreign_key,\n-        ondelete=ondelete,\n-        unique=unique,\n-        nullable=nullable,\n-        index=index,\n-        sa_type=sa_type,\n-        sa_column=sa_column,\n-        sa_column_args=sa_column_args,\n-        sa_column_kwargs=sa_column_kwargs,\n+    field_info_kwargs = {\n+        \"alias\": alias,\n+        \"title\": title,\n+        \"description\": description,\n+        \"exclude\": exclude,\n+        \"include\": include,\n+        \"const\": const,\n+        \"gt\": gt,\n+        \"ge\": ge,\n+        \"lt\": lt,\n+        \"le\": le,\n+        \"multiple_of\": multiple_of,\n+        \"max_digits\": max_digits,\n+        \"decimal_places\": decimal_places,\n+        \"min_items\": min_items,\n+        \"max_items\": max_items,\n+        \"unique_items\": unique_items,\n+        \"min_length\": min_length,\n+        \"max_length\": max_length,\n+        \"allow_mutation\": allow_mutation,\n+        \"regex\": regex,\n+        \"discriminator\": discriminator,\n+        \"repr\": repr,\n+        \"primary_key\": primary_key,\n+        \"foreign_key\": foreign_key,\n+        \"ondelete\": ondelete,\n+        \"unique\": unique,\n+        \"nullable\": nullable,\n+        \"index\": index,\n+        \"sa_type\": sa_type,\n+        \"sa_column\": sa_column,\n+        \"sa_column_args\": sa_column_args,\n+        \"sa_column_kwargs\": sa_column_kwargs,\n         **current_schema_extra,\n-    )\n+    }\n+    if IS_PYDANTIC_V2:\n+        # Add Pydantic v2 specific parameters\n+        field_info_kwargs.update(\n+            {\n+                \"validation_alias\": validation_alias,\n+                \"serialization_alias\": serialization_alias,\n+            }\n+        )\n+        field_info = FieldInfo(\n+            default,\n+            default_factory=default_factory,\n+            **field_info_kwargs,\n+        )",
      "comment": "Looks like we can move this outside of `if..else..` block to avoid duplication",
      "comment_id": 2392422553,
      "user": "YuriiMotov",
      "created_at": "2025-09-30T18:03:12Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2392422553"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "tests/test_aliases.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+from typing import Type, Union\n+\n+import pytest\n+from pydantic import VERSION, BaseModel, ValidationError\n+from pydantic import Field as PField\n+from sqlmodel import Field, SQLModel\n+\n+# -----------------------------------------------------------------------------------\n+# Models\n+\n+\n+class PydanticUser(BaseModel):",
      "comment": "We should think whether we want to keep parameterizing tests with Pydantic models.\r\nInitially I parametrized tests with both, Pydantic and SQLModel models to show the difference in behavior between SQLModel and Pydantic models.\r\n\r\nIf it's useful to keep this parametrization in repo? \ud83e\udd14\r\nTests would be a bit simpler without it, but on the other hand this way we ensure it works the same as with Pydantic model",
      "comment_id": 2392444806,
      "user": "YuriiMotov",
      "created_at": "2025-09-30T18:11:37Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2392444806"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "tests/test_aliases.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+from typing import Type, Union\n+\n+import pytest\n+from pydantic import VERSION, BaseModel, ValidationError\n+from pydantic import Field as PField\n+from sqlmodel import Field, SQLModel\n+\n+# -----------------------------------------------------------------------------------\n+# Models",
      "comment": "We will need to remove unnecessary comments in final version",
      "comment_id": 2392446448,
      "user": "YuriiMotov",
      "created_at": "2025-09-30T18:12:18Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2392446448"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "tests/test_aliases.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+from typing import Type, Union\n+\n+import pytest\n+from pydantic import VERSION, BaseModel, ValidationError\n+from pydantic import Field as PField\n+from sqlmodel import Field, SQLModel\n+\n+# -----------------------------------------------------------------------------------\n+# Models\n+\n+\n+class PydanticUser(BaseModel):\n+    full_name: str = PField(alias=\"fullName\")\n+\n+\n+class SQLModelUser(SQLModel):\n+    full_name: str = Field(alias=\"fullName\")\n+\n+\n+# Models with config (validate_by_name=True)\n+\n+\n+if VERSION.startswith(\"2.\"):\n+\n+    class PydanticUserWithConfig(PydanticUser):\n+        model_config = {\"validate_by_name\": True}\n+\n+    class SQLModelUserWithConfig(SQLModelUser):\n+        model_config = {\"validate_by_name\": True}\n+\n+else:\n+\n+    class PydanticUserWithConfig(PydanticUser):\n+        class Config:\n+            allow_population_by_field_name = True\n+\n+    class SQLModelUserWithConfig(SQLModelUser):\n+        class Config:\n+            allow_population_by_field_name = True\n+\n+\n+# -----------------------------------------------------------------------------------\n+# Tests\n+\n+# Test validate by name\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_create_with_field_name(model: Union[Type[PydanticUser], Type[SQLModelUser]]):\n+    with pytest.raises(ValidationError):\n+        model(full_name=\"Alice\")\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUserWithConfig, SQLModelUserWithConfig])\n+def test_create_with_field_name_with_config(\n+    model: Union[Type[PydanticUserWithConfig], Type[SQLModelUserWithConfig]],\n+):\n+    user = model(full_name=\"Alice\")\n+    assert user.full_name == \"Alice\"\n+\n+\n+# Test validate by alias\n+\n+\n+@pytest.mark.parametrize(\n+    \"model\",\n+    [PydanticUser, SQLModelUser, PydanticUserWithConfig, SQLModelUserWithConfig],\n+)\n+def test_create_with_alias(\n+    model: Union[\n+        Type[PydanticUser],\n+        Type[SQLModelUser],\n+        Type[PydanticUserWithConfig],\n+        Type[SQLModelUserWithConfig],\n+    ],\n+):\n+    user = model(fullName=\"Bob\")  # using alias\n+    assert user.full_name == \"Bob\"\n+\n+\n+# Test validate by name and alias\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUserWithConfig, SQLModelUserWithConfig])\n+def test_create_with_both_prefers_alias(\n+    model: Union[Type[PydanticUserWithConfig], Type[SQLModelUserWithConfig]],\n+):\n+    user = model(full_name=\"IGNORED\", fullName=\"Charlie\")\n+    assert user.full_name == \"Charlie\"  # alias should take precedence\n+\n+\n+# Test serialize\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_dict_default_uses_field_names(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Dana\")\n+    data = user.dict()\n+    assert \"full_name\" in data\n+    assert \"fullName\" not in data\n+    assert data[\"full_name\"] == \"Dana\"\n+\n+\n+# Test serialize by alias\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_dict_default_uses_aliases(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Dana\")\n+    data = user.dict(by_alias=True)\n+    assert \"fullName\" in data\n+    assert \"full_name\" not in data\n+    assert data[\"fullName\"] == \"Dana\"\n+\n+\n+# Test json by alias\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_json_by_alias(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Frank\")\n+    json_data = user.json(by_alias=True)\n+    assert ('\"fullName\":\"Frank\"' in json_data) or ('\"fullName\": \"Frank\"' in json_data)\n+    assert \"full_name\" not in json_data\n+\n+\n+# Pydantic v2 specific models - only define if we're running Pydantic v2\n+if VERSION.startswith(\"2.\"):\n+\n+    class PydanticUserV2(BaseModel):\n+        first_name: str = PField(\n+            validation_alias=\"firstName\", serialization_alias=\"f_name\"\n+        )\n+\n+    class SQLModelUserV2(SQLModel):\n+        first_name: str = Field(\n+            validation_alias=\"firstName\", serialization_alias=\"f_name\"\n+        )\n+else:\n+    # Dummy classes for Pydantic v1 to prevent import errors\n+    PydanticUserV2 = None\n+    SQLModelUserV2 = None\n+\n+\n+@pytest.mark.skipif(\n+    not VERSION.startswith(\"2.\"),\n+    reason=\"validation_alias and serialization_alias are not supported in Pydantic v1\",\n+)",
      "comment": "```suggestion\r\n@needs_pydanticv2\r\n```\r\n\r\nWe should use `@needs_pydanticv2` decorator as [it's usually done](https://github.com/fastapi/sqlmodel/blob/69b20188bdfec20bcda11c2b73be3e3d571047a8/tests/test_annotated_uuid.py#L9) in this code base\r\n```\r\nfrom tests.conftest import needs_pydanticv2\r\n```\r\n",
      "comment_id": 2392454534,
      "user": "YuriiMotov",
      "created_at": "2025-09-30T18:16:14Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2392454534"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "tests/test_aliases.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+from typing import Type, Union\n+\n+import pytest\n+from pydantic import VERSION, BaseModel, ValidationError\n+from pydantic import Field as PField\n+from sqlmodel import Field, SQLModel\n+\n+# -----------------------------------------------------------------------------------\n+# Models\n+\n+\n+class PydanticUser(BaseModel):\n+    full_name: str = PField(alias=\"fullName\")\n+\n+\n+class SQLModelUser(SQLModel):\n+    full_name: str = Field(alias=\"fullName\")\n+\n+\n+# Models with config (validate_by_name=True)\n+\n+\n+if VERSION.startswith(\"2.\"):\n+\n+    class PydanticUserWithConfig(PydanticUser):\n+        model_config = {\"validate_by_name\": True}\n+\n+    class SQLModelUserWithConfig(SQLModelUser):\n+        model_config = {\"validate_by_name\": True}\n+\n+else:\n+\n+    class PydanticUserWithConfig(PydanticUser):\n+        class Config:\n+            allow_population_by_field_name = True\n+\n+    class SQLModelUserWithConfig(SQLModelUser):\n+        class Config:\n+            allow_population_by_field_name = True\n+\n+\n+# -----------------------------------------------------------------------------------\n+# Tests\n+\n+# Test validate by name\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_create_with_field_name(model: Union[Type[PydanticUser], Type[SQLModelUser]]):\n+    with pytest.raises(ValidationError):\n+        model(full_name=\"Alice\")\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUserWithConfig, SQLModelUserWithConfig])\n+def test_create_with_field_name_with_config(\n+    model: Union[Type[PydanticUserWithConfig], Type[SQLModelUserWithConfig]],\n+):\n+    user = model(full_name=\"Alice\")\n+    assert user.full_name == \"Alice\"\n+\n+\n+# Test validate by alias\n+\n+\n+@pytest.mark.parametrize(\n+    \"model\",\n+    [PydanticUser, SQLModelUser, PydanticUserWithConfig, SQLModelUserWithConfig],\n+)\n+def test_create_with_alias(\n+    model: Union[\n+        Type[PydanticUser],\n+        Type[SQLModelUser],\n+        Type[PydanticUserWithConfig],\n+        Type[SQLModelUserWithConfig],\n+    ],\n+):\n+    user = model(fullName=\"Bob\")  # using alias\n+    assert user.full_name == \"Bob\"\n+\n+\n+# Test validate by name and alias\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUserWithConfig, SQLModelUserWithConfig])\n+def test_create_with_both_prefers_alias(\n+    model: Union[Type[PydanticUserWithConfig], Type[SQLModelUserWithConfig]],\n+):\n+    user = model(full_name=\"IGNORED\", fullName=\"Charlie\")\n+    assert user.full_name == \"Charlie\"  # alias should take precedence\n+\n+\n+# Test serialize\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_dict_default_uses_field_names(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Dana\")\n+    data = user.dict()\n+    assert \"full_name\" in data\n+    assert \"fullName\" not in data\n+    assert data[\"full_name\"] == \"Dana\"\n+\n+\n+# Test serialize by alias\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_dict_default_uses_aliases(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Dana\")\n+    data = user.dict(by_alias=True)\n+    assert \"fullName\" in data\n+    assert \"full_name\" not in data\n+    assert data[\"fullName\"] == \"Dana\"\n+\n+\n+# Test json by alias\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_json_by_alias(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Frank\")\n+    json_data = user.json(by_alias=True)\n+    assert ('\"fullName\":\"Frank\"' in json_data) or ('\"fullName\": \"Frank\"' in json_data)\n+    assert \"full_name\" not in json_data\n+\n+\n+# Pydantic v2 specific models - only define if we're running Pydantic v2\n+if VERSION.startswith(\"2.\"):\n+\n+    class PydanticUserV2(BaseModel):\n+        first_name: str = PField(\n+            validation_alias=\"firstName\", serialization_alias=\"f_name\"\n+        )\n+\n+    class SQLModelUserV2(SQLModel):\n+        first_name: str = Field(\n+            validation_alias=\"firstName\", serialization_alias=\"f_name\"\n+        )\n+else:\n+    # Dummy classes for Pydantic v1 to prevent import errors\n+    PydanticUserV2 = None\n+    SQLModelUserV2 = None",
      "comment": "We also need to test the logic with `RuntimeError` for Pydantic V1\r\n\r\n```py\r\n        if validation_alias:\r\n            raise RuntimeError(\"validation_alias is not supported in Pydantic v1\")\r\n        if serialization_alias:\r\n            raise RuntimeError(\"serialization_alias is not supported in Pydantic v1\")\r\n```",
      "comment_id": 2392464519,
      "user": "YuriiMotov",
      "created_at": "2025-09-30T18:21:10Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2392464519"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "sqlmodel/main.py",
      "line": 218,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,6 +215,8 @@ def Field(\n     *,\n     default_factory: Optional[NoArgAnyCallable] = None,\n     alias: Optional[str] = None,\n+    validation_alias: Optional[str] = None,",
      "comment": "Pydantic's `validation_alias` type annotation is wider (`validation_alias: str | AliasPath | AliasChoices | None`), but I think it's fine if we only support `str` for now and extend it later",
      "comment_id": 2392474638,
      "user": "YuriiMotov",
      "created_at": "2025-09-30T18:26:07Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2392474638"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "sqlmodel/_compat.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -221,7 +221,13 @@ def get_field_metadata(field: Any) -> Any:\n         return FakeMetadata()\n \n     def post_init_field_info(field_info: FieldInfo) -> None:\n-        return None\n+        if IS_PYDANTIC_V2:",
      "comment": "Added for backward compatibility with Pydantic v1.\nWithout this, Pydantic tests v1 would fail.\n\n",
      "comment_id": 2392903040,
      "user": "ravishan16",
      "created_at": "2025-09-30T21:46:55Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2392903040"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "sqlmodel/main.py",
      "line": 445,
      "side": "RIGHT",
      "diff_hunk": "@@ -387,43 +395,65 @@ def Field(\n     schema_extra: Optional[Dict[str, Any]] = None,\n ) -> Any:\n     current_schema_extra = schema_extra or {}\n-    field_info = FieldInfo(\n-        default,\n-        default_factory=default_factory,\n-        alias=alias,\n-        title=title,\n-        description=description,\n-        exclude=exclude,\n-        include=include,\n-        const=const,\n-        gt=gt,\n-        ge=ge,\n-        lt=lt,\n-        le=le,\n-        multiple_of=multiple_of,\n-        max_digits=max_digits,\n-        decimal_places=decimal_places,\n-        min_items=min_items,\n-        max_items=max_items,\n-        unique_items=unique_items,\n-        min_length=min_length,\n-        max_length=max_length,\n-        allow_mutation=allow_mutation,\n-        regex=regex,\n-        discriminator=discriminator,\n-        repr=repr,\n-        primary_key=primary_key,\n-        foreign_key=foreign_key,\n-        ondelete=ondelete,\n-        unique=unique,\n-        nullable=nullable,\n-        index=index,\n-        sa_type=sa_type,\n-        sa_column=sa_column,\n-        sa_column_args=sa_column_args,\n-        sa_column_kwargs=sa_column_kwargs,\n+    field_info_kwargs = {\n+        \"alias\": alias,\n+        \"title\": title,\n+        \"description\": description,\n+        \"exclude\": exclude,\n+        \"include\": include,\n+        \"const\": const,\n+        \"gt\": gt,\n+        \"ge\": ge,\n+        \"lt\": lt,\n+        \"le\": le,\n+        \"multiple_of\": multiple_of,\n+        \"max_digits\": max_digits,\n+        \"decimal_places\": decimal_places,\n+        \"min_items\": min_items,\n+        \"max_items\": max_items,\n+        \"unique_items\": unique_items,\n+        \"min_length\": min_length,\n+        \"max_length\": max_length,\n+        \"allow_mutation\": allow_mutation,\n+        \"regex\": regex,\n+        \"discriminator\": discriminator,\n+        \"repr\": repr,\n+        \"primary_key\": primary_key,\n+        \"foreign_key\": foreign_key,\n+        \"ondelete\": ondelete,\n+        \"unique\": unique,\n+        \"nullable\": nullable,\n+        \"index\": index,\n+        \"sa_type\": sa_type,\n+        \"sa_column\": sa_column,\n+        \"sa_column_args\": sa_column_args,\n+        \"sa_column_kwargs\": sa_column_kwargs,\n         **current_schema_extra,\n-    )\n+    }\n+    if IS_PYDANTIC_V2:\n+        # Add Pydantic v2 specific parameters\n+        field_info_kwargs.update(\n+            {\n+                \"validation_alias\": validation_alias,\n+                \"serialization_alias\": serialization_alias,\n+            }\n+        )\n+        field_info = FieldInfo(\n+            default,\n+            default_factory=default_factory,\n+            **field_info_kwargs,\n+        )",
      "comment": "Good catch! I've fixed this by moving it outside the if/else block to avoid duplication.",
      "comment_id": 2392937768,
      "user": "ravishan16",
      "created_at": "2025-09-30T22:10:10Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2392937768"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "tests/test_aliases.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,176 @@\n+from typing import Type, Union\n+\n+import pytest\n+from pydantic import VERSION, BaseModel, ValidationError\n+from pydantic import Field as PField\n+from sqlmodel import Field, SQLModel\n+\n+# -----------------------------------------------------------------------------------\n+# Models\n+\n+\n+class PydanticUser(BaseModel):",
      "comment": "Personally, I think it\u2019s useful to keep the parametrization for now, since it acts as a kind of integration test between the two libraries.",
      "comment_id": 2393050952,
      "user": "ravishan16",
      "created_at": "2025-09-30T23:26:05Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2393050952"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "sqlmodel/_compat.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -221,7 +221,13 @@ def get_field_metadata(field: Any) -> Any:\n         return FakeMetadata()\n \n     def post_init_field_info(field_info: FieldInfo) -> None:\n-        return None\n+        if IS_PYDANTIC_V2:",
      "comment": "I just checked it with Python 3.11 and Pydantic 1.10.22 - tests passed.\r\nCould you please check it one more time?\r\n```py\r\n    def post_init_field_info(field_info: FieldInfo) -> None:\r\n        if field_info.alias and not field_info.validation_alias:\r\n            field_info.validation_alias = field_info.alias\r\n        if field_info.alias and not field_info.serialization_alias:\r\n            field_info.serialization_alias = field_info.alias\r\n```",
      "comment_id": 2405320135,
      "user": "YuriiMotov",
      "created_at": "2025-10-06T08:27:43Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2405320135"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "tests/test_aliases.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,178 @@\n+from typing import Type, Union\n+\n+import pytest\n+from pydantic import VERSION, BaseModel, ValidationError\n+from pydantic import Field as PField\n+from sqlmodel import Field, SQLModel\n+\n+from tests.conftest import needs_pydanticv2\n+\n+\"\"\"\n+Alias tests for SQLModel and Pydantic compatibility\n+\"\"\"\n+\n+\n+class PydanticUser(BaseModel):\n+    full_name: str = PField(alias=\"fullName\")\n+\n+\n+class SQLModelUser(SQLModel):\n+    full_name: str = Field(alias=\"fullName\")\n+\n+\n+# Models with config (validate_by_name=True)\n+\n+\n+if VERSION.startswith(\"2.\"):\n+\n+    class PydanticUserWithConfig(PydanticUser):\n+        model_config = {\"validate_by_name\": True}\n+\n+    class SQLModelUserWithConfig(SQLModelUser):\n+        model_config = {\"validate_by_name\": True}\n+\n+else:\n+\n+    class PydanticUserWithConfig(PydanticUser):\n+        class Config:\n+            allow_population_by_field_name = True\n+\n+    class SQLModelUserWithConfig(SQLModelUser):\n+        class Config:\n+            allow_population_by_field_name = True\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_create_with_field_name(model: Union[Type[PydanticUser], Type[SQLModelUser]]):\n+    with pytest.raises(ValidationError):\n+        model(full_name=\"Alice\")\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUserWithConfig, SQLModelUserWithConfig])\n+def test_create_with_field_name_with_config(\n+    model: Union[Type[PydanticUserWithConfig], Type[SQLModelUserWithConfig]],\n+):\n+    user = model(full_name=\"Alice\")\n+    assert user.full_name == \"Alice\"\n+\n+\n+@pytest.mark.parametrize(\n+    \"model\",\n+    [PydanticUser, SQLModelUser, PydanticUserWithConfig, SQLModelUserWithConfig],\n+)\n+def test_create_with_alias(\n+    model: Union[\n+        Type[PydanticUser],\n+        Type[SQLModelUser],\n+        Type[PydanticUserWithConfig],\n+        Type[SQLModelUserWithConfig],\n+    ],\n+):\n+    user = model(fullName=\"Bob\")  # using alias\n+    assert user.full_name == \"Bob\"\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUserWithConfig, SQLModelUserWithConfig])\n+def test_create_with_both_prefers_alias(\n+    model: Union[Type[PydanticUserWithConfig], Type[SQLModelUserWithConfig]],\n+):\n+    user = model(full_name=\"IGNORED\", fullName=\"Charlie\")\n+    assert user.full_name == \"Charlie\"  # alias should take precedence\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_dict_default_uses_field_names(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Dana\")\n+    if VERSION.startswith(\"2.\"):\n+        data = user.model_dump()\n+    else:\n+        data = user.dict()\n+    assert \"full_name\" in data\n+    assert \"fullName\" not in data\n+    assert data[\"full_name\"] == \"Dana\"\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_dict_default_uses_aliases(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Dana\")\n+    if VERSION.startswith(\"2.\"):\n+        data = user.model_dump(by_alias=True)\n+    else:\n+        data = user.dict(by_alias=True)\n+    assert \"fullName\" in data\n+    assert \"full_name\" not in data\n+    assert data[\"fullName\"] == \"Dana\"\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_json_by_alias(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Frank\")\n+    if VERSION.startswith(\"2.\"):\n+        json_data = user.model_dump_json(by_alias=True)\n+    else:\n+        json_data = user.json(by_alias=True)\n+    assert ('\"fullName\":\"Frank\"' in json_data) or ('\"fullName\": \"Frank\"' in json_data)\n+    assert \"full_name\" not in json_data\n+\n+\n+if VERSION.startswith(\"2.\"):\n+\n+    class PydanticUserV2(BaseModel):\n+        first_name: str = PField(\n+            validation_alias=\"firstName\", serialization_alias=\"f_name\"\n+        )\n+\n+    class SQLModelUserV2(SQLModel):\n+        first_name: str = Field(\n+            validation_alias=\"firstName\", serialization_alias=\"f_name\"\n+        )\n+else:\n+    # Dummy classes for Pydantic v1 to prevent import errors\n+    PydanticUserV2 = None\n+    SQLModelUserV2 = None\n+\n+\n+def test_validation_alias_runtimeerror_pydantic_v1():\n+    if VERSION.startswith(\"2.\"):\n+        pytest.skip(\"Only relevant for Pydantic v1\")\n+    with pytest.raises(\n+        RuntimeError, match=\"validation_alias is not supported in Pydantic v1\"\n+    ):\n+        Field(validation_alias=\"foo\")\n+\n+\n+def test_serialization_alias_runtimeerror_pydantic_v1():\n+    if VERSION.startswith(\"2.\"):\n+        pytest.skip(\"Only relevant for Pydantic v1\")",
      "comment": "```suggestion\r\n@needs_pydanticv1\r\ndef test_serialization_alias_runtimeerror_pydantic_v1():\r\n```",
      "comment_id": 2405353223,
      "user": "YuriiMotov",
      "created_at": "2025-10-06T08:40:39Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2405353223"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "tests/test_aliases.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,178 @@\n+from typing import Type, Union\n+\n+import pytest\n+from pydantic import VERSION, BaseModel, ValidationError\n+from pydantic import Field as PField\n+from sqlmodel import Field, SQLModel\n+\n+from tests.conftest import needs_pydanticv2\n+\n+\"\"\"\n+Alias tests for SQLModel and Pydantic compatibility\n+\"\"\"\n+\n+\n+class PydanticUser(BaseModel):\n+    full_name: str = PField(alias=\"fullName\")\n+\n+\n+class SQLModelUser(SQLModel):\n+    full_name: str = Field(alias=\"fullName\")\n+\n+\n+# Models with config (validate_by_name=True)\n+\n+\n+if VERSION.startswith(\"2.\"):\n+\n+    class PydanticUserWithConfig(PydanticUser):\n+        model_config = {\"validate_by_name\": True}\n+\n+    class SQLModelUserWithConfig(SQLModelUser):\n+        model_config = {\"validate_by_name\": True}\n+\n+else:\n+\n+    class PydanticUserWithConfig(PydanticUser):\n+        class Config:\n+            allow_population_by_field_name = True\n+\n+    class SQLModelUserWithConfig(SQLModelUser):\n+        class Config:\n+            allow_population_by_field_name = True\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_create_with_field_name(model: Union[Type[PydanticUser], Type[SQLModelUser]]):\n+    with pytest.raises(ValidationError):\n+        model(full_name=\"Alice\")\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUserWithConfig, SQLModelUserWithConfig])\n+def test_create_with_field_name_with_config(\n+    model: Union[Type[PydanticUserWithConfig], Type[SQLModelUserWithConfig]],\n+):\n+    user = model(full_name=\"Alice\")\n+    assert user.full_name == \"Alice\"\n+\n+\n+@pytest.mark.parametrize(\n+    \"model\",\n+    [PydanticUser, SQLModelUser, PydanticUserWithConfig, SQLModelUserWithConfig],\n+)\n+def test_create_with_alias(\n+    model: Union[\n+        Type[PydanticUser],\n+        Type[SQLModelUser],\n+        Type[PydanticUserWithConfig],\n+        Type[SQLModelUserWithConfig],\n+    ],\n+):\n+    user = model(fullName=\"Bob\")  # using alias\n+    assert user.full_name == \"Bob\"\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUserWithConfig, SQLModelUserWithConfig])\n+def test_create_with_both_prefers_alias(\n+    model: Union[Type[PydanticUserWithConfig], Type[SQLModelUserWithConfig]],\n+):\n+    user = model(full_name=\"IGNORED\", fullName=\"Charlie\")\n+    assert user.full_name == \"Charlie\"  # alias should take precedence\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_dict_default_uses_field_names(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Dana\")\n+    if VERSION.startswith(\"2.\"):\n+        data = user.model_dump()\n+    else:\n+        data = user.dict()\n+    assert \"full_name\" in data\n+    assert \"fullName\" not in data\n+    assert data[\"full_name\"] == \"Dana\"\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_dict_default_uses_aliases(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Dana\")\n+    if VERSION.startswith(\"2.\"):\n+        data = user.model_dump(by_alias=True)\n+    else:\n+        data = user.dict(by_alias=True)\n+    assert \"fullName\" in data\n+    assert \"full_name\" not in data\n+    assert data[\"fullName\"] == \"Dana\"\n+\n+\n+@pytest.mark.parametrize(\"model\", [PydanticUser, SQLModelUser])\n+def test_json_by_alias(\n+    model: Union[Type[PydanticUser], Type[SQLModelUser]],\n+):\n+    user = model(fullName=\"Frank\")\n+    if VERSION.startswith(\"2.\"):\n+        json_data = user.model_dump_json(by_alias=True)\n+    else:\n+        json_data = user.json(by_alias=True)\n+    assert ('\"fullName\":\"Frank\"' in json_data) or ('\"fullName\": \"Frank\"' in json_data)\n+    assert \"full_name\" not in json_data\n+\n+\n+if VERSION.startswith(\"2.\"):\n+\n+    class PydanticUserV2(BaseModel):\n+        first_name: str = PField(\n+            validation_alias=\"firstName\", serialization_alias=\"f_name\"\n+        )\n+\n+    class SQLModelUserV2(SQLModel):\n+        first_name: str = Field(\n+            validation_alias=\"firstName\", serialization_alias=\"f_name\"\n+        )\n+else:\n+    # Dummy classes for Pydantic v1 to prevent import errors\n+    PydanticUserV2 = None\n+    SQLModelUserV2 = None\n+\n+\n+def test_validation_alias_runtimeerror_pydantic_v1():\n+    if VERSION.startswith(\"2.\"):\n+        pytest.skip(\"Only relevant for Pydantic v1\")",
      "comment": "```suggestion\r\n@needs_pydanticv1\r\ndef test_validation_alias_runtimeerror_pydantic_v1():\r\n```",
      "comment_id": 2405354804,
      "user": "YuriiMotov",
      "created_at": "2025-10-06T08:41:19Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2405354804"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "tests/test_aliases.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,178 @@\n+from typing import Type, Union\n+\n+import pytest\n+from pydantic import VERSION, BaseModel, ValidationError\n+from pydantic import Field as PField\n+from sqlmodel import Field, SQLModel\n+\n+from tests.conftest import needs_pydanticv2",
      "comment": "```suggestion\r\nfrom tests.conftest import needs_pydanticv1, needs_pydanticv2\r\n```",
      "comment_id": 2405458711,
      "user": "YuriiMotov",
      "created_at": "2025-10-06T09:20:17Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2405458711"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1577,
      "file_path": "sqlmodel/_compat.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -221,7 +221,13 @@ def get_field_metadata(field: Any) -> Any:\n         return FakeMetadata()\n \n     def post_init_field_info(field_info: FieldInfo) -> None:\n-        return None\n+        if IS_PYDANTIC_V2:",
      "comment": "You are right. I checked and tests passed. Thanks.",
      "comment_id": 2415362542,
      "user": "ravishan16",
      "created_at": "2025-10-09T01:42:32Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1577#discussion_r2415362542"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 997,
      "file_path": "tests/test_update.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+from sqlmodel import Field, SQLModel, create_engine",
      "comment": "```suggestion\r\nfrom sqlmodel import Field, SQLModel\r\n```",
      "comment_id": 2292048896,
      "user": "YuriiMotov",
      "created_at": "2025-08-21T20:17:51Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/997#discussion_r2292048896"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 997,
      "file_path": "tests/test_update.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+from sqlmodel import Field, SQLModel, create_engine\n+\n+\n+def test_sqlmodel_update():\n+    class Organization(SQLModel, table=True):\n+        id: int = Field(default=None, primary_key=True)\n+        name: str\n+        headquarters: str\n+\n+    class OrganizationUpdate(SQLModel):\n+        name: str\n+\n+    engine = create_engine(\"sqlite:///\", echo=True)\n+    SQLModel.metadata.create_all(engine)",
      "comment": "```suggestion\r\n```\r\n\r\nWe don't need this for this test",
      "comment_id": 2292050955,
      "user": "YuriiMotov",
      "created_at": "2025-08-21T20:18:52Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/997#discussion_r2292050955"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1560,
      "file_path": "sqlmodel/_compat.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +123,7 @@ def init_pydantic_private_attrs(new_object: InstanceOrType[\"SQLModel\"]) -> None:\n         object.__setattr__(new_object, \"__pydantic_private__\", None)\n \n     def get_annotations(class_dict: Dict[str, Any]) -> Dict[str, Any]:\n-        return class_dict.get(\"__annotations__\", {})\n+        return class_dict.get(\"__annotations__\", {})  # type: ignore[no-any-return]",
      "comment": "As on L425, where we're already ignoring it, the error is \r\n> Returning Any from function declared to return \"dict[str, Any]\"  [no-any-return]\r\n",
      "comment_id": 2352561220,
      "user": "svlandeg",
      "created_at": "2025-09-16T13:41:07Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1560#discussion_r2352561220"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1578,
      "file_path": "sqlmodel/_compat.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +124,20 @@ def init_pydantic_private_attrs(new_object: InstanceOrType[\"SQLModel\"]) -> None:\n         object.__setattr__(new_object, \"__pydantic_private__\", None)\n \n     def get_annotations(class_dict: Dict[str, Any]) -> Dict[str, Any]:\n-        return class_dict.get(\"__annotations__\", {})  # type: ignore[no-any-return]\n+        raw_annotations: Dict[str, Any] = class_dict.get(\"__annotations__\", {})",
      "comment": "Note that https://github.com/fastapi/sqlmodel/discussions/1594 proposes an alternative implementation, using `class_dict.get(\"__annotate_func__\")`",
      "comment_id": 2414049442,
      "user": "svlandeg",
      "created_at": "2025-10-08T14:24:35Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1578#discussion_r2414049442"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1307,
      "file_path": "tests/test_select_gen.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,8 +11,8 @@\n @needs_py39\n def test_select_gen() -> None:\n     result = subprocess.run(\n-        [sys.executable, \"scripts/generate_select.py\"],\n-        env={\"CHECK_JINJA\": \"1\"},\n+        [sys.executable, Path(\"scripts\") / \"generate_select.py\"],\n+        env={**os.environ, \"CHECK_JINJA\": \"1\"},",
      "comment": "The `env` stuff is basically the same fix as what was done in https://github.com/fastapi/sqlmodel/pull/969, but shortened.\r\n\r\n(we can probably also just keep the current way it's done on `main` - as long as the things in `os.environ` are passed to `env` as well)",
      "comment_id": 2354865365,
      "user": "svlandeg",
      "created_at": "2025-09-17T09:17:42Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1307#discussion_r2354865365"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1340,
      "file_path": "sqlmodel/_compat.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -103,7 +103,14 @@ def set_config_value(\n         model.model_config[parameter] = value  # type: ignore[literal-required]\n \n     def get_model_fields(model: InstanceOrType[BaseModel]) -> Dict[str, \"FieldInfo\"]:\n-        return model.model_fields\n+        # TODO: refactor the usage of this function to always pass the class\n+        # not the instance, and then remove this extra check\n+        # this is for compatibility with Pydantic v3\n+        if isinstance(model, type):\n+            use_model = model\n+        else:\n+            use_model = model.__class__\n+        return use_model.model_fields",
      "comment": "I was checking the error from Pydantic and I saw that they will deprecate accessing the `model_fields` from the instance in Pydantic v3, they should be accessed from the class (which makes sense).\r\n\r\nI updated this logic here to handle that future use case. In a subsequent PR we can refactor the internal usage of this function to only pass the class and not the instance.",
      "comment_id": 2061539455,
      "user": "tiangolo",
      "created_at": "2025-04-26T18:37:04Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1340#discussion_r2061539455"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1340,
      "file_path": "sqlmodel/main.py",
      "line": 480,
      "side": "RIGHT",
      "diff_hunk": "@@ -477,7 +477,7 @@ def Relationship(\n class SQLModelMetaclass(ModelMetaclass, DeclarativeMeta):\n     __sqlmodel_relationships__: Dict[str, RelationshipInfo]\n     model_config: SQLModelConfig\n-    model_fields: Dict[str, FieldInfo]  # type: ignore[assignment]\n+    model_fields: ClassVar[Dict[str, FieldInfo]]",
      "comment": "As the idea is that this should now be only in the class and not instances, I think it's good to type it right away. It won't affect at runtime if people are using it, but will start warning them in their linters, so they can start preparing for this change in Pydantic v3.",
      "comment_id": 2061539665,
      "user": "tiangolo",
      "created_at": "2025-04-26T18:38:09Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1340#discussion_r2061539665"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1340,
      "file_path": "sqlmodel/main.py",
      "line": 842,
      "side": "RIGHT",
      "diff_hunk": "@@ -839,7 +839,7 @@ def __tablename__(cls) -> str:\n         return cls.__name__.lower()\n \n     @classmethod\n-    def model_validate(\n+    def model_validate(  # type: ignore[override]",
      "comment": "I changed this to not use `kwargs` and instead ignore the type here, that way people will keep having autocompletion for the params, and kwargs won't swallow extra / invald params.\r\n\r\nSeeing this, I realize it was probably not the best idea to include the extra `update` here. :thinking: \r\n\r\nAlso, it's probably not needed for most use cases, maybe it would make sense to remove those docs, explain how to extend data to validate an object using just dicts, then deprecate using it, and finally at some point dropping the `update`... \r\n\r\nBut anyway, for now, it probably works to just `# type: ignore` and handle it on our side so that final users get the best developer experience / editor support.",
      "comment_id": 2061540780,
      "user": "tiangolo",
      "created_at": "2025-04-26T18:42:19Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1340#discussion_r2061540780"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1340,
      "file_path": "sqlmodel/main.py",
      "line": 867,
      "side": "RIGHT",
      "diff_hunk": "@@ -863,20 +863,24 @@ def model_dump(\n         mode: Union[Literal[\"json\", \"python\"], str] = \"python\",\n         include: Union[IncEx, None] = None,\n         exclude: Union[IncEx, None] = None,\n-        context: Union[Dict[str, Any], None] = None,\n-        by_alias: bool = False,\n+        context: Union[Any, None] = None,\n+        by_alias: Union[bool, None] = None,",
      "comment": "I like to keep the signature as close to the latest Pydantic, and then do the extra work internally to support the older versions, but this way people can get used to the new syntax and/or use it if they can already upgrade to the latest version.",
      "comment_id": 2061541161,
      "user": "tiangolo",
      "created_at": "2025-04-26T18:43:29Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1340#discussion_r2061541161"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1340,
      "file_path": "sqlmodel/main.py",
      "line": 903,
      "side": "RIGHT",
      "diff_hunk": "@@ -896,7 +900,7 @@ def model_dump(\n             return super().dict(\n                 include=include,\n                 exclude=exclude,\n-                by_alias=by_alias,\n+                by_alias=by_alias or False,",
      "comment": "With this trick, we avoid the type when `by_alias` is `None`. :sweat_smile: ",
      "comment_id": 2061541310,
      "user": "tiangolo",
      "created_at": "2025-04-26T18:44:11Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1340#discussion_r2061541310"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1340,
      "file_path": "sqlmodel/main.py",
      "line": 877,
      "side": "RIGHT",
      "diff_hunk": "@@ -863,20 +863,25 @@ def model_dump(\n         mode: Union[Literal[\"json\", \"python\"], str] = \"python\",\n         include: Union[IncEx, None] = None,\n         exclude: Union[IncEx, None] = None,\n-        context: Union[Dict[str, Any], None] = None,\n-        by_alias: bool = False,\n+        context: Union[Any, None] = None,\n+        by_alias: Union[bool, None] = None,\n         exclude_unset: bool = False,\n         exclude_defaults: bool = False,\n         exclude_none: bool = False,\n         round_trip: bool = False,\n         warnings: Union[bool, Literal[\"none\", \"warn\", \"error\"]] = True,\n+        fallback: Union[Callable[[Any], Any], None] = None,\n         serialize_as_any: bool = False,\n     ) -> Dict[str, Any]:\n+        if PYDANTIC_MINOR_VERSION < (2, 11):\n+            by_alias = by_alias or False",
      "comment": "With this we can handle older Pydantic versions but keep the most recent signature.",
      "comment_id": 2061546410,
      "user": "tiangolo",
      "created_at": "2025-04-26T18:58:36Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1340#discussion_r2061546410"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1255,
      "file_path": "sqlmodel/_compat.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,8 @@\n \n # Reassign variable to make it reexported for mypy\n PYDANTIC_VERSION = P_VERSION\n-IS_PYDANTIC_V2 = PYDANTIC_VERSION.startswith(\"2.\")\n+PYDANTIC_MINOR_VERSION = tuple(int(i) for i in P_VERSION.split(\".\", 2)[:2])",
      "comment": "Yes, this is much cleaner. \r\n\r\nI don't think the `maxsplit` parameter for `split()` makes any difference here, as we're not keeping the patch version part anyway, so I think we could might as well do \r\n```suggestion\r\nPYDANTIC_MINOR_VERSION = tuple(int(i) for i in P_VERSION.split(\".\")[:2])\r\n```\r\n\r\nright?",
      "comment_id": 1963713371,
      "user": "svlandeg",
      "created_at": "2025-02-20T14:50:08Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1255#discussion_r1963713371"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1255,
      "file_path": "sqlmodel/_compat.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,8 @@\n \n # Reassign variable to make it reexported for mypy\n PYDANTIC_VERSION = P_VERSION\n-IS_PYDANTIC_V2 = PYDANTIC_VERSION.startswith(\"2.\")\n+PYDANTIC_MINOR_VERSION = tuple(int(i) for i in P_VERSION.split(\".\", 2)[:2])\n+IS_PYDANTIC_V2 = PYDANTIC_MINOR_VERSION[0] >= 2",
      "comment": "To keep the semantics the same as before, and to avoid confusion of the semantics of this variable in the future when there would be a v3, I suggest to test for equality:\r\n```suggestion\r\nIS_PYDANTIC_V2 = PYDANTIC_MINOR_VERSION[0] == 2\r\n```",
      "comment_id": 1963715064,
      "user": "svlandeg",
      "created_at": "2025-02-20T14:50:55Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1255#discussion_r1963715064"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 1255,
      "file_path": "sqlmodel/_compat.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,8 @@\n \n # Reassign variable to make it reexported for mypy\n PYDANTIC_VERSION = P_VERSION\n-IS_PYDANTIC_V2 = PYDANTIC_VERSION.startswith(\"2.\")\n+PYDANTIC_MINOR_VERSION = tuple(int(i) for i in P_VERSION.split(\".\", 2)[:2])\n+IS_PYDANTIC_V2 = PYDANTIC_MINOR_VERSION[0] >= 2",
      "comment": "@svlandeg I agree that the naming would be confusing with the check `>= 2`. I was thinking more about the idea of this variable: this flag is used to check what API to expect, and in all/most cases, it is expected to check whether the version is 2+ or not, rather than whether it is exactly 2.\r\nAnyways, it's not critical for today, just a thought for the future. Thanks for reviewing the PR!",
      "comment_id": 1986205776,
      "user": "asiunov",
      "created_at": "2025-03-09T03:08:43Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/1255#discussion_r1986205776"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 983,
      "file_path": "sqlmodel/main.py",
      "line": 710,
      "side": "RIGHT",
      "diff_hunk": "@@ -643,7 +704,11 @@ def get_column_from_field(field: Any) -> Column:  # type: ignore\n         unique = False\n     if foreign_key:\n         assert isinstance(foreign_key, str)\n-        args.append(ForeignKey(foreign_key))\n+        foreign_key_obj = ForeignKey(foreign_key)\n+        ondelete = getattr(field_info, \"ondelete\", Undefined)\n+        if isinstance(ondelete, str):\n+            foreign_key_obj.ondelete = ondelete",
      "comment": "Here we could better use the same trick of creating args and kwargs outside before creating the `ForeignKey` object and then create it once with everything. Instead of setting the `foreign_key_obj.ondelete = ondelete` afterwards.\r\n\r\nJust because SQLAlchemy could do some additional magic apart from setting the attribute when instantiating the object. It currently doesn't do anything, but it wouldn't be surprising if it did at some point, so better be safe. :nerd_face: ",
      "comment_id": 1638664752,
      "user": "tiangolo",
      "created_at": "2024-06-13T17:51:31Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/983#discussion_r1638664752"
    },
    {
      "repo": "tiangolo/sqlmodel",
      "pr_number": 983,
      "file_path": "sqlmodel/sql/_relationship_types.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,3 @@\n+from typing_extensions import Literal\n+\n+OnDeleteType = Literal[\"CASCADE\", \"SET NULL\", \"RESTRICT\", \"NO ACTION\"]",
      "comment": "Nice these literals!\r\n\r\nAs this is used in a single place, I'm thinking that maybe this type could be created there in the same `main.py`. As it's not imported anywhere else, and we don't have any other types to put here, at least yet.\r\n\r\nAlso to keep the directory structure as similar to SQLAlchemy's as possible.",
      "comment_id": 1638667721,
      "user": "tiangolo",
      "created_at": "2024-06-13T17:54:13Z",
      "url": "https://github.com/fastapi/sqlmodel/pull/983#discussion_r1638667721"
    }
  ]
}